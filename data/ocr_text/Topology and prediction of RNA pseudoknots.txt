ORIGINAL PAPER

Vol. 27 no. 8 2011, pages 1076-1085
doi: 1 0. 1 093/bioinformatics/btr090

 

Structural bioinformatics

Advance Access publication February 17, 2011

Topology and prediction of RNA pseudoknots

Christian M. Reidys1’2’*, Fenix W. D. Huang‘, Jorgen E. Andersen3, Robert C. Penner3’4,
Peter F. Stadler5’6’7’8’9’1O and Markus E. Nebel11

1Department of Mathematics, Center for Combinatorics, Key Laboratory of Pure Mathematics and Combinatorics —
TianJin key Laboratory of Combinatorics, 2Department of Biology, College of Life Science, Nankai University Tianjin
300071, PR. China, 3Department of Mathematics, Center for Quantum Geometry of Moduli Spaces, Aarhus
University, DK—8000 rhus C, Denmark, 4Department of Mathematics and Physics, California Institute of Technology,
Pasadena, CA 91125, USA, 5Bioinformatics Group, Department of Computer Science, and Interdisciplinary Center
for Bioinformatics, University of Leipzig, H rtelstrasse 16—18, D—04107 Leipzig, 6Max Planck Institute for Mathematics
in the Sciences, Inselstrasse 22, 7RNomics Group, Fraunhofer IZI, Perlickstrasse 1, D—04103 Leipzig, Germany,
8Institut fur Theoretical Chemistry, University of Vienna, W hringerstrasse 17, A—1090 Vienna, Austria, 9Center for
non—coding RNA in Technology and Health, University of Copenhagen, Gronneg rdsvej 3, DK—1870 Frederiksberg,
Denmark, 10The Santa Fe Institute, 1399 Hyde Park Road, Santa Fe, NM 87501, USA and 11Department of
Computer Science, University of Kaiserslautern, Kaiserslautern, Germany

Associate Editor: Anna Tramontano

 

ABSTRACT

Motivation: Several dynamic programming algorithms for predicting
RNA structures with pseudoknots have been proposed that
differ dramatically from one another in the classes of structures
considered.

Results: Here, we use the natural topological classification of RNA
structures in terms of irreducible components that are embeddable
in the surfaces of fixed genus. We add to the conventional
secondary structures four building blocks of genus one in order to
construct certain structures of arbitrarily high genus. A corresponding
unambiguous multiple context-free grammar provides an efficient
dynamic programming approach for energy minimization, partition
function and stochastic sampling. It admits a topology-dependent
parametrization of pseudoknot penalties that increases the sensitivity
and positive predictive value of predicted base pairs by 10—20%
compared with earlier approaches. More general models based on
building blocks of higher genus are also discussed.

Availability: The source code of gfold is freely available at
http://www.combinatorics.cn/cbpc/gfold.tar.gz.

Contact: duck@santafe.edu

Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on October 14, 2010; revised on January 12, 2011;
accepted on February 15, 2011

1 INTRODUCTION

The global conformation of RNA molecules is to a large extent
determined by topological constraints encoded at the level
of secondary structure, i.e. by the mutual arrangements of
the base paired helices (Bailor et al., 2010). In this context,
secondary structure is understood in a wider sense that includes
pseudoknots. Although the vast majority of RNAs has simple,

 

*To whom correspondence should be addressed.

i.e. pseudoknot—free, secondary structure, PseudoBase (Taufer
et al., 2009) lists more than 250 records of pseudoknots determined
by a variety of experimental and computational techniques
including crystallography, nuclear magnetic resonance, mutational
experiments and comparative sequence analysis. In many cases,
they are crucial for molecular function. Examples include the
catalytic cores of several ribozymes (Doudna and Cech, 2002),
programmed frameshifting (Namy et al., 2006) and telomerase
activity (Theimer et al., 2005), reviewed in Giedroc and Cornish
(2009); Staple and Butcher (2005).

Secondary structures can been interpreted as matchings in a graph
of permissible base pairs (Tabaska et al., 1998). The energy of RNA
folding is dominated by the stacking of adjacent base pairs, not by
the hydrogen bonds of the individual base pairs (Mathews et al.,
1999). In contrast to maximum weighted matching, the general
RNA folding problem with a stacking—based energy function is NP—
complete (Akutsu, 2000; Lyngs¢ and Pedersen, 2000). The most
commonly used RNA secondary structure prediction tools, including
mf old (Zuker, 1989) and the Vienna RNA Package (Hofacker
et al., 1994), therefore exclude pseudoknots.

Polynomial—time dynamic programming (DP) algorithms can be
devised, however, for certain restricted classes of pseudoknots. In
contrast to the 0(N2) space and 0(N3) time solution for simple
secondary structures (Nussinov et al., 1978; Waterman, 1978;
Zuker and Stiegler, 1981), however, most of these approaches are
computationally much more demanding. The design of pseudoknot
folding algorithms thus has been governed more by the need to limit
computational cost and achieve a manageable complexity of the
recursion than the conscious choice of a particularly natural search
space of RNA structures. As a case in point, the class of structures
underlying the algorithm by Rivas and Eddy (1999) (R&E—
structures, pknot—R&E) was characterized only in a subsequent
publication (Rivas and Eddy, 2000). The following references
provide a certainly incomplete list of DP approaches to RNA
structure prediction using different structure classes characterized
in terms of recursion equations and/or stochastic grammars: Akutsu

 

1076 © The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com

112 /§JO'SIBUJHOIPJOJXO'SOIlBIHJOJUIOIQ/ﬁdnq 11101; prBOIUAAOG

9IOZ ‘09 lsnﬁnv uo ::

Topology and prediction of RNA pseudoknots

 

(2000); Cai et al. (2003); Chen et al. (2009); Deogun et al. (2004);
Dirks and Pierce (2003); Kato et al. (2006); Li and Zhu (2005);
Lyngs¢ and Pedersen (2000); Matsui et al. (2005); Reeder and
Giegerich (2004); Rivas and Eddy (1999); Uemura Y. et al. (1999).
The interrelationships of some of these classes of RNA structures
have been clariﬁed in part by Condon et al. (2004) and deland
(2006). In addition to these exact algorithms, a plethora of heuristic
approaches to pseudoknot prediction have been proposed in the
literature; see e.g. (Chen, 2008; Metzler and Nebel, 2008) and the
references therein.

At least three distinct classiﬁcation schemes of RNA contact
structures have been proposed: Haslinger and Stadler (1999)
suggested using book—embeddings, Jin et al. (2008) focused on
the maximal set of pairwise crossing base pairs and Bon et al.
(2008) based the classiﬁcation on topological embeddings. While
these classiﬁcations have in common that simple secondary structure
forms the most primitive class of structures, they differ already in
the construction of the ﬁrst non—trivial class of pseudoknots. Despite
their mathematical appeal, however, no efﬁcient (polynomial—time)
algorithms are available for predicting pseudoknotted structures
even in the simplest case of three non—crossing RNA structures.
A practically workable approach to three non—crossing structures
requires the enumeration of an exponentially growing number of
diagrams which are then ‘ﬁlled in’ by the means of DP (Huang et al.,
2009); a Monte—Carlo approach utilizing the topological approach
with a very simple matching—like energy model was explored by
(Vernizzi and Orland, 2005).

In this contribution, we show that the topological classiﬁcation
of RNA structures can be translated into efﬁcient DP algorithms.
To this end, we introduce y—structures and prove that they can be
derived from a ﬁnite family of abstract shapes called shadows. In
Theorem 2.3, we enumerate these four shadows for y: 1, which
can be cast as explicit construction rules for a unique multiple
context—free grammar (Section 2.3). Corresponding DP algorithms
for energy minimization, partition function and Boltzmann—sampling
functionalities are implemented in the software package gf 0 1d. An
important feature is that y—structures can be treated algorithmically
like pseudoknot—free secondary structures in the sense that there are
ﬁnitely many motifs, i.e. shadows, for ﬁxed y, each of which is
assigned a speciﬁc energy. Because of the multiplicity of motifs,
which rapidly increases with y, this allows for a more detailed
energy model of pseudoknotted structures based on their topological
complexity.

2 RESULTS
2.1 Topology of RNA structures

Diagram representation: RNA molecules are linear biopolymers
consisting of the four nucleotides A, U, C and G characterized
by a sequence endowed with a unique orientation (5’ to 3’). Each
nucleotide can interact (base pair) with at most one other nucleotide
by means of speciﬁc hydrogen bonds. Only the Watson—Crick
pairs GC and AU as well as the wobble GU are admissible.
These base pairs determine the secondary structure. Note that we
have neglected here base triples and other types of more complex
interactions. Secondary structures can thus be represented as graphs
where nucleotides are represented by vertices, the backbone of the
molecule as well as the hydrogen bonds are represented by edges; see

517/;
/‘\//J r\
IN /10 «(x
:30 i I'd
l‘i Anti?" 5° “K
x /\*“~ rig—555:1:fo r
</\ \r/Zofr 732’ \v
80’\/J J/./ 60
r\
Jh—.~ j———‘J

'..
II. ..
"....¢
I o- .
111’...
zrﬁn'“"”“i=sisthk
“‘
I A
2);...”...-;;.._.;;J_..U...-;;J_.;;J_..UJ_.;;J_.;;J_.;)JJ;;,_.;1,.”;_._.;;,_..;;_._.;;_._.;;_._U;

i ' to 20 30 40 so 60 7o 80 ' .87

Fig. 1. RNA structure as planar graph represented (a) as ball—and—stick ﬁgure
with short edges for hydrogen bonds and (b) with linear backbone and semi—
circles for hydrogen bonds.

We 4

—_—_—,—_,— —_—_—_P

 

C

Fig. 2. Inﬂation of edges and vertices to ribbons and disks. Here we have four
vertices, ﬁve edges and one boundary component (a, 1;, E, 21, 2,}, g, 713,17). The
corresponding surface has Euler characteristic X = v — e + r = 0 and genus
g: 1, see Equations (2.1) and (2.2).

Figure 1a. More conveniently, we use the convention to represent the
backbone of the polymer by a horizontally drawn chain. As before,
this chain consists of vertices and arcs, respectively, representing the
nucleotides and covalent bonds. However, the edges representing
the base pairs now are depicted as arcs in the upper half plane; see
Figure 1b. We call this representation the diagram of the molecule.

Thus, we shall identify a structure with a labelled graph over
the vertex set [N] = {1, 2, . . . ,N} represented by drawing the vertices
1, 2, ...,N on a horizontal line in the natural order and the arcs (i , j),
where i< j, in the upper half plane.

Fatgraph representation: in order to understand the topological
properties of RNA molecules, we need to pass from the picture of
RNA as diagrams or contact graphs to that of topological surfaces.
Only the associated surface carries the important invariants leading
to a meaningful ﬁltration of RNA structures. Formally, we will view
an RNA molecule as a topological surface (Andersen,J.E. et al.,
submitted for publication). The main idea is to ‘thicken’ the edges
into (untwisted) bands or ribbons and to expand each vertex to a
disk as shown in Figure 2. This inﬂation of edges leads to a fatgraph
D (Loebl and Moffatt, 2008; Penner et al., 2010).

A fatgraph, sometimes also called ‘ribbon graph’ or ‘map’, is a
graph equipped with a cyclic ordering of the incident half edges
at each vertex. Thus, D reﬁnes its underlying graph D insofar
as it encodes the ordering of the ribbons incident on its disks.

 

1077

112 /§JO'SIBUJHOIPJOJXO'SOllBIHJOJUIOIQ/ﬁdnq 11101; prBOIUAAOG

9IOZ ‘09 lsnﬁnv uo ::

C.M.Reidys et aI.

 

 

_ .J_ .r_ J— I— J— J— }— .a'_ J— J—

Fig. 3. Computing the number of boundary components. The diagram
contains 5+9 edges and 10 vertices. We follow the alternating paths
described in the text and observe that there are exactly two boundary
components (bold and thin). According to Equation (2.1), the genus of the
diagram is given by 1— %( 10 —14+2)= 2, see Supplementary Figure S6 for
details.

In the following, we will deal with orientable ribbon graphs.1
Each ribbon has two boundaries. The ﬁrst one in counterclockwise
order is labeled by an arrowhead, (Fig. 2). A D—cycle or D—
boundary component is then constructed by following these directed
boundaries from disk to disk, thereby alternating between base pair
ribbons and backbone, with the exception of the segment of the
boundary component that travels along the bottom of the backbone
using only backbone bonds, as shown in Figures 2 and 3. We give
a brief tutorial on how to compute boundary components in the
Supplementary Figure S6. Topological invariants such as the number
of boundary components of the fatgraph D can thus be computed
directly from the underlying diagram D. Furthermore, fatgraphs can
be succinctly stored and conveniently manipulated on the computer
as pairs of permutations (Penner et al., 2010).

The fatgraph D gives rise to a unique surface X11), and each D—
cycle corresponds to a boundary component of X11), whose Euler
characteristic and genus are given by

x(X]D>) = v—e+r (2.1)
1
20(1)) = 1— Exam), (2.2)

where v,e,r denotes the number of discs, ribbons and boundary
components in D (Massey, 1967). The graph D can readily be
obtained by continuously contracting the ribbons and discs of D.

We next make use of an additional feature of RNA structures,
namely that the backbone forms a unique oriented chain determined
by the covalent bonds. Thus, the backbone can be collapsed to a
single disk since the surface is orientable: in the absence of twisted
ribbons, there is no particular information in the backbone itself.
Indeed, the procedure can be undone by reinﬂating the disk and
rebuilding the backbone. The contraction of the N vertices to a
single one and the removal of the (N — 1) covalent bonds therefore
preserves the Euler characteristic and genus, (Fig. 4).

Using the collapsed fatgraph,2 we see that the relation between
the genus of the surface and the number of boundary components is
determined by the number of arcs in the upper half plane, namely,

2—2g—r=1—n, (2.3)

 

1Ribbons may also be allowed to twist giving rise to possibly non—orientable
surfaces (Massey, 1967).

2In order to relate this to the standard 2D models of surfaces derived from
triangulations: from the collapsed fatgraph we can derive the polygonal
model of the surface X113), i.e. a 2n—gon in which edges are identiﬁed in pairs;
(Fig. 4).

 

 

 

Fig. 4. Reduction to fatgraphs with a single vertex. Contracting the backbone
of a diagram into a single vertex decreases the length of the boundary
components and preserves the genus. The contracted fatgraph is equivalent
to the labeled directed cycle. The backbone of the polymer can be recovered
by reinﬂating the disk into the backbone. The polygon (r.h.s.) represents the
standard 2D model of a surface as discussed in Massey (1967).

- J - . . . . . . . . . F . . F l I . ————————.—

Fig. 5. The shadow of a diagram is obtained by removing all non—crossing
arcs and isolated vertices and collapsing all resulting stacks into single
arcs. While taking shadows is a signiﬁcant reduction, the key topological
invariants of genus and number of boundary components remain invariant.

where n is number of base pairs and r the number of boundary
components. The latter can be computed easily and therefore
controls the genus of the molecules. Equation (2.3) follows from
Equations (2.2) and (2.1), which together yield 2—2g—r=v—e,
and the observation that the contracted graph has e=n arcs and a
single (12:1) vertex.

2.2 y-structures

The shadow of a diagram (RNA structure) is obtained by removing
all non—crossing arcs, collapsing all isolated vertices and replacing
all remaining stacks (i.e. adjacent parallel arcs) by single arcs
(Fig. 5). Shadows can be seen as a generalization of shape
abstractions (Giegerich et al., 2004) to pseudoknotted structures
(Reidys and Wang, 2010). Similar to the process of contracting
the backbone into a single vertex, the projection into a shadow
changes neither genus nor the number of boundary components
(Andersen,J.E. et al., submitted for publication). However, all
information on stack lengths and non—crossing components of the
structure is lost in the process . We shall see that the set of structures
with shadow 6 can nevertheless be reconstructed efﬁciently. To this
end we will show that, for ﬁxed genus g, there are only ﬁnitely many
distinct shadows Sg, which will play a central role in constructing
folding algorithms.

A diagram is irreducible (or connected) (Kleitman, 1970) if for
any two arcs there is a sequence of arcs so that consecutive arcs
cross one other. A shadow is not necessarily irreducible but may
be composed of multiple irreducible components or blocks, see
(1) of Figure 6. Any shadow (and in general, any diagram) can be
decomposed iteratively by removing irreducible components from
bottom to top, i.e. so that that there is no component ‘inside’ the one
just removed. Note that the set 16 of irreducible components of the
set of shadows, 6(5), equals the set of shadows of the irreducible
components of the diagram S. Furthermore, the genus of 6(5) is the

 

1 078

112 /§JO'S[BUJHOIPJOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

Topology and prediction of RNA pseudoknots

 

r R is m
(1) (2)

Fig. 6. y—structures: we display the shadow of a 1—structure (1) having
topological genus 2 and the shadow of the HDV—structure (2) (Ferre—
D’Amare’ et al., 1998), a 2—structure having also genus two. Although both
shadows have genus two, the HDV—structure cannot be generated iteratively
via successive removals of 51—elements and stacked arcs. The structure
displayed on the left is derived via two 51—substructures.

sum of the genera of its irreducible components, i.e.

8(S)=g(6(5))= 2 8(6’) (24)
6/616(s)

It seems natural, therefore, to determine the complexity of a structure
by the maximal genus of the components of its shadows. More
precisely, we say that S is a y—structure if g(6’) 5 y holds for all
irreducible components of the shadows 6(5). By deﬁnition, a y—
structure can thus be constructed from the set 5y of shadows of
genus at most y by inserting certain non—crossing arcs, (Fig. 6). The
simplest class of structures are of course 0—structures, obtained by
placing non—crossing arcs over the empty structure.

LEMMA 2.1. An RNA structure is a 0-structure if and only if it is a
simple secondary structure. In particular, a 0-structure always has
genus g = 0.

PROOF. We ﬁrst observe that a diagram of genus zero contains
no crossing arcs. This follows from the fact that genus is a
monotone non—decreasing function of the number of arcs [see
Equation (2.3)] and that the genus of the matching (H) consisting of
two mutually crossing arcs has only one boundary component and
hence genus one; (Fig. 2). Secondly, we observe by induction on the
number of arcs that each new non—crossing arc contributes a new
boundary component and 2 — 2g — (r+ 1): 1 — (n—l— 1) shows that the
genus remains zero. Structures consisting only of non—crossing arcs
therefore have genus zero.

Next, we consider structures of arbitrary genus. For their analysis,
diagrams without isolated points, i.e. matchings, play a central role.
Let (€g(n) be the set of matchings of genus g with n arcs, and let
cg(n) :2 |C€g(n)| denote its cardinality. As shown by (Andersen,J.E.
et al., submitted for publication), the generating function Cg(z)=

anocgﬁ’lk” iS given by

x/ 1 — 4g
C Z 2P z —, Z 1, 2.5
gm g()(1_4z)3g g < >
where Pg(z) is an integral polynomial of degree (3g— 1) such that
Pg(1 / 4) 750. The number of genus zero matchings are well known
to be given by the Catalan numbers, and Equation (2.5) allows the
derivation of explicit formulas for higher genera, for instance,

2”_2(2n— 1):! _ 2”_4(5n—2)(2n— 1):!

elm): 3(n—2)! ’c2("’_ 90(n—4)!

Furthermore, the number cg(2g) of matchings of genus g having
exactly 2g arcs, i.e. matchings having exactly one boundary

 

component, is the coefﬁcient of zzg in P8 (z) and is given by
(48)!

4g (2g —I— 1)! '

Explicitly, we have c1(2)= 1, c2(4) :21 and C3 (6) = 1485 for

example. These particular matchings will serve as ‘seeds’ for our
folding algorithm. More precisely, we shall use the following:

cg(2g)= (2.6)

THEOREM 2.2. For arbitrary genus g, the set 5 g of shadows is ﬁnite.
Every shadow in 5 g contains at least 2g and at most (6g— 2) arcs.

The special case g = 1, on which we focus in the algorithmic part
of this contribution, is explicated in the Supplementary Material.

PROOF. First note that if there is more than one boundary
component, then there must be an arc with different boundary
components on its two sides, and removing this are decreases r
by exactly one while preserving g since the number of arcs is given
by n = 2g—l— r — 1. Furthermore, if there are vg boundary components
of length 12 in the polygonal model, then 2n=Z££vg since each
side of each arc is traversed once by the boundary. For a shadow,
v1 = 0 by deﬁnition, and v2 5 1 as one sees directly. It therefore
follows that 2n: Zgﬁvg Z 3(r—1)—l—2, so 2n=4g—l—2r—2Z 3r— 1,
i.e. 4g— 1 Z r. Thus, we have n=2g—l—(4g— 1) — 1 =6g—2, i.e. any
shadow can contain at most 6g — 2 arcs. The lower bound 2g follows
directly from n = 2g—l— r — 1 by observing r = 1.

Many 5 g—shadows are in fact y—structures for some y< g, that is,
they can be constructed from elements of 5),. One key result of this
contribution is the following characterization of 1—structures:

THEOREM 2.3. An RNA structure is a 1-structure if and only if its
shadow can be decomposed by iteratively removing one of the four
shadows

(H) (K) (L) (M)

In particular, 1-structures can have arbitrarily large topological
genus.

PROOF. We only give a sketch here and refer to the Supplementary
Material for a full proof. First, we observe that taking the shadow
preserves genus. Since (H) is the unique matching with two arcs of
genus g: 1, it is contained in every matching of genus g: 1. An
are crossing into (H) preserves the genus and leads to either (K) or
(L). While every are added to (K) increases the genus, there is one
possibility to preserve the genus when adding an arc to (L), namely,
the addition leading to (M). It remains to observe that no further arc
can be added to (M).

Before proceeding to algorithmic considerations, we brieﬂy
compare the class of y—structures with other classes of pseudoknots.
Condon et al. (2004) investigated the structure classes L&P (Lyngsp
and Pedersen, 2000), D&P (Dirks and Pierce, 2003), A&U (Akutsu,
2000) and R&E—class (Rivas and Eddy, 1999). The L&P— and D&P—
class are based on the H—type shadow depicted in Theorem 2.3 and
hence are proper subsets of the 1—structures. The A&U—class does not
cover shadow M but on the other hand contains some conﬁgurations
that are not 1—structures, and even the 2—structures do not completely
contain the A&U—class. Nevertheless, the A&U—class is small: there

 

1 079

112 /§JO'S[BUJHOIPJOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

C.M.Reidys et al.

 

4-non—crossing

( \\ 3:22;:
1’ 2::

Fig. 7. Venn diagram of important classes of structures with pseudoknots.
The mutual relationships of pseudoknot—free secondary structure (SS), the
two H—shadow classes D&P and L&P, and the classes A&U and R&E,
respectively, were already described by Condon et al. (2004). 1—structures
and 4—non—crossing structures are added here.

are more 1—structures than A&U—structures for any given sequence
length (Nebel,M.E. and Weinberg,F., submitted for publication).

The R&E class does not impose a limit on the genus of the shadow
and hence contains y—structure with arbitrarily large y. Conversely,
Figure 3 shows a 2—structure that is not contained in the R&E class.
This example is minimal, i.e. all 1—structures are contained in R&E.
Similarly, the set of k—non—crossing structures (Huang et al., 2009;
Jin et al., 2008) has inﬁnitely many shadows for any ﬁxed k23
(Reidys and Wang, 2010), and hence like R&E, contains y—structure
with arbitrarily large y. We note that every 1—structure is 4—non—
crossing; more precisely, shadows (H) and (K) are 3—non—crossing,
while shadow (L) and (M) each contain three mutually crossing arcs.
(Fig. 7).

2.3 Minimum free energy folding of y-structures

0-structures: We have shown in the previous section that 0—
structures are simple RNA secondary structures. Their minimum
free energy (MFE) conﬁguration can be obtained by DP recursions
(Waterman, 1978; Zuker and Stiegler, 1981) derived from a
decomposition into suitable substructures. This decomposition can
be expressed in terms of a context—free grammar (Dowell and Eddy,
2004; Steffen and Giegerich, 2005). In the simplest case, which
corresponds to evaluating base pairs only, we consider a single non—
terminal symbol 5 representing an arbitrary diagram over a segment
and three terminal symbols to represent isolated vertices (symbol :),
openings (symbol () and closings (symbol )) of base pairs. We only
need the three production rules

5—>:5, 5—>(5)5, 5—>s, (2.7)
to generate the corresponding language S.

1-structures: We shall use that (i) any 1—structure can be inductively
generated from genus one structures and (ii) that every genus one
structure has shadow (H), (K), (L) or (M), to specify a multiple
context—free grammar (MCFG) (Seki et al., 1991). In contrast to
context—free grammars, the non—terminal symbols of MCFGs may
consist of multiple components which must be expanded3 in parallel.

 

3This coupling is only required for components that were generated by the
same production step. Components, even if of the same kind, derived in
different steps are independent of each other.

_ _ _ - _ _ _ _ - _ _ _ __-____ __-J_____-,__——,_,-__—.—

Fig. 8. Fragment—pairs in RNA structures: the rule I —>IAlIBlIAzIBZS
induces the fragment—pairs [i1,r1], [s1,j1] and [i2,r2], [s2,j2]. Arcs
connecting the two fragments of a pair are noncrossing, while arcs with
both endpoints within the same fragment may be crossing such as those
within [52,

In this way, it becomes possible to couple separated parts of a
derivation and thus to generate crossings. In the case of 1—structures,
the language S is built upon sequences of intervals (fragment-pairs)
[i , r], [s, j], where (i , j), (r, s) are nested arcs. Arcs having endpoints in
the different fragments are assumed to be non—crossing; (Fig. 8). For
the MCFG the fragments of a pair are associated with two different
(coupled) components of a two—dimensional non—terminal symbol.
Accordingly, we (re)introduce the following symbols:

- non—terminal 5, representing secondary structure elements (i.e.
diagrams without crossing arcs) according to the rules given
above;

- non—terminals I and T, representing an arbitrary 1—structure;

- non—terminals X =[X1,X2] with two components used to
represent a fragment—pair with nested arcs, X E {H ,K ,L,M };
and

0 terminals (X,)X denoting the opening and closing of a base
pair, respectively, where X is one of the types H ,K ,L or M.

Different brackets as well as the different non—terminals of pattern
X are used to distinguish nestings of the various kinds of shadows.
Finally, we specify the production rules of our unambiguous
MCFG $1 2

I —> 5| T

5 —> (5)5 | :5 le

T —> I(T)5

T —> 121113112121st

T —> IAlIBIIAZICIIBZICZS

T —> IAlIBIICIIAZIBZICZS

T —> IA11B11C11A21D11321C21D25
x a [uIX1,X21)X1 I [cox].

where X E {H ,K ,L,M } distinguishes the four types of pseudoknots.

THEOREM 2.4. Any RNA 1-structure can be uniquely decomposed
via $1, and any diagram generated via $1 is a 1-structure (Fig. 9).

PROOF. We proceed by induction on the number of shadows.
Induction basis: in a 1—structure 6 that contains no genus 1—shadow,
there are no crossings and hence the structure can be decomposed
uniquely via the context—free grammar of secondary structures.
Induction step: suppose we are given a 1—structure containing r 3 1
shadows of genus one. We decompose from right to left. Everything

 

1 080

112 /§.IO'S[BU.ITIOIP.IOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

Topology and prediction of RNA pseudoknots

 

     

 

 

      

IA11311C11AZIBZIC2S

.‘n '. ‘. .S-
IA11B11A21B25

 

 

 

 

 

 

Fig. 9. Illustration of the grammar .521.

is clear until we encounter a substructure containing a genus 1
shadow. For an arc a=(i, j), we distinguish two cases: (I) a is not
crossed, or (II) a is crossed by another arc. In case of (I), there exists
a 1—structure nested in a. In case of (II), we consider the partial order
5, where (i, j)5(r,s) if and only if r<i and j <s. Since crossing
arcs in a 1—structure are contained in one of the four base types, we
distinguish the following scenarios

(H): then there exist maximal base pairs ,8=(r,s), where r < i <
s < j,

(K): then there exist maximal base pairs ,8=(r,s) and 6=(u,v),
where u<r<v<i<s<j,

(L): then there exist maximal base pairs ,8 = (r, s) and 6 = (u, v),
where u<r<i<v<s<j,

(M): then there exist maximal base pairs ,8=(r,s), 6=(u,v) and
6=(p,q), wherep<u<r<q<i<v<s<j.

Consider the set C(a) of arcs that are crossed by a and the minimal
are on, that crosses any element of C(a). Here, minimality is
considered with respect to the partial order 5, where (i, j) 5 (r,s)
if and only if r <i andj < s. It follows that a: (i,j) and on, =(i*,j*)
induce the fragment pair [i ,i*] and [i* , j]. We similarly obtain the
corresponding arcs 6*, 6* or 6*, which induce at most four fragment
pairs and correspond to a unique shadow of type (H), (K), (L) or (M)
(Fig. 10). By construction, the number of genus 1 shadows of any
substructure contained in such a fragment—pair is reduced at least
by one, and can by induction hypothesis be uniquely decomposes
via $1. Finally, any structure generated via .%1 is constructed from
top—to—bottom by iteratively building conﬁgurations of arcs having
shadow (H), (K), (L) or (M). Thus, any structure obtained via .%1 is
indeed a 1—structure completing the proof of the theorem.

2-structures: a folding algorithm for 2—structures requires an
analogous enumeration of all (irreducible) shadows of genus 2.
From Equation (2.6), it is straightforward to explicitly derive the 21
shadows of genus 2 with 4 arcs, see Supplementary Figure 10. As in
the case of genus 1, are insertions into these 21 conﬁgurations leads
to the complete set of 3472 shadows of genus 2. This large number
makes it infeasible to build a practically useful folding algorithms
for all 2—structures. It may be useful, however, to deal with a
(small) subset of shadows. The complexity of such an algorithm
is determined by the complexity of decomposing the individual
shadows by means of MCFG production rules reminiscent of those
for $1. For instance, the shadow of the HDV—structure displayed in
(2) of Figure 6 is contained in the R&E class and can therefore be
computed in 0(N6) time and 0(N4) space. However, when resorting

 

 

w-l w-I w-I ‘J-v-J’ w-I w-I *
A1 1 A2 B2 A1 B1 A2 C1 82 02
(1) (2)
0 8 9
0‘ 0L
    
A1 1 1 A2 2 CZ A1 1 C1 A2 1 2 2 D2

(3) (4)

Fig. 10. Fragmentation: the four cases corresponding to the four shadows
(H), (K), (L) and (M). In (1), there are two maximal arcs: 0t=(i, j) and
ﬁ=(r,s), where r<i<s< j, whence the diagram has shadow (H). Here,
a... = (i*,j*) is the minimal are crossing C(a) and 6* = (r*,s*) is the minimal
are crossing C(6). We have 31=[i,i*], 32 = [j,j...],A1=[r,r*],A2 = [s,s*].
Cases (2), (3) and (4) are analyzed similarly.

decompose
—>

 

 

 

Fig. 11. Folding of 2—structures: the shadow shown here is not contained in
the R&E class of structures and cannot be generated by gap matrices. It can
be decomposed, however, using the eight indexes i , j,k, 1 ,m,n, p and q, thus
implying a 0(N8) time—complexity. This makes use of a six—dimensional gap
matrix Gjakalamanap, which implies 0(N6) space—complexity.

to our approach its time complexity is at least 0(N8): the shadow
presented in Figure 11 requires an DP algorithm with 0(N8) time—
complexity and 0(N6) space—complexity. It is an ongoing work to
devise a sensible folding algorithm for 2—structures.

MFE folding of 1-structures: if we make use of a naive table—
based parsing scheme, checking for each subword s of the input
and for each rule f whether f can produce s, a rule like f :1 —>
IAIIBZICIIAZIDIIBZICZIDZS introduces a complexity 0(N18):
ﬁrst, we must process 0(N2) different with subwords s induced by
an input of size n. Secondly, each non—terminal but the ﬁrst on the
right—hand side of the production introduces an additional split point,
which speciﬁes the part of s to be generated by the corresponding
non—terminal. Since its location may freely be chosen within s, each
split point gives rise to another loop variable, and hence contributes
a factor 0(N) to the runtime.

Even if there are much more sophisticated parsing algorithms, it is
useful to consider this simple scheme since it directly translates into
a recursion for a DP algorithm typically used to compute structures
of minimum free energy. Furthermore, it is possible to introduce
intermediate steps in the derivation of our language by making use
of additional non—terminals and production rules such that the time
complexity can be reduced to 0(N6). For that purpose, let the non—
terminal I ’ represent 1—structures in which no structures with shadow
(H), (K), (L) or (M) are nested and the last vertex is paired. We
introduce the non—terminal symbols (7 = [U 1 , U2], l7: [V1, V2] and
17V =[W1, W2] assumed to represent intermediate fragment pairs and

 

1081

112 /§.IO'S[BU.ITIOIP.IOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

C.M.Reidys et al.

 

|
x
_\
/
E
_\
/

i r s j ii+1 p-1p r s qq+1 j-1j

G(i,j;r.S) '(i+1-P-1) G(p.q;r.3) I<q+1.i-1)
_ G(p+1.i:r,q+1)
l/TG \\
I“ \ — I ’
I I ‘\_, — I I‘ I I‘
i_r s j i pp+1 r s qq+1 i
Gu(i.l;r.S) |(i,P) |(SIQ)

, ’G- \Gu<i.q;p.s>

\
I "\ \ : I + + '
L1 I . .—.I—1; 
' r S J / Gu +1,';r, +1
Gw(i,j;r,s) \ :_.’/l (P I q )
/’ GU ‘\\Gu(i.q;r,p+1) /,’ GV ‘\G\v(i.q;r,p+1)
’_ s \
/ Gw‘x / x” \ \ / x” x \
I/ l"\ \ :, I \ \ , I \ \
+1 ' +1 ‘
l—r  Ii—r' si—EepTI—q' J 'i—r' sl—E\‘W—ql J
Gw(i,j;r,s) \ \ / / \ \ / /
\\G_’u’/ \\G‘_’u’/
Gu(s,i;p.q+1) Gu(S.i;p,q+1)

Fig. 12. The decomposition for 4—dimensiona1 matrices G, Gu, Gv, and Gw.

the production rules
(7 —> [1x1,1x2]
i7 —> [U1U;,U2U§]
iv a [U1.U1U2U§] I [V1.U1V2U2]

where (U’ ,Ué) is a marked copy of (U1,U2) used to identify
the components which must later be expanded in a coupled way.
Accordingly, we replace the derivations of T in .%1 as follows:

T —> I(T)5|I’5
1’ —> V1V2|U1V1U2V2|U1W1U2W2

Note that syntactically, i.e. considered as dot—bracket represen—
tations, the 1—structures can be generated by an MCFG parsable
in time 0(N5). However, in that case, corresponding brackets are
not generated in a coupled way making the grammar inappropriate
for algorithmic purposes.

As typical for DP and in analogy to our parsing scheme, we
use two—dimensional matrices to store the optimal structure over
a fragment. The matrix is indexed by the sequence coordinates
of the endpoints. It can be a simple secondary structure 8 or a
substructure of higher genus. For the fragment—pairs, i.e. for the
non—terminals of dimension two, four—dimensional matrices indexed
by the endpoints of both linked fragments are required to store the
optimal structure over them. Suppose the pair of fragments is [i , r]
and [s, j], and let Gu(i , j ; r, s) be the fragment—pair (associated with)
[U1,U2], Gv(i,j; r,s) be the fragment—pair [V1,V2], Gw(i,j; r,s)
be the fragment—pair [W1, W2] and G(i , j ; r,s) be the fragment—pair
[X 1 ,Xz]. The recursions for these matrices, summarized in graphical
form in Figure 12, are determined directly by the grammar.

We can conclude from the rewriting rules that the computation of
the two—dimensional matrices requires at most three loop variables,
and there are 0(N2) many of them. Accordingly, 0(N5) operations

are required to ﬁll the associated two—dimensional matrices. For
the four—dimensional matrices, two loop variables are needed for
each of the corresponding rewriting rules (those with a left—hand
side of dimension two) for there are in each case two split points
introduced by the right—hand sides of the corresponding productions.
Since we need to compute 0(N4) matrix entries, the total run time
is in 0(N6). Obviously, 0(N4) space is required to store these
tables. Accordingly, the algorithm can generate all 1—structures in
0(N6) time and 0(N4) space, i.e. with the same complexity as
pknotsRE (Rivas and Eddy, 1999) (for the larger R&E class).
The advantage of 1—structures is that structurally different shadows
can be parametrized in different ways, and that the search space is
restricted to moderately complex shadows. In contrast, the language
of R&E—structures is based on crossings and can neither identify
blocks of arcs nor restrict the genus of the shadows. For more
structure classes restricted to H —structures, NUPACK (Dirks and
Pierce, 2003) requires 0(N5) time and 0(N4) space.

This is substantially more demanding, of course, than the 0(N4)
time and 0(N2) memory complexity of pknotsRG Reeder and
Giegerich (2004), which, however, deals with a very restricted subset
of H—shadow structures, demanding that helices are maximally
extended and perfect in the sense that they are not interrupted by
bulge— or interior—loops. pknotsRG thus is not guaranteed to ﬁnd
the minimum energy structure within the class H—shadow structures.
A related fast heuristic treats the (K)—shadow as a superposition of
the two H—shadows (Theis et al., 2010).

2.4 Partition function and sampling

We have shown that the MCFG $1 uniquely generates all 1—
structures, i.e. it is unambiguous. Consequently, .%1 can be employed
to count 1—structures over a given sequence x and to compute the
corresponding partition function

Q: 2 e—G(s)/RT,
se6x

where R is the universal gas constant, T is the temperature, G(s)
is energy of structure s over sequence x and 6x is the set of 1—
structures in which all base pairs (i , j) satisfy the base pairing rules
for RNA, i.e. xixj€{AU,UA,GC,CG,GU,UG}. Let N”- denote
the substructure represented by the non—terminal symbol N in .9?1
over the fragment [i, j], and let Xi,j;r,s denote the fragment—pair
X: [X1 ,XZ], where X1 =[i, r] and X2: [s, j] in the recursions for
energy minimization. For each of these symbols, we introduce
corresponding partial partition functions QNLJ. and Q2173”. Since
the MCFG is unambiguous, the recursions for the partial partition
functions are derived by replacing minima by sums and addition of
energy contribution by multiplication of partial partition functions,
see e. g. (VoB et al., 2006). For instance, the recursion for the partition
functions corresponding to the non—terminal symbol T reads

QT,”- : ZQI‘M X QSh+Lj
h
—E[h,£] RT
+ZQILIH X QTjJrLtA X QSHLJ' X e / ’
hf

where E [h, 5] denotes the energy of the loop closed by the base pair
(h, 12).

 

1 082

112 /§.IO'S[BU.ITIOIP.IOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

Topology and prediction of RNA pseudoknots

 

The probabilities PM]. of partial structures of type N over the
fragment [i, j] and the probabilities P)?” of partial structures of
l,j;l",5

type X over the fragment pair [i, j], [r,s] are readily calculated
from the partial partition functions. These ‘backward recursions’ are
analogous to those derived by McCaskill (1990) for crossing free
structures: let A NW. be the set of 1—structures containing NW- and
let A)?” be the set of 1—structures containing the fragment—pair

l,j;l",5
_)

Xi,j;r,s. It follows that we have

PN.,.= Z Psi  Z Ps-
sEAN.. SEA)?”

1,] l,j;l",S
Suppose NM- or Xi,j;r,s are obtained by decomposing 63. The

conditional probabilities IP’NUIQs and P)?” '9 are then given
’ ‘ l,};l’,S s

by Q9,(Ni,j)/Qe, and Q9,(Xi,j;r,s)/Qe, , respectinY- Here Q9,
represents the partition function of 63, and Q93 (NM) and Q93 (XiJ; r, S)
represent the partition functions for those GS—conﬁgurations that
contain NW- and XIJWJ , respectively. Taking the sum over all
possible 63, we obtain

Q6_,(Ni,j) comm)
PNU :   , Pit-JV“?  T .

From this backward recursion, one immediately derives a stochastic
backtracing recursion from the probabilities of partial structures
that generates a Boltzmann sample of 1—structures, see Ding and
Lawrence (2003); Huang et al. (2010); Tacker et al. (1996) for
analogous constructions.

The basic data structure for this sampling is a stackA which stores
blocks of the form (i , j ,N ) [or (i, j ; r, s,X)], presenting substructures
of non—terminal symbols N over [i , j] (or X over [X 1 ,X2] where X1 =
[i , r] and X2 = [s,j]). L is a set of base pairs storing those removed
by the decomposition step in the grammar. We initialize with the
block (1 , n, I) in A, and L = O . In each step, we pick up one element
in A and decompose it via the grammar with probability QM /QN ,
where QN is the partition function of the block which is picked up
from A, and QM is the partition function of the target block which is
decomposed by the rewriting rule. The base pairs which are removed
in the decomposition step are moved to L. For instance, according
to the rewriting rule T—>I(T)5, the block (i, j, T) is decomposed
into the three blocks: (i,h— 1,I), (h—l—1,£— 1, T), (IE—l— 1,j,5) and one
base pair (h, E) which is to be removed. For ﬁxed indices h, E, where
i5 h < E 5 j, the probability of decomposing (i, j , T) reads

—E 71,5 RT
QIl-Jlil X Q7}+1,Z51 X QSZ+1J X e [ 

QT,-

The sampling step is iterated until A is empty. The resulting
1—structure is the given by the list L of base pairs.

 

PM =

,J'

2.5 Software

Implementation: MFE folding, partition function including a
computation of base pairing probabilities and stochastic backtracing
are implemented in gfold. The program is written in C.

Energy model: although the presentation above uses a simpliﬁed
grammar that does not explicitly distinguish the usual loop types,
gfold implements the Mathews—Turner energy model without
dangles (Mathews et al., 1999, 2004) for secondary structure

 

 

 

 

 

 

 

 

5 4
A E I I I I I I I I I E B  E I I I I I I I I :E:
4 :_  __ : e Z
10 5  E 3103 =— gooo 4:
E I ass-“11 I E, E o o g
a) 103 :-  1 E E I 0 ,. I
E E  I E 'N 2 e o 
D 2 —  I _ O :  :
g 10   z  E - ° “ -
: ‘ : CD ' 9  '
1; a“ E _' E 101  o  
1°  :9- :  3 e 5
0 _ ‘ II I I I I I I I I- 0 _  I I I I I I I I l—
10 32 64 128 10 32 64 128
length N length N

Fig. 13. Run time (A) and peak memory (B) of gfold. Timing information
is given for MFE—only (triangles) and partition function with sampling 10 000
structures from the Boltzmann ensemble. To compute error bars, we folded
between 10 (N > 100) and 100 (N < 70) randomly generated sequences on a
Xeon E5410, 2.33 GHz, 48 GB memory. Memory allocation is independent
of the sequence. For N Z 100, double precision ﬂoats are necessary to avoid
overﬂows. This leads to the jump in memory consumption by a factor of
2. Dotted lines indicate the theoretical behavior of 0(N6) (time) and 0(N4)
(space). The slope for CPU time is slightly steeper than the theory since
constraints among the six indices introduced by the minimum size of the
complex pseudoknot elements lead to an additional speedup for small N.

elements. For pseudoknots, we use here an extended version of
the Dirks—Pierce (DP) model (Dirks and Pierce, 2003) that allows
different penalties ,BX for the four topologically distinct pseudoknot
types X =H,K,L,M. We have observed that the values of ,BX have
a substantial inﬂuence on the accuracy of the predicted structures.
In both NUPACK and pknotsRE, a common pseudoknot penalty
,81 is assigned whenever two gap matrices cross. Since the number
of such crossings depends on the type of the pseudoknot, this
algorithmic design would imply ,BA 2 ,81, ,83 2 ,BC 22,81 and ,BD 2
3 ,81. In gfold, these parameters are independent and can be
adjusted to improve the performance. Since most experimentally
known pseudoknots are of types (H) and (K), we focused in
particular on the ratio of ,BA and ,BB and found that both sensitivity
(the ratio of correctly predicted base pairs to the total number
of base pairs in the reference structure) and positive predictive
value reach a maximum for ,83 = 1.3 ,BA. The pseudoknot penalty
of type (H) coincides with that of the DP model, i.e. ,BA 2 ,81 29.6
(kcal/mol). The other penalties are set to ,83 = 12.6, ,BC 2 14.6 and
,BD 2 17.6; see Supplementary Material for details. An alternative
set of pseudoknot parameters described by Andronescu et al. (2010)
can easily be incorporated but would require a readjustment of these
four topological penalties.

Performance: the current implementation of gfold is applicable
to sequences with a length up to N ~ 150 nt on current PC hardware.
Figure 13 summarizes the resource requirements.

We have observed that gfold provides a substantial increase
in both sensitivity and a positive predictive value (PPV, ratio
of correctly predicted base pairs to the total number of base
pairs in the predicted structure) compared with the alternative DP
approaches pknotsRE (Rivas and Eddy, 1999), NUPACK (Dirks
and Pierce, 2003) and pknotsRG—mfe (Reeder and Giegerich,
2004), and that gfold provides a substantial increase in accuracy,
cf. Figure 14. In an evaluation on the entire Pseudobase
(van Batenburg et al., 2001), gfold achieves a sensitivity of 0.762
and PPV of 0.761. However, as detailed in Supplementary Table

 

1 083

112 /§.IO'S[BU.ITIOIP.IOJXO'SOIlBIlIJOJUIOIQ/ﬂdllII 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

C.M.Reidys et al.

 

 

 

 

 

 

 

 

 

 

 

 

1-0 I I I I I
_ C-
b 0.9— C
E O
’5. 3 - ‘ -
2 CL
8 03—. —
.. _
07 I I I I I
were sears '°-°-°-°-°
o to o rt: (“ma
I—l 11> I—l 11>
Q.- 0 Q.- o bpprob
PSI 71

Fig. 14. Performance of gfold. Comparison of the average sensitivity
(A) and PPV (B) of different prediction algorithms on a sample of 32
structures from Pseudobase. All details of this sample are given in the
Supplementary Table S2. (C) The PPV increases signiﬁcantly if only base
pairs with larger pairing probabilities as predicted by the partition function
version of gfold are included in the predicted structure.

S3, the performance varies substantially between different classes
of sequences. Interestingly, the more complex pseudoknots of type
(K) are predicted with even higher accuracy (sensitivity 0.889, PPV
0.899) than the simpler, much more frequent type H.

The PPV of gfold predictions can be increased by ﬁltering
the base pairs of the MFE structure by their probability P of
formation, which is computed by the partition function version
of gfold. Accepting only base pairs with a predicted base
pairing probability P >0.95 increases the PPV from 0.76 to more
than 0.9, (Fig. 14C). In order to evaluate the false positive rate,
we folded 100 tRNA sequences from Sprinzl’s tRNA database
(Juhling et al., 2009). gfold correctly identiﬁes 94% of them as
pseudoknot free. In comparison, NUPACK correctly identiﬁes 86%
and pknotsRG—mf e 89% of this sample set.

3 DISCUSSION

Combinatorial models of pseudoknotted RNA structures are limited
in two ways: on the one hand, exact algorithmic folding can be
constructed only for certain types of structures; on the other hand,
the larger the structure sets are, the more base pairing patterns are
contained in them that cannot be realized in nature due to steric
constraints. Algorithm design so far has been mostly driven by
the desire to reduce computational complexity. The idea behind
gfold, in contrast, is to deﬁne a more suitable class of structures
that can be generated by nesting and concatenating a small number
of elementary building blocks. This recursive structure is captured
by a fairly simple unambiguous multiple context—free grammar that
translates in a canonical way to DP algorithms for computing the
minimum energy structure and the partition function in 0(N6) time
and 0(N4) space. In addition to MFE folding, we have implemented
the computation of base pairing probabilities and a stochastic
backtracing recursion, thus providing the major functionalities of
RNA secondary structure prediction software for a very natural class
of pseudoknotted structures.

The 1—structures considered here strike a balance between the
generality necessary to cover almost all known pseudoknotted
structures and the restriction to topologically elementary structures
that have a good chance to actually correspond to a feasible spatial
structure. From a mathematical point of view, the characterization

of structures in terms of irreducible components with given
topological genus appears particularly natural and promises to reﬂect
closely the ease with which a structure can be embedded in three
dimensions. In addition, the grammar underlying gfold naturally
distinguishes different types of pseudoknots and admits different
energy parameters for them. We observe that this additional freedom
of the parametrization leads to a substantial increase of sensitivity
of type (K) pseudoknots, (0.63—>0.889) and PPV (0.73—>0.899)
compared wit the usage of a common penalty for each crossing
of gap matrices. In terms of prediction accuracy, gfold thus
compares favorably also with the leading alternative DP approaches
to pseudoknotted structures.

Funding: This work was supported by the 973 Project of the Ministry
of Science and Technology; the PCSIRT Project of the Ministry of
Education; National Science Foundation of China to C.M.R. and
his lab; Deutsche Forschungsgemeinschaft (projects STA 850/2—1
& STA 850/7— 1); the European Union FP—7 project QUANTOMICS
(no. 222664) to FPS. and his lab. J.E.A. and R.C.P. are supported by
QGM, the Centre for Quantum Geometry of Moduli Spaces, funded
by the Danish National Research Foundation.

Conﬂict of Interest: none declared.

REFERENCES

Akutsu,T. (2000) Dynamic programming algorithms for RNA secondary structure
prediction with pseudoknots. Discr. Appl Math, 104, 45—62.

Andersen,J.E. et al. (2010) Enumeration of linear chord diagrams. J. Alg. Comb.
submitted.

Andronescu,M.S. et al. (2010) Improved free energy parameters for RNA pseudoknotted
secondary structure prediction. RNA, 16, 26—42.

Bailor,M.H. et al. (2010) Topology links RNA secondary structure with global
conformation, dynamics, and adaptation. Science, 327, 202—206.

B0n,M. et al. (2008) Topological classiﬁcation of RNA structures. J. Mol Biol, 379,
900—911.

Cai,L. et al. (2003) Stochastic modeling of RNA pseudoknotted structures: a
grammatical approach. Bioinformatics, 19 (Suppl. 1), i66—i73.

Chen,S.J. (2008) RNA folding: conformational statistics, folding kinetics, and ion
electrostatics. Annu. Rev. Biophys, 37, 197—214.

Chen,H.-L. et al. (2009) An 0(n5) algorithm for MFE prediction of kissing hairpins
and 4-chains in nucleic acids. J. Comput. Biol, 16, 803—815.

Condon,A. et al. (2004) Classifying RNA pseudoknotted structures. Theor. Comput.
Sci., 320, 35—50.

Deogun,J.S. et al. (2004) RNA secondary structure prediction with simple pseudoknots.
In Proceedings of the Second Conference on Asia-Paciﬁc Bioinformatics (APBC
2004 ). Australian Computer Society, Sydney, Australia, pp. 239—246.

Ding,Y. and Lawrence,C.E. (2003) A statistical sampling algorithm for ma secondary
structure prediction. Nucleic Acids Res., 31, 7280—7301.

Dirks,R.M. and Pierce,N.A. (2003) A partition function algorithm for nucleic acid
secondary structure including pseudoknots. J. Comput. Chem, 24, 1664—1677.
D0udna,J.A. and Cech,T.R. (2002) The chemical repertoire of natural ribozymes.

Nature, 418, 222—228.

D0well,R.D. and Eddy,S.R. (2004) Evaluation of several lightweight stochastic context-
free grammars for RNA secondary structure prediction. BMC Bioinformatics, 5,
71.

Ferré-D’Amare’,A.R. et al. (1998) Crystal structure of a hepatitis delta virus ribozyme.
Nature, 395, 567—574.

Giedroc,D.P. and Cornish,P.V. (2009) Frameshifting RNA pseudoknots: structure and
mechanism. Virus Res., 139, 193—208.

Giegerich,R. et al. (2004) Abstract shapes of RNA. Nucleic Acids Res., 32, 4843—485 1.

Haslinger,C. and Stadler,P.F. (1999) RNA structures with pseudo-knots: graph-
theoretical and combinatorial properties. Bull Math. Biol, 61, 437—467.

Hofacker,I.L. et al. (1994) Fast folding and comparison of RNA secondary structures.
Monatsh. Chem, 125, 167—188.

Huang,F.W. et al. (2009) Folding 3-n0ncr0ssing RNA pseudoknot structures. J. Comput.
Biol, 16, 1549—1575.

 

1 084

112 /§.IO'S[BU.ITIOIP.IOJXO'SOIlBIlIJOJUIOIQ/ﬂdlllI 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

Topology and prediction of RNA pseudoknots

 

Huang,F.WD. et al. (2010) Target prediction and a statistical sampling algorithm for
RNA-RNA interaction. Bioinformatics, 26, 175—181.

Jin,E.Y. et al. (2008) Combinatorics of RNA structures with pseudoknots. Bull Math.
Biol, 70, 45—67.

Juhling,F. et al. (2009) tRNAdb 2009: compilation of tRNA sequences and tRNA genes.
Nucleic Acids Res., 37, D159—D162.

Kat0,Y. et al. (2006) RNA pseudoknotted structure prediction using stochastic multiple
context-free grammar. IPSJ Digit. Cour, 2, 655—664.

Kleitman,D. (1970) Proportions of irreducible diagrams. Stud. Appl Math, 49,
297—299.

Li,H. and Zhu,D. (2005) A new pseudoknots folding algorithm for RNA structure
prediction. In Wang,L. (ed.) COCOON 2005, V01. 3595. Springer, Berlin,
pp. 94—103.

L0ebl,M. and Moffatt,l. (2008) The chromatic polynomial of fatgraphs and its
categoriﬁcation. Adv. Math, 217, 1558—1587.

Lyngso,R.B. and Pedersen,C.N. (2000) RNA pseudoknot prediction in energy-based
models. J. Comput. Biol, 7, 409—427.
Massey,W.S. (1967) Algebraic Topology: An Introduction. Springer, New York.
Mathews,D. et al. (1999) Expanded sequence dependence of thermodynamic parameters
improves prediction of RNA secondary structure. J. Mol Biol, 288, 911—940.
Mathews,D. et al. (2004) Incorporating chemical modiﬁcation constraints into a
dynamic programming algorithm for prediction of RNA secondary structure. Proc.
Natl Acad. Sci. USA, 101, 7287—7292.

Matsui,H. et al. (2005) Pair stochastic tree adjoining grammars for aligning and
predicting pseudoknot RNA structures. Bioinformatics, 21, 2611—2617.

McCaskill,J.S. (1990) The equilibrium partition function and base pair binding
probabilities for RNA secondary structure. Biopolymers, 29, 1105—1119.

Metzler,D. and Nebel,M.E. (2008) Predicting RNA secondary structures with
pseudoknots by MCMC sampling. J. Math. Biol, 56, 161—181.

Namy,O. et al. (2006) A mechanical explanation of RNA pseudoknot function in
programmed ribosomal frameshifting. Nature, 441, 244—247.

Nebel,M.E. and Weinberg,F. (2011) An algebraic approach to ma pseudoknotted
structures. submitted.

N ussinov,R. et al. ( 1978) Algorithms for loop matching. SIAM J. Appl Math, 35, 68—82.

Penner,R.C. et al. (2010) Fatgraph models of proteins. Comm. Pure Appl Math, 63,
1249—1297.

Reeder,J. and Giegerich,R. (2004) Design, implementation and evaluation of a practical
pseudoknot folding algorithm based on thermodynamics. BMC Bioinformatics,
5, 104.

Reidys,C.M. and Wang,R. (2010) Shapes of RNA pseudoknot structures. J. Comput.
Biol, 17, 1575—1590.

Rivas,E. and Eddy,S.R. (1999) A dynamic programming algorithm for RNA structure
prediction including pseudoknots. J. Mol Biol, 285, 2053—2068.

Rivas,E. and Eddy,S.R. (2000) The language of RNA: a formal grammar that includes
pseudoknots. Bioinformatics, 16, 334—340.

Rodland,E.A. (2006) Pseudoknots in RNA secondary structures: representation,
enumeration, and prevalence. J. Comput. Biol, 13, 1197—1213.

Seki,H. et al. (1991) On multiple context free grammars. Theor. Comput. Sci, 88,
191—229.

Staple,D.W. and Butcher,S.E. (2005) Pseudoknots: RNA structures with diverse
functions. PLoS Biol, 3, e213.

Steffen,P. and Giegerich,R. (2005) Versatile and declarative dynamic programming
using pair algebras. BMC Bioinformatics, 6, 224.

Tabaska,J.E. et al. (1998) An RNA folding method capable of identifying pseudoknots
and base triples. Bioinformatics, 14, 691—699.

Tacker,M. et al. (1996) Algorithm independent properties of RNA structure prediction.
Eur. Biophy. J., 25, 115—130.

Taufer,M. et al. (2009) PseudoBase++: an extension of PseudoBase for easy
searching, formatting and visualization of pseudoknots. Nucleic Acids Res., 37,
D127—D135.

Theimer,C.A. et al. (2005) Structure of the human telomerase RNA pseudoknot reveals
conserved tertiary interactions essential for function. Mol Cell, 17, 671—682.
Theis,C. et al. (2010) Prediction of ma secondary structure including kissing hairpin

motifs. Algorithms Bioinformatics, 6293, 52—64.

Uemura,Y. et al. (1999) Tree adjoining grammars for RNA structure prediction. Theor.
Comput. Sci, 210, 277—303.

van Batenburg,F.H.D. et al. (2001) PseudoBase: structural information on RNA
pseudoknots. Nucleic Acids Res., 29, 194—195.

Vernizzi,G. and Orland,H. (2005) Large-N random matrices for RNA folding. Acta Phys.
Polon., 36, 2821—2827.

VOB,B. et al. (2006) Complete probabilistic analysis of RNA shapes. BMC Biol, 4, 5.

Waterman,M.S. (1978) Secondary structure of single-stranded nucleic acids. Adv. Math,
1, 167—212.

Zuker,M. (1989) On ﬁnding all suboptimal foldings of an RNA molecule. Science, 244,
48—52.

Zuker,M. and Stiegler,P. (1981) Optimal computer folding of larger RNA sequences
using thermodynamics and auxiliary information. Nucleic Acids Res., 9, 133—148.

 

1 085

112 /§.IO'S[BU.ITIOIP.IOJXO'SOIlBIlIJOJUIOIQ/ﬂdlllI 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

