ORIGINAL PAPER

Vol. 26 no. 18 2010, pages 2321-2327
doi: 10. 1093/bioinformatics/btq414

 

Data and text mining

Advance Access publication July 12, 2010

Interactive and fuzzy search: a dynamic way to explore MEDLINE
Jiannan Wang“, Inci CetindiIZ’T, Shengyue Ji2, Chen Li2’*, Xiaohui Xie2’3’*, Guoliang Li1

and Jianhua Feng1

1Department of Computer Science, Tsinghua University, Beijing 100084, China, 2Department of Computer Science
and 3Institute for Genomics and Bioinformatics, University of California, Irvine, CA 92697, USA

Associate Editor: Alex Bateman

 

ABSTRACT

Motivation: The MEDLINE database, consisting of over 19 million
publication records, is the primary source of information for
biomedicine and health questions. Although the database itself has
been growing rapidly, the search paradigm of MEDLINE has remained
largely unchanged.

Results: Here, we propose a new system for exploring the
entire MEDLINE collection, represented by two unique features:
(i) interactive: providing instant feedback to users’ query letter by
letter, and (ii) fuzzy: allowing approximate search. We develop novel
index structures and search algorithms to make such a search model
possible. We also develop incremental-update techniques to keep
the data up to date.

Availability: Interactive and fuzzy searching algorithms for exploring
MEDLINE are implemented in a system called iPubMed, freely
accessible over the web at http://ipubmed.ics.uci.edu/ and
http://tastier.cs.tsinghua.edu.cn/ipubmed/

Contact: chenli@ics.uci.edu; th@ics.uci.edu

Received on April 27, 2010; revised on July 7, 2010; accepted on
July 8, 2010

1 INTRODUCTION

The PubMed service provided by NCBI is the most widely used
system for accessing the MEDLINE database, which contains more
than 19 million (as of April 2010) records from approximately
5000 selected publications covering biomedicine and health from
1950 onwards. It handles over 2 million searches per day, has
become an essential part of every biomedical scientist’s research
effort, and is increasingly employed by physicians and patients as
an indispensable tool to answer clinical questions.

PubMed uses keywords and Boolean operators to retrieve
documents from MEDLINE. To perform a search, users need to
ﬁrst compose a keyword query, submit it to the server, wait and
ﬁnally review the returned search results. If the returned results are
too many or not pertinent, the users need to modify or reﬁne the
query, and resubmit it to the server. This type of try-and—see search
paradigm requires the users to have certain knowledge to choose
wisely the appropriate keywords, and often requires numerous
iterations to reach the desired documents (Lewis et al., 2006;

 

*To whom correspondence should be addressed.
TThe authors wish it to be known that, in their opinion, the ﬁrst two authors
should be regarded as joint First authors.

Wildemuth and Moore, 1995), creating signiﬁcant delay between
the initial query and the ﬁnal results. Even though there are
several systems supporting search in the medical domain such as
CiteXplore and HubMed, all of these systems use this traditional
search paradigm. Recently, PubMed has started to give automatic
suggestions as typing the query; but these suggestions are not
based on the entire dataset. The suggestions are obtained by
performing preﬁx search on the popular queries made by other
users. For instance, if we type ‘Weinberg oncogene’ to search for
publications written by ‘Weinberg’ related to ‘oncogene’, PubMed
does not give any suggestions, while there are a lot of documents
containing these terms. In addition, PubMed cannot automatically
handle approximate query search. Instead, it provides a list of
candidate terms close to the query string and relies on users to pick
up the right one, based on which it then performs exact search.
This limitation is problematic for searching biomedical literatures,
for which user queries frequently contain difﬁcult—to—spell author
names, non—standard gene symbols or specialized medical terms.

We propose an interactive and dynamic model of information
retrieval and implement it to explore MEDLINE. The new model
incorporates two unique features: (i) interactive: providing instant
feedback as the query is being typed, and (ii) fuzzy: allowing
approximate search (Gusﬁeld, 1997; Navarro, 2001). Under this
model, the system updates search results online invoked by every
keystroke from the users. This type of search-as-you-type paradigm
allows the users to ﬁnd results ‘on the ﬂy’ and enables them to
dynamically modify or reﬁne queries, removing the major barrier
between queries and search results. The existing PubMed system
has several similar features, such as ‘browsing the index of terms’,
‘automatic term mapping’ and ‘truncating search terms’. The main
difference between these features and iPubMed’s features is that we
do preﬁx—based search on the ﬂy as the user types in a query, and
we allow minor errors.

The new search paradigm poses signiﬁcant computational
challenges, due to the requirement of high interactive speed and
the capability of relaxing keyword conditions. The total round—trip
time between the client browser and the backend server includes
the network delay and data—transfer time, query—execution time on
the server, and the javascript—execution time on the client browser.
To achieve an interactive speed, this total time should not exceed
milliseconds (typically within 100 ms); the query—execution time on
the server should be even shorter. This high speed is challenging to
achieve especially since we allow keywords to appear at different
places and to match approximately, both of which are not permitted
by the popular autocompletion method implemented in major search
engines (Bast and Weber, 2006) and more recently by PubMed.

 

© The Author 2010. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oxfordjournals.org 2321

112 /§JO'SIBUJHO[pJOJXO'SOllBIIIJOJUIOIQ/ﬁdnq 11101; prBOIIIAAOG

9IOZ ‘Ig lsnﬁnv uo ::

J. Wang et aI.

 

 

Paws-red by TASTIEFi Prciect

I Fuzzy Search On | E I

|_>Turn On / Off
Fuzzy Search

tulirrcr Site at Tainghua |_|niye:a-.3r.

lPubMed Search

 

lemy'e lateral rilu zecce
Type in title, authenjcu'rﬂ, HeSH heading and mere to search for 11,15,319 MEDLINE pubicﬂimefaa of Mar 2?, 2919)

Faeduaca

II exact match I fuzzy march (0.011 Seconds) Results 1 - 4.

+7 Exact match
Riluaele anu'l amyeti'ephi lateral Irlarr-t a auiyiyal' a pcpulatirun traced atudy in E:cutharn Ite-
a zoecolella, E Beghi. G Pa' Wﬁaddcaie. ‘y' Guerra. y Samarelli, ’y' Lepere. | L Simene. P Lamberti. L Eerlenga. G Legreacinu. SLAP registry
[13931191901DfNE'mﬂiculcalSciencea,Uniyerait'-.r afEari, Italy
Eurcnean IIZIUlr'::'I|  -' aural-Jay : the cfﬂclal Icurna!  a EIJIcnean FEdEl‘EIIICIl'I I:-."-' :e _-: cartel Secletiea. 14-3 ri-I-ar_ LI 2‘
I ' "_ " I I'JELJI'CIEI'DIECIIVE AL]I:"'I"II:', RJILIIDIIE

 

 

 

 

 

Ccct effectiy-L-ncca cf riluzole in amyotrc: in: lateral aclcrcai: Ital-j I: ceperatiyc C-rcup fc* E" e Study of lylcta Anal-race and the

 

Occcryatcric 'Z—LEPCi cui Farmaci
A Measuri. E Trippeli, P Becagli, G Zaccara

 

PharmaccEcmi-Jrr- :5  Aug, 1999

 

Drug Information Centre. Pharmaceutical Service. AziE'nda Canadaliera Caregqr. Ftcrance. Italy md3t139®mciiai~ i1

 

Efficacy of rilu:—.:<:ie 'r-Jhe arc the DJtIEl‘IEZ =::r-:'e||ecl In the studies?

 

 

GIBl‘lEEl‘ID Legreacine, StETEr'I Zecc:"‘"*'
nmymtrnphir lateral = "-=-l-'-'-.i"-. nfﬁ . .
Middle Aged | Meter Near-en Diaeaae | Neureprctectiye Age—.5 Patient Selection | Riluzele

 

 

Stefane Ieecelella, Andrea Santamate, Paula Lamberti

Ifa y

 

Neumnayrhiamr -] saaae andtreatment 5 9999

 

" :- '--"-I'r-Ilri Federatinn nfr-Ia-irm ' _':

Current and emerging treatments fer amyeucphic lateral aclereaia

Azllenda Dacedaliem-Urnyeraltarla Dapedali itiurias. Department cflyiedical and Hamelcgical Sciences, Clinic at Henrcua Elyatem Diseases, Uﬂl'dETE-II'JI' cf Feggla.

Fuzzy match

P arc-air h I’w‘lnuru I'Il'li'l.'1I'III'-ii'|-'-."Il'lr'li-PR'T-P‘T. 9-?“ Apr, E'I'I='I-'

 

 

Fig. 1. Screenshot of iPubmed system (http://ipubmed.ics.uci.edu/ and http://tastier.cs.tsinghua.edu.cn/ipubmed/).

In this article, we show that the goal of high speed for interactive
and fuzzy search is achievable by employing novel index structures,
caching techniques and search algorithms. We implemented these
algorithms and techniques in a system called iPubMed (stands for
Interactive PubMed), which is currently able to search the entire
MEDLINE. The preliminary algorithmic aspect of this work was
presented previously in a conference proceeding (Ji et al., 2009).
Here, we provide a full description of the algorithms used and deploy
these techniques speciﬁcally for MEDLINE search, incorporating
additional methods such as incremental update, article ranking and
parallel computing.

Figure 1 shows a screenshot of the system as a user typed in
four keywords—‘amyo lateral rilu zacc0’. The user intended to
ﬁnd the publications describing the treatment of amyotrophic lateral
sclerosis with drug riluzole authored by Zoccolella. PubMed at
NCBI failed to return any publication record for this query as it
contains a misspelling of the author name and two incomplete
query keywords. In contrast, iPubMed was able to retrieve the
right publications. More importantly, because the search results
are returned in real time as query strings are being typed,
users can adaptively change queries until desired results are
reached.

The iPubMed interface has several important features that make
it powerful and user friendly. It allows users to specify whether the
system should do ‘fuzzy’ search by clicking the ‘On’ or ‘Off’ links. In
addition, keywords in returned results are highlighted in the client’s
browser, with different colors depending on whether it is a fuzzy or
an exact match. The system has also a pagination feature that helps
users easily navigate through the results by using the provided links
for the previous and next pages.

2 METHODS
2.1 System architecture of iPubMed

The overall architecture of iPubMed is shown in Figure 2. The client accepts
a query through the user interface, and checks whether the cached results
are enough to answer the query. If not, the client sends the query to the web
server. The server has several components. The web server has a Broker
that receives a query from a user, and sends the query to the Fasthi
servers in the cluster. Each Fasthi Server waits for queries from the
broker, and caches query results. The Cache component checks whether the
query can be answered using the cached results. If not, the Fasthi server
incrementally answers the query. For each query keyword, the Fuzzy Preﬁx
Finder computes the predicted words and the lists of records that contain
a predicted word. Next, the Fasthi server computes the intersection of the
lists to compute the predicted records of the query and ranks the predicted
records to identify the best answers. Finally, the broker collects all these local
best answers from the Fasthi servers, aggregates these results and returns
the best answers to the client. The Indexer component indexes the data as
a trie structure with inverted lists of keywords and creates a forward index.
It keeps the data and all these structures are in memory. For data changes,
we download the update ﬁles from an NLM FTP server on a daily basis. We
pre—process the ﬁles to extract the six most commonly searched attributes:
authors, their afﬁliations, article title, journal name, journal issue and MESH
terms, and keep this data in a relational table. Then, we partition the data
into several machines horizontally and keep in a data shard. The Updater
component reads the updates from the corresponding data shard and loads it
into memory. Then it incrementally updates the index in memory.

2.2 Problem formulation

We formalize the problem of interactive, fuzzy search on a structured table,
although our method can be easily adapted to textual documents, XML data
and relational databases. Consider a relational table T with m attributes and n

 

2322

112 /§JO'SIBUJHOIPJOJXO'SOIlBIHJOJUIOIQ/ﬁdnq 11101; pepeoIUAAoq

9IOZ ‘Ig lsnﬁnv uo ::

Interactive and fuzzy search

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

     

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Client Server
I I I 2 3 4
I Q User I FastCGl Server 1 $ Update
Types Reads “ v Flles
NLM FTP
I DHTML I g , server
3 Indices
Events; Modiﬁcations I E
. x. Updated
I JavaScrIpt I 3 Daily
it it '-
D O M
l
v _ (Hg
Client Internet S
AJAX Requests! em" Updater
Cache Responses Cache
Client: Web Browser \ Data Shard I _

 

 

 

 

 

asses

 

Web Server

   

Data Source

 

 

Fig. 2. The system architecture of iPubMed.

Table 1. A sample publication relational table

 

 

 

ID Title Authors Journal name Year
r1 Biopsy ﬁndings after breast conservation therapy for Vapiwala,N., Starzykm,J., Harris,E.E., Int. J. Radiat. Oncol. Biol. Phys. 2007
early—stage invasive breast cancer Tchou,J.C., Boraas,M.C., Czemiecki,B.J.,
Rosato,E.F., Orel,S.G. and Solin,L.J.
r2 Fine—needle aspiration biopsy ﬁndings in patients Catrina Reading,F., Schlette,E.J., Stewart,J.M., Am. J. Clin. Pathol. 2007
with small lymphocytic lymphoma transformed to Keating,M.J., Katz,R.L., Caraway,N.P.
hodgkin lymphoma
r3 Histopathology reporting of prostate needle biopsies Montironi,R., Vela Navarrete,R., Virchows Arch. 2006
Lopez—Beltran,A., Mazzucchelli,R.,
Mikuz,G., B0n0,A.V.
r4 Ultrasound—guided prostate biopsy in 2005 Clements,R. and Luis,T. Int. Am. J. 2006
r5 Epidemiology of biopsy proven giant cell arteritis in Gonzalez—Gay,M.A., Garcia—Porrua,C., Ann. Rheum. Dis. 2007
northwestern Spain: trend over an 18 year period Rivas,M.J. Rodriguez—Ledo,P., Llorca,J.
r6 The optimal diet for women with polycystic ovary Marsh,K. and Brand—Miller,J. Br. J. Nutr. 2007
syndrome?
r7 Bile duct dysplasia and congenital hepatic ﬁbrosis Bettini,G., Mandrioli,L., Morini,M. Vet. Pathol. 2007
associated with polycystic kidney (Caroli
syndrome) in a rat
r8 Open—heart operations in patients with a spinal cord Lin,D., Bakaeen,F.G., Shenaq,S.A., Ribati,M., Am. J. Surgery 2007
injury Atlun',P.V., Holmes,S.A., Berger,D.H.,
Huh,J.
r9 Effects of zinc coadministration on lead toxicities in Piao,F., Cheng,F., Chen,H., Li,G., Lu,X., Ind. Health 2007
rats Liu,S., Yamauchi,T., Yokoyama,K.
r10 Dye—guided and radio—guided sentinel node biopsy Imoto,S. and Ito,H. J. Surgery 2007
in breast cancer
records. LetA={a1, a2,..., am} denote the attribute set, R={r1, r2,..., rn} records) that contain at least one of the predicted words of every query

denote the record set and W: {w1, wz, ...,wp} denote the distinct word set
in T. Given two words w,- and Wj, wl- Swj denotes that w,- is a preﬁx string
of Wj. An example relational table is shown in Table 1, which has 10 records
and 4 attributes.

Each keyword in a given query is treated as a partial keyword. For each
query keyword, we ﬁrst identify the words in W (called predicted words)
that contain a preﬁx matching the query keyword exactly or approximately
(in the case of fuzzy search). Then, we ﬁnd the records in R (called predicted

keyword. Finally, we rank the returned records.

More precisely, the search problem is formulated as follows. Given a
query consisting of a set of preﬁxes Q: {p1, p2, . . ., pl}, we ﬁrst identify the
predicted—word set of each preﬁx, that is, for preﬁx pi, P,- 2 {p; | Elw e W, p; 5
w and ed(p;, pi) 5 8}, where ed(p;, pi) is the edit distance between two strings
and 8 is the edit—distance threshold. Next, we identify the predicted—record
set of the query, RQ = {rlElpI e P,- & w,- in r €Rs.t. p; 5 w), Vie [1,1]}. Finally,
we rank the records in RQ according to their relevance to Q.

 

2323

112 /B.IO'SIBU.IHOII).IOJXO'SOIlBIHJOJUIOICI/ﬁdnq 11101; pepeoIUAAoq

9IOZ ‘Ig lsnﬁnv uo ::

J. Wang et aI.

 

   

 
 

. 16 5
[4’4]; 1551971

9 22] Forward Index

   

 

 

 

 

 

 

 

 

records keywords
8 ‘ r1 2 9
[1,1] ‘1,“ r4 2 7 9
r9 3 s 6 8

 

Fig. 3. An example index structure (partial) for the publication records
shown in Table 1.

2.3 Index structure

We use a trie to index the words in the table. Each word w in the table
corresponds to a unique path from the root of the trie to a leaf node. Each
node on the path has a label of a character in w. The nodes with the same
parent are sorted by the node label in their alphabetical order. Each leaf
node has a unique keyword ID for the corresponding word. The keyword
ID is assigned in the pre—order. Each node maintains the range of keyword
IDs in its subtree: [minKeyID, maxKeyID]. For each leaf node, we store an
inverted list of record IDs that contain the corresponding word. To improve
search performance, we can also maintain a forward index for the records.
For each record, the forward index keeps the sorted keyword IDs in the
record. Consider the publication relation in Table 1. Its trie for the tokenized
words is shown in Figure 3. The word ‘luis’ has a node ID of 16, and its
inverted list includes record r4. The keyword ID of leaf node 11 is 3. The
keyword range of node 11 is [3, 5]. The forward list of record r4 includes
keyword IDs 2, 7 and 9.

2.4 Search algorithm

We tokenize each query string to keywords. Our search algorithm consists of
the following three steps: (i) Finding the predicted words of each keyword
and the list of records that contain the predicted words; (ii) identifying the
predicted records by computing the intersection of the lists corresponding to
different query keywords; and (iii) ranking the answers. Next, we describe
these three steps.

2.4.1 Incrementally identifying predicted words of each keyword For each
input keyword, we incrementally identify the predicted words based on its
preﬁxes. In the case of exact search, there exists only one trie node that
match a partial keyword, therefore ﬁnding the predicted words is relatively
easy and can be done by traversing the descendants of the trie node. However,
to support fuzzy search, we need to predict multiple preﬁxes that are similar
to the partial keyword. We call the nodes of these similar preﬁxes the
active nodes of the input keyword (Fig. 4). We will need to locate the leaf
descendants of all active nodes, and identify the predicted records of these
leaf nodes. For example, consider the trie in Figure 3. Suppose 8: 1, and
a user types in a partial keyword ‘li’. The words ‘li’, ‘lin’, ‘liu’, ‘lu’ and
‘lui’ are all similar to the input keyword, since their edit distances to ‘li’
are within a threshold 8:1. Thus, nodes 11, 12, 13, 14 and 15 are active
nodes.

Given an input keyword p, we store the set of active nodes
Cl>p={<n, 5,, >}, where n is an active node for p, and 5,, =ed(p, n)§8.

6’]
C2
C3

. . . . . . . . . . .. ° px

Cx

 

Cx+l

 

<dién+|dunmi> Q oooo ~
.Deletion OMatch   Substitution © Insertion

Fig. 4. Incrementally computing active nodes.

(For the simplicity of notation, we will use n to denote both the trie node
and its corresponding string). We call 61),, the ‘active—node set’ for keyword p
(together with the edit—distance information for each active node). The main
idea behind our method is to use the preﬁx—ﬁltering. That is, when the user
types in one more letter after p, only the descendants of the active nodes of
p can be the active nodes of the new query and need to be examined. We use
this property to incrementally compute the active—node set of a new query,
taking advantage of the cached active—node sets (DP.

Suppose a user is typing in a query string clcz...cx letter by letter. After
the user types in a preﬁx query p,- = clcz . . .c,- (i 5x), we keep an active—node
set (DP,- for p,-. When the user types in a new character cx+1 and submits a
new query px+1, we compute the active—node set Cl>px+1 for px+1 making use
of (1),”, as follows.

We start by initializing an active node set corresponding to the empty
keyword 8, i.e. CI>p0= €138 ={<n, 5,, > l5,, 2 |n| 58}. That is, it includes all
trie nodes n whose corresponding string has a length |n| within the edit—
distance threshold 8. These nodes are active nodes for the empty string since
their edit distances to 8 are within 8.

For each < n, 5,, > in (PM, we consider whether the descendants of n are
active nodes for px+1. If 5,,+158, then n is an active node for px+1, so
we add <n, 5,,+1> to Cl>px+1. This case corresponds to deleting the last
character cx+1 from the new query string px+1. Note that even if 5,, +1 5 8
does not hold, node n can still potentially become an active node of the new
query string, due to operations described below on other active nodes in (PM.
For each child nc of node n, we consider two possible cases.

In the ﬁrst case, the child node nc has a character different from cx+1.
Suppose node n, is such a child node. We have ed(ns, px+1) 5 ed(n, m) + 1 =
5,,+ 1. If 5,,+158, n5 is an active node for the new string, and thus <ns,
5,, +1 > will be added to Cl>px+1. This case corresponds to substituting the
label of n, for the letter cx+1.

In the second case, the child node nc has a label cx+1. Suppose node n,,,
is such a child node. In this case, we have ed(n,,,, px+1) 5 ed(n, px) =5,, 5 8.
Therefore, n,,, is always an active node of the new string, so we add <n,,,,
5,, > to <I>px+1 . This case corresponds to the match between the character cx+1
and the label of n,,,. One subtlety here is that, if the distance for the node
n,,, is smaller than 8, i.e., 5,, < 8, we need to consider additional nodes: for
each descendant d of n,,, that is at most 8—5,, letters away from n,,,, we also
need to add <d, 5,) > to Cl>px+1, where 5d=5n+|d|—|n,,,|. This operation
corresponds to inserting letters after node n,,, (for node n,, we do not need
to consider its descendants for insertions; because if these descendants are
active nodes, they must be in (DP), and thus will still be considered).

 

2324

112 /B.IO'SIBUJHOIPJOJXO'SOIlBIIIJOJUIOICI/ﬁdllq 111011 pep1201umoq

9IOZ ‘Ig lsnﬁnv uo ::

Interactive and fuzzy search

 

keywords active nodes predicted words lists predicted records
in . . r]
in —> ,7.) W "" "* r9  ,4.
. _ s
.—  .... nn>  r4ni.... * r9 “‘
M H a

\
biopsy ----->r1 r2 r4 r5 r10 a; r2 ..., 1’4
bio —> M4 biopsies «unnopﬁ --""" r3 ‘

r4 .0
ll nnnnnnn nn>  . r5 "
I . IO '
 ....... co, r8 §.-~ ‘. r "'0
9 r4
l” ....... nu,
7'9 .-.::...:-:c)r8
. ' r9

 

Fig. 5. Intersecting lists for answering a keyword query ‘in bio li’.

Note that during the update of Cl>px+1, the above procedure may result in
the addition of multiple sets corresponding to the same node, in which case
we only keep the one with the shortest edit distance to the query string px+1.

2.4.2 Finding predicted records Given a query Q: {p1, p2, ..., pl},
suppose {k,-1, k,-2,...} is the set of keywords that are similar to the preﬁx
p,-. Let Li]- denote the inverted list of k,-j, and U,- = Uj L,-]- be the union of the
lists for p,-. Our goal is to ﬁnd (1,- U ,-, the intersection of different preﬁx union
lists. Figure 5 illustrates an example in which we want to answer query ‘in
bio li’.

To ﬁnd the intersection, we ﬁrst ﬁnd the preﬁx with the shortest union list.
We call each record in this list candidate record. Then we use the forward
index to check whether each candidate record contains similar preﬁxes of
every other query keyword. If so, this record is an answer. Each active state of
other query keywords has a keyword range [s, l], and we check whether the
candidate record contains a keyword in the range [s, i] using the following
steps: (i) use a binary search method to ﬁnd the candidate record ID in the
forward index; (ii) ﬁnd the smallest keyword ID on the candidate record’s
forward list that is larger than or equal to s; and (iii) check whether this
keyword ID is smaller than 1.

2.4.3 Ranking We consider the following several factors when designing
a metric for ranking the search answers: (i) Matching preﬁxes: we consider
the similarity between a query keyword and its best matching preﬁx. The
more similar a record’s matching keywords are to the query keywords, the
higher this record should be ranked. The similarity is also related to keyword
length. Exact matches on the query have a higher priority than fuzzy matches.
For example, consider the trie in Figure 3. If a user types in ‘liu’, the record
r9 could be ranked higher than r8; since the record r9 has an exact keyword
match when r8 has a fuzzy keyword match ‘lin’. (ii) Record weights: different
records could have different weights. For example, a newly added publication
record could be ranked higher than older publications.

To combine these factors, we use the following scoring function. Suppose
the query is Q={p1, p2...,p,,,},p; is the best matching preﬁx for p,. The
score of a record r for Q is deﬁned as:

score (r,Q)= Z [10(r)/(0t><ed (pup; )2+ﬁ)].

i=1, 2,...,m

where 06 and B are weights used to adjust the effect of edit distance. We use
06 = 10, B = 1 in our system. Mr) is the score of record r, which is deﬁned as:

it (r)=r[year] — 1900+ 10-9 x r[pmid],

where r[year] and r[pmid] are the corresponding ﬁelds of the record r. These
ﬁelds are used in the ranking function to give a higher priority to recent
publications. Since many records have the same year and pmids are given to
the records in an increasing order, we also used the pmid ﬁeld to be able to
rank the records within the same year.

2.5 Caching algorithms

Results of earlier computations are cached to speed up later queries. After
ﬁnding the answers of a query, we cache the active states for preﬁxes of
each input keyword. We then incrementally answer the subsequent keywords
using the cached active states. For the query with multiple keywords, we
also cache the predicted records (intersection of union lists). If the user
types another keyword, we use the cached records to answer the query by
checking whether the cached records contain the new keyword using the
forward index. If there are too many predicted records, we just cache the
highly relevant ones. For each subsequent keyword, we ﬁrst use the cached
records to compute the answer. If there are not enough top answers, we
continue to compute more answers for the previous query and store the
results in the cache. This ‘on—demand’ caching method makes sure that each
query is answered efﬁciently, and we cache results of a query only if they
are needed.

Results in the client are cached to reduce communication cost. This
optimization is especially important in scenarios where the user has a limited
network bandwidth, such as mobile networks. The main idea is that the client
browser caches the results of previous queries. To send to the client the
answers to a subsequent query, the server just sends the identiﬁers of those
already in the earlier results, in addition to the additional records. In this way,
only the ids of the earlier results need to be transferred over the network.

2.6 Incremental updates

Since many new records are added to the MEDLINE database on a daily
basis, updating our dataset timely becomes very crucial. We download
the provided update ﬁles from an NLM FTP server every day and use
incremental—update techniques to maintain the trie structure, inverted lists
and forward index. This allows us to process inserted, revised and deleted
records without reconstructing the whole structure from scratch.

The MEDLINE database is maintained via insertions, deletions and
revisions. For each revision, we delete the existing record ﬁrst, and then
insert the new record. Therefore, we will focus on insertions and deletions.
We store the trie, inverted lists, forward lists and the original data in memory.
We also keep a copy of the data shard on the disk to be able to rebuild the
structures in case of a system failure. Next, we discuss how these structures
change in the presence of an insertion or deletion.

Deletion: Assume a record r is deleted. First, we delete it from the copy
on disk. For the in—memory copy, we mark the record r as invalid, but do not
delete its keywords from the trie, because other records may contain these
keywords. We do not modify the inverted index nor the forward index, since
they are kept sorted and could be large. In this scenario, if the record r is
found in the answers to a query, the system will not return the record r to
the user since it is marked as invalid.

Insertion: Let r be an inserted record. First, we insert the record into
the data on disk. Then, we tokenize r to keywords and insert each of its
keywords into the trie. If there is a leaf node for the keyword, we can just
add the record r into the inverted list of this leaf node. Since the inverted
list of this keyword is sorted and might be huge, it could be expensive to
insert r directly into the list. For this reason, for each leaf node, we keep a
primary list and a secondary inverted list. We use the primary inverted list
when building the structure, and use the secondary inverted list for storing
updates. This method can reduce the time to insert a record to the inverted
list, since the number of records in the secondary inverted list tends to be
smaller than the primary one. These two lists can be merged into the primary
list periodically to be able to keep the secondary inverted list small.

If a keyword is seen for the ﬁrst time, it should be added to the trie. To
be able to use the forward index with the updated trie, we want to preserve
the order of the assigned ids of the trie nodes. If the keyword ids on the
trie are assigned consecutively, we may not be able to assign new unique
ordered IDs for the new keywords. To solve this problem, we reserve some
extra keyword ids on the trie to use in case the updated dataset contains new
keywords. In the rare case where the reserved space is not enough for new
keywords, we can rebuild the index structures.

 

2325

112 /B.IO'SIBUJHOIPJOJXO'SOIlBIIIJOJUIOICI/ﬁdllq 111011 pep1201umoq

9IOZ ‘Ig lsnﬁnv uo ::

J. Wang et aI.

 

After inserting all the keywords of record r into the trie and the record id
of r into their corresponding inverted lists, we can simply append the record
id of r with its corresponding keyword ids into the forward index. In this
scenario, for a query, if we reach a leaf node in the trie, we need to consider
both its primary and secondary inverted lists. The rest of the search process
will be the same as before.

3 RESULTS

3.1 System implementation

The iPubMed web server was set up using Apache2 on a Linux
machine. The web server has a broker which receives a query from
a user, and sends the query to the Fasthi Servers in the cluster.
In order to process queries over 19 million records, the current
iPubMed system at Tsinghua University is using a cluster of two
slave machines, each with four Intel Xeon E5420 (2.5 GHz) CPUs
and 16G DDR2—800 memory. The system at UCI is using a cluster
of four slave machines, each with two AMD Opteron 248 (2.2 GHz)
CPUs and 8G DDR2—800 memory. In the rest of the article, we
focus on the cluster at UCI and run our experiments in this cluster.
Each slave at UCI has two Fasthi Servers and each server builds its
local index on its local data (about 2.4 million records). The data are
partitioned through these eight processes by round—robin partitioning
to do the load balancing. The backend was implemented as a FastCGI
server process, written in C++, compiled with a GNU compiler.
Indexes were constructed on six most commonly searched attributes:
authors, their afﬁliations, article title, journal name, journal issue
and MESH headings. Table 2 shows the size of the dataset, index
size and index—construction time. These numbers are the sum of the

Table 2. Total index size and construction time for four slaves each with
two processes

 

Record number 19 million
Total size of indexed attributes 5.8 GB
Number of distinct keywords 3.07 million
Index construction time (for each 320 s
process)

Trie size 1.82 GB
Inverted—list size 2.65 GB
Forward—index size 2.65 GB

 

E

60

50

40

30

 

20 Queries with no errors

Average Search Time (ms)

10 'I- Queries with errors

1 2 3 4
Number of keywords

sizes across eight processes. In the future, if the total size of the
index structures in one processor exceeds the memory limit; we can
add more machines to the cluster.

3.2 User interface

The iPubMed interface is designed to show the query results in a
user friendly way. Figure 1 demonstrates an example of a query
results. In this interface, a user can specify whether to use fuzzy
search feature. If this feature is disabled, only the exact matches
to a query will be displayed. Furthermore, the fuzzy matches and
exact matches are highlighted with different colors to make them
more distinguishable. The interface has also a pagination feature for
navigation through the different pages of the results.

3.3 Query performance

We evaluated the query performance as the number of keywords
increased. Two types of queries were generated: the ﬁrst one
consisting of keywords randomly chosen from the dataset, and the
second one consisting of modiﬁed queries from the ﬁrst type by
adding 1 edit error to each keyword. Each query asked for 10 best
records. The average query response time for a query is shown in
Figure 6a, which demonstrates that the algorithms can answer a
single—keyword query very efﬁciently (within 20 ms) for both types
of queries. The processing time for multiple—keyword queries is
typically longer; however, it is still within a millisecond range. Our
algorithm caches the earlier results and uses them to calculate the
new result set incrementally. It intersects the earlier results with
the results of the new query keyword. Thus, the average search time
may also decrease if the last query keywords are very restrictive. We
see such a behavior in the results of exact match for four—keyword
queries.

We also measured the query time as the number of characters
increased in the query keyword. We generated single—keyword
queries that asked for 10 best records incrementally starting from the
third keystroke to the tenth keystroke. The average query response
time for each keystroke is shown in Figure 6b. Since all the queries
have single keyword, the time does not include intersecting any
inverted list. So the time to retrieve the best 10 records is expected
to be very similar no matter how many characters the keyword has.
However, the ﬁgure shows that our algorithms can speedup the later
queries by caching the former results.

3

60

50

4o

30

20

10

Average Search Time (ms)

3 4 5 6 7 8 9 1 0
Number of characters

Fig. 6. (3) Average search time for queries with different numbers of keywords. (b) Average search time for queries with different numbers of characters.

 

2326

112 /B.IO'SIBUJnOIpJOJXO'SOIlBIHJOJUIOICI/ﬁdnq 111011 pep1201umoq

9IOZ ‘Ig lsnﬁnv uo ::

Interactive and fuzzy search

 

3.4 Incremental updates

MEDLINE is a highly dynamic database with thousands of
publication records added or revised each day. Therefore, it is
important for iPubMed to be able to keep up with these daily changes
and update the internal data structures quickly and efﬁciently. In
our current implementation, we download the update ﬁles from the
NLM FTP server every day and use incremental—update techniques
to maintain the trie structure, inverted lists and forward index (see
Section 2.6). This allows us to process inserted, revised, and deleted
records without reconstructing the whole structure from scratch.
Instead of spending 320 s to reconstruct the index structures, we
incrementally update the structures around 15 s in average.

4 DISCUSSION

We described a new system for searching the MEDLINE database,
implemented in a fully functional server called iPubMed. Comparing
with the most widely used PubMed system at NCBI, the iPubMed
system contains two unique features: (i) being interactive, returning
search results on the ﬂy and allowing users to change queries
adaptively, and (ii) allowing approximate search.

We emphasize that our goal is not to replace the PubMed system,
which contains a number of useful features not implemented in
iPubMed, such as limiting search within different ﬁelds, allowing
boolean operations and so on. If a user knows exactly the authors
and the title of the paper he or she wants to ﬁnd, the PubMed system
is sufﬁcient for the task. Instead, iPubMed is targeting at a different
category of searches, in which the users have uncertain or partial
information regarding the publication records that they would like
to ﬁnd as showed in Figure 1. Through interactive search, iPubMed
allows users to reﬁne and/or modify queries on the ﬂy without the
need of issuing separate, independent queries as in PubMed.

Although iPubMed is fully functional in its current form, there
is a lot of room for further improvement. Currently, iPubMed does
not search abstracts of articles due to computational constraints.
In the future, we plan to increase the scalability of the system by
utilizing parallel computing and expanding system hardware. We
also plan to increase the functionality of iPubMed in several other
directions, such as limiting search in different ﬁelds and allowing
boolean operations. Our goal is to make iPubMed a truly practical
and useful tool for biomedical researchers.

Funding: Google and Microsoft; the National Natural Science
Foundation of China (60873065); the National High Technology
Development 863 Program of China (2007AA012152,
2009AA011906); the National Grand Fundamental Research
973 Program of China (2006CB303103) in part.

Conﬂict of Interest: the authors declare ﬁnancial interest in
Bimaple Technologies Inc., which is commercializing the algorithms
described in this publication.

REFERENCES

Bast,H. and Weber,l. (2006) Type less, ﬁnd more: fast autocompletion search with a
succinct index. Proc. ACM SIGIR 2006, ACM, pp. 364—371.

Gusﬁeld,D. (1997) Algorithms on Strings, Trees, and Sequences: Computer Science and
Computational Biology. Cambridge University Press, New York, NY, USA.

Ji,S. et al. (2009) Efﬁcient interactive fuzzy keyword search. Proceedings of the 18th
International Conference on World Wide Web, 2009, ACM, pp. 371—380.

Lewis,J. et al. (2006) Text similarity: an alternative way to search MEDLINE.
Bioinformatics, 22, 2298—2304.

N avarro,G (2001) A guided tour to approximate string matching. ACM Comput. Surv.
Arch, 33, 31—88.

Wildemuth,B.M. and Moore,M.E. (1995) End-user search behaviors and their
relationship to search effectiveness. Bull. Med. Libr. Assoc, 83, 294—304.

 

2327

112 /§.IO'SIBUJHOIPJOJXO'SOIlBIHJOJUIOICI/ﬁdnq 111011 pep1201umoq

9IOZ ‘Ig lsnﬁnv uo ::

