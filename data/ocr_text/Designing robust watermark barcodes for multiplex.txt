Bioinformatics Advance Access published June 22, 2016

Bioinformatics, 2016, 1—7

doi: 10.1093/bioinformatics/btw322

Advance Access Publication Date: 3 June 2016
Original Paper

 

Sequence analysis

Designing robust watermark barcodes for
multiplex long-read sequencing

Joaquin Ezpeleta1'2'*, Flavia J. Krsticevic1, Pilar Bulacio1'2 and
Elizabeth Tapia1'2

1Centro Internacional Franco Argentino de Ciencias de la Informacién y de Sistemas, Rosario SZOOOEZP, Argentina
and 2Facultad de Ciencias Exactas, Ingenierl’a y Agrimensura, Universidad Nacional de Rosario, Rosario
SZOOOBTP, Argentina

*To whom correspondence should be addressed.
Associate Editor: Cenk Sahinalp

Received on April 8, 2016; revised on April 28, 2016; accepted on May 16, 2016

Abstract

Motivation: To attain acceptable sample misassignment rates, current approaches to multiplex
single-molecule real-time sequencing require upstream quality improvement, which is obtained
from multiple passes over the sequenced insert and significantly reduces the effective read length.
In order to fully exploit the raw read length on multiplex applications, robust barcodes capable of
dealing with the full single-pass error rates are needed.

Results: We present a method for designing sequencing barcodes that can withstand a large num-
ber of insertion, deletion and substitution errors and are suitable for use in multiplex single-
molecule real-time sequencing. The manuscript focuses on the design of barcodes for full-length
single-pass reads, impaired by challenging error rates in the order of 11%. The proposed barcodes
can multiplex hundreds or thousands of samples while achieving sample misassignment probabil-
ities as low as 10‘7 under the above conditions, and are designed to be compatible with chemical
constraints imposed by the sequencing process.

Availability and Implementation: Software tools for constructing watermark barcode sets and
demultiplexing barcoded reads, together with example sets of barcodes and synthetic barcoded
reads, are freely available at www.cifasis-conicet.gov.ar/ezpeleta/NS-watermark.

Contact: ezpeleta@cifasis-conicet.gov.ar

 

1 Introduction

 

Single-Molecule Real-Time (SMRT) sequencing, with average read
lengths of ~10 kbp (Jiao et al., 2013), is poised to remarkably sim-
plify genome assembly and targeted sequencing in many applica-
tions (Carneiro et al., 2012; Guo et al., 2015; Koren and Phillippy,
2015). In this new era, DNA reads are considerably longer, but un-
fortunately corrupted by unusually high rates of sequencing errors.
For SMRT sequencing, error rates of ~11% (Korlach, 2013), with a
predominance of insertions/deletions (indels) and only ~1% substi-
tution errors (Carneiro et al., 2012), must be considered.
Fortunately, in any information transmission process affected by
noise—in this case SMRT sequencing—errors can be corrected by
adding enough redundancy to transmitted information—in this case

DNA sequences—(Gallager, 1968). The simplest way to add redun-
dancy is to transmit multiple copies of the information in the hope
that it will be possible to recover the original data through some
form of consensus. This is, for example, the rationale behind gen-
ome oversampling or coverage, which is used across sequencing
technologies to obtain virtually error-free sequences from noisy
reads. We will see, however, that this approach cannot be directly
applied to parallel multiplex (Hamady et al., 2008) SMRT sequenc-
ing without sacrificing the much desirable read length.

Multiplex sequencing relies on the use of short oligonucleotides,
known as barcodes, to tag DNA fragments belonging to different
samples, which provides a means for translating the massive through-
put of next-generation sequencing (NGS) technologies into reduced

©The Author 2016. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 1

9mg ‘09 isnﬁnV uo salaﬁuV soq ‘eiulomeg JO AiiSJQAiu [1 112 ﬂJO'sleumo[pJOJXO'soneuuoguioiq/ﬁdnq mog papeolumoq

J.Ezpeleta et al.

 

sequencing costs. Barcodes are sequenced and identified to assign
each read to a sample, which is known as demultiplexing. A variant
of SMRT sequencing called Circular Consensus Sequencing (CCS),
which provides more accurate reads, is generally advised for SMRT
multiplex applications (Travers et al., 2010). In this variant, SMRT
reads of improved quality are generated from intramolecular consen-
sus over subreads obtained from multiple (2 2X) polymerase passes
along a circularized sequencing template, which follows the repetition
approach described above. With CCS, however, the length of native
reads is reduced by a factor equal to the number of polymerase
passes. To attain Illumina-level quality values, about five passes
are needed and the effective read length drops to a few kilobases
(Jiao et al., 2013).

For the longer read length afforded by SMRT sequencing to be
fully leveraged, multiplexing would need to work directly with
single-pass reads, known as Continuous Long Reads (CLRs). In this
scenario, all error correction would depend on redundancy
embedded in the barcodes themselves. However, it has been noted
that current barcodes for SMRT-CCS reads, with lengths below
20 nt, are not sufficiently robust and that longer barcodes would be
needed for this purpose (Wang et al., 2015 ). This comes as no sur-
prise, since most existing SMRT-CCS barcodes are obtained by
imposing a minimum edit distance constraint to sets of random se-
quences (Buschmann and Bystrykh, 2013), a design method known
to scale poorly with increasing barcode length (Masek and Paterson,
1980). To overcome the limitations of random barcodes in general
multiplex SMRT sequencing applications, systematic barcodes can
be alternatively explored.

Recently, watermark barcodes, a class of systematic barcodes
able to deal with sequencing indels and substitutions, have been pro-
posed by Kracht and Schober (2015 ). These are inspired in the de-
sign of watermark error correcting codes (Davey and MacKay,
2001), originally developed to deal with synchronization and substi-
tution errors in digital communications. In these applications, syn-
chronization errors are modeled as the random insertion and
deletion of symbols (Levenshtein, 1966), and are thus assimilable to
sequencing indels.

Brieﬂy, watermark codes consist of an information-containing
carrier sequence imprinted with an arbitrary but fixed sequence of
equal length, known as watermark. In the original formulation of
watermark codes, the carrier sequence is sparse, meaning it contains
a majority of null or ‘zero’ symbols (i.e. symbols which, when im-
printed with—or added to—another, will not modify it, much like
zero in regular arithmetic). To obtain this carrier sequence, an infor-
mation message is protected by a tandem of two error correcting
codes, known as outer and inner code. Both of these embed redun-
dancy in the form of additional symbols, so that the resulting se-
quence is considerably longer than the original message. For
example, one of a set of 48 DNA samples, which in principle re-
quires only three bases (43 = 64 2 48), might be represented by a
carrier of, say, 16 symbols, most of the null type. When the water-
mark is imprinted over the carrier, the sparse constraint implies that
the resulting sequence will match the watermark at most positions.
Since the watermark is known to the decoder, this similarity pro-
vides a means to maintain synchronization in the presence of ran-
dom insertions and deletions. Substitution errors which remain after
achieving synchronization are dealt with through regular error cor-
rection, making use of available redundancy.

Although watermark barcodes appear promising, their practical
design for sequencing applications remains an open problem: for
SMRT-CLR sequencing error rates, even the best barcodes reported
by Kracht and Schober (2015) yield sample misassignment rates in

the vicinity of 5%. In this paper, we revisit the design of DNA barc-
odes around the watermark concept. As opposed to Kracht and
Schober (2015 ), we consider short low-density parity check (LDPC)
codes (MacKay, 1999) as outer codes, which offer the interesting
possibility of discarding very noisy reads rather than risk erroneous
decoding. In addition, as our main contribution, the key watermark-
carrier imprinting that conveys resilience to challenging insertion
and deletion errors is modified so that non-sparse carriers are now
allowed. This is accomplished by introducing a non-sparse inner
code and an appropriate decoding algorithm adapted from Briffa
et al. (2010), and is shown to significantly improve multiplexing per-
formance. Further, we propose an algorithm that leverages know-
ledge about the chemical context where the barcodes are embedded
to detect their boundaries. Finally, we show that the number of
barcodes which are chemically suitable for use on the sequencing
platform can be increased by exploiting the arbitrariness of the
watermark. Together, these design enhancements define the flexible
class of non-sparse watermark (NS-watermark) barcodes, which
offer high multiplexing capacity and are sufficiently robust for use
in SMRT-CLR sequencing applications.

2 Approach

To allow correct demultiplexing in the presence of errors, redun-
dancy must be added to sequencing barcodes. While this can be
done directly in the domain where errors naturally occur, it has been
shown that better performance can be achieved by ‘packing’ low-
level symbols together and designing codes in higher order finite
fields (Davey and MacKay, 1998). A finite field of order q, denoted
by E], is an alphabet of q symbols with special rules for addition,
subtraction, multiplication and division. Watermark barcodes,
introduced by Kracht and Schober (2015) and revisited here, exploit
the above fact and embed redundancy into an information message
through a combination of an outer code, defined on a high order fi-
nite field RI and an inner code, which operates at the level of nucleo-
tides or quaternary (F4) symbols.

2.1 Watermark barcodes based on short LDPC outer
codes

The outer code adds redundancy to an information message, which
encodes the sample number, to protect it against substitution errors.
This message is represented as a sequence x of length k whose elem-
ents belong to RI, i.e. x E IFS. Redundancy is introduced by a linear
error correcting code, which encodes each of the qk possible values of
x into an ‘outer codeword’ d 6 F3 of length n, that carries k inform-
ative symbols and m := n — k redundant ones (Fig. 1). In a linear
code, redundancy is added in such a way that the elements d,- of d sat-
isfy a series of linear constraints (e.g. d4 = 3d1 + 4d2). In Kracht and
Schober (2015), tabulated linear codes found by exhaustive methods
and collected in Grassl (2006) were used as outer codes. Instead, we
preserve the original formulation of watermark codes relying on
powerful LDPC codes (MacKay, 1999). In particular, we use short
quaternary LDPC codes developed by Tapia et al. (2015) for DNA
barcoding applications affected mainly by substitution errors. These
can be easily extended to arbitrary order fields, unlike the codes col-
lected in Grassl (2006), currently limited to F9.

2.2 Watermark barcodes based on non-sparse inner
codes

Given an outer codeword d, the inner code expands each symbol
d,- E E] into a quaternary sequence ed, of fixed length u, taken

9mg ‘09 isnﬁnV uo salaﬁuV soq ‘eiulomeg JO AiiSJQAiu [1 112 ﬂJO'sleumo[pJOJXO'soneuuoguioiq/ﬁdnq mog papeolumoq

Designing robust watermark barcodes

 

 

 

 

 

 

 

 

 

 

 X 5
d7; ed,-
IF I Linear encoder I 0 3 1 2
q A 1 2 1 3
rTT-TT'E rTT-TT‘: rTT-TT'E 2 3 0 2
d    3 0 2 3
Addition over F4: 3        (edl' ' ' ed”) 151 (2) 3 i
®0m3e cﬂEﬂﬂﬂﬂﬂEIEEEIEE 61m
0 0123 EBEBEBEBEBEBEBEBEBEBEBEBEBEBEB 7 210
w,- 1 1032 IE“4 WEE
2 2 3 0 1 b = 0 EB W
3  b iii? i4 01 23
i  11.14 —> N:
A T
N  N C G

Fig. 1. Construction of a NS-watermark barcode, illustrated for the message x = 21 6 F2, representing a particular sample number, and for parameters q=8,
n=5, k= 2, m=3 and u=3. The specific inner codebook 8 and mapping F4 —> N used are shown on the right. The definition of addition over F4 is shown on the

left. The linear encoder is assumed to enforce the following linear constraints: d1=x1; d2 =x2; d3 = 2x1 + xz; d4 = x1 + xz; d5 = 2x1 + 2xz

from an inner codebook 8 of size q x u. As a result of this expansion,
quaternary carriers c of length l :2 nu are obtained. Carriers are
then imprinted with a known quaternary watermark sequence w of
the same length (by simple symbol-wise addition over F4), resulting
in imprinted sequences b. Finally, using a fixed mapping from F4
into the ‘nucleotide space’ N := {A, C, T, G}, a set of q" candidate
barcode sequences is obtained (Fig. 1). Davey and MacKay (2001),
as well as Kracht and Schober (2015 ), constrain the sequences of 8
(e0 through eq_1) to be sparse. This helps achieve synchronization
by introducing relatively few modifications to the watermark.
However, it is accomplished at the expense of increased similarity
between watermark-imprinted codewords, which may in turn lead
to diminished error correction performance. Still, if codewords are
sufficiently long (e.g. with hundreds or thousands of symbols, as in
communication applications), the blessing face of dimensionality
turns such effect unnoticeable. Conversely, if the length of code-
words is reduced to the range of tens of symbols, as in the case of
DNA barcodes, similarity between codewords may become a major
concern, particularly at high levels of noise, as in the case of SMRT-
CLR sequencing. This may explain the poor performance of water-
mark barcodes recently proposed by Kracht and Schober (2015 ) for
this range of error rates. To overcome this problem, we instead se-
lect the sequences of 8 with no constraints other than large pairwise
hamming distance (i.e. choosing them to be as different as possible).
As a result, the minimum edit distance factor, which is key for the
performance of any coding scheme, improves significantly.

2.3 Barcode filtering

Of the initial M :2 qk candidate barcode sequences, only a reduced
number B will be chemically suitable for the SMRT sequencing plat-
form. Different factors can reduce multiplexing capacity, including
GC content, homopolymers, primer dimer formation and compati-
bility with sequencing adapters. In order to account for these effects
and filter out unsuitable barcodes, we consider a filtering stage
based on a version of the barcrawl filtering tool (Frank, 2009)
adapted to accept external candidate barcodes. Specifically, barco-
des are filtered based on the following criteria: GC content between
35% and 65%, maximum homopolymer length of 5, maximum het-
eroduplex length of 6 and maximum hairpin length of 6. This filter-
ing stage considers not only the individual barcodes but also their

compatibility with one another and with the SMRT sequencing
adapter.

2.4 On the choice of the watermark sequence

As long as it is fixed and known, the watermark can be arbitrarily
chosen, and a random sequence is the usual choice (Davey and
MacKay, 2001; Kracht and Schober, 2015 ). However, random
watermarks can perform poorly when it comes to satisfying chem-
ical constraints. To overcome this limitation, we propose a method
that exploits the arbitrariness of the watermark string to minimize
the loss of multiplexing capacity due to chemical constraints. More
precisely, we traverse the watermark from left to right and, at each
position, select the base which maximizes the number of surviving
barcodes after the barcrawl filtering stage. This process is repeated
until no improvement is achieved in an entire pass (indicating a local
minimum). At this point, a fixed number of bases are changed at
random before traversing the pattern again. In essence, this is an
iterated local search (Gendreau and Potvin, 2010) where the number
of barcodes lost during the filtering stage is taken as the cost
function. For the seven NS-watermark barcode sets discussed
later in this paper, this simple heuristic approach yields an average
~1.5-fold increase in multiplexing capacity relative to the use of
random watermarks, with no apparent degradation in multiplexing
performance.

2.5 A model for SMRT sequencing errors

In order to formally describe indels and substitutions introduced by
the sequencing process, DNA sequences were modeled as being trans-
mitted over a noisy channel. For this purpose, the Insertion Deletion
Substitution (IDS) channel model, defined by Davey and MacKay
(2001) and adapted to sequencing by Kracht and Schober (2015), was
considered (Fig. 2). For each incoming base, a random base can be in-
serted with probability P, (which can happen a maximum of I times),
and then the current base is either deleted with probability Pd or
sequenced (‘transmitted’) with probability Pt. Sequenced bases can
themselves be correctly sequenced with probability 1 — PS or suffer a
substitution error with probability PS. When a substitution occurs, the
three possible base replacements are equiprobable.

9mg ‘09 1sn8nV uo salaﬁuV soq ‘121u101n123 10 A1iSJQAiu [1 112 [glO'SIBILInO[plOJXO'SODBIILIOJHlOlQ/[Z(11111 111011 papeolumoq

J.Ezpeleta et al.

 

Pt Ps

   

Fig. 2. IDS model for errors affecting individual bases tiduring the sequencing
process

2.6 Demultiplexing NS-watermark barcodes

To demultiplex corrupted watermark barcodes, a two-step decoding
process is used. An inner decoder first processes the raw received se-
quence, affected by indels and substitutions, and produces an outer
codeword corrupted only by probabilistic substitution errors. This
codeword then enters an outer decoder which recovers the original
information, i.e. the sample number.

2.6.1 Inner decoding
Let r be the sequence of quaternary symbols obtained by sequencing
a NS-watermark barcode and mapping it back from N to F4. We
know that r ultimately comes from an outer codeword d whose sym-
bols d1...dn have been expanded into sequences of size u and
watermarked before being sequenced. Based on this, let 1',- be the
subsequence of 1' that corresponds to d,. If no indels occur,
1',- = [r(,-_1),,+1 . . .rm]. If we do admit indels and define the drift x,- at
the start of the transmission of d,- as the difference between inser-
tions and deletions up to that point, then r,- = [r(,-_1),,+1+xi . ..
maﬁa +1)]. Since the probability of an indel occurring does not depend
on errors made in the past, the Markov property P(x,~+1|x,- . . .x1) =
P(x,~+1|x,-) holds for drift variables. Therefore, the process of
sequencing expanded and watermarked codeword symbols d,- can be
modeled as a Hidden Markov Model (HMM) M of the Mealy
type (with emissions on transitions), with drifts x,- defined in some
space X as hidden states and subsequences r,- as observables (Fig. 3).
Given M, the well-known forward—backward (FB) algorithm
can be applied to calculate the likelihoods L(d,- = a) :2 P(r|d,- = a)
for i = 1 and a = 0...q — 1, which will initialize the outer

 

decoder:
L(d,- = a) = Z P(r_,x,- = x‘)
x—,x+EXT
13(fi,xi+1 = x+|di = a,xz‘ = x_ZP(r+lxi+1 = 96+), (1)
P(r,-,x— Qua-=4) Bilge)
where 1" :2 [r1...r,-_1] and r+ :2 [ri+1...rn]. In (1), Fi(x_) and

Bi+1(x+) are known as forward and backward quantities, respect-
ively, and can be computed from M using the standard formula-
tion of the FB algorithm, namely:

Fi(xf) = Z Fi_1(x’7)P(r,-_1,xf_ —>xf|d,-_1 2a) and (2)
x]? E X
a 6 Fl

Bk(xb) = Z Bk+1(x;)P(rkaxb —> xzfldk = 60- (3)
x; E X
a 6 Fl

The calculation of forward quantities is made recursively from
an initial boundary condition F1  (representing a priori knowledge
about the initial drift) and is known as a ‘forward pass’. Similarly,
the recursive calculation of backward quantities from a final

 

ioio

Fig. 3. HMM M for inner decoding. The double circle represents a boundary
condition

boundary condition Bn+1  (representing a priori knowledge about
the final drift) is known as a ‘backward pass’.

In (1), (2) and (3), terms of the form P(r5,x1 —> x2|d5 = a) repre-
sent the probability that drift changes from x1 to x; during the trans-
mission of dS and such transmission results in the reception of r5,
given that dS is equal to a. To compute these quantities, let t, be the
transmitted substring that would correspond to dS if dS were indeed
equal to a (i.e. ea plus the appropriate symbols of w, namely
w(5_1)u+1...wsu). Further, note that the probability of receiving 1',
and the drift changing from x1 to x; is equal to the probability of
receiving 1', and the drift changing by Ax := x2 — x1, since the prob-
ability of new indels does not depend on the current drift. Moreover,
the drift change Ax is implicit in the lengths of 1's and t5, since
Ax = len(rs) — len(ts). In light of the above, P(r5,x1 —> x2|d5 = a)
can be simplified to P(r5 |ts).

To calculate P(r5|ts), we introduce a new HMM H (Fig. 4),
which is analogous to M except that hidden variables 61...6u
defined in some space A now represent the drift before transmitting
each individual nucleotide and observables p1 . . . pu represent (pos-
sibly empty) strings received from the transmission of a single nu-
cleotide through the IDS channel model (Fig. 2).

P(r5|ts) is then calculated by performing a nucleotide-level for-
ward pass over the u states of H, according to (4) and (5) below:

P(rs|ts) = fu+1(len(rs) _ len(ts)) (4)

(2(5) 2 Z

5-e(An{5—1,...,5+1})

fy—1(5_)P(py_1lty—1), (5 )

where ty_1 is the (y — 1)-th quaternary symbol of t, and P(py_1|ty_1)
is the robability of receiving the (possibly empty) string
py_1 :2 ﬁqﬂ +61 ...r5(y_1+6) from the transmission of ty_1, which is
calculated according to (6) below. The boundary conditions for (5 )
are f1(6) = 1 for 5 = 0, and f1(6) = 0 for any other 5, because the
local drift before transmitting any symbols is necessarily 0. A
nucleotide-level backward pass, needed for the boundary estimation
algorithm, is handled analogously to (4).

The emission probability P(p*|t*) of receiving a substring p*
from the transmission of a single quaternary symbol t* can be ob-
tained by inspection of the IDS channel model (Fig. 2):

r Pd ifu=0
Pi “ Pi “‘11 . * *
 Pd+(Z) gPtPs 1f1§ﬂ<1+1ypﬂ7ét

Pi 'u Pi 'u_1
(—) Pd+(— Pt(1_Ps) if1£u<1+1,p;=t*

 

4 4
PW’lt’k):< P 11
 §(1—Pd)Ps ifu=1+1,p;’;7ét*
P- I
(:1 (I—del—P.) ifu=1+1,p;’;=t*
( 0 otherwise,

where u :2 len(p*).

9mg ‘09 1sn8nV uo salaﬁuV soq ‘121u101n123 10 AllSJQAlII [1 112 [glO'SIBILInO[plOJXO'SODBIILIOJHlOlQ/[Z(11111 111011 papeolumoq

Designing robust watermark barcodes

 

p1 p2 pu—l pu

Fig. 4. Nucleotide-level HMM H. The double circle represents a boundary
condition

The summations on (1), (2) and (3) should in principle iterate
over the space of all possible drift values, which is computationally
impractical. To reduce complexity, the iteration is limited to an
‘outer drift space’ X :2 {xmim xmax}, which equates to considering a
maximum drift of xmX and a minimum drift of xmin throughout the
transmission of the current barcode. Similarly, when calculating
nucleotide-level passes according to (5 ), an ‘inner drift space’
A :2 {5mm 5mm} is considered, which equates to considering a max-
imum local drift of 5max and a minimum local drift of 6min during
the transmission of a single outer symbol.

2.6.2 Outer decoding

By computing the likelihoods L(d,-) (i.e. the likelihood that each sym-
bol of d took each of the q possible values), the inner decoder effect-
ively transforms any combination of indels and substitution errors
affecting 1' into probabilistic substitution errors, for which the outer
linear code was specifically designed. Given these likelihoods, generic
linear codes can be decoded using Maximum-Likelihood (ML)
approaches, which select the codeword that maximizes the probabil-
ity of receiving 1'. While this is mathematically optimal, there always
exists a codeword which maximizes such probability and, thus,
decoding never fails. As noted by Tapia et al. (2015), incomplete
decoders (i.e. decoders that report a decoding failure when the result
is ambiguous) can be used instead to provide a tradeoff between
detected errors (read losses) and undetected errors (sample misassign-
ments). In multiplex sequencing applications, it is usually far prefer-
able to discard a read than to assign it to an incorrect sample.
Additionally, ML decoding scales poorly (Wolf, 1978), which
becomes prohibitive as we explore longer barcodes and higher multi-
plexing capacities.

In the particular case of LDPC codes, an iterative decoding algo-
rithm known as Belief Propagation (BP) (MacKay, 1999) can be
used instead to simultaneously address both issues. Specifically,
complexity now scales linearly with n (Davey and MacKay, 1998),
while the maximum number of iterations can be used to control the
tradeoff between read losses and sample misassignments, as ex-
plained below. Although the details are outside the scope of this
manuscript, BP can be intuitively understood as a message passing
algorithm on a graph like that shown in Figure 5. The graph
includes a set of variable nodes (labeled d1 through d") which repre-
sent the n symbols of an outer codeword, a set of constraint
nodes (labeled +) and a set of connecting edges. A constraint node is
said to be satisfied if the sum of variable nodes connected to it is
zero (with addition defined over the corresponding finite field and
each variable weighted by an appropriate constant). Connecting
edges are drawn so that every constraint is simultaneously satisfied
if and only if a set of values for d1 through d" forms a valid code-
word, thus providing a compact graphic representation of the code
structure. Decoding begins with an initial guess for the probability
distribution of each variable node, given by L(d,- = a), as calculated
by the inner decoder. If the value with the highest probability is
selected for each variable node (which is known as ‘hard threshold-
ing’) and the resulting set of values satisfies every constraint, a valid
codeword has been found and decoding stops. If, however, at least

 

 

 

Fig. 5. Illustration of the outer decoding of an LDPC code via Belief
Propagation. Edge weights and belief messages are shown only for the first
constraint, which is 2d1 + 3d3 + 2d,, = 0 (with Fq arithmetic)

one constraint is not satisfied, the BP algorithm draws progressively
close to a valid codeword by iteratively exchanging belief ‘messages’
between variable and check nodes. After a variable number of iter-
ations, the algorithm is expected to converge to a distribution which,
when hard thresholded, satisfies every constraint and thus corres-
ponds to a valid codeword. If this does not occur within a prede-
fined number of iterations, a decoding failure is reported. In our
sequencing context, the latter means that the received sequence is
too noisy to be confidently decoded and the read is simply discarded.
If we admit few iterations, only barcodes with few errors will reach
convergence and decoding will be very conservative (few sample
misassignments but many discarded reads). Conversely, if we admit
many iterations, fewer reads are discarded but more reads are
misassigned.

2.7 Context-aware boundary estimation

The forward and backward passes in the inner decoder require bound-
ary conditions given by F1  and Bn+1 (x), respectively. If the barcode
were sequenced in isolation, then F1 would be 1 for x: 0 and 0
otherwise (the drift at the start of the barcode would be necessarily 0).
Similarly, Bn+1  would be 1 for x = len(r) — len(b) and 0 otherwise
(the final drift would be known). In practice, however, a sequencing
read includes not only the barcode but also the sequenced insert and
certain platform-specific sequences, with no clear boundaries between
them. For multiplex SMRT sequencing, a typical experimental setup is
known as ‘Barcoded Universal Primer’ (Pacific Biosciences, 2015),
where the insert is capped by a so-called SMRTbellTM adapter
(Travers et al., 2010), as shown in Figure 6. In an error-free read, the
barcode will be ﬂanked to the left by a 12-nucleotide sequence located
immediately after the primer annealing site and to the right by a 30-nu-
cleotide consensus sequence, followed by the insert. If indels occur, bar-
code boundaries may shift relative to their expected positions, and this
must be taken into account for successful decoding. A simple approach
to do this is to consider a uniform distribution for F1  and Bn+1 (x),
as done by Kracht and Schober (2015 ). However, since the ﬂanking
sequences are known, a better result can be obtained by using these as
synchronizing markers. Specifically, the left barcode boundary (B) is
estimated by performing a nucleotide-level forward pass along the
12-nucleotide left ﬂanking sequence. Because sequencing begins at this
point, this forward pass can itself be initialized with a drift of 0 at the
start of the left ﬂanking sequence (A). Similarly, the right barcode
boundary (C) is estimated by performing a nucleotide-level backward
pass along the 30-nucleotide consensus sequence, which is initialized
with a uniform distribution at the end of such sequence (D).

3 Methods

To assess their performance in silico, existing watermark barcodes
and the proposed NS-watermark alternative were flanked to the left

9mg ‘09 1sn8nV uo salaﬁuV soq ‘121u101n123 10 AllSJQAlII [1 112 [BJO'SIBILIHO[plOJXO'SODBIILIOJHlOlQ/[Z(11111 111011 papeolumoq

J.Ezpeleta et al.

 

and right by appropriate sequences to account for the sequencing
adapter, and transmitted through the IDS channel model described pre-
viously. The sequenced insert was represented by an indefinitely long
random sequence. For codes reported by Kracht and Schober (2015 ),
the boundary estimation and decoding algorithms reported by the
authors were used. Specifically, forward and backward recursions
were initialized with a uniform distribution and a soft maximum
likelihood linear decoder (Wolf, 1978) was used as outer decoder.
For NS-watermark codes, our context-aware boundary estimation
algorithm, our inner decoder and a regular BP LDPC decoder with a
maximum of 10 iterations were used. The sample misassignment
probability Pu was then estimated by Monte Carlo simulation. For
each set of barcodes, N = 5 X 107 barcode sequences were ﬂanked,
transmitted through the channel model, passed through the appro-
priate boundary detection algorithm and decoded. Barcodes were
taken in equal numbers from the sets of filtered barcodes. The pro-
portion Pu of barcodes for which the decoder output was different
from the original sample was computed and taken as an estimate of

Pu. If Pu 7S 0, then 95% confidence intervals [13; ,P:] were com-

puted as Pu exp(i2o), where a: 4/(1 —Pu)/(NPu). If Pu = 0,
then P; = 0 and P: = 1 — exp(—2 / N) were used instead (MacKay,
1999). In the case of NS-watermarks, where the BP decoder is in-
complete and may report a decoding failure, a similar procedure
was used to estimate the read loss probability PC. The theoretical
multiplexing capacity M was calculated as 6]", while the actual num-
ber of barcodes B was obtained by counting the barcodes that were
compatible with SMRT chemical sequencing constraints (i.e. that
survived filtering). All NS-watermark barcode sets considered in this
manuscript are available at www.cifasis-conicet.gov.ar/ezpeleta/NS-
watermark.

.‘IIEID

Left ﬂanking

a _ sequence Barcode 30 nt Insert
PI'1me1‘“-lElllll7l-IIIIIIIIIIIIIEI5IEIEl- - -|:|:|:l|:llll|:ll:l
t
Iii“ A n B $311311??? D

Fig. 6. Sequencing adapter for a Barcoded Universal Primer experimental
setup. Points A, B, C and D mark the boundaries between adapter
subsequences

3.1 Multiplexing performance of watermark barcodes
Simulation experiments were performed to compare the overall ro-
bustness of watermark barcodes recently introduced by Kracht and
Schober (2015 ) and that of the proposed NS-watermark barcoding
alternative under different levels of sequencing errors (Fig. 7). For
this comparison, we selected the best codes reported by Kracht and
Schober (2015 ) in terms of error performance (6]: 7, k =2, 11: 6,
u = 6) and constructed NS-watermark barcode sets of the same
length (l = 24) with outer codes defined over F3 and F16 (both
with k = 2, n = 6, u = 4). For this simulation, mutation probabilities
Pmut E [0.01 . . . 0.15] were considered, where Pmut :2 Pi + Pd + PS
and Pi = Pd 2 P5.

3.2 Multiplexing performance of NS-watermark barco-
des for SMRT sequencing

On a second simulation, the performance of NS-watermark barco-
des of length 24, 48 and 96 with outer codes defined over F16 was
evaluated for particular error probabilities which are representative
of the SMRT error profile (Table 1). Specifically, we considered
Pi = 0.055, Pd 2 0.055 and PS 2 0.01. For each barcode length,

Table 1. Performance of NS-watermark barcodes under the SMRT
error profile

 

l M B 13e 13+ 1311 13:

e

 

24 256 232 7.2 x 10—3 7.3 x 10—3 1.7 x 10—4 1.8 x 10—4
24 4096 3567 2.3 x 10—2 2.3 x 10—2 2.5 x 10—3 2.5 x 10—3
48 256 239 7.0 x 10—5 7.2 x 10—5 2.2 x 10—7 4.0 x 10—7
48 4096 3471 2.3 x 10—4 2.4 x 10—4 1.1 x 10—6 1.4 x 10—6
96 256 164 9.8 x 10-6 1.0 x 10-5 0 4.0 x 10-8
96 4096 2163 1.0 x 10-5 1.1 x 10-5 0 4.0 x 10-8
96 65536 32136 1.9 x 10—5 2.0 x 10-5 6.2 x 10-8 2.0 x 10-7

 

Performance of NS-watermark barcode sets over F16 under the SMRT
error proﬁle for varying length l and unﬁltered multiplexing capacity M. B is

the number of barcodes, Fe is the read loss probability and Pu is the sample
+

e and P: are upper error bars for Fe and Pu,

misassignment probability. P
respectively.

 

10'1 5

|
Legend

-0- Kracht et al. (B = 49)

 

 

\( -El- NS-watermark, F8 ( B = 64)
-<>- NS-watermark, F16 ( B = 232)

’\ I

 

 

 

 

-3

\\

 

=104

 

: W \(>
10'5 V

 

\\4\

 

\\

 

 

 

\\

 

 

 

 

15 12 9

 

 

 

0 3 1 x102
P mut

Fig. 7. Sample misassignment rates for three types of 24—nucleotide barcodes as a function of the mutation probability Pmut. The number of barcodes B is shown
in parenthesis in the legend. 95% confidence intervals [P3, [3:] are shown as error bars where not negligible

9mg ‘09 1sn8nV uo salaﬁuV soq ‘121u10111123 10 A11819A1uf1 112 ﬂJO'sleumo[p101x0'831112u1101u101q/ﬁd11q 111011 papeolumoq

Designing robust watermark barcodes

 

different values of k (i.e. different multiplexing capacities) were also
considered.

4 Discussion

As seen in Figure 7, NS-watermark barcodes consistently outperform
the best watermark barcodes reported by Kracht and Schober (2015)
for the same barcode length (l = 24), while simultaneously increasing
multiplexing capacity. Additionally, results show that both the decod-
ing failure probability Pe (discarded reads) and the undetected demulti-
plexing error probability Pu (misassigned reads) decrease
monotonically with barcode length (Table 1). In connection with this,
we note that, although working with CLRs introduces significantly
higher error rates than using CCSs, it also makes it possible to use lon-
ger barcodes while keeping the relative barcoding overhead within rea-
sonable limits. For example, 96 bp barcodes, which are unfeasible for
CCS reads or short read technologies, introduce a relative overhead of
less than 1% on the average CLR of around 10 kb. Additionally, the
use of scalable design and demultiplexing algorithms makes such lon-
ger barcodes feasible from the computational point of view.

We further note that, because of the low sample misassignment
rates, correctly assigned reads are expected to vastly outnumber mis-
assigned reads for any given sample. Under these conditions, misas-
signed reads are likely to be ‘washed away’ by downstream consensus
within each sample group and, therefore, the final per-base error due
to undetected demultiplexing errors could be several orders of magni-
tude smaller than the reported sample misassignment rate.

A major advantage of the proposed NS-watermark is the flexibil-
ity it offers for code construction. Within reasonable ranges, any com-
bination of u, q, n, l, k, m, w and 8 yields an admissible barcode set.
For a given outer code length n, using more information
symbols (higher values of k, lower values of m) increases multiplexing
capacity but decreases multiplexing performance. For a given multi-
plexing capacity M and barcode length l, higher order fields (higher
values of 6]) improve the sample misassignment rate, albeit at the ex-
pense of higher read losses. For a given I, there is usually also more
than once choice for u and n such that l =nu. Of these, those with
higher u invest more redundancy in the inner code than in the outer
code and may be better suited for error profiles with high rates of in-
sertions and deletions, such as the one considered here. Conversely,
those with higher n invest more in resilience to substitution errors and
may be appropriate for more traditional error profiles.

This increased flexibility, along with the systematic construction
method, means new code configurations can be explored virtually
effortlessly to adapt to changing requirements, given by admissible
rates of read losses and sample misassignments, acceptable coding
overhead, number of samples or error profiles. In particular, our de-
sign method can be easily extended to other sequencing technologies
impaired by high rates of indels and substitution errors, notably the
much anticipated Nanopore sequencing (Akeson et al., 1999), by
appropriately tuning design-time and decoding-time parameters.

Funding

This work has been supported by the National Agency for the Advancement
of Science and Technology of Argentina through grant PICT 2012-2513.

Conﬂict of Interest: none declared.

References

Akeson,M. et al. (1999) Microsecond time-scale discrimination among poly-
cytidylic acid, polyadenylic acid, and polyuridylic acid as homopolymers or
as segments within single RNA molecules. Biophys. ]., 77, 3227—3233.

Briffa,]. et al. (2010). An improved decoding algorithm for the Davey-
MacKay construction. In: Proc. IEEE Int. Conf. Commun. (ICC), 2010, pp.
1—5.

Buschmann,T. and Bystrykh,L. (2013) Levenshtein error-correcting barcodes
for multiplexed DNA sequencing. BMC Bioinformatics, 14, 272—273.

Carneiro,M. et al. (2012) Paciﬁc biosciences sequencing technology for
genotyping and variation discovery in human data. BMC Genomics, 13,
375.

Davey,M. and MacKay,D. (1998) Low-density parity check codes over GF(q).
IEEE Commun. Lett., 2, 165—167.

Davey,M. and MacKay,D. (2001) Reliable communication over channels with
insertions, deletions, and substitutions. Inf. Theory IEEE Trans., 47,
687—698.

Frank,D. (2009) Barcrawl and bartab: software tools for the design and imple-
mentation of barcoded primers for highly multiplexed DNA sequencing.
BMC Bioinformatics, 10, 362.

Gallager,R. (1968) Information Theory and Reliable Communication. Wiley,
New York.

Gendreau,M. and Potvin,].Y. (2010) Handbook of Metaheuristics. vol. 2.
Springer, New York.

Grassl,M. (2006 ) Searching for linear codes with large minimum distance. In:
Bosma,W. and Cannon,]. (eds.) Discovering Mathematics with Magma,
Volume 19 of Algorithms and Computation in Mathematics. Springer,
Berlin, Heidelberg, pp. 287—313.

Guo,X. et al. (2015 ) SMRT sequencing for parallel analysis of multiple targets
and accurate SNP phasing. G3 (Bethesda), 5, 2801—2808.

Hamady,M. et al. (2008) Error-correcting barcoded primers for pyrosequenc-
ing hundreds of samples in multiplex. Nat. Methods, 5, 235—237.

Jiao,X. et al. (2013) A benchmark study on error assessment and quality con-
trol of CCS reads derived from the PacBio RS. ]. Data Min. Genomics
Proteomics, 4. 1—12.

Koren,S. and Phillippy,A. (2015) One chromosome, one contig: complete mi-
crobial genomes from long-read sequencing and assembly. Curr. Opin.
Microbiol., 23, 110—120.

Korlach,]. (2013) Understanding accuracy in SMRT sequencing. pacb.com/
wp-content/uploads/2015/09/Perspective_
UnderstandingAccuracySMRTSequencing.pdf. (Jan 2016, date last
accessed).

Kracht,D. and Schober,S. (2015) Insertion and deletion correcting DNA barc-
odes based on watermarks. BMC Bioinformatics, 16, 50.

Levenshtein,V. (1966) Binary codes capable of correcting deletions, insertions
and reversals. Soviet Physics Doklady, 10. 707—710.

MacKay,D. (1999) Good error-correcting codes based on very sparse matrices.
IEEE Trans. Inf. Theory, 45, 399—431.

Masek,W. and Paterson,M. (1980) A faster algorithm computing string edit
distances. ]. Comput. Syst. Sci., 20, 18—31.

Paciﬁc Biosciences. (2015 ) Multiplexing amplicons up to 10 kb. pacb.com/wp-
content/uploads/2015/09/ProductNote-Barcoded-Adapters-Barcoded-
Universal-Primers.pdf. (Jan 2016, date last accessed).

Tapia,E. et al. (2015) DNA barcoding through quaternary LDPC codes. PLoS
ONE, 10, e0140459.

Travers,K. et al. (2010) A ﬂexible and efﬁcient template format for circu-
lar consensus sequencing and SNP detection. Nucleic Acids Res., 38. e159.
Wang,M. et al. (2015 ) PacBio-LITS: a large-insert targeted sequencing method
for characterization of human disease-associated chromosomal structural

variations. BMC Genomics, 16, 214.

Wolf,]. (1978) Efﬁcient maximum likelihood decoding of linear block codes

using a trellis. IEEE Trans. Inf. Theory, 24, 76—80.

9mg ‘09 1sn8nV uo salaﬁuV soq ‘121u10111123 10 AusiaAiu [1 112 /810'S{12umo[p101x0'831112u1101u101q/ﬁd11q 111011 papeolumoq

