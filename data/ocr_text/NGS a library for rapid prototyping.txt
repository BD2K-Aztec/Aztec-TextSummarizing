APPLICATIONS NOTE W"23023b.11333/Esiigﬁalﬁitlﬁg

 

Genome analysis

Advance Access publication June 4, 2013

NGS++: a library for rapid prototyping of epigenomics

software tools

Alexei Nordell Markovitsl’l, Charles Joly Beauparlant2’l, Dominique Toupin3,
Shengrui Wangs, Arnaud Droit2’* and Nicolas Gevry”

1Department of Biology, Universite de Sherbrooke, Sherbrooke, Quebec J1 K 2R1, 2Department of Molecular Medicine,
Centre de Recherche du CHU de Quebec, Université Laval, Quebec, Quebec 61V 462 and 3Department of Computer
Science, Université de Sherbrooke, Quebec J1 K 2R1, Canada

Associate Editor: Michael Brudno

 

ABSTRACT

Motivation: The development of computational tools to enable testing
and analysis of high-throughput—sequencing data is essential to
modern genomics research. However, although multiple frameworks
have been developed to facilitate access to these tools, comparatively
little effort has been made at implementing low-level programming
libraries to increase the speed and ease of their development.
Results: We propose NGS++, a programming library in C++11 spe-
cialized in manipulating both next-generation sequencing (NGS) data-
sets and genomic information files. This library allows easy integration
of new formats and rapid prototyping of new functionalities with a
focus on the analysis of genomic regions and features. It offers a
powerful, yet versatile and easily extensible interface to read, write
and manipulate multiple genomic file formats. By standardizing the
internal data structures and presenting a common interface to the
data parser, NGS++ offers an effective framework for epigenomics
tool development.

Availability: NGS++ was written in C++ using the C++11 standard.
It requires minimal efforts to build and is well-documented via a com-
plete dochgen guide, online documentation and tutorials. Source
code, tests, code examples and documentation are available via the
website at http://www.ngsplusplus.ca and the github repository at
https://github.com/NGS-lib/NGSplusplus.

Contact: nicolas.gevry@usherbrooke.ca or arnaud.droit@crchuq.
ulaval.ca

Received on November 12, 2012; revised on May 23, 2013; accepted
on May 27, 2013

1 INTRODUCTION

Previous years have witnessed an explosion in the amount of
data produced using next-generation sequencing (NGS) technol-
ogies, as exempliﬁed by the ENCODE project (ENCODE
Project Consortium et al., 2012). However, analysis of these
enormous datasets (easily >100 GB) requires the use of a new
generation of computational tools. As the quantity of data pro-
duced by NGS machines increases, so will the time spent on
developing new tools. Although substantial efforts have been
made at integrating them into user-friendly frameworks such as

 

*To whom correspondence should be addressed.
TThe authors wish it to be known that, in their opinion, the ﬁrst two
authors should be regarded as joint First Authors.

Galaxy (Giardine et al., 2005) or GeneSpace (Genome Space),
relatively little effort has gone into providing the groundwork
needed to increase the productivity of NGS developers, such as
libraries and using standardized formats. Improvement in these
areas would allow developers to greatly accelerate the speed at
which they design and deploy new analysis software.

Although certain tool suites, such as BEDtools (Quinlan and
Hall, 2010) and BAMtools (Barnett et al., 2011), offer a library
or API to assist developers, these are generally aimed at giving
access to the existing tool functionality rather than facilitating
development of new ones. As such they are highly specialized.
The Squn library (Doring et al., 2008) offers functionality for
the developmental of future tools, but it specializes in sequence
analysis rather than genomic regions and features. Our proposed
library, NGS++, aims to ﬁll this gap by offering a powerful set
of generic and ﬂexible options to accelerate development and
prototyping of epigenomics analysis tools.

2 APPROACH

It is impossible to predict the entirety of future needs for NGS
data analysis. As such, NGS++ focuses on being a customizable
and generic library that facilitates the prototyping and imple-
mentation of new functionalities via a transparent data interface.
In this section, we summarize the three main components of
NGS++: (i) ﬁle format management, (ii) data manipulation
and (iii) functional operators.

Dealing with the wealth of existing ﬁle formats is a time con-
suming task. NGS++ offers a simple interface to parse and write
in many frequently used genomics ﬁle formats (BED, GF F /
GTF, Sam, Wig, bedGraph) using a generic data structure
named Tokens that contain a number of standard features of
genomic data entries (eg: Start/End positions, position value
and mapping quality). Additionally, the user can deﬁne ‘on-
the-ﬂy’ custom formats to deal with the plethora of datasets
that do not respect format speciﬁcations, and BAM format is
supported via integration of the BamTools API. The conversion
between most supported formats is a trivial task:

uParser parser(”ﬁlename.sam”, ”SAM”);

uWriter writer(”ﬁlename.bed”, ”BED”);

while (iparser .eof ())
writer.writeToken(parser. getNextEntryO);

 

© The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com 1893

112 ﬁhO'smumo[pJOJXO'sor1BmJOJurorw/2d11q IIIOJJ pepnorumoq

910K ‘09 lsnﬁnV no :2

A.N.Markovits et al.

 

I l w * ‘ n...“ {la-1" “Ii-5“
-: madam } I:-.ls:.~r deﬁned :
IN ‘5, ml" \‘unctgon‘f’

 
   
     

 

Experiment Generic applicators -

 

Eva-Jeni Chroma

Several Contigs

 

 

 

 

 

Manipulating interface
Cutfsubsetmuery

 

 

Writﬁ'r

Fig. 1. Typical workﬂow of the NGS++ library. Data are read by our
Parsing interface then ﬁltered as needed. User-deﬁned functions are exe-
cuted via our operators, and the transformed data are stored via our
Writer interface

The internal structure of the library is divided into a three-tiers
hierarchy separating a genomic dataset by unique scaffolds with
each of them containing any number of contigs. This hierarchy is
represented in (Fig. 1), and each level offers a number of func-
tions that can be extended via inheritance for specialized data
manipulation. Loading datasets is done through integration with
our Parser class and allows the user to easily load data:

Ta gExp.loadWithParser(inputStream,”SAM”);
RegionExp.loadWithParser(inputStream,"BED”);

NGS++ offers a powerful set of generic functions to compare,
sort, merge and modify the previously loaded data. These include
typical operations such as overlapping, merging and comparing
that allows the user to easily ﬁlter his data as needed. The
following would return tags overlapping a BED ﬁle:

auto fExp=TagExp.getOverlapping(RegionExp);

Additionally, the majority of these operators can be used on any
given feature of the data objects, including features added by the
user via inheritance. This example sorts and counts a subset
based on a new object feature:

RegionExp.sortSites([ ](uRegion iteml, uRegion
item2) {return item1.Score < item2.Score}, &
uRegion: : getScore, &uRegi on: : getScore)

int count = RegionExp.getSubsetCount(0.5,0.8);

As shown earlier in the text, this is greatly facilitated by the
inclusion of anonymous lambda functions in the C++11 stand-
ard. Using these ﬂexible operators allows the experienced devel-
oper to implement powerful modiﬁcations, whereas the default
genomic interval operators are easily usable by all.

Finally, to accommodate speciﬁc analysis needs, NGS++
offers an interface to run developer deﬁned functions and trans-
formations on the selected data. This allows the developer to
concentrate on the function he wishes to implement without
having to spend time on the underlying structure that will sup-
port it. Borrowing heavily from the functional programming
paradigm, this allows for rapid prototyping and implementation.
In the following we deﬁne and execute a function that allows us
to trivially generate a histogram of contig sizes:

map<int,int> sizeOfContigs;
uTagsExp.applyOnSites([&](uTag Elem){sizeOfContigs
[Elem.getSiZ6()]++;});

Additional functional operators exist, allowing a variety of dif-
ferent operations on the dataset. This interface wraps many of
the STL algorithms, enabling rapid parallelism via the OpenMP
standard (Dagum and Menon, 1998).

3 IMPLEMENTATION

NGS++ is written in C++ using the C++11 standard. It offers
a complete exception handling interface using the Boost excep-
tion class. A complete test suite is implemented using the Google
test platform. It has been designed for a Linux environment
using a C++11 compatible gcc compiler. Complete user guide,
tutorial and discussion are available on the web page. Source
code is hosted on GitHub.

4 CONCLUSION

Progress in the development of advanced bioinformatics analysis
tools has undoubtedly been hindered by the lack of available
programming frameworks. Our library aims to assist in ﬁlling
this gap for the community of C++ epigenomic developers by
giving them access to robust building blocks, thus reducing the
time spent on development signiﬁcantly. Our efforts are now
focused on including additional genomic formats and on increas-
ing the breath of our tutorials. Future developments will include
the integration of mid-level reusable functions, such as similarity
functions and normalization methods. The website provides a list
of tutorials and commented working code examples, to assist
developers in getting started with the library. Finally, the
GitHub should facilitate the integration of suggestions and feed-
back from the community.

Funding: Natural Sciences and Engineering Research Council of
Canada (NSERC) (to S.W.); Canadian Institutes of Health
Research (CIHR) (to N.G.); Ministere du Développement
Economique, Innovation et Exportation (MDEIE) (to AD.)
N.G. holds a Chercheur boursier (junior 1) award from the
Fond de Recherche en Santé du Quebec (F RSQ). A.D. holds a
Réseau de médecine génétique appliquée (RMGA) salary award.
C.J.B. holds a Centre de Recherche en Endocrinologie et
Génomique Humaine (CREMOGH) award.

Conﬂict of Interest: none declared.

REFERENCES

Bamett,D.W. et al. (2011) BamTools: a C++ API and toolkit for analyzing and
managing BAM ﬁles. Bioinformatics, 27, 1691—1692.

Dagum,L. and Menon,R. (1998) OpenMP: an industry standard API for shared-
memory programming. IEEE Comput. Sci. Eng., 5, 46—55.

D6ring,A. et al. (2008) Squn an efﬁcient, generic C++ library for sequence ana-
lysis. BMC Bioinformatics, 9, 11.

ENCODE Project Consortium et al. (2012) An integrated encyclopedia of DNA
elements in the human genome. Nature, 489, 57—74.

Giardine,B. et al. (2005) Galaxy: a platform for interactive large-scale genome ana-
lysis. Genome Res., 15, 1451—1455.

Genome Space. http://www.genomespace.org (18 June 2013, date last accessed).

Quinlan,A.R. and Hall,I.M. (2010) BEDTools: a ﬂexible suite of utilities for com-
paring genomic features. Bioinformatics, 26, 841—842.

 

1 894

112 ﬂJO'srnumo[pJOJXO'sot1BmJOJutotw/2d11q IIIOJJ pepnorumoq

910K ‘09 lsnﬁnV no :2

