Bioinformatics Advance Access published August 16, 2016

 

Genome analysis

H-PoP and H-PoPG: Heuristic Partitioning
Algorithms for Single Individual Haplotyping of
Polyploids

Minzhu Xie1’*, Qiong Wu 2, Jianxin Wang 3 and Tao Jiang 4’5

1 Key Laboratory of Internet of Things Technologies and Application, College of Physics and Information Science, Hunan Normal
University, Changsha 410081, China, 2State Key Laboratory of Systematic and Evolutionary Botany, Institute of Botany, Chinese
Academy of Sciences, Beijing 100093, China, 3School of Information Science and Engineering, Central South University, Changsha
410083, China, 4Department of Computer Science and Engineering, University of California, Riverside, CA 92521, USA and 5MOE
Key Lab of Bioinformatics and Bioinformatics Division, TNLIST/ Department of Computer Science and Technology, Tsinghua
University, Beijing, China

*To whom correspondence should be addressed.

Associate Editor: Dr. Inanc Birol

Abstract

Motivation: Some economically important plants including wheat and cotton have more than two copies
of each chromosome. With the decreasing cost and increasing read length of next-generation sequencing
technologies, reconstructing the multiple haplotypes of a polyploid genome from its sequence reads
becomes practical. However, the computational challenge in polyploid haplotyping is much greater than
that in diploid haplotyping, and there are few related methods.

Results: This paper models the polyploid haplotyping problem as an optimal poly-partition problem of
the reads, called the Polyploid Balanced Optimal Partition (PBOP) model. For the reads sequenced from
a k—ploid genome, the model tries to divide the reads into k groups such that the difference between
the reads of the same group is minimized while the difference between the reads of different groups is
maximized. When the genotype information is available, the model is extended to the Polyploid Balanced
Optimal Partition with Genotype constraint (PBOPG) problem. These models are all NP-hard. We propose
two heuristic algorithms, H-PoP and H-PoPG, based on dynamic programming and a strategy of limiting
the number of intermediate solutions at each iteration, to solve the two models, respectively. Extensive
experimental results on simulated and real data show that our algorithms can solve the models effectively,
and are much faster and more accurate than the recent state-of-the-art polyploid haplotyping algorithms.
The experiments also show that our algorithms can deal with long reads and deep read coverage effectively
and accurately. Furthermore, H-PoP might be applied to help determine the ploidy of an organism.
Availability: https://github.com/Minzthie/H-PoPG

Contact: xieminzhu@hotmail.com

Supplementary information: Supplementary data are available at Bioinformatics online.

9mg ‘09 1sn8nV uo salaﬁuV s01 ‘erulomeg JO AusraAru [1 112 [glO'SIBILInO[plOJXO'SODBIILIOJHlOlQ/ﬂdllq wort papeolumoq

 

1 Introduction

It is widely believed that domestication of wild plants was a key factor
leading to human population expansion about 10 thousand years ago,

 

and crops are still the most important source of human foods nowadays.
*to whom correspondence should be addressed . . . .
Therefore, crop breeding is very important for the world food secur1ty.

Most widely cultivated species of some economically important crops

1

© The Author (2016). Published by Oxford University Press. All rights reserved. For Permissions, please email:
journals.permissions@oup.com

 

such as wheat, sugarcane, apple and banana are polyploids (Leitch
and Leitch, 2008), i. e. they possess more than two copies of each
chromosome. Polyploidy has long been regarded as an important feature
to drive plant phenotypic diversiﬁcation and hence, the investigation of
polyploid genomic compositions will help understand plant evolution and
crop improvement (Renny-Byﬁeld and Wendel, 2014). With the recent
rapid development of sequencing technologies, the read length of next-
generation DNA sequencers has increased signiﬁcantly and the sequencing
cost has dropped enormously. Therefore, reconstructing the multiple
haplotypes of a polyploid genome from its DNA reads is becoming a
reality in practice.

There has been extensive research on the computational problem of
reconstructing a pair of haplotypes from the DNA reads of a diploid
genome, and many combinatorial optimization models (Xie et al., 2010a;
Browning and Browning, 2011) have been proposed, including MEC
(minimum error correction) (Lippert et al., 2002), MFR (minimum
fragment removal), MSR (minimum SNP removal) (Lancia et al., 2001),
and two recent models MFC (maximum fragments cut) (Duitama et al.,
2010) and BOP (balanced optimal partition) (Xie et al., 2012). Most of the
above models and their extended versions are NP-hard (B afna et al., 2005 ;
Cilibrasi et al., 2007; Duitama et al., 2010), and their exact algorithms
run in time exponential in at least one input parameter (B afna et al., 2005 ;
He et al., 2010; Xie et al., 2010b, 2008; Wang et al., 2010; Bonizzoni
et al., 2015; Patterson et al., 2015; Pirola et al., 2015). Therefore, a
large number of heuristic algorithms have been designed to deal with the
problem (Panconesi and Sozio, 2004; Wang et al., 2005; Genovese et al.,
2008; Duitama et al., 2010; Xie et al., 2012). In particular, integer linear
programming has been adopted recently to solve MEC, but additional
heuristic methods were also needed to process difﬁcult blocks (Chen et al.,
2013). However, the computational complexity of polyploid haplotyping
is much higher than that of diploid haplotyping. As shown in Figure 1,
with two heterozygous bi-allelic loci, there are only two possible haplotype
phasings for a diploid while there are eight possible haplotype phasings for
a triploid. Generally speaking, with n heterozygous loci, there are (k — 1)"
different genotypes and at least 2" _ 1 (k — 1) " different haplotype phasings
for a k-ploid. Simple extensions of current diploid haplotyping algorithms
are usually inefﬁcient in solving the polyploid haplotyping problem.

Recently, three polyploid haplotyping algorithms HapCompass (Aguiar
and Istrail, 2013), HapTree (Berger et al., 2014) and SDhaP (Das and
Vikalo, 2015) have been introduced in the literature. The HapCompass
algorithm converts a haplotype phasing as a spanning tree of the graph
built from DNA reads, where the nodes represent single nucleotide
polymorphisms (SNPs) and the edges indicate the evidence of co-occurring
SNP alleles in a haplotype as supported by the reads. HapCompass tries to
ﬁnd a spanning tree with the minimum weighted edges removed from the
graph based on cycle basis local optimization. HapTree uses a maximum-
likelihood estimation framework and aims to ﬁnd a haplotype phasing
solution with the maximal likelihood explanation of the reads. To reduce
computation complexity, HapTree adopts a strategy similar to dynamic
programming, i.e. it ﬁnds a collection of high-likelihood phases of the
ﬁrst n SNP loci and then extends the phases to the next n —I— 1th SNP
locus. SDhaP formulates the problem as a semi-deﬁnite program (SDP),
and employs a low-rank Lagrangian scheme followed by randomized
projections and a greedy reﬁnement of the k—ploid haplotypes to solve
the SDP (Das and Vikalo, 2015).

In this paper, we try to partition the DNA reads sequenced from a k-
ploid organism into k groups such that the reads of the same group share the
same alleles on as many SNP loci as possible and the reads from different
groups are different on as many loci as possible. We balance both factors by
proposing the Polyploid Balanced Optimal Partition (PB OP) model. Since
genotype information is easy to obtain and the genotype information may
help improve the accuracy of polyplotyping, we extend PB OP to PBOPG

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

—I—I— —'—'_
f .A' \

Genotypes: A/C G/T A/A/C G/G/T | A/A/C G/T/T | A/C/C G/G/T | A/C/C G/T/T
Possible _A_G_ _A_G_i_A_G_i_A_G_i_A_G_
hﬁglsgtygf’ —A—G—;—A—T—;—C—G-;-C-T—
png‘_C_T_ —C—T—|—C—T— —C—T— —C—T—
":‘X‘:“T": —A—G—!—A—rT—.—A—T—.—A—T—
—A—T—~—A—T—~—C—G-~-C-T—
—C—G— —C—G—!—C—G—!—C—G—!—C—G—

(a) Diploid (b) Triploid

Fig. 1. The genotypes and corresponding haplotype phasings on two heterozygous loci.

(the Polyploid Balanced Optimal Partition with Genotype constraint) to
make use of available genotype information. Both models are NP-hard. By
limiting the number of intermediate solutions at each iteration of a dynamic
programming, we designs two heuristic algorithms to solve the models.
Extensive tests on simulated and real data show that our algorithms are
much faster and more accurate than the recent state-of—the-art polyploid
haplotyping algorithms, especially on data with long reads and deep read
coverage.

2 Methods
2.1 Formulation and Problem

The input of the polyploid haplotyping problem consists of aligned DNA
reads sequenced from a k-ploid organism. In our approach, we try to divide
the reads into In different groups according to their original haplotypes.
Since it is trivial to determine the alleles of the k-haplotypes at homozygous
loci, and only loci where the reads have different alleles can be used
to partition the reads into different groups, we will only keep alleles of
the aligned reads on heterozygous SNP loci. The input aligned reads are
denoted by an m X n SNP matrix M as in previous work (Xie et al., 2008,
2012; Aguiar and Istrail, 2013; Berger et al., 2014), where m is the number
of reads and n the number of heterozygous SNP loci. M [i, j], the entry of
M at the 2th row and jth column, encodes the allele of the ith read at the
jth heterozygous SNP loci. M [i, j] takes a value from {0, 1, —}, where
‘0’ (or ‘1’) represents the major allele (or the minor allele, respectively)
at the locus in the population and ‘—’ represents an unknown allele. The
2th row (read) of M is denoted as n- and the jth allele of 'r is denoted as
r[j]. Similarly, a haplotype is denoted as a sequence of ‘0’, ‘1’ and ‘—’,
and the jth allele of a haplotype H is denoted as H [j

For two alleles a1, (12 E {0, 1, —}, we deﬁne a similarity function
5(a1, a2) and dissimilarity function d(a1, (12) as follows:

1, ifa1,a2 75 — and a1 = a2;
= 1
5(a1’a2) { 0, otherwise. ( )

1, ifa1,a2 75 — andal 75 a2;
0, otherwise.

d(a1, a2) = { (2)

Given a set R 2 {T1, ..., mp} of p rows (reads), a k-partition function
PofRis deﬁnedasamapP : {1, ...,p} —> {1, ..., k}, whichmeansthat
n- is put into the P(z')th group (subset) G p(,-) according to the function
P. Since every row in R has a unique index, the row with the smallest
index in a group is called the representative row of the group, and the
smallest index of the rows in a group G is denoted by I If G = a,
let I (G) = p —l— 1. Let the groups obtained by applying P on R be
Gf , ..., ka . A k-partition function P is called a canonical k-partition
function if the following condition holds: for any two groups G? and G 5
with 1 g 2' < j g k, 1(Gf) < 1(Gf).

The consensus haplotype H,- of the ith group G,- is deﬁned as the
haplotype that maximizes the sum of similarities between the reads in the

9mg ‘09 1sn8nV uo salaﬁuV s01 ‘BIIIJOJIIBD JO AusraAru [1 112 /3.IO'S[BII.IHO[p.IOJXO'SODBIIIJOJHIOIQ/ﬂ(11111 wort papeolumoq

 

group G,- and the haplotype, i.e.

H,- = arglrInax Z Z s(r[j],H[j]). (3)

T‘EGi j=1

Assume that the consensus haplotypes are the original haplotypes, and
the difference between the consensus haplotypes and the reads can be
regarded as sequencing errors. Given a k-partition function P on a set
of reads (rows), the corrected error measure C (P) is deﬁned as the total
difference between the reads and the consensus haplotypes of their groups,
2.6.

k: n
C(P) = Z Z Zd(riji,H.-iji)- (4)

i=1 reG, j=1

Since we only consider heterozygous loci, any two of the k haplotypes
should not be identical when several consecutive heterozygous loci are
considered together, and it is desirable that the k consensus haplotypes are
distinctively different. We introduce another measure D(P) as follows,
which is called the diversity measure:

D(P): Z Zd(Hi.ij],Hz-2iji) . <5)

i1,i2=1,---,k;’i1¢’i2 i=1

We would like to ﬁnd an ideal partition P that makes the difference
between the reads of a same group minimized and the difference between
the reads of different groups maximized, i.e. one that minimizes C (P)
and maximizes D(P). However, this may be impossible in most cases,
since a partition function P minimizing C (P) may not ensure that D(P)
is maximized and Vice versa. Therefore, we combine both measures into
a weighted partition score:

50’) = (1 — ’w)D(P) — 1110(1)), (6)

where w is a weighting parameter with 0 S w 3 1. In the following, we
propose a new optimization model for the polyploid haplotyping problem.
Polyploid Balanced Optimal Partition (PBOP): Given an SNP matrix
M and weight 11), ﬁnd a k-partition function P of the rows in M such that
5(P) = (1 — w)D(P) — wC(P) is maximized.

Note that when w = 1 and k = 2, PBOP becomes the MEC model
for the diploid haplotype assembly problem. MEC is known to be NP-
hard (Lippert et al., 2002). In fact, it has been recently shown not to
be in APX under the Unique Games Conjecture (Bonizzoni et al., 2015).
Therefore, PBOP is also NP-hard, and not in APX under the Unique Games
Conjecture. In the next subsection, we introduce a heuristic algorithm
called H-PoP.

When the genotype g of the polyploid is known, we will also consider
the genotype constrained version of PBOP. Since we do not consider
homozygous loci, for each locus j, g[j] E {1, ...,k — 1}. g[j] = t
means that at the j th locus, there are t haplotypes taking the allele ‘1’ and
the other I: — t haplotypes taking the allele ‘0’.

Let I,-  be an indicator function, i.e. Iz-  = 1 if at = 2'; otherwise
0. Given a k-partition function P on a set of rows R = {T1, ..., rp},
the consensus haplotypes H {, ..., H I; with genotype constraint g are the
haplotypes that satisfy the following conditions: (i) H [j] = — when there
are no reads in group G,- covering the jth locus (i.e. the alleles at locus
j of the reads in group G,- are all unknown), (ii) 2:le 11 (H g
g[j],Zf=12Zo(I-I£[j]) g k — g[j] for each locus j E {1,  and
(iii) 23le 2,601, 2;, s(r[j], H;[j]) is maximized.

The genotype constrained corrected error measure C ’ (P) and partition
score 5’ (P) are deﬁned as:

k: n
00") = Z Z Zd(r[j],H£[jl)- (7)

i=1 rec,- j=1

Similarly, the genotype constrained diversity measure D’ (P) and
partition score 5’ (P) are deﬁned as follows:

D’(P)= Z Zd(H£.[ji,H£2[ji) ; (8)

i1 ,i2=1,---,k;’i1¢’i2 i=1

s’(P) = (1 — w)D’(P) — wC’(P). (9)

Polyploid Balanced Optimal Partition with Genotype constraint
(PBOPG): Given an SNP matrix M, the genotype g of the polyploid
and weight 11), ﬁnd a k-partition function P of the rows in M such that
s’(P) = (1 — w)D’(P) — wC’(P) is maximized.

2.2 Algorithm

Given an m X n SNP matrix M, the number of ways to partition m
different rows r1, ..., rm into I: non-empty groups is a Stirling number
of the second kind, which is denoted as S(m,  Since S(m, k) =
% 219:0  (k — i)m, when m is large, it is impractical to
enumerate all possible partitions and choose one with the maximum
partition score. To solve the PBOP model of M efﬁciently, we propose
a heuristic dynamic programming algorithm in the subsection. In other
words, we will consider solutions for a number of rows of M then extend
the solutions to the next row, and so on until all rows of M have been
considered.

We ﬁrst introduce some deﬁnitions and notations similar to those in
(Xie et al., 2012), but some of which have different meanings. Let 
(e(z')) denote the ﬁrst (the last) column at which the 2th row of M takes
non-‘—’ values. If and only if  S j S e(z'), row i spans column j.
R( j) denotes the set of rows that contain the rows in M spanning the jth
column.

In the following, we assume that M has been sorted such that for two
rows i1 and i2 ofM with 2'1 < i2, b(z'1) < b(z'2), or b(z'1) = b(i2) and
6(i1) S 6(i2).

Let P be a canonical k-partition function on a set of rows R and P’
a canonical k-partition function on a subset R’ of R. If for any two rows
i,j E R’, P’(z') = P’(j) if and only if  = P(j), P’ is called the
projection of P on R’ and P an extension of P’ on R. It is easy to verify
that given a partition P of R and a subset R’, the projection of P on R’ is
unique, but not Vice verse. The projection of P on R’ is denoted by P[R’ ]
for convenience.

Let P be a canonical k-partition function of the subset R = {
Til, ..., riq } of the rows of M with iq as the largest row index in R,
and R’ 2 {T1, ..., rig} (i.e. the set of all rows from the ﬁrst row to row
riq ). P’ is an optimal extension of P if the following conditions hold: (i)
P’ is an extension of P on R’ and (ii) for any possible extension P” of
P on R’, 5(P’) Z 5(P”).

Similarly, when the genotype g is available, P’ is a genotype
constrained optimal extension of P if the following conditions hold: (i)
P’ is an extension of P on R’ and (ii) for any possible extension P’ ’ of
P on R’, s’(P’) Z s’(P”).

Given a partition P of R, let E(P) denote an optimal extension of
P and E’ (P) a genotype constrained optimal extension of P. We call
s(E(P)) (or s’ (E’ (P))) the global (or the genotype constrained global)

9mg ‘09 1sn8nV uo sajaﬁuV s01 ‘121u10111123 10 A1rs19Aruf1 112 /810's112umo[p101x0'sor112u1101urorq/ﬁd11q 111011 papeolumoq

 

H4 3)

 
 
     

» go go
P(1..4)=1 \\g .9
P(4)= w , "e 29
\\
5(3, 1) 3(3, 2) 5(3, 3)
P(1..3)=l v, P(1..3)=1..3

 =2» /

5(2, 1)@ 3(2, 5&9

P(1..2)=1 P(1..2)= 1.2

Fig. 2. An illustration of IF(4, 3), the set of all 15 canonical functions that partition 4 rows
into at most 3 groups. A partition function is represented by a path from the root node to
a leaf node. For example, the path from the root node IF(4, 3) to the leaf node 8(3, 1)
represents such a function P with P(4) = 2 and P(z‘) = 1 for i = 1 to 3.

score of P and denote it as 56 (P) (or 5/6 (P), respectively) for convenience.
The following theorem is straightforward.

Theorem 1. Let P be a canonical k-partition function of R(n) for an
m X n SNP matrix M. E (P) is a solution to PBOP (or PBOPG) of M
if and only if the following condition holds: for any possible canonical
k-partitionﬁxnction P’ ofR(n), 56 (P) 2 56 (P’) (or 5/6 (P) 2 5/6 (P’),
respectively ).

We consider the set of canonical k-partition functions that partition a
set of 2' rows into at most In groups, and denote the function set as lF(z', 
Let S(p, q) denote the set of canonical functions that partition p rows into
q non-empty groups. It is obvious that lF(z', k) = Uq=1,_tS(i, q), where t
is the maximum of i and k.

Let p and q be positive integers. To enumerate all canonical functions
that partition p rows into q non-empty groups, we consider the following
cases:

0 p < q: Such functions do not exist, i.e. S(p, q) = Q.

o p = q:It is easy to verify that S(p, q) contains only one partition
function, i.e.  = i forz' = 1 to p (denoted by P(1..p) = 1..p).

o p > q: If q = 1, there is only one partition function in S(p, q), i.e.
 = 1 forz' = 1 top (denoted by P(1..p) = 1). Ifq > 1, we may
construct S(p, q) using the following recursive process. Considering
the last row p, the group containing row p either has only one row, i. e.
row p, or two or more rows. We denote the set of partition functions
that put row p into a group by itself (labeled as group q) and partition
the ﬁrst p — 1 rows into the other q — 1 non-empty groups as {(P(p) =
q) - S(p — 1, q — 1)}, and denote the the set of partition functions that
partition the ﬁrst p — 1 rows into q non-empty groups and put row p
into one ofthe q groups as {(P(p) = 1, ..., q) - S(p — 1, Then,
we have the following recurrence:

509, q) = {(P(p) = q) -S(p — 1,q — 1)} U
{(P(p) = 1, ---,q) -S(p — 1,q)}-

Figure 2 illustrates IF(4, 3), the set of all 15 different functions
partitioning 4 rows into at most 3 groups. In the graph, the values S(p, q)
with p = q or q = 1 are represented as the leaf nodes and a partition
function is represented by a path from the root node to a leaf node.
Please note that there may be more than one path from the root to a
leaf node. For example, there are three different paths from the root
lF(4, 3) to the node 8(3, 3), corresponding to three different functions:
(i) P(4) = 1,P(1..3) = 1..3, (ii) P(4) = 2,P(1..3) = 1..3 and (iii)
P(4) = 3,P(1..3) = 1.3.

Given an m X n SNP matrix M, our algorithm considers the set R(1)
of rows spanning column 1 ﬁrst. To make the algorithm scalable, we will be

able to enumerate all the partition functions on a small number of rows. Let
q be the maximum integer such that | lF(q, k) |§ 1000 and q 3| R(1) 
Let R f be the set of the ﬁrst q rows in R(1) and Rb contain the rest
of the rows in R(1). When R(1) contains no more than q rows, R f =
R(1) and Rb = Q. Since the number of rows in R f is at most q and
| lF(q, k) |§ 1000, it is practical to enumerate all partition functions of
R f by the above method.

For each group G obtained by partitioning R f according to some
function P, let b(G) = mianG b(r) and e(G) = maXTEG e(r). We
use a 2 X 71 matrix to record a proﬁle P(G) for G, where the element
P(G) [1), j] counts the number of rows of G whose values at column j is v
for v = 0, 1 and j = b(G), ..., e(G). The set ofthe proﬁles for all groups
incurred by P is denoted as P p.

Based on P(G), we obtain a consensus haplotype H G of G easily:

0. manna] > P(G)ll,jl
Hg[j] = 1, iflP(G)[0,j] < P(G)[1,j] forj = b(G), ...,e(G).
—, otherwise
(10)
Using equations (4) - (6) and (10), the score 5(P) of a k—partition
function P on Rf can be calculated in time ()(lm (q —l— 132)), where
lm = maxieRf e(z') — minieRf  + 1.

Recall that at the very beginning of the algorithm, R f = {r1 , ..., rq },
and both the optimal extension and the genotype constrained optimal
extension of a partition function P of R f are P itself, i.e. E(P) = P
and E’(P) = P. Therefore, 5e (P) = 5(P) and 52 (P) = s’(P).

For an optimal partition function P of the set of the rows in M, the
projection of P on R f is likely a suboptimal partition function of R f. In
the following extension from R f to rows in R5, we will only consider
the top 10k2 partition functions of R f, which is denoted by F, based on
empirical experience.

If Rb is not empty, let T be the row with the smallest index in Rb and
R3. = R f U  We construct all possible extensions of the functions
in F to R3. and record (at most) 10k2 extensions with the highest global
scores in F’.

For a partition function P on R f, there are at most I: extensions of P
on R}. Let the number of rows in Rf be qf and g = mam-=1an P(z'),
i.e. P partitions the q f rows of R f into 9 nonempty groups G1, ..., Gg.
Since the row r can be put into any one of the 9 groups, there are at least
9 extensions Pl’, ..., P; of P on R}. When 9 < k, r can be put into a
new group and hence there is an additional extension P; +1 of P. For each

t t, i=qf—l—1.

extension Pt’ ,

Let the nonempty groups obtained by applying Pt’ on R} be

’1, ..., G’g,. Since the difference As between the global scores of Pt’

and P is due to putting r in G’ , it is easy to compute by considering two
cases below.

0 t S g: In this case, 9’ = g. Forz' = 1, ...,g exceptz' = t, G;
G), P(Gg) = P(Gi) and HG]. = HG,” Moreover, G; = G; U
{r}, P(va, j] = P(Gt)[v,j'] + My, j] forv = 0,1 and j =
b(Gg), ..., e(Gg), where Ir [1), j] = 1 when r takes value v at column
j; otherwise I r [1), j] = 0. Use Equation (10) to compute H G; . Let the
set of columns where H G t 75 H G; be C. Then

6(7")

A0 = ZIP(Giuooi—Maailoi|+ Z d(HG,/,ij],r[ji)
jEC j=b(r)

AD = 22(d(HG;iji.HG,ii-i)—d(HG.iji.HG.iji>)
jECiyét

A5 = (1—w)AD—wAG (12)

9mg ‘09 1sn8nV uo sajaﬁuV s01 ‘121u10111123 10 A11s19A1uf1 112 /810's112umo[p101x0'soi112u1101u101q/ﬁd11q 111011 papeolumoq

 

o t > g: Inthiscase, g < kandg’ = t 2 9+ 1. Forz' = 1,...,g,
G; = Gi,lP(G;) = P(Gi) andI-IG; = HG,” Moreover, G; = {r},
P(Gg)[v,j] = Ir[v,j] forv = 0,1 andj = b(r), ...,e(r), where
Ir [1), j] = 1 when r takes value v at column j; otherwise Ir [1), j] = 0.
H G; can be obtained easily using Equation (10). Then

e(r) 9
As = (1 — mm = (1 — w) 2 2 (MG, [3'], Ha.- 131))
j=b(r) i=1
(13)
The global score of Pt’ is
56(1); ) = 56(1)) + As, (14)

which can be calculated in time 0(lk), where l = e(r) — b(r) —l— 1.

Once all possible extensions of the functions in F to R’ have been
enumerated, we set F = F’, Rf = Rf U {r} and Rb = Rb —  The
above process is repeated until Rb becomes empty and R f = R(1).

After obtaining the top 10k2 partition functions of R( j ) for some j,
which are again stored in F, we consider the next column j —l— 1. Let Rd =
12(1) — R(j + 1), RT = Rm 0 Bo + 1) and R5 = R(j + 1) — R(j).
We ﬁrst compute the projections of the functions in F on RT, and then
extend them to R( j —l— 1).

Let F’ be the set of the projections of all functions in F on RT. It
is obvious that | F’ |§| F  For a function P in F, we can easily
compute its projection P’ on RT. If Rd 2 a, i.e. RT = R(j), then
P’ = P and F’ = F; otherwise, we compute its projection P’ as follows.
Let the rows in RT be r11 , 73-2, ..., and riz, and P” be such a partition
function of RT that P”  2 P03) forz' 2 2'1, ..., iz. Suppose that P”
partitions RT into t non-empty groups G’l’ , ..., Gg’. Sort these groups by
their representative row indices in the ascending order and let rank(g) be
the rank of G’g’ in the sorted groups, i.e. if the representative row index of
G’g’ is the p smallest then rank(g) = p. Set P’ = rank(P”  for
2': 2'1, ..., 2'2, and then P’ is the projection of P on RT.

For each function P’ in F’, we can calculate its global score 56 (P’ )
using the equation below:

56(P’) = 56(1)). (15)

max
PEF and P’ is a. projection of P
The time complexity of computing F’ and the scores is  (k log k —l—
|R(j ) |  Once F’ and the corresponding scores have been computed, set
F = F’ and Rf 2 RT, and extend the functions in F to R(j —l— 1)
by deleting a row from Rb and adding it to R f, one at a time, until
R f = R( j —l— 1) as done above by using Equation (11).

The above iteration continues until R( j) contains the last row of M.
Finally, an extension of the function in F with the highest global score is
output as a solution to the PBOP problem of M. A pseudo code for this
algorithm, called H-PoP, is presented at Figure S1 in the Supplementary
Materials.

For the PBOPG model, a similar heuristic algorithm H-PoPG can be
easily devised. All we need is a simple modiﬁcation of H-PoP to make
use of the provided genotype information. Please see the Supplementary
Materials for the details of H-PoPG.

3 Results

We use both real data and simulated data to compare the performance
of our algorithms H-PoP, H-PoPG and three recent single individual
polyplotyping algorithms HapCompass (Aguiar and Istrail, 2013),
HapTree (Berger et al., 2014) and SDhaP (Das and Vikalo, 2015). Besides
aligned SNP reads, all algorithms except H-PoP and SDhaP require
genotype information as an additional input. The weight w is set as 0.9 for

H-PoP and H-PoPG unless otherwise speciﬁed. All tests are conducted on
some 64 bit nodes with 2.6GHz CPU and 128GB RAM of a Linux cluster,
and each result on simulated data is the average of 100 repeated tests with
the same parameters.

3.1 Results on Real Data

Using 454 GS FLX Titanium sequencing, Curtin et al. (Curtin et al., 2012)
obtained a 12.7 Mb assembly of AWRIl499, a prevalent wine spoilage
strain of the yeast species Dekkera bruxellensis. The assembly is comprised
of 324 contigs (N50 = 68 kb) in 99 scaffolds, at median read coverage of
26-fold and it was found that AWRIl499 is a triploid (Curtin et al., 2012).
We downloaded the read data from the SRA database of NCBI under
the accessions SRX327045 and SRX327033, and the 14 contigs of the
ﬁrst scaffold from the Assembly database of NCBI under the accession
AHIQ01. After cleaning adapters and low quality bases from the reads,
BWA-MEM (Li and Durbin, 2009) was used to align the reads against
the contigs with default parameters, and the SAMtools package (Li et al.,
2009; Li, 2011a,b) was used to call SNPs based on the aligned reads. The
genotype of an SNP locus is determined by the proportion of the alleles 0
and l on the locus. Keeping only alleles at the heterozygous SNP loci of
the aligned reads, we obtained 14 SNP matrices, one for each contig.

We tested H-PoPG, H-PoP, HapTree, HapCompass and SDhaP on
these real data. AWRIl499 is a triploid, but its three true haplotypes
are unavailable. Instead, there are only consensus contigs. Since the true
haplotypes are unknown, we use the MEC score (Lippert et al., 2002)
to evaluate the accuracy of the reconstructed haplotypes. More precisely,
given an m X n SNP matrix M, let the reconstructed k haplotypes be
H = (H1,..., Hk). The MEC score sc (H, M) is the minimum number
of sequencing errors in the SNP matrix if H is considered as the true
haplotypes. That is,

50(H7 M) = Z pznllin k( 2  
i=1,...,m "i, j=1,...,'n,

where d(.,  is the dissimilarity function given in Equation 2. The MEC
rate ec (H, M) is the minimum sequencing error rate of the corresponding
DNA reads at the SNP loci if H is considered as the true haplotypes, i. e.
ec (H, M) 2 SC (H,  the number of non— ‘-’ elements of M.

The detailed test results on all 14 individual contigs are given in Tables
Sl-Sl4 of the Supplementary Materials. H-PoPG, H-PoP, HapCompass
and SDhaP were able to reconstruct the haplotypes from the SNP matrices
for all contigs, but the performance of HapCompass was clearly inferior to
the other algorithms. H-PoPG and HapTree achieved similar MEC rates.
Without the genotype constraint, SDhaP had less MEC rates while H-PoP
obtained the least MEC rates. However, HapTree aborted with run-time
errors on the data of contigs 6, 8, 15, 17, and 21, and failed to terminate in
seven days on the data of contig 19. The SNP matrices of contigs 6, 8, 15 ,
17, 19 and 21 consist of 64223 rows and 12226 columns (i.e. SNPs). The
total number of non-‘-’ elements is 448619, the average read coverage of
each SNP is 36.7, and the average number of non-‘-’ elements in a row
(i.e. an SNP read) is 7.0. All algorithms except HapTree reconstructed
20 disjoint blocks of haplotypes on these contigs, with the average block
length being 611.3 SNPs. The test results on the 6 contigs are summarized
in Table l.

The SNP matrices of the remaining 8 contigs (contigs l, 2, 4, 7, 10,
12, 16 and 18) consist of 13943 rows and 4096 columns (SNPs). The total
number of non-‘-’ elements is 115371, the average read coverage of each
SNP is 28.2, and the average number of non-‘-’ elements in a row (an SNP
read) is 8.3. All algorithms reconstructed 98 disjoint blocks of haplotypes
on these contigs, with the average block length being 41.8 SNPs. The test
results on the 8 contigs are presented in Table 2.

9mg ‘09 1sn8nV uo sajaﬁuV s01 ‘121u10111123 10 A11s19A1uf1 112 /810's112umo[p101x0'soi112u1101u101q/ﬁd11q 111011 papeolumoq

 

Table 1. Comparison of the performance of H-PoPG, H-PoP, HapCompass
(HapC in the table) and SDhaP on the real data corresponding to contigs 6, 8,
15, l7, l9 and 21 of triploid AWRIl499.

 

 

 

k = 3 k = 2

H-PoPG H-PoP HapC SDhaP H-PoP
MEC 8867 3891 22822 8186 28400
MEC rate (%) 1.98 0.87 5.08 1.82 6.33
Phased SNPs 12223 12160 12226 12226 12210
Time (s) 19.1 13.9 25237.9 41425.9 7.5
Memory (GB) 8.2 8.2 43.5 32.4 4.3

 

Table 2 shows that when regarding AWRIl499 as a diploid (i.e. set
I: = 2), the MEC rate of H-PoP was 4.33%, which is much larger than the
raw single base sequencing error rate of 2.23 % shown in the Supplementary
Figure 8 of Margulies et al. (2005). This suggests that we could perhaps use
H-PoP to help determine the ploidy of an organism by trying different I: and
comparing the MEC rate and DNA sequencing error rate. When regarding
AWRIl499 a triploid, without applying the genotype constraint, the MEC
rate 0.43% achieved by H-PoP was the least, about a half of that of SDhaP.
With the genotype constraint, the MEC rate 1.28 of H-PoPG was a little
better than that of HapTree. The MEC rate 3.25 of HapCompass was the
largest, which suggests that the reconstructed haplotypes of HapCompass
may be inaccurate. The phased SNPs of HapTree, HapCompass and SDhaP
are 4096, while two of these SNPs were not phased by H-PoPG since
it does not perform phasing at loci that are not covered by reads in the
corresponding groups. As for running time, H-PoP and H-PoPG were
more than 40 times faster than HapTree, HapCompass and SDhaP. The
maximum run-time (resident) memory used by HapCompass and SDhap
was more than 20GB, while the other algorithms needed only less than
3GB memory.

3.2 Results on Simulated Data

We generated aligned SNP reads of a polyploid genome as follows. First,
I: genomes were generated based on the real contigs and VCF ﬁles of
AWRIl499. Given a contig as the haplotype template and a corresponding
VCF ﬁle, we generated 12 copies of the contig as the initial 12 genomes.
For each heterozygous SNP in the VCF ﬁle, a genotype 9 (the number
of alternative alleles) of the SNP was generated randomly following a
uniform distribution from 1 to k — 1. Then 9 genomes were randomly
selected from the k genomes and their alleles at the SNP locus were set as
the alternative alleles, while the other genomes were set as the reference
alleles. The generated I: genomes were saved in a FASTA format ﬁle named
k-ploid.fa. Second, we used ART (Huang et al., 2012), a next-generation
sequencing read simulator, to generate simulated reads from the the k
genomes.

To simulate the real data of AWRIl499, we ran ART with the 454 GS
FLX Titanium platform proﬁle that came with the simulator to generate
single-end reads and paired-end reads. ART requires a parameter, the
coverage c of each haplotype, to generate single-end reads, and three
parameters, the coverage c of each haplotype, the mean insert length f
and the standard deviation (7 of insert length, to generate paired-end reads.
In the following tests without explicit speciﬁcation, f was set as 800 and
a was set as 150 according to the distribution of the reads in the real data.
The single-end and paired-end reads in the same dataset were generated
by ART with the same coverage parameter.

Correct phasing rate (RC), and perfect solution rate (Rp) will be used
to measure the phasing accuracy of the k haplotypes reconstructed by an
algorithm. When the genotype of the reconstructed haplotypes equals to
the original genotype, another measure vector error rate (R1, ) (Berger
et al., 2014) is used too. Let the set of k haplotypes reconstructed by an
algorithm be H = {H 1, H 2, ..., H k} and the set of true haplotypes be

Table 2. Comparison of the performance of H-PoPG (H-PG in the table), H-PoP,
HapTree (HapT in the table), HapCompass (HapC in the table) and SDhaP on
the real data corresponding to contigs l, 2, 4, 7, 10, l2, l6 and 18 of triploid
AWRIl499.

 

 

 

k = 3 k = 2

H-PG H-PoP HapT HapC SDhaP H-PoP
MEC 1471 497 1487 3748 1085 4991
MEC rate (%) 1.28 0.43 1.29 3.25 0.94 4.33
Phased SNPs 4094 4061 4096 4096 4096 4082
Time (s) 6.5 4.4 371.5 575.8 345.3 4.4
Memory (GB) 2.2 2.2 1.3 39.1 25.6 0.8

 

H* = {Hf, H3, ..., H]:  Let H be a one-to-one mapping from H to
H*. Deﬁne M(H) = 2le 2;, Suit, [j], H(Hi)[j]), where sis the
similarity function given in Equation (1). The correct phasing rate RC is
deﬁned as follows:

RC  = mﬁx 

where n is the number of phased SNPs. For the example, in Figure 3,
the correct phasing rate RC  = 10 / 12. The perfect solution rate is
R10 2 no / k, where no is the number of haplotypes correctly reconstructed
(i.e. they are exactly the same as the true ones) by the algorithm. For
example, the perfect solution rate of H in Figure 3 is 1/3.

The vector error measure is a generalization of the switch error measure
for diploid haplotype assembly to polyploid phasing. The vector errors
in k reconstructed haplotypes are deﬁned in (Berger et al., 2014) as the
minimum number of segments on all chromosomes for which a switch
must occur. To make it easy to understand, we give another equivalent
deﬁnition of the measure here. A one-to-one mapping H from H to H*
is called a matching at locus j if 2:le d(H,-[j],  = 0. The
distance d(H1, H2) between two mappings H1 and H2 is deﬁned as
2:le I(H1  79 H2 where I is an indicator function (i.e. I(a)
= 1 if a is a true statement and I (a) = 0 otherwise). When the genotypes
of H and H* are equal, there exist a series of one-to-one mappings M 2
{H1, ..., Hn} such that Hj is a matching at locus j forj = 1, ..., n, and
such a sequence is called a matching sequence. For a matching sequence
M, the total number of changes between adjacent matchings is Tc  =
23:11 d(Hj, Hj+1). The number of vector errors e1, in H against H*
are deﬁned as:

61)  = I  Tc  .
.M is a matching sequence

The number of vector errors e1, can be calculated by a dynamic
programming algorithm in time O(n(k — 1) [2), which is faster than the
method used in (Berger et al., 2014) with time complexity 0(kn2), when
k is small and n is big. Please see Figure S3 of the Supplementary Materials
for the the pseudocode of the dynamic programming algorithm.

The vector error rate R1, is deﬁned as e1, /n. For example, in Figure
3, there is a matching sequence M = {H1 , H2, H3, H4}, where H1 =
{H1 —> H§,H2 —> Hf,H3 —> H§}andH2 2 H3 2 H4 = {H1 —>
H§,H2 —> Hf,H3 —>  It is easy to see that Tc(./\/l) = 2, the
number of vector errors inHis2and the vector error rate R1, = 2 / 4 = 0.5.

To choose an appropriate weight w for H-PoPG, we tested its
performance with different to from 0.8 to 1.0, and compared it with
HapTree and HapCompass. We used the ﬁrst contig of AWRIl499 as
the haplotype template and ran ART with c = 2 to generate 100 triploid
read data sets (each consisting of a set of single-end reads and a set of
paired-end reads). After alignment to the contig and deleting alleles at
homozygous SNP loci and reads that cover fewer than 2 heterozygous
SNP loci, we obtained 100 SNP matrices, each of which has 449 columns

9mg ‘09 1sn8nV uo sajaﬁuV s01 ‘121u10111123 10 A11s19A1uf1 112 /810's112umo[p101x0'soi112u1101u101q/ﬁd11q 111011 papeolumoq

 

H H"
H1: 0 0 1 0 2H1? 0—>1—>1—>1 (H2)
1 .

i”) H22 0 1 1" Hf: 0  (H3)
 H3:1 1 0 0 m/‘wo—n—m (H1)

01in 1 of 3 haplotypes of H" is pha/ ed by H

   

no error: Rp= 1/3

H has 2 vector errors at 4 SNP ci: Rv=2/4
H1 has a vector error H3 has a vector error

Suppose Hf is reconstructed as H2, H2” as H3 and H3” as H1
10 of 12 alleles of H* are correctly phased: RC = 10/ 12
Fig. 3. An simple illustration of correct phasing rate, perfect solution rate and vector error
rate. In this example, the correct phasing rate RC of the reconstructed haplotypes H is
10/12, the perfect solution rate R1, = 1/3 and the vector error rate R1, = 2 / 4.

 

 

 

 

 

 

 

 

 

 

 

100 10
0.8-
,, f
g 10'“ .5 0.6-
2 E
a 8 04
> 102— m
0- 0.2
0.0- l -

10"— ,
Wei ht= 0.8 0.85 0.9 0.95 1.0 Wei ht= 03 035 09 095 10
g H-PopG HapTree HapComp g H_P0PG HapTree HapComp

(a) Vector error rate (b) Perfect solution rate

 

 

1 o 1.00
.3 g 0.98-
 0'8_ oz": 0.96-
% w
E E 0.94—
8 0.6- a

.0

(O

N
.

     

 

 

 

 

 

 

 

 

 

0.4— 0.90-
Welght= 0.8 0.85 Welght= 0.8 0.

I°°~
.

0.9 0.95 1.0 5 0.9 0.95 1.0
Pope HapTree HapComp oPG

HapTree HapComp

(C) Correct phasing rate (d) Phased SNP rate

00

_\
oi.
_\

 

 

_\ _\
ON on:
. .
_\
.°

51
Max memory (GB)

Running time (s)

_\
Co
.

 

 

 

 

 

 

 

 

 

\\\\\\\)

0.1 -
Weight= 0.8 0.85 0.9 0.9
H-PoPG

CI

101-
Weight= 0.8 nag-Igfpggs 1.0 HapTree HapComp 1-0 HapTree HapComp

(6) Running time (1) Max resident memory
Fig. 4. Comparison of the performance of H-PoPG, HapTree and HapCompass on
simulated triploid (k: = 3) 454 GS FLX Titanium sequencing data. Various weights from
0.8 to 1.0 were considered for the parameter w in H—PoPG.

(heterozygous SNPs). The average number of rows (SNP reads) of an SNP
matrix is 394.08, the average number of non— ‘-’ values of each row (called
the SNP read average length) is 13.4, and the average number of non-‘-’
values of each column (regarded as the SNP read coverage) is 11.7.

The test results are showed in Figure 4. When the weight 111 was set
as 0.9, H-PoPG reached the best performance among the three algorithms
according to Figure 4 (a) in vector error rate, Figure 4 (b) in perfect solution
rate and Figure 4 (c) in correct phasing rate. Figure 4 (d) shows that the
rate of phased SNPs (i. e. the phased SNPs to total SNPs ratio) of HapTree
and HapCompass is the best at 99.3%, while the phased SNP rates of H-
PoPG with different weights are near 98.5%. Figures 4 (e) and (1) show
that the running time and memory of H-PoPG varied little as the weight
changes and H-PoPG used much less time and memory than HapTree and
HapCompass. In the following experiments, to was set as 0.9 for H-PoPG
and H-PoP as the default value. Since HapCompass ran very slow and
its performance was clearly inferior to H-PoPG and HapTree, it was not
included in the tests.

_\
0.

 

 

 

 

 

 

 

 

 

 

|:| H-PoPG 1'0 l:| H-Po -PoP -§HapTree
- HapTree 
“g g 0.8
L _2 L
510 ' c
t .9
5 8
g 10-3_ g 
> 5
D- 0.2
10“- 0 0 
11.7 23.7 35.4 47.1 ' 11_7 23] 354 47_1
Coverage Coverage

(a) Vector error rate (b) Perfect solution rate

 

_\
O
O
_\
O

 

 

 

    
      

 

 

 

 

 

 

 

 

 

 

 

 

 

 

(D
E *3
30.95- 0;:
‘0 z
E w 0.9-
a a
3090- E
5 o.
O

0.85 0.8

' 11.7 23.7 35.4 47.1 "11.7 "23.7 "35.4 ' 47.1
Coverage Coverage

(C) Correct phasing rate (d) Phased SNP rate

l:| H-PoPG - H-PoP - HapTree - SDhaP

 

 

  
    

 

 

 

 

 

 

 

 

 

2
1° |:| H-PoPG i H-PoP
A - HapTree - SDhaP
A C0 1
e 10' <9 
(I) 1
g 510'
g 5
'E 1 - E
g (>6 10°-
0: E
0.1 i
10'1 - 1
11.7 23.7 35.4 47.1 11.7 23.7 35.4 47.1
Coverage Coverage
(e) Running time (1) Max resident memory

Fig. 5. Comparison of the performance of H—PoPG, HapTree and SDhaP on simulated
triploid (k: = 3) 454 GS FLX Titanium sequencing data. The SNP read coverage increased
from 11.7 to 23.7, 35 .4 and 47.1, and the average SNP length was about 13.5.

We increased c from 2 to 4, 6 and 8, and generated SNP matrices
with SNP read coverage changing from 11.7 to 23.7, 35.4 and 47.1 to
test H-PoPG, H-PoP, HapTree and SDhaP. Figure 5 presents the test
results. Without genotype information, the genotypes of the k haplotypes
reconstructed by SDhaP and H-PoP were often different from that of the
real k-haplotypes and hence vector error rate could not be used to measure
the performance of SDhaP and H-PoP. When the coverage increased, the
vector error rates, the perfect solution rates and the correct phasing rate of
all algorithms improved. The vector error rates of H-PoPG are less than
a half of those of HapTree, and the perfect solution rates of H-PoPG and
H-PoP are clearly higher than those of HapTree and SDhaP. In the test with
SNP read coverage 47.1, HapTree reached the highest correct phasing rate,
while in the other tests H-PoPG performed best in term of correct phasing
rate. HapTree and SDhaP phased the most SNPs, while the phased SNPs
of H-PoPG were a little fewer than those of HapTree and SDhaP. In the
test with SNP read coverage 11.7, the phased SNP rate of H-PoP was the
lowest. However, even in the worst case, H-PoP phased more than 96%
of the SNPs. In terms of efﬁciency, the average running times of H-PoPG
and H-PoP were less than 2 seconds, which is obviously less than those
of HapTree and SDhaP. H-PoPG and H-PoP used much less memory than
HapTree and SDhaP when the coverage was 11.7, and HapTree used the
least amount of memory in the other three cases. The memory requirement
of SDhaP was about 26 GB, and it did not change much in different tests
(including the tests below), while the memory required by H-PoPG and
H-PoP was less than 3 GB in all four cases. It is interesting to observe that
HapTree spent much more time and memory to handle the test data with
coverage 11.7 than other data with deeper coverages.

We varied I: from 4 to 6 to test the performance of the algorithms
on reconstructing the haplotypes of a tetraploid, pentaploid or hexaploid

9mg ‘09 1sn8nV uo saraﬁuV s01 ‘121u10111123 10 A11s19A1uf1 112 /810's112umo[p101x0'sor112u1101u101q/ﬁd11q 111011 popcorn/hog

 

-1
|:| H-PoPG ‘
- HapTree i

_|
0

D3
9
b1
0
E
(D
E
><
m
2

(d) Phased SNPrate (6) Running time (1) Max resident memory

Fig. 6. Comparison of the performance of H-PoPG, H-PoP, HapTree, and SDhaP on
simulated tetraploid (k: = 4), pentaploid (k: = 5) and hexaploid (k: = 6) data. The
number of SNPs was 449, and the average SNP read length was 13.5. The SNP read
coverage of the simulated data with k = 4(5, 6) was 47.1 (58.9, 70.8, respectively).

genome. Figure 6 illustrates the test results on simulated data generated
by ART with c = 6. When I: = 5, H-PoPG was superior to the other
algorithms in terms of vector error rate, perfect solution rate and correct
phasing rate. When I: = 4 and 6, HapTree was the best in terms of vector
error rate and correct phasing rate, but H-PoPG was not far behind. On
the other hand, the running time and memory requirement of HapTree
increased at a signiﬁcantly faster rate than those of the other algorithms
when I: increased. When I: = 6, HapTree ran for 1301 seconds and used
63 GB memory, while H-PoPG used only 23 seconds and 4 GB memory.
As for the phased SNP rate, there is very little difference between the
algorithms, and it was above 99.3% for all algorithms.

Figure 7 shows the test results on triploid data when we changed
the haplotype template from the ﬁrst contig of AWRIl499 to the
concatenations of the ﬁrst two contigs or the ﬁrst four contigs. The number
of heterozygous SNPs of the haplotype template increased from 449 to
1145 and 1739, respectively. Figure 7 illustrates that H-PoPG had the best
performance in terms of vector error rate, perfect solution rate and correct
phasing rate, while SDhaP was the worst in terms of perfect solution rate
and correct phasing rate. The phased SNP rates of HapTree and SDhaP
are a little higher than those of H-PoPG. The running time of HapTree
increased signiﬁcantly with the increased haplotype template length, while
the running time of H-PoPG and H-PoP increased slowly. The running
times and memories of H-PoPG and H-PoP are much less than those of
HapTree and SDhaP.

The length of reads generated by ART is limited by the build-
in sequencing platform quality proﬁle. To test the performance of the
algorithms on long reads that future sequencing technologies might
produce, we concatenated multiple copies of the Illumina HiSeq 2500
platform quality proﬁle contained in the ART package and generated a
simulated future sequencer quality proﬁle ﬁle to avoid the read length limit
of ART. We concatenated all 14 contigs of the ﬁrst scaffold of AWRIl499
into a template haplotype consisting of 22178 heterozygous SNPs, and
using the new quality proﬁle, we ran ART to generate reads with parameters
r (the length of reads to be simulated), f (the mean length of inserts for
paired-end reads), a (the standard deviation of DNA fragment sizes), and
c (the read coverage of each haplotype). We ﬁxed c as 12, a as 50, and
varied (r, f) from (500, 2000) to (1000, 3000) and (2000, 6000), and the
average length l of the generated SNP reads changed from 40 to 80 and
160.

Figure 8 shows the test results. Since HapTree ran slowly when tested
on the data with l = 80 and l = 160, in each case we divided 100 test
datasets into 10 subsets and tested HapTree on 10 different nodes of the

 

Vector error rate

Phased SNPs rate

 

_\

1 1:1 HTPoPG
 - HiapTree

449 '1145 1739
SNPs

(a) Vector error rate

.00

.0
co
01

0.90

449 1145 1739
NPS

(11) Phased SNP rate

|:I H-PoPG - H-PoP
- HapTree - SDhaP
1 1

Perfect solution rate

 

449 1145 1739
SNPs

(b) Perfect solution rate

.1

.1

Running time (s)

 

—‘
0.

449 1145 1739
SNPs

(6) Running time

 

Correct phasing rate

449 ‘ 1145 ‘ 1739
SNPs

(C) Correct phasing rate

—\ —\
oi 0N

Max memory (GB)
00

 

449 1 145 1739

(1) Max resident memory

Fig. 7. Comparison of performance of H—PoPG, H-PoP, HapTree and SDhaP on simulated
triploid (k: = 3) 454 GS FLX Titanium sequencing data with the number of SNPs changed.
The average SNP read length and coverage of the simulated data with 449 (1145, 1739)
SNPs were 13.4 (14.1, 14.7) and 11.7 (11.9, 11.9), respectively.

|:| H-PoPG- H-POP- HapTrss- SDhaP
1 .0

 

 

 

 

 

10“ I T 1.0
a, l:|H c s new.“ % g
E E 0'8 9 0.9
5 s .E’
t 4 g 0-6 In
a: 10 - a if; 0 3
o .5 0.4 6
T5 :1)
‘D "5 0.2 ‘e’ °-7
> a 8
105 0.0 0.6

Phased SNPs rate

40 80 160
SNP Read Length

(a) Vector error rate

.1
O

.0
<0

80 160
SNP Read Length

((1) Phased SNP rate

40 80 160
SNP Read Length

(b) Perfect solution rate

|:| H-PoPG - H-PoP - HapTree - SDhaP
1 o5

3.5.3.

Running time (s)

_._.
06°.
—

40 80 160
SNP Read Length

(6) Running time

SNP Read Length

(C) Correct phasing rate

100

#0703
COD

Max memory (GB)
N
O

I I
160
SNP Read Length

0
-
.5
o

(1) Max resident memory

Fig. 8. Comparison of performance of H—PoPG, H-PoP, HapTree and SDhaP on simulated
triploid (k: = 3) sequencing data with different SNP read lengths. Each haplotype contained
22178 heterozygous SNPs. When the average SNP read length was 40 (80, 160), the average
number of SNP reads and the SNP read coverage were 19719.2 (9827.7, 4877.3) and 35.6
(35 .5, 35 .2), respectively.

Linux Cluster, each with a subset. As for the test with l = 80, since HapTree
could only ﬁnish 4 subsets in 7 days, the results of HapTree in Figure 8
are the averages of its results on the 4 subsets. As for the test with l =
160, HapTree was unable to terminate on any subset in 7 days and hence
its results are missing in Figure 8. Figure 8 shows again that H-PoPG is
the best in terms of vector error rate and perfect phasing rate. The correct
phasing rates of H-PoPG, H-PoP and HapTree were all more than 99.8%,
while those of SDhaP were less than 94%. With regard to running time and
memory, H-PoPG and H-PoP were clearly more efﬁcient than the other
two algorithms.

4 Conclusion

With the rapid development of sequencing technologies, reconstructing
the multiple haplotypes of a polyploid from DNA sequencing reads is
becoming more and more practical. In this paper, we modeled polyploid
haplotyping as a combinatorial optimization problem to partition the input
reads, called the Polyploid Balanced Optimal Partition (PBOP) problem.
Since the problem is NP-hard, we developed a heuristic algorithm H-
PoP for it. When the genotype information is available, we also proposed
a genotype constrained version, called PBOPG, of the problem and
designed a corresponding heuristic algorithm H-PoPG. Note that these

9mg ‘09 1sn8nV uo saraﬁuV s01 ‘121u10111123 10 A11s19A1uf1 112 /810's112umo[p101x0'sor112u1101u101q/ﬁd11q 111011 popcorn/hog

 

methods are very different from our previous methods for dealing with
diploids (Xie et al., 2012) since they consider the distance between the
consensus haplotypes of different groups while the previous methods
for diploids calculates the distance between reads belonging to different
groups. We compared our algorithms with three recent state-of-the-art
polyploid haplotyping algorithms SDhaP, HapTree and HapCompass on
both simulated and real data. Our extensive test results showed that H-
PoPG was generally more accurate in reconstructing haplotypes than
SDhaP, HapTree and HapCompass, and H-PoP was able to achieve
comparable (though slightly worse) performance without the genotype
information. Furthermore, H-PoPG and H-PoP ran much faster than
SDhaP, HapTree and HapCompass, and could effectively handle long reads
and deep read coverage.

Our experiments on real data also showed that H-PoP could be used
to infer the number of chromosomes of an organism (i. e. its ploidy), since
when the parameter k is set smaller than the ploidy of the organism, the
MEC rate of H-PoP would be much larger than the sequencing error rate.

Funding

This work has been supported in part by the National Natural Science
Foundation of China under grant NO. 61370172 and US National Science
Foundation grant DBI- 1262107.

References

Aguiar, D. and Istrail, S. (2013). Haplotype assembly in polyploid genomes and
identical by descent shared tracts. Bioinformatics, 29(13), i352—60.

Bafna, V., Istrail, S., Lancia, G., and Rizzi, R. (2005). Polynomial and APX-
hard cases of the individual haplotyping problem. Theoretical Computer Science,
335(1), 109—125.

Berger, E., Yorukoglu, D., Peng, J ., and Berger, B. (2014). HapTree: a novel Bayesian
framework for single individual polyplotyping using NGS data. PLoS ComputBiol,
10(3), e1003502.

Bonizzoni, P., Dondi, R., Klau, G. W., Pirola, Y., Pisanti, N., and Zaccaria, S. (2015).
On the ﬁxed parameter tractability and approximability of the minimum error
correction problem. volume 9133 of LNCS, pages 100—113. Springer International
Publishing.

Browning, S. R. and Browning, B. L. (2011). Haplotype phasing: existing methods
and new developments. Nat Rev Genet, 12(10), 703—14.

Chen, Z. Z., Deng, F. and Wang, L. (2013). Exact algorithms for haplotype assembly
from whole-genome sequence data. Bioinformatics, 29(16), 1938—45.

Cilibrasi, R., van Iersel, L., Kelk, S., and Tromp, J. (2007). The complexity of the
single individual SNP haplotyping problem. Algorithmica, 49(1), 13—36.

Curtin, C. D., Borneman, A. R., Chambers, P. J ., and Pretorius, I. S. (2012). De-novo
assembly and analysis of the heterozygous triploid genome of the wine spoilage
yeast Dekkera bruxellensis AWRIl499. PLoS One, 7(3), e33840.

Das, S. and Vikalo, H. (2015 ). SDhaP: haplotype assembly for diploids and polyploids
Via semi-deﬁnite programming. BMC Genomics, 16, 260.

Duitama, J ., Huebsch, T., McEwen, G., Suk, E.-K., and Hoehe, M. R. (2010).
ReFHap: a reliable and fast algorithm for single individual haplotyping. In
Proceedings of the First ACM international Conference on Bioinformatics and
Computational Biology, pages 160—169, Niagara Falls, New York. ACM.

Genovese, L. M., Geraci, F., and Pellegrini, M. (2008). SpeedHap: an accurate
heuristic for the single individual SNP haplotyping problem with many gaps, high
reading error rate and low coverage. IEEE/ACM Trans Comput Biol Bioinform,
5(4), 492—502.

He, D., Choi, A., Pipatsrisawat, K., Darwiche, A., and Eskin, E. (2010).
Optimal algorithms for haplotype assembly from whole-genome sequence data.
Bioinformatics, 26(12), il83—90.

Huang, W., Li, L., Myers, J. R., and Marth, G. T. (2012). ART: a next-generation
sequencing read simulator. Bioinformatics, 28(4), 593—4.

Lancia, G., Bafna, V., Istrail, S., Lippert, R., and Schwartz, R. (2001). SNPs
problems, complexity and algorithms. In F. M. auf der Heide, editor, Proc. Ann.
European Symp. on Algorithms (ESA), volume 2161 of Lecture Notes in Computer
Science, pages 182—193, Berlin/Heidelberg. Springer.

Leitch, A. R. and Leitch, I. J. (2008). Genomic plasticity and the diversity of polyploid
plants. Science, 320(5875), 481—3.

Li, H. (2011a). Improving SNP discovery by base alignment quality. Bioinformatics,
27(8), 1157—8.

Li, H. (2011b). A statistical framework for SNP calling, mutation discovery,
association mapping and population genetical parameter estimation from
sequencing data. Bioinformatics, 27(21), 2987—93.

Li, H. and Durbin, R. (2009). Fast and accurate short read alignment with Burrows-
Wheeler transform. Bioinformatics, 25(14), 1754—60.

Li, H., Handsaker, B., Wysoker, A., Fennell, T., Ruan, J ., Homer, N., Marth, G.,
Abecasis, G., and Durbin, R. (2009). The sequence alignment/map format and
samtools. Bioinformatics, 25(16), 2078—9.

Lippert, R., Schwartz, R., G.Lancia, and Istrail, S. (2002). Algorithmic strategies
for the single nucleotide polymorphism haplotype assembly problem. Brief.
Bioinform, 3(1), 1—9.

Margulies, M., Egholm, M., Altman, W. E., Attiya, S., et al. (2005). Genome
sequencing in microfabricated high-density picolitre reactors. Nature, 437 (7057),
376—80.

Panconesi, A. and Sozio, M. (2004). Fast hare: a fast heuristic for single
individual SNP haplotype reconstruction. In I. Jonassen and J. Kim, editors,
Proc. WABI, volume 3240 of Lecture Notes in Computer Science, pages 266—277,
Berlin/Heidelberg. Springer.

Patterson, M., Marschall, T., Pisanti, N., van Iersel, L., Stougie, L., Klau, G. W.,
and Schonhuth, A. (2015). WhatsHap: weighted haplotype assembly for future-
generation sequencing reads. J Comput Biol, 22(6), 498—509.

Pirola, Y., Zaccaria, S., Dondi, R., Klau, G. W., Pisanti, N., and Bonizzoni, P.
(2015). HapCol: accurate and memory-efﬁcient haplotype assembly from long
reads. Bioinformatics, 10.1093/bioinformatics/btv495.

Renny-Byﬁeld, S. and Wendel, J. F. (2014). Doubling down on genomes: polyploidy
and crop plants. Am J Bot.

Wang, J ., Xie, M., and Chen, J. (2010). A practical exact algorithm for the individual
haplotyping problem MEC/GI. Algorithmica, 56(3), 283—296.

Wang, R. 8., Wu, L. Y., Li, Z. P., and Zhang, X. S. (2005). Haplotype reconstruction
from SNP fragments by minimum error correction. Bioinformatics, 21(10), 2456—
2462.

Xie, M., Wang, J ., and Chen, J. (2008). A model of higher accuracy for the individual
haplotyping problem based on weighted SNP fragments and genotype with errors.
Bioinformatics, 24(13), i105—l3.

Xie, M., Wang, J ., Chen, J ., Wu, J ., and Liu, X. (2010a). Computational models and
algorithms for the single individual haplotyping problem. Current Bioinformatics,
5(1), 18—28.

Xie, M., Wang, J., and Chen, J. (2010b). A practical parameterised algorithm for
the individual haplotyping problem MLF. Mathematical Structures in Computer
Science, 20(5), 851—863.

Xie, M., Wang, J., and Jiang, T. (2012). A fast and accurate algorithm for single
individual haplotyping. BMC Systems Biology, 6(Supp12), S8.

9mg ‘09 1sn8nV uo saraﬁuV s01 ‘121u10111123 10 A1rs19Aruf1 112 /810's112umo[p101x0'sor112u1101urorq/ﬁd11q 111011 popcorn/hog

