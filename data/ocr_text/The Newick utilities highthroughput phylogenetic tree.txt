Vol. 26 no. 13 2010, pages 1669-16 70
APP S N O  doi:10.1093/bioinformatics/btq243

 

Phylogenetics

Advance Access publication May 13, 2010

The Newick utilities: high-throughput phylogenetic tree

processing in the UNIX shell

Thomas Junierl’2’*

and Evgeny M. Zdobnovl’z’3

1Department of Genetic Medicine and Development, University of Geneva Medical School, 2Swiss Institute of
Bioinformatics, 1 rue Michel—Servet, 1211 Geneva, Switzerland and 3Imperial College London, South Kensington

Campus, SW7 2AZ, London, UK

Associate Editor: Alex Bateman

 

ABSTRACT

Summary: We present a suite of UNIX shell programs for processing
any number of phylogenetic trees of any size. They perform
frequently-used tree operations without requiring user interaction.
They also allow tree drawing as scalable vector graphics (SVG),
suitable for high-quality presentations and further editing, and as
ASCII graphics for command-line inspection. As an example we
include an implementation of bootscanning, a procedure for finding
recombination breakpoints in viral genomes.

Availability: C source code, Python bindings and executables
for various platforms are available from http://cegg
.unige.ch/newick_utils. The distribution includes a manual and
example data. The package is distributed under the BSD License.
Contact: thomas.junier@unige.ch

Received on March 3, 2010; revised on April 27, 2010; accepted on
April 29, 2010

1 INTRODUCTION

Phylogenetic trees are a fundamental component of evolutionary
biology, and methods for computing them are an active area of
research. Once computed, a tree may be further processed in various
ways (Table 1). Small datasets consisting of a few trees of moderate
size can be processed with interactive GUI programs. As datasets
grow, however, interactivity becomes a burden and a source of
errors, and it becomes impractical to process large datasets of
hundreds of trees and/or very large trees without automation.

Automation is facilitated if the programs that constitute an
analysis pipeline can easily communicate data with each other.
One way of doing this in the UNIX shell environment is to make
them capable of reading from standard input and writing to standard
output—such programs are called ﬁlters.

Although there are many automatable programs for computing
trees [e.g. PhyML (Guindon and Gascuel, 2003), PHYLIP
(Felsenstein, 1989)], programs for processing trees [e.g. TreeView
(Page, 2002), iTOL (Letunic and Bork, 2007)] are typically
interactive. Here, we present the Newick utilities, a set of
automatable ﬁlters that implement the most frequent tree—processing
operations.

 

*To whom correspondence should be addressed.

Table 1. Selected Newick utilities programs and their functions

 

Program Function

 

Extracts clades (subtrees), speciﬁed by labels

Extracts branch lengths in various ways (from root,
from parent, as matrix, etc.)

Draws trees as ASCII or SVG (suitable for further
editing for presentations or publications), several
options

Reports matches of a tree in a larger tree

Orders tree nodes, without altering topology

Changes node labels

Reroots trees on an outgroup, speciﬁed by labels

Trims a tree at a speciﬁed depth

Retains topological information

nw_clade
nw_di s tance

nw_di splay

nw_match
nw_order
nw_rename
nw_reroot
nw_trim
nw_topology

 

SVG, Scalable vector graphics.

2 RESULTS

The Newick utilities have the following features:

0 no user interaction is required;

0 input is read from a ﬁle or from standard input; output is written
to standard output;

° all options are passed on the command line (no control ﬁles);
0 the input format is Newick (Archie et al., 1986);

° the output is in plain text (Newick, ASCII graphics or SVG);
0 there are no limits to the number or size of the input trees;

0 each program performs one function, with some variants; and

° the programs are self—documenting (option —h).

2.1 Example: Bootscanning

Bootscanning (Salminen, 1995) locates recombination breakpoints
by identifying (locally) closest relatives of a reference sequence. An
example implementation is as follows:

(1) produce a multiple alignment of all sequences, including the
reference;

(2) divide the alignment into equidistant windows of constant
size (e. g. 300 bp every 50 bp);

(3) compute a maximum—likelihood tree for each window;

(4) root the trees on the appropriate outgroup (not the reference);

 

© The Author(s) 2010. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non—Commercial License (http://creativecommons.org/licenses/
by—nc/2.5), which permits unrestricted non—commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.

112 /§JO'SIBUJn0[pJOJXO'SOIlBIHJOJUIOIQ/ﬁdnq mm; popeommoq

9IOZ ‘Ig1sn8nv I102:

IJunier and E.M.Zdobnov

 

Bootscanning of HRV_3UTR.dna WRT CL073908, slice size 300 nt

 

 

 

 

 

E

g 0.4 I I I I I 

3 0.35 - - HRV-88

5; 03 . . HRV-7 —

3 HRV-89 —
0.25 - .

g HRV-36

9 0.2 - - HRV-9

.52 _ _ HRV-32 —

9 0-15 HRV-67 —

9 0.1 - -

8 0.05 - .

C

E 0 I I I I I I

g 100 200 300 400 500 600 700 800

position of slice centre in alignment [nt]

Fig. 1. Bootscanning using PhyML, EMBOSS, Muscle, Newick utilities,
GNUPlot and standard UNIX shell programs. The species with the lowest
distance is the reference’s nearest neighbor (by distance along tree branches).
A recombination breakpoint is predicted near position 450, as the nearest
neighbor changes abruptly.

(5) from each tree, extract the distance (along the tree) from the
reference to each of the other sequences; and

(6) plot the result (Fig. 1).

The distribution includes a Bash script, bootscan. sh, that
performs the procedure with Muscle (Edgar, 2004) (Step 1),
EMBOSS (Rice et al., 2000) (Step 2), PhyML (Step 3),
GNUPlot (Step 6) and Newick utilities for Steps 4 and 5. This
method was used to detect breakpoints in human enterovirus
(Tapparel et al., 2007).

3 DISCUSSION

The Newick utilities add tree—processing capabilities to a shell user’s
toolkit. Since they have no hard—coded limits, they can handle large
amounts of data; since they are non—interactive, they are easy to
automate into pipelines, and since they are ﬁlters, they can easily
work with other shell tools.

Tree processing may also be programmed using a specialized
package [e.g. BioPerl (Stajich et al., 2002), APE (Paradis et al.,
2004) or ETE (Huerta—Cepas et al., 2010)], but this implies
knowledge of the package, and such programs tend to be slower
and use more resources than their C equivalents. The difference is
particularly apparent for large trees (Fig. 2).

3.1 Python bindings

To combine the advantages of a high—level, object—oriented language
for the application logic with a C library for fast data manipulation,
one can use the Newick utilities through Python’s c types module.
This allows one to code a rerooting program in 25 lines of Python
while retaining good performance (Fig. 2). A detailed example is
included in the documentation.

Some users will feel more at ease working in the shell or with
shell scripts, using existing bioinformatics tools; others will prefer
to code their own tools in a scripting language. The Newick utilities
are designed to meet the requirements of both.

ACKNOWLEDGEMENTS

We wish to thank the members of the E.Z. group for feedback and
beta testing.

 

     

 

 

 

O 5 mln /;
$2 _
O _
E .— _
(D
.E
g _
Newick Utils
5 - - - Newick Utils/Python ctypes
o' _ — ETE
APE
— BioPerI
I I I I I
O 5000 10000 15000 20000

Tree size [# leaves]

Fig. 2. Average run times (10 samples) of rerooting tasks on various tree
sizes in different implementations. The task involved reading, rerooting and
printing out the tree as Newick. Runs of the BioPerl and APE implementation
on the 20 GOO—leaf tree did not complete. Error bars show 1 SD. Computer:
3 GHz 64 bit Intel Core 2 Duo, 1GB RAM, Linux 2.6. Made with R (R
Development Core Team, 2008).

F unding: The Infectigen Foundation; Swiss National Science
Foundation (grant 3100A0—112588 to E.Z.).

Conﬂict of Interest: none declared.

REFERENCES

Archie,J. et al. (1986) http://evoluti0n.genetics.washington.edu/phylip/newicktree.html.

Edgar,R.C. (2004) MUSCLE: multiple sequence alignment with high accuracy and high
throughput. Nucleic Acids Res., 32, 1792—1797.

Felsenstein,J. (1989) PHYLIP - Phylogeny Inference Package (version 3.2). Cladistics,
5, 164—166.

Guindon,S. and Gascuel,O. (2003) A simple, fast, and accurate algorithm to estimate
large phylogenies by maximum likelihood. Syst. Biol, 52, 696—704.

Huerta-Cepas,J. et al. (2010) ETE: a python environment for tree exploration. BMC
Bioinformatics, 11, 24.

Letunic,I. and B0rk,P. (2007) Interactive Tree Of Life (iTOL): an online tool for
phylogenetic tree display and annotation. Bioinformatics, 23, 127—128.

Page,R. (2002) Visualizing phylogenetic trees using TreeView. Curr. Protoc.
Bioinformatics, Chapter 6, Unit 6.2.

Paradis,E. et al. (2004) APE: analyses of phylogenetics and evolution in R language.
Bioinformatics, 20, 289—290.

Rice,P. et al. (2000) EMBOSS: the European molecular biology open software suite.
Trends Genet, 16, 276—277.

R Development Core Team (2008) R: A Language and Environment for Statistical
Computing. R Foundation for Statistical Computing, Vienna, Austria. ISBN
3-900051-07-0.

Salminen, M. (1995) Identiﬁcation of breakpoints in intergenotypic recombinants of
HIV type I by bootscanning. AIDS Res. Hum. Retroviruses, 11, 1423—1425.

Stajich,J.E. et al. (2002) The Bioperl toolkit: Perl modules for the life sciences. Genome
Res., 12, 1611—1618.

Tapparel,C. et al. (2007) New complete genome sequences of human rhinoviruses shed
light on their phylogeny and genomic features. BMC Genomics, 8, 224.

 

1 670

112 /§.IO'SIBUJHOlpJOJXO'SOIlBIHJOJUIOICI/ﬁdnq 11101; popeommoq

9IOZ ‘Ig lsnﬁnv (10::

