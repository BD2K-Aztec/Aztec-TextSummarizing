Bioinformatics, 32(8), 2016, 1151—1157

doi: 10.1093/bioinformatics/btv738

Advance Access Publication Date: 16 December 2015
Original Paper

 

Sequence analysis

OMPPM: online multiple palindrome pattern
matching

Hwee Kim and Yo-Sub Han*

Department of Computer Science, Yonsei University, Seoul 120-749, Republic of Korea

*To whom correspondence should be addressed.
Associate Editor: John Hancock

Received on 23 August 2015; revised on 11 December 2015; accepted on 12 December 2015

Abstract

Motivation: A palindrome is a string that reads the same forward and backward. Finding palin—
dromic substructures is important in DNA, RNA or protein sequence analysis. We say that two
strings of the same length are pal—equivalent if, for each possible centre, they have the same length
of the maximal palindrome. Given a text Tof length n and a pattern Pof length m, we studythe pal—
indrome pattern matching problem that finds all indices isuch that Pand T[i — m—l— 1 : i] are pal—
equivalent.

Results: We first solve the online palindrome pattern matching problem in 0(m2) preprocessing
time and 0(mn) query time using 0(m2) space. We then extend the problem for multiple patterns
and solve the online multiple palindrome pattern matching problem in 0(mkM) preprocessing
time and 0(mkn + 0) query time using 0(mkM) space, where M is the sum of all pattern lengths,
mk is the longest pattern length and c is the number of pattern occurrences.

Availability and implementation: The source code for all algorithms is freely available at http://toc.

 

yonsei.ac.kr/OMPPM
Contact: kimhwee@cs.yonsei.ac.kr

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

Finding motifs and patterns in bio strings has been one of the most
popular topics in both computer science and biology (Adebiyi et 61].,
2001; Buhler, 2001; Parisi et 61]., 2003; Priifer et 61]., 2008;
Rigoutsos and Floratos, 1998). A palindrome is a string that reads
the same forward and backward. Namely, a string w is a palindrome
if w : wR, where wR denotes the reversal of w. If a substring of a
string is a palindrome, we say that the string has a palindromic sub—
string or palindromic structure. It is important to find palindromes
and identify similar palindromic structures in DNA, RNA or protein
sequence analysis (Gusfield, 1997). Since palindromic structures in
bio data reflect the capability of molecules to fold and form double—
stranded stems (Kolpakov and Kucherov, 2009), bio data with simi—
lar palindromic structures may have similar secondary structures.
Moreover, palindromic sequences are closely associated with DNA
breakage during gene conversion (Krawinkel et 61]., 1986), and pal—
indromic substructures are presented in CRISPIUCas9 (Kunin et 61].,

2007), which has been used for gene editing and gene regulation in
species (Mali et 61]., 2013). Therefore, it is useful to identify palin-
dromic substructures and palindromic equivalence efficiently.

We focus on the palindrome pattern matching problem intro-
duced by I et al. (2013). Given a text T of length n and a pattern P
of length m, the palindrome pattern matching problem is to find all
indices 1' such that P and T[i — m —l— 1 : i] have the same set of all cen—
tre—distinct maximal palindromes. See Figure 1 for an example.

I et al. (2013) presented two algorithms that solve the palin—
drome pattern matching for an arbitrary size alphabet. We notice
that both algorithms by I et al. (2013) require a preprocessing step
of T. This may slow down the whole process when T is an extremely
large text and I/O for T is considerably slow due to the large but
slow storages. Moreover, these algorithms might not be applicable if
T is a stream data. Many researchers designed online string algo-
rithms to avoid these problems, where each character in T is given
online, and we want to report intermediate results without reading

©The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 1151

9mg ‘09 1sn3nv uo sopﬁuv s01 111110;th aIo A11SJQA1UH 112 /§.IO'S[BU.IHO[p.IOJXO'SODBIHJOJUIOIQ/ﬁdllq 11101; popeommoq

H.Kim and Y.-S.Han

 

1152
19 =:[\(}lX(EIJrX 1\(}IX(EIJ[\
-~CGCUACGGAUACGAGUCC~~

%esg%e&

Fig. 1. An example of the palindrome pattern matching. Stripped boxes below
a string represent the set of all centre-distinct maximal palindromes with the
length at least 1. Note that the pattern on the left is matched, while the pattern
on the right is not matched due to the red-stripped box

whole T (Ahmad et al., 2003; Paten et al., 2009). For the palin—
drome pattern matching problem, we want to report all matching in-
dices i while reading T online. Based on the Knuth—Morris—Pratt
algorithm (Knuth et al., 1977), we first build an automaton A from
P and process T using A. For a text T of length n and a pattern P of
length m, our algorithm requires O(m2) preprocessing time and runs
in O(mn) query time using O(m2) space. We, furthermore, tackle
the online multiple palindrome pattern matching based on a modifi—
cation of the Aho—Corasick automaton (Aho and Corasick, 1975).
For multiple patterns P1,  ,Pk of length m1,  ,mk, our algo-
rithm requires O(mkM) preprocessing time and runs in O(mkn —l— c)
query time using O(mkM) space, where M is the sum of all pattern
lengths, mk is the longest pattern length and c is the number of pat—
tern occurrences. Note that the second algorithm considers multiple
patterns and has the same query time as the first algorithm except
the number of pattern occurrences.

2 Methods

2.1 Strings, palindromes and finite automata

A finite—state automaton (FA) A is specified by A = (Q,Z, 5,s,F),
where Q is a set of states, 2 is an alphabet, (3 : Q X Z —> Q is a tran-
sition function, s E Q is the start state and P Q Q is a set of final
states. A string w is accepted by A if there is a labeled path from s to
a state in P such that the path spells out w. For complete background
knowledge in automata theory, the reader may refer to textbooks
(Hopcroft and Ullman, 1979; Wood, 1986).

For a string w, let wR denote the reversed string of w. A string w
is called a palindrome if w : wR. The radius of a palindrome w is
l—Z’l. The centre of a palindromic substring w[i : j] of a string w is 
A palindromic substring w[i : j] is called the maximal palindrome at
the centre  if no other palindromes at the centre  have a larger
radius than w[i : j]; in other words, if w[i — 1] 7E w[/' —l— 1], i : 1 or
j =  Let Pals(w) be the set of all centre—distinct maximal palin-
dromes where each element is encoded by a pair of its centre and ra—
dius (I et al., 2010). Namely, given a string w,

palindrome at centrec : 1,1.5,2,  ,n

w[c — r —l— 0.5 : c —l— r — 0.5] is amaximal
Pals(w) : (c, r)( .

For example, if w : ahhacahhha, we have
Pals(w) : {(1,0.5),(1.5,0),(2,0.5),(2.5,2),(3,0.5),
(3.5,0) 4,0.5),(4.5,0),(5,3.5),(5.5,0),
(6,0.5) 6.5,0),(7,0.5),(7.5,1),(8,2.5),
(8.5,1),(9,0.5),(9.5,0),(10,0.5)}.

a(
a(

For two strings w and z of the same length, we say that w and z
are pal-equivalent if Pals(w) : Pals(z). Manacher (1975) proved

that for a string w of length m, we can compute Pals(w) in O(m)
time. From now on, we assume that the elements of Pals(w) are
sorted in increasing order of centrers c—the algorithm of Manacher
(1975) computes the elements of Pals(w) in this order.

We first tackle the palindrome pattern matching problem in
Definition 2.1. Note that while I et al. (2013) find start positions of
matching occurrences, we search for end positions of matching
occurrences.

Definition 2.1 (Palindrome Pattern Matching, Pal—Matching in
Short): Given a text T of length n and a pattern P of length m,
compute all positions i such that Pals(P) : Pals(T[i — m —l— 1 : 

We then define the multiple palindrome pattern matching prob-
lems as follows:

Definition 2.2 (Multiple Palindrome Pattern Matching, MPal—Matching
in Short): Given a text T of length n and patterns P1,  ,Pk of
length m1,  ,mk, compute all pairs ofa position i and a corres-
ponding pattern P,- such that Pals(P)) : Pals(T[i — m,- —l— 1 : 

For a pattern matching problem, we can consider an environment
where we want to report all matching occurrences at position i after
reading each character T[i]. This often requires a preprocessing step
of the pattern P—we call such a problem an online pattern matching
problem. We call the time to preprocess P preprocessing time, and the
time to read T and find all matching occurrences query time.

2.2 The algorithm for Pal—matching

We start from designing an algorithm for Pal-Matching in
Definition 2.1. The main idea of our algorithm is to design a special
automaton simulating the Knuth—Morris—Pratt algorithm (Knuth
et al., 1977). Before we design an algorithm, we have the following
observation (See Figure. 2 for an illustration): For two strings w, z
and an index i, if there exists (c, r) E Pals(w) such that c 3i and
c —l— r — 0.5 2 i, then z[i] = z[2c — i]. If there is no (c, r) satisfying the
condition, then z[i] E {z[2r — i]|(c, r) E Pals(w) andc —l— r — 0.5 =
i — 1}. Note that z[i] is computed based on z[i]’s for j < i, instead of
characters in w. This leads us to define z to be a new sequence of
variables, where we can assign characters to variables based on
equality and inequality conditions, and the result string is pal—
equivalent to w. Based on the observation, we define a variable pat-
tern of P as follows:

Definition 2.3: For a pattern P of length m over 2 of size t, a vari—
able pattern P’ is defined by an array A[m] of variables and an array
B[m] of inequality conditions satisfying the following conditions:

1. P’[i] : A[l,-] for 1 32,],- g m.
If there exists (c, r) E Pals(P) where c g i and c—l— r — 0.5 2 i,
then 1,- = 1254, and thus, P’ = P’ [2c — i].

3. Otherwise, for all j E {2r — i|(c, r) E Pals(P) andc —l— r — 0.5 =
i— 1}, P’[i] 7E P’[/]. For P’[i] : A[l,-] and P’[/] : A[l,-], we use
BM] : l,- and = i to denote P’[i] 7E P’[/].

Namely, if we assign characters to A based on inequality condi—
tions, then Pals(P’) : Pals(P). Initially, we have no variables for
constructing P’. The inequality condition of Definition 2.3 implies
that for every index i where every maximal palindrome with a centre
c g i ends before i, we need to introduce a new variable satisfying in-
equality conditions with respect to the previously—used variables.
We construct an array A[m] of variables. We also construct an array
B[m] that represents the inequality conditions between all pairs of

91% ‘09 1sn3nv uo sopﬁuv s01 ‘BIUJOJIIBD aIo AusroAtun 112 /§.IO'S[BU.IHO[p.IOJXO'SODBIHJOJUIOIQ/ﬁdllq 11101; popeommoq

1153

 

 

 

 

 

 

 

 

 

 

(c,r) E Pals(w) T
i
Fig. 2. Two cases in searching pal-equivalent strings. (a) There exists (0, r)
E Pals(w) such that c g i and 0+ r — 0.5 2 i. (b) There is no (0, r) satisfying
the condition. Stripped boxes represent maximal palindromes

 

 

 

 

 

 

p=|A|G|C|G|T|A| B
1 2,3,4
px=|1|l2|l3|12|14|15| 21,3,4,5
3 1,2,4
A47AA1,A2,A3,A5=> 4 1,2,3,5
5 2,4

 

 

 

 

Fig. 3. A variable pattern P’ and an array B of inequality conditions for P =
AGCGTA. Variables A[i] are written as A,- in the figure for better readability

variables. Thus, if j E B[i], then the condition A[i] 7E  holds. Now
we construct P’ as described in Algorithm 1. Figure 3 shows P’ and
B for P :AGCGTA.

Based on Definition 2.3, we establish the following result: after
running Algorithm 1, if there is a surjection of A to 2 where A[i]
7E  holds for all i, j such that j E B[i], then Pals(P’) : Pals(P).
Moreover, given a string w such that Pals(w) : Pals(P), there exists
a surjection of A to 2 such that P’ = w.

We analyze the time and space complexity of Algorithm 1.
Computing Pals(P) takes O(m) time. Since the for loop from line 6
to line 10 takes O(m) time and line 12 also takes O(m) time, the
time complexity of the algorithm is O(mz). For the space complex—
ity, A[m] and P’ requires O(m) space and B[m] requires O(mz) space.
Therefore, the space complexity is O(mz).

Once we have P’, we can construct a special automaton A = (Q,
AU{]j},5,s,F,Z,B,5f,7-t) that finds all occurrences of P’ in T as
follows:

° Q is the set of states,

° A is the array of variables (which is used as an alphabet in A)
and (j is a wildcard variable,

° (3 : Q X A —> Q is the transition function,

° s is the start state,

° F is the set of ﬁnal states,

° 2 is the alphabet of the original pattern P,

° B is the array for inequality conditions of variables,

° 5f : Q —> Q is the failure transition function, and

' H : Q —> 2AX(AU{l}) is the set of injective functions for variables.

 

Note that four parameters 2, B, (3f, H—are added to the defin-
ition of a traditional FA. The automaton A simulates the Knuth—
Morris—Pratt algorithm, using P’ instead of P as a pattern. In the
Knuth—Morris—Pratt algorithm, when there occurs a mismatch, the al—
gorithm uses the longest suffix of the prefix of T read so far, which is a
prefix of P’. The automaton A simulates the process when a mismatch
occurs by (3f, and additionally, changes surjection of A to 2 according
to H. Algorithm 2 constructs an automaton A from P and Figure 4
shows an example automaton constructed from P : AGCGTA.

We establish the time and space complexity of Algorithm 2 as
follows: We can compute Pals(P) in O(m) time and, based on
Pals(P), line 11 takes O(m) time. Since other lines in the algorithm

 

Algorithm 1: ConstructVariablePattern

 

Input: Pattern P of length m over 2 of size If
Output: Variable Pattern P', array A[m] of variables,
array B[m] of inequality conditions
1 construct A[m], B[m] and compute Pals(P) // we insert
(0.5, 0) to Pals(P) for convenience

2 c<—0.5,l<—0,3<—0

3 forz' <— 1tomdo

4 if l 2 ithen P’  <— P’ [20—2’] else

5 s<—s+1,P’[z']<—A[s]

6 for each (0’, r’) E Pals(P) where c S i do

7 ifc’—l—r’—0.5=i—1then

8 AU] <— P’[z' — 1]

9 A[l'] <— P’[C’ —l— 7" — 0.5]

10 add l’ to B[l], add l to B[l’]

11 ifl S ithen

12 ﬁnd 0’ such that (c’, r’) E Pals(P), c’ — r’ —|— 0.5 S i,
i—l— 1 g c’ —l— r’ — 0.5 and c’ + r’ — 0.5 is the smallest.

13 ifc’§i+0.5thenl<—c’—l—r’—0.5,c<—c’elseif

 

_ l=i—1then l<—l—|—1
4 returnP’,A,B

 

H

 

 

Algorithm 2: ConstructSingleAutomaton

 

Input: Pattern P of length m over 2 of size t

Output: Automaton A = (Q, A U {#}, 6, s, F, E, B, 6f, ’H)
1 ConstructVariablePattern(P)
2 add go to Q

3 fori<— 1tom—l—1d0
4 if 22 7E m —|— 1 then
5

6

 

 

add (1,- to Q
_ 6(qi—1,A[j]) <— (Ii for P’lil = A[J'l
7 ifi = 2 then
8 5f(q1) <— (10
9 _ add (A[1] <— #) to H(q1)
10 else if i > 2 then
11 ﬁnd the smallest 2" such that
Pals(P’[1 : i—i’]) = Pals(P’[i’ : i—1])
12 6f(qi—1) <— Qi—v
13 forl<—1toi—z"d0
14 add (A[h] <— A[h’]) to H(q,-_1) for P’[l] = A[h]
] and P’ [l+z"—1] = A[h’]
15 for each A[h] in P’ [1 : i—1] without injective function
in 7-i(q,-_1) d0
16 |_ add (A[h] <— #) to H(qi_1) for A[h]
17 return (Q,A U {#}, 6, go, {qm}, ELB, 6f, ’H)

 

 

 

Aﬁ—Ag Aﬁ—A2
A1<—A3 A3<—A4 A2<—A4
A3<—# A4(—# A3(—A5
I ’ ’ ‘ ~ I ’ ' ~ \ A4(—#
’, \>: ’———:>\__§5—(:#
’ ’ «T \ 7 ‘ x
I I, ’ \ \ x
I I, \ \ \ \
A1 ' A2 ’—’A3 H A2 —’.A“ —’.A5
‘. _ _ _ _ _ _ _ _ _ _ _ _
A <—A Aﬁ—Az
lAi<—#l TAIZWE] AWAS
A3<—#

 

Fig. 4. An automaton A constructed from P = AGCGTA. Variables A[i] are
written as A,- in the figure for better readability. A dashed transition from a
state p is the failure transition 5f(p) and the label on the failure transition with
square brackets represents the set of injective functions H(p)

9mg ‘09 1sn3nv uo sopﬁuv s01 ‘BTUJOJTIBD aIo AnsroAtun 112 /B.IO'S[BU.IHO[p.IOJXO'SOTlBIIIJOJUTOTQ/ﬁdllq 11101; popeommoq

1154

H.Kim and Y.-S.Han

 

 

Algorithm 3: FindPalindromeMatching

Input: Text T of length n and pattern P of length m over 2 of
size t
Output: Indices i such that Pals(P) = Pals(T[i—m—l—1 : 
1 ConstructsingleAutomaton(P)
2 fort <— 1 to m d0  <— # q; <— qo // current state
3 fort <— 1tondo
4 While one of the following conditions holds for
6(qlaAljl) = ql+1
1.ql 2 gm
2Ali] 7é Tlil, #
3.A[j] = # and there exists 3" E B[j] such thatALj’] = 

 

5 do

6 for each (A[h] <— A[h’]) E ’H(ql) d0 A[h] <— A[h’]
Cll <— 5f(ql)

7 ifA[j] = # then A[j] <—  ql <— ql+1

8 if q) 2 gm then return i

 

 

except for loops require constant time, the total time complexity is
O(mz). For the space complexity, there are O(m) states in A. For
each state, there are one out—transition, one outgoing failure transi-
tion and O(m) injective functions. Therefore, the space complexity
is O(mz).

Now we present an algorithm that solves Pal—Matching using A.
Based on the Knuth—Morris—Pratt algorithm, Algorithm 3 processes
T in A and reports all end—indices of matching occurrences.

We analyze the time and space complexity of Algorithm 3.
Checking the condition in line 5 takes O(m) time, and the for loop
in line 6 takes O(m) time. Note that lines 5—6 runs once for one exe—
cution of line 6, where 1 decreases. For each i, 1 increases by 1 in line
7. Since I Z 0, the total runtime of the While loop from line 5 to line
6 is O(mn). Combined with Algorithm 2 in line 1, the algorithm re-
quires O(m2 —1— mn) time and O(mz) space. Thus, given a text T of
length n and a pattern P of length m, we can solve the online palin-
drome pattern matching problem with O(mz) preprocessing time
and O(mn) query time using O(mz) space.

2.3 The algorithm for MPal—matching

Now we extend the previous algorithm to solve MPal—Matching.
The basic idea of the algorithm is to process multiple patterns at
once with a single automaton, based on the idea of the Aho—
Corasick automaton (Aho and Corasick 1975). Assume that given
patterns P1,  ,Pk of length m1,  ,mk are sorted by ascending
order with respect to the length of the pattern and M is the sum of
all pattern lengths. For P1,  ,Pk, we first compute variable pat—
terns P’1,  ,PZ, while merging all B[m,]s to one B[le] It is
straightforward to show that the process, which we call
ConstructMultiVariablePattern, runs in O(mkM) time using O(mk
M) space.

We define an automaton B : (Q,A U {(1}, 6,s,F,Z,B, 6f,H, 6p).
The definition of B is similar to the definition of A, except for an
additional parameter: The pattern suffix transition function 6p : Q
—> Q contains transitions to find multiple matching occurrences on
a single state. The automaton B simulates the Aho—Corasick algo—
rithm, using P], . . . ,PZ instead of P1, . . . ,Pk as patterns. Algorithm
4 constructs B from P1,  ,Pk. We use a supplementary function
StateForVP to return the state denoting the end of a given variable
pattern. Figure 5 shows an example automaton constructed from
P1 = AGA,P2 = ACTG,P3 = ATAT, P4 = TCTGC.

We analyze the time and space complexity of Algorithm 4. We
can compute Pals(Pi) in O(mi) time and, based on Pals(Pi), lines 14

 

U—’©
+ _ _ _ _
Aﬁ—Ag

A2 4—A3
A3(—A4
A4<—#

 

Fig. 5. An automaton B constructed from P1 = AGA, P2 = ACTG,
P3 = ATAT, P4 = TCTGC. Variables A[i] are written as A,- in the figure for bet-
ter readability. Dashed transitions represent failure transitions and dotted
transitions represent pattern suffix transitions

 

Algorithm 4: ConstructMultiAutomaton

 

 

Input: Patterns P1, . . . , Pk of length m1, . . . ,mk over 2 of
size t
Output: Automaton B = (Q, AU {#}, 6, s, F, E, B, 6f, H, 610)
1 ConsturctMultiVariablePattern(P1, . . . , P1,)
2 add q), to Q
3 p1,...,pk <—q)\
4 fori<— 1tomk+1do
5 for each P,’ where i g m,- —l— 1 do
6 let P,’  2 AU] and pj = qs
7 ﬁnd the smallest i' and corresponding j ’ such that
Pals(PJHI : i—i’]) = Pals(Pﬂi' : i—1])
8 ifiyémj—l—lthen
9 6(q87Alll) <— qs-z
10 add gs.) to Q
11 ifi = 2 then
12 6f (gs) (— (IA
13 add (A[1] <— #) to 7-i(qs)
14 else if i > 2 then
15 6f(qs) <—StateForVP(PJ’/ [1 : i—i’])
16 forg<—1toi—z"do
17 add (A[h] <— A[h’]) to ’H(qs) for
] Pj’,[g] = A[h] and P,’[g-l—i’—1] 2 AW]
18 for each A[h] in P; [1 : i—l] without injective
function in ’H(qs) d0
19 |_ add (A[h] <— #) to ’H(qs)
20 ifizmj—l—lthen
21 add q, to F
22 _ ifz' — z" = 772,-, then 6p(pj) <—StateForVP(P,’/)
23 _ pj <— q$~l

 

 

N

4 return (Q, A U {#}, 6, q)” F, Z,B, 6f, H, 6,,)

 

 

Function StateForVP
Input: Variable Pattern P’
Output: State q,
1 qs <— (IA
2 fori <— 1 to |P’| do qs <— qs.l for P’[z'] 2 AU] return qs

 

 

9mg ‘09 1sn8nv uo sopﬁuv s01 ‘121u10111123 aIo AnsroAtun 112 /§.IO'S[BU.IHO[p.IOJXO'SOTlBIIIJOJUTOTQ/ﬁdllq 11101; pop1201umoq

OMPPM

1155

 

 

Algorithm 5: FindMultiPalindromeMatching
Input: Patterns P1, . . . ,Pk of length m1, . . . ,mk over 2 of
size if

Output: Pairs of an index i and a pattern Pj such that
Pals(Pj) = Pals(T[i—mj—l—1 : 

 

1 ConstructMultiAutomaton(P1, . . . ,Pk)
2 fort <— 1 to m}, do  <— # q; <— qx // current
state

3 fort <— 1tondo

4 while one of the following conditions holds for all A[j]

such that 6(ql, A[j]) 75 (ll

l.ql has no out transition

2Ali] 79 Tlil, #

3.A[j] : # and there exists 3" E B[g] such thatA[j'] : 
and 6(ql,A[j]) =StateForVP(Pé[1 : |l|+1])

5 d0

6 L for each (A[h] <— A[h’]) E H(ql) do A[h] <— A[h’]

ql <— 5f(ql)
7 ifAljl = # then Ali] <— Tlil qz <— 6(qz,Aljl)
8 if q; E F then

9 return (i, le) where StateForVP(P,’/) = q;

10 pl <— (11

11 while 6,,(pl) 75 (2) do

12 Pl <— 61) (Pl)

13 return (73, sz) where StateForVP(P,’,) = p;

 

 

and 21 takes O(mk) time. Since other lines in the algorithm except
for loops require constant time, the main loop from lines 4 to 23
takes O(mkM) time. Therefore, the total time complexity is
O(mkM). For the space complexity, there are O(M) states in B.
For each state, there are one out—transition, one outgoing
failure transition, at most one outgoing pattern suffix transition and
O(mk) injective functions. Therefore, the space complexity is


We design Algorithm 5 similar to Algorithm 3 on B to solve
MPal—Matching with an additional process: whenever the current
state q; reaches a final state qf, return all patterns that are con—
nected by 6,, from qf. This additional process requires O(c) total
runtime, where c is the number of pattern occurrences. Since the
size of H for each state in B is bounded to mk, the algorithm
requires O(mkM +mkn—l— c) time and O(mkM) space. Therefore,
given a text T of length n and a pattern P of length m, we can
solve the online multiple palindrome pattern matching problem
with O(mkM) preprocessing time and O(mkn —l— c) query time using
O(mkM) space.

3 Experiments

We design three experiments to estimate the average performance of
the algorithms. For Algorithm 3, we first establish two parameters—
the length m of the pattern and the length n of the text—and esti—
mated three values—the preprocessing time tp, the query time tq, the
number s of variables—for random DNA patterns and texts.
Second, we calculate the average number of variables for small m by
considering all possible patterns of length m. Third, for Algorithm
5, we use real RNA data as a pattern set and measure the pre—
processing time tp and the query time tq by two parameters—the
sum M of all pattern lengths and the longest pattern length mk.
The details of the experiment are as follows:

1. For the ﬁrst experiment,

° The length m of the pattern changes from 10 to 100 by 10,
and then from 100 to 1000 by 100. The length n of the text
changes from 10 000 to 100 000 by 10 000.

° For each pair of m and n, we randomly generate a pattern
and a text from an alphabet {A, G, C, T} 100 times, and cal—
culate the average value of the preprocessing time tp, the
query time tq and the number of variables s.

2. For the second experiment, we iterate all possible strings for
1 g m g 10 and calculate the average of s for each m.
3. For the third experiment,

° We use 24 RNA secondary structures belonging to distinct
RNA families from the Rfam database (Burge et al., 2013) as
a superset of a pattern set. The set of RNA secondary struc—
tures used is in the supplementary material.

' We use a RNA—sequence of length 100 000 from the
ArrayExpress database (Brazma et al., 2003) as a text. We
checked that each pattern in the superset does not appear in
the text, which erases the factor c from the runtime.

° We run 100 iterations. For each iteration, we ﬁrst choose a
pattern pk, and then select each pattern in the superset with
the length less than |pk| with the probability % to form a set of
patterns for the iteration. We compute the preprocessing
time tp and the query time tq.

We obtain the following results from our experiments (note that
we have rounded our results to the nearest hundredth.):

° Preprocessing time of Algorithm 3: Figure 6 shows the prepro—
cessing time tp of Algorithm 3 according to the length m of the
pattern (the table for the graph is in the supplementary material).

° Query time of Algorithm 3: Figure 7 shows the query time tq of
Algorithm 3 according to the length m of the pattern and the
length n of the text (tables for graphs are in the supplementary
material).

° Number of variables: In Algorithm 3, the query time is bounded to
O(ns), where s is the number of variables. Figure 8 shows the num—
ber of variables s according to the length of the pattern m (The table
for the graph is in the supplementary material). The data for m =
1—10 is the average of s for all possible cases, and the data from m
= 10 to m = 1000 is the average for 100 random cases.

° Pre-processing time of Algorithm 5: Figure 9 shows the prepro—
cessing time tp of Algorithm 5, according to the sum of all pat—
tern lengths M and the longest pattern length mk.

° Query time of Algorithm 5: Figure 10 shows the query time tq of
Algorithm 5 according to the longest pattern length mk and the
sum of all pattern lengths M. We observe that tq is independent

 

 

 

 

)3
21H] if f
 N h
'  Er"-
0 m _ _ ﬁg -
0 200 400 601] 80G LOUD

'H i.

Fig. 6. Preprocessing time graph for Algorithm 3, where 10 g m g 1000. m
denotes the length of pattern and tp denotes the preprocessing time. We can
observe that tp follows the quadratic function of m since tp = O(mz).

9mg ‘09 1sn8nv uo sopﬁuv s01 ‘121u10111123 aIo AnsroAtun 112 /§.IO'S[BU.IHO[p.IOJXO'SOTlBIIIJOJUTOTQ/ﬁdllq 11101; pop1201umoq

H.Kim and Y.-S.Han

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

1156
I,D
. 
_ 

(m x 71,19)
r Linear Regression
0 '
0 0.2 0.4 0.6 0.8 1
m :x: n . 1]]?
1,000 HE, HE"
JET-ﬁr}-
U (m X 11.,qu
 Linear Regression
ﬂ  
0 0.2 0.4 0.0 0.8 l
m :x: n *103

Fig. 7. Query time graph for Algorithm 3. m denotes the length of pattern and
fa denotes the query time. We observe that tq is proportional to n and m since
tq = O(nm). Note that tq for n = 10000 and m = 100 is 13.02, whereas tq for
n = 100000 and m = 10 is 31.56. This implies that the increase of m affects tq
less than the increase of n

 

 

 

 

£1
41111 Brae-f”
243'”
no riff-T
2'00 EIGHT-
_ Jeff-Ti
o W
0 200 400 000 800 1 .000

111.

Fig. 8. Number of variable graph, where m denotes the length of the pat-
tern and 3 denotes the number of variables used. For m = 1—10, we observe
linear increase of s as m increases. The difference of s between m and m — 1
tends to decrease as m increases, but the difference rapidly converges
to 0.47, and we can easily approximate s 2 0.47m (Note that s = 468.78 when
m = 1000.)

 

  
  
  

 

 

 

 

 

 

60
{3| 3,.
Q _ f -f-
ﬁg'ﬁ ill}

(on, x M, £31)
— Linear Regression
1.5 2 2.5
on, in: Mr -105

Fig. 9. Preprocessing time graph for Algorithm 5. We observe that t,,, is pro-
portional to Mand mksince tp = O(mkM)

 

 

 

 

 

 

200
150
E?" n
=  ” 31'" If) C
+3" {to too  r: o o
C , CG 00 C D
50  neg  gceoooe 0
Cl 0m 5' E}
D o o '3 (1111,,0,”
0 20 40 00 80 100 120 140
1'11],;
100 1" U r“: O
80
E“ 00
E, . .
4.? 40
20 g,

 

 

ﬂ r$111,133]
0 200 400 000 300 1,0001,2001,4001,000

 

Fig. 10. Query time graph for Algorithm 5, considering mk and M. mk denotes
the length of the longest pattern, Mdenotes the sum of the lengths of all pat-
terns and tq denotes the query time. We observe that tq is independent
from M

 

 

(Fkar ti?)

 

 

 

 

 

 

 

 

 

 

500 o
Linear Regression
U 0 0.5 1 1.5 2 2.5
goback '105

l 1500
grotto
500
0

0 0.5 1 1.5:- 2 2.5 3 3.5
checkall +105

Fig. 11. Query time graph for Algorithm 5, considering goback and checkall.
goback denotes the number of changes on the array of variables, checkall de-
notes the number of pattern suffix transitions taken, and tq denotes the query
time. This graph shows that tq is proportional to goback, which is O(mkn) but
the average value is far less than mkn and not proportional to mkn

to M but it is not clear whether or not tq is proportional to mk.
We design another experiment to determine the factor that af—
fects mk most.

° T is a randomly generated text of length 100 000. We run 1000
iterations for different sets of patterns.
For each iteration, we choose mk between 100 and 200, and gen—
erate a set of random patterns, where M is 1000.

91m ‘Og 1sn8nv uo sepﬁuv s01 ‘etuiomeg JO AnsmAtun 112 /3,IO'S[BIIJHOIpJOJXO'SOTIBIHJOJUTOTQ/ﬂClllq 11101; pep1201umoq

OMPPM

1157

 

° We record the number of changes on the array of variables
(which we call goback) and the number of pattern sufﬁx transi-
tions taken (which we call checkall).

Figure 11 shows the query time tq of Algorithm 5 according to
goback and checkall. Theoretically, tq : O(mkn —l— c), the upper
bound of goback is m/m and the upper bound of checkall is c.
This experiment shows that tq is proportional to goback, which is
O(mkn) but the average value is far less than m/m and not propor—
tional to m/m. This feature makes the algorithm much more efficient
than running pattern matching algorithms for individual pattern la
times.

4 Conclusions

Palindromic structures are widely studied in string processing
and combinatorics and have applications in the analysis of DNA,
RNA and protein sequences. For a text T of length n and a pattern
P of length m, we have solved the online palindrome pattern
matching in O(mz) preprocessing time and O(mn) query time
using O(mz) space. Then we have extended the problem for mul-
tiple patterns P1,  ,Pk and solved the online multiple palin-
drome pattern matching in O(mkM) preprocessing time and
O(mkn) query time using O(mkM) space, where M is the sum of
all pattern lengths and mk is the longest pattern length. Note that
the algorithm for the multiple palindrome pattern matching does
not increase the query time. We performed experiments to analyze
the runtime of the algorithms, and found out that the runtime for
the multiple pattern matching is much faster than expected. We
believe that the algorithm can be efficiently used to find a struc—
tural similarity between multiple bio strings. Since the online mul-
tiple palindrome pattern matching is first proposed in the paper,
our future work includes reducing time and space requirement of
the algorithm. Moreover, we believe that the approach to solve
the multiple pattern matching based on the Aho—Corasick au—
tomaton can be applied to pattern matching problems considering
other structural equivalences.

Acknowledgements

We Wish to thank the referees for the careful reading of the paper and many
valuable suggestions including relevant references.

Funding

This work was supported by the Basic Science Research Program through
National Research Foundation funded by MEST [2015R1D1A1A01060097],
Yonsei University Future-leading Research Initiative of 2015 and the

National Research Foundation Grant funded by the Korean Government
[NRF-2013-Global Ph.D. Fellowship Program to H.K.].

Conﬂict of Interest: none declared.

References

Adebiyi,E.F. et al. (2001) An efﬁcient algorithm for ﬁnding short approximate
non-tandem repeats. B ioinformatics, 17, 85—8 12.

Ahmad,S. et al. (2003) RVP-net: online prediction of real valued accessible sur-
face area of proteins from single sequences. B ioinformatics, 19, 1 849—185 1.
Ah0,A.V. and Corasick,M.J. (1975) Efﬁcient string matching: an aid to biblio-

graphic search. Commun. ACM, 18, 333—340.

Brazma,A. et al. (2003) ArrayExpress—a public repository for microarray gene
expression data at the EBI. Nucleic Acids Res., 31, 68—71.

Buhler,]. (2001) Efﬁcient large-scale sequence comparison by locality-sensitive
hashing. Bioinformatics, 17, 419—428.

Burge,S.W. et al. (2013) Rfam 11.0: 10 years of RNA families. Nucleic Acids
Res., 41, 226—232.

Gusﬁeld,D. (1997). Algorithms on Strings, Trees, and Sequences: Computer
Science and Computational Biology. Cambridge University Press,
Cambridge, UK.

Hopcroft,].E. and Ullman,].D. (1979). Introduction to Automata Theory,
Languages, and Computation. Addison—Wesley, Boston, USA.

I,T. et al. (2010). Counting and verifying maximal palindromes. In:
Proceedings of the 17th International Conference on String Processing and
Information Retrieval, pp. 135—146.

I,T. et al. (2013). Palindrome pattern matching. Theor. Comput. Sci., 483,
162—170.

Knuth,D.E. et al. (1977). Fast pattern matching in strings. SIAM ]. Comput.,
6, 323—350.

Kolpakov,R. and Kucherov,G. (2009) Searching for gapped palindromes.
Theor. Comput. Sci., 410, 5365—5373.

Krawinkel,U. et al. (1986) Palindromic sequences are associated with sites
of DNA breakage during gene conversion. Nucleic Acids Res., 14,
3871—3882.

Kunin,V. et al. (2007) Evolutionary conservation of sequence and secondary
structures in CRISPR repeats. Genome B iol., 8, R61.

Mali,P. et al. (2013) Cas9 as a versatile tool for engineering biology. Nat.
Methods, 10, 957—963.

Manacher,G. (1975 ) A new linear-time “on-line” algorithm for ﬁnding the
smallest initial palindrome of a string. ]. ACM, 22, 346—35 1.

Parisi,V. et al. (2003) STRING: ﬁnding tandem repeats in DNA sequences.
Bioinformatics, 19, 1733—1738.

Paten,B. et al. (2009) Sequence progressive alignment, a framework for prac-
tical large-scale probabilistic consistency alignment. Bioinformatics, 25,
295—301.

Priifer,K. et al. (2008) PatMaN: rapid alignment of short sequences to large
databases. Bioinformatics, 24, 1530—1531.

Rigoutsos,I. and Floratos,A. (1998) Combinatorial pattern discovery in biolo-
gical sequences: the TEIRESIAS algorithm. Bioinformatics, 14, 5 5—67.

W00d,D. (1986). Theory of Computation. Harper 85 Row, New York City,
USA.

91% ‘09 1sn8nv uo sopﬁuv s01 ‘121u10111123 aIo AnsroAtun 112 /§.IO'S[BU.IHO[p.IOJXO'SOTlBIIIJOJUTOTQ/ﬁdllq 11101; pop1201umoq

