Vol. 30 ISMB 2014, pages i87—i95
doi: 10. 1 093/bioinformatics/btu289

 

Pareto-optimal phylogenetic tree reconciliation
Ran Libeskind-Hadasl, Yi-Chieh Wu2, Mukul s. Bansal3’* and Manolis Kellis2’4

1Department of Computer Science, Harvey Mudd College, Claremont, CA 91711, 2Department of Electrical Engineering
and Computer Science, MIT, Cambridge, MA 02139, 8Department of Computer Science and Engineering, University of
Connecticut, Storrs, CT 06269 and 4Broad Institute, Cambridge, MA 02142, USA

 

ABSTRACT

Motivation: Phylogenetic tree reconciliation is a widely used method
for reconstructing the evolutionary histories of gene families and spe-
cies, hosts and parasites and other dependent pairs of entities.
Reconciliation is typically performed using maximum parsimony, in
which each evolutionary event type is assigned a cost and the object-
ive is to find a reconciliation of minimum total cost. It is generally
understood that reconciliations are sensitive to event costs, but little
is understood about the relationship between event costs and solu-
tions. Moreover, choosing appropriate event costs is a notoriously
difficult problem.

Results: We address this problem by giving an efficient algorithm for
computing Pareto-optimal sets of reconciliations, thus providing the
first systematic method for understanding the relationship between
event costs and reconciliations. This, in turn, results in new techniques
for computing event support values and, for cophylogenetic analyses,
performing robust statistical tests. We provide new software tools and
demonstrate their use on a number of datasets from evolutionary gen-
omic and cophylogenetic studies.

Availability and implementation: Our Python tools are freely available
at www.cs.hmc.edu/~hadas/xscape.

Contact: mukul@engr.uconn.edu

Supplementary information: Supplementary data are available at
Bioinformatics online.

1 INTRODUCTION

Phylogenetic tree reconciliation is a fundamental technique for
studying the evolution of pairs of entities such as gene families
and species, parasites and hosts and species and geographical
regions. Recent algorithmic advances in tree reconciliation
have led to seminal biological discoveries. Among these are the
ﬁnding that >26% of extant gene families arose during the
Archaean period between 3.33 and 2.85 billion years ago
(David and Ahn, 2011), a study showing that interactions of
species and their ecological niches are strongly conserved
across the entire tree of life (Gomez et al., 2010), and new in-
sights into the relationship between pathogenic RNA viruses and
their hosts (Jackson and Charleston, 2004).

The reconciliation problem takes as input two trees and the
associations between their leaves and seeks a mapping of one tree
onto the other such that incongruence between the two trees is
accounted for by a set of evolutionary events. In the context of
gene family evolution, the two trees are the gene tree and the
species tree, and in the well-studied Duplication-Transfer-Loss
model (DTL), the events are speciation, duplication, transfer
and loss. Unlike the simpler Duplication-Loss (DL)

 

*To whom correspondence should be addressed.

reconciliation model (Goodman et al., 1979: Page, 1994), DTL
accounts for transfer events and is thus broadly applicable across
the tree of life. In the context of parasites and their hosts, the
corresponding events are co-speciation, independent speciation,
host switch and loss, respectively. In the context of species and
area cladograms, these four events correspond to vicariance,
sympatric speciation, dispersal and loss, respectively (Morrone,
2009). Henceforth, we refer to this set of events as the DTL
model and use the DTL event names.

DTL-reconciliation is generally performed in a maximum par-
simony framework in which each event type has an associated
user-deﬁned cost and the objective is to find a reconciliation of
minimum total cost. Probabilistic approaches for DTL reconcili-
ation, which do not require event cost assignments, also exist
(Szollosi et al., 2012; Tofigh, 2009), but these require estimates
of other parameters, such as species divergence times, and are
prohibitively slow for trees with more than a few leaves. If the
species trees are fully dated, then maximum parsimony reconcili-
ations can be found in polynomial time (Doyon et al., 2010;
Libeskind-Hadas and Charleston, 2009). However, accurately
dating the internal nodes of a phylogenetic tree is generally dif-
ﬁcult (Rutschmann, 2006). In the absence of dates, reconcili-
ations may be time-inconsistent in the sense that they can
induce contradictory constraints on the relative order of the in-
ternal nodes. The problem of finding optimal time-consistent
DTL-reconciliations in undated trees is known to be NP-hard
(Hallett et al., 2004; Ovadia et al., 2011). Therefore, a common
approach, and the one followed in this article, is to relax the
time-consistency requirement (Bansal et al., 2012, 2013; Chen
et al., 2012; David and Alm, 2011; Tofigh et al., 2011), which
permits an optimal (although not necessarily time-consistent) so-
lution to be found in 0(mn) time (Bansal et al., 2012), where m
and n denote the number of nodes in the gene (parasite) and
species (host) trees, respectively. Experimental evidence suggests
that the solutions found using this approach are generally time-
consistent (Addario-Berry et al., 2003); but see also Stolzer et a].
(2012).

Maximum parsimony reconciliations depend on the event
costs. In the DTL model, speciations are considered ‘null events’
and are therefore typically assigned a cost of 0 while duplica-
tions, transfers and losses are assigned positive costs. Figure la
shows a species (host) tree in black and a gene (parasite) tree in
gray along with associations between their leaves. If duplication,
transfer and loss each cost 1, then the reconciliation in Figure lb
is optimal, comprises one speciation and one transfer and has
total cost 1. However, if duplication and loss cost 1 and transfer
costs 5, then the maximum parsimony reconciliation in Figure lc
is optimal, comprises one speciation, one duplication and three
losses and has total cost 4. Even small differences in event costs

 

© The Author 2014. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by/3.0/), which
permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact

journals.permissions@oup.com.

1e /§JO'S{eumo [p.IOJXO'SOllBIIHOJUIOIQ/ﬁdllq 11101; popeoIII/noq

9IOZ ‘091sn3nv uo ::

R. Libeskind-Hadas et al.

 

(a)

(b) _ _ (c)
specnation / loss

\. duplication loss
loss
—

transfer
speciation

Fig. 1. (a) A species (host) tree in black and a gene (parasite) tree in gray
with the leaf associations shown in dotted lines. (b and c) Two different
reconciliations with events labeled by type

can induce different solutions when the trees are larger. For ex-
ample, we have found that in many datasets, the default costs
used in TreeMap (Charleston, 1998) and Jane (Conow et al.,
2010) give rise to different reconciliations than those using the
default costs in AnGST (David and Alm, 2011) and RANGER-
DTL (Bansal et al., 2012).

Despite great advances in the efﬁciency and accuracy of DTL-
reconciliation, little is understood about the relationship between
event costs and the resulting maximum parsimony reconcili-
ations. A systematic way to handle the difﬁculty in determining
appropriate event costs is to optimize for event counts rather
than total numerical cost. We deﬁne an event count vector for
a reconciliation to be a triple (6, 6, E), denoting the number of
duplications, transfers and losses, respectively. These vectors do
not explicitly count the number of speciation events because the
number of speciations is implicit (it is m — 6 — 6 — 1).

An event count vector v= (6,6,6) is strictly better than an
event count vector v’ = (6’, 6’, 6’) if each entry of v is less than
or equal to the corresponding entry in v’ and at least one entry of
v is less than its corresponding entry in v’. A reconciliation is
Pareto-optimal if there is no reconciliation with a strictly better
event count vector. We use the term Pareto-optimal for both
reconciliations and their corresponding event count vectors.

Given the set of all Pareto-optimal event count vectors, we can
partition the space of possible event cost assignments into
equivalence classes, or ‘regions’, such that any two event cost
assignments within the same region lead to the same optimal
reconciliations. These regions provide insights into the relation-
ships between event costs and maximum parsimony reconcili-
ations and have numerous applications, including new
deﬁnitions and algorithms for computing event consensus
support.

Previous work

TreeMap (Charleston, 1998) was the first to address the problem
of uncertain event costs by enumerating Pareto-optimal solu-
tions. However, TreeMap’s underlying algorithm has worst-
case exponential time and thus can only be used with small
trees. Toﬁgh (2009) later considered the problem of computing
all Pareto-optimal solutions for the DTL-reconciliation problem

but without accounting for losses; this simpliﬁes the algorithmic
problem but affects the accuracy of the reconciliation. Losses
play a fundamental role in the ability to distinguish between
duplications and transfers, and in mapping the nodes of the
gene tree to the nodes of the species tree, and thus should be
explicitly considered during reconciliation (Stolzer et al., 2012).
Thus, despite earlier work on Pareto-optimal reconciliations,
there currently exist no algorithms or tools for computing or
exploring the space of all Pareto-optimal DTL reconciliations.

Our contributions

In this article, we give efﬁcient algorithms that compute all
Pareto-optimal DTL reconciliations and completely characterize
the relationship between event costs and maximum parsimony
reconciliations. Speciﬁcally,

0 We give an algorithm for computing the Pareto-optimal
event count vectors by extending the dynamic programming
approaches that we and others have developed for the case
of ﬁxed event costs. Our algorithm has worst-case running
time 0(m5nlog m) where m and n denote the number of
leaves in the gene (parasite) tree and species (host) tree, re-
spectively. The algorithm also counts the number of distinct
reconciliations associated with each event count vector. In
addition, we give a 0(m4log m)-time algorithm that uses the
Pareto-optimal event count vectors to partition the event
cost space into equivalence classes, or regions, such that
event costs in a region give rise to the same set of maximum
parsimony reconciliations.

0 We present three applications of this algorithm and provide
downloadable software tools for each one.

— The ﬁrst tool, costscape, computes the Pareto-optimal
event count vectors and provides a visualization of the
corresponding regions.

— The second tool, eventscape, identiﬁes the individual
events that are common to the reconciliations in each
region and uses this information to identify events that
are strongly supported across the event cost space.

— The sigscape tool permits new, more robust statistical sig-
niﬁcance tests in cophylogenetic analyses.

0 We apply these tools to a number of datasets to demonstrate
their utility. These results show that a small number of ap-
propriately selected event costs can be used to capture a
large fraction of maximum parsimony reconciliations; that
a signiﬁcant fraction of speciation events occur in every rec-
onciliation across a wide range of event costs; and that du-
plications, transfers and losses are more sensitive to the
choice of event costs.

2 DEFINITIONS AND PRELIMINARIES

We follow the basic deﬁnitions and notation from Bansal et al.
(2012). Given a tree T, we denote its node, edge and leaf sets by
V(T), E(T) and Le(T), respectively. If T is rooted, the root node
of T is denoted by rt(T), the parent of a node v e V(T) by paT(v),
its set of children by ChT(v) and the (maximal) subtree of T

 

i88

1e /310's113umo [p.IOJXO'SSUBUHOJUIOIQ/ﬁdllq 11101; popeoIII/noq

9IOZ ‘091sn3nv uo ::

Pareto-optimal phylogenetic tree reconciliation

 

rooted at v by T (v). The set of internal nodes of T, denoted [(7), is
deﬁned to be V(T)\Le(T). We deﬁne 3T to be the partial order
on V(T) where x3 Ty if y is a node on the path between rt(T) and
x. The partial order :T is deﬁned analogously, i.e. x2 Ty if x is a
node on the path between rt(T) and y. We say that y is an an-
cestor of x, or that x is a descendant of y, if ngy (note that,
under this deﬁnition, every node is a descendant as well as an-
cestor of itself). We say that x and y are incomparable if neither
x3 Ty nor yng. Given a non-empty subset L g Le(T), we
denote by lcaT(L) the last common ancestor (LCA) of all the
leaves in L in tree T, that is, lcaT(L) is the unique smallest upper
bound of L under 3T. Given x, y e V(T), x—>Ty denotes the
unique path from x to y in T. We denote by dT(x, y) the
number of edges on the path x—>Ty; note that if x = y then
dT(x, y)=0. Throughout this work, the term tree refers to a
rooted binary tree.

We assume that the two input trees are denoted by T and S,
and the goal is to map tree T to tree S. Thus, in gene-tree/species-
tree reconciliation, T denotes the gene tree and S the species tree;
in coevolutionary studies, T denotes the parasite tree and S the
host tree; and in biogeographical studies, T denotes the species
tree and S the area cladogram. Each leaf of tree T is labeled with
the leaf-label from S with which it is associated. This labeling
deﬁnes a leaf-mapping [SIS : Le(T) —> Le(S) that maps a leaf
node te Le(T) to the unique leaf node s e Le(S), which has
the same label as t. Note that T may have more than one leaf
associated with the same leaf of S. Throughout this work we will
implicitly assume that the species tree contains all the species
represented in the gene tree.

2.1 Reconciliation and DTL scenarios

Next, we deﬁne what constitutes a valid DTL reconciliation;
speciﬁcally, we deﬁne a Duplication-Transfer-Loss scenario
(DTL-scenario) (Bansal et al., 2012; Toﬁgh et al., 2011) for T
and S that characterizes the mappings of T into S that constitute
a biologically valid reconciliation. Essentially, DTL-scenarios (i)
map each node of T to a unique node in S in a consistent way
that respects the immediate temporal constraints implied by the
topology of S, and (ii) designate each node of T as representing
either a speciation, duplication or transfer event.

DEFINITION 2.1 (DTL-scenario). A DT L-scenario for T and S is a
seven-tuple (L‘, M, 2, A, E, E, r), where L‘ : Le(T) —> Le(S) rep-
resents the leaf-mapping from T to S, M : V(T) —> V(S) maps
each node of T to a node of S, the sets 2, A and E partition
I{ T ) into speciation { or co-speciation), duplication and transfer
nodes, respectively, E is a subset of edges of T that represent
transfer edges and r : E —> V(S) specifies the recipient for each

transfer event, subject to the following constraints:

(1) [ft 6 Le(T), then M(t)=£(t).
(2) If t e [(7) and t’ and t” denote the children of t, then,
(a) M(l) ¢M(l’) and N10) WWI”),
(b) At least one of M(t’) and M(t”) is a descendant of
M(t).

(3) Given any edge (t, t’) e E(T), (t, t’) e E ifand only ifM(t)
and M(t’) are incomparable.

(4) If t e [(7) and t’ and t” denote the children of t, then,
(a) t E 2 only ifM(t)=lca(M(t’), M(t”)) and M(t’) and

M(t”) are incomparable,

(b) t e A only ifM(t)ZS lca(M(t’), M(t”)),

(C) t e E ifand only ifeither (t, t’) e E or (t, t”) e E.

(d) If t e 0 and (t, t’) e E, then M(t) and r(t) must be
incomparable, and M(t’) must be a descendant of t(t).

Constraint 1 above ensures that the mapping M is consistent
with the leaf-mapping L‘. Constraint 2a imposes on M the tem-
poral constraints implied by S. Constraint 2b implies that any
internal node in G may represent at most one transfer event.
Constraint 3 determines the edges of T that are transfer edges.
Constraints 4a, 4b and 40 state the conditions under which an
internal node of T may represent a speciation, duplication and
transfer, respectively. Constraint 4d speciﬁes which species
may be designated as the recipient species for any given transfer
event.

DTL-scenarios correspond naturally to reconciliations, and it
is straightforward to infer the reconciliation of T and S implied
by any DTL-scenario.

Given a DTL-scenario, one can directly count the minimum
number of gene losses (Bansal et al., 2012) in the corresponding
reconciliation as follows.

DEFINITION 2.2 (Losses). Given a DTL-scenario a = (L‘, M, 2, A,
E, E, t) for Tand S, let t e V(T) and {t’, t”} = Ch(t). The number
of losses Losso,(t) at node t is defined to be

0 |dS(M(t), M(t’)) — 1| + |dS(M(t), M(t”)) — 1|, ift e 2.
o dS(M(t), M(t’))+dS(M(t), M(t”)), ift e A.
o dS(M(t), M(t”))+dS(r(t), M(t’)), if (t, t’) e E.

The total number of losses in the reconciliation corresponding to
the DTL-scenario or is defined to be Loss“ = Losso,(t).

We assume that speciations have zero cost, and let CA, C9
and CL denote the assigned positive costs for duplication, trans-
fer and loss events, respectively. Then the cost of reconciling T
and S according to a DTL-scenario a is deﬁned as follows:

DEFINITION 2.3 (Reconciliation cost of a DTL-scenario). Given a
DTL-scenario a: (L‘, M, 2, A, E, E, t) for T and S, the recon-
ciliation cost associated with or is given by
CA -  + C9 -  ‘I‘ CL - LOSS“.

The traditional goal of DTL-reconciliation is to ﬁnd a
most parsimonious reconciliation, i.e. a DTL-scenario for G
and S with minimum reconciliation cost. However, in
this work, we assume that the exact cost assignments, CA, C9
and CL, are unknown; therefore, we focus on the inferred
event counts rather than the reconciliation cost itself.

DEFINITION 2.4 (Event count vector). Given a DTL-scenario a =
(L‘,M,2,A,®,E,t) for T and S, the event count
vector associated with 05, denoted va, is defined to be
(IAI, |@|, LOSSal-

Given two DTL-scenarios a: (L‘, M, 2, A, E, E, t) and a’ =
(L‘, M, 2’, A’, ’, E’, t’) for Tand S, the event count vector v0, is
said to be strictly better than val if each entry of v0, is less than or

 

i89

1e /§IO's113umO [p.IOJXO'SOllBIIIJOJUIOIQ/ﬁdllq U101} prBOIUAAOG

9IOZ ‘091sn3nv uo ::

R. Libeskind-Hadas et al.

 

equal to the corresponding entry in val and at least one entry of
v0, is less than its corresponding entry in val.

DEFINITION 2.5 (Pareto-optimal event count vector). Given a
DTL-scenario a=(£,M,2, A, E, E, t) for T and S, the event
count vector v0, is said to be Pareto-optimal if there does not
exist any other DTL-scenario oz’ for T and S whose event count
vector val is strictly better than va.

Given trees T and S and leaf-mapping ISIS, our goal is to ﬁnd
all Pareto-optimal event count vectors for the two trees. Note
that, if an event count vector (6, 6, E) is Pareto-optimal, then
there exists some assignment of values for CA, C9 and CL for
which a most parsimonious reconciliation invokes exactly 6 du-
plications, 6 transfers and 6 losses. Thus, the set of all Pareto-
optimal event count vectors provides a relationship between
event cost assignments and most parsimonious reconciliations.

PROBLEM 1 (Pareto-optimal vectors). The Pareto-optimal vectors
{PV} problem is to find the set of all Pareto-optimal event count
vectors for trees T and S and their leaf-mapping Egg.

The set of Pareto-optimal vectors obtained by solving the PV
problem can then be used to partition the space of possible event
cost assignments into ‘equivalent’ regions.

PROBLEM 2 (Equivalent Region Partition). Given T, S, [its and
the set of all Pareto-optimal event count vectors for the two trees,
the equivalent region partition (ERP) problem is to partition the
space of possible event cost assignments into disjoint regions such
that any two event cost assignments within the same region yield
the same set of maximum parsimony reconciliations.

In the next section, we ﬁrst show how to efﬁciently solve both
the PV and ERP problems. In the subsequent sections, we use
these algorithmic results as the basis of new software tools and
then demonstrate the utility of these tools on several biological
datasets.

3 ALGORITHMS

Our algorithm for the PV problem is based on an extension of
the dynamic programming framework for computing most par-
simonious DTL reconciliations with known event costs, e.g.
(Bansal et al., 2012). Toﬁgh (2009) was the ﬁrst to adapt the
dynamic programming algorithm to compute Pareto-optimal
event count vectors. However, that result did not count losses,
which signiﬁcantly simpliﬁes the dynamic programming algo-
rithm and also bounds the number of Pareto-optimal event
count vectors to just 0(m), resulting in an 0(m3n)-time algo-
rithm, where m = |Le(T)| and n = |Le(S)|. In developing an efﬁ-
cient algorithm for the PV problem, we not only show how to
efﬁciently account for losses in the dynamic programming algo-
rithm [using ideas from Bansal et al. (2012)] but also show how
to efﬁciently maintain the resulting larger set of Pareto-optimal
event count vectors.

3.1 Solving the PV problem

Given any te 1(7) and s e V(S), let Pg(t, s) denote the set of
Pareto-optimal event count vectors for reconciling T (t) with S
such that t maps to s and t e 2. The terms PA(t, s) and P®(t, s)

are deﬁned similarly for t e A and t e C, respectively. Given any
t e V(T) and s e V(S), we deﬁne P(t, s) to be the set of Pareto-
optimal event count vectors for reconciling T (t) with S such that
t maps to s. Our algorithm performs a nested post-order traversal
of T and S to compute P(t, s) for each t and s.

Given two sets A and B of Pareto-optimal event count vectors,
we deﬁne A 69 B to be the set obtained by taking the union of
the event count vectors in A and B and then selecting the
subset of event count vectors that are Pareto-optimal.
Similarly, A (X) B is deﬁned to be the set obtained by ﬁrst com-
puting the Cartesian product of A and B, then converting each
resulting ordered pair into a single event count vector by adding
the two vectors of the ordered pair, and ﬁnally taking only the
subset of Pareto-optimal event count vectors. These operations
will be used when merging the Pareto-optimal event count vec-
tors from smaller subproblems to compute the Pareto-optimal
event count vectors for larger subproblems. The dynamic pro-
gramming table for P(t, s) is initialized and computed as shown
below:

(0,0,0) ift e Le(T) and s=M(t),
P(t, s) = (00, oo, oo) ift e Le(T) and s 75 M(t),
Pg(t, s) 69 PA(t, s) 69 P®(t, s) otherwise.

Given an event count vector, v = (6, 6, K), we use the notation
v + (A, i), for i 6 2+, to denote the event count vector where the
count for duplications is incremented by i, i.e. (6+i, 6, E). The
vectors v + (E, i) and v + (L, i) are deﬁned analogously for trans-
fers and losses, respectively. We extend this notation to a set of
event count vectors, A, as follows: A+(A, i) represents the set
{v+(A, i) : v e A}. The sets A+(®, i) and A+(L, i) are deﬁned
analogously. We deﬁne

 S) = $366 V(S(S))(P(tr x) + (L, dS(S’ 
out“, S) = EBxE V(S) incomparable to s P(t, x): and
 S) = $366 V(S(S))  

Our algorithm computes P2(I,S), PA(t,s) and P®(t,s) for
each t e V(T) and s e V(S) by performing a nested post-order
traversal of T and S. The values in(-, -), out(-, -) and inAlt(-, -)
help to reuse previously computed information to efﬁciently
compute the values Pg(t, s), PA(t, s) and P®(t, s) at each step.
The exact formulas for computing the values of Pg(t, s), PA(t, s)
and P®(t, s) using previously computed values are given in steps
17, 18 and 19 of the algorithm below. The nested post-order
traversal ensures that when computing Pg(t, s), PA(t, s) and P9
(t, s) at nodes t e G and s e S, all the required
in(-, -), out(-, -), inAlt(-, -) and P(-, -) values have already been
computed.

Note that once all the P(-, -) sets have been computed, the set
of Pareto-optimal event count vectors for the reconciliation of T
and S is simply EBSE V(S) P(rt(T), s). The algorithm is as follows:

 

Algorithm Pareto — Reconcile(T, S, L)

1: for each I e V(T) and s e V(S) do

2: Initialize P(t, s), P;(t,s), PA(t, s), P®(t, s), in(t,s), inAlt(t, s), and
out(t, s) to Q.

3: for each I e Le(T) do

 

i90

1e /§IO's113umO [p.IOJXO'SOllBIIIJOJUIOIQ/ﬁdllq U101} prBOIUAAOG

9IOZ ‘091sn8nv uo ::

Pareto-optimal phylogenetic tree reconciliation

 

4: P(t, £(t))={(0, 0, 0)}, and, for each sisal), in(t,s)={
(0, 0, dS(s, £(t)))} and inAlt(t, S): {(0, 0, 0)}.

5: for each I e [(1) in post-order do
6: for each s e V(S) in post-order do
7: Let {t’, t”} = Chm).
8: if s E Le(S) then
9: P;(t,s)={(oo, oo, 00)}.
10: PA(t, s) = (P(t’, s) (X) P(t”, s)) + (A, 1).
11: P9 (t, s) = ((in(t’, s) (X) out(t” , s))EB

(in(t”, s) (X) out(t’, s))) + (O, 1).
12: P(t, s) = P;(t, s) EB PA(t, s) EB P®(t, s).
13: in(t, s) = P(t, s).
14: inAlt(t, s) = P(t, s).
15: else
16: Let {s’, s”} = ChS(s).
17: P;(t, s) = (in(t’, s’) (X) in(t”, s”))EB

(in(t” , s’) (X) in(t’, s” )).
18: PA(t, s) = (in(t’, s) (X) in(t”, s)) + (A, 1).
19: If s 75 rt(S), then P®(t, s) = ((in(t’, s) (X) out(t”, s))EB

(in(t”, s) (X) out(t’, s))) + (O, 1).
20: P(t, s) = P;(t, s) EB PA(t, s) EB P®(t, s).
21: in(t, s) = P(t, s) EB (in(t, s’) + (L, 1))69
(in(t, s”) + (L, 1)).

22: inAlt(t, s) = P(t, s) EB inAlt(t, s’) EB inAlt(t, s”).
23: for each s e I(S) in pre—order do
24: Let {s’, s”} = ChS(s).
25: out(t, s’) = out(t, s) EB inAlt(t, s”), and

out(t, s”) = out(t, s) EB inAlt(t, s’).
26: Return easel/(S) P(rt(T), s).

To complete our description of the above algorithm, we must also
show how to efﬁciently perform the operations A EB B and A (X) B,
for any two sets A and B of Pareto-optimal event count vectors.
Operation A 69 B can be performed in 0(m4) time using a straight-
forward algorithm (Lemma 3.2 below). Computing A (X) B efﬁciently
is more involved. From Lemma 3.1 (below), each Pareto-optimal
set has size 0(m2). Thus, computing their Cartesian product
takes time 0(m4). Finding the subset of Pareto-optimal vectors
by pairwise comparisons would thus take 0((m2 >< m2)2) = 0(m8)
time. We now show how A (X) B can be computed in 0(m4log m)
time.

 

 

Procedure Perform — ®(A, B)

1: Create an empty ordered list Z that will be used to store event count
vectors in lexicographically sorted order.

2: for each a e A do

3: for each b e B do

4: Compute the vector a+b. Let this new vector be denoted as
c = (6, 6, K).
5: Insert c into Z (maintaining lexicographic order).
6: Consider the element d immediately before c in the list Z.
7: if d exists and is of the form (6, 6, K — x), where x Z 0
then
8: Delete c from Z.
9: else
10: Consider the element e immediately after c in the list Z.
11: if e exists and is of the form (6, 6, 6+x), where x Z 0
then
12: Delete e from Z.

13: Delete from Z all vectors that are not Pareto-optimal.
14: Return Z.

We now analyze our algorithm and prove its correctness.
Recall that m and n denote the number of leaves in T and S,
respectively.

 

LEMMA 3.1. The cardinality of any set of Pareto-optimal event
count vectors can be no greater than @(mz).

PROOF. Consider any event count vector (6, 6, 6). Let A be any
set of Pareto-optimal event count vectors. Suppose A contains
more than one vector with identical values for 6 and 6 but dif-
ferent values for 6. Clearly, only one of these vectors can be
Pareto-optimal (the one with the lowest value for 6). Thus, for
any pair of ﬁxed values for 6 and 6, A may contain at most one
vector with that assignment of values for 6 and 6. Because the
values of 6 and 6 are both bounded by m—l, the number of
internal nodes in T, the lemma follows.

LEMMA 3.2. Given any two sets, A and B, of Pareto-optimal event
count vectors, the set A EB B can be computed in 0(m4) time.

PROOF. Let C = A 69 B. Because both A and B have 0(m2) elem-
ents, so does C. Thus, trimming down set C to just the Pareto-
optimal vectors requires at most 0(m4) time.

LEMMA 3.3. Given any two sets, A and B, of Pareto-optimal event
count vectors, the set A (X) B can be computed in 0(m4log m) time.

PROOF. Consider Procedure Perform — ®(A, B). We ﬁrst prove
its correctness and then analyze its time complexity.

Correctness: Consider the set Y= {v1 + v2 : v1 6 A and v2 6 B}.
The procedure constructs each element of C, one at a time, and adds
it to the ordered set Z. The only elements ever deleted from set Z in
Steps 8 and 12 are those that are not Pareto-optimal. Finally, Step 1 3
removes any remaining elements that are not Pateto-optimal from
Z. The procedure thus computes the value of A (X) B correctly.

Complexity: Because both A and B contain at most 0(m2)
vectors (Lemma 3.1), Steps 4 through 12 are each executed
0(m4) times. By using a self-balancing binary search tree to rep-
resent Z, each of these steps can be executed in 0(log m) time,
yielding a total time complexity of 0(m4log m) for Steps 1
through 12. Because the time complexity of Step 13 is 0(|Z|2),
it now sufﬁces to show that the size of Z never exceeds m2 at any
time. Consider Steps 8 and 12. These steps ensure that for any
ﬁxed value of 6, and 6, there is at most one vector in Z of the
form (6, 6, 6). Thus, the size of Z can not exceed 0(m2) at any
time.

Based on the pseudo-code for Algorithm Pareto-Reconcile,
and on the previous three lemmas, the next two theorems
follow easily. For brevity, their proofs appear in
Supplementary Section S1.

THEOREM 3.1. Algorithm Pareto-Reconcile correctly solves the PV
problem.

THEOREM 3.2. The total time complexity of Algorithm Pareto-
Reconcile is 0(m5nlog m). In addition, the algorithm can be im-
plemented so that its total space complexity is 0(m3n).

3.2 Equivalent region partition

In this section, we describe how the set of Pareto-optimal event
count vectors can be used to efﬁciently partition the space of
event costs into a ﬁnite number of equivalence classes, or ‘re—
gions’, such that all event costs in a given region induce the same
set of maximum parsimony reconciliations. These regions

 

i91

1e /§IO's113umO [p.IOJXO'SOllBIIIJOJUIOIQ/ﬁdllq uIOIj popeOIHAAOQ

9IOZ ‘091sn8nv uo ::

R. Libeskind-Hadas et al.

 

provide insights into the relationship between the event costs and
the resulting solutions and are used in several of the software
tools described in the next section.

Recall that we assume that speciation is a ‘null’ event with cost
0 and all other events have positive costs. Because the costs are
unit-less, duplication cost is normalized to 1 and the costs of
transfer and loss are non-negative values relative to the unit
cost of duplication. For a given event count vector v= (6, 6, E)
and positive real transfer and loss costs C9 and Cg, respectively,
the cost of that solution, denoted C(v, C9, Cg), is
6+C® ~6+CL-£.

Let A denote the Pareto-optimal set of event count vectors for
a given pair of trees and leaf mapping. These vectors induce a
partition of the event cost space into regions where the region
R(v) associated with event count vector v e A is the set of points
(C9, Cg) E R+ X R+ SUCh that C(V, C9, Cg) E C(V’, C9, Cg),
Vv’ e A — v.

From this deﬁnition, it follows that for every combination of
transfer and loss costs in a given region, every maximum parsi-
mony solution using those costs will have the event count vector
associated with that region. While there can be many distinct
reconciliations in a given region, all event costs in that region
will admit the same set of maximum parsimony reconciliations.

THEOREM 3.3. Given a set of Pareto-optimal event count vectors,
the corresponding regions can be found in time 0(m4log m).

PROOF. Let A denote the set of Pareto-optimal event count vec-
tors. By Lemma 3.1, |A| e 0(m2). The region R(v) corresponding
to v e A comprises all points (C9, Cg) e [R2+ >< [R2+ such that
C(v, C9, Cg) g C(v’, C9, Cg), Vv’ e A — v. Each inequality of
the form C(v, Ce, Cg) S C(v’, C9, Cg) induces a half-space and
R(v) is the intersection of those half-spaces. The intersection of
N half-spaces can be found in time 0(Nlog N) (Berg et al., 2008)
and thus each region can be found in time 0(m210g m). Thus, all
|A| regions can be found in time 0(m4log m).

3.3 Counting solutions and enumerating events

Our algorithm for the PV problem can be easily adapted to count
the number of maximum parsimony reconciliations for each
Pareto-optimal event count vector and to record the events in
those reconciliations. To count the number of distinct reconcili-
ations, we keep track of the number of solutions associated with
each event count vector in each subproblem P(t, s). Those values
are easily updated based on the number of solutions from the
subproblems from which P(t, s) is constructed (Bansal et al.,
2013). The additional bookkeeping does not increase the asymp-
totic running time of the algorithm.

In addition, the dynamic program can be augmented to keep
track of the set of events occurring in the reconciliations associated
with a Pareto-optimal event count vector. While the number of
reconciliations can grow exponentially with the m and n, the total
number of distinct events is bounded by 0(mn2) because each of
the 0(m) nodes of T can be mapped to at most 0(n) nodes in S and,
for transfer events, there are 0(n) possible destinations for the
‘landing site’. For each subproblem P(t, s) we can, therefore, main-
tain a set of associated events such as the union or intersection of all
events that occur in that subproblem. This increases the asymptotic

running time by a factor that depends only on the time complexity
of the particular set theoretic operation. For example, we use set
intersection in the eventscape tool described in the next section,
which contributes a multiplicative factor of 0(mn210g mn) using
self-balancing binary search trees.

4 APPLICATIONS AND SOFTWARE

In this section, we demonstrate three programs that use the al-
gorithmic results in the previous section to provide new insights
into maximum parsimony reconciliation. Each of these tools
solves the PV and ERP problems and uses those solutions in
different ways. We note that while our algorithms can compute
all Pareto-optimal regions, these tools take a user-speciﬁed a
range of costs for transfer and loss events, relative to the normal-
ized unit cost of duplication, and restrict the Pareto-optimal
event count vectors and corresponding regions to that event
cost space. (We note that the choice of ﬁxing the duplication
cost to 1 and normalizing the remaining costs with respect to
duplication is arbitrary).

The ﬁrst tool, costscape, computes the Pareto-optimal event
count vectors and their corresponding regions as well as a
‘Count’ of the number of distinct maximum parsimony recon-
ciliations in each region. These results are displayed graphically
to provide a systematic overview of the relationship between
event costs and the structure of the maximum parsimony solu-
tion space. For example, Figure 2a and b show the results of
using costscape on the canonical gopher-louse (Hafner and
Nadler, 1988) and indigobird-ﬁnch (Sorenson et al., 2004) data-
sets for transfer and loss costs ranging from 0.1 to 5, relative to
the unit cost of duplication.

The second tool, eventscape, augments the dynamic program-
ming algorithm to compute the set of events that are common to
every reconciliation in a region. Eventscape then collects all of
these events over all regions and partitions that set into the set of
events that are found in exactly one region, exactly two regions
and so forth up to the total number of regions. Each event in-
cludes a gene (parasite) node, its association with a species (host)
node and the type of event. In the case of transfers, the landing
site of the event is also speciﬁed. One important application of
eventscape is in identifying events that are highly supported by
merit of occurring in a large fraction of the regions or the cost
space. The next section explores this application on a large col-
lection of datasets.

The third tool, sigscape is designed for cophylogenetic analyses
where permutation tests are performed to test the null hypothesis
that the host and parasite trees are similar owing to chance.
Shades of each color indicate variations in P—values, with
brighter shades indicating smaller P—values. For example, for
the gopher-louse dataset using transfer and loss costs ranging
from 0.1 to 5 and using 1000 permutations, sigscape found 97.6
% of the event cost space to have signiﬁcance at the 0.01 level,
1.5% to have signiﬁcance between 0.01 and 0.05, and 0.9%
below the 0.05 level (Fig. 20). More details about sigscape are
provided in Supplementary Section S2.

These tools, collectively called xscape, are written in Python
and are freely available at www.cs.hmc.edu/~hadas/xscape. As
noted earlier, the underlying algorithms do not guarantee time-
consistent solutions because ﬁnding such solutions is NP-hard

 

i92

1e /§IO's113umO [p.IOJXO'SOllBIIIJOJUIOIQ/ﬁdllq uIOIj popeOIHAAOQ

9IOZ ‘091sn8nv uo ::

Pareto-optimal phylogenetic tree reconciliation

 

  
 
  
 
   

A

Transfer cost relative to duplication m

V
01

 

2, 3> Count = 3

3, 1> Count = 2

,5, 0> Count = 8
4, O> Count = 2
1, 5> Count = 1
0, 10> Count = 1

 

Transfer cost relative to duplication 5'

3

2 4
Loss cost relative to duplication

 

A
V
01

 

 

Loss cost relative to duplication

<13, 0, 7, 25> Count = 108
<12,0,8,18> Count = 12
<11,0,9, 13> Count= 6
<8, 0, 12, 5> Count = 20
<6, 0, 14, 1> Count = 160
<5, 0, 15, 0> Count = 640
<13, 1, 6, 25> Count = 54
<12,1,7,18> Count= 6
<13, 2, 5, 28> Count = 18
<12, 2, 6, 22> Count = 6
<12, 4, 4, 31> Count = 12
<12, 5, 3, 37> Count = 3
<12, 6, 2, 50> Count = 3
<11, 7, 2, 45> Count = 3
<11, 9, O, 69> Count =1

N (A) -I>
+

Transfer cost relative to duplication O

 

 

 

 

3 4 5 i i 5 4 5
Loss cost relative to duplication

Fig. 2. Pareto-regions for the (a) gopher-louse and 0)) indigobird-ﬁnch datasets. Colors are arbitrary and are used to match regions with the event counts
in the legend. The displayed event counts comprise the number of speciations in addition to the number of duplications, transfers and losses. In addition,
the ‘Count’ ﬁeld indicates the number of distinct reconciliations in each region. While most regions are polygons, regions may also be points or lines, such
as in the ﬁrst region in the legend in (a). (c) Results of a permutation test on the gopher-louse dataset using 1000 random trials. For (c) only, green
indicates signiﬁcance at the 0.01 level, yellow represents signiﬁcance between 0.01 and 0.05 and red indicates lack of signiﬁcance at the 0.05 level.
Brightness of green, yellow and red indicates differences in P—values, with brighter shades indicating smaller P—values. All plots use transfer and loss costs
ranging from 0.1 to 5. Plus sign marks the default event costs for Jane/TreeMap (CA = 1, C9 = 2, C L = 1) and multiplication sign the default event costs
for AnGST/RANGER-DTL (CA = 1, C9 = 3 / 2, CL = 1 / 2). In (a), the two sets of default costs are in the same region, whereas in (b) and in almost all but

the smallest datasets, the two sets of default costs are in different regions

(Ovadia et al., 2011). However, if the species trees are fully dated,
then our algorithms can be modiﬁed (resulting in slower polyno-
mial-time algorithms) to guarantee time-consistency (Conow
et al., 2010).

5 RESULTS

In this section, we demonstrate the utility of our algorithms and
tools on a diverse collection of datasets. Currently, reconciliation
analyses infer evolutionary events by choosing a set of event
costs (often the default costs in the software, although most
tools recommend experimenting with different costs) and con-
structing reconciliations based on these costs. Because event costs
are not easily estimated and the choice of costs affects the rec-
onciliations, we seek here to understand the impact of event costs
on the resulting reconciliations.

We ﬁrst analyzed a biological dataset consisting of predomin-
antly prokaryotic species sampled broadly from across the tree of
life (David and Alm, 2011). This consisted of 4860 gene trees
(with at least two extant genes) over 100 species, but, for efﬁ-
ciency, we restricted our analyses to a subset of 3433 gene
families from 20 randomly sampled species and evaluated event
counts and their corresponding event cost regions for transfer
and loss costs ranging from 0.5 to 2 (with respect to the unit cost
of duplication). The results presented here exclude 34 (<l.0%)
gene families for which eventscape used more than the allocated
5 GB of RAM in our experimental setup.

Using the costscape tool, we observed that 85.8% (2917) of the
gene families induce at least two regions, 37.5% (1274) have at
least ﬁve regions and that the number of regions grows as a
function of tree size (Fig. 3a). Thus, the common practice of
selecting a single cost setting or a small ﬁxed number of cost
settings [e.g., Stolzer et al. (2012) considered three settings, and
Bansal et al. (2013) considered ﬁve] can result in missing poten-
tially important parts of the solution space. Additionally, many
regions have zero area (e.g. lines or points), meaning that the

associated reconciliations are unlikely to be discovered by an ad
hoc choice of event costs: for this dataset, 54.1% (1839) of the
gene families have at least one region with zero area, and for
19.7% (669) of the gene families, more than half of the regions
have zero area.

We also found that a systematic choice of event costs (e.g.
using costscape) can cover a substantial portion of the solution
space. For example, for all gene families studied here, an appro-
priately selected subset of ﬁve or fewer regions covers the major-
ity (>50%) of the event cost space (Fig. 3b), and coverage of the
event cost space appears to follow a power law distribution
(Supplementary Fig. S1). Although these results seem to suggest
that a small set of event costs (and their associated regions) is
representative of the entire event cost space, we note that cover-
age of event cost space is a biased measure, as some large regions
may include cost ratios that are biologically unrealistic while
other regions containing biologically plausible ratios might
cover a small fraction of the event cost space. Regions of zero
area, for example, are generally abundant and may contain a
biologically relevant solution. While these results provide some
preliminary understanding of the relationship of event costs and
the space of maximum parsimony reconciliations, further re-
search is needed to understand the properties of this space and,
ultimately, to determine appropriate event costs.

Next, we focus on the identiﬁcation of well-supported events
across the event cost space. Given a user-speciﬁed event cost
space, that is, a range of costs on transfer and loss (with respect
to the unit cost of duplication), we used the eventscape tool to
infer the Pareto-optimal regions and the sets of events that are
common to l, .. . , k regions, where k is the total number of re-
gions in the event cost space. We deﬁne an event to have con-
sensus support s, 0 g s g 1 (with respect to the event cost space),
if the event is found in every reconciliation in at least a fraction s
(inclusive) of the regions. Note that this is one of many possible
measures of event support, and our algorithms can be used to
deﬁne and compute other measures.

 

i93

1e ﬁlm'spaumo [pJOJXO'SOllBUlJOJUIOIQ//Idllq U101} popeOIHAAOQ

9IOZ ‘091sn8nv uo ::

R. Libeskind-Hadas et al.

 

m
E

 

120-

|_l

O

O
I

00
O
I

h
O
I

N
O
l

 

 

 

 

g

l l
0 10 20 30 4o 50 60 7o 0 5 10 15 20
number of genes number of regions

 

number of regIons
O)
O
I
fraction of event cost space

Fig. 3. The costscape summary on the tree of life dataset. For each gene
family, we computed (a) the number y of Pareto-optimal regions (all
regions, black white circles; positive area regions, red plus sign; zero
area regions, blue multiplication sign) and the number x of extant
genes, and (b) the fraction y of the event cost space covered by the largest
x regions

Using this deﬁnition, we investigated the fraction of events
supported at various support thresholds (Fig. 4a). Ahnost uni-
versally, speciations are the best supported type of event, with
~33.2% of speciations supported under strict consensus (that is,
found in all regions). Manual inspection revealed that speciations
found near the root of the tree were often conserved across mul-
tiple regions. However, when analyzing gene family evolution,
we are typically interested in the inferred duplications, transfers
and losses (collectively, the DTL events), and we found that few
of these have high support. For example, only 2.1% of duplica-
tions, 15.1% of transfers and 2.1% of losses have at least 80%
support (though the percentage of events with at least 50% sup-
port is substantially higher, with 56.8% of duplications, 41.4%
of transfers and 34.9% of losses supported at that level).
Interestingly, we observed a ‘jump’ in the number of supported
events around a support threshold of 50%. Also, in general, for
most support thresholds, duplications are the most supported
type of event (after speciation), followed by transfers, then
losses; however, for low support thresholds, the three types of
DTL events show roughly equal support. These results have im-
portant implications for existing analyses that rely on DTL rec-
onciliation and suggest that many inferred events are highly
speciﬁc to the user-deﬁned event costs.

In this study, we have investigated a speciﬁc range of event
costs (transfer and loss ranging from 0.5 to 2 relative to the unit
cost of duplication). The number of regions, and thus the level of
consensus support, depends on this range. Moreover, our ana-
lyses permitted cost combinations in which duplications are more
expensive or less expensive than transfers and losses. Adding
constraints on these cost relationships could alter the levels of
support. We also note that manual inspection revealed that loss
events, and to a lesser extent transfers, are often ‘fungible’ in the
sense that they can be moved from one location to another with-
out changing the total cost of the solution, and thus any individ-
ual loss or transfer event is not likely to be strongly supported.
By looking at the event cost space and supported events, our
tools allow the elucidation of the complex interplay between
event cost assignments and event support under various ranges
and constraints of event costs.

For completeness, we also determined event support as mea-
sured by fraction of the event cost space (rather than fraction of

 

 

 

 

 

 

 

 

(a)1.o (b)1.o
3 0.8- L, 0.8-
C C
2 2
a, 0.6- a, 0.6- ﬂfj
H— H—
o o f
E 0.4- E 0.4-
J-J d—l
U U
E 0.2- 2 0.2-
H— H—
_/
0.0 I I I I 0.0 I I I I
1.0 0.8 0.6 0.4 0.2 0.0 1.0 0.8 0.6 0.4 0.2 0.0
fraction of regions fraction of event cost space
— all DTL — speciation duplication — transfer — loss

Fig. 4. Event support for the tree of life dataset as measured by (a)
fraction of regions or 0)) fraction of event cost space covered.
Coordinate (x, y) indicates that fraction y of events are found in at
least fraction x of regions (or event cost space), with the plot being
left-continuous (such that the highest y for each x should be read).
Over all gene families, 16 795 speciations, 8375 duplications, 41 247 trans-
fers and 13 761 losses are inferred

the number of regions) covered (Fig. 4b), yielding similar results.
The main difference between these two measures is that event
support increases gradually with increasing region coverage but
tends to ‘jump’ with increasing event cost space coverage; this
conﬁrms our ﬁnding that the event cost space is dominated by a
few large regions. Otherwise, duplications also show a clear de-
marcation from no support to high support at ~66.7% coverage.

To demonstrate the applicability of our tools on cophyloge-
netic datasets, we performed similar analyses on ﬁve host—para-
site datasets and found results consistent with those above
(Supplementary Section S3, Supplementary Fig. S2).

Finally, the average runtimes for our tools is on the order of
seconds (Supplementary Table S1). To demonstrate scalability,
we also ran costscape on the full 100-taxa tree of life dataset (also
using transfer and loss costs ranging from 0.5 to 2) and found
that the median runtime remains <1 min.

6 CONCLUSIONS

In this work, we have described new algorithms and tools for
understanding the relationship between event costs and max-
imum parsimony reconciliations. In particular, we have given
algorithms for computing the set of Pareto-optimal event count
vectors and partitioning the event cost space into equivalence
classes, or regions, induced by these vectors. We have demon-
strated these algorithms in three software tools that (i) compute
and visualize the regions that partition the event cost space, (ii)
list the sets of events shared by reconciliations within and be-
tween regions and (iii) determine the statistical signiﬁcance of
reconciliation costs over the cost space.

An alternative approach to computing Pareto-optimal event
count vectors would be to uniformly sample event costs and, for
each sample, use existing algorithms to compute the maximum
parsimony reconciliation and corresponding event counts.
However, it is not known how to determine the appropriate
sampling density to capture all event count vectors.
Additionally, sampling fails to ﬁnd regions that comprise
points and lines, which we have shown to comprise a large frac-
tion of the total number of solutions. Finally, our approach
allows us to determine all Pareto-optimal event count vectors,

 

i94

1e /§IO's113umO [p.IOJXO'SOllBIIIJOJUIOIQ/ﬁdllq U101} popeOIHAAOQ

9IOZ ‘091sn8nv uo ::

Pareto-optimal phylogenetic tree reconciliation

 

whereas a sampling approach would necessarily capture only a
subset of the event cost space.

Using the tools based on our algorithms, we have conducted
experiments on a broad array of datasets. These results show that
the space of maximum parsimony solutions is complex and sen-
sitive to the event costs, and thus, choosing ad hoc event costs
may result in misrepresenting evolutionary histories. At the same
time, we cannot discount ad hoc procedures for ﬁnding event
costs [for example, through comparison to event inferences on a
biological dataset, as in David and Ahn (2011)]. In particular,
such approaches may elucidate the boundaries for biologically
reasonable event cost assignments, which could then be used as
input into our tools for more systematic analysis.

In addition, by deﬁning notions of consensus support based on
the number of regions that share an event, we found that while
many speciation events have high consensus support, most other
events do not. Thus, inferring events based on non-systematically
selected event costs is likely to provide only a piece of a complex
picture, and our tools motivate further investigation into the
robustness of analyses based on DTL reconciliation.

There are numerous interesting directions for future work. In
particular, this work affords opportunities to explore many vari-
ants of event consensus support. For example, our work uses the
most speciﬁc deﬁnition of an event in computing support: for a
speciation, duplication or transfer to be supported across differ-
ent reconciliations, a gene (parasite) tree node must map to the
same species (host) tree node and to the same event, and transfers
must also yield the same transfer edge. Similarly, for two losses
to be supported across different reconciliations, they must be
found along the same branch of both the gene tree and species
tree. In some cases, analyses only require the species mapping
(David and Ahn, 2011) or event mapping (Koonin, 2005), and
thus the support values must be considered for these relaxed
deﬁnitions of events. Our algorithms can be modiﬁed
accordingly.

In addition to identifying highly supported events, it is desir-
able to ﬁnd highly supported whole reconciliations. In the spirit
of promising recent work on this problem for ﬁxed event costs
(Scornavacca et al., 2013), one promising research direction is to
identify and succinctly represent whole reconciliations that are
robust across the space of event costs.

In summary, this work provides techniques and tools that are
immediately useful in the phylogenomic, cophylogenetic and bio-
geography analyses and offers avenues for further research that
leverages the Pareto-optimal reconciliation methods developed
here

ACKNOWLEDGEMENTS

The authors thank the anonymous referees for their invaluable
comments.

Funding: This work was supported by the R. Michael Shanahan
Endowment to R.L-H., startup funds from the University of
Connecticut to M.S.B. and National Science Foundation
CAREER award 0644282 to M.K.

Conflict of Interest: none declared.

REFERENCES

AddariO-Berry,L. et al. (2003) Towards identifying lateral gene transfer events. Pac.
Symp. Biocomput., 8, 279—290.

Bansal,M.S. et al. (2012) Efﬁcient algorithms for the reconciliation problem with
gene duplication, horizontal transfer and loss. Bioinformatics, 28, 283—291.
Bansal,M.S. et al. (2013) Reconciliation revisited: Handling multiple Optima when

reconciling with duplication, transfer, and loss. J. Comput. Biol, 20, 738—754.

Berg,M. et al. (2008) Computational Geometry: Algorithms and Applications. 3rd
edn. Springer-Verlag TELOS, Santa Clara, CA.

Charleston,M. (1998) J ungles: a new solution to the host-parasite phylogeny recon-
ciliation problem. Math. Biosci., 149, 191—223.

Chen,Z.Z. et al. (2012) Simultaneous identiﬁcation of duplications, losses, and lat-
eral gene transfers. IEEE/ACM Trans. Comput. Biol. Bioinform., 9, 1515—1528.

Conow,C. et al. (2010) Jane: a new tool for the cophylogeny reconstruction prob-
lem. Algorithm Mol. Biol, 5, 16.

David,L.A. and Alm,E.J. (2011) Rapid evolutionary innovation during an archaean
genetic expansion. Nature, 469, 93—96.

Doyon,J.P. et al. (2010) An efﬁcient algorithm for gene/species trees parsimonious
reconciliation with losses, duplications and transfers. In: Tannier,E. (ed.)
RECOMB—CG, volume 6398 of Lecture Notes in Computer Science. Springer,
Berlin Heidelberg, pp. 93—108.

GOmez,J.M. et al. (2010) Ecological interactions are evolutionarily conserved across
the entire tree of life. Nature, 465, 918—921.

Goodman,M. et al. (1979) Fitting the gene lineage into its species lineage. a parsi-
mony strategy illustrated by cladograms constructed from globin sequences.
Syst. Zool, 28, 132—163.

Hafner,M.S. and Nadler,S.A. (1988) Phylogenetic trees support the coevolution of
parasites and their hosts. Nature, 332, 258—259.

Hallett,M.T. et al. (2004) Simultaneous identiﬁcation of duplications and lateral
transfers. In: Bourne,P.E. and Gusﬁeld,D. (eds) RECOMB. ACM, New
York, NY, USA, pp. 347—356.

J ackson,A. and Charleston,M. (2004) A cophylogenetic perspective of RNA-virus
evolution. Mol Biol. Evol., 21, 45—57.

Koonin,E.V. (2005) Orthologs, paralogs, and evolutionary genomics. Annu. Rev.
Genet., 39, 309—338.

Libeskind—Hadas,R. and Charleston,M. (2009) On the computational complexity of
the reticulate cophylogeny reconstruction problem. J. Comput. Biol, 16,
105—1 17.

Morrone,J. (2009) Evolutionary Biogeography: An Integrative Approach with Case
Studies. Columbia University Press, New York.

Ovadia,Y. et al. (2011) The cophylogeny reconstruction problem is NP-complete.
J. Comput. Biol, 18, 59—65.

Page,R.D.M. (1994) Maps between trees and cladistic analysis of historical associ-
ations among genes, organisms, and areas. Syst. Biol, 43, 58—77.

Rutschmann,F. (2006) Molecular dating of phylogenetic trees: a brief review of
current methods that estimate divergence times. Divers. Distrib., 12, 35—48.

Scornavaoca,C. et al. (2013) Representing a set of reconciliations in a compact way.
J. Bioinform. Comput. Biol, 11, 1250025.

Sorenson,M.D. et al. (2004) Clade-limited colonization in brood parasitic ﬁnches
(vidua spp.). Syst. Biol, 53, 140—153.

Stolzer,M. et al. (2012) Inferring duplications, losses, transfers and incomplete lin-
eage sorting with nonbinary species trees. Bioinformatics, 28, 409—415.

Szollosi,G.J. et al. (2012) Phylogenetic modeling Of lateral gene transfer reconstructs
the pattern and relative timing Of speciations. Proc. Natl Acad. Sci. USA, 109,
17513—17518.

Toﬁgh,A. (2009) Using trees to capture reticulate evolution: lateral gene
transfers and cancer progression. PhD Thesis, KTH Royal Institute of
Technology.

Toﬁgh,A. et al. (2011) Simultaneous identiﬁcation of duplications
and lateral gene transfers. IEEE/ACM Trans. Comput. Biol. Bioinform., 8,
517—535.

 

i95

1e /810's113umo IPJOJXO'SOllBIIIJOJUIOIQ/ﬁ(1111] U101} popeOIHAAOQ

9IOZ ‘091sn8nv uo ::

