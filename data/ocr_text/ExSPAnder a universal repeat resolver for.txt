Vol. 30 ISMB 2014, pages i293—i301
doi: 10. 1 093/bioinformatics/btu266

 

ExSPAnder: a universal repeat resolver for DNA fragment

assembly

Andrey D. Prjibelskil’l’*, Irina Vasilinetc1 ’l, Anton Bankevich‘, Alexey Gurevich‘,
Tatiana Krivosheeva‘, Sergey Nurk‘, Son Pham4, Anton Korobeynikov1 ’2, Alla Lapidus1 ’3

and Pavel A. Pevzner1 ’4

1Algorithmic Biology Lab, St. Petersburg Academic University, St. Petersburg, Russia, 2Department of Mathematics and
Mechanics, 3Theodosius Dobzhansky Center for Genome Bioinformatics, St. Petersburg State University,
St. Petersburg, Russia and 4Department of Computer Science and Engineering, University of California, San Diego, USA

 

ABSTRACT

Next-generation sequencing (NGS) technologies have raised a chal-
lenging de novo genome assembly problem that is further amplified in
recently emerged single-cell sequencing projects. While various NGS
assemblers can use information from several libraries of read-pairs,
most of them were originally developed for a single library and do
not fully benefit from multiple libraries. Moreover, most assemblers
assume uniform read coverage, condition that does not hold for
single-cell projects where utilization of read-pairs is even more chal-
lenging. We have developed an exSPAnder algorithm that accurately
resolves repeats in the case of both single and multiple libraries of
read-pairs in both standard and single-cell assembly projects.
Availability and implementation: http://bioinf.spbau.ru/en/spades
Contact: ap@bioinf.spbau.ru

1 INTRODUCTION

Most of existing next-generation sequencing (NGS) platforms
generate read-pairs—pairs of reads (called mates) that are
sequenced from different ends of a genomic fragment with ap-
proximately known length (called the insert size). Because the
insert size usually exceeds the length of a single read, read-
pairs may match up unique regions surrounding repeats that
are longer than the read length. A combination of several
libraries of read-pairs with different insert sizes is often used to
produce high-quality assemblies (Butler et al. 2008; Bresler et al.,
2012). Paired-end libraries usually have insert size <1 kb and are
used for resolving relatively short repeats. Jumping libraries are
characterized by an average insert size of anywhere from 1 to 20
kb and are helpful in resolving longer repeats and contig scaf-
folding (inferring the order of contigs in the genome). However,
because of a high insert size variation, information from jumping
libraries is rather difﬁcult to use for the purpose of assembly.
The problem of using multiple read-pair libraries was previ-
ously addressed by ALLPATHS-LG (Gnerre et al., 2011), Ray
(Boisvert et al., 2010), Velvet (Zerbino and Birney, 2008) and
some other assemblers. However, these tools are designed for
standard (mutlicell) assemblies and do not perform well on
single-cell datasets. On the other hand, the single-cell assemblers
ESC (Chitsaz et al., 2011), IDBA—UD (Peng et al., 2012) and
SPAdes (Bankevich et al., 2012) are designed for a single

 

*To whom correspondence should be addressed.
TThe authors wish it to be known that, in their opinion, the ﬁrst two
authors should be regarded as Joint First Authors.

read-pair library. In addition, the recently proposed Paired de
Bruijn Graph algorithms for repeat resolution (Medvedev et al.,
2011; Pham et al., 2013; Vyahhi et al., 2012) also focus on
a single library and it remains unclear how to extend them to
multiple libraries.

We present EXSPANDER algorithm that works with both single
and multiple libraries in standard and single-cell assembly pro-
jects. EXSPANDER uses a simple path extension approach for
repeat resolution that was originally proposed in the Ray assem-
bler [and later used in Telescoper (Bresler et al., 2012)] and com-
bines it with some ideas from the Rectangle Graph approach
(Bankevich et al., 2012; Vyahhi et al., 2012). Given a set of
paths in the assembly graph (Bankevich et al., 2012) (i.e. simpli-
ﬁed de Bruijn graph (Compeau et al., 2011; Pevzner et al., 2001)
of k—mers in reads after removal of bulges, tips and chimeric
edges), EXSPANDER attempts to extend each path with the goal
to generate longer paths. For a path P ending in a vertex v, we
consider all edges starting at v (referred to as extension edges) and
compute Scorep(e) for each extension edge. To compute
Scorep(e) we analyze all reads that map to path P and whose
mates map to e. Thus, Scorep(e) reﬂects our conﬁdence that an
extension of the path P by the edge e is correct. We note that to
properly map read-pairs and calculate Score P(e), the total length
of path P and edge e should be longer than the insert size.

In addition to function Scorep(e), EXSPANDER uses a decision
rule Extend(P) that either chooses one of the extension edges to
extend the path P or makes the decision to stop growing this
path beyond the ending vertex of P. The procedure is iterated
over all the paths until no path can be further extended. To
initiate this algorithm one can start with a set of single-edge
paths formed by all sufﬁciently long edges in the assembly
graph. The resulting paths are output as contigs after removing
the paths that are contained within other paths as well as remov-
ing non-informative overlaps (i.e. sufﬁxes of paths that represent
preﬁxes of other paths).

This simple approach is merely a framework and, depending
on the speciﬁcs of the scoring function and the decision rule, it
can be either efﬁcient (like in the Ray assembler) or disastrous.
The authors of Telescoper made an attempt to improve on Ray’s
scoring function and to substantiate it with rigorous statistical
analysis. However, scoring functions in both Ray and Telescoper
are not universal, e. g. they assume the uniform genome coverage
by reads, condition that does not hold for single-cell data.

We demonstrate that EXSPANDER works well on single-cell
datasets with multiple libraries. We also show that EXSPANDER

 

© The Author 2014. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/
by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial

re-use, please contact journals.permissions@oup.com

112 ﬁlm'spaumo[pJOJXO'sopemJogutotq/ﬁd11q IIIOJJ papeolumoq

910K ‘09 isnﬁnV no :2

A.D.Pljiibelski et al.

 

1 00000

 

1 0000

A
N
v
A
0'
v

1 000

1 0000 1 00

Number of reads
Number of reads

 

 

 

 

1 000 1
200 300 400 0 4000 8000 12000

Observed insert size, bp Observed insert size, bp

 

 

A
O
v

1e+06 (d) 100000

1 00000 1 0000
1 000
1 0000
1 00

Number of reads
Number of reads

1000 10

 

 

 

 

 

 

1 00 1
100 200 300 0 2000 4000

Observed insert size, bp Observed insert size, bp
Fig. 1. Plots of the insert size distributions for Bfaecium isolate
(a) paired-end and 0)) jumping library, and S.aureus single-cell dataset
with (c) paired-end and (d) jumping library. The distributions were com-
puted by mapping reads to the Bfaecium str. DSM4810 (Lapidus et al.,
2009) and S. aureus str. USA300 substr. FPR3757 (Diep et al., 2006)
reference genomes, respectively. All plots are in the logarithmic scale

[implemented as a part of SPAdes (Bankevich et al., 2012)] im-
proves on existing assemblers on standard bacterial datasets and
outperforms such popular assemblers as ABySS (Simpson et al.,
2009), Ray (Boisvert et al., 2010), SOAPdenovo (Li et al., 2010)
and Velvet (Zerbino and Birney, 2008). ALLPATHS-LG
(Gnerre et al., 2011) is an excellent assembler whose applications,
however, are limited to specially constructed read-pair libraries.
On such libraries EXSPANDER and ALLPATHS-LG generate
comparable results (EXSPANDER generates longer contigs but
ALLPATHS-LG generates longer scaffolds).

2 ANALYSIS OF READ-PAIR LIBRARIES

As we mentioned in the introduction, jumping libraries present
additional challenges for genome assembly owing to their high
variations in the insert size. Additionally, jumping libraries have
high rate of chimeric read-pairs—read-pairs that either have ab-
normal insert size or incorrect orientation. Chimeric read-pairs
further complicate utilization of such libraries while resolving
repeats.

Below we present analysis of the insert size distributions for
the following data: Brachybacteriumfaecium isolate dataset (read
length 150 bp) and Staphylococcus aureus single-cell dataset (read
length 101 bp). Both datasets contain one paired-end and one
jumping library. To analyze read-pair libraries we aligned reads
to the B.faecium and S.aureus reference genomes using Bowtie 2
(Langmead and Salzberg, 2012) and computed the chimeric read-
pair rates and insert size distributions.

As Figure 1 and Table 1 demonstrate, both isolate and single-
cell paired-end libraries have small variations of the insert size. In
contrast, the jumping library from the Bfaecium dataset has a
much higher variation in the insert size and higher rate of chi-
meric read-pairs (Table 1). At the same time, in addition to the
large insert size variations, S.aureus jumping library contains
only 22% of all read-pairs aligned with the proper reverse—
forward orientation. Thirty-six percent of all read-pairs have

Table 1. Information on the Bfaecium isolate dataset and the S.aureus
single-cell dataset

 

 

Dataset Bfaecium S.aureus

Library Paired-end Jumping Paired-end Jumping
Number of reads 13 M 41 M 38 M 41 M
Average coverage 400x 1100x 1050x 1050x
Coverage span 210—570x 0—3000x 0—3500x 0—3500x
Insert size 270 bp 7.5 kb 210 bp 1.8 kb
Insert span 150—400 bp 6—10 kb 180—230 bp 0.5—4 kb
Chimeric read-pairs (%) 1 9 3 50
Unaligned read-pairs (%) 16 10 6 28

 

Note: Insert span is the shortest insert size interval that contains at least 95% of
properly aligned read-pairs. Unaligned reads refer to the percentage of read-pairs
that have at least one read unaligned. Chimeric read-pairs refer to the percentage of
chimeric read-pairs among all read-pairs. All statistics was obtained using Bowtie2
(Langmead and Salzberg, 2012). Coverage span is the smallest coverage interval that
includes a least 95% of all genomic positions

incorrect forward—reverse orientation (correspond to the left
peak in Fig. 1d) and 14% are classiﬁed as chimeric read-pairs
of other types. F orward—reverse read-pairs in jumping libraries
represent an artifact of the sample preparation and are common
for datasets of different types.

Despite the fact that various artifacts of jumping libraries
make it difﬁcult to incorporate them into existing assembly
tools, EXSPANDER uses jumping libraries to generate high-quality
assemblies.

3 EXSPANDER ALGORITHM

EXSPANDER uses an assembly graph constructed by SPAdes
(Bankevich et al., 2012) and a set of read-pair libraries. For
each library, we map read-pairs to the long edges of the assembly
graph and estimate the average insert size along with its confi-
dence interval—a shortest insert size interval that contains at least
80% of properly aligned read-pairs. These estimates are used as
parameters of the scoring function and the decision rule.

3.1 The decision rule

3.1.] Single library Given a path P, we deﬁne a winner as an
edge e with the maximal score Score P(e) among all extension
edges for P. Similarly, a contender is deﬁned as an extension edge
with the second best score. The winner edge is called the strong
winner if (i) Scorep(winner) >63 and (ii) Scorep(winner)>C -
ScoreP(contender), where (9 and C are parameters of the algo-
rithm, which are discussed below. If the path P has a single
extension edge (which is obviously the winner), only the ﬁrst
condition is used. The decision rule is deﬁned as follows:

e, if edge e is the strong winner for path P
Extend(P) = _ _ _
0, 1f there 1s no strong w1nner for path P

3.1.2 Multiple libraries The decision rule described above can
be generalized for several read-pair libraries. Consider M read-
pair libraries, which are sorted in the order of increasing insert

 

i294

112 [glO'SIBILInO[p.IOJXO'SODBIIIJOJIIIOIQ/ﬂ(11111 IIIOJJ papeolumoq

910K ‘09 isnﬁnV no :2

ExSPAnder

 

 

(a) r 'r’
— —
530 I yo I
C e )3 I )0
C

 

 

 

 

 

e I
I

I

I

I

yo -----g .
- .l

I
370 6

(d)

I .
e I
I

I

I

I

I

I

\I

I

e

 

Fig. 2. (a) Reads r and r’ form a read-pair mapping to consecutive edges e
and e’ in the assembly graph at positions x0 and yo, respectively.
(b) Representation of a read-pair (r,r’) as a point in a rectangle (e,e’).
(c) ‘Ideal read-pairs’ with the exact insert size I connecting edges e and e’
form a 45° line within a rectangle. (d) Read-pairs from the real sequencing
data with variations in the insert size represented as points within a rect-
angle. Most points are located within the conﬁdence strip providing the
evidence that edges e and e’ are supported by the read-pairs and are
genome-consecutive. (e) A rectangle formed by a pair of edges that has
few points falling into the conﬁdence strip revealing that e and e’ are not
genome-consecutive edges

sizes and the associated decision rules Extend,(P) for 1 5 i 5 M.
We process the libraries in this order because our analysis re-
vealed that the smaller is the insert size of a library (and its
variation), the more reliable is the decision rule for this individual
library. We thus select the library with the smallest index i that
has the strong winner and deﬁne the decision rule for multiple
libraries Extend(P) as simply Extend,(P). If neither library has a
strong winner, we deﬁne Extend(P) = 0.

3.2 The scoring function

3.2.] The support function We ﬁrst consider an idealized case
when the genome deﬁnes a genomic path in the assembly graph.
We say that an edge e’ follows edge e at a distance D if the
distance between starts of these edges in the genomic path is
D. We deﬁne a boolean function SupportD(e,e’) that reﬂects
our conﬁdence that edge e’ follows edge e in the genome at dis-
tance D. Below we describe how to calculate SupportD(e,e’).
Let I and [ImimImax] be the mean and the conﬁdence interval of
the insert size for a read-pair library formed by reads of length
ReadLength. Consider consecutive edges e and e’ in the assembly
graph and a read-pair (r,r’) such that read r maps to e at position
x0 and read r“ maps to e’ in position yo (Fig. 2a). We say that the
read-pair (r,r’) connects edges e and e’. Figure 2b shows a rect-
angle formed by the edges e and e’ [further simply referred to as
rectangle (e,e’)] with the read-pair (r,r’) represented as a point
(x0,y0) within the rectangle. If edges e and e’ represent consecu-
tive regions in the genome, then the genomic distance from the
start of read r to the start of read r’ equals to Length(e) — x0 + yo,

where Length(e) stands for the length of edge e. Therefore, in the
case of an ‘ideal read-pair’ (r,r’) (e.g. a read-pair with the exact
insert size 1), yo = x0 — d, where d = Length(e) — I + ReadLength.
Thus all ‘ideal read-pairs’ mapping to edges e and e’ form a set
of integer points on the 450 line y = x— d within the rectangle
(Fig. 20). Because the read-pairs from the real sequencing data
have variations in the insert size, their corresponding points are
typically scattered in the strip between the 45° lines y = x — dmin
and y = x — dmax, where

dml-n = Length(e) — [ml-n + ReadLength,
dmax = Length(e) — [max + ReadLength.

This strip in the rectangle is further referred to as the confidence
strip (Fig. 2d).

Let F(x) be the empirical distribution of the insert size and S
be a set of all integer points within the conﬁdence strip in the
rectangle (e,e’). We deﬁne the expected number of read-pairs
within the conﬁdence strip (under the assumption of the uniform
coverage) as

Expected(e, e’) = E F (I (X, y»,
(x,y)eS

where I(x, y) = Length(e) — x + y + ReadLength represents the
insert size of a read-pair that corresponds to the point (x, y).
We also deﬁne Points(e,e’) as the total number of read-pairs
(from the real dataset) that correspond to the points within the
conﬁdence strip. The notion of density is deﬁned as

. , _ Points(e, e’)

Denszty(e, e) Expected“, 6,).

We set Density(e,e’) = 0, if Expected(e,e’) = 0. The points outside
the conﬁdence strip may represent read-pairs with somewhat
larger deviations from the mean insert sizes or chimeric read-
pairs. Our analysis revealed that being conservative (e. g. limiting
analysis to the conﬁdence strip) allows one to avoid most of the
assembly errors caused by chimeric read-pairs, particularly in
single-cell projects.

We distinguish between notions of genome-consecutive and
graph-consecutive edges and emphasize that graph-consecutive
edges are not necessarily genome-consecutive. The decision
about which graph-consecutive edges are genome-consecutive is
an important part of any assembler. Figure 2d and e illus-
trate how rectangles help us to make such decisions: both rect-
angles correspond to graph-consecutive edges, but only rectangle
in Figure 2d is formed by the pair of genome-consecutive edges.

The described notions of Expected(e,e’), Points(e,e’) and
Density(e,e’) (deﬁned for the case when edges e and e’ are
genome-consecutive) can be generalized for the case when e
and e’ are not consecutive genomic edges under the assumption
that genomic distance between them is D. In this case the conﬁ-
dence strip [further referred to as StripD(e,e’)] is bounded by the
lines y = x — dmin and y = x — dmax, where

dmm = D — [min + ReadLength,
dmax = D — [max + ReadLength.

PointsD(e,e’) similarly represents the number of points within
strip StripD(e,e’). ExpectedD(e,e’) and DensityD(e,e’) are deﬁned

 

i295

112 ﬂJO's112umo[progxosoneuuoptotqﬂzd11q 111011 papeolumoq

910K ‘09 isnﬁnV no :2

A.D.Pljiibelski et al.

 

(a)

61

p1 P3

(b)

 

 

 

 

 

 

   

Fig. 3. (a) An example of an assembly graph with the genomic paths (p1,
p2, p3, el) and (p1, p’z, p3, e2). (b, e) The composite rectangles for correct
genomic extension of each path: in these cases the points are evenly
distributed within the conﬁdence strip and the resulting score is equal
to 1. (c, d) The composite rectangles that correspond to incorrect exten-
sions edges of these two paths. In each of these cases, at least one simple
rectangle contains few points within the conﬁdence strip

using the same formulas and the corresponding conﬁdence strip.
Clearly, for two genome-consecutive edges Expected(e,e’) =
ExpectedL(e,e’) and Density(e,e’) = DensityL(e,e’), where
L = Length(e).

The support function reﬂects whether the number of read-
pairs connecting edges e and e’ supports the conjecture that e’
follows e in the genome at distance D:

1, DensityD(e, e’) > \11

SupportD (e, e’) = _
0, otherw1se

where \11 is a parameter of the algorithm, which is automatically
computed for each read-pair library based on the chimeric read-
pair rate (see below). For the standard isolate datasets this par-
ameter corresponds to the coverage cutoff for read-pairs. For
single-cell datasets this parameter is usually set to be very low
to retain the regions with low coverage, which are typical for sin-
gle-cell projects. If SupportD(e,e’) = 1, we say that the rectangle
(e,e’) is supported by the read-pairs.

3.2.2 The naive scoring function To explain the intuition behind
EXSPANDER, we ﬁrst introduce the naive scoring function. We
further modify the naive scoring function to arrive to the
advanced scoring function used in the real EXSPANDER
implementation.

A path P = (p1, . . . ,pm) and its extension edge e can be repre-
sented as a composite rectangle formed by m simple rectangles
(pj,e) containing points that correspond to read-pairs connecting
edges of P and e. Figure 3b shows an example of a composite
rectangle, which is formed by a path (p1, p2, p3) and its extension
edge el and consists of three simple rectangles. The notion of the

conﬁdence strip remains (it now consists of up to m substrips
within simple rectangles), except that it is bounded by the lines
y = x — dmin and y = x — dmax, where

dml-n = Length(P) — [min + ReadLength,
dmax = Length(P) — [max + ReadLength.

For an edge pj from the path P we deﬁne the expected number
of points in the conﬁdence substrip within the simple rectangle
(pj,e) as ExpectedDj(pJ-, e), where Dj is the distance between
start of pj and start of e according to the path P
(i.e. D,- = J. Length(p,)). We consider rectangles (pj, e), j =star
t, . . . , end such that ExpectedDj(pJ-, e) > 0 and introduce the func-
tion Scorep(e) as the fraction of the total number of expected
read-pairs in these rectangles with SupportDJ.(pJ-, e) = 1:

 

end
2 SupportDj(pJ-, e) - ExpectedDj(pJ-, e)
Score p(e) = 12mm end
2 ExpectedDj(pJ-, e)
j =start

We set Scorep(e) = 0 if all simple rectangle have zero expected
read-pairs.

Figure 3a shows paths P = (p1, p2, p3) and P, =(p1,p’2,p3)
and its extension edges e1,e2. Let (p1, p2, p3, el) and (p1, p’2, p3,
e2) be the true (but unknown) genomic paths. Figure 3b shows
the composite rectangle for path P and its correct extension e1, in
which points within the conﬁdence strip are rather evenly dis-
tributed resulting in Scorep(e1) = 1. Figure 3c shows the com-
posite rectangle for path P = (p1, p2, p3) and its incorrect
extension edge e2. Because (p1, p’2, p3, e2) is a genomic path, dens-
ity of the points in the sectors of the conﬁdence strip correspond-
ing to edges p1 and p3 is high. However, edge p2 of the path P
does not support extension edge e2 because there are few points
in the rectangle (p2, e2). Additionally, Figure 3d and e shows
composite rectangles for all possible extension edges for path
P = (pup/2,193)-

Because the deﬁned scoring function does not linearly depend
on read coverage, it is well suitable for both single-cell and stand-
ard sequencing projects. At the same time, considering only read-
pairs with insert size in [ImimImax] (which correspond to points
within the conﬁdence strip) allows one to ﬁlter out most of the
chimeric read-pairs (common for single-cell datasets) and to min-
imize their inﬂuence on the scoring function.

3.2.3 The advanced scoring function The naive scoring function
Score P(e) described above works well in many cases but may be
too conservative when the path P contains repetitive edges (edges
that are visited more than once by the genomic traversal).
Figure 4 illustrates the case when the path P has a repetitive
edge and motivates the need for further improvements in the
scoring function.

Figure 4a shows an assembly graph with four unique edges
(p, p’, e and e’) and a single repetitive edge p, with multiplicity 2.
We assume that paths (p,p,,e) and (p’,p,,e’) are genomic and
paths (p,p,,e’) and (p’,p,,e) are non-genomic. Our goal is to
design an algorithm that correctly extends genomic paths (p,p,)

 

i296

112 /810's112umo[pJOJXO'soI112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 isnﬁnV no :2

ExSPAnder

 

 

 

Pr

 

 

Fig. 4. Scoring a path that contains repetitive edges. (a) An example of
the assembly graph with a repetitive edge pr. 0)) A composite rectangle for
the correct extension e of path (p,p,). (c) A composite rectangle for the
incorrect extension e’ of the path (p,p,)

and (p’,p,) into longer genomic paths (p,p,,e) and (p’,p,,e’),
respectively.

Consider a path P = (p,p,) and composite rectangles (P,e) and
(P,e’) (Fig. 4b and c). As Figure 4 illustrates, ScoreP(e) is similar
to Score P(e’ ), implying that there is no strong winner for path P
and preventing us from extending the path P by edge e.
However, because the repetitive edge p, supports both extension
edges e and e’, it does not provide any valuable information
about the correct extension of the path P. Therefore, to make
a decision about extending the path P by an extension edge e, we
should have excluded p, from the consideration as a repetitive
edge. Because we do not know in advance which edges of the
assembly graph correspond to repeats in the genome, we classify
p, as repetitive because it supports both extension edges e and e’ .

Below we present the EXSPANDER algorithm that allows us
to exclude repetitive edges from contributing to scoring. An
extension edge e of path P is called an active edge if
C - Score p(e) Z Scorep(winner). At the ﬁrst step of the algorithm
we score all extension edges and form a set of active edges A. An
edge pj in path P is classiﬁed as repetitive if it supports all active
edges, i.e. SupportDJ.(pJ-, e,-) =1 for all e,- e A. At the second step
we mark all repetitive edges pj e P and recalculate scores of all
edges in A ignoring these repetitive edges. We then update A by
removing all non-active edges and iterate the process. The pro-
cess continues until yet another iteration does not change the set
of active edges A. If A = {e} and Score P(e) >® (which means that
e satisﬁes both conditions in the decision rule) the extension edge
e is considered to be a strong winner and added to the path P.
Otherwise, we stop extending path P.

We further demonstrate the work of the EXSPANDER algo-
rithm using a simple assembly graph shown in Figure 5. The
paths (p1,p2,p3, e1), (p’1,p2,p3, e2) and (p’2,p3, e3) are genomic
paths, which means that edges p2 and p3 are repetitive and have
multiplicities 2 and 3, respectively.

Let P = (p1, p2, p3) be a path we aim to extend. We ﬁrst cal-
culate scores of all extension edges using the composite rectangles
(Fig. 6a—c) and form a set of active edges A= {e1, e2, e3}
based on their scores (marked red in Fig. 6d). Because SupportD3

 

1 61

p2
P1 103 62
, > )0

P2

00

Fig. 5. An example of the assembly graph with repetitive edges p2 and p3

(p3, e,-) = 1 for i = 1, 2, 3, edge p3 is classiﬁed as repetitive and is
removed from further consideration (Fig. 6e). We now recalcu-
late scores for the extension edges in A ignoring repetitive edge p3
(Fig. 6f—h) and remove non-active edge e3 from A (Fig. 6i).
Using the updated set A= {e1, e2} we again proceed to the
repeat detection step and mark edge p2 as repetitive because Su
pportD,(p2, e,-)=1 for i = 1, 2 (Fig. 6j). Finally, we once again
recalculate scores of the extension edges in A (Fig. 6k—m) and
remove e2 as non-active (Fig. 6n). The extension edge e1 remains
the only active edge in and is used to extend path P.

Extensive tests of the advanced scoring function revealed that
it works well across diverse datasets including single-cell jumping
libraries with high variations in the insert size, extremely non-
uniform coverage and large number of chimeric reads and chi-
meric read-pairs (see Section 4).

3.3 Scaffolding

After all paths are constructed, we consider all pairs of paths
that form composite rectangles with non-zero number of points
(Fig. 7). For each such pair of paths P and P’ we can check
whether points in the corresponding composite rectangle are
scattered around a certain 45° line using SPAdes distance esti-
mation procedure (Nurk et al., 2013). When SPAdes provides the
estimated distance D between P and P’, we use EXSPANDER to
verify the conjecture that P’ follows P at distance D. If this con-
jecture is supported and does not contradict to any other con-
jectures about these paths, we extend the path P by P’ (the
scaffolding step). We estimate the gap length between the paths
as D — Length(P) and insert the appropriate number of ‘N’ sym-
bols (unspeciﬁed nucleotide) between end of P and start of P’ . If
paths P and P’ overlap, we construct their overlap alignment to
correct distance D.

3.4 Choice of the parameters

3.4.] The scoring function We select the parameter \11 as a
threshold for the density of the read-pairs within the conﬁdence
strip. We therefore assume that rectangles with the density below
\11 contain mostly chimeric read-pairs and should be ignored
while calculating the score of an extension edge. To select \11
for a particular read-pair library, we estimate the distribution
of the densities for rectangles that contain only chimeric read-
pairs (false rectangles) and for rectangles that contain only non-
chimeric read-pairs (true rectangles).

To partition all read-pairs into chimeric and non-chimeric, one
needs the complete genome that is unavailable. To get around
this, we identify a subset of chimeric reads using the long edges in
the assembly graph (e. g. edges longer than N50) that can be

 

i297

112 /810's112umoprOJXO'soI112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

A.D.Pljiibelski et al.

 

 

 

 

 

"6
j_I
"6
NJ
"6
w
'B
j-I
'B
[Q
"G
00

CD

 

 

 

 

(i)

 

 

 

 

(n)

Fig. 6. A step-by—step example of the EXSPANDER algorithm. (a—c) Forming a set of active edges {e1, e2, e3} (marked red) for the path P = (p1, p2, p3)
using the corresponding composite rectangles. (d, e) Classifying of edge p3 as repetitive and removing it from further consideration (marking gray). Edges
that are not classiﬁed as repetitive are colored in blue. (f—h) Recalculating scores of the extension edges and updating the set of active edges. (i, j)
Removing repetitive edge p2. Gem) Recalculating scores for the remaining active edges {eh e2} and removing e2 as non-active. (n) Selecting the only
active edge e1 as an extension for the path P

 

i298

112 /810's112umoprOJXO'soI112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

ExSPAnder

 

 

 

 

Fig. 7. An example of a composite rectangle formed by paths (p1, p2, p3)
and (121,193,193)

viewed as subgenomes of the complete genome. By mapping a
read-pair to a long edge we can compute its insert size and thus
classify read-pairs with abnormally large insert sizes as chimeric.

To estimate the parameter \II, we generate a large number of
equally sized rectangles by artiﬁcially ‘splitting’ each long edge
into shorter edges of equal length (e.g. 100 bp) called uni-edges.
We then consider rectangles formed by all pairs of uni-edges
within the same long edge. Because we know the exact distance
between such uni-edges, we can calculate the expected number of
read-pairs ExpectedD(e1,e2) for all pairs of uni-edges within the
same long edge. If uni-edges el and e2 come from the same long
edge and ExpectedD(e1,e2) = 0, then all points in the conﬁdence
strip StripD(e1,e2) represent chimeric read-pairs connecting el
and e2. Such edge-pair (e1,e2) is classiﬁed as a false edge-pair.
Otherwise, if ExpectedD(e1, e2)>0, we assume that all points
within StripD(e1, e2) represent correct read-pairs and classify
(e1,e2) as a true edge-pair.

Edges el and e2 and a parameter D deﬁne the strip
StripD(e1,e2) with the number of points PointsD(e1,e2). For a
pair of edges el and e2, we deﬁne

D* = argmax PointsD(e1, e2).
D

When (e1,e2) is a false edge-pair, D:k deﬁnes a conﬁdence strip S
trip D* (e1, e2) with the maximum number of chimeric read-pairs.
To compute the threshold \11, we assume this worst-case scenario
for all pairs of uni-edges (within the same long edge) by using
distance D:k (rather than the known genomic distance) for calcu-
lating the densities DensityD*(e1, e2).

For a certain value of \II we deﬁne false positives (false nega-
tives) as the false (true) edge-pairs that have density higher
(lower) than \II’. Figures 8a and b illustrate how false-positive
rate (green) and false-negative rate (blue) depend on the param-
eter \II. EXSPANDER selects \II that corresponds to the intersection
point of the false-positive and false-negative plots. Our bench-
marking revealed that such choice of the parameter \11 allows one
to ﬁlter out the rectangles containing only chimeric reads-pairs
based on their densities. Additional analysis revealed that esti-
mating the parameter \11 is an important step in the EXSPANDER
algorithm because varying this parameter may signiﬁcantly affect
the assembly quality (see Section 3 in Appendix).

H
H

 

 

p o
O) on
FP/FN rate
_o o
01 on

FP/FN rate
9
.1:

.0
.1:

O
N
O
N

 

 

 

 

 

 

0 0

'.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 '.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
w w

Fig. 8. Plots of the false-positive (green) and false-negative (blue) rates

for (a) Bfacium and (b) S.aureus paired-end libraries

3.4.2 The decision rule Our analysis revealed that varying par-
ameters C and (9 within speciﬁed ranges (see Section 3 of the
Appendix) hardly affects the quality of the resulting assemblies.
However, selecting inappropriate C and (9 may result in a dete-
riorated performance of EXSPANDER. Thus, we arbitrarily select
these parameters within the ranges speciﬁed in Section 3 of
Appendix (analysis of diverse sequencing datasets supports the
default values C = 1.5 and (9 = 0.5).

4 RESULTS

4.1.] Datasets We have compared EXSPANDER (coupled with
SPAdes assembler) with several popular assemblers on the
B.faecium isolate dataset (genome size 3.6 Mb) and the
S.aureus single-cell dataset (genome size 2.9 Mb). For each
dataset we have generated assemblies of (i) only paired-end
library and (ii) both paired-end and jumping libraries. Section
1 of Appendix provides a detailed description of both datasets.

4.1.2 Benchmarking assemblies ABySS 1.3.6, Ray 2.0.0, Velvet,
Velvet-SC and SOAPdenovo 2.0.4 were run with k—mer size 55.
IDBA-UD 1.1.1 was run in its default iterative mode. The
authors of (Peng et al., 2012) released this new version of
IDBA-UD that is capable of using several paired-end libraries,
but there is no manuscript yet covering this new development.
ALLPATHS-LG was run with the default parameters; however,
we down-sampled jumping library for the B.faecium dataset to
generate 100x coverage required by ALLPATHS-LG. SPAdes
2.4 (previous version of SPAdes that did not include EXSPANDER
and did not support multiple libraries) was run in its default
iterative mode with k = 21, 33, 55, 77 for the Bfaecium dataset
and k = 21, 33, 55 for the S.aureus dataset. EXSPANDER (coupled
with SPAdes) was run using the default parameters.

To analyze the resulting assemblies we used QUAST 2.2
(Gurevich et al., 2013) that reports various parameters including
NG50 (similar to N50, but is calculated with respect to the
reference genome size), the total number of contigs/scaffolds,
the length of the longest assembled contig/scaffold, the number
of misassemblies and the fraction of genome mapped. QUAST
deﬁnes a misassemny breakpoint as a position in the contig/
scaffold, such that its left and right ﬂanking sequences either
align to the reference genome over 1 kb away from each other,
or overlap by>1 kb, or align on opposite strands or different
chromosomes (Gurevich et al., 2013). To compare assemblers we
used both contigs and scaffolds of length exceeding 500 bp.

 

112 /810's112umoprOJXO'soI112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

A.D.Pljiibelski et al.

 

Table 2. Comparison of contigs for the Bfaecium isolate dataset

 

Assembler NG50 Number Largest Number GF
of contigs of mis

 

Only paired-end library

ABySS 203 40 672 0 99.9
Ray 114 51 436 1 98.9
SOAPdenovo 20 333 61 0 98.8
Velvet 144 47 550 0 99.4
Velvet- SC 163 46 550 0 99.4
IDBA-UD 202 39 483 0 99.4
SPAdes 2.4 361 24 635 1 99.7
EXSPANDER 380 22 672 1 99 . 5
Both paired-end and jumping libraries
ABySS 203 40 672 0 99.9
ALLPATHS-LG 313 21 686 0 99.5
Ray 87 88 416 2 96.8
SOAPdenovo 20 333 61 0 98.8
Velvet 103 75 242 1 1 99.0
Velvet- SC 253 40 545 15 99.8
IDBA-UD 207 41 483 0 99.4
EXSPANDER 3268 2 3268 1 99.9

 

Note: NG50 is given in kb; number of contigs is the total number of contigs
>500 bp; largest stands for the length (in kb) of the longest contig assembled;
number of mis is the number of misassemblies; GF stands for the fraction of
genome mapped given in percent. In each column, the best value is indicated
in bold.

Tables 2 and 3 show the benchmarking results for the
Bfaecium isolate dataset. Interestingly, the single-cell assemblers
(IDBA-UD and EXSPANDER coupled with SPAdes) as well as
ABySS performed well on the Bfaecium isolate dataset and pro-
duced contigs with the largest NG50 in the case of a single
library. While AbySS generated the assembly with the maximal
genome fraction, manual inspection revealed that it reﬂects the
speciﬁcs of ABySS and QUAST reporting (mapping each repeat
to a single position in the genome) rather than real superiority of
ABySS by this metric.

In the case of two libraries, EXSPANDER produced the best
contigs while ALLPATHS-LG produced the best scaffolds.
The complexity of using jumping libraries is reﬂected in a dete-
riorated performance of ABySS and Ray (reduction in NG50) as
well as Velvet and Velvet-SC (dramatic increase in the number of
misassemblies).

Tables 4 and 5 compare various assemblers on the S.aureus
single-cell dataset. This comparison highlights the complexity of
both (i) assembling single-cell datasets and (ii) using jumping
libraries. For example, SOAPdenovo produced assemblies of
poor quality for single-cell data (we decided not to include it in
Tables 4 and 5). Similarly, ABySS produced assemblies with high
number of misassemblies for the single-cell data. Velvet and
Velvet-SC are not included in the benchmark experiment for
jumping libraries testing because they also produce low-quality
assemblies when both paired-end and jumping libraries are used
simultaneously. IDBA-UD performed well on a single paired-
end library, but produced an assembly of lower quality when
both libraries were provided (decreased NG50). EXSPANDER

Table 3. Comparison of scaffolds for the Bfaecium isolate dataset

 

 

Assembler NG50 Number of Largest Number GF
scaffolds of mis

Only paired-end library
ABySS 383 24 676 0 99.9
Ray 204 31 553 1 98.9
SOAPdenovo 477 26 724 0 99.3
Velvet 477 28 724 0 99.4
Velvet-SC 477 28 724 0 99.4
IDBA-UD 250 30 671 0 99.4
SPAdes 2.4 361 22 671 1 99.7
EXSPANDER 380 22 672 1 99.5

Both paired-end and jumping libraries
ABySS 250 30 739 1 99.9
ALLPATHS-LG 3610 7 3610 1 99.5
Ray 106 75 416 2 96.8
SOAPdenovo 480 28 810 2 99 .4
Velvet 2651 14 2651 78 99.1
Velvet-SC 945 102 1381 500 98.9
IDBA-UD 1002 9 1692 0 99.4
EXSPANDER 3268 2 3268 1 99.9

 

Note: NG50 is given in kb; number of scaffolds is the total number of scaffolds
>500 bp; largest stands for the length (in kb) of the longest scaffold assembled;
number of mis is the number of misassemblies; GF stands for the fraction of
genome mapped given in percent. In each column, the best value is indicated in
bold.

Table 4. Comparison of contigs for the S.aureus single-cell dataset

 

 

Assembler NG50 Number of Largest Number GF
contigs of mis

Only paired— end library
ABySS 27 914 91 262 98.0
Ray 21 306 108 14 88.7
Velvet 10 538 56 2 93.2
Velvet-SC 9 616 56 4 94.2
IDBA-UD 75 390 161 7 98 .6
SPAdes 2.4 98 400 230 8 99.1
EXSPANDER 148 366 275 3 98 .6

Both paired-end and jumping libraries
ABySS 27 914 91 262 98.0
ALLPATHS-LG 15 283 75 26 79.9
Ray 100 178 486 21 93.5
IDBA-UD 47 415 161 7 98.6
EXSPANDER 314 322 603 9 99.3

 

Note: NG50 is given in kb; number of contigs is the total number of contigs >500 bp;
largest stands for the length (in kb) of the longest contig assembled; number of mis is
the number of misassemblies; GF stands for the fraction of genome mapped given in
percent. In each column, the best value is indicated in bold.

produced assemblies with the highest NG50 and largest
assembled contig/scaffold.

Using only paired-end library IDBA-UD, SPAdes 2.4 and
EXSPANDER recovered the largest fraction of the genome
(>98.5%). However, the highest genome fraction of the assembly

 

i300

112 /810's112umofpinXO'soi112u1101uioiq//2d11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

ExSPAnder

 

Table 5. Comparison of scaffolds for the S.aureus single-cell dataset

 

 

Assembler NG50 Number of Largest Number GF
scaffolds of mis

Only paired-end library
ABySS 28 910 91 270 98.2
Ray 21 306 108 14 88.7
Velvet 10 538 56 2 93.2
Velvet-SC 10 620 56 5 94.2
IDBA-UD 88 382 161 8 98.2
SPAdes 2.4 99 391 230 8 99.2
EXSPANDER 148 357 426 4 98.6

Both paired-end and jumping libraries
ABySS 30 852 91 275 98.0
ALLPATHS-LG 40 165 132 69 79.9
Ray 100 169 486 25 93.5
IDBA-UD 55 397 161 9 98.6
EXSPANDER 314 302 603 9 99.3

 

Note: NG50 is given in kb; number of scaffolds is the total number of scaffolds
>500 bp; largest stands for the length (in kb) of the longest scaffold assembled;
number of mis is the number of misassemblies; GF stands for the fraction of
genome mapped given in percent. In each column, the best value is indicated in
bold.

generated by SPAdes 2.4 reﬂects the speciﬁcs of SPAdes 2.4 and
QUAST reporting (some artifacts with reporting of repetitive
regions) rather than real advantage of SPAdes 2.4 with respect
to this parameter.

When using both libraries simultaneously, EXSPANDER pro-
duced assemblies with the highest genome fraction exceeding
99%, the largest genome fraction we saw across dozens of
single-cell datasets assembled with SPAdes in the past 2 years.
Moreover, Tables 4 and 5 show that EXSPANDER successfully
deals with the high rate of the chimeric read-pairs and relatively
high variations in the insert size.

5 CONCLUSION

We have presented EXSPANDER algorithm for resolving
repeats using either a single or multiple read-pair libraries with
different insert sizes, which is applicable for both single-cell and
isolate bacterial datasets. Benchmarks across eight popular
assemblers demonstrate that EXSPANDER produces high-quality
assemblies for datasets of different types. Additionally, as
illustrated by recent integration of Illumina and PacBio reads
in SPAdes 3.0, EXSPANDER is a ﬂexible approach that can be
easily modiﬁed to work with diverse types of sequencing data.

ACKNOWLEDGEMENTS

The B.faecium sequencing data were produced by the Joint
Genome Institute in collaboration with the user community.
The S.aureus dataset was provided by the Human Microbiome
Project (bioproject ID PRJNA236734).

Funding: This work was supported by the Government of the
Russian Federation [grant numbers 11.G34.31.0018,
11.G34.31.0068]; the National Institutes of Health
[3P41RR024851-02S1]; and the Russian Fund for Basic
Research [12-01-00747-a to AK].

Conflict of Interest: none declared.

REFERENCES

Bankevich,A. et al. (2012) SPAdes: a new genome assembly algorithm and its ap-
plications to single-cell sequencing. J. Comput. Biol, 19, 455—477.

Boisvert,S. et al. (2010) Ray: simultaneous assembly of reads from a mix of high-
throughput sequencing technologies. J. Comput. Biol, 17, 1519—1533.

Bresler,M. et al. (2012) Telescoper: de novo assembly of highly repetitive regions.
Bioinformatics, 28, 311—317.

Butler,J. et al. (2008) ALLPATHS: de novo assembly of whole-genome shotgun
microreads. Genome Res, 18, 810—820.

Chitsaz,H. et al. (2011) Efﬁcient de novo assembly of single-cell bacterial genomes
from short-read data sets. Nat. Biotechnol, 29, 915—921.

Compeau,F. et al. (2011) How to apply de Bruijn graphs to genome assembly. Nat.
Biotechnol, 29, 987—991.

Diep,B. et al. (2006) Complete genome sequence of USA300, an epidemic clone of
community-acquired meticillin-resistant Staphylococcus aureus. Lancet, 367,
731—739.

Gnerre,S. et al. (2011) High-quality draft assemblies of mammalian genomes from
massively parallel sequence data. Proc. Natl Acad. Sci. USA, 108, 1513—1518.

Gurevich,A. et al. (2013) QUAST: quality assessment tool for genome assemblies.
Bioinformatics, 29, 1072—1075.

Langmead,B. and Salzberg,S. (2012) Fast gapped-read alignment with bowtie 2.
Nat. Methods, 9, 357—359.

Lapidus,A. et al. (2009) Complete genome sequence of Brachybacterium faecium
type strain (Schefferle 6-10). Standards Genomic Sci., 1, 3—11.

Li,R. et al. (2010) De novo assembly of human genomes with massively parallel
short read sequencing. Genome Res., 20, 265—272.

Nurk,S. et al. (2013) Assembling single-cell genomes and mini-metagenomes from
chimeric MDA products. J. Comput. Biol, 20, 1—24.

Medvedev,P. et al. (2011) Paired de bruijn graphs: a novel approach for incorporating
mate pair information into genome assemblers. J. Comput. Biol, 18, 1625—1634.

Peng,Y. et al. (2012) IDBA-UD: a de novo assembler for single-cell and metage-
nomic sequencing data with highly uneven depth. Bioinformatics, 28, 1—8.

Pevzner,P.A. et al. (2001) An Eulerian path approach to DNA fragment assembly.
Proc. Natl Acad. Sci. USA, 98, 9748—9753.

Pham,S. et al. (2013) Pathset graphs: a novel approach for comprehensive utilization
of paired reads in genome assembly. J. Comput. Biol, 20, 259—371.

Simpson,J. et al. (2009) ABySS: a parallel assembler for short read sequence data.
Genome Res., 19, 1117—1123.

Vyahhi,N. et al. (2012) From de Bruijn graphs to rectangle graphs for genome
assembly,” in Workshop on Algorithms in Bioinformatics 2012. Lecture Notes
Comput Sci, 7534, 200—212.

Zerbino,D.R. and Bimey,E. (2008) Velvet: algorithms for de novo short read assem-
bly using de Bruijn graphs. Genome Res., 18, 821—829.

 

112 /810's112umofpinXO'soi112u1101uioiq//2d11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

