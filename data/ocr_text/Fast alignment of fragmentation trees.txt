Vol. 28 ISMB 2012, pages i265—i273
doi: 10. 1093/bioinformatics/bts207

 

Fast alignment of fragmentation trees
Frahziska Hufsky1’2, Kai D hrkopl, Florian Raschel, Markus Chimahi3 and

Sebastian B cker1’*

1Chair for Bicinfcrmatics, Friedrich—Schi||er—University, 2Max Planck Institute for Chemical Ecology, Beutenberg
Campus and 3Algorithm Engineering, Friedrich—Schi||er—University, Jena, Germany

 

ABSTRACT

Motivation: Mass spectrometry allows sensitive, automated and
high-throughput analysis of small molecules such as metabolites.
One major bottleneck in metabolomics is the identification
of ‘unknown’ small molecules not in any database. Recently,
fragmentation tree alignments have been introduced for the
automated comparison of the fragmentation patterns of small
molecules. Fragmentation pattern similarities are strongly correlated
with the chemical similarity of the molecules, and allow us to cluster
compounds based solely on their fragmentation patterns.

Results: Aligning fragmentation trees is computationally hard.
Nevertheless, we present three exact algorithms for the problem: a
dynamic programming (DP) algorithm, a sparse variant of the DP,
and an Integer Linear Program (ILP). Evaluation of our methods
on three different datasets showed that thousands of alignments
can be computed in a matter of minutes using DP, even for
‘challenging’ instances. Running times of the sparse DP were an
order of magnitude better than for the classical DP. The ILP was
clearly outperformed by both DP approaches. We also found that for
both DP algorithms, computing the 1% slowest alignments required
as much time as computing the 99% fastest.

Contact: sebastian.boecker@uni-jena.de

1 INTRODUCTION

Metabolomics deals with the identiﬁcation and quantiﬁcation of
small compounds below 1000 Da, and has received increasing
interest during the last years (Last et al., 2007). All organisms,
especially plants, fungi and bacteria, synthesize many different
metabolites and a large portion of them is still unknown (Fernie et al. ,
2004). The genome sequence usually does not reveal information
about metabolite structure, as it does for protein structure. Newly
identiﬁed metabolites often serve as leads in drug design (Li and
Vederas, 2009; Schmidt et al., 2007), in particular for antibiotics.
For a high-throughput analysis of metabolites and other small
molecules, mass spectrometry (MS) is the predominant technology
(Cui et al., 2008; Fernie et al., 2004; Last et al., 2007). Nuclear
magnetic resonance reveals more information about the analyte, but
is inapplicable for hi gh-throughput analysis due to its low sensitivity.
MS can be coupled with a separation method (gas chromatography,
liquid chromatography or capillary electrophoresis) to analyze
complex mixtures like cell extracts (Fiehn, 2008; Halket et al.,
2005). To obtain information beyond the compound mass,
the analyte is usually fragmented, and fragment masses are
recorded. Typically, collision-induced dissociation is combined
with liquid chromatography—MS, whereas gas chromatography—MS
uses electron impact fragmentation. The ﬁrst attempt to develop
computational methods for analyzing fragmentation spectra of

 

*To whom correspondence should be addressed.

metabolites has been the DENDRAL project in 1965 (Lederberg,
1965). But the project was stopped after it became clear that
automated structure elucidation using MS data could not be achieved
at that time. Today, data analysis is still the major bottleneck in
metabolomics (Neumann and Booker, 2010). Manual data analysis
requires time and deep knowledge of the underlying chemistry
(Werner et al., 2008). Due to the limited reproducibility of the
data, even library searches are difﬁcult (Oberacher et al., 2009).
Additionally, spectral libraries are vastly incomplete. Methods for
de novo sequencing of non-ribosomal peptides have recently been
developed. But these methods rely on the fact that the analytes are
structurally restricted polymers with predictable fragmentation.

When manually analyzing tandem MS spectra, chemists try
to annotate fragmentation peaks and identify relations between
fragments, resulting in fragmentation pathways. This approach has
been automated by Becker and Rasche (2008). They calculate
hypothetical fragmentation trees solely based on the MS data.
Fragmentation tree nodes are annotated with the molecular formula
of the fragments, whereas edges represent losses. To ﬁnd a
fragmentation tree that shows maximum agreement with the
measured data, we search for a tree of maximum edge weight,
comparable to prize-collecting Steiner trees (Ljubic et al., 2005).
Only lists of common and implausible losses are required as
expert knowledge about fragmentation mechanisms. In Rasche et al.
(2011), experts evaluated the calculated fragmentation trees and
conﬁrmed their excellent quality. Recently, methods to calculate
fragmentation trees from multiple MS and gas chromatography—
MS data have been developed (Hufsky et al., 2012, manuscript;
Scheubert et al. 2011).

MS analysis of similar compounds results in similar fragmentation
trees. Rasche et al. (2012) proposed local tree alignments for
the automated comparison of fragmentation trees and showed that
this method is superior to spectral comparison. Fragmentation
tree alignments even allow for inter-dataset comparisons for
datasets measured on different instruments (Rasche et al., 2012).
A tree alignment may contain matches, mismatches, insertions and
deletions, but respects the structure of the two trees. Fragmentation
tree similarity is deﬁned Via edges (representing losses) and nodes
(representing fragments). A local tree alignment contains those parts
of the two trees where similar fragmentation cascades occurred.

Tree alignments were introduced by J iang et al. (1995) and can be
applied for RNA secondary structure comparison (Le et al., 1989).
RNA structure trees are ordered, that is, the children of any node
have a ﬁxed order. In contrast, fragmentation trees are unordered,
as there cannot exist any sensible ordering for the sub fragments of
some fragment. In this respect, fragmentation trees are more similar
to phylogenetic trees than to RNA structure trees. Whereas efﬁcient,
polynomial—time algorithms exist for the alignment of ordered trees,
the alignment of unordered trees is computationally hard, namely
MAX SNP—hard (J iang et al., 1995). This implies that there exists no

 

© The Author(s) 2012. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/|icenses/
by-nc/3.0), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.

112 [3.10'S1120an[p.IOJXO'SOpBIIIlOJIIIOIQ/ﬂ(11111 IIIOJJ papeolumoq

9IOZ ‘09 isnﬁnV uo ::

EHufsky et al.

 

cystine (a)

 

 

methionine

 

 

C6H11NZOBS;
223.021 Da

     

 

 
     

C3H8NOZS+
122.027 Da

H3N

 

 

 

 

 

( C6H8N035;)
205.994 Da

 

c,H,No,s+
120.011 Da

 

 

 

s H
|
H s
H
0
§ N.H
O H H
H.
rel. intensity ( 
1,0 ,
0's cystine
0,6
0,4
0,2
 . I . || | I . .
0 25 50 75 100 125 150 175 200 225 250
1.0 I I m/z
0'8 methionine
CHZO2 0.6 |
0,4
0,2
II . 

 

 

 

0'00 25 50 75 100 125 130 115 200 225 250
56.049Da m/z

Fig. 1. Optimal fragmentation tree alignment for cystine (11 losses) and methionine (6 losses) from the Orbitrap dataset (a). (b) Fragmentation mass spectra
of cystine and methionine. The mass spectra do not share peaks. Molecular structures of cystine (c) and methionine (d). The molecular structures are not
known to the alignment method. The alignment detects the common fragmentation path of formic acid—ammonia—ethylene losses and the separate ammonia
branch. Additionally, it ﬁnds the methylthiol loss, which occurs at a later stage in cystine

Polynomial Time Approximation Scheme (PTAS) for the problem
unless P=NP (Arora et al., 1998). In case both trees have ﬁxed
maximum out degree, an optimum alignment can be computed Via
dynamic programming (DP) in polynomial time (Jiang et al., 1995).
In comparison, computing the edit distance between two unordered
trees remains MAX SNP hard even for bounded degrees (Zhang
and J iang, 1994). An informal algorithm for aligning fragmentation
trees was presented by Rasche et al. (2012), and JOIN nodes were
introduced to account for missing nodes in one of the trees compared.
Missing nodes result from missing peaks in one of the spectra.
Rasche et al. (2012) do not give a correctness proof or running time
analysis for the algorithm. As related work, we mention the TREE—
CONSTRAINED BIPARTITE MATCHING problem where either a node or
any of its descendants may be part of the matching; this problem is
also APX-hard (Canzar et al., 2011).

Our contribution: we modify the tree alignment algorithm from
Jiang et al. (1995) for edge similarities and local alignments, and
analyze its running time. We then show how to integrate JOIN nodes
without increasing the worst-case running time. Next, we modify
the algorithm to allow for sparse DP, a technique common in RNA
folding (Backofen et al., 2011). This does not only decrease the
practical memory requirements of the method but, more importantly,
also severely decreases running times in practice. Furthermore, we
present an Integer Linear Program (ILP) for the fragmentation tree
alignment problem, as ILPs often solve NP-hard problems swiftly in
practice. We then evaluate all methods on real-world data, and ﬁnd
that the sparse DP approach dominates the classical DP, resulting
in an 11-fold speed-up for one dataset. Somewhat unexpectedly, the
ILP is clearly outperformed by both DP approaches.

2 ALIGNING FRAGMENTATION TREES

Let T =(V,E) be a tree; the elements of V are called nodes. In
the following, we assume all trees to be arboreal, that is, all edges

in E are directed away from some root node. By uv, we denote a
directed edge from node u to node v. Let p(v) be the parent node
of some node v. A fragmentation tree is a tree T =(V,E) together
with an edge labeling K :E —> E. In more detail, nodes V correspond
to fragments of a compound, whereas the labels E are (neutral
or radical) losses: that is, both are molecular formulas over some
ﬁxed alphabet of elements (BOCkCI‘ and Rasche, 2008). Formally,
molecular formulas are compomers or multi sets. The children of
any node of a fragmentation tree are intrinsically unordered, as there
is no sensible way to order the sub fragments of some fragment.
In our presentation, we will not consider the molecular formulas
of fragments, and concentrate on comparing losses only. As we
will see below, comparing fragments instead or comparing both
simultaneously requires only minor modiﬁcations. See Figure 1 for
two examples of fragmentation trees.

We introduce some notation used throughout this article: Let T1 =
(V1,E1) and T 2=(V2,E2) be the two trees we want to align. We
sometimes call T1 the left tree and T 2 the right tree. Let C(v) denote
the children (nodes) of any node v in T1 or T 2. In the following,
we usually assume that u is a node of T1, and v a node of T 2. For
1': 1,2, let ni :2 |Vi| be the number of nodes in T i, and let di be
the maximum out degree in T i. These maximum out degrees will
be of particular interest to us, as the running time of our DP grows
exponentially in 031,032. Let 8 =min{d1,d2} and A =max{d1,d2}.

Rasche et al. (2012) introduce a similarity function a : E X E —> R
for pairs of losses (molecular formulas). We do not repeat the details
here, but note that this implies a similarity function 0 :E1 x E2 —> R
between edges of the two trees T1,T2 Via 0(e1,e2)= a(£(e1), £(e2)).
They also introduce a similarity function for fragment molecular
formulas, which induces a similarity function between nodes of the
two trees.

Furthermore, they also extend the deﬁnition of tree alignments by
introducing a JOIN operator [see Figure 2(b)]: Given a path p1 in T1
of length two, let e1,e’1 be the edges of p1. We can assign a loss to

 

i266

112 /8Jo'SIBanoprOJxo'sor1emJOJquIq//:d11q IIIOJJ papeolumoq

9IOZ ‘09 isnﬁnV uo ::

Fast alignment of fragmentation trees

 

C4H8N203

     

0» w

 

H3N CH202
 H3N
‘T” I E
I 5 I
C2I'I2 ‘\   Csz

Fig. 2. Two alignments of fragmentation trees based on edge similarities.
Nodes represent molecular formulas of the fragments, edges represent
molecular formulas of the losses. (a) A gap (—) is introduced for the missing
CO loss in the left tree (dashed edge and node). Losses CO and CH3 are
aligned by a mismatch (dotted edges). (b) In the left tree, the fragment after
loosing H3N is missing (dashed edges and node), whereas the fragment
after further loss of C2H2 is observed. To account for missing fragments,
we introduce the join operation. It allows to align the two successive losses
H3N and C2 H2 in the right tree to a single loss C2 H5N in the left tree (dotted
edges). Fragments may be missing because the corresponding peak was not
detected, for example

p1 by adding the corresponding losses £(e1)+£(e’1) e E. This means
taking the sum of the respective compomers or the additive union of
the corresponding multisets. We then assign a similarity between
p1 and any edge e2 of T2 as 0(p1 , e2) =a(£(e1)+£(e’1),£(e2)).
Analogously, we can deﬁne a similarity for paths of length two in T 2.
Obviously, this can be generalized to paths of arbitrary lengths but
here, we will limit ourselves to paths of length two. For joining
nodes in the alignment, we assume homogeneous join costs: The
penalty for joining a node is ojoin 5 0, independent of the node or
edge that we want to join. Formally, this allows us to focus on the
important aspects of our algorithms, and omit some technical details.
Practically, we currently see no biologically reasonable way to assign
different scores to different join nodes, as these usually correspond
to the non-detection of a peak in one of the mass spectra.

Let T 1 , T 2 be two trees. We deﬁne a global alignment A of T1, T2
as follows (Jiang et al., 1995): A is a tree where nodes are labeled
with pairs from (V1U{—})X(V2U{—}). Here, ‘—’ is the gap symbol
[see Figure 2(a)]. If we restrict labels of A to the ﬁrst coordinate and
contract all edges that end in a node labeled ‘—’, we end up with the

tree T1; if we do the same for the second coordinate, we end up with
the tree T 2. (In fact, we have to replace the nodes of the restricted
trees by their labels, we omit the simple technical details.) We say
that A is a local alignment if the trees originating from contracting
gap edges are induced subtrees of T1 and T 2, respectively.

Different from Jiang et al. (1995), we want to score an alignment
based on the edges of the two trees. To this end, for any node a of
A but the root, let e1(a) be the unique edge in T1 that ends in the
ﬁrst coordinate of the label of a, and let e2 (a) be the unique edge in
T 2 that ends in the second coordinate of the label of a. In case no
such edge exists, we assume e1 (a) = ‘—’ or e2 (a) = ‘—’, respectively.
Now, we deﬁne the score of A as

Z a(e1(a),e2(a)).

non-root node a of A

We deﬁne 0(T1,T2) as the maximum score of a local alignment of
T1 and T2.

Scoring node pairs and scoring edge pairs are closely related: We
can push an edge score into its end node, or we can pull a node score
into its unique incoming edge. The only difference is that the root
node is not considered when scoring edge pairs. The two scorings
can be combined by introducing a particular root scoring 0* : V1 X
V2 —> R for the root nodes of the alignment. In the following, we
omit the simple but somewhat tedious details, and simply note that
all algorithms presented here work both with node scoring, edge
scoring, as well as a combination thereof. A local fragmentation
tree alignment for two compounds from the Orbitrap dataset (see
Section 6) can be found in Figure 1.

3 DYNAMIC PROGRAMMING

We now present an algorithm to compute optimum fragmentation
tree alignments that has reasonable running time in practice. Our
algorithm is a modiﬁcation of an algorithm by Jiang et al. (1995)
for computing global alignments of unordered trees. The reason for
these algorithms to be swift in practice is that fragmentation trees
usually have comparatively small out degree: fragments rarely have
more than, say, ﬁve child fragments. We can limit the inevitable
exponential part of the running time to this out degree.

We use DP to compute the maximal score 0(T1,T2) of a local
alignment between two trees T 1 , T 2. Let S(u,v) be the maximal
score of a local alignment of two subtrees of T1,T2, where the
subtree of T1 is rooted in u, and the subtree of T 2 is rooted in v. For
Ag C(14) and BE C(v), we deﬁne Su,v[A,B] to be the score of an
optimal local alignment of subtrees rooted in u and v, respectively,
such that maximally the children A of u and B of v are used in
the alignment. Clearly, S (u,v)=Su,v[C(u), C(v)]. Furthermore, we
have Su,v[A,0]=Su,v[0,B]=0 for all A,B. When all S(u,v) are
known, we can compute the maximal score of a local alignment of
T1 , T 2 as

0(T1,T2)= max 5(u,v)- (1)
uET1,v€T2

We present a recurrence for the computation of Su,v[A,B]. We
initialize Su,v[A,B]=0 for A20 or 8:0. Recall that T1 is the
left tree and T 2 is the right tree. In the recurrence, we distinguish
three cases, namely match (including mismatches), deletion left or
deletion right, where the latter two are symmetric (Figure 3). For

 

i267

112 /8Jo'SIBanoprOJxo'sor1emJOJquIq//:d11q IIIOJJ papeolumoq

9IOZ ‘09 isnﬁnV uo ::

EHufsky et al.

 

(a)

   
  

match / mismatch

(b)

‘ u
“‘~.\deletion
.\ a
A
0(a)

 

Fig. 3. Representation of the match and the deleteL recurrences of the
DP algorithm. (a) matchu,v[A,B] is the best score of matching edge ua on
edge vb, such that maximally the children A of u and B of v are used. (b)
deleteLu,v[A,B] is the best score for deleting edge ua, such that maximally
the children A of u and B of v are used. A subset B’ QB of the children of v
can now be matched to the children of a

non-empty sets A g C(14) and B Q C (v) we set

Su,v[A,B] =max{0, matchu,v[A,B],

deleteL”, v [A, B] , deleteRuﬂ, [A, B] }
where we deﬁne

matchu,v[A,B]:= max {S(a,b)+

aeA,beB

Su,v[A—{a},B—{b}]+a(ua,vb)}

deleteLu,v[A,B]:= max {Sa,v[C(a),B']+
aEA,B’§B
(2)
Su,v[A-{a},B—B’]+a(ua,—)}

deleteRu,v[A,B]:= maX {SM bIA/,C(b)l+
A’gA,beB ’

s,,v[A —A’,B—{b}]+a(—,vb)}

Here, 0 (Ltd, vb) denotes the score of the losses attached to arcs Ltd and
vb, and 0(ua, —), a(—, vb) accordingly. Recurrence (2) is the obvious
modiﬁcation of the recurrence presented in Jiang et al. (1995) for
global alignments and node similarities.

Merging two losses in T1 or T 2 requires two additional symmetric
cases, namely join left and join right for merging in tree T1 or
T 2, respectively. To speed up computations, we add an additional

PREJOIN case for nodes that will be joined in the alignment. We set

Su,v[A,B] =max{0, matchu,v[A,B],
deleteLw, [A, B] , deleteRu, v [A, B], (3)

joinLu,v[A,B],joinRu,v[A,B]}
where we deﬁne, in addition to (2),

prejoinLu,v[A,B]:= max {S(a,b)+
aeA,beB

prejoinLuﬂ, [A — {a}, B — {b}] ‘I‘
a(p(u)a, vb)+0join} (4)

joinLu,v[A,B]:= max {prejoinLa,v[C(a),B’]+
aEA,B’§B

Su,v[A—{a},B—B’I}

Here, a(p(u)a,vb) is the score for the combined losses on the path
from p(u) to a with the loss of edge vb. Recall that ajoin50 is
the penalty for joining a node. Again, we initialize joinLu,v[A, 0] =
joinLu,v[0,B]=0 for all A,B. Analogously to (4), we can deﬁne
recurrences for prejoinRu,v[A,B] and joinRu,v[A,B].

For bottom-up DP (Sniedovich, 2006), we have to ﬁnd an order
in which the entries of the DP tables can be ﬁlled. Computation of
matchu,v[A,B], deleteLu,v[A,B] and deleteRu,v[A,B] only accesses
entries Suzy! [A’ ,B’], such that u’ e {u}U C(14) and v’ e {v}U C(v). By
processing nodes in postorder, we ensure that all Su/,v/[A’ ,B’] are
previously computed for (u’ , v’) 7E (u, v). For the remaining case, we
iterate |A| + |B| = 0, 1, . . ., |C(u)| + |C(v) |. Similar arguments hold for
the computation of JOIN and PREJOIN nodes.

THEOREM 1. Let T1=(V1,E1) and T2=(V2,E2) be two trees,
a :E1U{—}XE2U{—}—>R a scoring function between edge pairs,
and ojoin ER the penalty for joining a node. For 1': 1,2 set 11,- :2
|Vi|, and let di be the maximum out degree in T i. The maximum
score 0(T1,T2) of a local alignment of T1,T2 can be computed
in 0(3A -26 «3111112) using recurrence (3) and equation (1), where
A :=max{d1,d2} and 8 :=min{d1,d2}.

The proof of the theorem is based on the following lemma:

LEMMA 1. Computing Su,v[A,B] for all Ag C (u) and BE C (v) is
possible using recurrence (3) in 0(3d“ -2dv -dv+2du -3dv -du) time,
where d“ = |C(u)| and dv = |C(v)|.

See the Supplementary Material for proofs of Lemma 1 and
Theorem 1. Similarly to Theorem 1, we can show that any pairwise
tree alignment that does not take joining nodes into account, can also
be computed in this time. We leave out the straightforward details.

THEOREM 2. A pairwise unordered tree alignment (global or local,
scoring nodes or edges or both, with similarities or costs) of rooted
trees T1,T2 can be computed in 0(3A-26 «3111112) time. Here, n,-
is the number of nodes in tree T i, and di is the maximum out
degree in T i, for i =1,2; furthermore, A:=max{d1,d2} and 8::
min{d1,d2}.

 

i268

112 Bio'SIBanoprOJxo'sor1emJOJquIq//:d11q IIIOJJ papeolumoq

9IOZ ‘09 isnﬁnV uo ::

Fast alignment of fragmentation trees

 

4 SPARSE DYNAMIC PROGRAMMING

Applying the above algorithm to real-world instances of aligning
fragmentation trees, one can see that S(u,v)=0 holds for many
node pairs u,v. This can be attributed to two factors: First, we
are computing local alignments, so we can always choose to end
the alignment subtrees in the nodes u,v. Second, there are many
different labels found at the edges (or nodes) of a fragmentation
tree. Areasonable scoring scheme will assign negative scores to most
non-matching edge (or node) labels, so it is rather the exception than
the rule that we can ﬁnd two nodes u, v with S (u, v) > 0.

The idea is to ‘sparsify’ our DP tables by storing only those
table entries with positive values. Thereby, we face the following
fact: If Su,v[A,B] > 0 forA 5 C(14) and B Q C(v) then Su,v[A’,B’] > 0
holds for all supersets A’ ,B’ with A EA’ 5 C (u) and B EB’ g C (v).
So, as soon as we have one non-zero entry in the table, then an
exponentially large part of the table will be ﬁlled with non—zero
entries, too.

To negate this rather unfortunate effect, we modify our DP as
follows: for A 5 C(14) and BE C(v), we deﬁne SL’W[A,B] to be the
score of an optimum local alignment with subtrees rooted in u and
v, respectively, such that exactly the children A of u and B of v
are used in the local alignment. If no such alignment exists, we set
SL’W[A,B] =—oo. Then SL’WME] :0, but for all A,B;«éﬂ we have
SL’W[A, 0] < 0, SL’V[0,B] < 0. Clearly,

S(u,v)= max SL’N[A,B]. (5)
Agc(u),BgC(v) ’

We need one more trick in our recurrence: in (2) we have accessed
entries Sa,v[C(a),B’] and Su,b[A’ , C(b)], but this is not possible for
the table S ’ as the optimal alignments might not use all the children
of a or b. To this end, we introduce

S’ A,>l< :2 {S’ A,B’ },
u,v[ I Irma)?” u,v[ I
S, *,B := {S’ A',B },
u,v[ I Imagéu) u,v[ I

for the maximum over all subsets of C (v) or C (u), respectively. For
non-empty sets A g C (u) and B Q C (v) we set

SLIM, [A, B] =max{match;,’v[A,B],
deleteLim, [A, B] , deleteRi,’ v [A, B], (6)
joinLil’v[A,B],joinR;,’v[A,B]}

which, compared to (3), misses the lower bound 0 and uses the
deﬁnitions:

matchil’v[A,B]:= max {S(a,b)+

aeA,beB
s;,v[A—{a},B—{b}]+a(ua,vb)}

deleteLil’v[A,B] :=aer1n}a3xCB{Sc’l’v[*,B’]+

(7)
SL’W[A —{a},B—B’] +o(ua,—)}

deleteRim, [A, B] :=A, g4a§EB{S;’b [A], *]+

s;,v[A —A’,B—{b}]+o(—,vb)}

For the further join recurrences, we only concentrate on the left
tree. The deﬁnition of prejoinLil’v[A, *] and the JOIN recurrences at
the right tree are analogous.

re'oinL' A,B :2 max {S a,b+
p] u’v[ ] aeA,beB ( )

prejoinLil’v [A — {a}, B — {b}]+

0(P(u)a,vb)+0jom}

8
prejoinle’v [*,B] :=£ngx4{prej0inL;’v[A/,B]} ( )

joinLim,[A,B] :=a€1r1na3xCB{prejoinL;’v[*,B’]+

S;,v[A—{a},B—B’]}

To summarize, the central point is that we do not have to store
any entries with SL’W[A,B] 50: such entries will never lead to an
optimal alignment, as we are better off removing all nodes A,B,
plus everything below these nodes from the alignment. The only
exception to this rule is that we store the entry SL’WM, 0] :0.
Furthermore, we do not have to store entries Sim, [A, B] if there exist
subsets A’ EA, B’ EB with (A’,B’)7E(A,B) such that SL’W[A,B] 5
SL’W[A’,B’]. In this case, we can replace an alignment that uses
children A,B of u, v, by an alignment that uses only children A’ ,B’
and has better or equal score. We say that an entry SL’W[A,B] is
dominated by entry SL’W[A’ ,B’]. For a scoring scheme that assigns
negative scores for non-matching edge (or node) labels, large parts
of the tables have negative scores or are dominated by another entry.
We do not actually have to forbid that dominated entries are stored,
as they do not interfere with our computations; rather, we are free
to leave out dominated entries when we encounter them.

The resulting tables Sim, are sparsely populated, and for many
vertices u, v, there are no entries with SL’W [A,B] > 0. We can reduce
the memory consumption of the method using hash maps instead of
arrays. Hash map implementations like Cuckoo hashing (Pagh and
Rodler, 2004) or Hopscotch hashing (Herlihy et al., 2008) can carry
out all operations in constant (amortized) time. In practice, we ﬁnd
that memory consumption is usually not prohibitive. In this case, we
can use lazy arrays that are not allocated until a ﬁrst entry is stored.

Resolving the recurrences: Now, it is time for our ﬁnal trick:
instead of computing the scores using recurrence (6—8), we
apply a successive approximation procedure similar to Dijkstra’s
Algorithm for shortest paths (Sniedovich, 2006). That is, instead
of ‘pulling’ scores from previously calculated entries, we ‘push’
scores from entries that have been ﬁnalized. For example,
assume that we have ﬁnalized the computation of some entry
SL’W[A,B] for ﬁxed A§C(u) and B§C(v). Also assume that
SL’W[A,B] > 0 as otherwise, SL’W[A,B] is dominated by SL’WMﬂ] =
0. Then, recurrence (7) tells us that we can update other entries
of the table accordingly: if SL’V[A,B]>SL’,’V[*,B] (which we
assume to be incompletely calculated so far) then SL’V[*,B] <—
SL’W[A,B]. Similarly, if SL’V[A,B]>SL’,’V[A,*] then SL’W[A,*]<—
SL’W[A,B], and if SL’V[A,B]>S(u,v) then S(u,v)<—Sl’,’v[A,B].
Regarding the recurrence for match’, we iterate over all a e C (u) \A
and be C(v)\B: If matchil’v[AU{a},BU{b}] <S(a,b)+SL’,’v[A,B]+
o(ua,vb) then update it accordingly. If matchil’v[AU{a},BU{b}] 5

 

i269

112 Bio's112umofp101xo'sor112u1101uroIq/ﬁd11q 111011 papeolumoq

9IOZ ‘09 isnﬁnV uo ::

EHufsky et al.

 

matchil’v [A, B] then the entry matchil’v [A U {a}, B U {b}] is dominated
and we can remove it from the hash map.

For all other cases, similar updates can be performed, which
we only sketch here: For deleteL’ we iterate over all a e C (u)\
A and B’ §C(v)\B; if deleteLil’v[AU{a},BUB’] <Sc/l’v[*,B/]+
SL’V[A,B]+o(ua,—) then update it accordingly. Updates have to
be performed as soon as an entry is ﬁnalized, that is, it cannot
be changed by any future modiﬁcations. Finding ﬁnalized entries
is similar to the order of computations in the previous section; we
omit the technical details.

The above algorithm has exactly the same worst-case running time
complexity as the initial recurrence from Section 3. But in practice,
we can get even faster, at least in cases where the arrays are very
sparse: to this end, ﬁnalizing some entry deleteij,[A,B] triggers
updates for all subsets B’ Q C(v)\B. But only those B’ can lead to
relevant updates where S 6’”, [*, B’ ] > 0 holds. Otherwise, the updated
entry will be dominated by Sc’l’v [*, 0] = 0. If we iterate over the hash
map for those B’ with Sc/l’v[*,B/] >0 then the worst-case running

time increases to 0(4A -26 -8n1n2), assuming constant time access
to the hash map. However, in practice, running time decreases if the
DP tables are sparsely populated. We stress that the sparse DP still
guarantees to ﬁnd the optimal solution.

5 INTEGER LINEAR PROGRAMMING

ILPs are a classical approach for ﬁnding exact solutions of
computationally hard problems. We now present an ILP for
computing a pairwise unordered tree alignment. Again, let T1:
(V1,E1),T2 2 (V2, E2) be the input trees with V1 0 V2 2 0. As the ILP
is edge based, we have to introduce some additional notation: Let
e e E, i 6 {1,2}, be any edge in one of the two given trees. We denote
by D(e) the set of edges in the subtree rooted at the head of e, and by
N (e) :=E,- \ ({e} UD(e)) the non-descendant edges of e. For an edge
e, we deﬁne p(e) to be the parent edge, and p* (e) :2 {p(e),p(p(e)), ...}
all of its ancestor edges. Finally, .7: (e) :=D(p(e))ﬂN (e) is the
‘extended family’ of e, that is, all descendants of e’s parent edge,
except for e and its descendants.

We start with the ILP without considering the join operation
(ILP 1) and use the following binary variables: Iff an edge e’ e
(E1UE2) appears in the aligned subtree, we have zet = 1; iff this
edge is aligned to a gap, we have yet 2 1. Finally, iff an edge e 6E1
is aligned to an edge f e E2, we have x{ef} = 1. The constraints (10)
ensure for each edge that we decide whether this edge is used in the
alignment and if, how it is aligned. The inequalities (11) ensure that
the subgraphs of T1 (and T 2) are proper trees. Finally, (12) ensure
that the obtained alignments are consistent: assume an alignment
(e, f ) then we cannot also align a descendant of e with a non-
descendant of f and Vice versa. The conditional term following the
universal quantiﬁer simply avoids redundancy.

Based thereon, we can construct an ILP allowing join operations

(ILP 2). Therefore, we require additional binary variables xilev}
(with ie{1,2},eeEi,feE3_,-), which are 1 iff the joined edges
(p(e),e) are aligned with f. Technically, we also require “er} =
1 in such a case. Note that this amount of additional variables
is necessary to compose a linear objective function, when the
join costs cannot be computed only based on align— and gap
costs. Furthermore, we introduce binary variables (bet , e’ e (E 1 UE2),
which are 1 iff the edge e’ is used as a parent edge within

Table 1. The three datasets used in this study

 

 

Characteristics of the datasets Orbitrap MassB ank Hill

Number of compounds 97 370 102
Number of non-empty trees 93 343 102
Maximum out degree 7 6 10
Average/median out degreemax 3 2 5
Number of alignments 4278 58 653 5151

 

Fragmentation trees were computed for all compounds. Only non-empty trees were
considered for tree alignment. The maximum out degree of a single tree is denoted by
out degreemax. Number of alignments is given without self-alignments.

a join (e.g.,¢p(e)=1 if the former xgzﬂ variable is 1). We

use the shorthands a<1>(e, f) :=o(e +p(e), f)+ojoin—o(e, f) and
0(2)(e, f) :=o(e, f +p(f))+0'j0in —o(e, f) m the objective function.

Constraints (15)—(17) are analogous to the former ILP. While (18)
guarantees that joins are always separated from each other within
an input tree, (19) ensures that at most one joined alignment may
occur for any edge. Inequalities (20)—(22) make sure that a parent
edge e’ is only marked as a joined parent iff all its aligned children
are joined with e’ . Finally, (23) guarantees that we do not align two
joined edges with each other.

6 EXPERIMENTAL RESULTS

To evaluate our work, we used three different test datasets (Table 1).
The Orbitrap dataset (Rasche et al., 2012) contains 97 compounds,
measured on a Thermo Scientiﬁc Orbitrap XL instrument. The
MassBank dataset (Horai et al., 2010) consists of 370 compounds
measured on a Waters Q-Tof Premier spectrometer. The Hill dataset
consists of 102 compounds measured on a Micromass Q-Tof,
published by Hill et al. (2008). We omit the experimental details.
Fragmentation trees were computed using ILP as described in Rauf
et al. (2012). Self-alignments were excluded from the analysis.

For our evaluations, we use a scoring function very similar to
the one from (Rasche et al., 2012), evaluating pairs of losses and
pairs of fragments. For losses nl1, nl2, we distinguish between
size-dependent positive match scores o(nl,nl) :25 + number
of non-hydrogen atoms and size-dependent negative mismatch
scores o(nl1,nl2) :2 —5 number of diﬁ‘erent non-hydrogen atoms.
For fragments f1, f2, we use size-dependent positive match
scores o(f , f ) :25 + number of non-hydrogen atoms and size-
independent negative mismatch scores 00‘1,f2):= —3. We allow
insertion/deletions, as well as joining two subsequent losses, both
without penalty. The idea behind this ad hoc scoring is to reward
or penalize large losses stronger than small losses, whereas non-
matching fragments are penalized independent of size. See Rasche
et al. (2012) for details.

We implemented the DP algorithms in Java 1.6. For the sparse
DP, we used lazy arrays to store the DP tables. We solved the
ILP Via branch and cut using CPLEX 12.1 in its default settings.
Computation was done on two different but comparable computers,
namely on a quad-core 2.2 GHz AMD Opteron processor with 5 GB
of main memory for the DP algorithms, and on a quad-core Intel
Xeon E5520 with 2.27 GHz in 32—bit mode for the ILP, using 2 GB
RAM per job. For the DP algorithms, we repeated computations ﬁve
times, reporting the minimum running time for each instance.

 

i270

112 Bio's112umofp101xo'sor112u1101uroIq/ﬁd11q 111011 papeolumoq

9IOZ ‘09 isnﬁnV uo ::

Fast alignment of fragmentation trees

 

 

max 2 0(e,f)-x{e,f} + Z 0(6’,—)-ye/ + Z 0(—,e’)-ye/ (9)
eEEl’ e’EE1 e’EE2
feE2
s.t. ye+ Z x{ef}=ze Vie{1,2},eeE,- (10)
fGEa—i
zet+ze~51+ze Vie{1,2},eeE,-,e’ eD(e),e”e.7-"(e) (11)
x{ef}+x{etft}51 Vi€{1,2},e€Ei,f€E3_,-, (12)
e’€D(e),f'€N(f), [if i=2=f’ ¢p*(f)]
x{ef},Ye’,Ze’ €{0, 1} V6 6E1 ,f E1’32,e'€(E1UE2) (13)
ILP 1: The ILP for pairwise unordered tree alignment without join operations
max 2 (mime + Z a(i>(e,f)x§? 1}) + Z 0(6',-)ye' + Z 0(-,€')ye' (14)
eEE1’ ie{1,2} e’EE1 e’EE2
feE2
s.t. ye+¢e+ Z xw} =ze Vie{1,2},eeE,- (15)
fEV3—i
zet+zeu51+ze Vi€{1,2},e€E,-,e’€D(e),e”e.7:(e) (16)
x{ef}+x{et’ft} fl Vi€{1,2},e€Ei,f€E3_,-, (l7)
e’€D(e),f’€N(f), [if i=2=f’ ¢p*(f)]

¢e’ +¢e~ S 1 Ve’ E (E1 UEZ), e” =p(e’) (18)

1 2
x8]? +er’)f} gxw} Ve 6E1 , f 6E2 (19)
x{e,f}_xE:)’f}f1_¢e’ Vie{1,2},eeEt-,e’=p(e),f €E3—i (20)
yefl_¢e’ Vi€{1,2},e€Et,e’=p(e) (21)
xii}, 545a Vie{1,2},eeEt-,e’=p(e),f e V3—i (22)
xfzfmyt :1 Vie{1,2},eeEt-,f 6E3—1,f’=p(f) (23)
x{ef},ye',Ze’,xE:)f},¢e’ 610,1} Vie{1,2},eeEt,f E1’32,e'6(1’51U1’52) (24)

ILP 2: The ILP for pairwise unordered tree alignment including join operations

 

For the Orbitrap and the MassBank dataset, we found that for
over 98% of the instances, the running time was in the range of
microseconds for both DP algorithms. For these datasets, we only
evaluate total running times for all alignments. For MassBank,
the classical DP (Section 3) ﬁnished in 4.2s for an all—against—
all alignment of 343 trees, whereas sparse DP (Section 4) only
required 1.8 s. For Orbitrap, the classical DP ﬁnished in 5.4s for
the all-against—all alignment of 93 trees, whereas sparse DP required
0.6 s, a 9-fold speed-up. In contrast, the ILP needed 9.6 min for all
alignments in the MassBank datasets and 14.5 min for all alignments
in the Orbitrap dataset.

The Hill dataset contains trees with much higher maximum out
degree, so we performed a more detailed running time analysis.
Classical DP required 13.9 min and sparse DP ﬁnished in 1.3 min,
an 11-fold speed-up. Running times of the ILP could only be
measured without allowing join operations. For 1241 instances,
computations run into the memory limitation of 2 GB. For the

remaining alignments, the ILP ﬁnished in 11.24 h. Hence, we
excluded the ILP from our detailed analysis. To get an overview
of the differences in the running times between hard and easy
alignments, we sorted the instances by their running times in
increasing order. This was done separately for each algorithm. See
Figure 4 (top) and Table 2. For both algorithms, we found that the
99% fastest alignments need nearly as much computing time as the
remaining 1% slowest alignments. We further sorted all instances
by the running time of the classical DP (see again Figure 4). We
found that for every instance, sparse DP requires less time than the
classical DP.

7 CONCLUSION

Fragmentation trees are a tool to overcome the limitations of spectral
library search, as they, for the ﬁrst time, enable us to retrieve not
only exact hits, but also similar compounds from a spectral database.
But performing the workﬁows proposed by Rasche et al. (2012) on

 

i271

112 Bio's112umofp101xo'sor112u1101urorq”:d11q 111011 papeolumoq

9IOZ ‘09 isnﬁnV uo ::

EHufsky et al.

 

 

 

 

 

 

 

 

 

 

 

(a) dynamic programming
1000 __ ———— —- sparse dynamic programming
E 10 min
0
8
E 100‘:
a:
.E
on
.E
c
c
3
: 10-
S
.9
1
I I ' I I I ' I ' ' ' ' I
40 50 60 70 80 90 100
number of instances in %
 dynamic programming
40 — ———— —- sparse dynamic programming
30-
o _
a)
w
.E
CD _
E
=- 20 -
O? _
.E
c
c
E
10-
o _ ..................... t.EcxnrJVLLExlv~JicJLvi~w|\/
l.........l....l
200 150 100 50

200 slowest instances

Fig. 4. Running times for the Hill dataset with 5151 individual alignments.
(a) Total running times when instances are sorted by individual running
times. For any fraction x%, we calculate the total running time of the x%,
instances for which the alignment was computed faster than for any of the
remaining instances. For example at 50% one can ﬁnd the running time
that was needed to compute the 50% fastest instances. For each algorithm,
instances were sorted separately. Note the logarithmic y-axis. (b) Individual
running times for the 200 slowest instances of the classical DP algorithm.
Instances are sorted by their running time for the classical DP algorithm.
One can see that running times of the classical DP are outperformed by that
of the sparse DP

a large database requires tree alignments to be executed extremely
fast. In this article, we have presented three exact algorithms for
the alignment of fragmentation trees. We ﬁnd that the sparse DP
approach dominates the classical DP, resulting in an 11-fold speed-
up for one dataset. ILPs have an excellent record of providing fast
algorithms for NP—hard problems. Thus, it is rather unexpected
that, for the problem discussed here, the ILP is usually clearly
outperformed by both DP approaches; still, it has the potential to
solve those instances that are ‘hard’ for DP-based algorithms. Also,
in such cases we may use the ILP as a heuristic, solving only its LP
relaxation and applying some integer rounding algorithm, many of
which are standard in state-of—the—art ILP solvers.

Table 2. Running times for the Hill dataset

 

Algorithm All 90% fastest 99% fastest 1% slowest

 

DP 833.3 s 133.5 s (16.0%) 437.9 s (52.6%) 395.4 s (47.4%)
Sparse DP 75.3 s 13.9 s (18.5%) 33.9 s (45.0%) 41.4 s (55.0%)

 

Speed up 11-fold 10-fold 13-fold 10-fold

 

We report running times in seconds and as fractions of the total running time for all
instances (5151 alignments). We also report running time for the 90 and 99% fastest and
for the 1% slowest alignments. For both algorithms, instances were sorted separately.

When larger datasets become available, we expect the total
running time of an all—against—all alignment to increase more than
quadratic with dataset size: We have shown above that a large
fraction of the total running time stems from a few ‘hard’ alignments
which, in turn, correspond to a few trees in the dataset that are
large and, in particular, have high out degrees. We conjecture that
for larger datasets, the running time spent on computing the 99%
fastest alignments will be signiﬁcantly smaller than the running time
spent on the 1% slowest alignments. Here, even faster methods
for computing fragmentation tree alignments are sought. We will
evaluate whether our ILP is capable of solving these ‘hard’ instances
faster than a DP-based approach, as its running time is not directly
dependent on the out degree of the trees.

We have put particular focus on fragmentation trees that are hard
to align, namely large trees with high out degrees. Small trees with
low out degree seem to be less interesting since they often belong to
small compounds (<300 Da). Often, these compounds are ‘knowns’
(that is, reference measurements of the compound can be found
in a spectral library) and can be identiﬁed by spectral comparison.
Also, small fragmentation trees contain less information for, say,
classifying an unknown compound. Nevertheless, we believe that
we can also speed up alignments when one of the fragmentation trees
is relatively small: this may be achieved using some preprocessing
for small trees with, say, less than four losses.

We conjecture that running time of the DP (Theorems 1 and 2)
can be improved to 0(2‘11‘I'd2 -poly(d1,d2)n1n2) using the Mbbius
transform (ijrklund et al., 2007), but this appears to be of
theoretical interest only.

In our evaluations, we have used a scoring function similar to
the one by Rasche et al. (2012). Both scorings lack any statistical
explanation and should be reﬁned in the future using, say, log
odds scores. Also, the effect of merging two or possibly even
more nodes has to be investigated. Both questions were beyond
the scope of this work. Another interesting question is whether
polynomial—time methods for tree alignment of unordered trees, such
as the constrained tree edit distance (Zhang, 1996), can be used
for aligning fragmentation trees: whereas the restrictions imposed
by Zhang (1996) have no sensible interpretation in the context of
fragmentation trees, quality of results may still be sufﬁcient for
certain applications.

Aligning fragmentation trees allows for an automated
classiﬁcation of unknown compounds into compound classes.
Thus, large-scale compound screens can easily be searched for
compounds of interest. This may be useful in the search for signaling
molecules, biomarkers, or novel drugs and the identiﬁcation of
illegal drugs or toxins. In conjunction with other methods from

 

i272

112 Bio's112umofp101xo'soi112u1101uioIq/ﬁd11q 111011 papeoiumoq

9IOZ ‘09 isnﬁnV uo ::

Fast alignment of fragmentation trees

 

systems biology, the concept can help to identify new metabolic
pathways based on tandem MS experiments.

ACKNOWLEDGMENTS

We thank Ales Svatos (MP1 for Chemical Ecology, Jena, Germany),
Masanori Arita (University of Tokyo, Japan) and David Grant and
Dennis Hill (University of Connecticut, Storrs, USA) for providing
the MS datasets.

Funding: International Max Planck Research School Jena [stipend
to F.H.]; and the Carl-Zeiss-Foundation [to MC]

Conﬂict of Interets: Value of two patents may be affected by
publication (S.B., F.H. and FR).

REFERENCES

Arora,S. et al. (1998). Proof veriﬁcation and the hardness of approximation problems.
J. ACM, 45, 501—555.

Backofen,R. et al. (2011). Sparse RNA folding: time and space efﬁcient algorithms.
J. Discrete Algorithms, 9, 12—31.

Bj6rklund,A. et al. (2007). Fourier meets MObius: fast subset convolution. In
Proceedings of ACM Symposium on Theory of Computing (STOC 2007), ACM
Press, New York, pp. 67—74.

B6cker,S. and Rasche,F. (2008). Towards de novo identiﬁcation of metabolites by
analyzing tandem mass spectra. Bioinformatics, 24, 149—155. [Proceedings of
European Conference on Computational Biology (ECCB 2008)].

Canzar,S. et al. (2011). On tree-constrained matchings and generalizations.
In Proceedings of International Conference on Automata, Languages and
Programming (ICALP 2011), Springer, Berlin, Vol. 6755, pp. 98—109.

Cui,Q. et al. (2008). Metabolite identiﬁcation Via the Madison Metabolomics
Consortium Database. Nat. Biotechnol, 26, 162—164.

Fernie,A.R.et al. (2004). Metabolite proﬁling: from diagnostics to systems biology. Nat.
Rev. Mol. Cell Biol, 5, 763—769.

Fiehn,O. (2008). Extending the breadth of metabolite proﬁling by gas chromatography
coupled to mass spectrometry. Trends Analyt. Chem, 27, 261—269.

Halket,J.M. et al. (2005). Chemical derivatization and mass spectral libraries in
metabolic proﬁling by GC/MS and LC/MS/MS. J. Exp. Bot, 56, 219—243.

Herlihy,M. et al. (2008). Hopscotch hashing. In Proceedings of Symposium on
Distributed Computing (DISC 2008), Springer, Berlin, Vol. 5218, pp. 350—364.

Hill,D.W. et al. (2008). Mass spectral metabonomics beyond elemental formula:
chemical database querying by matching experimental with computational
fragmentation spectra. Anal. Chem, 80, 5574—5582.

Horai,H. et al. (2010). MassBank: a public repository for sharing mass spectral data for
life sciences. J. Mass Spectrom, 45, 703—714.

Jiang,T. et al. (1995). Alignment of trees: an alternative to tree edit. Theor Comput.
Sci., 143, 137—148.

Last,R.L. et al. (2007). Towards the plant metabolome and beyond. Nat. Rev. Mol. Cell
Biol, 8, 167—174.

Lederberg,J. (1965). Topological mapping of organic molecules. Proc. Natl. Acad. Sci.
USA, 53, 134—139.

Le,S.Y. et al. (1989). Tree graphs of RNA secondary structures and their comparisons.
Comput. Biomed. Res, 22, 461—473.

Li,J.W.-H. and Vederas, J .C. (2009). Drug discovery and natural products: end of an
era or an endless frontier? Science, 325, 161—165.

Ljubié,I. et al. (2005). Solving the prize-collecting steiner tree problem to optimality. In
Proceedings of Algorithm Engineering and Experiments (ALENEX 2005), SIAM,
pp. 68—76.

Neumann, S. and Bbcker, S. (2010). Computational mass spectrometry for
metabolomics — a review. Anal. Bioanal. Chem, 398, 2779—2788.

Oberacher,H. et al. (2009). On the inter-instrument and inter-laboratory transferability
of a tandem mass spectral reference library: 1. results of an Austrian multicenter
study. J. Mass Spectrom, 44, 485—493.

Pagh,R. and Rodler,F.F. (2004). Cuckoo hashing. J. Algorithms, 51, 122—144.

Rasche,F. et al. (2011). Computing fragmentation trees from tandem mass spectrometry
data. Anal. Chem, 83, 1243—1251.

Rasche,F. et al. (2012). Identifying the unknowns by aligning fragmentation trees. Anal.
Chem, 84, 3417—3426.

Rauf,I. et al. (2012). Finding maximum colorful subtrees in practice. In Proceedings of
Research in Computational Molecular Biology (RECOMB 2012). Springer, Berlin,
Vol. 7262, pp. 213—223.

Scheubert,K. et al. (2011). Computing fragmentation trees from metabolite multiple
mass spectrometry data. In Proceedings of Research in Computational Molecular
Biology (RECOMB 2011), Vol. 6577, pp. 377—391.

Schmidt,B.M. et al. (2007). Revisiting the ancient concept of botanical therapeutics.
Nat. Chem. Biol., 3, 360—366.

Sniedovich,M. (2006). Dijkstra’s algorithm revisited: the dynamic programming
connexion. Control Cybem., 35, 599—620.

Wemer,E. et al. (2008). Mass spectrometry for the identiﬁcation of the discriminating
signals from metabolomics: current status and future trends. J. Chromatogr. B, 871,
143—163.

Zhang,K. and Jiang,T. (1994). Some MAX SNP-hard results concerning unordered
labeled trees. Inf. Process. Lett, 49, 249—254.

Zhang,K. (1996). A constrained edit distance between unordered labeled trees.
Algorithmica, 15, 205—222.

 

i273

112 Bio's112umofp101xo'sor112u1101uroIq/ﬁd11q 111011 papeoiumoq

9IOZ ‘09 isnﬁnV uo ::

