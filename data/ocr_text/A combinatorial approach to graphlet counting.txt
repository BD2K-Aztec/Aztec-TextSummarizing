ORIGINAL PAPER

Vol. 30 no. 4 2014, pages 559—565
doi:10. 1093/bioinformatics/btt71 7

 

Data and text mining

Advance Access publication December 11, 2013

A combinatorial approach to graphlet counting

Tomai Hocevar" and Janez Demsar

Faculty of Computer and Information Science, University of Ljubljana, Sl—1000 Ljubljana, Slovenia

Associate Editor: Igor Jurisica

 

ABSTRACT

Motivation: Small-induced subgraphs called graphlets are emerging
as a possible tool for exploration of global and local structure of net-
works and for analysis of roles of individual nodes. One of the obs-
tacles to their wider use is the computational complexity of algorithms
for their discovery and counting.

Results: We propose a new combinatorial method for counting graph-
lets and orbit signatures of network nodes. The algorithm builds a
system of equations that connect counts of orbits from graphlets
with up to five nodes, which allows to compute all orbit counts by
enumerating just a single one. This reduces its practical time complex-
ity in sparse graphs by an order of magnitude as compared with the
existing pure enumeration-based algorithms.

Availability and implementation: Source code is available freely at
http://www.biolab.si/supp/orca/orca.html.

Contact: tomaz.hocevar@fri.uni-lj.si

Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on August 30, 2013; revised on November 29, 2013;
accepted on December 6, 2013

1 INTRODUCTION

Following the advent of high-throughput methods more than a
decade ago, analysis of complex network data has assumed the
central role among computational methods in bioinformatics.
The huge size of such networks on one hand and the computa-
tional intractability of the related methods on the other have
spawned a number of innovative analytic approaches.

Priulj et al. (2004) described an approach focused on small
induced subgraphs called graphlets. Owing to combinatorial ex-
plosion, such analysis is usually limited to the 30 graphlets with
2—5 nodes (Fig. l). The number of appearances of graphlets in
the network provides a description of the network’s structural
properties. On a local level, counting how many times a particu-
lar node participates in each kind of graphlet induced in the
network gives a topological signature of the node’s neighbour-
hood represented as a 30-dimensional vector.

For a ﬁner description, the nodes of every graphlet are parti-
tioned into a set of automorphism groups called orbits (PrZulj,
2007). Two nodes belong to the same orbit if they map to each
other in some isomorphic projection of the graphlet onto itself.
Nodes of graphlets on 2—5 points are grouped into 73 orbits
shown by numbers and node colors in Figure 1. For instance,
the ﬁve nodes from G14 belong to three different orbits, marked
with different colors and numbers; the black (as well as the grey)

 

*To whom correspondence should be addressed.

nodes have symmetric positions in the graphlet and thus belong
to the same orbit (31 for the black, 32 for the grey), and the white
node belongs to the orbit 33. By counting the number of times a
node of a graph appears in each orbit, the node can be described
by a 73-dimensional vector of orbit counts, which reﬂects its
position with respect to the local structure and gives insight
into its role in the network.

Existing methods for counting the graphlets and orbits are
based on direct enumeration: to count them, they need to ﬁnd
all their embeddings in the network. We propose a new method,
Orbit Counting Algorithm (Orca), which reduces the time com-
plexity by an order of magnitude by computing the orbit counts
using the relations between them and directly enumerating only
smaller graphlets.

1.1 Motivation

Graphlets are used for different kinds of analyses in bioinfor-
matics. Milenkovié and PrZulj (2008) designed a method for
comparing node neighbourhoods based on graphlets and demon-
strated that clusters of nodes in protein—protein interaction (PPI)
networks, obtained with their graphlet-based distance measure,
share common protein properties. They showed how to use this
approach to predict functions of proteins and their memberships
in protein complexes, subcellular compartments and tissue ex-
pressions. Milenkovié et al. (2010b) studied the relation between
cancer genes and their network topology. They examined several
clustering methods based on a graphlet similarity measure and
found a difference between the PPI network structure around the
cancer and non-cancer genes. Around 80% of the predicted
cancer gene candidates have been validated in the literature.
Similarly, cost functions for network alignment that are based
on graphlet degree vectors show superior results in comparison
with other state-of-the-art methods. In particular, Milenkovié
et al. (2013) showed how alignment between the PPI networks
of Saccharomyces cerevisiae, Drosophila melanogaster and
Caenorhabditis elegans with the human PPI network can be
used for identiﬁcation of genes related to aging, which are difﬁ-
cult to observe directly for humans due to our long lifespans.
Milenkovié et al. (2011) also applied graphlets to estimate node’s
topological centrality. Their graphlet degree centrality measure is
based on graphlet degree vectors and captures density and com-
plexity of a node’s extended neighbourhood. They showed that
the genes participating in key biological processes also reside in
complex and dense parts of networks.

Hayes et al. (2013) argue that to understand the biological
networks, we need to ﬁnd the mathematical models describing
their structure, even though this may not be of direct predictive
use. Priulj et al. (2004) used graphlet distributions to show that

 

© The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e—mail: journals.permissions@oup.com 559

112 [glO'SIBIIan[p.IOJXO'SODBIIIlOJIItOTQ/ﬂ(11111 IIIOJJ pepnolumoq

910K ‘09 lsnﬁnV no :2

T.Hoéevar and J.Dems'ar

 

4
5

G

t
N

Graphlet on
two nodes
H
aphlets on
ee nodes
Graphlets on
four nodes

Q
Q
Q

0

15
16 18
17 20
21
19
09 G

10 11

Graphlets on ﬁve nodes

6 8 9 13 14
7 1:1 11 12
1o l<  >'
3 G4 G5 G6 G7 G8
46
25 27 36 41 o
22 32 34 43 48
26 28
23 3o 33 33 42 44 47
29
24 31 35 39 45
G G12 G G14 G G G18 G

13 15 G16 17 19
56 67 65
52 55 58 . . 63 68 71 72
49 53 063 v v
57 . . .
50 5 1 54 59 60 66 ‘ 70
G20 G21 622 623 624 625 G26 627 628 629

Fig. 1. Graphlets with 2—5 nodes and automorphism orbits. Notation follows (Przulj, 2007). Colors are chosen arbitrarily; nodes of the same color
belong to the same orbit within that graphlet, e.g. both black nodes in G14 belong to orbit 31

geometric graphs match the structure of PPI networks better
than Erdc’Ss—Rényi and scale-free graph models. Using a
number of large PPI networks, Hayes et al. (2013) further
showed that although the network structure may be unstable
in regions with low edge-density, high-density regions are suit-
able for network comparison using graphlet degree distributions.

Graphlets can also assist in other analytic methods, such
as global network alignment. GRAph ALigner (GRAAL)
(Kuchaiev et al., 2010) is an algorithm for aligning arbitrary
networks based solely on their topology, which uses a local top-
ology similarity measure based on graphlet degree vectors. The
technique was used to show the large amount of shared network
topology between yeast and human PPI networks, which can be
used to predict biological functions of aligned proteins or recon-
struct phylogenetic trees. H-GRAAL (Milenkovié et al., 2010a)
aligns networks by reducing the problem to a weighted bipartite
matching that can be solved with Hungarian algorithm. Finally,
MI—GRAAL (Kuchaiev and PrZulj, 2011) integrates multiple
sources of node similarity information, including the graphlet
degree vectors.

Solava et al. (2012) extended the use of graphlets by deﬁning
the orbits for graphlet edges and demonstrated their use with a
new clustering method that is not limited to locally similar edges
and allows some overlap between clusters. As a practical result,
they predicted new pathogen-interacting proteins from clusters in
the human PPI network that represent drug target candidates.

Therefore, graphlet analysis is a useful tool for bioinformatics,
and with the increase of available data there is also a growing
need for fast graphlet counting tools.

1.2 Related work

We will denote the explored graph as G = (V, E). Let = |V| and
e = |E| be the number of vertices and edges, and let d denote the
maximal node degree. Let N(u) denote the set of vertices adjacent
to vertex u. In numbering the graphlets and orbits, we follow
PrZulj (2007); we refer to the j-th graphlet and i-th orbit by G]-
and 0,, respectively.

Counting subgraphs is a computationally intensive task.
Common approaches to speed it up include sampling (Kashtan
et al., 2004; PrZulj et al., 2006; Wernicke, 2006), exploiting pat-
tern symmetries (Stoica and Prieur, 2009) or using reconﬁgurable
hardware accelerators based on F ield-Programmable Gate Array
(FPGA) chips (Betkaoui et al., 2011).

The method described in this article is related to the approach
developed by Kloks et al. (2000), who constructed a system of
equations that allows computing the number of occurrences of
all six induced four-node subgraphs by knowing the count of any
of them. The time complexity of setting up the system equals the
time complexity of multiplying two square matrices of size n. We
extend this approach to counting how many times each node
participates in each orbit. Our method also works on ﬁve-node
graphlets and scales better on sparse graphs. Kowaluk et al.
(2011) generalized the result by Kloks et al. (2000) to count
subgraph patterns of arbitrary size.

There are several programs for graphlet counting and motif
detection that are used in bioinformatics. Fast Network Motif
Detection (FANMOD) WVemicke and Rasche, 2006) is a network
motif detection tool based on sampling random subgraphs and
comparing their counts with those from random network models.
Besides implementing a novel sampling algorithm Wernicke,
2006), it also provides a full enumeration procedure for graphlets
on 2—8 nodes. Whelan and Sénmez (2012) developed
GraphletCounter, which works as a Cytoscape plugin and
merges graphlet analysis with visual inspection of the network.

GraphCrunch (Milenkovié et al., 2008) is a tool for large net-
work analysis. It includes a function for computing orbit signa-
tures of every graph node for graphlets of up to ﬁve nodes using
an enumeration procedure with correction for over-counting
some of the graphlets. A well-organized enumeration method
imposes constraints that eliminate the need for isomorphism test-
ing except for distinguishing between a few different graphlets;
this is further accelerated by comparing the number of edges and
individual node degrees. GraphCrunch has been extended with
a new method for topological network alignment and with

 

560

112 [glO'SIBILInO[p.IOJXO'SODBIIIlOJIITOTQ/ﬂ(11111 IIIOJJ pepnolumoq

910K ‘09 lsnﬁnV no :2

Graphlet counting

 

comparison of the networks with some additional mathematical
models (Kuchaiev et al., 2011). The graphlet counting procedure
in the new version remained essentially the same.

Rapid graphlet enumerator (RAGE) (Marcus and Shavitt,
2012) takes a different approach to counting four-node graph-
lets. Instead of counting the induced subgraphs directly, it recon-
structs them from counts of non-induced subgraphs. For
computing the latter, it uses speciﬁcally crafted methods for
each of the six possible subgraphs (G3 to G8 in Fig. 1). The
time complexity of counting non-induced cycles and complete
graphs is 0(e - d + e2), whereas counting other subgraphs re-
quires 0(e - d). Another bound, which is also more suitable for
comparison with our method, is 0(e - d2) = 0(n - a“). Unlike
FANMOD and GraphCrunch, RAGE works only for up to
four-node graphlets.

2 METHODS

Let x represent a certain node of interest in graph G. Our task is to
compute the number of times, 0,, that x appears in each orbit 0,- across
all graphlets induced in G. We will present an approach based on a system
of linear equations that relate the orbit counts 0,. The rank of the system
is smaller than the number of orbits by one, so we can compute all values
of 07 from directly enumerating only a single one. The algorithm allows to
compute the orbits for all points x in a graph in time that is smaller than
the existing direct enumeration approaches by an order of magnitude.

We will ﬁrst show how to construct a system of equations for four-
node graphlets. As for the single orbit that must be enumerated, we chose
014, which represents nodes of the complete graph, [(4 (or G8); we show
an efﬁcient way to enumerate it. The approach used for four-node graph-
lets is less suitable for larger graphlets, so we present a different technique
for ﬁve-node graphlets.

2.1 Orbits in four-node graphlets

Right sides of equations we are about to construct contain terms that are
computed from the graph G. Let c(u, v) = |N(u) ﬂ N(v)| denote the
number of common neighbours of nodes u and v. Let p(u, v) denote the
number of paths on three nodes that start at node u, continue with v and
end with some node t, which is not connected to u. We can compute
p(u, v) as p(u, v) = deg(v) — 1 — c(u, v).

If some node x participates in a k—node graphlet G,-, it also participates
in some (k — 1)-node graphlet Gj. This can be seen by removing one of
the graphlet’s nodes that are the farthest away from x. The subgraph
induced by the remaining nodes is connected (any disconnected node
would have to be farther from x than the removed node), so it is iso-
morphic to some (k — 1)-node graphlet Gj.

We will use this observation in reverse: every four-node graphlet can be
constructed by adding a node to some three-node graphlets. To ﬁnd the
relations between counts of orbits in four-node graphlets for a certain
node x, we enumerate all three-node graphlets touching the node and
count their possible extensions with the fourth node.

An example is shown in Figure 2. Nodes x, y and Z induce graphlet G1,
a path on three nodes; we will observe its extensions to four-node graph-
lets with the fourth node, w, connected to y and Z (dashed lines). The
number of such nodes w is c(y,z). In our example, there are c(y,z) = 3
such nodes, which we marked by w, w and W3 (Fig. 2a). The edge (x, w)
might exist in the graph G (as in the case of W3, the dotted line) or not (as
for WI and w). With no edge, nodes x, y, Z and w form a paw (G6) with x
in orbit 09 (Fig. 2b). With an edge between x and w, they form a dia-
mond (G7) with x in orbit 012 (Fig. 20). Because all c(y,z) nodes in
N(y) (1 N(2) must participate either in G6 or G7, which puts x in 09 or
012, this gives 09 + 012 = c(y, z) for the particular triplet x, y and z.

(a) wlqzzk (b) wq\ (c)

 \‘~ \ 10 12

w2  Z \\\ \ Z ’I Z
:j*~’:<\ \\ 13 /”/

{V3 01'” ---- —:\ y 11“ y w G: --- ——l§ y

N )nN(z)  
(y 9 x 12 x

c(y, z) = 3
G6 G7

Fig. 2. Relation between orbits 09 and 012. Solid lines are edges in the
three-node graphlet being extended. Dashed lines exist by deﬁnition: w
(or w,) are the common neighbours of y and z. Dotted lines are optional
edges that make the resulting four-node graphlet on x, y, Z and w, iso-
morphic to G6 or G7

We sum this over all possible three-node paths starting at x.
Summation must account for symmetries: each graphlet G6 appearing
in the graph is counted twice with roles of Z and w reversed, and G7 is
counted twice with reversed roles of y and w. Accounting for this, we get

209 + 2012 = Z C(yaz)

y, z: x, zeN(y)

G[{x, y, 2}]EG1
where g denotes graph isomorphism (e.g. G[{x, y, 2}], a subgraph on
nodes x, y and z is isomorphic to G1, a path with three nodes).

For a different example, we will relate orbits 06 and 09. We will extend

a path on nodes x, y and z with another path that starts with nodes x and
y; we denoted the number of such paths by p(x, y) (Fig. 3a). Depending
on whether the new node is adjacent to z, the extended graphlet is either a
claw (G4, Fig. 3b) or a paw (G6, Fig. 30). After accounting for symmetries
and subtracting 1, as p(x, y) also covers the case when w = 2, we get

Z @041») — 1)
y, z: x, zeN(y)
G[{xs ya 2}]EG1

206 + 209 2

There are only two three-node graphlets and relatively few possible
extensions. Investigating all possibilities in a similar manner yields 10
linearly independent equations with 11 variables that correspond to
counts of 11 orbits in four-node graphlets (see the Supplementary
Material).

Right sides depend on the graph G and need to be computed for each
point x. To accelerate their computation, we precompute values of c(u, v)
and p(u, v). In all equations, except for the last one, c(u, v) is computed on
pairs of nodes (u, v) that are connected; in p(u, v), they are connected by
the deﬁnition of 1). Therefore, it sufﬁces to precompute c(u, v) and p(u, v)
only for all pairs of connected nodes u and v, which requires 0(e) space.
The last equation, in which the new node closes a cycle, is treated separ-
ately. Nodes x and Z are not adjacent but we can precompute the number
of paths of length 2 that start at node x and end at node y. This requires
0(n) space for each point; because we compute orbits for one point at a
time, this memory can be recycled. Altogether, all lookups in the sums on
the right sides can be done in constant time by sacriﬁcing the memory of
size 0(e + n) for precomputed values c(x, y) and p(x, y).

The total time complexity for computing all orbits for all nodes is
0(e - d + T4), where 0(T 4) is the time needed to enumerate complete
graphlets on four nodes. Later in the text, we describe an algorithm
that does this in 0(n - d3), yet the actual importance of this term depends
on the structure and density of the graph.

2.2 Counting complete graphlets

For every node, we still have to determine the count of one of the 11
orbits. Because graphs are usually sparse, a good candidate is the rare
orbit 14, which represents the nodes of the complete graphlet on four

 

561

112 [glO'SIBILInO[p.IOJXO'SODBIIIlOJIIIOIQ/ﬂ(11111 11101; pepnolumoq

910K ‘09 lsnﬁnV no 22

T.Hoéevar and J.Dems'ar

 

(a)  (b) (c)
1‘, 10 10
W2  _  z 6 Z w  .... . . Z
W3 :\\ W 6O“~~~ \\\\\
W4 0 _______ __ y 7 y 11 y
p(x, y) - 1 = 4 x 6 x 9 x
G G

Fig. 3. Relation between orbits 06 and 09. Edges are marked like in
Figure 2

nodes G8. Because of few occurrences of this graphlet and its symmetri-
city, we can efﬁciently restrict the enumeration.

A straightforward way to count the complete graphlets of size four
that touch a given node x1 is to start with that node and in every step add
a neighbour x, of the last added node xi_1, while checking that the new
node is also connected to all nodes before xi, Xj< ,-_1. In this way, when we
add x4 as a neighbour of x3 we have to check whether it is connected to x1
and x2 (dotted lines in Fig. 4a), which is unlikely, especially in sparse
graphs.

A better strategy is to ﬁnd the common neighbours of x1 and x2,
N(xl) ﬂ N(xz), which can be done in 0(d). We then choose pairs
(x3,x4) from this set and check whether they are connected (Fig. 4b).
Candidates generated in this way have to satisfy only one additional
condition, as opposed to two in the straightforward approach.

To avoid counting the same graphlet multiple times, we request that
x2 <x3 <x4 under some ﬁxed arbitrary ordering of nodes. Although the
theoretical time complexity for ﬁnding all G8 that touch x using this
algorithm is the same for both approaches, 0(d3), the latter is much
faster on sparse graphs.

This method can be generalized for efficient counting of larger com-
plete graphlets in sparse graphs. In every step, we maintain a list of can-
didate nodes C,- for x,- that are adjacent to all previously added nodes. We
select one of these candidates and form a new candidate set C,-+1 consist-
ing only of nodes in C,- that are adjacent to the selected node,
C,-+1 = C,- O N(xi) and C1 = V. The time complexity of ﬁnding all com-
plete k-node graphlets that touch x using this algorithm is 0(dk‘1). Later
in the text, we use such procedure to enumerate complete subgraphs on
ﬁve nodes.

2.3 Orbits 0n ﬁve-node graphlets

For counting four-node graphlets, we constructed a list of equations by
adding nodes to three-node graphlets and observing the resulting four-
node graphlets. Extending the four-node graphlets to ﬁve-node graphlets
would yield a huge number of equations that are not linearly independ-
ent. We will use a different approach: for each orbit, we choose some
node y from the corresponding graphlet and observe the graphlets and
orbits in which the node of interest, x, appears if we add edges between y
and other nodes in the graphlet.

Let x be the node of interest, let y be the node whose edges we observe
and let x1, x2 and x3 be the other three nodes in that graphlet.

Figure 5 illustrates counting of appearances of x in 059, which belongs
to G24 (Fig. 5a). We will focus on the node marked by y, which is con-
nected to the nodes marked by x1 and x3. Removing y reduces G24 into a
diamond, G7, with x in orbit 012.

Now assume that we are computing orbits for a certain node x and
discover some induced subgraph H g G7 with x in 012. We assign labels
x1, x2 and x3 to the remaining nodes as shown in the ﬁgure. Altogether,
the graph G contains c(xl, x3) common neighbours of x1 and x3 (similar
to nodes marked with w in Fig. 3a). Although all these nodes are—by
deﬁnition of c(xl, X3)—connected to x1 and 263, some are also connected

(a) (b) N(x1)Q.]Y§Z€2.?. ............... ..
x7": ----------- u” x3 {‘"354 Q; --------------  
'-  ” ' """"""" "‘43: ................. 4,5341 ......... --
'. ‘. ,I’ ll 1‘ ~\\ ’/ I
'. .3. 1’ I, “ x I I
'_ I". I 1 X I
 1”, a I “ 1”, x ‘\ ll
xld ------ "ex. x; ------ "7.962

Fig. 4. Enumerating G8 by adding one neighbour at a time or by check-
ing pairs of neighbours. Dashed edges are added by iterating through
neighbours, and dotted edges are checked in the last step

   

(a) (c) (d)
y O\ y,O\
1 \ x3  1 \ x3
x1  x1
x2  x2
x 59 x 68
G24 G26 G27 GZS

Fig. 5. Computing orbit count 059; ﬁgures show graphlets for different
edges between y and other nodes and the orbits of x

to x2 or x, or both. Figure 5 shows all four possibilities, which give
graphlets G24, G26, G27 and G28 with x in orbits 59, 65, 68 and 70, re-
spectively. Therefore, 0’59 + 0’65 + 0’68 + 0’70 2 c(xl, x3) — 1, where 0;-
denote orbits of x with respect to H.

For the relation between 059, 065, 068 and 070 for the entire graph, we
sum this over all possible induced G7 with x in 012. After considering the
symmetries that cause counting the same graphlet multiple times with
different assignments of y, x1, x2 and 263, we get

059 + 4065 + 2068 + 6070 = Z
x1,x2,x3:
x1 <x2/\X3¢N(x)a
G[{x, x1, x2, x3}]EG7

C(x1,x3) + c(xz,x3) - 2

Condition x1 <x2 (under some arbitrary ordering of nodes) is needed to
consider each graphlet G7 just once. The other two conditions put x in
012. The second term in the sum, c(xz, x3), accounts for the case in which
the roles of x1 and x2 are exchanged.

Using a similar construction for other orbits, except for 072, gives 57
linear equations for 58 orbits (see the Supplementary Material). Like for
four-node graphlets, we directly enumerate the orbit 072, which belongs
to the complete graphlet. Equations are linearly independent due to the
way in which they were constructed: each equation is set up with one
orbit in mind (e.g. 059 in the aforementioned example), and the other
orbits that appear in the equation belong to graphlets with a larger
number of edges (the additional edges between y and the other nodes,
like the dotted edges in Fig. 5b—d). Additional nice consequence besides
independence is that the system is easy to solve, as orbit counts can be
computed from those belonging to graphlets with more edges towards
those with less.

When constructing the equations, we choose y that allows for efﬁcient
computation of the right sides: we will ensure that the right sides contain
only the node degrees and the numbers of common neighbours of pairs
and of connected triplets [c(u, v), c(u, v, t)]. This will allow us to precom-
pute and store the values of c(u, v) and c(u, v, t) for all pairs and con-
nected triplets in G before computing the orbit counts for individual
nodes.

First, we choose the node y so that the remaining nodes constitute
a four-node graphlet, i.e. removing y does not break the graphlet
into disconnected components, which would require enumeration of
disconnected subgraphs. Second, the node y has to have at most three
connections to avoid the need to compute the number of common

 

562

112 /810's112umofpinXO'soi112u1101utoiq//2d11q 111011 pepnolumoq

910K ‘09 lsnﬁnV no 22

Graphlet counting

 

neighbours of four points, c(u, v, w, t). Besides, when y has three neigh-
bours, they need to be connected.

A node y that fulﬁls these criteria exists for all orbits except 072.
Precomputing the values c(u, v, t) for all connected triplets takes
0(e - all) time, and storing them in a hash table takes 0(e - d) space.
Computation of the right sides also requires enumerating all the four-
nodes graphlets, which again has a complexity of 0(e - d2).

The total time required to compute all orbit counts for all x e V is then
0(e - 612 + T5) with 0(e - d) space, where 0(T 5) is the time required to
enumerate all complete ﬁve-node graphlets (G29). The algorithm thus has
the same upper bound complexity as the existing algorithms, 0(n - d4).
However, experiments show that the bound is not tight: the contribution
of the 0(T 5) is negligible over the range of sensible graph densities, and
the actual running times are smaller by an order of magnitude.

We could use the same technique to construct systems of equations for
larger graphlets. However, we reduced the running times by imposing
some conditions to the selection of the node y. We have not researched
whether such nodes also exist for larger graphlets; although theoretically
interesting, this may be of little practical use in the context of
bioinformatics.

3 RESULTS AND DISCUSSION

We compared the speed of Orca with RAGE, GraphCrunch and
FANMOD. We ran all experiments on a modest desktop com-
puter (Intel Core 2, 2.67GHz). We have not experimented with
parallel execution; all four algorithms allow for trivial distribu-
tion of work on multiple cores, so the beneﬁts of parallelization
should be the same for all.

We compared the performance of methods on the three largest
species-speciﬁc PPI networks from the July 2013 update of the
Database of Interacting Proteins (Salwinski et al., 2004) and the
human PPI network from the BioGRID (Chatr-Aryamontri

Table 1. Statistics of benchmark real-world networks

 

 

Network Nodes Edges Maximum
degree

S. cerevisiae 5097 22 282 289

Escherichia coli 2984 11 626 178

D.melan0gaster 761 8 22 864 178

Human 18170 137 775 9716

Internet autonomous systems 25 368 75 004 3781

 

Table 2. Comparison of algorithms on real-world networks

et al., 2013) 3.2.104 release. The sizes of individual datasets are
presented in Table 1.

All algorithms except the signiﬁcantly slower FANMOD
counted orbits for four-node graphlets in the smaller graphs in
a few seconds (Table 2). Five-node graphlets present a more
difﬁcult task: running GraphCrunch on the S.cerevisiae PPI
network took >9 min (as compared with 4.4s for four-node
graphlets). FANMOD was almost 10 times slower, whereas
Orca ﬁnished the same task 80 times faster, in 6.6 s. RAGE is
limited to four-node graphlets. We got similar results for the
other two networks.

In the larger human network, Orca counted the four-node
graphlets 100 and 1800 times faster than Rage and
GraphCrunch, respectively; we aborted FANMOD after 24 h.
Orca was also the only algorithm capable of counting ﬁve-
node graphlets in a human PPI network in less than a day.

For comparison with RAGE, we included a test network of
Internet autonomous systems (http://www.netdimes.org/
PublicData/csv/ASEdges4_20l2.csv.gz) that was used as the
benchmark for RAGE (Marcus and Shavitt, 2012). FANMOD
required >9 h, GraphCrunch ﬁnished in 37 min, RAGE in 3 min
and Orca in 2.5 s. Orca ﬁnished the computation for ﬁve-node
graphlets in 49 min, whereas the other two algorithms were
stopped after 24 h.

The time that Orca needs for counting orbits in ﬁve-node
graphlets is comparable with those that GraphCrunch needs
for four-node graphlets. This is consistent with the way the
two algorithms are constructed: GraphCrunch enumerates
four-node graphlets to count them, whereas Orca enumerates
them to count ﬁve-node graphlets. As expected, the time
needed for enumeration of complete ﬁve-node graphlets is neg-
ligible at these network densities.

For more insight into time complexities of the compared al-
gorithms, we tested them on synthetic data using three different
random network models—Erdds—Rényi, geometric and
Barabasi—Albert, random graphs. Erdds—Rényi graphs are con-
structed by randomly connecting e pairs of nodes. We generated
geometric graphs by randomly placing nodes in a 3D unit cube
and connecting the e closest pairs; geometric graphs show largest
resemblance to protein interaction networks (PrZulj et al., 2004).
Barabasi—Albert preferential attachment model generates scale--
free networks that exhibit hubs and individual highly connected
nodes.

 

 

 

 

Network Four-node graphlets Five-node graphlets

FANMOD GraphCrunch RAGE Orca FANMOD GraphCrunch Orca
S.cerevisiae 62 s 4.4 s 1.7 8 <0.1 s 87 min 9.5 min 6.6 s
E.coli 34s 1.8s 1.0s <0.1s 38min 4.1 min 4.8s
D.melan0gaster 21 s 3.1 s 1.6 8 <0.1 s 18 min 2.8 min 2.3 8
Human / 183 min 11.8 min 6.1 s / / 269 min
Internet autonomous systems 574 min 37 min 3.0 min 2.5 s / / 49 min

 

Note: We aborted the algorithms that took more than a day and marked the corresponding results with /.

 

563

112 /810's112umofpinXO'soi112u1101utoiq//2d11q 111011 pepeolumoq

910K ‘09 lsnﬁnV no 22

T.Hoéevar and J.Dems'ar

 

Erdés—Rényi

Geometric

time [seconds]

0 100 200 0 100 200

edges [thousands]

 

edges [thousands]

Barabasi-Albert

 

0  - -- GraphCrunch
0 100 200 _ EI_ RAGE
edges [thousands] —e— Orca

Fig. 6. Comparison of times needed for counting orbits in four-node graphlets in random networks. Graphs are cut off at one minute; results of
experiments in which the methods were allowed to run for up to 1h are available in the Supplementary Material

Erdéis—Rényi

Geometric

G
O

60

,1;
O

40

[\D
O

20

time [seconds]

 

O

X
10 20 30

10 20 30 40

edges [thousands]

    

edges [thousands]

Barabasi-Albert

 

0 10 20

---x - -- GraphCrunch

edges [thousands] —e— Orca

Fig. 7. Comparison of times needed for counting orbits in ﬁve-node graphlets in random networks

We explored the performance of GraphCrunch, RAGE and
Orca at different network densities. FANMOD was not included
as it consistently ﬁnished previous tests far behind
GraphCrunch. All graphs had 1000 nodes; for each method,
we increased the graph density until the method needed more
than a minute to complete the test. The corresponding graphs
were relatively dense, containing up to 40% of all possible edges
for test with four-node graphlets and ~10% for ﬁve-node
graphlets.

RAGE counted the four-node graphlets slightly faster than
GraphCrunch, but they were both signiﬁcantly outperformed
by Orca (Fig. 6 and Supplementary Tables Sl—S6). We observed
similar results when counting ﬁve-node graphlets (Fig. 7). Orca
achieved the highest gain in comparison with other methods on
Barabasi—Albert models, in which hubs present a large obstacle
for GraphCrunch and RAGE. This makes Orca more suitable
for real-world networks, which often display the small-world
property and contain hubs.

4 CONCLUSION

Graphlet-based network analysis is useful for various tasks in
bioinformatics, such as alignment of PPI networks and predic-
tion of protein functions based on topological similarities. Past
studies used these approaches to, for instance, identify genes
related to cancer (Milenkovié et al., 2010b) and aging
(Milenkovié et al., 2013).

We presented a new algorithm for counting graphlet orbits
that is based on derived relations between orbit counts. To
count the orbits for k—node graphlets, it enumerates (k — 1)-
node graphlets and a single k—node graphlet. Empirical results
conﬁrm that this decreases the time complexity by an order of
magnitude in comparison with other known methods. In

practical terms, the algorithm counts orbits in large PPI net-
works 50—100 times faster than other state-of-the-art algorithms.

Funding: Slovenian Research Agency (P2—0209, J 2-5480).

Conflict of Interest: none declared.

REFERENCES

Betkaoui,B. et al. (2011) A framework for FPGA acceleration of large graph prob-
lems: graphlet counting case study. In: 2011 International Conference on Field-
Programmable Technology. IEEE, pp. 1—8.

Chatr-Aryamontri,A. et al. (2013) The BioGRID interaction database: 2013 update.
Nucleic Acids Res, 41, D816—D823.

Hayes,W. et al. (2013) Graphlet-based measures are suitable for biological network
comparison. Bioinformatics (Oxford, England), 29, 483—491.

Kashtan,N. et al. (2004) Efﬁcient sampling algorithm for estimating subgraph con-
centrations and detecting network motifs. Bioinformatics, 20, 1746—1758.

Kloks,T. et al. (2000) Finding and counting small induced subgraphs efﬁciently. Inf.
Process. Lett., 74, 115—121.

Kowaluk,M. et al. (2011) Counting and detecting small subgraphs via equations
and matrix multiplication. In: Proceedings of the T wenty-Second Annual ACM-
SIAM Symposium on Discrete Algorithms. pp. 1468—1476.

Kuchaiev,0. and Przulj,N. (2011) Integrative network alignment reveals large re-
gions of global network similarity in yeast and human. Bioinformatics (Oxford,
England), 27, 1390—1396.

Kuchaiev,0. et al. (2010) Topological network alignment uncovers biological func-
tion and phylogeny. J. R. Soc. Interface, 7, 1341—1354.

Kuchaiev,0. et al. (2011) GraphCrunch 2: software tool for network modeling,
alignment and clustering. BM C Bioinformatics, 12, 24.

Marcus,D. and Shavitt,Y. (2012) RAGE - a rapid graphlet enumerator for large
networks. Comput. Netw., 56, 810—819.

Milenkovié,T. and Przulj,N. (2008) Uncovering biological network function via
graphlet degree signatures. Cancer Inform., 6, 257—273.

Milenkovié,T. et al. (2008) GraphCrunch: a tool for large network analyses. BM C
Bioinformatics, 9, 70.

Milenkovié,T. et al. (2010a) Optimal network alignment with graphlet degree vec-
tors. Cancer Inform., 9, 121—137.

 

564

112 /810's112umofpinXO'sot112u1101utotq//2d11q 111011 pepeolumoq

910K ‘09 lsnﬁnV uo 22

Graphlet counting

 

Milenkovié,T. et al. (2010b) Systems-level cancer gene identiﬁcation from protein
interaction network topology applied to melanogenesis-related functional gen-
omics data. J. R. Soc., 7, 423—437.

Milenkovié,T. et al. (2011) Dominating biological networks. PLoS One, 6, e23016.

Milenkovié,T. et al. (2013) Global network alignment in the context of aging. In:
Proceedings of the International Conference on Bioinformatics, Computational
Biology and Biomedical Informatics. pp. 23—32.

Przulj,N. (2007) Biological network comparison using graphlet degree distribution.
Bioinformatics (Oxford, England), 23, e177—e183.

Przulj,N. et al. (2004) Modeling interactome: scale-free or geometric? Bioinformatics
(Oxford, England), 20, 3508—3515.

Przulj,N. et al. (2006) Efﬁcient estimation of graphlet frequency distributions in
protein-protein interaction networks. Bioinformatics (Oxford, England), 22,
974—980.

Salwinski,L. et al. (2004) The database of interacting proteins: 2004 update. Nucleic
Acids Res., 32, D449—D451.

Solava,R.W. et al. (2012) Graphlet-based edge clustering reveals pathogen-interact-
ing proteins. Bioinformatics (Oxford, England), 28, 1480—1486.

Stoica,A. and Prieur,C. (2009) Structure of neighborhoods in a large social network.
In: 2009 International Conference on Computational Science and Engineering.
IEEE, pp. 26—33.

Wernicke,S. (2006) Efﬁcient detection of network motifs. IEEE/A CM Trans.
Comput. Biol. Bioinform., 3, 347—359.

Wernicke,S. and Rasche,F. (2006) FANMOD: a tool for fast network motif detec-
tion. Bioinformatics (Oxford, England), 22, 1152—1153.

Whelan,C. and Sénmez,K. (2012) Computing graphlet signatures of network nodes
and motifs in Cytoscape with GraphletCounter. Bioinformatics (Oxford,
England), 28, 290—291.

 

565

112 /810's112umofpinXO'sot112u1101utotq//2d11q 111011 pepeolumoq

910K ‘09 lsnﬁnV uo 22

