ORIGINAL PAPER

Vol. 28 no. 21 2012, pages 2724—2731
doi: 10. 1093/bioinformatics/bts525

 

Genome analysis

Advance Access publication September 3, 2012

JEnsembl: a version-aware Java API to Ensembl data systems

Trevor Paterson* and Andy Law

Division of Genetics and Genomics, The Roslin Institute and Royal (Dick) School of Veterinary Studies, University of

Edinburgh, Easter Bush, Midlothian EH25 9R6, UK

Associate Editor: Alfonso Valencia

 

ABSTRACT

Motivation: The Ensembl Project provides release-speciﬁc Perl APls
for efficient high-level programmatic access to data stored in various
Ensembl database schema. Although Perl scripts are perfectly suited
for processing large volumes of text-based data, Perl is not ideal for
developing large-scale software applications nor embedding in graph-
ical interfaces. The provision of a novel Java API would facilitate
type-safe, modular, object-orientated development of new Bioinfor-
matics tools with which to access, analyse and visualize Ensembl
data.

Results: The JEnsembl APl implementation provides basic data re-
trieval and manipulation functionality from the Core, Compara and
Variation databases for all species in Ensembl and EnsemblGenomes
and is a platform for the development of a richer API to Ensembl
datasources. The JEnsembl architecture uses a text-based configur-
ation module to provide evolving, versioned mappings from database
schema to code objects. A single installation of the JEnsembl APl can
therefore simultaneously and transparently connect to current and
previous database instances (such as those in the public archive)
thus facilitating better analysis repeatability and allowing ‘through
time’ comparative analyses to be performed.

Availability: Project development, released code libraries, Maven
repository and documentation are hosted at SourceForge (http:/fjen
sembl.sourceforge.net).

Contact: jensembl-develop@lists.sf.net, andy.law@roslin.ed.ac.uk,
trevor.paterson@roslin.ed.ac.uk

Received on June 12, 2012; revised on August 16, 2012; accepted on
August 20, 2012

1 INTRODUCTION

The Ensembl Project provides a genome information system for
the annotation, analysis and display of genome assembly data
pertaining to vertebrates [ENSEMBL (http://www.ensembl.org)]
and for other taxonomic groups [ENSEMBLGENOMES
(http://www.ensemblgenomes.org)]. Together with core genomic
annotations, the curated resources now include comparative gen-
omic, variation, functional genomic and regulatory data stored
in separate but linked database schemas (Flicek et al., 2010).
Access to data in Ensembl databases is freely provided
through Ensembl’s interactive web browser, the BioMart data
mining tool (http://www.ensembl.org/biomart/martview) and
web services (http://www.biomart.org/martservice.html), publicly

 

*To whom correspondence should be addressed.

exposed MySQL databases (ensembldb.ensembl.org:5306;
mysql.ebi.ac.uk:4157; ensembldb.ensembl.org:3306) and pro-
grammatically through Perl API modules (http://www.ensembl
.org/info/data/api.html) (Stabenau et al., 2004). The Perl API is
ideally suited to the processing of large volumes of text-based
data and as such is used for the majority of the Ensembl systems’
internal workﬂows. However, Perl is not an ideal language for
embedding in graphical interfaces.

In contrast, Java provides a robust, object-oriented program-
ming environment and is a preferable language for implementing
large-scale projects, with the beneﬁts of compile time type check-
ing, enforced interfaces, the potential to separate interface from
implementation (allowing for transparent alternative implemen-
tations), multi-threading, better support for graphical user inter-
faces and support for garbage collection of circularly referenced
objects. Java, like Perl, also beneﬁts from a vast resource of
freely available diverse code libraries and development frame-
works and tools, including open source projects in the
Bioinformatics domain.

Previously, Ensembl provided the ENSJ library, a Java API
for data access in Java or J ython (Stabenau et al., 2004). Like the
Perl API, ENSJ intimately embedded data access code (i.e. the
actual SQL statements that access the Ensembl MySQL data-
bases) within the body of code representing the genetic objects.
As a consequence, a new API release had to be generated for
each database schema version (Ensembl release) conﬁgured to
connect and retrieve data from its cognate schema, with no back-
wards compatibility guaranteed. As with the Perl API, the dis-
persed nature of the embedded SQL statements meant that
changes required to keep pace with each database release were
spread across multiple ﬁles, which was an inefﬁcient process. In
2006, ENSJ was discontinued when the Ensembl team elected to
focus their ﬁnite resources on the maintenance of the Perl API
code alone. Since then, despite the growing number of bioinfor-
matic tools being developed in Java, there has been no Java
Ensembl API available.

Other parties have, however, developed several partial APIs to
Ensembl in a number of alternative programming languages,
particularly to support bulk data download. Typically, these
APIs do not directly address the issue of schema versioning,
and many are not actively maintained. Two of the most widely
used such APIs are the Bioconductor R interface to BioMart,
‘biomaRt’ (http: //www.bioconductor.org/packages/release/bioc/
html/biomaRt.html), although this is a biomart API rather
than an Ensembl API per se, and the BioGem plug-in ‘ruby-
ensembl-api’ (http://bioruby-annex.rubyforge.org/) which uses
Active Records to abstract over the Ensembl Core Schema.

 

© The Author(s) 2012. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/3.0), which
permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.

112 ﬁhO'smumo[pJOJXO'soi1BmJOJutoiw/2d11q IIIOJJ pepcolumoq

910K ‘09 lsnﬁnV no :2

JEnsembl

 

Although the ActiveRecord design allows the API code to
remain ‘in sync’ with the database schema automatically, no
higher level data model is generated and scripts that run against
a particular release of the Ensembl databases will not run against
other releases if the names of tables or columns have been
changed. Several Python-based APIs that have been made avail-
able have not evolved with schema changes and provide limited
data models [e.g. PyCogent (http://pycogent.sourceforge.net)
(Knight et al., 2007), PyGr (http://code.google.com/p/pygr/
wiki/PygrOnEnsembl), cache-ensembl (http://pypi.python.org/
pypi/cache_en sembl)] .

A new, easily maintainable Java-based API to the Ensembl
system would be a timely and highly effective addition to the bio-
informatics toolbox. Such an API would allow integration be-
tween graphical user interfaces and Ensembl datasources and
between other bioinformatic resources and libraries implemented
in Java [for example, the BioJava (http://www.biojava.org)
framework; Holland et al., 2008].

A full Java API to the Ensembl system would replicate all the
data access functionality of the Perl API Core, Compara,
F uncGen and Variation modules and would:

(1) Connect to and extract data from the current release ver-
sion of Ensembl.

(2) Access all instances of Ensembl data systems including
single-species databases at Ensembl and EnsemblGenomes
and the multi-species databases (bacterial collections) at
EnsemblGenomes.

(3) Access data from all database types: Core, FuncGen,
Variation, Compara, etc.

(4) Emit software objects corresponding to the major ob-
ject types within Ensembl including Sequence
Regions, Markers, Alleles, Genes, Exons, Transcripts,
CoordinateSystems and AnnotationFeatures of numerous
kinds.

(5) Map between appropriate CoordinateSystem levels for a
given genome (thus allowing actual DNA sequence data to
be retrieved for features annotated at higher levels, e. g.
genes on chromosomes).

(6) Provide an architecture for updating the API connectivity
and functionality as new versions of Ensembl are released,
while maintaining backwards compatibility with earlier re-
leases (improve on the Perl requirement for version-
speciﬁc API releases).

(7

v

Be compatible with (and build upon) existing open source
Java libraries for bioinformatics where relevant (e. g.
BioJava 3.0).

We report here the implementation of an extendable Ensembl
Java API that demonstrates the tractability of the objectives
above; speciﬁcally it provides access to all versions of databases
currently published at Ensembl and EnsemblGenomes. It imple-
ments core functionality for the retrieval of chromosome, gene,
transcript, exon, protein data, etc. from ‘Core’ databases; maps
locations between CoordinateSystems and maps transparently
between database versions where changes in the schema necessi-
tate different SQL statements to extract the same information.
We have also implemented retrieval of SNP variation

information from the ‘Variation’ databases and comparative
homology information from the ‘Compara’ databases.

We demonstrate the potential utility of our Ensembl Java API
by incorporating the J Ensembl libraries in a plug-in created for
the Savant Genome Browser (http://www.savantbrowser.com/)
(Fiume et al., 2010), and in our Genetic Map Drawing applica-
tion ‘ArkMAP’ (http://www.thearkdb.org/arkdb/download.jsp).
These plug-ins demonstrate how third-party developers can use
JEnsembl to access data from Ensembl datasources, allowing
the graphical display and alignment of chromosomal sequences,
variations and exceptions, gene annotations and gene
homologies.

2 IMPLEMENTATION

J Ensembl is implemented in Java version 1.6 following a modu-
lar design pattern using Maven software management. Project
development is hosted on SourceForge where code is available
from the subversion repository (http://jensembl.sourceforge.net/;
https://sourceforge.net/projects/jensembl/). The architecture of
the project is shown schematically in Figure 1. Each of the sep-
arate interdependent modules of the API is built as a Maven
artifact allowing for public distribution via Maven repositories.
Alternatively, the Jar artifacts can be used as standard Java
libraries outwith a Maven build environment. Each module is
coded against full J Unit tests, with an additional module provid-
ing demonstration code and functional tests for data retrieval by
the API from remote datasources. Current release versions of the
libraries are available on the project website and Maven
repository.

The modular design of the JEnsembl artifacts is described
more fully in the online documentation. In brief, the J Ensembl
API deﬁnes Java objects corresponding to the various genetic
objects described in the Ensembl datasources (i.e. Chromosomes,
DNASequences, Features, Species, Genes, etc.). These data ob-
jects are created and populated through the data access layer (see
Fig. 1) using MyBatis (http://www.mybatis.org/) as the
RDBMS-to-Java object-mapping tool. A fundamental goal of
the project design was to separate schema version-speciﬁc data-
base query code from the data model; this is achieved by parti-
tioning the SQL code and MyBatis data mapping rules into a
hierarchy of XML conﬁguration ﬁles in the conﬁguration
module (see Fig. 2). Conﬁgurations in the schemaproperties ﬁle
automate which mapping rules are used for each Ensembl
release-version, allowing the data access code seamlessly to main-
tain correct data mappings as the Ensembl data schema evolves,
while retaining backwards compatibility with earlier schema.

To connect to a datasource (e.g. Ensembl), a DBRegistry
object is instantiated by injecting either a default RegistryConﬁ-
guration object read from the current ensembl—conﬁg module or a
RegistryConﬁguration generated from locally supplied proper-
ties. The RegistryConﬁguration deﬁnes the set of MyBatis con-
ﬁguration ﬁles to read for each version of the database/schema
identiﬁed within the installation. Upon DBRegistry initializa-
tion, the names of available databases at the conﬁgured data-
source are parsed using the Ensembl naming conventions and
meta-data tables to identify database-type, species, assembly and
schema release versions. The DBRegistry object can then be
queried for lists of known databases or species, or can return

 

2725

112 ﬁhO'smumo[pJOJXO'soi1BmJOJutoiw/2d11q IIIOJJ pepcolumoq

910K ‘09 lsnﬁnV no :2

T.Paterson and A.Law

 

 

User Application Code

 

 

 

1
data-aucasa—lnterfaca

ensemhI-mndel

 

   
   
    

JEnsembi

Ensembl Java API

 

 

 

 

data-access i—i II
I datasourceaware-model I
'—'I

 

 

datamapper

MyBatis-3

 

 

 

 

 

 

 

 

 

 

 

 

 

Ensam hlGanoms

 

 

 

 

 

Fig. 1. J Ensembl architecture. Schematic diagram of the modular
J Ensembl architecture, where schema-versioned MyBatis conﬁgurations
in the ensembl—conﬁg module are mapped to DatasourceAware objects
using the MyBatis data mapping framework. Connection to external
Ensembl datasources is via the MySQL JDBC connector

objects extracted from current or speciﬁc releases of named spe-
cies databases.

J Ensembl represents each of the database schema with a hier-
archy of subclasses of the Database class, (CoreDatabase,
ComparisonDatabase, VariationDatabase, etc.). A correctly
typed instance of a Database class is constructed by the
Registry for each species/version/schema database, with each
Database object creating its own instance of a MyBatis
SqlSessionFactory, conﬁgured (via the Conﬁguration artifact)
with the correct SQL mapping ﬁles for the appropriate schema
type and version. Correctly conﬁgured data access is controlled
by DAOFactory objects; an appropriate type of DAOFactory is
created on demand for each Database instance and automatic-
ally conﬁgured to use the correct MyBatis mapping rules for its
schema version. The DAOFactory provides the DA0 access ob-
jects which perform data queries using MyBatis SqlSessions pro-
vided by their shared DAOFactory. These SQL queries typically
return DatasourceAware objects; each DatasourceAware object
holds a reference to its own DAOFactory, which is used to per-
form lazy loading of data ﬁelds and perform queries about

 

 

 

 

 

 

A I  I B I lﬂ'lll'ﬂ-I-Vl'l-Iﬂﬂ_l'ﬂmlrlg.prup|lllﬂ
= .1 ram Itnwnnanaarnhluschumaﬁ
=—1I'ﬂ'rrﬂ =5051525354ﬁ535T585-93ﬂ5f6263546556
- .J m
_ I T, m cuaneneamernlma=ﬁE
:_ j 2 km mﬂglii nonhuman
7 1.1 rm: biEBﬁ_n'ly‘baI|a.
[h 12:117-an rl'l ' ' ' ' u ‘ _ Iml
ﬁll mmag-l-Fa-‘IW-m nl
= —-i m loch-ml ill-um locum-i
E Tape-n33: mama—W . . . .
m Imam] u-
E maml
m n-mrFqu-e-nu lemmhl mn‘ll union! to use
2:101“? wre_ﬁﬂ_5nhama=ﬁﬂimrai
__ kiln l
Trmmmll eure_51_acnerna ETimrEu'
ﬂ Triﬂm'uml "
_] burr. Cm_ﬁﬁ_5—Chma=ﬁﬁllmmll
._: nan-1w cum_EE_5::hEima=ﬁ§inanli
e -,_1 a:
__' _] mm: m_ml_schemu=ﬁﬁimrei
m emf-pm ml
5 mum-m..." nulle-c:inn_mta_55_ﬁd'hema=5?fenrei
__I ﬁt! “Hm-i" wminnumuﬂi mwaﬁmw
-' TIE-“Wm,” EDIEIIDn_me_EUﬁEﬂI_EEhRIﬂB=E-EIIUJFEII
ﬂ Ennmll
E Gn'vaurrll =
E ﬁmrmml TmLmI-nparajtsenama E'l'n'mwara}
I: ., mmm' maurbl_numpm_mn'enl_achama=5ﬂmmparai
En mm
1' g mmmm varhtianjchhama-ﬁﬂvarialimi'
I ﬂ mnii'llJI-ImnrtrrIl-I _..
: : mmpmm variant-.111 current schma-ﬁzmnuum

 

 

Fig. 2. Data mapping between database releases and schema versions.
(A) The conﬁguration ﬁle hierarchy in the ensembl—conﬁg module. The
ensembldb, ensembldb—archives and ensemblgenomes properties ﬁles hold
JDBC connection parameters, while schema_version_mappings speciﬁes
which MyBatis conﬁgurations are to be used for each Ensembl release
version. The base Configuration.me and Database.xml ﬁles conﬁgure
connection at the datasource level, while release-speciﬁc MyBatis map-
pings are held in database type-speciﬁc directories: schema/XX/compara,
core, fancgen and variation; rules speciﬁed in a Configuration.me ﬁle in
each directory allows a release conﬁguration to use mapping ﬁles from
different directories. (B) Abridged listing of schema_version_mappings
properties, showing how the appropriate mappings of database type
and version to MyBatis conﬁguration directories are speciﬁed. Core
and Compara mappings were developed for release 57 and are backwards
compatible to release 51. Variation mappings were introduced from ver-
sion 62 and Core mapping rules updated at release 65

further data relationships. Hence, all access to a particular data-
base is effectively performed through a DAOFactory singleton
(providing the opportunity for implementing data caching).

Databases with schema versions for which conﬁguration de-
tails are not explicitly provided will not be made available by the
Registry, thus avoiding incompatibility with unsupported older
releases or newer releases that post-date the API code and that
have not yet been mapped. New Ensembl releases requiring
changes to SQL code are handled simply by deﬁning a new
mapping conﬁguration. Where no changes are needed, existing
conﬁgurations can be reused in a ﬂexible and granular fashion—
new mapping conﬁgurations can import existing elements and
only need to replace the individual mapping ﬁles that cover the
modiﬁed part of the schema. This architecture is illustrated in
Figure 2.

The Ensembl datasources contain not only the actual DNA
sequences of genome assemblies but also annotations of features
on the assembly derived from Ensembl’s own pipeline analyses
and external sources, together with derived relationships between
these features. Core sequence and assembly information together
with gene and transcription annotations are stored in a ‘Core’
schema, while the other (optional) data schema are used to hold
further information about the better studied model species.
Access to data in the other (non-Core) database schema is con-
trolled through the Core DAO Factory, which, for example, can
supply an instance of a DAOVariationFactory for the correct

 

2726

112 /810's112umo[pJOJXO'soi112u1101utoiq/ﬁd11q 111011 pep1201umoq

910K ‘09 lsnﬁnV no 2:

JEnsembl

 

species/version Variation Database, with its own correctly con-
ﬁgured SQLSessionFactory. This DAOVariationFactory sup-
plies a DAOVariation object, which may be used to retrieve all
the variations for a given chromosomal region. Comparative
genomic data are stored somewhat differently in Ensembl, and
a DAOComparaFactory accesses a single Compara database for
each release of Ensembl, which holds the results of pair-wise
inter-species comparisons (comprising both genomic alignments
and gene family and homology data).

The EnsemblGenomes datasource uses the same (versioned)
schema as Ensembl (which is now focused as a Vertebrate re-
source), but with species organized into ﬁve separate taxonomic
groups, each with its own Compara database. Therefore, as with
the Ensembl Perl API, J Ensembl can use the same API for data
access from EnsemblGenomes with the added beneﬁt of version
aware conﬁguration on the ﬂy. However, EnsemblGenomes bac-
terial datasources differ signiﬁcantly in being organized into
multi-species databases according to phylogeny. Ensembl
adapted their schema to handle multi-species resources, and the
Perl API handles all schema identically (as potentially
multi-species). In J Ensembl, multi-species resources are currently
handled by implementing separate ‘multi-species’ interfaces in
Database and Factory objects. Because the underlying schema
is identical, the multi-species data access architecture could be
used for accessing standard single-species datasources. However,
currently we feel retaining the single-species database paradigm is
simpler for the majority of users and allows for easier represen-
tation of a ‘species’ object, shared between database release
versions.

In order to harness the comprehensive sequence manipulation
features of BioJava libraries, we extended the BioJava 3.0 Core
DNASequence object for the J Ensembl DNASequence object,
providing an Ensembl SequenceReader that can lazy-load se-
quence on demand from the Ensembl datasource. This provides
the J Ensembl Sequence objects with BioJava API behaviour, for
example reading protein sequences from translated transcripts.
Incorporation of third-party open source libraries not only ob-
viates code duplication but also enables interoperability with a
wider range of third-party software.

The JEnsembl release libraries were used to create a novel
plug-in for the Savant Genome Browser (Fiume et al., 2011).
The plug-in source code and binary Jars for different versions
of the browser are also available from the J Ensembl project site
on SourceForge (http://jensembl.sourceforge.net/savant.html).
Our ‘ArkMAP’ map drawing tool has recently been converted
to retrieve chromosome gene annotation data directly from
Ensembl datasources using the J Ensembl API instead of the
BioMart web services, thus allowing ArkMAP to be ‘Version
Aware’ for Ensembl data. J Ensembl-mediated access to
Compara data allows the discovery and alignment of regions
of conserved synteny between species and SNP marker mappings
can be retrieved from Variation datasources.

3 RESULTS AND DISCUSSION
3.1 JEnsembl

The J Ensembl development code, Jar library releases (Maven
artifacts) and documentation including J avaDocs are available

on SourceForge (current release 1.12). Access to an Ensembl
datasource is achieved by initializing a DBRegistry object
either with one of the two conﬁgurations provided
(ENSEMBLDB or ENSEMBLGENOMES) or with user-speci-
ﬁed conﬁguration properties that allow connection to alternate
datasources using the Ensembl schema, for example Ensembl
Archives or private, local data resources. Initialization of the
Registry object sorts and registers the available databases at
the selected datasource: their release number, schema type and
species, determining which releases match the schema version
mappings in the current J Ensembl Conﬁguration module.
Thereafter, data from any ‘known’ database type and version
can be interrogated through the Registry. In the absence of spe-
ciﬁed type or version number, a query retrieves data by default
from the most recent conﬁgured (i.e. ‘known’) version of the
appropriate database type. In addition to providing public
access to the databases, the Registry provides public access to
Species objects by name or alias, suitable for more high-level
usage. Species can then be queried for information about
genes, sequences, etc. without any knowledge of the Ensembl
data structure.

Figure 3 demonstrates example code usage, starting with
Registry initialization and retrieval of a Species object, which is
then used to access data from speciﬁed release versions of the
Ensembl datasource. Thus, the current or any earlier release ver-
sion of chicken chromosome 2 (together with all of it annota-
tions) can be retrieved (e.g. release ‘60’ in Fig. 3). This allows
reproducible access to the correct version of data used by histor-
ical analyses and allows comparison of different versions of the
data using a single API code installation. This is illustrated by the
single code snippet shown in Figure 4 where data pertaining to a
single human gene can be retrieved from the current and previ-
ous 17 human core database releases available at the Ensembl
datasource (and for which the J Ensembl API has conﬁgured
schema mappings). This allows, for example, the location of
the gene to be compared over time, between Ensembl releases,
assembly builds, patches and changes to the gene model and
permits many other ‘through-time’ analyses of genome assem-
blies to be contemplated. The retrieval of similar multi-release
data using Perl would require multiple, separate, release-speciﬁc
versions of the Ensembl Perl API to be installed and involve
complex library path manipulations.

A central concept within the J Ensembl model is a ‘Mapping’:
between source and target ‘MappableObjects’, with source and
target coordinates (start, stop, strand). Mappings allow any of
the Ensembl annotation types to be located on other types (e. g.
genes, exons, variations on chromosomes). When genes are
retrieved from a chromosome, the query returns a set of genes,
each with its own mapping to the chromosome, while the
chromosome is returned with an ordered set of the (inverse)
mappings of genes on the chromosome.

Retrieval of data across the database schema types is achieved
transparently, by loading appropriate DAOFactories, and using
appropriate identiﬁers shared across the schema. For example,
querying a gene for homologues uses the gene’s stable Ensembl
identiﬁer to query the Compara schema, and the target ‘hits’
retrieved contain enough information to convert them to Core
schema objects if required (target stable id, chromosome name
and coordinates, and target species name). Similarly, queries to

 

2727

112 /810's112umo[pJOJXO'soi112u1101utoiq/ﬁd11q 111011 pep1201umoq

910K ‘09 lsnﬁnV no 2:

T.Paterson and A.Law

 

 

// Connect to default Ensembl datasource
Registry eReg = new DBRegistry(DataSource.ENSEMBLDB);

// Alternatively connect to locally configured datasource
RegistryConfiguration conf = new RegistryConfiguration();
conf.setDBByFile(new File("dbConn.properties"));
conf.setSchemaByFile(new File("schema.properties"))3

eReg = new DBRegistry(conf, true);

// Get species GaLLus gaLLus by alias
Species sp = eReg.getSpeciesByAlias("chicken");

//Get default (current) or specific version of chromosomez
Chromosome chr2 = sp.getChromosomeByName("2");
Chromosome chr2v69 = sp.getChromosomeByName("2","69");

// Get all the genes on chromosome 2
List<? extends Gene> genes
= chr2 . getGenesOnRegion (1, chr2 . getLength ( ) );

// Or get them as mappings with coordinates
MappingSet mps =
chr2.getLoadedMappings(FeatureType.gene);

// Chromosome mappings can be retrieved from a gene, as
can gene homologies
Gene g = sp.getGeneByStableID("ENSGAL699999999911");
Mapping mp = g.getChromosomeMapping()5
List<? extends HomologyPairRelationship> homols

= g.getHomologies ()3

// Transparent lazy loading of DNA sequence using Ensembl
assembly mappings
String seq = chr2.getSequenceAsString(1, 1999999);

// Variations (e.g. SNPs) can be found for a DNA Region
List<? extends Variation> vars
= chr2.getVariationsOnRegion(1, 19999999);

// Accessing data from a multi-species collection

eReg = new DBRegistry(DataSource.ENSEMBLGENOMES);

Species ecoli = eReg.getSpeciesByAlias("e_coli_k12");
Chromosome chr = ecoli.getChromosomeByName("Chromosome“);

 

 

 

Fig. 3. Example usage of JEnsembl Java API (v1.12). The Species ‘ecoli’
retrieved in the ﬁnal code block is actually a CollectionSpecies because it
is retrieved from the ‘escherichia_shigella_collection_core’ databases.
CollectionSpecies are slightly less reliable access points than normal
Species as there is no guarantee of stable species, strain names and aliases
between releases

retrieve variants from the Variation database are parameterized
with the Core sequence identiﬁer and desired range coordinate
and return the properties and mapping coordinates of variants
within this range.

The Ensembl pipeline typically annotates features at the high-
est ‘level’ of coordinate systems used in production of the
genome assembly. J Ensembl transparently integrates the varying
levels of coordinate systems (chromosome, supercontig, contig,
clone, etc.) down to the lowest ‘sequence’ level coordinate
system. This is achieved using a hierarchy of interfaces:
DNASequence, AssembledDNASequence and Chromosome.
AssembledDNASequences contain an assembly of DNASe-
quences (which may themselves be AssembledDNASequences)
at a given coordinate system level. Hence, the actual DNA se-
quence for a given chromosome is returned by lazy loading the
assembly mappings and underlying sequence level objects to re-
trieve the range of actual sequences required. The J Ensembl

 

Registry reg = new DBRegitry(DataSource.ENSEMBLDB);
Species sp = eReg.getSpeciesByAlias("human");
for (Database db : sp.getDatabasesByType(Ensemb1DBType.core) )
{ System.out.print( "r: " + db.getSchemaVersion() + "b: " + db.getBuildO );
Gene g = sp.getGeneByStable]D("ENSG00000153551",
db. getSchemaVersionO );
if (g != null)
{ System.out.println( "\tChr: "
+ ((Chromosome)g. getChromosomeMappingO.getTargetO). getNameO
+ " " + g.getChromosomeMappingO.getTargetCoordinatesO.toString());
} else { System.out.println( "\tNot Present“ ); }

r250 b:361 Chr:3 32408167 - 32485079 (FORWARD_STRAND)
r:51 b:36m Chr:3 32408167 - 32485079 (FORWARD_STRAND)
r252 b:36n Chr:3 32408167 - 32485079 (FORWARD_STRAND)
r253 b:360 Chr:3 32408167 - 32485079 (FORWARD_STRAND)
r254 b:36p Chr:3 32408167 - 32485079 (FORWARD_STRAND)
r255 b237 Chr:3 32433163 — 32510075 (FORWARD_STRAND)
r256 b237a Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r257 b:37b Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r258 b:37e Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r259 b:37d Chr:3 32433163 — 32524559 (FORWARD_STRAND)
r260 b:37e Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r261 b:37f Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r262 b:37g Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r263 b237 Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r264 b237 Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r265 b237 Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r266 b237 Chr:3 32433163 - 32524559 (FORWARD_STRAND)
r267 b237 Chr:3 32433163 - 32524559 (FORWARD_STRAND)

 

 

 

Fig. 4. Code illustrating J Ensembl API retrieving chromosomal coordin-
ates for a human gene (Ensembl ID ENSG00000153551) for 18 different
Ensembl Releases currently available at the ENSEMBLDB datasource
(i.e. MySQL databases at ensembldb.ensembl.org:5306). The results re-
ﬂect different coordinates of this gene in assembly builds 36 and 37. The
increase in apparent gene size between release 55 and 56 (highlighted) is
due to the addition of further transcripts to the gene model

DNASequence classes are built upon BioJava3 DNASequence
and extend the ProxySequenceReader interface to load, read and
manipulate sequences.

Throughout the J Ensembl development process, Ensembl has
continued to release successive versions of its datasets, with an
evolving data schema. This evolving schema has afforded a chal-
lenging opportunity to demonstrate the effectiveness of
J Ensembl’s transparent version conﬁguration strategy. For ex-
ample, a major change was introduced to the Core schema at
version 51 to allow multiple species to be held within a single
database, with separate coordinate systems being held for each
species. Our code must therefore execute different SQL queries
when retrieving coordinate system information from database
instances before or after this release. Similarly, the merging of
separate stable_id tables with the gene, exon, transcript and
translation tables in Ensembl release 65 requires different SQL
queries to be run post and prior this release. These schema mi-
grations are speciﬁed in a hierarchy of MyBatis XML conﬁgur-
ations and a properties ﬁle specifying which MyBatis
conﬁgurations should be used for each schema release (see
Fig. 2). The conﬁguration occurs seamlessly and silently and
requires no user intervention.

The J Ensembl development site details many more example
code ﬁles that may be downloaded, and which demonstrate data
access using all of the currently implemented aspects of the API.
These ﬁles (found in the Ensembl Test artifact) include the data
access routines used in the Savant and ArkMAP examples below.

 

2728

112 /810's112umo[pJOJXO'soi112u1101utoiq/ﬁd11q 111011 pepeolumoq

910K ‘09 isnﬁnV no 2:

JEnsembl

 

3.2 Savant Plug-In

To demonstrate the potential utility of J Ensembl to third-party
developers, we have implemented a Java plug-in Jar for the
Savant Genome. The plug-in allows a Savant user to browse
all of the available species and versions available at Ensembl
and EnsemblGenomes, and to load chromosome assemblies for
display in Savant. These can then be decorated with the gene
annotations for that chromosome build (Fig. 5).

As in our code examples (Fig. 3), the plug-in creates a
DBRegistry object and presents available databases (and subse-
quently chromosomes) to the user as drop down selection lists.
The gene annotation data for the selected genome are retrieved
from gene mappings (for example code, see Fig. 3) and then
passed to the Savant application.

It should be noted that limitations in the Savant API architec-
ture, whereby data must be passed in as a single BED ﬁle, pre-
clude some of the capabilities of the J Ensembl code which has
been designed to load sequence details in a ‘lazy’ fashion, i.e.
only when needed. For this reason, importing of actual DNA
sequence data together with the chromosome coordinates is pro-
vided as an optional step and should be avoided for large
chromosomes.

3.3 ArkMAP

ArkMAP is a desktop Java application provided by ArkDB for
drawing genetic maps (i.e. linkage maps, radiation-hybrid maps,

 
 
 

  

B Edit View Window Hairs Help
mum: [drmnm_m_ee: 5.1m - 5.75::

 

 

cytogenetic maps, physical maps). It can download and align
mapping data from ArkDB web services and from Ensembl
datasources. It has recently been refactored to use the
J Ensembl API to retrieve mapping data from JEnsembl.
Previously, Ensembl assembly data (e. g. gene location annota-
tions) were retrieved using BioMart web services, which re-
stricted ArkMAP to accessing data in the current Ensembl
release (held in BioMart). However, by using the JEnsembl
API for data access, ArkMAP becomes release-version aware
and data can now be selected for any available Ensembl release.
This is important because it allows work performed using previ-
ous assemblies to be compared with the current genome assem-
bly. This is illustrated in Figure 6: an ArkDB map created using
the bovine assembly data of Ensembl release 54 can be aligned
with gene annotation data from the appropriate Ensembl release,
which can in turn be aligned with the most recent assembly re-
lease. The J Ensembl API allows additional data exploration: for
example the discovery of gene homologies and the identiﬁcation
and alignment of regions of conserved synteny between species
(as shown in Fig. 6) or the retrieval of the coordinates of SNP
Markers (e.g. dbSNP markers).

3.4 Scripting with the J Ensembl API

The comprehensive Ensembl Perl API is widely used for data
access and manipulation by bioinformaticians and Perl is an
ideal scripting language for bulk sequence manipulation.
However, as further functionality is implemented in J Ensembl,

event Genome Browser - Untitled Projectsvp *

0.0. Hue-run

 

p: I': we?” F I'e-e'ﬁeamt'h:l*r _Mr _i'pw.

 

WTW‘I
aunt-mm

  

 

:
|Tool5 oispiaymde Appearm IntermoII-Eldwt g

- rm ﬁrm
- hue-n the!
——...-.—. Inhi-
— Henna-ling

 

 

I Tn'oort [Homer-.421  from Eremrbl

tantamount-n) nasal momma-anemia

 

  

Irr'ipujrt Ci‘irorrio-mrries: Horn Enee rrtil

Ermn‘bl Species: (Select Garnmﬁuild}

 

 
     
   

 

 

 

 

 

 

 

 

-__=l

 

 

Data Tobie I LICEC Explorer 113'th Elﬁn-Doom m Emoth I:
m:

 

 

 

 

mm a with {Bee 13111.15) V Irelaaee. 56 [genome build. 311 
yelhw few n'oemito {hedge aegjrpﬂ} .n.
j Felch Gone mo: _ __-
gmtparoa (Ale n'elanoleixa} _ _
UH III-rem: goon mole (Arnolis :a'olheneis} 53m Gauqu
[m VII Ali-1:31 malaria -: -

-: atrle -E--:--:- 15!." u=. _-
nematoclia {teem-imam elagare}
mite-WEI man-Inset (Celliifrt: jactl'ue}
dag (owe me Familiar'e} .V

 
   

 

 

 

 

 

Fig. 5. J Ensembl plug-in for Savant genome browser. (A) The user selects the desired species and release version from those available at the selected
datasource (Ensembl, EnsemblGenomes or EnsemblGenomes-Bacterial). (B) A single chromosome/assembly is selected from those available for the
chosen species/release. The chromosome is imported either as a simple coordinate skeleton or with the associated colour-coded genomic sequence.
Currently, the only feature annotation that can be imported from the datasource is the gene track, which Savant shows aligned with the DNA Sequence

 

2729

112 /810's112umo[pJOJXO'soi112u1101uroiq/ﬁd11q 111011 pepeolumoq

910K ‘09 isnﬁnV no 2:

T.Paterson and A.Law

 

ﬂoral-1M - Min-DB's Map Draw-ing application

DIIﬂFIII

 

 

—ax

Iplolu Ell-
n-i3'm Bilﬂqlélmlllﬁltﬁlur-Il: Fr- 'Ik
W "I?" 'II

* —1H

_ ml.“ lm'meMI_I-ouwlﬂ1 1|

Jllﬁl'lhﬂl
4- _  ' 

I-u_'

 

 

_E __II‘ - _ .... --_-_

W,” "m.- mm-ew _

-_;.;\_|__T_.::_I_-I.__I
tun-1mm: '-.'-_.:__ __:-_ ._

—a x
Mme-Im- _13 3"
Emma-"H!
mihldwmlﬂ-eﬁ-Iml‘

 

 

 

 

 

 

 

 

 

 

 

i I n-

Fig. 6. The ArkMAP application uses J Ensembl for retrieving maps and homologies from Ensembl datasources. ArkMAP can be used to draw genetic
maps loaded from ArkDB, Ensembl or local datasources. Here the ﬁrst 8 Mb of a bovine ePCR map has been loaded from ArkDB, where Ark Markers
have been mapped on the Btau4 assembly. The J Ensembl API was then used to retrieve and align the cognate gene-annotated chromosome 1 assembly
from Ensembl release 54. J Ensembl was then used to retrieve a more recent (release 66) gene annotated assembly which is aligned to the old assembly.
Finally, J Ensembl was used to search for human gene homologies with the bovine genes in this region, and the region of conserved synteny on human
chromosome 21 aligned with the bovine chromosome (with colour-coded homology relationships)

there is greater potential for using Java scripts for data manipu-
lation, a task aided by the use of powerful Java IDE tools such as
Netbeans and Eclipse for writing code. Example data access
scripts can be found in the Ensembl Test artifact described
above and are available on the project website. Use of
J Ensembl has both validated the API and driven implementation
of new features as required. For example, retrieval of variation
data from the Variation schema databases was introduced to sup-
port a script that outputs SNPs within a given proximity to an
annotated gene, while the requirement for a mechanism to re-
trieve pseudoautosomal sequences was exposed by scripts which
were failing to locate sequence features on the human Y
chromosome.

4 CONCLUSIONS

The majority of bioinformatic processing of genome information
has traditionally been performed using Perl scripting, and the
Ensembl Perl API is a fundamental tool for bioinformatic ana-
lysis. However, Java developers of bioinformatics tools, particu-
larly graphical display interfaces, have been restricted by the lack
of a generic Java API for accessing Ensembl data. In its absence,
they have been forced to develop ad hoc solutions and data
models for importing and representing genome data from
Ensembl either directly accessing the raw MySQL datasources

(which have an extremely complex data model) or retrieving data
from Web Service calls to Ensembl BioMart and converting the
raw data to the user’s own genetic data model. All of these
methods are fragile to a lesser or greater degree and thus repre-
sent ‘workarounds’ rather than ‘solutions’. The provision of this
Java API to Ensembl thus represents a valuable new resource for
the expanding Java bioinformatics community.

Our current release version of J Ensembl demonstrates how we
believe certain key aspects of a Java API should be addressed, in
particular schema versioning and interoperability with other
available Java libraries. It provides the framework on which to
build a fully functional, open source implementation of a Java
Ensembl API equivalent in functionality to the Perl API main-
tained by the Ensembl team. The project is hosted on
SourceForge where we hope it will develop as a collaborative
project similar to the BioJava code base and as such we call
for and welcome expressions of interest from other developers.

ACKNOWLEDGEMENTS

We wish to thank the numerous BioJava3 developers for helpful
discussions during the early stages of this project and the
Ensembl development teams for helpful information and
feedback.

 

2730

112 /810's112umo[pJOJXO'soi112u1101uroiq/ﬁd11q 111011 pepeolumoq

910K ‘09 isnﬁnV no 2:

JEnsembl

 

Funding: Supported by Institute Strategic Grant funding from
the Biotechnology and Biological Sciences Research Council.

Conﬂict of Interest: none declared.

REFERENCES

Fiume,M. et al. (2010) Savant: genome browser for high-throughput sequencing
data. Bioinformatics, 26, 1938—1944.

Flicek,P. et al. (2008) Ensembl’s 10th year, 2010. Nucleic Acids Res., 38 (Suppl. 1),
D557—D562.

Holland,R.C.G. et al. (2008) BioJava: an Open-Source Framework for
Bioinformatics. Bioinformatics, 24, 2096—2097.

Knight,R. et al. (2007) PyCogent: a toolkit for making sense from sequence. Genome
Biol., 8, R171.

Stabenau,A. et al. (2004) The Ensembl core software libraries. Genome Res., 14,
929—933.

Strozzi,F. and Aerts,J.A. (2011) A Ruby API to query the Ensembl database for
genomic features. Bioinformatics, 27, 1013—1014.

 

2731

112 /810's112umo[pJOJXO'sot112u1101utotq/ﬁd11q 111011 pepeolumoq

910K ‘09 isnﬁnV no 2:

