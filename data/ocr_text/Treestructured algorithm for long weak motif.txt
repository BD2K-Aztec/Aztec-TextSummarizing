ORIGINAL PAPER

Vol. 27 no. 19 2011, pages 2641—2647
doi: 10. 1093/bioinformatics/btr459

 

Sequence analysis

Advance Access publication August 5, 2011

Tree-structured algorithm for long weak motif discovery
He Quan Sun”, Malcolm Yoke Hean Lowl, Wen Jing Hsul, Ching Wai Tan1

and Jagath C. Rajapaksem’3

1Department of Computer Science, School of Computer Engineering, Nanyang Technological University, Singapore
639798, 2Singapore—MIT Alliance, Nanyang Technological University, Singapore 637460 and 3Department of
Biological Engineering, Massachusetts Institute of Technology, MA 02142, USA

Associate Editor: Alex Bateman

 

ABSTRACT

Motivation: Motifs in DNA sequences often appear in degenerate
form, so there has been an increased interest in computational
algorithms for weak motif discovery. Probabilistic algorithms are
unable to detect weak motifs while exact methods have been able
to detect only short weak motifs. This article proposes an exact tree-
based motif detection (TreeMotif) algorithm capable of discovering
longer and weaker motifs than by the existing methods.

Results: TreeMotif converts the graphical representation of motifs
into a tree-structured representation in which a tree that branches
with nodes from every sequence represents motif instances. The
method of tree construction is novel to motif discovery based on
graphical representation. TreeMotif is more efficient and scalable in
handling longer and weaker motifs than the existing algorithms in
terms of accuracy and execution time. The performances of TreeMotif
were demonstrated on synthetic data as well as on real biological
data.

Availability: https://sites.google.com/site/shqssw/treemotif
Contact: sunh0013@e.ntu.edu.sg

Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on March 30, 2011; revised on July 31, 2011; accepted on
August 1, 2011

1 INTRODUCTION

Regulatory regions such as promoters, enhancers, locus control
regions, etc. contain motifs or regulatory elements that control
biological processes such as gene expression (Laurent and Philipp,
1997). Generally, activation or inhibition of gene expression is
regulated by proteins referred to as transcription factors (TFs) that
bind to particular sites in regulatory regions. For example, TATA
box with a core sequence of 5’-TATAAA-3’ located in the promoter
region of genes is bound by TFs such as TFIID, TFIIA and TFIIB to
initiate transcription. Such TF binding sites (TFBS) are useful DNA
motifs and their locations and detection are important to decipher
and control sophisticated regulatory mechanism of gene expression.

In practice, sequence motifs occur with mutations or degeneration
at sites, which are then referred to as motif instances. Motifs
are denoted as (l,d)-m0tifs where l denotes the motif length and
d denotes the maximum number of mutations allowed in the
motif. Many techniques have been proposed for detecting motifs:
enumeration algorithms (Sinha and Tompa, 2003), probabilistic

 

*To whom correspondence should be addressed.

algorithms and (Bailey and Elkan, 1994; Boucher et al., 2007; Hertz
and Stormo, 1999; Lawrence et al., 1993; Roth et al., 1998; Yao
et al., 2006) deterministic algorithms (H0 et al., 2009; Pavesi et al.,
2004; Sagot, 1998; Sun et al., 2010a, b). In addition, ensemble
techniques have been attempted (Wijaya et al., 2008).

An algorithmic challenge for motif discovery was posed in
Pevzner and Sze (2000): ﬁnd 20 planted motif instances of
(l,d)—m0tifs in 20 DNA sequences of length 600. It was observed
that most existing techniques were unable to detect a (15, 4)—m0tif.
This problem, referred to as motif challenge problem, planted motif
discovery problem or subtle/weak motif discovery problem, has
recently received increased attention. Many deterministic graph—
based algorithms have been proposed for weak motif discovery,
which begin by representing l-mer substrings sampled from
sequences in the dataset as nodes in a multipartite graph. Thereafter,
the nodes with 5 2d Hamming distance are connected by edges as
two instances of the same motif must not differ by more than in 2d
sites. The cliques of a sufﬁcient size of this graph represent instances
of the motifs in the dataset.

A graph-based algorithm WINNOWER was proposed to solve the
motif challenge problem (Pevzner and Sze, 2000). CWINNOWER
imposes an additional ﬁltering constraint to WINNOWER to decide
whether edges should be deleted or retained (Liang et al. , 2004). The
modiﬁcation substantially improves the execution time compared
with WINNOWER. We have previously proposed an exact graph-
based algorithm DPCFG, which efﬁciently detects weak motifs by
constructing lists (cliques) of motif instances in graphs (Yang and
Raj apakse, 2004). DPCFG had better accuracy and execution time
than those of WINNOWER for sequences as long as 2000 for the
(15 , 4)—motif problem. However, for longer and weaker motifs such
as (24, 8), DPCFG demands high memory requirements. This work
attempts to solve problems with longer and weaker motifs with less
memory and time requirements.

Probabilistic graph-based algorithms, such as MotifCut (Fratkin
et al., 2006) and MCL—WMR (Boucher et al., 2007), have also
been proposed for weak motif discovery. MotifCut formulates the
problem into ﬁnding maximum density subgraphs in a weighted
graph constructed using all l-mer substrings from the dataset. MCL-
WMR is a heuristic that uses the Markov cluster to search for
cliques of motif instances in weighted graphs. MCL—WMR has
shown competitive execution time and accuracy.

Non-graph-based algorithms were also proposed. For example,
PROJECTION enhanced discovery performances through ﬁnding
good starting points for expectation maximization (Buhler and
Tompa, 2002). PROJECTION produced higher performance than
WINNOWER for weaker (l, d)-m0tif detection problems. However,

 

© The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com 2641

112 [3.10'811211an[p.IOJXO'SODBIIIJOJIIlOlCI/[I(11111 IIIOJJ pepcolumoq

9IOZ ‘09 lsnﬁnV uo ::

H. Q.Sun et al.

 

its performance begins to drop signiﬁcantly above sequence length
of 1400 for the (15, 4)—motif problem (Buhler and Tompa, 2002).

A rule-based algorithm iTriplet was recently proposed for weak
motif discovery (Ho et al., 2009), which uses substrings of sample
sequences to construct triplets. Based on several proposed rules,
iTriplet generates candidate motifs from the intersection of three
circles centered at each member of a triplet. The candidate motifs
are then associated to the sequences. If a generated candidate motif is
associated to an expected number of sequences in the dataset, it will
be selected as the target consensus motif. iTriplet has been shown
to be capable of handling highly degenerated long motifs, such as
(18, 6)- and (24, 8)-motifs. However, it suffers from substantial
computational requirements.

In this article, a new deterministic tree-structured graph-based
algorithm is introduced for weak motif discovery. Using reference
nodes from a pair of reference sequences, TreeMotif constructs one
node trees with nodes from one speciﬁc sequence by dynamically
appending new nodes from the other sequences as the leaf nodes of
the trees. The TreeMotif is able to detect long weak motifs such as
(40, 14) efﬁciently in time with acceptable memory requirements.

2 TREEMOTIF

TreeMotif is inspired by graph-based approaches to weak motif
discovery. The novelty of TreeMotif is that it uses a tree-structured
algorithm to ﬁnd cliques from the graphical representation of motif
instances. In addition, as a clique may not represent a deterministic
motif consensus [for some sites, more than one bases are likely to
appear (Price et al., 2003)], TreeMotif, driven by samples instead
of speciﬁc patterns, is capable of detecting motifs with highly
degenerated positions. The algorithm consists of three main steps:
graph representation, tree construction and motif reﬁnement. In what
follows in this section, we describe these steps in detail.

2.1 Graph representation

Given a set s={si}:.":01 of m DNA sequences where si=(si,j)]’.:01
denotes the i-th sequence in the dataset and si,jeSZ={A, C, G, T},
we are interested in detecting (l,d)—motifs. For simplicity, all the
sequences are assumed to be of the same length 11 (>> l) and one-
occurrence-of—motif—per—sequence (OOPS) model is assumed. Let
vi={vi,j}]’.:é be the set of all l-mer subsequences in sequence s,-
where vi, j=(si, jx)§.,+:l {1 represents the subsequence starting at site j
of the sequence. These subsequences are represented as nodes in a
m-partite graph.

Let function D compute the Hamming distance between two
nodes and Dmax compute the maximum pairwise Hamming distance
among the nodes in its arguments. In order to build the graph
representing motif instances in the dataset, a pair of reference
sequences are chosen: without loosing generality, let us choose s0
and s1 as reference sequences. The reference node pairs, one from
each reference sequence, are selected as the node pairs that are of 2d
distance apart. A graph is constructed by drawing edges between the
reference node pair and each node in the other sequences {vi $12—21
if the maximum Hamming distance of the node to the reference
node pair is 5 2d. Algorithm 1 describes the selection of nodes for
construction of trees. From each reference node pair, the set {Pl-E":2
denotes the nodes in the graph for tree construction where P,- stands
for the nodes selected from sequence Si.

 

Algorithm 1 Node selection

 

Given {{vi,j}]’.‘:_é};.":_01 representing l-mer subsequences on all
sequence {Si};:_01
Select sequences s0 and s1 as reference sequences
Initialize {Pi = mg";
for {ﬂy/9217’: 0 do
if D(v0,jz,v1’ju)  then
for {1131—1 do
for {31:5 do
if Dmax(v0,jx,v1,ju,vi,j)52d then
Pi=PiU{Vi,j}

return {P3271231

 

2.2 Tree construction

Another reference sequence (other than the reference pair for node
selection) is selected for tree construction. Let us select s2 as the
reference, and then the nodes in P2 are initialized as the individual
roots for building trees. Let T = {root(T )} U521 T k be a K -ary tree
with a ﬁnite set of nodes where root(T) denotes the root of the tree.
Except the root node of the tree, other nodes are partitioned into
k disjoint subsets {T HE:1 where each T k is a K -ary tree. Except
for the root, each node in T has one unique parent node and can
have up to K child nodes. Let parent() denote the parent node of the
argument node, child() denote the set of child nodes of the argument
node and depth() denote the depth of the argument node in the tree.
Note that depth(root(T)) = 1.

Speciﬁcally, for each reference node pair, all the trees initialized
are constructed by appending nodes in {Pl-H1231 incrementally. Any
branch of a tree is a connected path of nodes. A branch is said to be
extendable by a node if the maximum Hamming distance between
any one of the nodes on the branch and the node is 5 2d . The
extendable() function is designed by ﬁltering tree T in a breadth-ﬁrst
manner by using a ﬁrst-in-ﬁrst—out queue Q, as given in Algorithm
2. The leaf nodes are retained in Q as ﬁltered nodes. Initially, Q is set
as empty. For the root node R of T, if D(vi,j,R) 5 2d, R is inserted
into Q; otherwise, ﬁltering is stopped and Q is returned as empty.
The process of possible ﬁltering starts at the check on the front node
in Q. If the node is a leaf node of T, ﬁltering is stopped and Q is
returned; otherwise, the node is removed from Q and its children
(whose Hamming distances from viJ- are not > 2d) are inserted into
the end of Q. While Q is not empty, the above process is repeated.
Note that a tree node viJ- corresponds to a node from S,- starting at
position j.

As discussed, if queue Q is non-empty, all ﬁltered nodes
correspond to branches that are extendable by node viJ. Thus, we
directly append viJ- onto these leaf nodes. If Q is empty, it means that
no branches in T can be extendable by viJ. After check on appending
of viJ, the same ﬁltering and appending processes are carried out
for all the other nodes in Pi. If not any node in P,- is appended,
the current tree can be stopped for construction and cleared. The
tree-construction algorithm is given in Algorithm 3.

2.3 Motif reﬁnement

There may be spurious branches that cannot lead to motifs subjected
to OOPS constraint and redundant branches that correspond to the

 

2642

112 [3.10'811211an[p.IOJXO'SODBIIIJOJIIIOICI/[I(11111 IIIOJJ pepcolumoq

9IOZ ‘09 lsnﬁnV uo ::

Tree-structured algorithm for long weak motif discovery

 

 

Algorithm 2 extendable(viJ, T)

Given tree T and a node vid-
Q <— 0 // set the queue as empty
if D(vi,j,root(T)) 5 2d then
Q.back() <—root(T); // insert the root to the end of Q
while Q 71$ 0 and depth(Q.fr0nt()) < i— 2 do
F <— Q.front() // get the front node and delete it from Q
for each node 0 e child(F) do
if D(C, vi’j) f 2d then
Q.back() <— 0
return Q

 

 

 

Algorithm 3 Tree construction

 

Given a reference node pair (vodv , v1,ju) and {Pi $12—21
for each node v2, 6 P2 do
v2, = root(Tr)
for {1131—1 do
Flag = FALSE
for each node vid- ePi do
if extendable(vi, j, T r) then
Add viJ- to T r according to Q
Flag = TRUE
if Flag is FALSE then
clear T r and break;
return {Tr}v2,rep2 With (v0,j/,v1,j~)

 

same motif. The reﬁnement of the trees as follows is necessary to
include more target motif instances.

0 Elimination of spurious branches in tree construction: if a
branch cannot be extendable by any node in a speciﬁc sequence,
pruning of this branch is performed by backtracking from the
leaf node to a node whose parent has more than one child; and
just prune away the subbranch from this node to the leaf node.

0 Merging redundant tree branches after tree construction: once
a tree is obtained, each branch together with related reference
nodes corresponds to a clique of motif instances. Therefore,
such cliques are merged if all the nodes are within 2d (making
the clique size larger than m). This can guarantee more target
instances included in the same clique.

After reﬁnement, trees that have nodes from every sequence
represent motifs. Consensuses of the motifs are then found using
all the motif instances (that is, the nodes in the trees). An example
on tree construction and motif reﬁnement is given in Section A of
Supplementary Material.

2.4 Time complexity

Suppose p is the probability of two random strings of length l having
a Hamming distance 5 2d . Then

2d
p=Z(£)(3/4)l(1/4)’—l
i=0
where p is a measure about the weakness of the (l, d)-motifs. The

larger the value p, the weaker the motif becomes (Buhler and Tompa,
2002; Ho et al. , 2009; Yang and Raj apakse, 2004).

Table 1. Comparisons of time complexities of different motif discovery
algorithms

 

WINNOWER iTriplet DPCFG TreeMotif

 

m4n4p4 mn3pl3 d2 mn3p2 + nmp3m—6 mn4p2

 

Table 1 shows the time complexity of TreeMotif and related
motif discovery algorithms. The time complexity of TreeMotif
is approximately 0(mn4p2) when p <0.32 and n 5 800. When
sequences are long or motifs become weaker, TreeMotif is able
to reduce the execution time by generating new branches more
accurately compared with DPCFG.

In addition, TreeMotif does not have to duplicate the previous
tree for new nodes. It only needs to append new nodes onto the
previous tree after ﬁltering. Necessary pruning operations only take
place when all nodes (selected from a speciﬁc sequence) have been
checked for extendability. This makes information from the previous
sequences intact without duplications, reducing execution time and
memory requirements.

3 RESULTS

The performance of TreeMotif was evaluated on synthetic data
as well as on real biological data. Synthetic datasets provide
quantitative measures that can compare its performance with the
existing techniques (Sandve et al., 2007; Tompa et al., 2005).
Experiment results of MEME, GibbsDNA, PROJECTION, iTriplet,
DPCFG and TreeMotif were obtained from runs on a workstation
with 2.66GHz CPU and 3 GB RAM. Detections with MEME,
GibbsDNA, PROJECTION and DPCFG were based on exactly
one motif occurrence per sequence (OOPS) while with iTriplet and
TreeMotif, detections were made with at least one motif instance
per sequence.

3.1 Synthetic data

Following Pevzner and Sze (2000), synthetic datasets are generated
using the model of ﬁxed number of mutations. First, a speciﬁc
number of i.i.d. sequences were generated. Second, an instance of
a target motif of length l is planted at a random position of every
sequence. Third, for each motif instance, equal to or less than d
positions were mutated by randomly selecting from Z positions.

3.1.] Motif challenge problem for one dataset, 20 instances of a
(15, 4)—motif were planted in random positions of 20 i.i.d. sequences
of length 600. A total of 50 synthetic datasets were created to obtain
unbiased estimates of performances. Following Pevzner and Sze
(2000), nucleotide performance coefﬁcient nPC1 and sensitivity
nSn2 were evaluated using true positives (TPs), false positives (FPs),
false negatives (FNs) and true negatives (TNs), to compare the
performances of different methods. Table 2 shows nPC, nSn and
execution time (with :l: SD) averaged over the results of all 50
datasets. Three motifs ranked as the best ones were used to compare
the highest nPC. For TreeMotif, different cliques of motif instances
are ranked based on information content (Schneider and Stephens,

 

1nPC=TP/(TP + FN + FP).
2nSn=TP/(TP + FN).

 

2643

112 /810's112umofp101xo'soi112u1101u101q”:d11q 111011 pepeolumoq

9IOZ ‘09 lsnﬁnV uo ::

H. Q.Sun et al.

 

1990). Note that nPC is <1.0 because random substrings could
exist in the sequences, which are as conserved as the target motif
instances.

TreeMotif, DPCFG and iTriplet show comparable nPC and
nSn, higher than those of MEME, GibbsDNA and PROJECTION.
Thereinto, DPCFG shows the highest nPC but with lower nSn while
iTriplet shows perfect nSn at the cost of lower nPC. With OOPS
model, TreeMotif can achieve the same results as DPCFG; if the
target is to ﬁnd an exact consensus motif, TreeMotif can achieve
the same results as iTriplet. On performance, TreeMotif can be
considered as an eclectic method of iTriplet and DPCFG.

Note that TreeMotif and DPCFG did not detect the correct motif
(at low nSn), because the clique of the correct motif instances was
(found but) not reported as the top ones. Although pattern-driven
methods such as iTriplet can show better nSn due to the alignment
using candidate consensus patterns, when there is no exact consensus
motif in a dataset, they usually fails to ﬁnd the motif instances. This is
why the clique of motif instances are kept as the target for TreeMotif.
As for time efﬁciency, TreeMotif and DPCFG required comparable
execution times that are less than the other methods for (15, 4)—motif
problem.

3.1.2 Weakness of embedded motif The p value reﬂects the
weakness of an (l, d)-motif (Section 2.4). With n = 600 and m = 20,
the average nPC and average execution time of TreeMotif, DPCFG
and iTriplet with increasing p are depicted in Table 3. For relatively
stronger motifs (showing smaller p value), such as (13, 3) and
(40, 12), TreeMotif shows comparable performance to DPCFG
For weaker motifs such as (14, 4) and (19, 6), TreeMotif shows
relatively higher nPC and consumes less execution time. In addition,
TreeMotif can successfully produce results for much weaker motifs

Table 2. Comparisons on performances on motif challenge problem

 

 

Algorithms nPC nSn Time (s)

GibbsDNA 0.01 :l: 0.01 0.02 :l: 0.02 3.46 :l: 0.37
MEME 0.22 :l: 0.20 0.32 :l: 0.25 3.04 :l: 0.08
PROJECTION 0.42 :l: 0.27 0.54 :l: 0.30 75.43 :l: 3.12
iTriplet 0.94 :l: 0.06 1.00 :l: 0.00 185.56 :l: 5.30
DPCFG 0.97 :l: 0.05 0.98 :l: 0.03 0.70 :l: 0.03
TreeMotif 0.95 :l: 0.05 1.00 :l: 0.01 0.74 :l: 0.04

 

such as (16, 5), (24, 8) and (40, 14) while DPCFG cannot produce
results due to memory shortage.

As seen, when l < 20, TreeMotif shows comparable nPCs to
iTriplet while consuming less execution times. TreeMotif performs
poor on the (16, 5)-motif, because many random cliques occur in
such data. In this case, more informative target function on ranking
the cliques are needed. Meanwhile, when l > 20, TreeMotif can ﬁnd
the target motif instances with slightly higher nPCs while consuming
much less execution time than iTriplet. For instance, for the (24, 8)-
motif problem which other methods such as MEME and GibbsDNA
all have difﬁculty in dealing with (Ho et al., 2009), TreeMotif
requires about one-seventh the execution time of iTriplet.

iTriplet yielded low values of nPC because it failed to ﬁnd the
target motif instances for a part of the datasets tested (due to out of
memory). As seen from Table 3 , performance of iTriplet is inﬂuenced
by both the weakness p of the motif and the motif length while that
of TreeMotif is inﬂuenced only by weakness. Generally, pattern-
driven algorithms cannot scale efﬁciently with the length of motif
as the number of candidate motifs to test grows exponentially with l.
TreeMotif is a sample-driven algorithm, which is more scalable for
dealing with long weak motifs. For example, with settings (13, 3) and
(40, 12) showing approximately the same p, iTriplet requires much
more time on the latter while TreeMotif performs consistently.

3.1.3 Length of embedded sequences We tested TreeMotif on
synthetic data with sequence length increased from 600 to 2000.
For each dataset, one instance of a (15, 4)-motif is planted in each
of the 20 sequences. Performances of the algorithms are shown in
Figures 1 and 2.

Figure 2 shows that PROJECTION can produce slightly better
results than MEME and GibbsDNA, but their nPCs are all <0.5.
Approximately, nPC of DPCFG is the highest when sequence length
is <1500. This is because it outputs exactly m instances and most of
them are the target instances. However, when the sequence length
is >1500, nPC of DPCFG decreases quickly. This is because too
many target instances have been substituted by spurious sequence
instances. nPC of TreeMotif and iTriplet is >0.70 as sequence length
is increased to 2000. Their nPC also decreases when the sequences
become longer since random substrings that are as conserved as the
target motif instances were collected in the resulted cliques. That
is, the main reason why low nPC is resulted by DPCFG is that
it misses true signals, whereas TreeMotif and iTriplet report false
signals. Overall, iTriplet has similar nPCs as TreeMotif. However,

Table 3. Comparisons of nPC and execution time on (l, d)-motifs with increasing value of p

 

 

 

 

(l, d) (13, 3) (40, 12) (12, 3) (14, 4) (19, 6) (16, 5) (30, 10) (24, 8) (40, 14)
Alg. p 0.0243 0.0262 0.0544 0.1117 0.1749 0.1897 0.1966 0.2338 0.2850
094,006 046,050 081,007 084,006 093,014 086,008 — 0.94,0.22 —
a 0.55 ,0.02 m 0.24,0. 15 h 0.05,0.00 h 0.29,0.01 h 2.00,0.07 h 1.91,0.06 h — 15 .50, 1 .00 h —
nPC Time 098,005 100,000 087,009 076,023 087,011 — 1.00,0.00 — —
0.16,0.01 S 018,002 S 083,005 s 1.10,0.12 m 0.61,0.05 h — 0.53,0.05 h — —
094,005 100,000 082,007 080,019 094,006 0.18,0. 18 100,000 097,008 100,000
0 019,001 S 033,001 S 075,004 S 042,003 m 0.20,0.02 h 1.16,0.16 h 0.08,0.01 h 2.09,0.30 h 6.09,1.10 h

 

Alg.: a, iTriplet; b, DPCFG; c, TreeMotif; each mean value in the table followed by the standard error; —, not available as the related algorithm failed to yield the motifs.

 

2644

112 /810's112umofp101xo'soi112u1101u101q”:d11q 111011 pepeolumoq

9IOZ ‘09 lsnﬁnV uo ::

Tree-structured algorithm for long weak motif discovery

 

for certain datasets with sequences of length 1000, iTriplet runs out
of memory and thus fails to produce correct results. This results in
its lower average nPC.

Figure 1 compares the execution times of TreeMotif and DPCFG
Part of the execution time of iTriplet is also included. As seen,
iTriplet consumes much more execution time than TreeMotif and
DPCFG. As n is increased from 600 to 2000, TreeMotif requires
less time to discover motifs than DPCFG. For example, when the
sequence length is <1300, two algorithms require comparable time.
But when the sequence length is 2000, TreeMotif consumes about
one-third the execution time of DPCFG

3.1.4 Similarity of embedded sequences For synthetic data, all
bases were generated with no bias on their contents, that is, their
occurrences are equally likely. Any bias on the bases introduces
spurious signals into sequences (Buhler and Tompa, 2002). This may
cause TreeMotif to take a longer time to ﬁnd motifs (see Section B
of the Supplementary Material). For example, with G + C = 0.35,
TreeMotif requires >100 s to ﬁnd out a (15, 4)-motif while it requires
<1 s when G + C = 0.5. Execution time of probabilistic algorithms
such as MEME is not affected by such settings. However, they
cannot guarantee the discovery of the target instances. For pattern-
driven algorithms, they are also not affected. However, as discussed
in Section 3.1.1, such algorithms take effect only for data containing

 

1000 -

800 -

600 -

400 -

 

 

 

 

Mean of execution time
wrth standard error

200 

 

 

 

 

 

 

 

 

 

0600 800 1000 1200 1400 1600 1800 2000
Sequence length

Fig. 1. Execution times of algorithms with increased sequence length on the
(15 , 4)-motif problem. Note: algorithms on each point (from left to right) are
iTriplet, DPCFG and TreeMotif. Time unit: second.

deterministic consensus motifs. Therefore, although sample-driven
algorithms such as TreeMotif are time consuming for the discussed
settings, one may be inclined to use them to produce results if not
enough prior information is known about the data.

3.2 Real data

To test the practicality, TreeMotif was tested on datasets of pre-
proinsulin, DHFR and c-fos (Keich and Pevzner, 2002), LexA
(Hertz et al., 1990), and E.coli CRP (Stormo and Hartzell, 1989).
Discovered and published motifs are shown in Table 4. For all
the datasets, each sequence was assumed to contain one instance
and experiments were carried out with l starting from 6, and pair
(l,d) were set empirically to check if the target motif consensus
is discovered. Data c-fos, DHFR and prerpoinsulin consist of
sequences in the upstream regions of eukaryotic genes. Motifs
they contained had only a few mutations, which were discovered
efﬁciently and accurately by TreeMotif.

3.2.1 E. coli CRP data For E. coli CRP data from GenBank
Release 55, each sequence contains at least one CRP-binding site.
Although each sequence consists of only 105 bases, the motif
tgtgaxxxxgxtcaca is rather weak. For this data, TreeMotif can
produce the motif as tgtgaxxxagxtcacatt with l = 18, d = 6. With the
same l and d, PROJECTION cannot ﬁnd the motif although it can
produce the consensus as ttgtgatggagttcacattt with l = 20, d = 4.
Also, as not all the bases on each position are unique, pattern-driven
methods such as iTriplet fail to ﬁnd the motif. This demonstrates
the better capability of TreeMotif to discover weaker motifs than
PROJECTION [note that (18, 6) is a weaker setting compared with
(20, 4)] and the pattern-driven methods.

3.2.2 LexA data This data contain 16 sequences but only 14 of
them contain more than one motif instances (sequences himA and
uvrC contain no instances). By setting l = 24 and d = 8, one motif
is discovered as tactgtatataxaxxcagtxxaat (with 80% of the bases
of the published motif). In addition, after excluding himA and uvrC
(to obtain the OOPS data), tactgtatataxatacagta is discovered by
setting l = 20 and d = 5.

3.2.3 Other benchmark data Benchmark datasets for the
evaluation of motif discovery algorithms have been constructed by

 

Mean of nPC with standard error

 

100 1 400 1 600
Sequence length

 

 

Fig. 2. nPCs of different algorithms with increasing sequence length on the (15 , 4)-motif discovery. Algorithms on each point (from left to right) are MEME,

GibbsDNA, PROJECTION, DPCFG, iTriplet and TreeMotif.

 

2645

112 /810's112umofp101xo'soi112u1101u101q”:d11q 111011 pepeolumoq

9IOZ ‘09 lsnﬁnV uo ::

H. Q.Sun et al.

 

Table 4. Results on real data with (l, d)-motifs

 

 

Data Discovered (l , d) Published

1 ccatattaggacatct (16, 3) ccatattaggacatct
ttcgcgccaaact (13, 2) ttcgcgccaaact
cctcagcccc (10, 2) cctcagcccc,

3 agacccagca (10, 2) agacccagca,
ccctaatgggcca (13, 2) ccctaatg g gcca

4 tgtgaxxxagxtcacatt (1 8, 6) tgtg axxxxgxtcaca
tactgtatataxatacagta (20, 5)

5 tactgtatataxaxxcagtxxaat (24, 8) tactgtatatatatac agta

 

x, none of the bases appear with opportunity > 50%; 1, c-fos; 2, DHFR; 3, Preproinsulin;
4, E.coli CRP.; 5, LexA.

Sandve et al. (2007) using binding sites extracted from TRAN SFAC
database version 9.4. The real data version of the benchmarks
contains 50 datasets formed using genomic sequences. Each dataset
contains ﬁve or more sequences of the maximum length of sequences
as 2000 bp. For each motif, gaps are not allowed and each sequence
is expected to have one or more occurrences of the motif instances.
Compared with the benchmark designed by Tompa et al. (2005),
these datasets are more appropriate for evaluating motif discovery
algorithms (Sandve et al., 2007).

On this dataset, using performance of MEME as the base, the
performance of TreeMotif was compared with Weeder (Pavesi et al. ,
2004) which is a sufﬁx tree-based quasi-exact algorithm, as it shows
relatively better performance than some other tools according to the
analysis in Tompa et al. (2005). Following Tompa et al. (2005) and
Sandve et al. (2007), the nucleotide level correlation coefﬁcient nCC
was used as the performance metric.3

The discovery results of TreeMotif is uploaded to the web
benchmark tool provided by Sandve et al. (2007). We compare nC C
of TreeMotif and Weeder by keeping FP approximately at the same
level, as shown in Figures 3 and 4. The nCC of all datasets produced
by MEME are sorted in the ascending order and used as a basis. Then
the performances of Weeder and TreeMotif on each dataset are drawn
accordingly. As seen, TreeMotif achieves better nCC than weeder
for 34 out of 50 datasets. Overall, at the comparable level of FP,
TreeMotif achieves an average nCC of 0.194 compared with that of
Weeder as 0.096.

For the ﬁve datasets on which Weeder achieves better nCC by
reporting fewer FP, it also reported less or equal TP than TreeMotif.
Weeder outperforms other existing tools, because it reports only
the ‘strongest’ motifs (thus fewer FP) (Tompa et al., 2005). For
the other 11 datasets, TreeMotif fails as too many random cliques
were found while the target clique is not reported as the top one
(this is similar to the discussion in paragraph 5 of Section 3.1.1). A
possible reason for this may be that the contents of nucleotide bases
are biased, i.e. bases are not uniformly distributed. For instance, the
G + C content of these ﬁles is ~0.55 or 0.45. This increases the
probability of two random strings being within 2d (related to the
problem we addressed), especially when the background sequences
are long. As a result, the number of random cliques, which may
inhibit the detection of correct target, increases.

 

3
TP-TN—FP-FN

CC =
\/(TP+FP)(FP+TN)(TN+FN)(FN+TP)

 

 

 

1400 r r r r I I I I I I I I I I I I I I

77 l l l l l l l l l l l l l l l l ll
szWeeder3:311:111V111112222
"*TreeMotif: 1:11:11: ::

    

1200-5é

 

 

 

 

 

3 3, V Weeder: avg: O. 096, delta: 0.14
+MEME: avg: 0.083, delta: 0.20

 

 

 

 

nCC

 

 

 

 

Fig. 4. TreeMotif, Weeder and MEME on real benchmark data (Sandve
et al., 2007).

4 DISCUSSION

Weak motif discovery is an important yet unresolved problem in
computational biology. Several graph-based exact methods such
as WINNOWER and DPCFG have shown improved accuracy
compared with heuristics or probabilistic methods. However, clique
ﬁnding to discover the motifs can be time consuming. In this
article, we designed TreeMotif for discovering weak (l, d)-motifs by
building up trees on nodes of graphs. After initialization, TreeMotif
appends new nodes onto existing trees, where the appending
operations happen only when cliques indicated by the leaf nodes
are extendable by the new nodes.

The novel-constrained strategy of clique construction introduced
in TreeMotif can avoid trivial operations on intermediate results of
ﬁnal cliques. In addition, by doing motif reﬁnement, the sensitivity
of motif discovery (deﬁned in Section 3.1.1) can be increased
compared with the list algorithm in Sun et al. (2010b) which
produces exact OOPS motif instances by using a recursive node
selection. Performance comparisons with several popular motif
discovery methods have shown that TreeMotif detects weak motifs
accurately, especially for relatively longer weak motifs. Moreover,
it performs better on a recent benchmark constructed using real
motif data.

One drawback of TreeMotif is that its memory requirement grows
exponentially as the sequence length n or parameter p is increased.
Because of large memory requirements, TreeMotif failed to ﬁnd
weaker (l, d)-motifs such as (13, 4), (15, 5), (17, 6), (18, 6) and
(19, 7). This is due to the maintenance of increased number of

 

2646

112 /810's112umofp101xo'soi112u1101u101q”:d11q 111011 pepeolumoq

9IOZ ‘09 lsnﬁnV uo ::

Tree-structured algorithm for long weak motif discovery

 

tree branches (i.e. intermediate cliques of size i5 m — 1). In all such
cases, if the number of sequences is small, say K, TreeMotif might
be able to ﬁnd K -cliques (K <m). Therefore, by devising K that
divides a dataset of m sequences into m /K subdatasets, TreeMotif
can be used on these subdatasets. After all cliques of size K are
found, they could be merged as larger ones. This will be part of our
future work.

Another limitation of TreeMotif is that it can deal with only OOPS
type of data at the current stage. While in practice, the data may
contain sequences with no motif instances. Therefore, techniques to
avoid noisy instances during tree construction have to be designed.
For example, a strategy has been introduced to construct cliques
of all varying sizes and has shown success in ﬁnding motifs in
noisy data (Ho and Rajapakse, 2006). Correspondingly, a similar
strategy might be used that appends new nodes onto not only leaf
nodes but also nodes on the upper levels of a tree. In this way,
cliques of all sizes will be constructed instead of those of only size
i. This might involve more space; however as a trade-off, the noise
in the cliques might be excluded. Generally, the strategy for tree
construction still needs improvement to make TreeMotif more time
and memory efﬁcient.

Funding: This study is supported by the NTU Research Scholarship;
ARC 9/ 10 Tier—2 grant of Ministry of Education, Singapore (to
J .C.R.) in part.

Conﬂict of Interest: none declared.

REFERENCES

Bailey,T.L. and Elkan,C. (1994) Fitting a mixture model by expectation maximization
to discover motifs in biopolymers. In Proceedings of the Second International
Conference on Intelligent Systems for Molecular Biology. AAAI Press, Menlo Park,
CA, pp. 28—36.

Boucher,C. et al. (2007) A graph clustering approach to weak motif recognition. In 7th
Workshop on Algorithms in Bioinformatics (WABI ’07). Vol. 4645 of Lecture Notes
in Computer Science Springer, Berlin/Heidelberg, pp. 149—160.

Buhler,J. and Tompa,M. (2002) Finding motifs using random projections. J. Comput.
Biol, 9, 225—242.

Fratkin,E. et al. (2006) MotifCut: ﬁnding regulatory motifs with maximum density
subgraphs. Bioinformatics, 22, e150—e157.

Hertz,GZ. and Stormo,GD. (1999) Identifying DNA and protein patterns with
statistically signiﬁcant alignments of multiple sequences. Bioinformatics, 15,
563—577.

Hertz,GZ. et al. (1990) Identiﬁcation of consensus patterns in unaligned DNA sequences
known to be functionally related. Comput. Appl. Biosci., 6, 81—92.

Ho,L.S. and Rajapakse,].C. (2006) Graphical approach to weak motif recognition in
noisy data sets. In Workshop on Pattern Recognition in Bioinformatics (PRIB 2006 ).
Vol. 4146 of Lecture Notes in Computer Science, Springer, Hong Kong, China,
pp. 23—31.

Ho,E.S. et al. (2009) iTriplet, a rule-based nucleic acid sequence Motif Finder.
Algorithms Mol. Biol, 4.

Keich,U. and Pevzner,P.A. (2002) Finding motifs in twilight zone. Bioinformatics, 18,
1374—1381.

Laurent,D. and Philipp,B. (1997) Searching for regulatory elements in human noncoding
sequences. Curr Opin. Struct. Biol, 7, 399—406.

Lawrence,C.E. et al. (1993) Detecting subtle sequence signals: a Gibbs sampling
strategy for multiple alignment. Science, 262, 208—214.

Liang,S. et al. (2004) chNNOWER algorithm for ﬁnding fuzzy DNA motifs.
J. Bioinformatics Comput. Biol, 1, 47—60.

Pavesi,G et al. (2004) Weeder Web: discovery of transcription factor binding sites
in a set of sequences from co-regulated genes. Nucleic Acids Res., 32 (Suppl. 2),
W199—W203.

Pevzner,P.A. and Sze,S.-H. (2000) Combinatorial approaches to ﬁnding subtle signals
in DNA sequences. Intell. Syst. Mol. Biol, 8, 269—278.

Price,A. et al. (2003) Finding subtle motifs by branching from sample strings.
Bioinformatics, 19 (Suppl. 2), ii149—ii155.

Roth,F.P. et al. (1998) Finding DNA regulatory motifs within unaligned non-coding
sequences clustered by whole-genome mRNA qantitation. Nat. Biotechnol, 16,
939—945.

Sagot,M.-F. (1998) Spelling approximate repeated or common motifs using a sufﬁx
Tree. In Theoretical Informatics: Third Latin American Symposium (LATIN ’98).
Lecture Notes in Computer Science, Springer, Brazil, pp. 374—390.

Sandve,GK. et al. (2007) Improved benchmarks for computational motif discovery.
BMC Bioinformatics, 8, 1—13.

Schneider,T.D. and Stephens,R.M. (1990) Sequence logos: a new way to display
consensus sequences. Nucleic Acids Res., 18, 6097—6100.

Sinha,S. and Tompa,M. (2003) YMF: a program for discovery of novel transcription
factor binding sites by statistical overrepresentation. Nucleic Acids Res., 31,
3586—3588.

Stormo,GD. and Hartzell,G W. (1989) Identifying protein-binding sites from unaligned
DNA fragments. In Proceedings of the National Academy of Sciences of the United
States of America, PNAS, USA, pp. 1183—1187.

Sun,H.Q. et al. (2010a) ListMotif: a time and memory efﬁcient algorithm for weak
motif discovery. In Proceedings 2010 IEEE International Conference on Intelligent
Systems and Knowledge Engineering (ISKE 2010). IEEE, inc., China, pp. 254—260.

Sun,H.Q. et al. (2010b) RecMotif: a novel fast algorithm for weak motif discovery.
BMC bioinformatics, 11 (Suppl. 11).

Tompa,M. et al. (2005) Assessing computational tools for the discovery of transcription
factor binding sites. Nat. Biotechnol, 23, 137—144.

Wij aya,E. et al. (2008) MotifVoter: a novel ensemble method for ﬁne- grained integration
of generic motif ﬁnders. Bioinformatics, 24, 2288—2295.

Yang,X. and Rajapakse,].C. (2004). Graphical approach to weak motif recognition.
Genome Informat. Ser, 15, 52—62.

Yao,Z. et al. (2006) CMﬁnder—A covariance model based RNA motif ﬁnding algorithm.
Bioinformatics, 22, 445—452.

 

2647

112 Bio's112umofp101xo'sor112u1101urorq”:d11q 111011 pepeolumoq

9IOZ ‘09 lsnﬁnV uo ::

