Bioinformatics, 32(11), 2016, 1652—1661

doi: 10.1093/bioinformatics/btw050

Advance Access Publication Date: 2 March 2016
Original Paper

 

 

Sequence analysis

Efficient privacy-preserving string search and an
application in genomics

Kana Shimizu1'2'*, Koji Nuida3'4 and Gunnar Ratsch2'*

1Biotechnology Research Institute for Drug Discovery, National Institute of Advanced Industrial Science and
Technology, Tokyo 135-0064, Japan, 2Computational Biology, Memorial Sloan Kettering Cancer Center, New York,
NY 1275 York, USA, 3Information Technology Research Institute, National Institute of Advanced Industrial Science
and Technology, Tokyo 135-0064, Japan and 4Japan Science and Technology Agency (JST) PRESTO Researcher,
Tokyo, Japan

*To whom correspondence should be addressed.
Associate Editor: Janet Kelso

Received on April 19, 2015; revised on November 27, 2015; accepted on January 19, 2016

Abstract

Motivation: Personal genomes carry inherent privacy risks and protecting privacy poses major
social and technological challenges. We consider the case where a user searches for genetic infor—
mation (e.g. an allele) on a server that stores a large genomic database and aims to receive allele—
associated information. The user would like to keep the query and result private and the server the
database.

Approach: We propose a novel approach that combines efficient string data structures such as the
Burrows—Wheeler transform with cryptographic techniques based on additive homomorphic en—
cryption. We assume that the sequence data is searchable in efficient iterative query operations
over a large indexed dictionary, for instance, from large genome collections and employing the
(positional) Burrows—Wheeler transform. We use a technique called oblivious transferthat is based
on additive homomorphic encryption to conceal the sequence query and the genomic region of
interest in positional queries.

Results: We designed and implemented an efficient algorithm for searching sequences of SNPs in
large genome databases. During search, the user can only identify the longest match while the ser—
ver does not learn which sequence of SNPs the user queried. In an experiment based on 2184
aligned haploid genomes from the 1000 Genomes Project, our algorithm was able to perform typ—
ical queries within m 4.63 and m 10.83 for client and server side, respectively, on laptop computers.
The presented algorithm is at least one order of magnitude faster than an exhaustive baseline
algorithm.

Availability and implementation: https://github.com/iskana/PBWT—sec and https://github.com/rats
chlab/PBWT—sec.

Contacts: shimizu—kana@aist.go.jp or Gunnar.Ratsch@ratschlab.org

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 IntrOducuon Traditionally, those techniques have been optimized for accuracy and

String search is a fundamental task in the field of genome informatics, computational efficiency, however a recent boom of personal genome
for which a large variety of techniques have been developed (see, for sequencing and analyses has spotlighted a new criteria, namely, priv-
instance, Altschul et 61]., 1990; Kent, 2002; Li and Homer, 2010). acy protection. As reported in many studies, a genome is considered
©The Author 2016. Published by Oxford University Press. 1652

This is an Open Access article distributed underthe terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/4.0/), which permits
unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.

112 /§JO'S{eumo [p.IOJXO'SOTlBIHJOJUTOTQ/ﬁdllq 11101; popeommoq

9IOZ ‘09 lsnﬁnv uo ::

Efficient privacy-preserving string search

1 653

 

to be one of the most critical pieces of information for an individual’s
privacy. In fact, it is largely different from any other personal infor-
mation because it works as an identifier of an individual while it pos-
sesses the information that has strong correlation with the phenotype
of the individual (Erlich and Narayanan, 2014; Roche and Annas,
2001). Therefore, in principle, privacy protection is an inevitable
problem when handling personal genomes. As a practice, the most
popular approach is protecting genomes physically; genomic se—
quences have been kept at few collaborator sites, and only a limited
number of researchers are allowed to access them. This conservative
approach severely limits the great potential of existing genomic re-
sources. In order to mitigate the stagnation caused by privacy issues,
it appears crucial to develop practical methods that enable searching
and mining genomic databases in a privacy—preserving manner.

So far, several groups have tackled related problems. Jha et al.
(2008) developed secure multi—party computation protocols for
computing edit distance. Blanton and Aliasgari (2010) proposed a
protocol to search DNA string against a DNA profile represented by
finite automata. Bruekers et al. (2008) proposed a protocol to detect
a match between two short DNA sequences for the purpose of gen—
etic test. Baldi et al. (2011) also aimed for genetic test to develop a
method for computing set intersection cardinality. Freedman et al.
(2005) proposed a protocol for searching pre—defined keywords
from databases. Naganuma et al. (2012) proposed a substring search
protocol for public databases while keeping user’s query private.
Ayday et al. (2013) developed a system by using several crypto—
graphic techniques to find a subset of short reads which includes a
fixed-length query string at specific position. He et al. (2014) pro—
posed an algorithm for finding relatives by secure identity—by—des—
cent matches.

We propose a general approach which utilizes an efficient itera-
tively queriable data structure together with cryptographic tech—
niques. Among many variations of such data structures, the
Burrows—Wheeler Transform (BWT Langmead et al., 2009; Li and
Durbin, 2009; Li et al., 2009) and related techniques such as the
positional BWT (PBWT; Durbin, 2014) have dramatically improved
the speed of genomic database analyses. Those data structures com—
monly have an indexed dictionary called a rank dictionary. By refer-
ring to the rank dictionary in iterative operations, one can efficiently
search the database. For the case of BWT, a match between query
and database is reported as a left—open, right—closed interval , g],
and the interval is computed by the look—up of the rank dictionary.
In our approach, we access the rank dictionary in privacy—preserving
manner by using additive homomorphic encryption and oblivious
transfer (OT).

Cryptographic approaches often require significant computa—
tional resources. The goal of this work is to illustrate that privacy—
preserving queries are within reach when using current crypto—
graphic techniques and standard computing hardware. We demon—
strate that a typical query would only take about 4.6 s on the user
side using a single thread and m 10.8 s on the server having four
cores, while preserving privacy of the query string and the database.

The rest of the paper is organized as follows. In Approach, we
describe the main ideas of our approach without going into technical
details. In Methods, the detailed algorithm of recursive oblivious
transfer is given followed by the description of a practical algorithm,
named PBWT—sec, for privacy—preserving search in large—scale geno—
type databases. We also describe complexity and security properties
of the proposed algorithm. We provide the more intricate details of
a more efficient version of the algorithm in Supplementary Sections
S1—S2. In Experiments, we evaluate the performance of PBWT—sec
on datasets created from data of the 1000 Genomes Project

(The 1000 Genomes Project Consortium, 2012) and compare it to
an alternative method for fixed—length le—mer search. Finally, we
conclude our study in Section 5.

2 Approach
2.1 Problem setup

We consider the setting in which a user would like to search a gen—
omic sequence in a database with the aim to either determine
whether this sequence exists in the queried database and/or to obtain
additional information associated with the genomic sequence. An
example is the use in a so—called genomic beacon (for instance, those
created within the Beacon Project of the Global Alliance for
Genome 86 Health (GA4GH).) Another application is the search of
a specific combination of variants, for instance, in the BRCA1 or
BRCA2 genes, with the aim to determine whether that combination
of variants is known or predicted to be deleterious (see, for instance,
GA4GH’s BRCA Challenge). For privacy reasons, the user would
like to conceal the queried sequence, which would be particularly
relevant for the second example. For both examples it would be im—
portant that the server’s database is protected.

2.2 Information flow of searches on recursive search
data structures

Let us describe the information flow between a user and a server for
such problems. In this work, we perform searches on the (positional)
Burrows—Wheeler transform of a genomic database of length N.
(P)BWT stores string information very efficiently and still allows
computations (this is a property of Succinct Data Structures, see
Jacobson, 1988).

To search for a query string q over the alphabet 2, one iteratively
operates on intervals that can later be used to identify the matching
genomic regions based on the (P)BWT. A substring match is repre—
sented by an interval , g]. The number of matches is given by the
length of the interval g—f. It is known that the (la —1— 1)th interval
(fk+1,gk+1] corresponding to a (la —1— 1)—mer match can be updated
from the lath interval (fk, gk] and the (la —1— 1)th letter of the query q.

We will provide more details on how to update f and g in Section
3.3. To understand the key ideas, it is sufficient to understand that
the updates can be written in the form of

fk+1 = Velka and gk+1 = Vclgkl,

where c : q[le —l— 1] and vc E NN is a large, static lookup table.
Hence, the iterative algorithm of updating (fk, gk] by using the query
q, can be written as a recursive algorithm:

fk+1 = Vqlk+1llvqlklIVqu—1ll--- tiulfol will-

This can be done analogously for gk+1. In this work we will refer
to data structures that can be queried in the recursive way described
above as recursive search data structures. Figure 1 illustrates the in-
formation ﬂow of a search on the recursive search data structure.

2.3 Oblivious transfer for privacy—preserving search

In a search on the recursive search data structures, the user needs to
conceal not only a query string q but also f and g because  is ﬁ_1th
element of vqm, and q[i] is inferred from those two values.
Analogously, q[i] is also inferred from g,- and gi_1. The server needs
to minimize output because the user reconstructs a part of v from
the server’s output. In this study, we achieve such security require—
ments by a cryptographic technique called oblivious transfer.

112 /310'spaumo [p.IOJXO'SSUBUHOJUTOTQ/ﬁdllq 11101; popeommoq

9IOZ ‘09 lsnﬁnv uo ::

1654

K. Shimizu et al.

 

 

w=mmgn

q=(0}131503,__) qmﬂ] v=(10,10,11,11,...)
ﬁcige
—

 

'—

 

 

 

 

 

 

 

— - X
t‘alfqlittlge] ~. -

q[2]=1
f. ="clfcl
g; =vo[gc]

 

 

—


are] = 1
1:4! git—1

 

—
1'1]sv1[3i'-5]

Fig. 1. Information flow of a search on a recursive search data structure such
as (P)BWT. For ith iteration, the user sends q[i], f,-_1, and g,-_1, the server re-
turns vq[,-][f,-_1] and vq[,-][g,-_1], and the user updates 2‘,- = vq[,-][f,-_1] and
Qi = tii] [gr—1)

2.3.1 Oblivious transfer

Oblivious transfer (OT) is a cryptographic technique for two parties:
the user and the server, and enables the user to specify 0 g t < N and
obtain only tth element of the server’s vector v without leaking any in-
formation about t to the server (Rabin, 1981). Figure 2 illustrates an
outline of the oblivious transfer. Among several efficient algorithms
(Lipmaa, 2005, 2008; Zhang et al., 2013), we used those which are
based on additive homomorphic encryption. The detailed algorithm
will be given in Section 3.2.

2.3.2 Concealing the query

The user’s query consists of  g,], and q[i —I— 1] for ith iteration. A
key idea of our approach is to look—up elements of vc by OT and ob—
tain the next interval (ﬁ+1 : vc gi+1 : vc[g,-]] without revealing 
, g,] to the server. In our approach, we also use a masking technique
such that the user tries vc for all c E Z, and the server only returns
vc where c : q[i —I— 1] without knowing the value of q[i —I— 1].
Technical details will be given in Section 3.2.

2.3.3 Concealing the database

While this approach protects a user’s privacy, the server leaks infor—
mation of vc which may be sufficient to reconstruct parts of the geno—
types in the database. In order to rigorously protect the server’s
privacy, we propose a technique that allows for recursive oblivious
transfer where the user does not learn intermediate results but only if
a unique match was found. It is based on a bit—rotation technique
which enables the server to return f k :2 R(fk) and gk 2: R’ (gk) which

The sewer does not learn t.

   

Fig.2. Outline of Oblivious Transfer (OT). The user (laptop computer) obtains
tth element of the server's vector v without leaking tto the server, and none
of the other elements of the vector v

are random values to the user. Only the server can recover fk and gk
in encrypted form (i.e. the server does not see fk and gk when recover—
ing them), and thus the user can recursively access vc[fk] and vc[gk]
correctly. The details of this approach are given in Section 3.2.

In this work, we designed an algorithm based on these tech—
niques that can be used for privacy—preserving search in large geno-
type databases.

Note that there are still privacy risks for the server, though re-
turning only a unique match minimizes the information leakage
from the server. For example, assume there is a database storing a
genomic study of drug addicts that implements the PBWT—sec, and a
person (Bob) participated in the study. If someone obtains a DNA
sample from Bob and queries the databases, he/she will reveal that
Bob is a drug addict. As described in the above case, there is always
a limitation for protecting the server’s privacy as long as the server
returns the search results, and there is associated information such
as phenotypes (Shringarpure and Bustamante, 2015). We emphasize
that this issue is common for any database search application and is
not specific to our proposed method.

3 Methods
3.1 Additively homomorphic encryption

Our main cryptographic tool in this paper is an additive—homo—
morphic public-key encryption scheme (KeyGen; Enc; Dec), which
enables us to perform additive operations on encrypted values.
Here, the algorithm KeyGen generates a public key pk and a secret
key Sk; Enc(m) denotes a ciphertext obtained by encrypting message
m under the given pk; and DeC(c) denotes the decryption result of
ciphertext c under the given Sk. The scheme also has the following
additive—homomorphic properties:

° Given two ciphertexts Enc(m1) and Enc(m2) of integer messages
m1 and m2, Enc(m1 —1— ing) can be computed without knowing
m1, m2 and the secret key (denoted by Enc(m1)EBEnc(m2)).

° Given a ciphertext Enc(m) of a message m and an integer e, Enc(
e - m) can be computed without knowing m and the secret key
(denoted by e (X) EnC(m)). In particular, EnC(—m) can be com-
puted in this manner.

This scheme should have semantic security; that is, a cipher text
leaks no information about the original message (Goldwasser and
Micali, 1984). For example, we can use either the Paillier cryptosys—
tem (Paillier, 1999) or the ‘lifted’ version of the ElGamal cryptosys—
tem (ElGamal, 1985 ); now the second operation (2) can be realized
by repeating the first operation @.

Figure 3 illustrates an outline of performing an additive operation
on a user’s value m1 and a server’s value Mg by the additively homo—
morphic encryption. In the first step, the user generates two keys: a se—
cret key and a public key, and the user sends the public key to the
server. In the second step, the user encrypts ml by the public key and
sends a ciphertext Enc(m1) to the server. In the third step, the server

112 /810's112umo [p.IOJXO'SOTlBIIlJOJUTOTQ/ﬂClllq 11101; popeommoq

9IOZ ‘09 lsnﬁnv uo ::

Efficient privacy-preserving string search

1 655

 

encrypts Mg by the public key and computes c : Enc(m1 —1— mg).
The server sends a ciphertext c to the user. In the fourth step, the user
obtains m1 —1— ml by decrypting c.

It goes beyond the scope of this paper to review the details of
these cryptographic techniques and the reader is referred to a book
(Yi et al., 2014) on homomorphic encryption. A typical addition op—
eration in the ElGamal cryptosystem takes about 2 X 10T7s on a sin—
gle CPU based on AIST’s ElGamal encryption library (https://github.
com/aistcrypt/Lifted—ElGamal).

3.2 Recursive oblivious transfer by random rotations

To protect the privacy of the database, we propose a technique for
recursively querying a data structure without obtaining information
about intermediate results. Let us define the recursive oblivious
transfer problem as follows:

[Step 1] Key setup [Step 3} Computation of an encrypted result
an: ft“. 311:?

I for :lct'lypilozii
Public key

[for encryptmnjl

 

[Step 2] Query entry

Eﬂfﬂ'ﬂl} X'I'H—T—J
m1 —  _ m

iii1 + m: = De0{0 c = Emir”, + 012 It
[Step £1] Decryption of the encrypted result

| Enc{ili:+iii:J:Enc{iii:,lE|Euc[ru:J ]

_ 2

 

Fig. 3. Computation of m1 + mg on the server in encrypted form by additively
homomorphic encryption

[Step 1] liey setup [Step 3] Computation of an encrypted result

 

 melt

P W k [l'[|]E]-7.ne[ql]}$---$[l'[.'l'}®ETHJIt¢jt-ll
II :I II." E ' ‘ r" 

ll'o-rcntnjr'litioill  “- "' 'r :5 ‘Iﬂ'ﬁ FEW. 1' " F-“H‘Ul :' "‘

Ester :I ﬂ'll-Ill'l' Ila-try i - r = i[f]®Enc{q, l - Encfﬂl

q all ("’3 (EnrterllwrinctetIll -  '-
' :0 11:11 —_n I- 

a] 1?:[lh5~--,‘l‘~_1}]
v[t] = DeC(c) c = Enc(i{t]} '
{Step at] Decryption of the encrypted result

 

Fig. 4. Outline of Oblivious Transfer (OT) based on additive homomorphic en-
cryption. See Sections 2.3 and 3.2 for more details

{a} Genotype matrix K

{b} Positional prefix arrays A

MODEL 1. A user has a private value 0 3 x1 < N and a server has
a private vector v of length N. Let us denote xk+1 : v[xk] and the user
is allowed to access the server E — 1 times. After the calculation, the
user learns only xg and the server learns nothing about x1, . . . ,xg.

Here we explain our idea by extending a simple linear communi-
cation size OT where the user aims to know the tth element of the
server’s vector v.

Figure 4 illustrates the oblivious transfer algorithm based on
additive homomorphic encryption. In the initialization step, the user
generates a public key and a secret key and sends the public key to
the server. The user creates a bit vector:

q:(q0:07---7qt:17"'7qN—1:0)7

and sends the following encrypted vector to the server.

Ehc(q) = (Enc(qo)  ,Enc(qN_1))

The server computes

N—1
C I @150  ® Enc(qi»:

and sends c to the user.

The user computes DeC(c) and obtains v[t] by using the secret
key because i = t :> v[t] ® Enc(qt) : Enc(v[i]) and
i 7E t => v[t] ® Enc(qt) = Enc(0).

Now we consider the case that the server does not leak v[t], but
allows the user to access v[v[t]]. Our idea is that the server generates
a random value r E {0, 1, . . . ,N — 1} and returns the cipher text

N—1
5 = @120 (((Vlil + 0m0d N) ® E00010) = Enc((vltl + 0m0d N):

where (a —I— b)m0d N denotes addition in a number field modulo N.
The user decrypts 8 to know a randomized result (v[t] —I— r)m0d N,
and performs the next query:

51 = (510 = 0:  751((uit]+r)mod N) = 1»  =51N—1 = 0)-
Note that 51 is the r—rotated permutation of the ‘true’ query:
of = (as =0,  ,q;[,] = 1,  ,q’N_1 =0).

Therefore, denote Perm(q, r) as the permutation of a vector q
such that ith element moves to  — r)mOdN))th position, the server

{c} PBWT matrix P

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

querr=1 0 0 1:11 1‘2] [3
1111001010 x1x4x4x4x4x3x3... 10001011"...
t2110100]1 t2x1x1t1r3x1x2... 100101_1_]...
1131000001 x3x2x3x3x1x2x1... 1100000“
x40000111 texexsxzxztexzi... 001101H1
s5101m110 x5x5x2x5x5x5x5... 1001110...

-i'.__,.i’___,... .11.}, -t,:,_,-4___,... .4____.,._, 3,3,... 31131.31.R__,._,
Fig. 5. Outline of the search strategy with PBWT. A set of genotype sequences x = {X1,  ,x5} illustrated in (a) is sorted by the algorithm described in Durbin

(2014) to obtain the positional prefix arrays A illustrated in (b). Each element P,-,,- of PBWT matrix illustrated in (c) is (j+ 1)th letter of sequence A,-,,-. By computing
rank operations with regard to kth query letter on P.,k_1, one can update an interval corresponding to k—mer match between the query and X. In this figure, the
search starts from fourth allele. The first interval (f1, 91] is initialized by rank operations on P3 with regard to first query letter ‘1'. The second interval (f2, 92] is ob-
tained by rank operations on R4 with regard to the second query letter ‘0' and (f1,g1]. Similarly, the third interval (f3,93] is obtained by rank operations on P5
with regard to the third query letter ‘0' and (f2, 92]. See Sections 2.2 and 3.3 for more details

112 /810'S[eumo [p.IOJXO'SOTlBIIlJOJUTOTQ/ﬂClllq 11101; popeommoq

9IOZ ‘09 lsnﬁnv uo ::

1656

K. Shimizu et al.

 

can correctly recover ‘true’ query q’ in its encrypted form by the fol-
lowing permutation: EPtC(q’) : Perm(EP1C(q), r). In this way, the
server correctly computes an encrypted v[t]th element by

N—1
Enc(v[v[t]]) = 09.2., (v[t] ® Enc(qZ-D,

without learning any information about the user’s query.

By recursively applying these calculations, the user can obtain
xk+1 according to Model 1. The complete algorithm implementing
this idea is given in Algorithm 1. It uses a function ROT for rotating
the server’s results to conceal intermediate query results in order to
protect the database.

 

Algorithm 1. Recursive oblivious transfer

 

1 function PrepQuery(t, N)
2 qf(qo=o,...,q,=1,...,qN_1=O)
3 Enc(q) f (Enc(qo),  ,Enc(qN_1))
4 return Enc(q)
5: end function
6
7
8
9

function ROT(EP1C(q), v, r, r’, N)
Enc(q’) =NP1erm(Ehc(q), r)

a = i=0 (((vlz'l + omuN ® Emma)
10: return 8
11: end function
12:
13: v is a server’s private vector of length N.
14: x1 is a user’s private value.
15: xg is the value of user’s interest.
16: E is known to both user and server.
17: User’s initialization: t <— x1
18: Server’s initialization: r’ <— 0
19: Common initialization: i <— 1

20: while i < E do

21: The user computes: Eﬁc(q) <— PrepQuery(t,N)
22: if i =2 (E — 1) then

23: Server sets: r: 0

24: else

25: Server generates random value r

26: end if

27: Server computes: f: <— ROT(EP1C(q), v, r, r’, N)
28: Server sets: r’ <— r

29: Server sends 8 to user

30: User computes: t <— DeC(E)

31: end while
32: User obtains Xg : t.

 

3.3 PBWT-sec: Privacy—preserving search on genotype
databases

In this section, we introduce a practical genotype database search
based on recursive oblivious transfer and PBWT. We only introduce
the algorithm to search for the longest match starting from tth col—
umn, however, variations are possible and would allow for a variety
of different search types (see also Durbin, 2014).

To formulate the problem, let us consider a set X of M haplotype
sequences x,, i: 1,  ,M over N genomic positions indexed by
la : 1,  ,N, and a query q which is a user’s haplotype sequence
over the same N genomic positions. We denote lath allele of a

sequence x,- by x,- Given two indices 131 and 132, we say that there is
a match between q and x,- from 131 to 132, if q[le1]  q[l22 — 1] :
xi[le1] . . . xi[le2 — 1]. We say that the match is set—longest at 131 if there
is no match between q and any sequence x,- (possibly with j: i) from
k1 to [Q -I— 1.

The goal is to find a set—longest match at a given position t be—
tween q and X in a privacy—preserving manner. Here, we consider the
case that the user’s private information is the query string and the
position t is not the user’s private information. We later introduce the
case that the both the query string and t are user’s private informa-
tion. The formal description of the model is described as follows:

MODEL 2. The user is a private haplotype sequence holder, and
the server is a holder of a set of private haplotype sequences. The
user learns nothing but a set-longest match at a given position t be-
tween the query and the database while the server learns nothing
about the user’s query. t is not a user’s private information and the
server knows it.

Let us remember how to search the set—longest match in non—
privacy-preserving manner. PBWT involves a matrix P E NMXN that
stores well—compressible information in an efficiently searchable
form. It is created from the genotype matrix X by algorithms
described in Durbin (2014) such that ith column is (i —I— 1)th letters
of sequences sorted by i reverse prefix (i.e. sorted from ith letter to
first letter). In order to compute the match starting from the first al-
lele, P has 0th column P30 : (x1[1], . . . ,xM[1])T. By using rank dic-
tionary operations on P (see below), one can search a match
between a query and X. When operating on P one computes updates
of intervals using the following two quantities (see Durbin, 2014 for
more details): (i) The rank dictionary for sequence S for letter c E 2
at position t:

RankC(S,t) = |{;‘|S[/'] =c, 1 SiStHa

where Z is the alphabet of S. (ii) The table CF counting occurrences
of letters that are lexicographically smaller than c in S by

CFC(S) = Z Rank,(S, N) .

T<C

Based on these two quantities, we can compute the updates (ka
,ng] using two simple operations

fk+1 : CFC(P-,k) + RankC(P-,kafk)7
gk+1 : CFC(P-,k) + RankC(P-,kagk)7

where we denoted the lath column vector by P.7k. Let us define a

look—up vector vc for the column la where

. CFc(P-,k) (i = 0)

Valli = . . (1)
CFC(P.k) + RankC(P.,k,z) (1 g 2 g M)

7

for c E 2. Then, updating an interval is equivalent to two look—ups
in the vector v5:

fk+1 = Vclfkl and gk+1 = Vclgkl- (2)

Given a position t and a PBWT P of the database sequences, the
first match is obtained as an interval (f1 : vc[0], g1 : vc where c
: q[1] and vc is a look—up vector for (t — 1)th column of P (see the
definition of vc in Equation (1)). The match is extended by one letter
by an update of the interval. The update from the lath interval to
(la —1— 1)th interval is conducted by specifying c : q[le —I— 1], re—com—
puting vc for (la —1— 1)th column of P and referring vc[fk] and vc[gk] as
fk+1 and gk+1 (see Equation (2)). The set—longest—match is found

112 /310's112umo [p.IOJXO'SOTlBIIIJOJUTOTQ/ﬁdllq 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

Efficient privacy-preserving string search

1 657

 

when f = g. An outline of the search using PBWT is illustrated in
Figure 5.

In order to achieve the security described in the model 2, for
each update, the user has to specify c without leaking c to the server,
and obtain only vc[f] and vc [g] without leaking f and g. To satisfy
the second requirement, the user accesses the server’s vc through the
function ROT, which allows the user to obtain a specific element in
the specified vector. To achieve the first requirement, the server
computes all possible intervals (i.e. computing (f, g] for the all case
of c : 0,  ,|Z| — 1). This allows the user to obtain the correct
interval, however, the sever leaks extra information (i.e. intervals
for c 74 q[le]). To avoid this, the user sends Enc(q[le]), and the server
adds a conditional randomization factor r X (q[le] — c) to f and g
with different random value r for all c E Z. Note that this factor be—
comes equivalent to 0 iff. q[le] : c, and user only obtains the interval
for c : q[le].

In order to identify the set—longest match, the user has to know if
f = g. The user cannot compute the identity of f and g directly from
the server’s return, because ROT returns a value which is a random
value to the user (but the ‘true’ value is recovered in encrypted form
only at the server side). Therefore, the server also sends an encrypted
ﬂag d which shows whether or not f = g. Since f and g are repre—
sented as indices of q} : Perm(qf, r’m) and q; : Perm(qg, r’(g)) (see
the functions PrepQuery and ROT), the server computes d by
following:

M
d 2 Giganaa >< (anti — quit»

where r,- is a random value. DeC(d) is equal to 0 iff. qf : qg. See
Supplementary Algorithm S5 which defines a function isLongest. In
addition to finding a set—longest match at t, it is convenient to find a
longest substring which matches to at least 8 sequences. This oper—
ation enables to avoid detecting unique haplotype and provides 8-
anonymity result and is implemented by replacing the function:
isLongest by another function: isLongestGT 8 which computes ﬂags
each of which shows if the interval matches to 0, . . . ,8 — 1 respect—
ively and returns shufﬂed flags, and the user knows the result by
checking if there is a flag which is equal to zero. See Supplementary
Algorithm S5 for more details.
The detailed algorithm of PBWT-sec is shown in Algorithm 2.

3.4 Concealing the search position

By the algorithm introduced above, the match position t needs to be
provided to the server. Let us consider the case that t needs to be
concealed (e.g. the used would not like to reveal which gene is ana—
lyzed). In practical genotype database search, it is often sufficient for
the user to hide t in a set of multiple columns. Therefore, here we as—
sume the following security model.

MODEL 3. The user is a private haplotype sequence holder, and
the server is a holder of a set of private haplotype sequences. The
user has a vector ofD positions T = (t1,  ,tD). The user learns
nothing but a set-longest match at a given position t E {t1, . . . ,tD}
between the query and the database while the server learns nothing
about the user’s query string. The server knows T but cannot iden-
tify which element the user queries.

Conceptually, the user could query multiple positions at the
same time to conceal the search position. In the extreme case the
user would query all search positions to avoid leaking any informa-
tion about t. However, every answered query would leak more in-
formation from the database and querying would become
computationally prohibitive. We therefore propose joint processing

 

Algorithm 2. The detailed description of PBWT—sec ﬁnding a
set—longest match at position t.

 

0 Public input: Problem size M 86 N; alphabet
Z : {0,1,.., |Z| — 1}, start position t E {1,  ,N}
0 Private input of user: A query sequence S of length E
0 Private input of server: PBWT matrix P E NMXN
0. (Key setup of cryptosystem) User generates key pair (pk, sk)
by key generation algorithm KeyGen for additive—homo—
morphic
cryptosystem and sends public key pk to server.
1. (User initialization) Set initial interval  = 0, g = M].
2. (Recursive search)
Initializes query and position index: i <— 1; la <— t — 1
while (i g E) do
a. (Query entry) The user performs the following steps:
0 Prepares next query:
Ehc(qf) <— PrepQuery(f,M + 1)
Ehc(qg) <— PrepQuery(g,M + 1)
o Sends Enc(S[i]), EDC(qf), EDC(qg) to the server.
b. (Search) The server performs the following steps:
0 Compute look—up tables for all c E Z:

 _ CFc(P-,k)  Z 
VG _ CFC(P.,k) + Rank.(P.,t,i) (1 s i s M)

0 Obtain random values rm, r(g)

0 Set r’m : r’(g) : 0 iff. i2:

0 Compute next possible intervals for all c E Z:
a?) (— ROT(Ehc(qf),vc,r(f),r’(f),M)
are e ROT(Ehc(qg), vc, Ag), 14g) , M)

o Randomize return values except for user’s target
interval by computing the following for all c E 2

Generate temporary random values r0, r1
(2:0 e an e Enc(ro >< (S[z‘] — 6))
egg) e egg) e Enc(r1 >< (S[z‘] — 6))

0 Compute an encrypted ﬂag showing if match is longest
d e isLongest (EDC(qf), Enc(qg), W), M)

0 Store random values r’ (f ) <— rm, r’ (g) <— r(g)

0 Send d, e(f),e(g) to the user

c. (Decryption of encrypted ﬂag and randomized
interval)
The user performs the following steps:
if (DeC(d) :2 0)
Sends decoy queries to server until i 2:
Reports result S[1, . . . ,i — 2]

else
Computes f <— Dec(e§],]), g ‘— DeC(eg‘iba
end if
i <— i—]— 1, le <— k + 1
end while

 

using OT that simultaneously uses multiple search positions. Let us
define VC as another look—up vector for a letter c as follows:

CFC(P-,(t,-+k)) + 0i (i = 0)
VclOi +1] 2 { _ ‘
CFc(P-,(t,-+k)) 1‘ Rankc(P (t;+k)7l) ‘l‘ of (1 3”é 0)

'7

where o,- = (j — 1)(M —I— 1) is an offset and la is an index which is ini-
tialized by —1 and incremented by 1 in each iteration of the recursive

112 /§Jo's112umo [p.IOJXO'SOTlBIIIJOJUTOTQ/ﬁ(1111] 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

1658

K. Shimizu et al.

 

search. Note that (Vc[o,-], . . . , Vc[o,- —I— M]) corresponds to vc for tjth
column. The algorithm for the Model 3 is designed by replacing the
lookup tables vc by VC (see Step 2a, item 1 in Algorithm 2) and initi-
alizing f and g by 0,, and Ox —1— M, respectively, where t: tx (see Step
1 in Algorithm 2). As a result the tables get D times larger which has
an impact on computing requirements and data transfer size (see
Section 3.7). We therefore suggest using this algorithm for small D.

3.5 Reducing communication size

As we will describe in the Complexity analysis in the following sec-
tion, the PBWT—sec algorithm using standard OT requires 0(M in
communication size per iteration in the best case, which makes the
core algorithm less practical. We propose to use an algorithm for sub—
linear-communication OT (SC—OT) proposed in Zhang et al. (2013).
Using this approach we can reduce the communication size of PBWT-
sec to O(s/M (best case). Here, we only outline the key ideas of
SC—OT and its adaptation of PBWT—sec. In the SC—OT, the one en—
codes the position t by a two dimensional representation:
to = t/  , t1 : (t)m0d  , where  denotes the ceil of the argu—

ment. The user sends Enc(to) and Ehc(q) to the server, where
Enc(q) = (Enc(qo = 0)  ,Enc(qt1 = 1),,Enc(q[m_1 = 0)).

The server obtains random valuesrk, la : 0, . . . ,  ] — 1, and
computes

WWI—1
a. = ﬂ} <ka x W] + 21 ® Enc<e>>69<e e Enc(to — 0).
i=0
and sends c : (c0, . . . , c m _1) to the user. The user knows the re—

sult by the decryption: DeC(ctO). Note that Enc(to — la) : Enc(O) iff.
t0 : la, therefore the decryption of c,- becomes a random value when
i 75 to.

In order to apply bit—rotation technique naturally to SC—OT, the
server needs to return v[t] in the same two dimensional representa—
tion. The key idea here is that the server creates v0 and v1 where
you] = v[i]/]\/N] and v1[i]:(v[i])mod[m],i: o,  ,N — 1, and
searches on both v0 and v1. Similar to the linear communication size
function ROT, the removable random factors are added to server’s
returns. More details on SC—OT is given in Section S1. The complete
algorithm for privacy—preserving search based on SC—OT is given in
Supplementary and Algorithm S2.

3.6 An exhaustive baseline algorithm

There are a few related works in regard to finding a DNA substring
match (Baldi et al., 2011; Cristofaro et al., 2013), however, the goal
of PBWT—sec is to find the set—longest prefix match from a set of
aligned sequences while those works aim to find a fixed-length ap-
proximate substring match between two sequences. Therefore, we
will compare our algorithm with a baseline algorithm which can
find the set—longest prefix match on the basis of exhaustive enumer—
ation of le—mers. This baseline algorithm serves as a proxy for the
other conceptually similar algorithms.

In order to identify the match, the user queries the server about
the presence of a le—mer. Here, the server stores all le—mers, there are
O(|Z|k) of them, and we use SC—OT. Such a strategy is efficient for
short queries as |Z|k is not too large. However, the resource require—
ments will be dominated by queries for large la and the algorithm
quickly gets intractable.

Table 1. The summary of the time, communication and space com-
plexities of PBWT-sec (CP) and an exhaustive method (EX)is the
length of query and is the alphabet size

 

 

Time Communication Space
CP(uSCr) O(E(/MD|E|) O(E(/MD|Z|) O(t/MD|E|)
CP(server) O(EMD|Z|) O(E MD|E|) O(MD|E|)
EX(user) 0( DW) 0((/D|2|() 0( D|Z|e)
EX(server) 0(D|2|() 0( D|Z|e) 0(D|2|()

 

Both algorithms use SC-OT. M is the number of haplotype sequences (server
side), D is the number of queried positions (including D — 1 decoy position to
conceal the query position), E is the length of query and lil is the alphabet size.

3.7 Complexity

Most of the computing and transfer on server and user side is related
to the encryption/decryption and the computational cost of the
search is negligible. While PBWT requires essentially (9(1) to update
the intervals per iteration, PBWT—sec needs to conceal the query and
requires M |Z| operations on the server, where M is the number of se—
quences in the database and |Z| is the size of the alphabet. When
multiple queries are performed at the same time, i.e. D > 1, the ef—
fort increases linearly in D, i.e. the server sides compute effort is O(
MD|Z|) per iteration. When using SC—OT, the communication size
and effort for the user is  (see Section 3.5 and
Supplementary Section S1 for details).

Table 1 summarizes the time, data transfer overhead and space
complexities of the PBWT—sec, when the server’s PBWT is M x N
matrix consisting of a set of alphabet letters 2 and the user’s query
length is E and the number of queries positions is D (including D — 1
decoy positions; see Section 3.4 for details). For the purpose of com—
parison, we consider the method outlined in Section 3.6 that
achieves the same security and utility as PBWT—sec. Since the com—
plexity of the exhaustive approach is exponential to the query
length, its performance deteriorates quickly for long matches. On
the other hand, the time and data transfer overhead complexity of
the PBWT—sec are linear and sub—linear to the query length, which
enables the user to find a long match efficiently.

3.8 Security notion

In this paper, we assume the security model called Semi-honest model
where both parties follow the protocol, but an adversarial one at—
tempts to infer additional information about the other party’s secret
input from the legally obtained information. The semantic security of
the encryption scheme used in the protocol (see Section 3.1) implies
immediately that the server cannot infer any information about the
user’s query q during the protocol. Also, the user cannot infer any in-
formation about server’s return except for the result.

Another security model is called Malicious model where an adver—
sarial party cheats even in the protocol (e.g. by inputting maliciously
chosen invalid values) in order to illegally obtain additional informa-
tion about the secret. Here we brieﬂy describe one example of an illegal
access based on the Malicious model. In our protocol, the user needs to
create a bit vector q of N that includes a bit that is 1 and the rest of the
N — 1 bits are 0. If the malicious user creates a non—bit vector:

61k: x
0 (MAM/e741)

where x is a large integer, the server returns c : Enc(v[i] —I— x - 
When x is larger than any element of v, the user can infer v[i] by

112 /§Jo's112umo [p.IOJXO'SOTlBIIIJOJUTOTQ/ﬁ(1111] 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

Efficient privacy-preserving string search

 

(DeC(c))mod x and  by DeC(c)/x. (For example, if x: 100 and
DeC(c) : 821, the user can detect v[i] : 21 and  = 8.) Thus the
server leaks two elements of v by a single query.

In this study, we do not discuss such cases in detail; however, we
would like to mention that it is possible to design an algorithm for
the Malicious model with a small modification. In order to avoid
such attacks, the server needs to verify if the user sends a bit vector
which includes only one bit that is 1 and rest of the bits are 0. To
achieve this, we suggest using a cryptographic technique called Non—
Interactive Zero Knowledge Proofs which enables the user to con—
vince a server that each ciphertext Enc(m) corresponds to a value In
E {0, 1}, but does not leak any information about which of 0 and 1
is m. Among several algorithms, Sakai’s algorithm (Sakai et al.,
2013) has such a property. By using the algorithm, the server knows
whether or not q[i] E {0, 1}. To return a correct result only if q in-
cludes only a single 1, it is sufficient for the server to add w = r (X) (
Enc(q0)EB . .. EBEnC(qN_1)EBEnC(—1)) to the original result,
where r is a random value. Note that w : Enc(O) iff. q): 1 and
qj:0for0 §j<Nandi7éi

4 Experiments

In this section, we evaluate the performance of the proposed method
on the datasets created from the chromosome 1 data from the 1000
Genomes Project phase 1 data release which consists of 2184 hap—
loid genomes (The 1000 Genomes Project Consortium, 2012). In
our experiments and as in Durbin (2014), we used alleles having
SNPs, but we did consider indel variants. We used all 2184 genomes
of original data for all the experiments.

We implemented the proposed algorithm in C—i——i— based on an
open source C —i——i— library of elliptic curve ElGamal encryption pro-
vided by AIST. Our implementation supports communication over
the network. We used the standard parameters called secp192k1
(SECG curve over a 192—bit prime field), according to the recom—
mendation by The Standards for Efficient Cryptography Group. For
comparison, we also implemented an exhaustive baseline method
(see Section 3.6) that achieves the same security and utility as
PBWT—sec. In order to perform a fair comparison, both PBWT—sec
and the exhaustive method used the same SC—OT module where
computation of ck (see Algorithm 1) is simply parallelized by
OpenMP.

In the first experiment, the user selected a true start position to—
gether with 49 decoys (see Section 3.4 for details), and both PBWT—
sec and the exhaustive method were run with the same computa—
tional setting: the user used a single thread of a laptop computer
equipped with an Intel Core(TM) i7 3.00 GHz CPU and 16 GB
memory, and the server used more than eight threads of another lap—
top equipped with an Intel Core(TM) i7 2.60 GHz CPU (four cores
with hyper-threading) and 8 GB memory. Those two computers
communicated over the network.

Figures 6 and 7 show run time and data transfer overhead of
PBWT—sec and of the exhaustive method. The observed run time
and data transfer size of PBWT—sec is linear in the query length,
while that of the exhaustive approach is exponential. For query
lengths larger than 30 bit, the computation of the exhaustive method
did not finish within 24 h. These results fit the theoretical complex—
ity described in Section 3.7. We also evaluated performance of the
runtime of PBWT—sec when the user selected 0, 4, 9, 14, and 49 add—
itional decoy positions. The search with a typical query of length 25
SNP positions and no decoy required no more than 15.5 s including
communication overhead (Table 2).

 

 

 

 

 

 

1659
10000 _ . I I I I I I I I
- O
1000 .— H _
g 100 :— >< X 0 + 
if; _I_ Q + + +
a) +
E 10 e + D _
e + o
E ' e -
1 I— o PBWT-eps (user) + f
e PBWT-eps (server) ><
' O Crypto PBWT (all)
0'1 5' m Exhaustive (user) 0 -.
k: Exhaustive (server) '
- Exhaustive all 0 -
0.01 ' ' '

 

1 5 1O 15 2O 25 3O 35 4O 45 50
Query length (bit)

Fig. 6. Run time of PBWT-sec and the exhaustive method on 2184 aligned
haploid genomes on laptop computers equipped with four cores. The user se-
lected 49 decoy positions for concealing the true query position. The server
used all of the four cores with hyper-threading while the user used a single
thread. ‘PBWT-sec (all)’ and ‘Exhaustive (all)’ include communication
overhead

 

 

 

 

 

 

 

 

 - | | | | | | | | |
’07 ' 3K 36
a. 10000 .— g x 9" ’K __
.0 x 9K
5, ' ale
'0 ' >l<
8 1000 .— E —
-E _
G.)
a ’5 a _
.93 100 _— __
e - a -
S
*3 10 _— ﬁ PBWT-sec (user to server) + —_
o - PBWT-sec (server to user) ><
E3 Exhaustive (user to server) >i<
I I I EthausthI/e (seIrverth) userI) DI
I

 

151015 20 25 30 35 40 45 50
Query length (bit)

Fig. 7. Data transfer overhead of PBWT-sec and the exhaustive method on
2184 aligned haploid genomes on laptop computers. The user selected 49
decoy positions for concealing the true query position

Table 2. The run time of a typical query of length 25 SNP positions
with PBWT-sec on M22184 aligned haploid genomes on laptop
computers equipped with four cores

 

 

User Server All
Run time (sec) with D = 1 4.55 10.8 15.5
Run time (sec) with D = 5 8.77 34.0 43.0
Run time (sec) with D : 10 12.5 65.3 78.0
Run time (sec) with D = 20 17.3 124 142
Run time (sec) with D = 50 27.5 311 339

 

The server used all the four cores with hyper-threading while the user used
a single thread. All included communication overhead. D is the number of
positions queried simultaneously to conceal the query position (if required).

The user’s run time of PBWT-sec is relatively small, making it
suitable for a practical case where computation power in a server
side is generally stronger than that of user side. Since the memory
usage of PBWT—sec does not depend on query length, it uses less

112 /810's112umo [p.IOJXO'SOTlBIIIJOJUiOTQ/ﬁdllq 111011 pop1201umoq

9IOZ ‘09 lsnﬁnv uo ::

1660

K. Shimizu et al.

 

Table 3. The run time of a typical query with PBWT-sec on
M22184 aligned haploid genomes on a compute node with up to
16 cores with hyper-threading and a query length of 25 SNP
positions

 

 

Parallel Compute Cores 4 8 16

Run time (sec) with D : 1 22.6 15.5 7.9
Run time (sec) with D = 5 47.3 40.0 18.4
Run time (sec) with D = 10 84.5 68.4 31.6
Run time (sec) with D : 20 154 114 56.5
Run time (sec) with D = 50 386 260 132.6

 

Wall time includes server (z 90%) and user time (x 10%). D is the num-
ber of positions queried simultaneously to conceal the query position (if
required).

than 60 MB while that of the exhaustive method exponentially in-
creases according to the query length and required 6 GB when the
query length is 25 bit.

Although the exhaustive method is efficient for short queries, we
consider that PBWT—sec is more practical when taking into account
that the bit length of a unique substring for a human genome is
greater than 31 bits. Moreover, since there are large linkage blocks,
even queries with more than 100 bits would not always lead to
unique matches in the 1000 genomes data. Hence, the exhaustive
search strategy would either not always be able to return a unique
match or would be very inefficient. The proposed iterative privacy—
preserving technique is efficient also for long queries.

In the second experiment, we evaluated the performance of the
run time of PBWT—sec on a compute node equipped with four CPU
sockets (Intel Xeon 2.40 GHz CPU; total of 32 cores with hyper—
threading). In this experiment, the user also selected 0, 4, 9, 14 and
49 additional decoy positions. For environmental reasons, we did
not perform communication over the network and the data was
transferred by file I/O which is also included in run time.

Although the current implementation is a prototype and there is
room for improvement in terms of parallelization, the server’s run
time was at an acceptable level in practical configurations (Table 3).
We note, that with improvements in parallelization, the server run
time may be reduced to 3—4 s.

5 Conclusion

In this paper, we have proposed a novel approach for searching gen—
omic sequences in a privacy—preserving manner. Our approach com—
bines an efficient data structure that can be used for recursive search
and a novel approach for recursive oblivious transfer. It achieves
high utility and has strong security features and requires acceptable
compute and communication resources.

The developed novel algorithm can find the longest match be—
tween a query and a large set of aligned genomic sequences indexed
by PBWT. We implemented our algorithm and tested on the dataset
created from the 1000 Genomes Project data (The 1000 Genomes
Project Consortium, 2012). Compared to an exhaustive baseline ap—
proach, our algorithm, named PBWT—sec, was orders of magnitude
more efficient both in run time and data transfer overhead for prac—
tical query sizes. When the prototype program was run on laptop
machines, the total run time including communication time over the
network was 15 .5 s for searching on 2184 genomes without conceal—
ing the query position. Searches with a concealed query position
using a compute node took between 18.6 and 133 s depending on
the level of privacy.

As the original data structure supports many useful search op—
tions such as wild card search and set maximal search, PBWT—sec
could also support those options by using the same techniques used
in the original structures in combination with cryptographic tech—
niques, including OT. Moreover, the approach could be easily
applied for BWT and has a potential to be applied for other recur—
sively searchable data structures.

To the best of our knowledge, the proposed algorithm is the first
that allows set—maximal search of genomic sequences in a privacy—
preserving manner for user and database. We note that the imple—
mentation can still be improved and the overall run time can likely
be reduced to not more than a few seconds per query. This would
make it practical to use our approach in a genomic Beacon (see
GA4GH’s Beacon Project) that would allow the privacy—preserving
search for combinations of variants. It also appears practical to use
our approach to enable search by a user that has access to his/her
genomic sequence and would like to query the database, for in—
stance, for information related to disease risk without sharing this
information with anybody. Finally, the algorithm can also be used
to facilitate sharing of genetic information across institutions and
countries in order to identify large enough cohorts with a similar
genetic backgrounds. This is in spirit of the mission of the Global
Alliance for Genome and Health.

Acknowledgements

We are thankful to Stephanie L. Hyland for proof-reading the manuscript.
We would also like to acknowledge an encouraging discussion with Richard
Durbin. We are grateful to the reviewers for their detailed comments that sig-
niﬁcantly improved the manuscript.

Funding

We gratefully acknowledge funding from AIST (to KS), Memorial Sloan
Kettering Cancer Center (to GR.) and NIH (grant 1R01CA176785-01A1).
This study was also supported by the Japan-Finland Cooperative Scientiﬁc
Research Program of Japan Science and Technology Agency (JST; to KS).

Conﬂict of Interest: none declared.

References

Altschul,S.F. et al. (1990) Basic local alignment search tool. ]. Mol. Biol., 215,
403—410.

Ayday,E. et al. (2013) Privacy-preserving processing of raw genomic data. In:
Data Privacy Management and Autonomous Spontaneous Security — 8th
International Workshop, DPM 2013, and 6th International Workshop,
SETOP 2013, Egham, UK, September 12—13, 2013, Revised Selected
Papers, pp. 133—147.

Baldi,P. et al. (2011) Countering GATTACA: efﬁcient and secure testing of
fully-sequenced human genomes. In: Proceedings of the 18th ACM
Conference on Computer and Communications Security, CCS 2011,
Chicago, Illinois, USA, October 17—21, 2011, pp. 691—702.

Blanton,M. and Aliasgari,M. (2010) Secure outsourcing of DNA searching Via
ﬁnite automata. In: Data and Applications Security and Privacy XXIV, 24th
Annual IFIP WG 11.3 Working Conference, Rome, Italy, june 21—23,
2010, Proceedings, pp. 49—64.

Bruekers,F. et al. (2008) Privacy-preserving matching of DNA proﬁles. IACR
Cryptol. ePrint Arch., 2008, 203.

Cristofaro,E.D. et al. (2013) Secure genomic testing with size- and position-
hiding private substring matching. In: Proceedings of the 12th annual ACM
Workshop on Privacy in the Electronic Society, WPES 2013, Berlin,
Germany, November 4, 2013, pp. 107—118.

112 /810's112umo IpJOJXO'SOIlBIHJOJUIOIQ/ﬁdllq 111011 pop1201umoq

9IOZ ‘09 isnﬁnv uo ::

Efficient privacy-preserving string search

1661

 

Durbin,R. (2014) Efﬁcient haplotype matching and storage using the pos-
itional Burrows—Wheeler transform (PBWT). Bioinformatics, 30,
1266—1272.

ElGamal,T. (1985) A public key cryptosystem and a signature scheme based
on discrete logarithms. IEEE Trans. Inf. Theory, 31, 469—472.

Erlich,Y. and Narayanan,A. (2014) Routes for breaching and protecting gen-
etic privacy. Nat. Rev. Genet., 15, 409—421.

Freedman,M.]. et al. (2005) Keyword search and oblivious pseudorandom
functions. In: Theory of Cryptography, Second Theory of Cryptography
Conference, TCC 2005, Cambridge, MA, USA, February 10—12, 2005,
Proceedings, pp. 303—324.

Goldwasser,S. and Micali,S. (1984) Probabilistic encryption. ]. Comput. Syst.
Sci., 28, 270—299.

He,D. et al. (2014) Identifying genetic relatives without compromising priv-
acy. Genome Res, 24, 664—672.

Jacobson,G.J. (1988) Succinct static data structures. Ph.D. thesis, Carnegie
Mellon University Pittsburgh, PA, USA. ACM Order number AAI891 8056.

Jha,S. et al. (2008) Towards practical privacy for genomic computation. In:
IEEE Symposium on Security and Privacy, pp. 216—230.

Kent,W.]. (2002) BLAT — the BLAST-Like Alignment Tool. Genome Res., 12,
65 6—664.

Langmead,B. et al. (2009) Ultrafast and memory-efﬁcient alignment of short
DNA sequences to the human genome. Genome Biol., 10, R25.

Li,H. and Durbin,R. (2009) Fast and accurate short read alignment with
Burrows—Wheeler transform. Bioinformatics, 25, 1754—1760.

Li,H. and Homer,N. (2010) A survey of sequence alignment algorithms for
next-generation sequencing. Brieﬁngs Bioinf., 11, 473—483.

Li,R. et al. (2009) Soap2: an improved ultrafast tool for short read alignment.
Bioinformatics, 25, 1966—1967.

Lipmaa,H. (2005 ) An oblivious transfer protocol with log-squared communi-
cation. In: Information Security, 8th International Conference, ISC 2005,
Singapore, September 20—23, 2005, Proceedings, pp. 314—328.

Lipmaa,H. (2008) New communication-efﬁcient oblivious transfer protocols
based on pairings. In: Information Security, 11th International Conference,
ISC 2008, Taipei, Taiwan, September 15—18, 2008. Proceedings,
pp. 441—454.

Naganuma,K. et al. (2012) Private string search using the blocksorting algo-
rithm. In: The Proceedings of SCIS 2012 (In japanese).

Paillier,P. (1999) Public-key cryptosystems based on composite degree resi-
duosity classes. In: Proceedings of the 17th international conference on
Theory and application of cryptographic techniques, EUROCRYPT’99, pp.
223—238.

Rabin,M.O. (1981) How to exchange secrets with oblivious transfer. Technical
Report 81, Harvard University.

Roche,P.A. and Annas,G.]. (2001) Protecting genetic privacy. Nat. Rev.
Genet., 2, 392—396.

Sakai,Y. et al. (2013) Methods for restricting message space in public-key en-
cryption. IEICE Trans., 96-A, 1 156—1 168.

Shringarpure,S.S. and Bustamante,C.D. (2015) Privacy risks from genomic
data-sharing beacons. Am. ]. Hum. Genet., 97, 631—646.

The 1000 Genomes Project Consortium (2012) An integrated map of genetic
variation from 1,092 human genomes. Nature, 491, 5 6—65 .

Yi,X. et al. (2014) Homomorphic Encryption and Applications. Springer
Briefs in Computer Science. New York: Springer.

Zhang,B. et al. (2013) Practical fully simulatable oblivious transfer with sub-
linear communication. In: Financial Cryptography and Data Security — 17th
International Conference, FC 2013, Okinawa, japan, April 1—5, 2013,
Revised Selected Papers, pp. 78—95.

112 /810's112umo IpJOJXO'SOIlBIHJOJUIOIQ/ﬁdllq 111011 pop1201umoq

9IOZ ‘09 isnﬁnv uo ::

