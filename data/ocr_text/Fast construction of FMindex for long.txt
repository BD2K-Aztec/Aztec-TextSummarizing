APPLICA TIONS NOTE V°" 3%.iigiiliiﬁéiiiiféﬁiiﬁ

 

Sequence analysis

Advance Access publication August 8, 2014

Fast construction of FM-index for long sequence reads

Heng Li

Medical Population Genetics Program, Broad Institute, 75 Ames Street, Cambridge, MA 02142, USA

Associate Editor: Michael Brudno

 

ABSTRACT

Summary: We present a new method to incrementally construct the
FM-index for both short and long sequence reads, up to the size of a
genome. It is the first algorithm that can build the index while implicitly
sorting the sequences in the reverse (complement) lexicographical
order without a separate sorting step. The implementation is among
the fastest for indexing short reads and the only one that practically
works for reads of averaged kilobases in length.

Availability and implementation: https://github.com/lh3/ropebwt2
Contact: hengli@broadinstitute.org

Received on June 2, 2014; revised on July 15, 2014; accepted on
August 4, 2014

1 INTRODUCTION

F M-index plays an important role in DNA sequence alignment,
de novo assembly (Simpson and Durbin, 2012) and compression
(Cox et al., 2012). Fast and lightweight construction of FM-
index for a large dataset is the key to these applications.
In this context, a few algorithms (Bauer et al., 2013; Liu et al.,
2014) have been developed that substantially outperform earlier
algorithms. However, they are only efﬁcient for short reads.
A fast and practical algorithm for long sequence reads is still
lacking. This work aims to ﬁll this gap.

2 METHODS

Let 2={A, C, G, T, N} be the alphabet of DNA with a lexicographical
order A<C <G<T <N. Each element in 2 is called a symbol and a se-
quence of symbols called a string over 2. Given a string P, |P| is its length
and P[i_| the symbol at position i. A sentinel $ is smaller than all the other
symbols. For simplicity, we let P[—1]= P[|P|] = $. We also introduce P as
the reverse of P and P as the reverse complement of P.

Given a list of strings over 2, (Pi)OSl-<m, let T = P0$0...Pm_1$m_1
with $o< --- <$m_1<A<C<G<T<N. The suﬂix array of Tis an inte-
ger array S such that S(i), 0 5 i< |T|, is the starting position of the i-th
smallest sufﬁx in the collection T. The Burrows— Wheeler Transform, or
BWT, of T can be computed as B[i_| = T[S(i) — 1]. For the description of
the algorithm, we segment B into B= B$BABCBGBTBN, where Ba[i_| = B[i
+ C(a)] with C(a) = |{j : TD] < a}| being the array of accumulative counts.
By the deﬁnition of sufﬁx array and BWT, Ba consists of all the symbols
with their next symbol in T being a.

The above deﬁnes BWT for an ordered list of strings. We next seek to
deﬁne BWT for an unordered set of strings C by imposing an arbitrary
sorting order on C. We say list (Pi),- is in the reverse lexicographical order
or RLO, if P,- 5 Pj for any i < j; say it is in the reverse-complement lex-
icographical order or RCLO, if P,- 5 Pj for any i < j. The RLO-BWT of C,
denoted by BRLO(C), is constructed by sorting strings in C in RLO and
then applying the procedure in the previous paragraph on the sorted
list. RCLO-BWT BRCLO(C) can be constructed in a similar way.

In BRCLO ({Pi}, U {Pj}j), the k-th smallest sequence is the reverse comple-
ment of the k-th sequence in the FM-index. This property removes the
necessity of keeping an extra array to link the rank and the position of a
sequence in the FM-index, and thus helps to reduce the memory of some
FM-index—based algorithms (Simpson and Durbin, 2012). For short
reads, RLO/RCLO-BWT is also more compressible (Cox et al., 2012).

As a preparation, we further deﬁne two string operations: rank(c, k; B)
and insert(c, k; B), where rank(c, k; B) = |{i<k : B[z] = c}| gives the
number of symbols c before the position k in B, and insert(c, k; B) inserts
symbol c after k symbols in B with all the symbols after position k shifted
to make room for c. We implemented the two operations by representing
each BC in a B + -tree in memory, where a leaf keeps a run-length encoded
string and an internal node keeps the count of each symbol in the leaves
descended from the node.

Algorithm 1 appends a string to an existing index by inserting each of
its symbol from the end of P. It was ﬁrst described by Chan et al. (2004).
Algorithm 2 constructs RLO/RCLO-BWT in a similar manner to
Algorithm 1 except that it inserts P[i_| to [l, a), the sufﬁx array interval
of P’s sufﬁx starting at i + 1, and that BWT symbols in this interval are
already sorted. This process implicitly applies a radix sort from the end of
P, sorting it into the existing strings in the BWT in RLO/RCLO. Note
that if we change line 1 to “l <— a <— |{i : B[i_| = $}|”, Algorithm 2 will be
turned into Algorithm 1. Recall that the BCR algorithm (Bauer et al.,
2013) is, to some extent, the multi-string version of Algorithm 1.
Following similar reasoning, we can extend Algorithm 2 so as to insert
multiple strings at the same time, which gives Algorithm 3. We use an
array A(j) to keep the state of the j-th sequence after inserting its d—long
sufﬁx. At line 2, AU).c is the previously inserted symbol and [A(i).l, A(]')
.u) is the interval to which the new symbol is inserted. In implemen-
tation, we may speed up the sorting mode by inserting multiple symbols
at line 3.

When B is represented by a balanced tree structure, the time complex-
ity of all three algorithms is 0(n log n), where n is the total number of
symbols in the input. However, we will see later that for short strings,
Algorithm 3 is substantially faster than the ﬁrst two algorithms, due to
the locality of memory accesses, the possibility of cached B + -tree update
and the parallelization of the ‘for’ loop at line 1. These techniques are
more effective for a larger batch of shorter strings.

Disregarding RLO/RCLO, Algorithm 3 is similar to BCR except that
BCR keeps B in monolithic arrays. As a result, the time complexity
of BCR is 0(nl), where l is the maximum length of reads, not scaling
well to l.

 

Algorithm 1: Append one string

Input: A string P and an existing BWT B for T
Output: BWT for TP$

Function INSERTIO 1 (B, P) begin
c<—$;k<— |{i:B[i] =$}|
fori <— |P| — 1to —1 do

L insert(P[z'], k2; BC)

 

k: (— rank(P[i], k; BC) + Za<c  3 BaU] = 
c <— 
return B

 

 

3274 © The Author 2014. Published by Oxford University Press. All rights reserved. For Permissions, please e—mail: journals.permissions@oup.com

1e [3.10811211an[plOJXO'SODBIIIJOJIIIOIQ/[idllq wort pepeolumoq

910K ‘09 lsnﬁnV no :2

Fast construction of FM-index

 

 

Algorithm 2: Insert one string to RLO/RCLO-BWT

Input: BRLO (C) (or BRCLO (C)) and a string P
Output: BRL0(C u {P}) (or BRCLO(C u {P}))

Function INSERTRLOI (B, P, is_comp) begin
1 mu) 4 [0, is = Biil = $}l)
fort <— |P| — 1to —1 do
L [l, u) <—INSERTAUX(B, P[i], l, u, P[z' + 1], is_comp)
_ return B
Function INSERTAUX(B, c’, l, u, c, is_comp) begin
k <— l
if is_comp is true and c’ 75 “N” then
fora = $0rc’ < a < “N” do
L L k <— k + [rank(a, u; BC) — rank(a, l; 36)]

 

else
for $ S a < c’ do
L k <— k + [rank(a, 11.; BC) — rank(a, l; 36)]

l’ <— rank(c’,l; BC); u’ <— rank(c’,u; BC)
insert (0’ , k; BC)

m <— Za<c Hi I Bali] = C'}|
return [l’ + m,u’ —l— m)

 

 

 

Algorithm 3: Insert multiple strings

Input: Existing BWT B and a list of strings {Pk}k
Output: Updated BWT B with strings inserted in the speciﬁed order

 

Function INSERTMULTI(B, {Pk}k, is sorted, is_comp) begin
f0P0 S j < |{Pk}lc| ‘10

A(j).c <— $; A(j).i <— j

if is_s0rted is true then

I_ [A(j)-l,A(j)-U) <— [0, Hi I Bli] = $}|)

else
|_ A(j).l (- A(j).u <— |{i : B[z'] = $}| +j
d <— 0
while |A| 75 0 do
1 Stable sort array A by A(-).c
2 for0§j<|A|do

c <— A(j).c; A(j)-C <— PA(j).iI|PA(j).i| — 1 — d]
[Am-l, AUX“)

 

3 <—INSERTAUX(B, A(j).c, A(j).l, A(j).u, c, is_comp)
Remove A(j) ifA(j).c = $
d <— d + 1
_ return B

 

3 RESULTS AND DISCUSSION

We implemented the algorithm in ropeBWT2 and evaluated its
performance together with BEETL (http://bit.ly/beethH), the
original on-disk implementation of BCR and BCRext,
ropeBWT-BCR (https://github.com/lh3/ropebwt), an in-
memory reimplementation of BCR by us, and NVBio (http://
bit.ly/nvbioio), a GPU-based algorithm inspired by CXl (Liu
et al., 2014). Table 1 shows that for ~100 bp reads, ropeBWT2
has comparable performance to others. For the ~875 bp Venter
dataset, NVBio aborted due to insufﬁcient memory under vari-
ous settings. We did not apply BCR because it is not designed for

Table 1. Performance of BWT construction

 

 

Dataa Algorithm RCLO Real CPU% RAMb Comments
(GB)
worm nvbio — 316 s 138 12.9 See note0
worm ropebwt-bcr — 480 s 223 2.2 -thRf
worm Algorithm 3 Yes 506 s 250 10.5 -erm10g
worm Algorithm 3 No 647 s 249 1 1.8 -me10g
worm beetl-bcr — 965 s 259 1.8 RAM diskd
worm beetl-bcr — 2092 s 122 1.8 Network6
worm Algorithm 1 — 5125 s 100 2.5 -me0
worm beetl-bcrext — 5900 s 48 0.1 Network6
12 878 ropebwt-bcr — 3.3 h 210 39.3 -thRf
12 878 nvbio — 4.1 h 471 63.8 See notef
12 878 Algorithm 3 Yes 5.0 h 261 34.0 -erm10g
12 878 Algorithm 3 No 5.1 h 248 60.9 -me10g
12 878 beetl-bcr — 11.2 h 131 31.6 Network6
Venter Algorithm 3 Yes 1.4 h 274 22.2 -erm10g
Venter Algorithm 3 No 1.5 h 274 22.8 -me10g
mol Algorithm 3 No 6.8 h 285 20.0 -me10g

 

aDatasets—worm: 66M X 100 bp Caenorhabditis elegans reads from SRR065390;
12878: 1206M X 101 bp human reads for sample NA12878 (Depristo et al., 2011).
Venter: 32M X 875 bp (in average) human reads by Sanger sequencing (Levy et al.
2007; http://bit.ly/levy2007); mol: 23M X 4026 bp (in average) human reads by
Illumina’s Moleculo sequencing (http://bit.ly/moll2878).

bHardware—CPU: 48 cores of Xeon E5-2697v2 at 2.70GHz; GPU: one Nvidia
Tesla K40; RAM: 128 GB; Storage: Isilon IQ 72000x and X400 over network.
CPU time, wall-clock time and peak memory are measured by GNU time.

0Run with option ‘-R -cpu-mem 4096 -gpu-mem 4096’. NVBio uses more CPU and
GPU RAM than the speciﬁed.

dResults and temporary ﬁles created on in-RAM virtual disk ‘/dev/shm’.

6Results and temporary ﬁles created on Isilon’s network ﬁle system.

fRun with option ‘-R -cpu-mem 48000 -gpu-mem 4096’.

long reads of unequal lengths. Only ropeBWT2 works with this
data set and the even longer moleculo reads.

Funding: NHGRI U54HG003037; NIH GM100233.

Conﬂict of Interest: none declared.

REFERENCES

Bauer,M.J. et al. (2013) Lightweight algorithms for constructing and inverting the
BWT of string collections. T heor. Comput. Sci, 483, 134—148.

Chan,H.-L. et al. (2004) Compressed index for a dynamic collection of texts. In:
Sahinalp,S.C. Muthukrishnan,S. and Dogruséiz,U. (eds) CPM, Volume 3109 of
Lecture Notes in Computer Science. Springer, Berlin Heidelberg, pp. 445—456.

Cox,A.J. et al. (2012) Large-scale compression of genomic sequence databases with
the burrows-wheeler transform. Bioinformatics, 28, 1415—1419.

Depristo,M.A. et al. (2011) A framework for variation discovery and genotyping
using next-generation DNA sequencing data. Nat. Genet., 43, 491—498.

Levy,S. et al. (2007) The diploid genome sequence of an individual human. PLoS
Biol, 5, e254.

Liu,C.-M. et al. (2014) GPU-accelerated BWT construction for large collection of
short reads. arXiv:1401.7457.

Simpson,J.T. and Durbin,R. (2012) Efﬁcient de novo assembly of large genomes
using compressed data structures. Genome Res, 22, 549—556.

 

3275

112 [3.10811211an[plOJXO'SODBIIIJOJIIIOIQ/[idllq wort pepeolumoq

910K ‘09 lsnﬁnV uo :2

