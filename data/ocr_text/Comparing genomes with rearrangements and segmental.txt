Bioinformatics, 31, 2015, i329—i338
doi: 10.1093/bioinformatics/btv229
ISMB/ECCB 2015

 

Comparing genomes with rearrangements and
segmental duplications
Mingfu Shao* and Bernard M.E. Moret*

School of Computer and Communication Sciences, EPFL, CH-1015, Lausanne, Switzerland

*To whom correspondence should be addressed.

Abstract

Motivation: Large-scale evolutionary events such as genomic rearrangements and segmental du-
plications form an important part of the evolution of genomes and are widely studied from both
biological and computational perspectives. A basic computational problem is to infer these events
in the evolutionary history for given modern genomes, a task for which many algorithms have
been proposed under various constraints. Algorithms that can handle both rearrangements and
content-modifying events such as duplications and losses remain few and limited in their
appHcaany.

Results: We study the comparison of two genomes under a model including general rearrange-
ments (through double-cut-and-join) and segmental duplications. We formulate the comparison as
an optimization problem and describe an exact algorithm to solve it by using an integer linear pro-
gram. We also devise a sufficient condition and an efficient algorithm to identify optimal substruc-
tures, which can simplify the problem while preserving optimality. Using the optimal substructures
with the integer linear program (ILP) formulation yields a practical and exact algorithm to solve the
problem. We then apply our algorithm to assign in-paralogs and orthologs (a necessary step in
handling duplications) and compare its performance with that of the state-of-the-art method
MSOAR, using both simulations and real data. On simulated datasets, our method outperforms
MSOAR by a significant margin, and on five well-annotated species, MSOAR achieves high accur-

 

acy, yet our method performs slightly better on each of the 10 pairwise comparisons.
Availability and implementation: http://lcbb.epf|.ch/softwares/coser.

Contact: mingfu.shao@epfl.ch or bernard.moret@epfl.ch

 

1 Introduction

In addition to the point mutations (single base-pair substitutions, in-
sertions and deletions), in the course of evolution, genomes also
undergo many large-scale events, which are usually divided into two
categories, rearrangements and content-modifying events. Genome
rearrangements include inversions, transpositions, circularizations
and linearizations, all of which act on a single chromosome, and
translocations, chromosomal fusions and fissions, which act on two
chromosomes. Rearrangements can shuffle the order and switch the
transcriptional orientations of the genes on chromosomes but can-
not change the number of gene copies. On the other hand, the con-
tent-modifying events, which include segmental duplications,
tandem duplications, gene insertions and losses, can affect the copy
number of the genes. These two types of large-scale events are ubi-
quitous in the tree of life and have been shown playing a very im-
portant role in the variations of the individual traits. The molecular
mechanisms behind them, although have been widely studied, are
still very diverse [see Gu et al. (2008) for a review].

©The Author 2015. Published by Oxford University Press.

One basic task of comparative genomics is to infer the events
took place in the evolutionary history for the extant species. Many
combinatorial optimization problems aiming to compute the most
parsimonious number of events between two given genomes (i.e. the
edit distance) are formulated, and many algorithms, heuristics or
exact ones, are proposed for them. When only rearrangement events
are considered, Hannenhalli and Pevzner (1995) gave the first poly-
nomial-time algorithm to compute the inversion distance, which
was later improved to linear time (Bader et al., 2001). Yancopoulos
et al. (2005) proposed a universal operation, called double-cut-and-
join (DCJ), which can unite most of the rearrangement events.
Under the DC] model, the edit distance can also be computed in lin-
ear time, but in a more simple and elegant way (Bergeron et al.,
2006). Because of its simplicity, DC] model has formed the basis for
the following algorithmic research on rearrangements (Bergeron et
al., 2009; Chen, 2010; Moret et al., 2013).

All of the above efficient algorithms assume that genomes do not
contain duplicated genes. In the presence of duplicated genes, most

i329

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/|icenses/by-nc/4.0/),
which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact

journa|s.permissions@oup.com

112 [3.10811211an[plOJXO'SODBIILIOJIIlOlQ/ﬂ(11111 moi; popeolumoq

910K ‘09 lsnﬁnV no :2

i330

M.Shao and B.M.E.Moret

 

of the edit distance problems are NP-hard. For two genomes with
duplicated genes, Chen et al. (2005 ) proposed an efficient heuristic
to compute the inversion distance by decomposing the problem into
two new optimization problems. Shao et al. (2014) devised an exact
algorithm to compute the DC] distance by formulating the problem
as an integer linear program. Both of the methods output a one-to-
one correspondence between the homologous genes and thus can be
applied to assign orthologs.

When only content-modifying events are considered, Kahn and
Raphael (2008) devised an efficient dynamic programming algo-
rithm to compute the duplication distance, which was later extended
by introducing likelihood techniques and then applied to reconstruct
the evolutionary history of the segmental duplications in human
genome (Kahn et al., 2010). Holloway et al. (2013) proposed an
alignment approach to reconstruct the ancestral genome for two
genomes with segmental duplications and gene losses and applied it
in a phylogenetic context to infer the evolution of the stable RNA
gene content and organization in various genomes.

When both rearrangements and content-modifying events are
considered, El-Mabrouk (2001) proposed an efficient algorithm to
compute the edit distance for inversions and deletions. Braga et al.
(2010, 2011) gave a linear time algorithm to compute the edit dis-
tance for DC]s, insertions and deletions. Notice that these algo-
rithms also assume that the given genomes do not contain
duplicated genes. Shao and Lin (2012) gave a 1.5-approximation al-
gorithm to compute the edit distance for two genomes in the pres-
ence of duplicated genes under a model that includes DC]s, single-
gene insertions and single-gene deletions. Fu et al. (2007) extended
the heuristics in Chen et al. (2005) to unite rearrangements and sin-
gle-gene duplications as a new software package, called MSOAR,
which can be applied to detect in-paralogs in addition to orthologs.

In this article, we compare two genomes in the presence of dupli-
cated genes with DC]s and segmental duplications. Formally, the
problem is to compute a set of segmental duplications in each genome
and a bijection between the nonduplicated genes, such that the total
cost of the segmental duplications and the DC]s induced by the bijec-
tion is minimized. We propose an exact algorithm for this problem by
formulating it as an integer linear program. Based on studying the
underlying structure of problem, we then devise an efficient prepro-
cessing algorithm to simplify the problem while keeping the optimal-
ity. We also discuss and propose a reasonable way to balance the
costs between DC]s and segmental duplications. Finally, we apply our
method to assign in-paralogs and orthologs and compare its perform-
ance with MSOAR on both simulated and biological datasets.

2 Problem statement

We model each genome as a set of chromosomes and model each
chromosome as a linear or circular list of genes. Each gene is repre-
sented by a signed (+ or —) symbol, where the sign indicates the tran-
scriptional direction of this gene. Homologous genes are grouped
into gene families. For a genome X, we use A(X) to denote all the
gene families in X and use F(X, f) to denote the set of genes in X
that come from gene family 

We say consecutive genes on one chromosome form a segment.
The length of a segment s is defined as the number of genes in s,
denoted by  We say two segments in the same genome are
independent if they do not contain the same gene. We say segments
s = (a1,a2,- - -,a,,) and t = (h1,h2,- - -,hn) are homologous if a,- and
h,- are homologous and have the same sign for all 13 i Sn or a,- and
hn+1_,- are homologous and have the opposite sign for all 1 Si Sn.

We say segment s is possibly duplicated, if there exists segment t in
the same genome such that s and t are independent and homologous.
For a genome X, we use 8 (X) to denote the set of all the possibly
duplicated segments in X (Fig. 1a). We say a subset S C 8(X) is
independent if every two segments in S are independent. For an inde-
pendent subset S C S(X), we use X \ S to denote the new genome
after removing all genes appearing in the segments in S from X. Given
two genomes X and Y, we say two independent subsets S C S (X) and
T C S (Y) are consistent if X \ S and Y \ T have the same gene
content, i.e. for each gene family f E A(X) U A(Y), we have
|F(X\S,f)| = |F(Y \ T,f)| (Fig. 1a). In this article, we assume that
the given two genomes X and Y satisfy that A(X) = A(Y); otherwise
we modify them by removing all the genes that are not in
A(X) ﬂ A(Y). With this assumption, there always exist two independ-
ent subsets S E S (X) and T E S (Y) that are consistent.

Suppose we are given two independent consistent subsets S E S (X) and
T E 8(Y). We denote by B(X \ S, Y \ T) the set of bijections that map
each gene in X\S to a homologous gene in Y\T. IfX\S and Y\T
contain only singletons, i.e. we have |F(X\S,f)| =  T, = 1 for
all f E A(X) U A(Y), then we have |B(X\ S, Y \ T)| = 1, and the DC]
distance between X \ S and Y \ T is well deﬁned and can be computed in
linear time (Bergeron et al., 2006). Once a bijection B E B(X \ S, Y \ T) is
given, we can relabel X \ S and Y \ T by assigning each pair of genes in B
with a distinct gene family and thus results in two new genomes with only
singletons. We denote by d(B) the DC] distance between these two new gen-
omes induced by bijection B.

In this article, we study the following problem: given two gen-
omes X and Y satisfying A(X) = A(Y), and a cost function c(-),
which maps each segment in 8(X) U 8(Y) to a positive value, com-
pute a triple Q = (S, T,B), where S C 8(X) and T C 8(Y) are two
independent consistent subsets and B E B(X \ S, Y \ T), such that
the total cost of Q, 32(Q) = Zsesqus) + d(B), is minimized.

3 ILP formulation

We now formulate the above problem as an integer linear program.
To achieve that, we first introduce the adjacency graph in Section

 

 

 

 

(a) (b)
r 1 1 2 1 2 ﬁr 1 1 1 2 N
a\ b\ a\ c\ b\ a\ b\ c\b
r r I r r I
(X)
\ l l \ l
)\ J
(‘0

 

‘( N
2 2 1 1 1 1 1 1 2 2
bt bh at ah bt bh ct ch bt bh

ll

4 3 3 3 3 3 3 4 4
bthah at bt bh ct ch bh bi)

 

34
bh

 

 

 

2 2 3 3 3 3 3
kct ch ah at bt bh ct ch

 

Fig. 1. (a) Two genomes X and Y. Genes in the same gene family are
represented by the same symbol with different superscripts. We have 8(X)
= {(a1). (a2).(b1). (122)} and 8m = W). (b3), (c3). <—b4)} and s = {092)}
and T = {(02)} are two consistent subsets. (b) The genomes X\ S and Y\ T
and the bijection B. (c) The adjacency graph w.r.t. 0 = (S, T, B). Black edges
are represented by long thin lines, while gray edges by short thick lines. Head
extremities are represented by circles, while tail extremities by squares. (d)
The extended adjacency graph w.r.t. 0, in which internal edges are repre-
sented by double lines

112 [3.10811211an[plOJXO'SODBIILIOJIITOTQ/ﬂ(11111 moi; popeolumoq

910K ‘09 lsnﬁnV no :2

Comparing genomes with rearrangements and segmental duplications i331

 

3.1, which is the essential data structure to compute the DC] dis-
tance. We also propose a new extension of the adjacency graph,
called the extended adjacency graph, which can incorporate dupli-
cated genes and thus forms the basis for the following ILP formula-
tion. We then describe a capping method to remove the telomeres,
in Section 3.2, which allows us only to count the number of cycles
when computing the DC] distance. On the basis of them, we finally
give the ILP formulation in Section 3.3.

3.1 Adjacency graph

We first introduce some notations. The two ends of a gene a are
called extremities. The head is denoted by a], and the tail is denoted
by at. The set of all extremities in genome X is called the extremity
set of X, denoted by 8 If genes a and h are homologous, we also
say the two corresponding extremity pairs, a], and 19],, at and 19,, are
homologous. Two consecutive genes a and h form one adjacency,
which is represented by a set of two extremities. Thus, each adja-
cency comes in one of the four types: {at, 19:}, {am 19,}, {at, 19],} and
{am 19],}. If gene a lies at one end of a linear chromosome, then this
end can be represented by a set of one extremity, {ab} or {at}, called
a telomere.

Suppose that we are given a triple Q = (S, T, B), where
S C S (X), T C S (Y) are two independent consistent subsets and
B E B(X \ S, Y \ T). We can build the adjacency graph w.r.t. Q,
denoted by G(Q), as follows. We first build X \ S and Y \ T through
removing all genes in S U T and take all the extremities in them, i.e.
8(X\S) U8(Y\T), as the vertices of G(Q). Then for each adja-
cency in X \ S and Y \ T, we add one gray edge to connect the two
extremities in it. Finally, for each pair of homologous extremities
specified by B (each homologous gene pair in B specifies two pairs
of homologous extremities), we add one black edge to connect them
(Fig. 1a—c). Clearly, in G(Q), the degree of each vertex is at most 2,
and thus it consists of a set of vertex-disjoint cycles and paths. The
length of a cycle (or a path) is defined as the number of black edges
in it. Let c be the number of cycles and o be the number of odd-
length paths in G(Q). We have that the DC] distance induced by B
can then be computed as d(B) = n — c — 0/2, where n is the number
of genes in X \ S (Bergeron et al., 2006).

Given a triple Q = (S, T, B) defined above, we propose an
equivalent form of G( Q), called the extended adjacency graph w.r.t.
Q, denoted by G’ The set of vertices of G’ (Q) includes all the
extremities in X and Y, i.e. 8(X) U 8(Y). For each adjacency in X
and Y, there is one gray edge connecting the two extremities in it.
For each pair of homologous extremities specified by B, there is one
black edge connecting them. For each gene contained in some seg-
ment in S U T, there is one internal edge connecting the two extrem-
ities in this gene (Fig. 1d). The difference between G’ (Q) and G(Q)
is that, the latter one explicitly removes those extremities in the
genes in S U T, whereas the former one keeps them but adds internal
edges connecting the two extremities in those genes. Clearly, G’ (Q)
also consists a set of vertex-disjoint cycles and paths, and there is a
one-to-one correspondence between the connected components in
G(Q) and that in G’ Thus, the DC] distance induced by B can
also be computed as d(B) = n — c’ — o’ / 2, where c’ is the number of
cycles and o’ is the number of odd-length paths in G’ (Q), and n is
the number of genes in X \ S. As we will see later, this extended ad-
jacency graph is the key point in devising the ILP formulation.

3.2 Add capping genes
In Shao and Lin (2012), we described a method to remove telomeres
by introducing capping genes. A capping gene contains only one

extremity, which combines with the adjacent telomere (or another
capping gene) to form one adjacency. All capping genes are homolo-
gous to each other, forming a distinct gene family, denoted by f,.
Given two genomes X and Y with IX and ly linear chromosomes, re-
spectively (without loss of generality, we assume that lX2ly), we
first add one capping gene to each end of all the linear chromosomes
in X and Y; then we add (lX — ly) dummy chromosomes, each of
which contains only a pair of capping genes, to genome Y (Fig. 2).
We denote by X and Y the two new genomes after adding capping
genes for X and Y. Clearly, we have  =  Thus,
given a pair of independent consistent subsets S C S (X) and
T C 8(Y), we know that X \ S and Y \ T also have the same gene
content. Using the same argument as in Shao et al. (2014), we can
prove that
min d(B) = min d(B),
B€B(X\S,Y\T) B€B(X\S,Y\T)

and the optimal B can be recovered from the optimal B through dis-
carding the pairs with capping genes. This statement allows us to
add capping genes to remove telomeres on the two given genomes
without affecting the optimal bijection. Since the two new genomes
X and Y do not contain telomeres, we have that for any triple
Q = (s, 11%), where s c 8(X), T c 8(Y) and 1% e 302 \ s, 1? \ T),
both G(Q) and G’ (Q) contain only cycles (Fig. 2). This property
allows us only to count the number of cycles when computing the
DC] distance, which simplifies the following ILP formulation.

3.3 ILP formulation

Let X and Y be two given genomes after adding capping genes.
Let Q* = (S*, T*, B*) be the optimal triple minimizing
ZSES*UT*C(S) + d(B*), where we have 3* c 8(X), T* c 8(Y) and
B* E B(X \ S*, Y \ T*). (Notice that here X and Y may contain cap-
ping genes, but we define S (X) and S (Y) are in terms of the original
genomes, which do not contain segments with capping genes.) To
facilitate our description, we use a E X to denote that gene a is con-
tained in genome X. We use a E s to denote that gene a is contained
in segment s. We denote by fa the gene family to which gene a

 

 

 

 

(a) (D)
( a1) b1> a2) cl >NK$1 a1) b1, a2) 61:72
(X) (X)
3 4
(Y) 33 (Y)
\ j \ j
(c) (d)
r \

 

\(
11112211 11112211
at ah, bt bh a’t ah Ct Ch 7-1 at ah bt bh a’t ah ct ch, 2

3 3 3 2 2 2 2 3
Kb1t ah at bt bh ch ct bh)

 

 

 

 

 

 

Fig.2. (a) Two genomes Xand Y. (b) The genomes X and Y after adding cap-
ping genes, where capping genes are represented by diamonds. (c) The ex-
tended adjacency graph w.r.t. (S, T, B), where S = {(a2)}, T = {(b2)} and B
maps a1, b1 and c1 to a3, b3 and 02, respectively. (d) The extended adjacency
graph w.r.t. (S, T, B), where B consists of the two pairs mapping 11 and 12 to
1:3 and 174, respectively, and those pairs in B

112 /810'S{12umo[pJOJXO'soiiemJOJuioiw/2dnq moi; papeolumoq

910K ‘09 lsnﬁnV no 2:

i332

M.Shao and B.M.E.Moret

 

belongs. We say gene a is duplicated in Q*, if there exists one seg-
ment s E S* U T* such that a E s and nonduplicated otherwise.

We now give the ILP formulation to compute Q*. For each seg-
ment s E 8(X) U 8(Y), we have one binary variable xS to indicate
whether s E S* U T*. For each gene a E X U Y, we have one binary
variable ya to indicate whether a is duplicated in Q*. We use the fol-
lowing two sets of constraints to guarantee that ya = 1 if and only if
there exists one segment s E S* U T* such that a E s:

ya 2 x5, Vs E 8(X) U 8(Y) and‘v’a E s;

y. E 2 x5, VaEXUY.
sES(X)US(Y):a€s

We require that these segments in S* U T* are independent, i.e.
there do not exist two of them that contain the same gene:

x531, Va 6 XU Y.
sES(X)US(Y):a€s

We also require that X \ S* and Y \ T* have the same gene con-
tent, i.e. for each gene family there must be an equal number of non-
duplicated genes in Q* in this family in each genome:

Z (1—ya)= Z (1—yb), Vf€A(X)-

aeF(X,f) beF(Y,f)

And for each gene family, at least one gene is nonduplicated

in Q*:

2 my.) 2 1, Vf€A(X);
aEF(X,f)
211—”) 2 1, WWW)-
beF(Y,f)

For each pair of homologous genes a E X and h E Y, we add one
binary variable 24,), to indicate whether B* contains this pair. We re-
quire that for each gene in X U Y, it is mapped to exactly one hom-
ologous gene in the opposite genome if and only if it is
nonduplicated in Q*:

2 z,,;, = 1 —y,,, VaEX;
beF(Y,f,)

Z a), = 1 —y;,, Vhe Y.
dEFOCfb)

These constraints guarantee that these pairs in B* form a valid bi-
jection between the genes in X \ S* and those in Y \ T*. To compute
d(B*), we need to count the number of cycles in G’ We add a
variable lg for each extremity e E 8 (X) U 8 (Y) to represent the label
of e. We then assign a distinct upper bound for lg, denoted by Ue (for
example, we can just sort all the extremities in 8 (X) U 8 (Y) in an arbi-
trary order and assign Ue as the index of e in the sorted list):

OglegUe, Ve e 8(X) u 8(Y).

We then require that all the extremities in the same cycle in G’ (
Q*) have the same label. This can be achieved by forcing that the
two extremities connected by any edge in G’ (Q*) have the same
label. To guarantee this, we add the following three groups of con-
straints, each of which corresponds to one type of edges. First, we
require that the two extremities in each adjacency have the same
label (these constraints correspond to the gray edges):

lg,- = lei, V{e,-, ei} form an adjacency in X or in Y.

Second, we require that each pair of extremities specified by B*
have the same label (these constraints correspond to the black

edges). To achieve that, we add the following four constraints for
each pair of homologous genes a E X and h E Y (if a and h are cap-
ping genes, then we have a], 2 at and h], = ht and thus the following
four constraints degenerate into two):

la, S 1b,, +(1 — 24,19) ' Ugh;
1b,, S lab +(1 — 2,1,5) - Ubh;
la, S 1b,, +(1 — 24,19) ' Um;
lb, 314,, +(1 — 24,19) ' Uh,-

Third, we require that the two extremities in each duplicated
gene have the same label (these constraints correspond to the in-
ternal edges):

1,, gl,,+(1—y,,)-U,,,, VaEXUY;
la, gl,,+(1—y,,)-U,,,, VaEXUY.

We then add a binary variable we for extremity e to indicate
whether le reaches its upper bound:

we-Ue g 1,, Ve€£(X)U8(Y).

Since all the extremities in the same cycle in G’ (Q*) are forced to
have the same label, and all label variables have distinct upper
bounds, we know that for each cycle in G’ (Q*) at most one extrem-
ity can have its label reaching its upper bound. Thus, we have that

we
e€£(X)U£(Y)

is exactly the number of cycles in G’ And d(B*) can then be
computed by

 _Zya— Z we,

an ee£(X)U£(Y)

where the first two items give the number of genes in X \ S*.
Finally, we set the objective function of the ILP as

min 2 c(s) -x5 + |X| — Zya — Z we.

s€S(X)US(Y) aEX e€£(X)U£(Y)

4 Identify optimal substructures

Given two genomes X and Y after adding capping genes, we say two
homologous segments s in X and t in Y form a pair of shared seg-
ments, denoted by (s, t). Intuitively, shared segments are more likely
to be nonduplicated and mapped to each other. Below, we give one
sufficient condition and one algorithm to decide whether a pair of
shared segments is in some optimal solution, i.e. in this optimal solu-
tion, a,- and h,- are nonduplicated and a,- is mapped to 19,-, for all
1992. From now on, we assume that the cost function only de-
pends on the length of the segments, i.e. we assume that if |s| = |t|
then we have c(s) = c(t).

4.1 A sufficient condition

We say gene a in genome X is isolated, if there does not exist any
segment s E S (X) such that a E s and |s|22. The following theorem
gives a sufficient condition to decide whether a pair of shared seg-
ments of length two is an optimal substructure.

Theorem 1: Let p = ((a1,h1), (a2,h2)). If we have a1 and a2 are
singletons, and b1 and b2 are isolated, then p is in some optimal
solution.

112 /810'S{12umo[p101x0'soi112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 lsnﬁnV no 2:

Comparing genomes with rearrangements and segmental duplications i333

 

Proof: Let Q = (S, T, B) be an arbitrary triple such that either 191
or b2 is duplicated in Q, or B does not contain (191,192). Below, we
will show that we can always build a new triple Q’ = (S’, T’, B’) in
which both 191 and h2 are nonduplicated and B’ contains ((91,192) and
also verify that y(Q’)§y(Q). Since Q is arbitrary, this proves the
theorem.

First, assume that in Q both 191 and h2 are duplicated. Let s E S
and t E T be the segments containing 191 and 192’ respectively.
Since both 191 and h2 are isolated, we know that |s| = |t| = 1. Let
S’ = S \ {s} and T’ = T \  We have that X\S’ and Y\ T’ still
have the same content. Let B’ = B U {(191,192)}. We have that
d(B’) = d(B), since X \ S’ has one more gene than X \ S, whereas
G(Q’) has one more cycle than G( Q) (Fig. 3a and b). Thus, we have

2(Q’) = Z,€S,UT,c(u) +d<B'> = gauge) — c(s) — c<t> + M):
Ewen!) +d<B> = 2(2).

Second, assume that in Q gene, 192 is duplicated, while 191 is not (or
symmetrically, h1 is duplicated, while 192 is not). Suppose that h1 is
mapped to h3 in B, i.e. ((91,193) E B. Let S’ = S and
T’ = T \ {t} U {t’}, where t E T is the segment containing 192 and t’ is
the segment containing only gene [93. Clearly, we also have that
X \ S’ and Y \ T’ have the same content. Let
B’ = B \ {(191,193)} U {(191,192)}. To compare d(B’) with d(B), con-
sider the difference between G(Q’) and G(Q). In fact, we can trans-
form G(Q) into G(Q’) through two DC]s on genome Y (after that we
need to rename 193 as 192). We first perform one DC] to cut 193 out to
create the adjacency {193,193} (Fig. 3c and d). This operation might de-
crease the number of cycles, but the number decreased is at most 1 ac-
cording to the property of the DC] model. We then insert 193 back as
the neighbor of a2 to form the segment (a2, (93), which will increase
the number of cycles by 1 (Fig. 3d and e). This implies that the num-
ber of cycles in G(Q’) is no less than that in G( Q). In addition to the
fact that X \ S’ and X \ S have the same number of genes, we have
that d(B’)gd(B). Thus, we have Mg) = Zueﬂmau) +d(B’) g
Ewen!) — c<t> + cw) + M) = Ewen!) + M) = we).
The last equality uses the assumption that the cost function only de-
pends on the length of the segments.

Third, assume that in Q both 191 and h2 are nonduplicated, and
h1 is mapped to 193 while 194 is mapped 192. Let S’ = S, T’ = T
and B’ = B \ {(191,193), (194,192)} U {(191,192), (194,193)}. Using the
same technique in the Theorem 1 (Shao et al., 2014), we can
prove that d(B’)§d(B). Thus, we still have y(Q’) =

ZuES’UT’C(u) + d(B’)SV(Q)-

4.2 An algorithm

We say a pair of shared segments p = ((a1,a2, --- ,an), (191,192, -- - ,hn))
between genomes X and Y is half fixed, if h,- is singleton for all
1992 (and thus none of them can be duplicated) and all genes in
F(X, f at.) are isolated for all 1992. Let p be such a pair of half fixed
shared segments (PHFSS for short). We use A(p) to denote all the
gene families in p, i.e. A(p) = {fal,faz, - - - ,fan}. In this section, we
propose an algorithm to decide whether a PHFSS is in some optimal
solution. Notice that for a PHFSS p, if we further know that in some
optimal solution ak is mapped to bk for some 13/292, then we can
immediately conclude that the whole p is in some optimal solution
by iteratively applying theorem 3.

Let Q; = (S, T,B) be the triple with smallest total cost among
these triples that do not contain p (i.e. h,- is not mapped to a,- for all
1991). We now modify Q; to replace a; with a,-, where a;
is the gene that are mapped to h,- in Q; Notice that
{(a1), (a2), - - - , (an)} C S, since a,- is duplicated in Q; (because 19,- is
singleton and a; is nonduplicated in Q;) and all genes in F(X, f “1)

are isolated. Let S’ = S\{(a1),---,(an)}U {(a’l),---, (a;)}, B’ =B
\{<a’1’ b1),  ’ (ah,  U {(6117 b1), ' "7 (an)  and  2 (SI) T’B’)'
Clearly Q; contains p. According to the definition of Q;, if we can
show that y(Q;)§y(Q;), then p is in some optimal solution. From
the construction of Q;, we can see clearly that the cost of the seg-
mental duplications in Qi is equal to that in Q;. Thus, we only need
to compare the number of DC]s between Qi and Q;.

We compare the number of cycles in G’ (Q;) and G’ (Q;). Notice
that G’ (Q;) and G’ (Q;) differ only on these gene families in A(p).
We now define a new graph to focus on A(p) while hiding others.
Let Q be a triple and p be a PHFSS. We can build the reduced adja-
cency graph w.r.t. Q and p, denoted by R(Q, p), as follows. The ver-
tices of R( Q, p) are divided into two types, the core vertices, which
are exactly those extremities in the genes in the gene families in A(p)
and the boundary vertices, which consist of these extremities that
form adjacencies with core vertices (Fig. 4a and b). The edges of
R(Q, p) are divided into four types, gray edges, black edges, internal
edges and reduced edges. For any two vertices in R(Q, p), they are
connected by gray edges or internal edges, if and only if they are
connected by the same type of edge in G’ For any two core ver-
tices in R( Q, p), they are connected by one black edge if and only if
they are connected by one black edge in G’ For any two bound-
ary vertices in R(Q, p), they are connected by one reduced edge if
there exists one path connecting them in G’ (Q) without going
through any core vertices or boundary vertices (except its two ends).
Clearly, R(Q, p) also consists of a set of vertex-disjoint cycles
(Fig. 4c and d).

We claim that the difference of the number of cycles between
G’ (Q;) and G’ (Q;) is the same as that between R(Q;, p) and
R(Q;, p). In fact, the cycles that do not contain any core vertices or
boundary vertices are the same between Qi and Q; according to the
construction of Q; and those cycles do not appear in either R(Q;,p)
or R(Q;, p). Moreover, for each cycle in G’ (Q;) that contains some
core vertices, there exists one corresponding cycle in R(Q;, p),
since the reduction procedure in constructing R(Qi,p) can only
shorten the length of each cycle, while it cannot merge or split it. It
is the same for G’ (Q;) and R(Q;, p). Thus, the claim holds.
Furthermore, the reasoning used here also implies that we can con-
struct R(Q;,p) directly from R(Q;,p), rather than from G’ (Q;):
we can first replace the black edges corresponding to (aj, 19,-) with

(a) (b) (c)

1 1 1 1 1 1 1 1 1
61 at ah 62 61 at ah bt bh 62 61 at ah bt bh 62

 

e3a§aﬁe4e3a3 2b3bﬁe4e3aga

(d) (e)

1111 1111
61 at a’h bt bh e2 61 at ah bt bh e2

84 e5 3 3 66

 

Q—Q {Zr—r:

63 a? ai 84 b? b 85 66 63 a? ai bi’ b2 84 e5 66

g-oo

 

Fig. 3. (a,b) The adjacency graph before and after adding (b1,b2). (c—e)
Transforming G(Q) into G(O’) using two DCJs. Irrelevant extremities are rep-
resented by stars

112 /810'S{12umo[p101x0'soi112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 lsnﬁnV no 2:

i334

M.Shao and B.M.E.Moret

 

 

33111111113311
T1 at a’h Ct ch at ah bt bh dt dh bt bh 6t eh 7'2

\

 

7'2

 

T3 d3 di (1% 61% b2 bi c2 0% d3 d? e2 6% T4

 

 

 

 

 

 

 

      
 

 

 

 

2 2 2 2
ah b; bh ct

k J

Fig. 4. X =(a3,cl,a1,b1,d1,b3,e1), Y = (d2, a2, b2, 02, —d3, e2). p = ((al,b1),
(a2, b2)). The four subgraphs show 610;), G’(O;), R(Q;,p) and R(Q;, p), re-
spectively. The core vertices are shown as solid patterns, and the boundary
vertices are shown as patterns with one inner point. Reduced edges are
shown as dashed lines

that corresponding to (a,-, b,-) and then replace the internal edges cor-
responding to a,- with that corresponding to a].

In summary, once we know R(Q;,p), we can then construct
R(Q;, p) and compare the number of cycles in them. If the number
of cycles in R(Q;,p) is no less than that in R(Q;,p), then p is in
some optimal solution. However, the problem is that we do not
know R(Q;, p). Our strategy is to enumerate all the possibilities of
R(Qi,p). The vertices of R(Qi, p), i.e. all the core vertices and all
the boundary vertices w.r.t. p, can be computed in advance very eas-
ily. All the genes of a,-, 1992, are duplicated in R(Q;, p) by defin-
ition, and thus the two extremities in a,- are always connected by one
internal edge in R(Q;,p). All genes in F(X,fa,) \ {a,-} are possibly
mapped to b,- in R(Q;,p). For any two boundary vertices (maybe in
the same genome), we need to check whether they can be connected
by one reduced edge in R(Qi, p), i.e. whether there exists one pos-
sible path connecting them that does not go through any other core
vertices or boundary vertices. Notice that this path must be alternat-
ing, i.e. the edges with odd indices must be either black edges or in-
ternal edges and the edges with even indices must be gray edges
(Fig. 4c and d).

There exists a linear time algorithm to decide the existence of an
alternating path between two given vertices (Bang-]ensen and Gutin,
1998). We now adapt it for our use. Given a PHFSS p and two

 

N

 

 

 

 

 

 

ail; 7'2 7'3 d? 0% d? d; 6% 3% T4
: : : : :: 3:  
cl 6%          
I? (I? ?—<> '3' Q O=E| u (f T
I l
x | J

 

Fig. 5. The underlying graph used to decide the existence of an alternating
path connecting 0,1, and et1 w.r.t. pfor the same instance in Figure 4. All bridg-
ing edges are shown as dotted lines

boundary vertices x and y, the algorithm first build a graph with
V1 U V2 U{x, y} as its vertices, where V1 is the set of all extremities
except all the core vertices and boundary vertices and V2 is a copy of
V1. Two extremities in V1 are connected by one gray edge if they
form one adjacency. Two homologous extremities in V2 in different
genomes are connected by one black edge, and the two extremities
in V2 in a possibly duplicated gene are connected by one internal
edge. We connect x (resp. y) to its all homologous extremities in V2
in the opposite genome by black edges. Finally, all the counterparts
between V1 and V2 are connected by bridging edges (Fig. 5).
Clearly, all the bridging edges form a matching of size | V1 |, denoted
by M. The algorithm then computes an augmenting path w.r.t. M
using the Blossom algorithm, which takes linear time. We claim that
such an augmenting path exists if and only if there exists one alter-
nating path connecting x and y without going through any core ver-
tices or boundary vertices. In fact, if such an augmenting path exists,
then the two ends of this path must be x and y, since they are the
only two unmatched vertices. We claim that the edges in the aug-
menting path that are not in M form an alternating path connecting
x and y. This is because edges in M are spanning V1 and V2, whereas
gray edges are all inside in V1 and black edges and internal edges are
inside in V2. The opposite side of statement can be reasoned in a
similar way.

The algorithm to decide whether a given PHFSS p is in some op-
timal solution proceeds as follows. The first phase of the algorithm
is to compute the core vertices and the boundary vertices w.r.t. p and
then for each pair of boundary vertices, to check whether they can
be connected by a reduced edge. If the total number of edges
(reduced edges plus those among core vertices) is larger than log n,
the algorithm terminates. Otherwise, the algorithm comes to the se-
cond phase. It enumerates all the possibilities of R(Q;, p): for each
possible valid combination of the reduced edges (i.e. they form a
matching that covers all the boundary vertices), it enumerates all the
possible valid mappings for the genes in A(p) (a,- cannot be mapped
to b,- by the definition of R(Q;, p)) and the mapping that yields the
maximum number of cycles, plus the current combination of the
reduced edges, forms one possibility of R(Q;,p). After that, for
each possibility of R(Q;, p), it then builds R(Q;, p) and com-
pares the number of cycles between them. If the number of cycles in
R(Q;, p) is always no less than that in R(Q;,p) for all the possibil-
ities, then the algorithm concludes that p is in some optimal
solution.

The above algorithm runs in polynomial time. In fact, the first
phase runs in polynomial-time, since we can decide the existence of
a reduced edge for each pair of boundary vertices in linear time.
In the second phase, the number of edges is in logarithmic-size,
which implies that the number of possibilities of R(Qi,p) is in poly-
nomial size. Thus, the second phase also runs in polynomial time.

We remark that usually not all pairs of boundary vertices can be
connected by a reduced edge (Fig. 6). In fact, if this is not the case,

112 /810'S{12umo[p101x0'soi112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

Comparing genomes with rearrangements and segmental duplications i335

 

 

 

l 1 1 1 3 3
7'1 at ah ct ch at ah bt bh dt dh bt bh 7'2
:;:~“ ><\ ‘:::‘___  ”’,’4-:/:
\~‘—::"’——_ \\ _:><" /’ \~ éé’ ”
\ ———'K" ‘~- ’ —.—'"’_-”
\\ \x ‘—/J_————:’
\\ \\\ ’z’ ””’
\\\ [TI/r’»\’\”
\\\ zCT’T’T \\\
4’ \
U‘—I H C—‘EI
2 2 2 2 2 2
K dh at ah bt bh ct J

 

 

Fig. 6. All the possible reduced edges in R(Q;,p) for the same instance in
Figure 4. We can verify that among all possibilities of R(Q;, p), the number of
cycles in R(Q;,p) is always no less than that in R(Q;,p). Thus, in this in-
stance, p is optimal

then there always exists one possibility such that R(Qi, p) contains
more cycles than R(Q;,p), in which case the algorithm fails. In
other words, the first phase to identify possible reduced edges is very
essential, which not only decreases the number of possibilities but
more importantly makes the algorithm capable of identifying opti-
mal substructures. We also remark that this algorithm is a sufficient
test, i.e. if it returns ‘yes’, then p is guaranteed in some optimal solu-
tion. However, if it returns ‘no’, then it is still possible that p is in
some optimal solution. This is because two reduced edges in R(Q;,
p) might not be able to coexist in G’ (Q;).

We can apply the theorem in Section 4.1 and the algorithm in
Section 4.2 on all shared segments to verify their optimality. If such
an optimal substructure is identified, we immediately fix it and up-
date the genomes through assigning each pair of genes in it a distinct
gene family. We can iteratively repeat this process until no such opti-
mal substructure can be found. This serves as a preprocessing algo-
rithm to simplify the problem before calling the ILP solver. The
performance of this preprocessing algorithm on real genomes is ana-
lyzed in Table 4.

5 Set the cost

Under a parsimonious model, it is natural to set a unit cost for all
segmental duplications (as we do for all DC]s). However, in this
case, two segmental duplications, one in each genome, that create a
pair of shared segments can be always explained as two DC]s with
the same total cost. Consider the example in Figure 7a, for which we
have two optimal solutions with total cost of 2: one is to regard a2
and a4 as duplicated genes, and the other uses two DC]s, which first
cut a2 out from X and then insert it back between c1 and d1. The
scenario in the second case (two DC]s using one circular chromo-
some as intermediate) requires three inversions to explain, and
therefore it is much less unlikely to happen comparing with the first
scenario. Thus, to avoid the second case we set  < 1.

On the other hand, if we have c(-)§0.5, then every DC] that in-
verts a possibly duplicated segment can be always explained by two
segmental duplications with the same or even better total cost.
Consider the example in Figure 7b, for which one solution is to use
only one DC] to invert the segment (a2, b2) on X. However, if we
have c(-)§0.5, then we can regard (a2, b2) and (—b4, —a4) as dupli-
cated segments, whose total cost is at most 1. Thus, to avoid the se-
cond case, we need to set  > 0.5.

Combining the above two facts, in the following experiments,
we set  = 0.75.

6 lnfer in-paralogs and orthologs

Under a most parsimonious evolutionary scenario, the duplicated
genes in the optimal triple infer the in-paralogs in each genome,

 

 

 

 

 

 

(a) (b)
6 N f \
(11‘ b1\ a2\ c1\ d1\ a1\ b1\ c1\ a2\ b2 d1
(X) (X)
(Y) (Y)
K (13, b2, 02’ a4, d2rJ \ 0.3, b3 02’ —b4 10.4 d2’)

 

 

 

Fig. 7. (a) An example in which there are two optimal solutions if c(-) = 1. (b)
An example in which there are two optimal solutions if c(-) = 0.5

whereas the bijection between the nonduplicated genes in the two
genomes infers a subset of the orthology pairs [more specifically,
positional orthologs (Dewey, 2011)]. In the following, we apply our
method to infer in-paralogs and orthologs on both simulated data-
sets and biological datasets and compare its performance with
MSOAR.

6.1 Results on simulated datasets

We simulate a pair of genomes as follows. We start from an ancestor
genome with only one linear chromosome consisting of N 25000
singletons (we also test N = 1000 and N = 2000; the results are not
presented since they agree with N = 5000). We then perform S1 seg-
mental duplications on the ancestor genome to make some gene
families contain more than one copy. A segmental duplication ran-
domly chooses a segment of length L and inserts its copy to another
random position. The two extant genomes then speciate independ-
ently from this ancestor genome. The speciation process on each
branch includes randomly mixed S2 segmental duplications and D
DC]s. A DC] randomly chooses two positions in the genome and
then reverses the segment in between. We make sure that the ex-
pected number of genes per gene family in each extant genome is 1.5
(this number is comparable to that in human genome, which is
1.46), therefore we have that S1 + S2 = 0.5 - N/L. We further fix S1
= 0.2 - N/L and S2 = 0.3 - N/L (we also test S1 = 0 and
S2 = 0.5 - N / L, and the results are almost the same). Thus, a simula-
tion configuration is determined by parameters L and D.

For each pair of simulated genomes X and Y, we take them as in-
put to run MSOAR and our method. For MSOAR, we run its binary
version downloaded from http://msoar.cs.ucr.edu/. For our method,
we first apply the preprocessing algorithm described in Section 4
and then formulate the simplified problem as an ILP instance, which
is solved using the GUROBI solver. We set the time limit to 2h for
each instance, i.e. if the ILP solver does not return the optimal solu-
tion in 2 h, we terminate it and return the current sub-optimal
solution.

Both methods return triples (S, T, B), where S and T infers the
in-paralogs in the two extant genomes, respectively, and B infers the
orthology pairs. We now give the measures to evaluate them. First,
we regard the problem to infer in-paralogs as a standard binary clas-
sification problem: those genes that are generated by segmental du-
plications in the speciation process are considered as gold standard
positive in-paralogs and those genes that are in the segments in S
UT are considered as predicted positive in-paralogs. Thus, we use
the sensitivity and specificity to measure (S, T). To evaluate the per-
formance of B, we refer to those gene pairs in the two extant gen-
omes that correspond to the same gene in the ancestor genome as
the true orthology pairs. We therefore use the following way to
evaluate B: we say a pair in B is assessable, if at least one of its two
genes can be found in some true orthology pair, and the accuracy of

112 /810'S{12umo[p101x0'soi112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

as
w
03

M.Shao and B.M.E.Moret

 

 

98 100

94 96

Sensitivity (%)

 

 

 

92

 

I I I I
500 1000 1500 2000
True DCJ Operations (Parameter D)

Fig. 8. Sensitivity of the inferred in-paralogs. The solid lines and dashed lines
track our method and MSOAR, respectively. The circles, triangles and dia-
monds track L: 1, L: 2 and L: 5, respectively

 

 

 

 

 

 

o
O—
H
Ao_
509
V0—
€00
sis—
8
QC-
:0“? \_<.>__‘<>_ ~A——_.A
0. _‘°‘—-<>~_
10 ‘°———<>———<>
l l l I
500 1000 1500 2000

True DCJ Operations (Parameter D)

Fig. 9. Specificity ofthe inferred in-paralogs

B is then defined as the ratio between the number of true orthology
pairs in B and the number of assessable pairs in B.

For each parameter configuration, we simulate 10 instances and
compute the average sensitivity, specificity and accuracy for both
methods. The performance of the two methods is shown in
Figures 8—10, where the parameters L E {1, 2, 5} and D ranges from
250 to 2000. First, we can observe that both methods get very high
sensitivity (above 90% on all configurations). However, MSOAR
gets relatively low specificity. One reason for this is that MSOAR
uses unit cost for both rearrangements and single-gene duplications.
According to the discussion in Section 5, unit cost for all operations
might misclassify in-paralogs. Second, as D increases, the perform-
ance of both methods decreases. This is because the number of DC]s
is highly positively correlated to the difficulty of the problem. When
D35 00, i.e. roughly 10% of the size of the simulated genome
(which is usually the case for real genomes, see Table 2 columns
d(B) for some examples), we can see that our method almost gets
perfect performance. Third, observe that MSOAR is very sensitive
to L even when D is very small. This might be because the evolution-
ary model for in-paralogs in MSOAR is single-gene duplication,
which creates trouble when genomes contain long segmental dupli-
cations. Finally, our method outperforms MSOAR on all the
configurations.

6.2 Results on biological datasets

We compare both methods on five mammalian species, human
(H.s.), gorilla (G.g.), orangutan (P.a.), mouse (M.m.) and rat (R.n.).
For each species, we collect all the protein-coding genes and down-
load their positions on the chromosomes and the Ensembl gene fam-
ily names from Ensembl (http://www.ensembl.org). Two genes are
considered as homologous if they have the same Ensembl gene fam-
ily name. Since the tandemly arrayed genes (TAGs) have a different
evolutionary model from segmental duplications, we merge each

 

Accuracy (%)
70 75 80 85 90 95 100
I

 

 

 

 

I I I I
500 1000 1500 2000
True DCJ Operations (Parameter D)

Fig. 10. Accuracy of the inferred orthologs

Table 1. Comparison with MSOAR on accuracy

 

 

 

Assessable Accuracy
Species pairs Time

MSOAR ILP MSOAR (%) ILP (%)
G.g. and H.s. 14 898 14 807 98.9 99.1 43
G.g. and M.m. 12 946 12 923 98.7 99.0 100
G.g. and Ba. 11 308 11 262 98.7 99.0 71
G.g. and R.n. 10 831 10 779 97.2 98.0 292
H.s. and M.m. 14 030 13 989 99.1 99.3 61
H.s. and Ba. 12 004 11 955 99.1 99.3 32
H.s. and R.n. 11 748 11 685 97.5 98.1 127
M.m. and Pa 10574 10537 98.9 99.3 68
M.m. and R.n. 12 332 12 280 97.7 98.2 130
R.n. and Ba. 8788 8745 97.6 98.2 157

 

Bold values highlight larger accuracy. The last column shows the running
time of MSOAR (in min).

Table 2. Comparison with MSOAR on inferred operations and total
score

 

|S| —|— |T| d(B) Total cost

 

Species pairs
MSOAR ILP MSOAR ILP MSOAR ILP

 

G.g. and H.s. 1738 1962 670 361 1973.50 1832.50
G.g. and M.m. 2183 2369 1214 891 2851.25 2667.75
G.g. and Ba. 1985 2259 896 530 2384.75 2224.25
G.g. and R.n. 3389 3620 1969 1394 4510.75 4109.00
H.s. and M.m. 1320 1381 909 743 1899.00 1778.75
H.s. and Ba. 1336 1444 497 306 1499.00 1389.00
H.s. and R.n. 2897 2885 1366 1069 3538.75 3232.75
M.m. and Ba. 1731 1825 906 707 2204.25 2075.75
M.m. and R.n. 2621 2739 1176 763 3141.75 2817.25
R.n. and Ba. 3109 3208 1535 1101 3866.75 3507.00

 

group of TAGs into only one gene through only keeping the first
gene in the group while removing all the following ones.

We do the pairwise comparison for all five species, and for each
pair of species, we run both methods to obtain triples (S, T, B). We
use the same accuracy defined in Section 6 .1 to evaluate B. To com-
pute the accuracy, we use the gene symbols (HGNC symbols for pri-
mate genes, MGI symbols for mouse genes and RGD symbols for rat
genes, downloaded from Ensembl) to define true orthology pairs:
those gene pairs that have the same gene symbol form the set of true
orthology pairs for each pair of species. We do not have annotation
data to serve as gold standard positive in-paralogs (we cannot just
regard those genes that are not in the true orthology pairs as gold
standard positive in-paralogs, since many genes have not yet been
assigned a valid gene symbol). Thus, we are not able to compute the
sensitivity and specificity of (S, T).

112 /810'S{12umo[p101x0'soi112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

Comparing genomes with rearrangements and segmental duplications i337

 

Table 3. Distribution of the length of the segments in S and T

 

Species pairs S1 S2 S23 |S| T1 T2 T>3 |T|

 

G.g. and H.s. 98.7 1.2 0.0 1347 95.2 4.3 0.3 615
G.g. and M.m. 98.5 1.3 0.1 1421 96.7 2.9 0.3 948
G.g. and Pa. 97.9 1.8 0.1 1579 98.8 1.1 0.0 680
G.g. and R.n. 98.1 1.6 0.2 1377 94.9 3.7 1.2 2243
H.s. and M.m. 94.8 4.9 0.1 563 96.2 3.5 0.2 818
H.s. and Pa. 93.9 4.8 1.2 807 99.3 0.4 0.1 637
H.s. and R.n. 94.9 4.2 0.7 631 95.3 3.2 1.3 2254
M.m. and Pa. 96.0 3.3 0.6 1109 99.1 0.5 0.2 716
M.m. and R.n. 95.5 3.5 0.9 648 94.5 3.5 1.8 2091
R.n. and Pa. 95.2 3.5 1.2 2472 99.0 0.6 0.2 736

 

Sk (respectively, Tk) contains the percentage of the segments of length k in
S (respectively, T).

Table 4. Composition of B

 

Species pairs Trivial (%) Predetermined (%) Remaining (%) |B|

 

G.g. and H.s. 51.5 47.9 0.5 16 213
G.g. and M.m. 48.7 49.5 1.6 15 015
G.g. and Pa. 50.7 48.5 0.7 15 271
G.g. and R.n. 46.3 50.5 3.0 14 983
H.s. and M.m. 51.0 47.5 1.3 15 572
H.s. and Pa. 52.3 47.1 0.4 15 481
H.s. and R.n. 48.5 49.5 1.8 15 379
M.m. and Pa. 50.0 48.6 1.2 14 620
M.m. and R.n. 48.9 49.4 1.6 16 347
R.n. and Pa. 47.7 50.1 2.0 14 534

 

The comparison on accuracy is shown in Table 1. We can observe
that both methods have very high accuracy, indicating that the inferred
orthology pairs from gene order data mostly agree with the annotations.
On the other hand, our method gets higher accuracy than MSOAR on
all the 10 pairs. The running time of MSOAR is also shown in Table 1.
On average, for each instance, MSOAR takes 108 min, which is on the
same level with our method (120 min for each instance).

In Table 2, we compare the number of operations and total score
inferred by the two methods to evaluate their ability as an optimizer.
First, we can see that our method gets more segmental duplications
and many fewer DC]s than MSOAR. One reason for this is that we
use smaller weight for segmental duplications. Second, our method
gets smaller total cost on all the 10 pairs. This shows the advantage
of our exact algorithm over the heuristic applied in MSOAR. Notice
that the total cost shown in Table 2 is computed using our weight,
i.e. d(B) + 0.75 -  + |T|), for both methods. However, if the total
cost is computed using MSOAR’s weight, i.e. d(B) + |S| + |T|, our
method still has less total cost on all pairs.

In Table 3, we analyze the distribution of the length of the
inferred duplicated segments by our method. We can see that most
of them are single-gene duplications. We can also observe that the
rat genome contains more duplications than the other four genomes.

In Table 4, we analyze the composition of B returned by our
method. If a gene family is a singleton in both genomes, then this pair
of genes cannot be duplicated and must be mapped to each other by
definition. We call such pair a trivial pair. Observe that roughly half
of the pairs in B are trivial pairs (trivial column). We also show the
percentage of the pairs that are fixed through the preprocessing algo-
rithm (predetermined column). We can see that this preprocessing al-
gorithm is very efficient, which can fix almost all the nontrivial pairs,
leaving a very small portion (remaining column) that are to be deter-
mined by the ILP. This is because these species contain many shared

segments and many isolated genes (because most of the segmental du-
plications are single-gene duplications), and thus there are many opti-
mal substructures that can be identified by our algorithm.

7 Conclusion and discussion

We proposed an exact algorithm to compute a set of DC]s and seg-
mental duplications with minimum total cost between two given
genomes. As far as we know, this is the first exact algorithm to com-
pare two genomes in the presence of duplicated genes with both re-
arrangements and content-modifying events. This algorithm can be
applied to infer in-paralogs and orthologs, and the inferred results
were showed highly agreeing with the annotations.

The algorithm described in Section 4.2 has potential to extend.
For example, it can be directly used to test whether a general sub-
structure, rather than a single PHFSS, is optimal. Moreover, we
made a strong assumption that all genes in the related gene families
are isolated, which immediately makes the cost of the segmental du-
plications trivial to compare and thus allows us to focus on the num-
ber of cycles. In fact, we can relax this assumption, as long as we
can guarantee that the segmental duplications induced by the sub-
structure that is tested is optimal.

Although the evolutionary model used in our algorithm, i.e. DC] plus
segmental duplication, is already quite general, there are some other
events, like tandem duplications, that cannot be explained by this model.
We will extend our algorithm for more general models in the future.

Conﬂict of Interest: none declared.

References

Bader,D. et al. (2001) A fast linear-time algorithm for inversion distance with
an experimental comparison. ]. Comput. Biol., 8, 483—491.

Bang-Jensen,]. and Gutin,G. (1998) Alternating cycles and trails in 2-edge-col-
oured complete multigraphs. Discrete Math., 188, 61—72.

Bergeron,A. et al. (2006) A unifying view of genome rearrangements. In:
Proceedings of the 6th Workshop on Algorithms in Bioinformatics
(WABI’06), Volume 4175 of Lecture Notes in Computer Science. Springer
Verlag, Berlin, pp. 163—173.

Bergeron,A. et al. (2009) A new linear-time algorithm to compute the genomic
distance via the double cut and join distance. Theor. Comput. Sci., 410,
5300—5316.

Braga,M. et al. (2010) Genomic distance with DC] and indels. In:
Proceedings of the 10th Workshop on Algorithms in Bioinformatics
(WABI’I 0), Volume 6293 of Lecture Notes in Computer Science. Springer
Verlag, Berlin, pp. 90—101.

Braga,M. et al. (2011) Double cut and join with insertions and deletions.
]. Comput. Biol., 18, 1167—1184.

Chen,X. (2010) On sorting permutations by double-cut-and-joins. In:
Proceedings of the 16th Conference On Computing and Combinatorics
(COCOON’1 0), volume 6196 of Lecture Notes in Computer Science.
Springer Verlag, Berlin, pp. 439—448.

Chen,X. et al. (2005) Assignment of orthologous genes via genome rearrange-
ment. ACM/IEEE Trans. Comput. Biol. Bioinform., 2, 302—315.

Dewey,C. (2011) Positional orthology: putting genomic evolutionary relation-
ships into context. Brief. Bioinform., 12, 401—412.

El-Mabrouk,N. (2001) Sorting signed permutations by reversals and inser-
tions/deletions of contiguous segments. ]. Discrete Algorithms, 1, 105—122.

Fu,Z. et al. (2007) MSOAR: a high-throughput ortholog assignment system
based on genome rearrangement. ]. Comput. Biol., 14, 1160—1175.

Gu,W. et al. (2008) Mechanisms for human genomic rearrangements.
Pathogenetics, 1, 4.

Hannenhalli,S. and Pevzner,P. ( 1995 ) Transforming cabbage into turnip
(polynomial algorithm for sorting signed permutations by reversals).
In: Proceedings of the 27th Annual ACM Symposium Theory of Computing
(STOC’95). ACM Press, New York, pp. 178—189.

112 /810'S{12umo[p101x0'soi112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

i338

M.Shao and B.M.E.Moret

 

Holloway,P. et al. (2013) Ancestral genome organization: an alignment ap-
proach. ]. Comput. Biol., 20, 280—295.

Kahn,C. and Raphael,B. (2008) Analysis of segmental duplications via dupli-
cation distance. Bioinformatics, 24, i133—i138.

Kahn,C. et al. (2010) Parsimony and likelihood reconstruction of human seg-
mental duplications. Bioinformatics, 26, i446—i452.

Moret,B. et al. (2013) Rearrangements in phylogenetic inference: compare,
model, or encode? In: Chauve,C. et al. (eds.) Models and Algorithms for
Genome Evolution, Volume 19 of Computational Biology. Springer Verlag,
Berlin, pp. 147—172.

Shao,M. and Lin,Y. (2012) Approximating the edit distance for genomes with
duplicate genes under DC], insertion and deletion. BMC Bioinformatics,
13(Supp119), 513.

Shao,M. et al. (2014) An exact algorithm to compute the DC] distance for
genomes with duplicate genes. In: Proceedings of the 18th International
Conference on Computations of Molecular Biology (RECOMB’14),
Volume 8394 of Lecture Notes in Computer Science. Springer Verlag,
Berlin, pp. 280—292.

Yancopoulos,S. et al. (2005 ) Efﬁcient sorting of genomic permutations by trans-
location, inversion and block interchange. B ioinformatics, 21, 3340—3346.

112 /810'S{12umo[p101x0'soi112u1101uioiq/ﬁd11q 111011 papeolumoq

910K ‘09 isnﬁnV no 2:

