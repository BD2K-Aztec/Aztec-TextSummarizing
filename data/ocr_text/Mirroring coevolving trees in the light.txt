ORIGINAL PAPER

Vol. 28 no. 9 2012, pages 1202-1208
doi: 1 0. 1 093/bioinformatics/bts 1 09

 

Phylogenetics

Advance Access publication March 6, 2012

Mirroring co-evolving trees in the light of their topologies
Iman Hajirasoulihal’I, Alexander Sch nhuch’I, David de Juan3, Alfonso Valencia3 and

S. Cenk Sahinalplﬁk

1School of Computing Science, Simon Fraser University, Burnaby, BC, V5A 1S6, Canada, 2Centrum Wiskunde &
Informatica (CWI), Science Park 123 1098 XG, Amsterdam, The Netherlands and 3Structural Biology and
Biocomputing Programme (CNIO) Spanish National Cancer Research Centre, 28029 Madrid, Spain

Associate Editor: David Posada

 

ABSTRACT

Motivation: Determining the interaction partners among
protein/domain families poses hard computational problems,
in particular in the presence of paralogous proteins. Available
approaches aim to identify interaction partners among
protein/domain families through maximizing the similarity between
trimmed versions of their phylogenetic trees. Since maximization
of any natural similarity score is computationally difficult, many
approaches employ heuristics to evaluate the distance matrices
corresponding to the tree topologies in question. In this article, we
devise an efficient deterministic algorithm which directly maximizes
the similarity between two leaf labeled trees with edge lengths,
obtaining a score-optimal alignment of the two trees in question.
Results: Our algorithm is significantly faster than those methods
based on distance matrix comparison: 1 min on a single processor
versus 730 h on a supercomputer. Furthermore, we outperform
the current state-of-the-art exhaustive search approach in terms of
precision, while incurring acceptable losses in recall.

Availability: A C implementation of the method demonstrated in this
article is available at http://compbio.cs.sfu.ca/mirrort.htm

Contact: imanh@sfu.ca; cenk@sfu.ca; as@cwi.nl

Received on October 18, 2011; revised on February 23, 2012;
accepted on February 24, 2012

1 INTRODUCTION

The vast majority of cellular functions are exerted by combinations
of interacting gene products. As a result, ‘preservation of
functionality’ among proteins and other gene products typically
implies ‘preservation of interactions’ across species. It is
well established that protein—protein interactions (both physical
interactions as well as co—occurence of domains) are preserved
through speciation events [see Lovell and Robertson (2010); Pazos
and Valencia (2008) and the references therein]. A major implication
of this is that the evolutionary trees behind two interacting protein
families can look near—identical.

As interacting proteins have a tendency to co—evolve, it may
be possible to assess the potential of two or more proteins (or
other gene products) being interaction partners by measuring how
similarly they evolve across related species. For this purpose, a
number of computational strategies have been developed. Such

 

*To whom correspondence should be addressed.
IThe authors wish it to be known that, in their opinion, the ﬁrst two authors
should be regarded as joint First Authors.

strategies aim to compare the phylogenetic trees of two (or more)
protein or protein—domain families, where paralogs and orthologs
are represented with leaves with appropriate labels and internal
vertices can be interpreted as either speciation or duplication events.
Among these strategies we will focus on mirrortree approaches,
which explicitly or implicitly map leaves of a pair of trees (belonging
to two distinct proteins or gene products) onto one another such
that the leaves that are mapped to each other would be identiﬁed
as potential interaction partners. Mirrortree approaches aim at an
overall quantiﬁcation of ‘family similarity’ Via a measure of tree
similarity. Typically, these approaches do not aim to modify the
speciﬁc topology of the underlying phylogenetic trees and thus
are different from tree reconciliation approaches (Page, 1994;
Vyugin et al., 2002). They are also distinct from phylogenetic
proﬁling methods (Pellegrini et al., 1999), which aim to measure the
phylogenetic proﬁles of proteins or domains to check for potential
interaction partners.

The ﬁrst mirrortree approach was proposed to discover protein—
protein (rather than domain—domain) interactions and was based
on comparing the distance matrices1 resulting from the multiple
alignment members of each protein family (Pazos and Valencia,
2001). Note that one can interpret this as mapping leaves onto one
another, as will be explained below. Since this study, a number
of mirrortree approaches have been developed; almost all of these
approaches are again based on comparing distance matrices rather
than the trees directly (see the introductory paper by Pazos and
Valencia (2001) and Pazos and Valencia (2008) for more references).
In fact, direct comparison of gene trees has been considered as ‘...
a problem yet to be fully resolved.’ (Izarzugaza et al., 2008, p. 2).

In this article, we consider a fresh approach to the problem of
predicting protein or other gene product interactions by comparing
gene trees directly, without the aid of a distance matrix. Note that
such a distance matrix is a byproduct of the underlying phylogenetic
tree: popular multiple sequence alignment methods typically align
sequences in the order imposed by their phylogenetic tree and
the ‘distances’ in the matrix correspond to the distances in the
phylogenetic tree. As a result our method should be considered as a
more direct approach to mirroring trees.

In the case where there are no paralogs of any gene, assessing
tree similarity is both computationally straightforward and reliable
(Pazos and Valencia, 2008). More speciﬁcally, if there is at most
one family member per species, the mapping problem reduces to

 

1The distance matrix of a gene tree is comprised of entries (1', j) which
represent the distance between leaves i and j.

 

1202 © The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com

112 /§.IO'SIBUJHOprOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 11101; prBOIUAAOG

9IOZ ‘09 lsnﬁnv uo ::

Aligning phylogenetic trees

 

the problem of ﬁnding out species where the interaction is lost;
after removal of such species, the topologies of the two trees will
be identical, i.e. the leaf representing a particular species in one
tree will correspond to the leaf representing the same species in the
other tree.

In the presence of paralogous genes (and thus proteins or gene
products), however, the mapping problem becomes much more
complex. For example, if we have n paralogs per tree for one of
the species, we may need to evaluate more than n! many potential
mappings (n! is the number of mappings where each paralog from
one tree pairs with a paralog from the other tree. In addition, there
are mappings where one has to remove non—interacting paralogs.
As was pointed out in Tillier et al. (2006), protein interaction
can be preserved during duplication, while interaction can be lost
during speciation). Thus, the number of potential mappings is super—
exponential in the number of paralogs per species, implying a
signiﬁcant computational challenge.

There are a number of mirrortree approaches which address
the presence of paralogs and aim directly at inferring the correct
mapping of leaves; these approaches typically aim to ‘align’ the
distance matrices by shufﬂing and eliminating the rows (and
corresponding columns) so as to maximize the similarity between
the matrices. The similarity between two aligned matrices is deﬁned
in the form of root mean square difference (Ramani and Marcotte,
2003), correlation coefﬁcient (Gertz et al., 2003), information—
theoretic ‘total interdependency’ of multiple alignments (Tillier
et al., 2006), Student’s t (Izarzugaza et al., 2008) or the size
of the largest common submatrix (Tillier and Charlebois, 2009).
Because an exact solution to the matrix alignment problem, where
the goal is to maximize any of these notions of similarity (by
determining the right mapping of rows and columns), is hard to
compute, many available approaches employ heuristics based on
swapping pairs of rows/columns in a greedy fashion. These methods
also commonly perform column/row elimination from the ‘larger’
matrix only, and not the other (Gertz et al., 2003; Izarzugaza et al.,
2008; J othi et al., 2005; Ramani and Marcotte, 2003; Tillier et al.,
2006). We are aware of one exception by (Tillier and Charlebois,
2009), which aims to determine the largest common (i.e. within a
threshold) submatrix and removes the remainder of the columns
and rows from both matrices. Similarly the only approach which
directly compares the tree topologies themselves is by Jothi et al.
(2005), which uses a Metropolis algorithm to heuristically travel
‘tree automorphism’ space. However, this approach cannot handle
trees of different sizes. See Lovell and Robertson (2010); Pazos and
Valencia (2008); and Tillier and Charlebois (2009) for references on
mirrortree approaches which do not necessarily relate to the mapping
problem in the presence of paralogs.

In this article, we present polynomial—time algorithms that
determine mappings of leaves which respect the topologies of the
two trees compared. As input, we are given two ‘gene trees’ T and T’
of two protein/domain families known to interact with one another.
T and T’ have labeled leaves where labels reﬂect species such that
the presence of the same label at two different leaves reﬂects the
presence of paralogs. We introduce and formally deﬁne the gene
tree alignment problem, which aims to delete both leaves and inner
vertices from both trees until the remaining trees are isomorphic,
that is, one can map the vertices of the two remaining trees in a
one—to—one fashion onto another such that ancestor relationships are
preserved. This in particular implies a one—to—one mapping of the

remaining leaves, which we present as output. Clearly, there are
many different possible choices of such one—to—one mappings of
leaves—our algorithms determine the score-optimal such alignment
where different deletion operations are penalized in different ways,
depending on how they transform the topologies of the trees. Note
that our algorithm depends on some (user—deﬁned) cost parameters,
that can be used to impose constraints on the alignment. We describe
the nature of our scoring scheme in detail in the following; please
see Section 3 for full details and precise notations.

Note that the algorithm only outputs one uniquely determined,
score—optimal alignment of subsets of leaves of T, T’ . Note further
that we do not perform an exhaustive search since we never consider
mappings of leaves which imply mappings of internal vertices that
do not preserve ancestor relationships of the gene trees T, T’ and
thereby contradicts their topologies.

Our method can be viewed as an extension of tree—edit distance
approaches. Alternative constraints leading to polynomial time
solvable variants on the tree edit distance is surveyed in Zhang
(1996). For further, more recent work see also Pinter et al. (2008)
that address the subtree homeomorphism problem, which, given a
‘text’ tree T and a ‘pattern tree’ P as the input, asks to ﬁnd a subtreet
in T such that P is homeomorphic to 1. Now, two trees T1 , T2 are said
to be homemorphic if one can remove degree 2 vertices from T1,T2
such that T1 and T2 are isomorphic. Another recent work (Raynal
et al., 2010) considers homeomorphic alignment of ‘weighted’ but
unlabeled trees. Here the goal is to obtain a homeomorphic mapping
between vertices of two trees such that the differences between the
weights of ‘aligned’ edges is minimized. While being related to
our approach, the method described in Raynal et al. (2010) is not
applicable to our problem as the trees they consider are not leaf
labeled. We refer the reader to Bille (2003) for a general and gentle
overview of further related work on tree edit distance, tree alignment
and tree inclusion.

The main technical contribution of this article is a novel
deterministic mirrortree algorithm that directly compares tree
topologies. The algorithm is optimal within the constraints we
impose and is provably efﬁcient. We compare our algorithm with the
most recent, state—of—the—art heuristic search approach (Izarzugaza
et al., 2008) that aims to maximize the similarity between distance
matrices, where distances reﬂect lengths of shortest paths in
neighbor—joining trees. In our comparisons, we use precisely the
same trees to be able to juxtapose a distance matrix—based heuristic
search method to our topology—based, deterministic method without
introducing further biases.

2 PRELIMINARIES AND NOTATIONS

Let T=(V,E,w) be a tree with weighted edges as given by a non—
negative weight function sz —>R+. We denote the leaves of T
by L={£1,...,£n}, the internal nodes of T (excluding the root) by
U ={u1 , ...,um} and the root of T by r. In particular, let n be the
number of leaves and m be the number of internal vertices without
the root. Note that a tree T is binary and rooted if and only if
deg(r)=2 and deg(u)=3 for all internal vertices we U; this will
imply that m=n—2 and |E| =2n—2. In our setting, edge weights
w(vi,vJ-) reﬂect the evolutionary distance between adjacent vertices
vi,vJ-. Note that leaves refer to gene products whereas internal
vertices can be interpreted as speciation and/or duplication events.
For a given vertex v E V, we deﬁne 6(1)) as the evolutionary distance

 

1 203

112 /§.IO'SIBUJHOprOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 11101; prBOIUAAOG

9IOZ ‘09 lsnﬁnv uo ::

I. Hajirasouliha et aI.

 

between the root and v. In other words, 6(1)) is the sum of the edge
weights in the unique path from the root to v. In rooted trees, there
is a natural partial order

12,5 vj <=> v,- is an ancestor of vi (1)

on the vertices of T. Hence, the edges have a natural orientation and
each vertex v,- induces a unique subtree T(v,-). This partial order is
crucial for our algorithm—which cannot be applied to unrooted trees
in a straightforward manner. For processing unrooted (e.g. neighbor—
joining) trees, consider the pair of proteins/domains (one from each
tree) which are known to interact. We root the two trees at these
vertices in order to apply our algorithm. Provided such a pair exists
(which is typically the case), our algorithm optimally aligns the trees
as it does not assume any order among the many sibling vertices.
In a tree T which is rooted at r, we call vertex a the parent of a
vertex v if a and v are connected by an edge and a is closer to r than
v. The height of a rooted tree is deﬁned as max{d(r,£l-) | i: 1, ..., n}
where d(v1,v2) is the length of the shortest path between vertices
v1 and 122 without considering edge weights, that is the maximum
(unweighted) distance of the root to a leaf. We denote a bijection
(i.e. a one—to—one and onto alignment) of subsets of vertices of T, T’
by M[T, T’ ] and write

M:={(v,w)€TXT’|M(v)=w} (2)

for the pairs of mapped vertices. Note that in such a bij ection, not all
vertices of T are necessarily mapped to a vertex in T’ and vice versa.
We refer to vertices which are not mapped as deleted by M[T, T’].
We only consider alignments which satisfy the following: (i) the
alignment preserves the ancestor relationship of T and T’; (ii) only
leaves with identical labels are mapped onto one another; and (iii)
upon deletion of vertices, where deletion of an internal vertex 12 leads
to new edges joining the parent of v with the children of v, the two
tree topologies are isomorphic. Among the alignments satisfying
the above conditions, we compute the alignment that has maximum
score.

For a formal deﬁnition of our scoring scheme, consider the
internal vertices of T and T’ that are deleted. Among them, we
distinguish between vertices 12 that have descendants x which are
not deleted. We write N] for such vertices. We write NT for the
remaining deleted vertices. Note that each vertex v 6 NT makes part
of a subtree of T which has been deleted as a whole. The score of
the alignment is then deﬁned as

5(M[T,T’]>
= Z SM(v,v’)-I— Z SN,(v)+ 2 mm (3)

(v,v’)EM VEN] VENT

The individual score functions SM,SNI and SNT will be formally
deﬁned in Section 3. As noted above, our algorithm, which
maximizes the overall score of the alignment, can be viewed as an
extension of the standard tree edit distance algorithm for unweighted
trees (Tai, 1979), to those with edge weights. Determining the tree
edit distance is NP—complete (Zhang et al., 1992) [in fact MAX—
SNP—hard (Zhang and J iang, 1994)]. Since the instances treated here
are too large (trees have up to >200 leaves) we have to impose
reasonable constraints when aiming at fast, polynomial—runtime
solutions. Motivated by test runs (see numbers referring to CLZ
in Sections 4 and 5), we chose to impose the additional constraint

Fin-all R0012
a" "s 4' 
 \ a, bl .' 
  

Fig. 1. Two isomorphic trees are shown as an example in this ﬁgure. The
leaves of the left tree are labeled with a1 , a2, a3 and a4 whereas the leaves of
the tree on the right are labeled with 191,192,193 and 194. A possible mapping
between the leaves that respect the tree topology is (a1,b3), (a2,b4), (a3,b2)
and (a4 , b1 

that a vertex a and its parent 12 cannot be deleted at the same time
without deleting the entire subtree rooted at 12. That is we disallow
to have both a parent v and a child a in N1. Note, however, that
deletion of two internal siblings is permissible—we found that such
deletions can lead to favorable alignments. As the operation of
deleting entire subtrees does not lead to runtime issues, does not
perturb the topology of the remaining trees and also reﬂects the
biologically reasonable assumption that interaction can be lost for
entire subtrees, we allow it without additional restrictions.

3 METHODS

Given two rooted weighted—edge trees T and T ’ , our algorithm aligns the
trees by mapping a subset of leaves of T to a subset of leaves of T ’ . In
order to obtain this mapping, a series of (i) individual vertex deletions or
(ii) subtree deletions (with speciﬁc penalties) are performed on each tree
with the goal of obtaining two isomorphic trees T1=(V1,E1,w1) (from
T) and T{=(V/,Ei,w/1) (from T i ); Figure 1 shows two such rooted trees
that are isomorphic; it also shows a mapping between the leaves. The
speciﬁcs of vertex and subtree deletions on a tree T=(V,E,w) are as
follows.

( 1) Deleting an internal vertex v also deletes the edge (u,v), where a is
the parent of v. Furthermore, it connects each child x of v to a by
deleting the edge (v,x) and creating a new edge (u,x). The weight of
this new edge, w(u,x) is set to w(u, v)+w(v,x). As mentioned earlier,
it is not possible to delete both a node v and its parent a from T.

(2) Deleting an entire subtree rooted at an internal vertex v deletes all
descendants of v and their associated edges.

In the remainder of this section, we will discuss the costs of the above
deletion operations and the scores of the mapped vertices. As mentioned
earlier, the overall score of the mapping will be the sum of the scores of the
mapped vertices and the scores (negative costs) of the the deletion operations.

3.1 Scoring scheme

Let T1 and T i be the isomorphic trees which result from performing a series
of deletion operations on T and T ’ . The isomorphism CI>:T1—> Ti implies
an alignment M[T, T’] between the original trees T, T’. Let L1,L’1 denote
the sets of leaves that are mapped in T and T’, respectively; because the
mapping is a bijection, we must have |L1|=|L/1|. We write SP:= {(1,1’) lie
L,l’ eL’, (l,l’) EM} CM[T, T’] for the set of mapped pairs (we require that
mapped leaves have identical labels hence the naming SP for ‘species’).

Recall that a mapping of two trees may involve deleting internal vertices
or entire subtrees. We now distinguish between two types of internal vertex
deletions.

(1) [Isolated Deletionz] deletion of only one child v of a vertex a. Let
further x1,x2 be the two children of v. Isolated deletion of v also

 

1 204

112 /§JO'SIBurnoprOJIXO'sor112u1101urorq//zd11q 111011 pep1201umoq

9IOZ ‘09 lsnﬁnv uo ::

Aligning phylogenetic trees

 

implies to also delete edges (a, v), (v,x1), (v,xg) and create new edges
(u,x1), (u,xg). Note that after deletion v has three children.

(2) [Parallel Deletionz] deletion of both children (say x and y) of a
vertex v. This implies deletion and creation of edges in a fashion
analogous to that for isolated deletion. Note that after deletion v has
four children.

Accordingly, we further distinguish between isolated deleted vertices Nlaiso
and vertices which became deleted in parallel Nlapar such that N1 =
NIJSO UNLPar. The idea behind distinguishing between isolated and parallel
deletion is that parallel deletion reﬂects greater perturbation of tree topology
at the same evolutionary point in time, and is less likely to occur. For a given
mapping M[T, T’] let ES(M) :2 {(u,v) | v eNIaiSO} be the set of edges which
join isolated deleted vertices with their parents. Analogously, Ep(/\/l) is the
set of edges that join deleted siblings with their parent. See Figure 2 for
examples of isolated and parallel deletions.

Given a pair of mapped leaves 21,22 6 SP their alignment score, 1421 , Zg)
is deﬁned as

I421 .172): C — |9(€~1)—9(€~2)l

where C is a positive constant, providing a positive contribution to the
overall score because of the mapping of two leaves with the same label
while we subtract the difference between the distances of [1 and [g from the
root for penalizing the mapping between two leaves which have topologic
differences.

The total score 8 of an alignment M[T, T’] as per the above deﬁnition is
fully speciﬁed by

swam/1): 2 “21.22)
(Z1,ZZ)ESP

— Z E-w(es)— Z F-w(ep)

es  6p 

(4)

where, with respect to the formulation in (3), the term in the ﬁrst row is for
Zvav/GMSMozm/L the second row is for ZveNISNI(v) and ZVGNT SNT(v) is
zero. E and F are user—deﬁned constants that, respectively, penalize isolated
deletion and parallel deletion of edges. Note that this penalty is proportional
to the length of the edges joining the deleted vertices with their parents—
deletion of longer edges leads to a more severe perturbation of topology hence
is more severely penalized. We set the cost of deleting a subtree (i.e. SNT) to
0. Note, however, deleting subtrees is implicitly penalized by disregarding
any potential good mappings of leaves in them.

Given the above score function, the gene tree alignment problem can be
formally stated as follows.

Gene tree alignment problem. Given two rooted weighted—edge trees T, T‘,
determine subsets of leaves L1CL,L/1CL’ of equal size such that the
corresponding subtrees can be transformed by isolated and parallel deletion
and subtree removal operations into trees T1,Ti, for which there is an
isomorphism CI) : T1 —> Ti that maximizes S(M[T, T/]).

3.2 A dynamic programming solution

The gene tree alignment problem can be efﬁciently solved by a dynamic
programming algorithm. Our algorithm runs in 0(|V| - IV/ |) time for two
binary, rooted trees T ,T ’ with vertex sets V, V’ . In general, our strategy
can be applied to arbitrary rooted trees with bounded maximum degree,
Amax. Note that by allowing to delete internal vertices (i.e. contract the
edges), the number of children of an internal vertex will be still bounded by
a constant (54).

Initialization. As a ﬁrst step, we remove all leaves that refer to species that
are unique to each tree. Let n: |V| and n’ = |V’ |. For every pair of vertices
v,- e V and v; e V’ (i.e. for every i=1,...,n andj=1,...,n’), we compute the
maximum alignment score for the subtrees rooted at v,- from T [i.e. T(v,-)]

(3) A7

A5/ \A6
Al/ \A2 A3/ \A4

No deletion

(0) //A7\\
A1 A2 A3 A4

Parallel deletions of two
nodes: A5 and A6

(1,) A7
\
// ..
/ \
A1 A2 A3 A4

An isolated deletion: A5

Fig. 2. A gene tree (a), with an isolated node deletion, A5 (b) and a parallel
deletion of the nodes, A5 and A6 (c).

and 12’. from T [i.e. T ’ (124)]. We denote the maximum alignment score for T (vi)
and T/ (1);.) by S Note that the computation of the maximum alignment score
between rooted subtrees induce a mapping between their leaves.

In our dynamic programming algorithm, we handle the ‘base’ cases, where
one (or both) of T (vi) or T (12;) have three or fewer leaves, as follows.

0 If both v,- e V and v; e V’ are leaves, then by deﬁnition, Sl‘j =Ic(v,-, v15).

0 Without loss of generality, if v,- is a leaf and 12‘. is an internal vertex,
Sl‘j =max(S,-j1 ,Sl‘jz), where j1 and jg correspond to the children of v14.

0 The remainder of the base cases have both v,- and Vj as internal
vertices and are solved through exhaustive evaluation of all possible
alignments.

Recursion. Internal vertices, each with at least four descendants, Si]- will be
computed through recurrence equations. These equations are based on the
alignment scores between subtrees rooted at the children (or grandchildren)
of v,- and v}. Let i1(jl) and ig(jg) be the children of the vertex 12102;). Also,
let 111, 112 be the children Of i1, and 121, 122 be the Children Of ig. Similarly,
let j11, j1g be the children of j1, and jg1, jgg be the children of jg. We ﬁrst
give a high—level description of the recurrence equation. Suppose that the
maximum alignment score between any subtree in T (v,) and any subtree in
T / (v15) has already been computed. In order to compute the alignment score
Sl‘j, we consider several cases: we can either delete one or both subtrees
rooted at the children of v,- and v’. (deleting an entire subtree) or align the
subtrees rooted at the children of v,- and v’. to each other. We can also delete
one of the children of v,- (either i1 or ig) together with one of the children
of vj (either j1 or jg) and align the three resulting subtrees in T (v,) to a
permutation2 of the ones in T’(1/.). Finally, we have to consider the case
where both children of the root [i.e. i1 and ig in T (vi), and j1 and jg in T ’ (123)]
are deleted. In this case, we align four subtrees in T(v,-) (rooted at in, i1g, ig1,
igg) to a permutation of the four resulting subtrees in T ’ (v14). The optimal
alignment score of Sij will thus be the maximum alignment score provided
by all of the cases above.

Let e(v) denote the penalty for isolated deletion of an internal vertex v,
which is the product of the constant E and the weight of the edge between v
and its parent (see Section 3.1). Also, let f (v) denote the penalty for parallel
deletion of both children of an internal vertex v. f (v) was deﬁned as a constant

 

2We have to consider all the permutations because the trees are unordered
(i.e. the order of siblings of an internal vertex is unimportant).

 

1 205

112 /§JO's12urnofp101x0's31112u1101u101q//:d11q 111011 pep1201umoq

9IOZ ‘09 lsnﬁnv uo ::

I. Hajirasouliha et al.

 

F times the total weight of the edges that connect v to its children. The
recurrence equation for Sl‘j thus becomes the following

'0 (deleting both subtrees from each tree)

S. . S. .
’1“ + 1212 regular cases
Sim +5i2j1
5171
5..
SW deleting one subtree from each tree
iij
Sizj
Sinjz +Si12i11+Si2j12
ma)“ Sinjz +Si12i12 +Si2j11 _e(i1)_e(]-1)
511212 +Si11j11+Si2j12
> i12i2 +Si11j12 +Si2j11
Sij = max 1 512112  +Sl-1JI12 (5)
max‘ 1211.2 ,- - 11]“ —€(i2)—€(il)
 21.111 +Si1j12
>Si22j2 +Si21j12 +Si1j11‘
Si21j1+Si22j21+Si1j22
max« Simjl +Si22j22 +Si1j21 * —e(i2)—e(iz)
Sin/'1 +Si21j21+Si1j22
>Si22i1+Si21j22 +Si1j21 1
Si11j1+Si12i21+Si2j22
max« Si11j1+Silmz +Si2j21 * —e(i1)—e(iz)
Si12i1+Si11j21+Si2j22
Si12i1+Si11j22 +Si2j21,

 

 

 

S111JT1+Si12712 +Siz1fr3 +Sizzﬂ4 

where the permutation 112111112113714 ranges over all permutations of
{j11,j1g,jg1,jgg}. Note that some cases are redundant but are still represented
here for the sake of clarity. In case that several options yield the same, optimal
score, the algorithm picks the ﬁrst observed one.

Now, given r and r’, the roots of T and T ’ , respectively, the alignment
score Sm2 (i.e. the maximum alignment score of the rooted trees) can
be computed using the above recurrence equation, providing a solution to
the gene tree alignment problem. It is quite straightforward to prove that
our algorithm correctly computes the maximum alignment score through a
(strong) induction on the sum of the heights of the rooted trees. Note that
the scores of internal vertex alignments can be computed through the scores
of the alignments between their (grand)children and the recurrence precisely
serves to satisfy the constraints. The base of the induction is trivial. If the
minimum height of the trees is zero (i.e. one of the trees is just a single
leaf), the optimal value of the alignment can be found using the deﬁnitions
and simple case analysis. Given the subtrees T(v,-) and T/ (v14), with heights h
and h’, respectively, we assume the induction hypothesis, that for all pairs of
subtrees T(vp) and T/ (12:1) with heights hp and hq such that hp +hq < h+h/ . It
is easy to verify by case analysis that all cases in the recurrence equation will
be reduced to a case in which the sum of the heights of the aligned (grand)
children will be less.

Evaluation criteria. We determine the maximum number of members of
the two protein domain families under consideration that can be paired
by following (Izarzugaza et al., 2008): for each species we determine the
paralogous members of the domain in the two trees that can be paired with
one another (that is both members reside in the same protein) and determine
the maximum number of pairs that can result from the respective potential
pairings. Summing up these numbers yields the maximal size of a correct
mapping. By the usual conventions, we denote this value as P. In other
words, P is the size of the correct pairing. Among the P many potential
correct pairs, we determine the ones which were inferred by the algorithm
in use and refer to them as ‘true positives’, TP. Similarly, the number of

 

 

 

 

 

— I Baseline

co. _ I MatrixHeuristic
o C] TreeTopology
‘12 _

o

c\! _

o

O. _

o

   

Recall Precision

Fig. 3. Recall and Precision for the heuristic matrix—based approach
[MatrixHeuristic, (Izarzugaza et al., 2008)] and the deterministic, tree—
topology—based approach (TreeTopology = Copt). Baseline is determined as
randomly pairing as many protein domain family members as possible.
Runtimes for MatrixHeuristic and TreeTopology are 730h and 1min,
respectively.

Table 1. Evaluation of different schoring schemes. Copt is ’TreeTopology’
in the other ﬁgures.

 

 

Method RP Recall RelRec Precis
C0 0.546 0.330 0.557 0.447
C1 0.610 0.378 0.586 0.475
C{1,g} 0.612 0.377 0.581 0.471
Cser 0.638 0.373 0.556 0.444
Copt 0.612 0.380 0.588 0.479

 

domain pairs computed, where the respective members are not from the
same protein, is referred to as ‘false positives’, FP. Recall (Sensitivity) is
deﬁned as Rec=TP/P and Precision (positive prediction rate) is deﬁned as
Prec=TP/(TP+FP). Note that Recall is referred to as accuracy in (Izarzugaza
et al., 2008). We determine Precision and Recall for each pair of trees
individually. Values displayed in Figure 3, Table 1 and Figure 4 (see Section
4) are average values for all 488 co—evolving tree pairs respectively for all
tree pairs satisfying the respective criteria.

4 RESULTS

Data source and alternative methods. We benchmarked our
algorithm against the most recent heuristic search method
(Izarzugaza et al., 2008) for determining a mapping in the presence
of paralogs on the large—scale data corpus described in the same
study. This data set contains multiple alignments for 604 yeast
protein domains among which 488 domain pairs are known to
co—occur in the same protein. Those 488 domain family pairs are
considered to be a particularly tough test (Izarzugaza et al., 2008)
due to the presence of ~6 paralogs per species on average. For
all interacting domain family pairs, neighbor—j oining trees were
computed, using ClustalW (Thompson et al., 1994) and the trees
were rooted at the domains which are known to interact.

Tree constraints. In order to appropriately assess the contribution of
the different tree constraints as outlined in Section 3, we evaluated
our algorithm by not allowing to delete internal nodes (C0), allowing
isolated node deletion (C1) as well as further allowing parallel
deletion of two sibling nodes (C1, g), see Figure 2c for an example.
We also include the test case Cser where we allow for deletion of
a parent and a child, simultaneously. In all the above cases, we

 

1 206

112 /§JO's12urnofp101x0's31112u1101u101q//:d11q 111011 pep1201umoq

9IOZ ‘09 lsnﬁnv uo ::

Aligning phylogenetic trees

 

Space: Recall Space: Precision

 

 

        
  

  

 

 

 

 

 

 

 

 
 

 

 

 

 

 

 

0_7 - l—a- MatrixHeuristic l—a— MatrixHeuristic
-0- TreeTopology 0 5 ‘NN -0- TreeTopology

0.6 - - .......... ~_

0.5 — 0.4 ~~~~~~~~~~~ __

0.4 '9‘ .......... ~_ 0 3 

0.3 - ------------------- __ '

0.2 - , , 0.2 ,

<11680 >=11680 <11680 >=11680
Size: Recall Size: Precision

 - + MatrixHeuristic -B- MatrixHeuristic
-<>- TreeTopology 0 5 _ “..‘x -<>- TreeTopology

0.6 — l— - ~~ .... ,1 l—

0.5 - ~~~~~ ..

9..“ 0.4 - 
0.4 - - - ~ ~ ~ — . . . . , , _ 1 1 _ ~ ~ ~ ~.
0.3 - ~~~~~~~~~~~~ ._ -
-..g 0.3
0.2 _ I | I I
<120 >= 120 <120 >= 120

Fig. 4. The comparison of our method with the heuristic search method
reveals favorable results for large trees (bottom row), x—axis indicates the
size (number of leaves) of the larger tree of the two trees paired and in
particular for large search spaces, that is for Space :11 680 where Space is
the product of the number of leaves of the two trees paired.

allow deletion of subtrees as a whole without penalty. The speciﬁc
scores for these cases are as follows: C02C=1,E=oo,F =oo,
C12C=1,E=0,F=oo and C1,22C=1,E=F=0.

Among the cases above CLg gives the best results (see Table
1 and further comments below), implying that parallel deletions
are beneﬁcial. We experimented with several values of E and F,
and noticed that it may be beneﬁcial to impose a large penalty for
parallel deletions in contrast to a relatively small penalty for isolated
deletions. We concluded that an optimal choice of parameters would
be E =2,F =50 (referred to as Copt), when C: 1. Note that the
exact value of C is the function of neighbor—joining trees resulting
from ClustalW multiple alignments alone—for different settings
absolute values need to be put into perspective with orders of
magnitude of edge weights of the trees under consideration.

As outlined in Section 3, inducing tree constraints considerably
reduces the search space, thereby allowing for an efﬁcient and
deterministic method. Given a pair of trees, let CP (constraint
positives) denote the maximum number of correctly paired domains
over all possible alignments of the trees. Note that one can compute,
CP for any given pair of trees, by running our algorithm with a
scoring scheme which assigns 1 to correctly paired domains and not
penalizing any operation which the constraints allow us to do.3 We
compute RP=CP/P (relative positives) as the fraction of pairings
that can still be inferred, and which measures the reduction of
search space size due to imposing constraints. We further compute
RelRec=TP/CP (Relative Recall) as a recall value which reﬂects
how many of the correct pairings possible were inferred by the
algorithm in question. The good RelRec values the tree topology
approach achieves (0.59 versus 0.55 for the matrix—based approach,
note that for the matrix—based approach this coincides with Recall
since it does not impose any constraints), indicate that losses in
Recall are due to imposing constraints, but not necessarily due to
the scoring scheme.

Figure 3 presents numbers of all 488 tree pairs for a canonical
baseline procedure, which randomly pairs as many domain family

 

3This scoring scheme assumes knowledge we are not allowed to use in the
algorithm; we use this knowledge for the purpose of evaluation here.

members per species as possible, the heuristic matrix—based
approach (MatrixHeuristic) and the deterministic tree—topology—
based approach (TreeTopology = Copt). Table 1 furthermore
presents numbers resulting from usage of different tree constraints.
Following (Izarzugaza et al., 2008), we also separate tree pairs
according to the numbers of leaves of the larger tree and the product
of the numbers of leaves of the two paired trees which, according
to (Izarzugaza et al., 2008), quantiﬁes search space size. See Figure
4 for the respective results.

5 DISCUSSION

Runtime. The possibly most striking advantage of our topology—
based approach is the drastic reduction of runtime—we can
compute mappings for the 488 interacting domain families in
roughly 1 min on a single CPU—in comparison to 730 h on
MareNostrum4 needed for the Metropolis search performed by
(Izarzugaza et al., 2008). Note that there are rapidly growing
large—scale phylogenetic databases such as ENSEMBL (ht tp: / /
ensembl.org) or PhylomeDB (http: //phylomedb.org),
whose growth is further accelerated by next—generation sequencing
projects (as of 12th August, 2011, PhylomeDB contains 482274
phylogenetic trees). The reduction in runtime delivered by our
approach certainly overcomes a major obstacle—we render large—
scale mapping and, as a consequence, comparison of paralog—rich
gene trees feasible. Note that this reduction has become possible
by imposing both computationally and biologically reasonable
constraints on the search space while at the same time allowing for an
efﬁcient scheme to ﬁnd the global optimum within these constraints.

Search space size/recall. Comparing Copt with the method of
(Izarzugaza et al., 2008) (heuristic) overall, clearly, Izarzugaza
et al. (2008) achieve best recall. As pointed out above, this comes
as no surprise since we cannot explore pairings that contradict
the topologies of the paired trees. Quite surprisingly though,
although usage of tree topology and neighbor—joining trees in
particular have been discussed rather controversially (Waddell
et al., 2007), we ﬁnd that still the majority of pairings (54.6%
with the strictest constraints and 61.2% for allowing isolated
and parallel deletion) can be determined by a topology—based
approach. These numbers may put usage of neighbor—joining tree
topology in mirrortree approaches into a general perspective.
Moreover, note that the fraction of correct domain pairs computed
by our method over that of the heuristic search method is
~0.7 (= TP( Copt)/TP(heuristic) = Recall(C0pt)/Recall(heuristic) =
%) which is more than what was to be expected by reduction of the
search space (CP(Copt)/ CP(heuristic) = CP(Copt)/P(heuristic) =
RP(C0pt) = 0.61) which points out that we compensate search space
reduction by a more effective search strategy. This becomes reﬂected
by the better RelRec values of Copt.

Precision. Precision favors the topology—based approach, at least
on larger (combinations of) trees (see ﬁgure 4 and table 1). Better
precision reﬂects a larger fraction of the correct domain pairs among
the pairs inferred overall. We achieve slightly better values in terms

 

4MareNostrum is a supercomputer of the Barcelona Supercomputing Center,
one of the largest machines in the world dedicated to science (Izarzugaza
et al., 2008, p. 10).

 

1 207

112 /§JO's12urnofp101x0's01112u1101u101q//:d11q 111011 pep1201umoq

9IOZ ‘09 lsnﬁnv uo ::

I. Hajirasouliha et al.

 

of Precision than (Izarzugaza et al., 2008), see Precision in Figure 3.
See also Figure 4 for a comparison with respect to search space size—
related differences. While Izarzugaza et al. (2008) achieve excellent
values on pairs of smaller trees, we outperform their approach on
larger trees, with the most obvious differences on pairs of trees where
the product of the numbers of leaves is large.

Conclusion. In summary, we have, for the ﬁrst time, devised a
deterministic and efﬁcient, polynomial—runtime mirrortree approach
which directly compares the gene trees, and not the distance matrices
behind or giving rise to them. We have juxtaposed our approach
with the most recent, state—of—the—art matrix—based heuristic search
procedure without introducing further experimental biases. Most
importantly, our tree topology—based algorithm lists efﬁciency as
its decisive beneﬁt. While recall is better for the heuristic search
obviously due to that it does not impose any constraints on the search
space, we only incur relatively mild losses. We achieve better results
in precision, in particular when both of the mirrored trees are large.
This leads us to the overall conclusion that the heuristic method
remains the better choice for smaller trees and when runtime is not
an issue. In case of larger trees and in particular for large—scale
studies, our approach has considerable beneﬁts. Note ﬁnally that
we have been comparing neighbor—joining trees which have been
repeatedly exposed as suboptimal choices of phylogenetic trees. We
believe that our approach can gain from improvements in tree quality
signiﬁcantly more than the matrix—based approaches. Note ﬁnally
that mapping domains can lead to ambiguous results due to that
several homologous copies can co—occur in one protein. To resolve
such issues is interesting future work.

Funding: I.H. was supported by an Natural Sciences and Engineering
Research Council of Canada (NSERC) Alexander Graham Bell
Canada Graduate Scholarships. A.S. was supported by a post—
doctoral fellowship of the Paciﬁc Institute of Mathematical Sciences.
S.C.S. receives funds from the NSERC and Bioinformatics for
Combating Infectious Diseases.

Conﬂict of Interest: none declared.

REFERENCES

Bille,P. (2003) Tree edit distance, alignment and inclusion. Technical Report TR-2003-
23. IT University of Copenhagen. Available at http://itu.dk/en/Forskning/Technical-
Reports/2003fTree-Edit-Distance-Alignment-Distance-an.

Gertz,J. et al. (2003) Inferring protein interactions from phylogenetic distance matrices.
Bioinformatics, 19, 2039—2045.

Izarzugaza,J. et al. (2008) Enhancing the prediction of protein pairings between
interacting families using orthology information. BMC Bioinformatics, 9, 35.
J0thi,R. et al. (2005) Predicting protein-protein interaction by searching evolutionary

tree automorphism space. Bioinformatics, 21(Suppl. 1), i241—i250.

L0vell,S. and Robertson,D. (2010) An integrated view of molecular co-evolution in
protein-protein interactions. Mol. Biol. Evol, 27, 2567—2575.

Page,R. (1994) Maps between trees and cladistic analysis of historical associations
among genes, organisms, and areas. Syst. Biol, 43, 58—77.

Pazos,F. and Valencia,A. (2001) Similarity of phylogenetic trees as indicator of protein-
protein interaction. Protein Eng, 14, 609—614.

Pazos,F. and Valencia,A. (2008) Protein co-evolution, co-adaptation and interactions.
EMBO J., 27, 2648—2655.

Pellegrini,M. et al. ( 1999) Assigning protein functions by comparative genome analysis:
protein phylogenetic proﬁles. Proc. Natl Acad. Sci. USA, 96, 428541288.

Pinter,R. et al. (2008) Approximate labelled subtree homeomorphism. J. Discr. Algor,
6, 480—496.

Ramani,A. and Marcotte,E. (2003) Exploiting the co-evolution of interacting proteins
to discover interaction speciﬁcity. J. Mol. Biol, 327, 273—284.

Raynal,B. et al. (2010) Homeomorphic alignment of weighted trees. Pattern Recogn,
43, 2937—2949.

Tai,K.-C. (1979) The tree-to-tree correction problem. J. ACM, 26, 422—433.

Th0mps0n,J. et al. (1994) Clustal w: improving the sensitivity of progressive multiple
sequence alignments through sequence weighting, position speciﬁc gap penalties
and weight matrix choice. Nucleic Acids Res, 18, 467341680.

Tillier,E. and Charlebois,R. (2009) The human protein coevolution network. Genome
Res, 19, 1861—1871.

Tillier,E. et al. (2006) Codep: maximizing co-evolutionary interdependencies to
discover interacting proteins. Prat. Struc. F unc. Bioinform, 63, 822—831.

Vyugin,V. et al. (2002) Tree conciliation: reconstruction of species phylogeny by
phylogenetic gene trees. Mol. Biol, 36, 650—658.

Waddell,P. et al. (2007) Phylogenetic methodology for detecting protein interactions.
Mol. Biol. Evol, 24, 650—659.

Zhang,K. and Jiang,T. (1994) Some MAX-SNP—hard results concerning unordered
labeled trees. Inform. Process. Lett, 49, 249—254.

Zhang,K. et al. (1992) On the editing distance between unordered labeled trees. Inform.
Process. Lett, 42, 133—139.

Zhang,K. (1996) A constrained edit distance between unordered labeled trees.
Algorithmica, 15, 205—222.

 

1 208

112 /§JO's12urnofp101x0's01112u1101u101q//:d11q 111011 pep1201umoq

9IOZ ‘09 lsnﬁnv uo ::

