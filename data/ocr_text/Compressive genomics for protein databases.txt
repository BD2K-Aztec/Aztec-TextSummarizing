Vol. 29 lSMB/ECCB 2013, pages i283—i290
doi:10. 1093/bioinformatics/btt214

 

Compressive genomics for protein databases
Noah M. Danielsl, Andrew Gallantl, Jian Peng2’3, Lenore J. Cowenl, Michael Baym2’3’4 and

Bonnie Berger2’3’*

1Department of Computer Science, Tufts University, Medford, MA 02451, 2Department of Mathematics, 8Computer
Science and Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, MA 02139 and
4Department of Systems Biology, Harvard Medical School, Boston, MA 02115, USA

 

ABSTRACT

Motivation: The exponential growth of protein sequence databases
has increasingly made the fundamental question of searching for
homologs a computational bottleneck. The amount of unique data,
however, is not growing nearly as fast; we can exploit this fact to
greatly accelerate homology search. Acceleration of programs in the
popular PSI/DELTA-BLAST family of tools will not only speed-up hom-
ology search directly but also the huge collection of other current
programs that primarily interact with large protein databases via pre-
cisely these tools.

Results: We introduce a suite of homology search tools, powered by
compressively accelerated protein BLAST (CaBLASTP), which are sig-
nificantly faster than and comparably accurate with all known state-of-
the-art tools, including HHblits, DELTA-BLAST and PSI-BLAST.
Further, our tools are implemented in a manner that allows direct sub-
stitution into existing analysis pipelines. The key idea is that we intro-
duce a local similarity-based compression scheme that allows us to
operate directly on the compressed data. Importantly, CaBLASTP’s
runtime scales almost linearly in the amount of unique data, as
opposed to current BLASTP variants, which scale linearly in the size
of the full protein database being searched. Our compressive algo-
rithms will speed-up many tasks, such as protein structure prediction
and orthology mapping, which rely heavily on homology search.
Availability: CaBLASTP is available under the GNU Public License at
http://cablastp.csail.mit.edu/

Contact: bab@mit.edu

1 INTRODUCTION

Identiﬁcation of homologous sequences is of fundamental im-
portance in computational biology. Sequence search tools, such
as BLASTP and PSI-BLAST (Altschul et al., 1997), have played
important roles in various tasks arising in protein science, includ-
ing secondary and tertiary structure prediction (Rost et al., 2004;
Soding et al., 2005), functional annotation (Kosloff and
Kolodny, 2008; Loewenstein et al., 2009) and orthology mapping
(Singh et al., 2008; Tatusov et al., 2000). The runtimes of the
most popular methods [e. g. BLASTP, PSI-BLAST and DELTA-
BLAST (Boratyn et al., 2012)] scale nearly linearly in the size of
protein databases. With the exponential increase in protein se-
quence data, this is becoming a major bottleneck to computa-
tion. Thus, it is imperative to design algorithms that scale sub-
linearly in the size of the databases.

The recent exponential growth in genomic sequence data
(Kahn, 2011; Kircher and Kelso, 2010), which is outpacing
growth of computing power (Gross, 2011; Huttenhower and

 

*To whom correspondence should be addressed.

Hofmann, 2010; Kahn, 2011; Schatz et al., 2010), has spurred
an interest in compressive genomics (Loh et al., 2012) and the
need to compress sequence data for efﬁcient storage (Brandon
et al., 2009; Cameron et al., 2007; Chen et al., 2002). Protein
sequence data, although on a slower growth curve than genomic
data, nonetheless increase at an exponential rate (Fig. Al), dou-
bling roughly every 2 years, for now just keeping pace with
Moore’s law for computational power.

A key observation from compressive genomics is that much of
the new data are actually similar to existing data, which was used
to accelerate nucleotide sequence search without loss of accuracy
(Loh et al., 2012).

Despite its name, even NCBI’s non-redundant protein se-
quence database (NR) contains a great deal of redundancy; it
is non-redundant only at the level of entire sequences; highly
similar sequences are represented separately. Thus, even NR
lends itself to a compression scheme that takes advantage of
this redundancy. Although NR has already eliminated exact du-
plicates at the global sequence level, we take advantage of local
sequence similarity to achieve compression.

We introduce a compressive algorithm, CaBLASTP, along
with an implementation that allows direct computation on the
compressed data. CaBLASTP boosts the runtime performance
of any search tool in the protein BLAST (Altschul et al., 1997)
family, while maintaining accuracy. Speciﬁcally, we show that
compressive versions of BLASTP, PSI-BLAST (Altschul et al.,
1997) and DELTA-BLAST (Boratyn et al., 2012) scale nearly
linearly in the size of the unique data, as well as sub-linearly in
the size of the complete protein database.

Notably, any program that relies on protein BLAST can
take advantage of our compressive software with virtually no
effort. Thus, we expect CaBLASTP to be of great use to the
community.

2 METHODS

We introduce a framework for compressing protein sequences and per-
forming a variety of homology search techniques in compressed space.
We have designed this “CaBLASTP” framework primarily to be compat-
ible with the NCBI-BLAST family of software (Altschul et al., 1997).

The key observation underlying CaBLASTP is that when sequences
are sufﬁciently similar—yet not necessarily identical—tasks such as ap-
proximate search can initially operate on just one representative of the
similar set. The remainder of the set need only be analyzed if a represen-
tative sequence is found to be of interest.

The basic approach of CaBLASTP thus consists of two phases. First, a
pro-processing (or compression) phase identiﬁes similarities among se-
quences in a protein database. This phase is computationally intensive,
yet it need be done only once for a given database. After compression is

 

© The Author 2013. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non—Commercial License (http://creativecommons.org/licenses/
by—nc/3.0/), which permits non—commercial re—use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial

re—use, please contact journals.permissions@oup.com

1e /310's113u1no [p.IOJXO'SOllBIIHOJUTOTQ/ﬁdllq 11101; popeoIII/noq

9IOZ ‘091sn3nv uo ::

N.M.Daniels et al.

 

complete, CaBLASTP can then translate the decreased redundancy of the
database into a speed-up when performing search, which is the second
phase.

CaBLASTP compresses a protein sequence database to identify re-
gions of high similarity (Fig. 1a). This is done by ﬁrst scanning through
the database and categorizing sequences as either new or redundant.
Owing to both the amino acid alphabet size and the sheer database
size, to become tractable, this step required the development of new com-
putationally efﬁcient methods (detailed later in the text).

Novel sequences are stored in a ‘coarse’ database, whereas sequence
segments that align well to previously seen sequences are not. The coarse

Seed Table

(a) Original Database

    
     
   
    
 
  

STAQEPKSAEDSPSSNG
STAQEPKSAEDSVNARD
IGGVAYLREQFYESVSK
SRIQEPKSAEDSPSSNG

 

 

Gapped & Ungapped
Extension

 

 

Coarse Database Link index

STAQEPKSAEDSPSSNG
VNARD
IGGVAYLREQFYESVSK

  
 
   
    
    
 
 

Coarse Database

uer Se uence
O y q 1.Coarse BLASTP

STAQEPKSAEDSPSSNG

    

STAQEPKSAEDSVNARD VNARD
I GGVAYLREQFYE SVSK

 
 
 
   
 
   
 

3. Fine BLASTP Candidate Hits

  

STAQEPKSAEDSPSSNG
VNARD

Fine BLASTP Candidates
2. Sequence

Reconstruction Lmk Index

   
    
 

STAQEPKSAEDSPSSNG
STAQEPKSAEDSVNARD

 

 

 

  

Results

STAQEPKSAEDSVNARD

Fig. 1. (a) Novel sequences are stored in a ‘coarse’ database, whereas
sequence segments that align well to previously seen sequences are not.
Instead, records for these alignments are added to a link index. Our ap-
proach can be viewed as a hybrid between traditional data-compression
algorithms, which create a dictionary for exact sequences encountered in
the data and sequence alignment algorithms, such as BLAST. Links point
from entries in the seed table to entries in the coarse database. Blue text
indicates matching subsequences; red indicates differences. (b) The search
phase applies a two-stage approach. First, the query is searched against
the coarse database. To maintain accuracy, this ‘coarse search’ uses a
more permissive E-value threshold than the threshold speciﬁed for ﬁnal
results. For each hit from the coarse search, CaBLASTP then recon-
structs any additional candidate hits by following the links in the link
index. Final results are then obtained by a ‘ﬁne search’ against these
candidate sequences

database essentially represents only the unique data from the original
database. Instead, records for these alignments are added to a link
index. Our approach can be viewed as a hybrid between traditional
data-compression algorithms, which create a dictionary for exact se-
quences encountered in the data, and sequence alignment algorithms,
such as BLAST (Altschul et al., 1997).

The search phase applies a two-stage approach (Fig. lb). First, the
query is searched against the coarse database. To maintain accuracy, this
‘coarse search’ uses a more permissive E-value threshold than the thresh-
old speciﬁed for ﬁnal results. For each hit from the coarse search,
CaBLASTP then reconstructs any additional hit candidates by following
the links in the link index. Final results are then obtained by a ‘ﬁne
search’ against these candidate sequences.

We have implemented a compression tool, which converts a protein
sequence database to a CaBLASTP compressed database, as well as three
compressive search tools that operate on this database, implementing
compression-space versions of NCBI-BLAST, PSI-BLAST and the re-
cently released DELTA-BLAST (Boratyn et al., 2012). Our software is
written in the publicly available Go programming language (Griesemer,
2009; Kortschak, 2011).

2.1 Compression

The compressive phase takes a protein sequence database and produces a
compressed data structure amenable to the search step described in
Section 2.2. This pipeline is illustrated in Figure la. This is implemented
in the program cablastp-compress, which takes a standard FASTA ﬁle as
input.

Given an input sequence database, compression proceeds as follows:

(1) First, initialize a table of all possible k—mer ‘seeds’ of amino acids,
and a ‘coarse’ database of amino acid sequences, initially contain-
ing the ﬁrst sequence in the input database (empirically, the best
compression runtime performance occurs with k set to 4).

(2) For each k—mer of the ﬁrst sequence, then create a pointer from the
corresponding entry in the seed table to the position of that k-mer
in the ﬁrst sequence.

(3) For each sequence s in the input after the ﬁrst, slide a window of
size k + k’, where k’ may be zero (empirically, best performance is
achieved with k’ set to 2).

(4) Low-complexity regions (single-residue repeats) of length >10 are
skipped.

(5) Look up the ﬁrst k residues of this window in the seed table. For
every pointer corresponding to that k-mer in the seed table, follow
it to a subsequence in the coarse database. If a resulting subse-
quence s’ in the coarse database further matches the window by the
additional k’ residues, then attempt extension (see below). If no
subsequences from this window can be extended, move the
window by one residue. The separation of the window size into k
and k’ is simply an optimization to reduce the memory footprint of
compression; it allows, for example, an effective window size of 6
while only requiring a seed table with 204 rather than 206 entries.

(6) If a match was found via extension, move the k-mer window to the
ﬁrst k-mer in s after the match, and the extension process repeats
with this new seed.

Extension. Given a k + k’ match between the sequence s and subse-
quence s’ pointed to by the seed table, ﬁrst attempt ungapped extension:

(1) Greedily extend the match into an ungapped alignment as far as
possible.

(2) Within each window of 10 residues, if identical 4mers in s and s’
can be found, and at least two additional matching residues can be

 

i284

1e /310's113u1no [p.IOJXO'SOllBIIIJOJUIOIQ/ﬁdllq 11101; popeoIII/noq

9IOZ ‘091sn3nv uo ::

Compressive genomics for protein databases

 

found, then there is an ungapped match within that lOmer window
between s and s’ that exhibits at least 60% sequence identity.

(3) Continue ungapped matching using lOmer windows until no more
60% identity lOmers are found.

(4) The result of ungapped extension is that there is an alignment
between sequences s and s’ with no insertions or deletions, only
matches and substitutions, and at least 60% of the positions con-
tain exact matches.

When ungapped extension can no longer proceed, switch to gapped
extension. From the end of the ungapped alignment, align 25mer win-
dows of both s and s’ using the Needleman—Wunsch (Needleman and
Wunsch, 1970) algorithm with BLOSUM62 as a cost matrix. We use a
variant of Needleman—Wunsch, implementing constrained dynamic pro-
gramming, prohibiting more than six gaps in the alignment, reducing the
search space by a factor of ~4. Global alignment is chosen because we
wish to attempt to align the entire 25mer from each sequence. After
gapped extension on a window length of 25, attempt ungapped extension
again.

When neither gapped nor ungapped extension can continue, terminate
extension. Realign the resulting extension of s and s’, again using
Needleman—Wunsch. If the resulting alignment has <70% sequence iden-
tity or is <40 residues, discard it, instead attempt extension on the next
link in the seed table for the original k-mer; if there are no more links for
that k—mer, then consider the next k—mer. If, however, the resulting align-
ment has at least 70% sequence identity and is at least 40 residues long,
then create a link from the entry for s’ in the coarse database to the
subsequence of s beginning with the original k-mer and corresponding
to the extended region. If there are ‘dangling’ ends to s <30 residues that
did not satisfy the extension criteria, append them to the match. Longer
‘dangling’ ends that did not match any subsequences reachable from the
seed table are added into the coarse database themselves, with links from
the relevant seeds in the seed table to their constituent k—mers. The re-
quirement to deal with protein sequences being discrete represents a dif-
ference from Loh et al. (2012).

Any sequence or subsequence in the input that cannot be matched to
earlier sequences in the coarse database will itself become an entry in the
coarse database, with pointers from the k-mer seed table linking to it, and
similar sequences seen later in the input may be matched to it.

In addition, a difference script is associated with this link. The differ-
ence script is simply a representation of the insertions, deletions and
substitutions resulting from the overall Needleman—Wunsch alignment.
Applying the difference script to a representative sequence in the coarse
database (s’ above) will return the sequence s; it is effectively decom-
pressed. Similarly, applying the difference script to s will return its rep-
resentative s’.

After all sequences have been compressed, the sequences in the coarse
database are written out in FASTA format; the resulting coarse FASTA
ﬁle, which is smaller than the original input ﬁle, is used by all search
implementations described later in the text. In addition, the set of links
between coarse sequences and original sequence identiﬁers and their dif-
ference scripts is written to disk in a binary format. An index ﬁle is also
produced, which maps the sequence identiﬁers from the coarse database
to entries in the compressed database. These formats are documented in
the Go source code for CaBLASTP. It is worth noting that the compres-
sion format is lossless and completely invertible; it is possible to exactly
reconstruct the original FASTA source from the compressed database.

When compressing a large amino acid data set such as NCBI’s ‘NR’,
memory usage can grow large. As a memory and runtime performance
optimization, the seed table can be reset when it reaches a user-speciﬁed
size, 8 GB by default. For our experiments, we used a maximum seed
table size of 20 GB. When no limit was imposed, the seed table could
grow to >40 GB on NR, but we saw negligible difference in compression
ratio between these two limits.

On the compressed database described here, we have implemented
three search techniques, BLASTP, PSI-BLAST and DELTA-BLAST.
All three follow the same basic two-step technique (Fig. lb): ﬁrst, they
search the compressed database with a relaxed threshold to ﬁnd candi-
date matches, and then the closely related sequences to the candidate hits
are more closely examined. The fundamental speed-up introduced by this
two-step approach is that the initial step rules out the vast majority of the
original database without ever having to examine it.

2.2 Search

2.2.] Compressive BLASTP Compressive accelerated BLASTP, or
cablastp-search, requires a compressed database produced by our com-
pression method as described earlier in the text. Given a query sequence
and a compressed database, this search method calls the BLASTP pro-
gram to search the coarse FASTA ﬁle, which is typically much smaller
than the original FASTA ﬁle. This step is called coarse search, as sug-
gested by Loh et al. (2012). Coarse search uses a relaxed E-value thresh-
old compared with what would be desired if the entire original database
was searched using standard BLASTP. The idea behind coarse search is
to identify possible hits, which may be rejected by the later fine search.
Because the coarse FASTA ﬁle is a subset of the original, uncompressed
FASTA ﬁle, potential hits may be subsequences that are shorter than or
slightly different from the original sequences they represent. Thus, a more
permissive E-value must be used. Command-line arguments to be passed
to BLASTP itself may be speciﬁed by the user. The results of the coarse
search are sequences from the coarse FASTA ﬁle; thus, they are actually
sequences or subsequences from the original FASTA ﬁle. Based on the
compressed database’s search index, each of these sequences is then re-
constructed into all corresponding sequences from the original database,
by following the links to original sequence matches, and applying their
difference scripts. Note that the coarse FASTA ﬁle need not ever be
decompressed in its entirety, although it is possible to do so. The resulting
set of sequences, larger than the resulting set from the coarse search, is
then provided to BLASTP as the subject for a second query, which again
uses the query sequence provided to cablastp-search. This step is called
fine search, and it produces a set of ﬁnal results, based on an E-value
threshold speciﬁed by the user (or the BLASTP default). These results are
provided in an identical format to BLASTP. This implementation of
cablastp-search relies on the BLAST+ implementation (developed and
tested against BLAST+ 2.2.6 and 2.2.7).

2.2.2 Compressive PSI-BLAST Compressively accelerated PSI-
BLAST, or cablastp-psisearch, operates much like compressively acceler-
ated BLASTP. PSI-BLAST builds a position-speciﬁc scoring matrix, or
PSSM, iteratively, by running BLAST searches for a query against a
database. Instead of just using the BLOSUM-62 matrix to compute align-
ment scores, PSI-BLAST computes substitution scores column-by-
column, based on an initial alignment and subsequent reﬁnements.
cablastp-psisearch takes advantage of the PSI-BLAST program’s ability
to save a checkpoint of its PSSM to a ﬁle. Given a user-speciﬁed number
of iterations, the program performs both a coarse and a ﬁne search for
each iteration. Every iteration, except the ﬁrst, relies on a PSSM ﬁle
output by the previous iteration, whereas every iteration, except the
ﬁnal, writes a PSSM ﬁle for the next iteration to use. Each iteration
comprises a coarse and a ﬁne search identical to cablastp-search, but
using the PSI-BLAST executable.

2.2.3 Compressive DELTA-BLAS T Domain-enhanced look up
time accelerated BLAST, or DELTA-BLAST (Boratyn et al., 2012),
uses a library of pre-computed PSSMs based on NCBI’s Conserved
Domain Database. The DELTA-BLAST executable is included with
BLAST+ 2.2.6 and later versions. Compressively accelerated DELTA-
BLAST, or cablastp-deltasearch, operates similarly to compressiver
accelerated BLASTP, performing a single iteration of search comprising

 

i285

1e /310's113u1no [p.IOJXO'SOllBIIIJOJUIOIQ/ﬁdllq 11101; popeoIII/noq

9IOZ ‘091sn3nv uo ::

N.M.Daniels et al.

 

a coarse and a ﬁne search step. We did not implement an iterative version
of this algorithm, as Boratyn et al. (2012) showed decreased accuracy
with iteration.

2.3 Accuracy validation

To verify that compressive acceleration does not signiﬁcantly harm the
accuracy of BLASTP, PSI-BLAST and DELTA-BLAST, we performed
100 random searches against the NR database, for each of these three
tools. For each tool, we treated the results from the standard version (e. g.
BLASTP) as a gold standard, and computed the true positive rate and
false positive rate for compressive versions of the same search (e.g.
cablastp-search) with respect to this gold standard. We performed this
search with an E-value threshold of 10‘3, for both the coarse and ﬁne
threshold for the compressive versions of each search, and for
CaBLASTP, PSI-BLAST and DELTA-BLAST. Because of the design
of the algorithm, false positives with respect to the non-compressiver
accelerated tools are not possible.

We were also interested in homology detection performance of our
compressive implementations of PSI-BLAST and DELTA-BLAST with
respect to HHblits (McDonnell et al., 2006). We identiﬁed all 1123 se-
quences from the ASTRAL subset of release 1.75A of the Structural
Classiﬁcations of Proteins (SCOP) (Murzin et al., 1995) database that
were not present in HHblits’ ‘NR20’ database or the August 2010
NCBI NR database, but whose SCOP families contained other homolo-
gous sequences that were present in these databases. We chose the
August 2010 NCBI NR database to more fairly compare with the
August 2011 HHblits NR20, which is the most recent available. We
then performed searches using one iteration of HHblits, one iteration
of cablastp-deltasearch and two iterations of cablastp-psisearch against
these databases. We chose these numbers of iterations because a single
iteration of PSI-BLAST is effectively just BLASTP, whereas Boratyn
et al. (2012) showed decreased accuracy with more than one iteration
of DELTA-BLAST. Multiple iterations of HHblits would have resulted
in slower runtime performance. We considered results from the same
SCOP superfamily (and by extension, the same SCOP family) as the
query to be true positives, and results from different SCOP folds to be
false positives. We removed results from the same SCOP fold but differ-
ent superfamilies, as it is not consistent across the SCOP fold classiﬁca-
tions whether these sequences are homologs. We also removed results
that were not identiﬁable in SCOP. We plotted ROC curves based on
these homology predictions. We also report the mean running times of
these searches.

3 RESULTS
3.1 Scalability 0n simulated data

We ﬁrst compared the performance of our compressive
accelerated versions of BLAST with their original implementa-
tions. We constructed a simulated dataset to mimic the expected
growth of a protein sequence database into the future, to
demonstrate CaBLASTP’s ability to scale to large datasets. We
began with all known and putative proteins in the Saccharomyces
Genome Database (Cherry et al., 2012), which contains the
proteomes of 21 strains of yeast. To simulate clades of recently
diverged species, we used a tool for simulating protein mutation
(Daniels et al., 2012; Kumar and Cowen, 2009, 2010). For each
original sequence in the database, we added 5, 10, 20, 30 or 40
similar sequences by substituting residues with a mutation rate of
20%, based on the BLOSUM62 substitution matrix. The original
dataset contained 6717 sequences; with 40 mutated copies of
each sequence, the database contained 275 397 sequences. In
this way, we essentially ‘simulate’ an evolutionary process to

build a number of ‘putative’ proteomes from Saccharomyces
proteomes. Performance of sequence search on these augmented
databases should be comparable with the performance on future
databases where closely related species have now been
sequenced, producing increasing numbers of orthologous se-
quences. We benchmarked sequence search on these augmented
databases.

Figure 2a demonstrates the superior runtime of CaBLASTP
over BLASTP for large datasets. The results are averaged over
all sequences from the native Saccharomyces proteome. The
runtime of BLASTP increases almost linearly in the number of
‘simulated’ proteomes, or the size of the full database. In
contrast, CaBLASTP scales sub-linearly with database size,
even when there are 40 times as many proteomes. Notably,
CaBLASTP achieves roughly constant runtime regardless of
database size. These results show that our compressive scheme
is able to exploit data redundancy, thereby avoiding redundant
searches. Finally, we have performed similar comparisons on
datasets with different mutation rates (e.g. 5, 10 and 30%),
and the results are similar. This benchmark was performed on
a quad-core Intel Core i7 with 16 GB random access memory
and a solid-state disk.

3.2 Homology search on real data

3.2.1 Speed We evaluated the homology-search performance of
both the original and our compressive BLAST versions on the
widely used NR database. We randomly chose 100 sequences
from the December 2012 NR database. Five runs for each
query sequence were performed on three early versions of NR
built on June 2010, July 2012 and December 2012, with a coarse
E-value of 10‘5 and a ﬁne E-value of 10‘10 (we selected these
three NR datasets because we do not have access to any other
versions). The average runtime for each method is shown in
Figure 2b. This benchmark was run on a system with dual six-
core AMD Opteron 2427 processors and 32 GB random access
memory, equipped with a RAID-10 disk array.

Although on each NR dataset, BLASTP takes 120, 200 and
240s, respectively, CaBLASTP takes only 50, 70 and 75s, re-
spectively. Given that the NR datasets each contain 11.6, 19.1
and 22 million sequences, BLASTP scales almost exactly linearly
in database size, whereas the runtime of CaBLASTP grows much
more slowly. CaBLASTP is faster than BLASTP by factors of
2.4, 2.7 and 3.1 on these NR datasets, respectively. These results
ﬁt with the observation that the uncompressed NR databases are
6.1, 11 and 13 GB in size, respectively, whereas their compressed
counterparts are 1.4, 2.4 and 2.7 GB in size. Considering that the
NR databases already have 100% global sequence-identity re-
dundancy removed, CaBLASTP takes advantage of the local
similarity within the databases to speed-up homology search.
It is worth noting that on the NR databases, the ‘coarse’
search step of CaBLASTP dominates the running time; the
‘ﬁne’ step requires <1 s in all cases.

Similar to the comparison between BLASTP and CaBLASTP,
the compressive accelerated versions of both PSI-BLAST and
DELTA-BLAST are much faster than their original versions.
We performed two iterations of PSI-BLAST and one iteration
of DELTA-BLAST, as suggested in the latter’s original article.
The acceleration ratio increases as the size of NR grows (Fig. 2b).

 

i286

1e /310's113u1no [p.IOJXO'SOllBIIIJOJUIOIQ/ﬁdllq 11101; popeoIII/noq

9IOZ ‘091sn3nv uo ::

Compressive genomics for protein databases

 

 

 

 

 

 

(a) — Compressive-accelerated BLASTP
- - -- BLASTP
: I
5 —_ ’I
- I
I I
_ I
- I
I ’I
4 —' I
'3 E I
g I I,
O : I
g 3 _- 1’
O I I
a 2 x
H : II
a _
8 2‘: 1’
8 - I
m 3 ,’
3——7*/
: , ’
1€,I’
0 - I I |
5 10 20 30 40

Number of copies of SGD

20% mutation rate

 

 

60 80 100
| |

Average Search Time (seconds)
40

20
|

 

 

 

 

 

 

 

 

- Compressed
DELTA-BLAST

Compressed
PSI-BLAST HHblits

Search Method

--0- BLASTP
—0— Compressive-accelerated BLASTP
PSI-BLAST (2 iters)
Compressive-accelerated PSI-BLAS T (2 iters)
(b) - i- DELTA-BLAST
—-I— Compressive-accelerated DELTA-BLAST

 

 

 

 

 

 

 

 

 

 

 

500 _
400 
A _
m
'6 _
5 :
8 300 —_
65 :
o
a .ng
'5' 5 I
'5 200 ’ 5 g = 5 ’
i-I , g 5 ’
N -55’
Q s , 5 5 ’
CID ‘ ‘ ‘ ‘ S
100 —_
0 - I
H H
g E. c?
N O
N o
S e B
o N I-I
N
Date of NR database
( ) o
m. _
l0
N _
6.‘
‘— 0
ll  —
£2
5
I
E,
0. L0
: ‘_' —
'0
CD
(D
D.
U)
S
E O- - -I-
a; ’ -'-
<
LO
0. _
O. _
° Compressed Compressed
DELTA-BLAST PSI-BLAST HHblits

Search Method

Fig. 2. (a) Runtime of CaBLASTP versus BLASTP as datasets grow because of simulated mutation. Below 20% mutation rate, CaBLASTP run time is
virtually constant. (b) Runtime of cablastp-search versus BLASTP on three historical versions of NCBI’s ‘NR’ database. Times are the mean of ﬁve runs
each for 100 randomly chosen queries. (c) Runtime of cablastp-deltasearch versus cablastp-psisearch (two iterations) on NR from August 2010 and
HHblits on NR20 from August 2011. Times are the mean of ﬁve runs each for 100 queries from NR from December 2012. (d) Relative speed-up of
cablastp-deltasearch and cablastp-psisearch (two iterations) versus HHblits (one iteration) on NR from August 2010 and HHblits on NR20 from

August 201 1

3.2.2 Accuracy To verify that compressive acceleration does
not decrease the accuracy of BLASTP, PSI-BLAST and
DELTA-BLAST, we also compared the differences between
the sequence hits from the above random query searches with
the NR databases for each tool. Speciﬁcally, we compared the
overlap between the sequence hits found by the compression-
accelerated versions and those identiﬁed by the original versions.

It is worth noting that because of the boosting compressive
scheme we have designed, our algorithms will not ﬁnd any se-
quences that do not appear in the hits of their original counter-
parts. We then calculated the overlap between the alignments
generated by our compression-accelerated tools and their ori-
ginal versions. Table 1 depicts that the overlap of sequence hits
is >99% and that of alignments is 100%. In other words, when a

 

i287

1e /310's113u1no [p.IOJXO'SOIlBIHJOJUIOICI/ﬁdllq 11101; popeommoq

9IOZ ‘091sn3nv uo ::

N.M.Daniels et al.

 

Table 1. Accuracy of compressive tools

 

 

Program TPR FPR Alignment
(%) (%) accuracy (%)
Compressive BLASTP 99.4 0 100
Compressive PSI-BLAST 99.3 0 100
Compressive DELTA-BLAST 99.4 0 100

 

Note: TPR is the fraction of hits from standard versions of each tool that were also
found by the compressive versions. FPR is the fraction of hits from the compressive
versions that were not found by the standard versions. Note: because of the algo-
rithm design, false positives with respect to the standard uncompressed tools are not
possible.

 

0.0030
l

Coarse E-Value
I 1e-05
El 0.001
El 0.1

 

 

 

CaBLASTP miss rate
0.0015 0.0020 0.0025
I I I

0.0010
l

0.0005
I

 

 

 

 

 

_ LJJLJlLL__

5 6 7 8 9 10 11 12 13 14 15
Negative of Exponent of BLAST Hit E-value

0.0000
I
I

Fig. 3. Analysis of missed BLASTP hits. One thousand queries were run
on the yeast genome database at three different coarse E—values and a ﬁne
E-value of 1E-5. The majority of misses are at the margin; in total, these
represent <0.5% of the hits

hit is found, the alignment perfectly matches the standard
BLASTP alignment. An analysis of the differences in the
search results suggests that short query sequences (<40 residues)
may in some cases return no hits in the coarse search. Changing
the minimum match length in the compression phase would
likely address this issue, yet likely at the expense of a signiﬁcant
fraction of the runtime performance gains.

To better gauge the impact of coarse search E-value on accur-
acy, we performed 1000 random queries against the yeast data-
base, with a ﬁne E-value of 10‘5 and three different coarse
E-values: 10”, 10‘3 and 10‘5. We compared these results with
standard BLASTP queries with an E-value of 10‘5. Figure 3
illustrates the results of this analysis; CaBLASTP is robust to
choice of coarse E-value, as long as the coarse E—value is more
permissive than the ﬁne E-value.

3.2.3 Comparison with HHblits Finally, we compared the per-
formance of homology detection of our compressively acceler-
ated implementations of PSI-BLAST and DELTA-BLAST with
a recently introduced proﬁle-based search tool, HHblits
(Remmert et al., 2012). By partitioning sequences into clusters
based on global sequence similarity, HHblits pre—computes dis-
cretized hidden Markov models (HMMs) on each cluster and

 

0.6 0.8 1.0
l

True positive rate
0.4
I

 

 

g _ I; — CaPSI-BLAST AUC: 0.69
{I PSI-BLAST AUC: 0.69
" — CaDELTA—BLAST AUC: 0.76

- - - DELTA-BLAST AUC: 0.76
- - HHblits AUC: 0.75

I I I I I I
0.0 0.2 0.4 0.6 0.8 1.0

False positive rate

 

 

 

0.0
I

 

Fig. 4. Accuracy: ROC curves for homology detection performance of
cablastp-psisearch versus cablastp-deltasearch and HHblits, as well as
standard PSI-BLAST and DELTA-BLAST

only searches a query against those HMMs. In contrast, our
compression-accelerated algorithms take the local similarity
into account to speed-up sequence search. For comparison, we
identiﬁed all 1123 sequences from the ASTRAL subset of release
1.75A of the SCOP (Murzin et al., 1995) database that are not
present in HHblits’ ‘NR20’ database or the August 2010 NCBI
NR database, and which were in SCOP families that did contain
other non-identical sequences in those older NR databases. We
chose the August 2010 NCBI NR database to more fairly com-
pare with the August 2011 HHblits NR20, which is the most
recent available. We then performed searches using one iteration
of HHblits, one iteration of cablastp-deltasearch and two iter-
ations of cablastp-psisearch. The numbers of iterations were
chosen to ensure the performance of these tools is similar accord-
ing to previous reports (Boratyn et al., 2012; Remmert et al.,
2012). We considered top sequence hits from the same SCOP
superfamily (and by extension, the same SCOP family) as the
query to be true positives, and hits from different SCOP folds
to be false positives. We removed sequence hits from the same
SCOP fold but different superfamilies, as it is questionable
whether those sequences are homologous. We also removed re-
sults that were not identiﬁable in SCOP. We reported the mean
running times of these searches and plotted ROC curves based
on the homology predictions. Figure 2c illustrates these results.
Finally, we reported the speed-up of cablastp-deltasearch and
cablastp-psisearch with respect to HHblits. Speed-up is calcu-
lated as the mean, over all queries, of the mean HHblits time
for a given query divided by the mean time for the speciﬁed
search for that query. Error bars represent a 95% conﬁdence
interval based on the distribution of search times for each
query sequence. Figure 2d illustrates these results.

HHblits takes an average of 102s for one iteration. cablastp-
deltasearch takes an average of 51 s for one iteration. cablastp-
psisearch needs 52 s for one iteration and 106 s for two iterations.
Compression-accelerated DELTA-BLAST is twice as fast as
HHblits on this test; CaBLASTP-PSI-search is slightly slower
than HHblits. The result is notable considering that the clustered
NR20 by HHblits is much smaller than the NR database we
used. Moreover, as shown in Figure 4, compressive DELTA-

 

i288

112 /310'sreu1no [pJOJXO'SOIlBIIIJOJUIOIQ/ﬁdllq 11101; popeommoq

9IOZ ‘091sn3nv uo ::

Compressive genomics for protein databases

 

BLAST achieves an area under the ROC curve of 0.76, com-
pared with 0.75 for HHblits and 0.69 for compressive PSI-
BLAST. In a R0C5 analysis (Fig. A2), where only the area
under the curve up to the ﬁfth false positive is considered, and
the area is normalized, compressive DELTA-BLAST achieves a
R0C5 score of 0.82, compared with 0.71 for HHblits and 0.63 for
compressive PSI-BLAST.

We also ran the original versions of DELTA-BLAST and PSI-
BLAST on the same set of query sequences. Their results are
identical to our compression-accelerated versions, but their run-
times are roughly three times slower.

4 DISCUSSION

We have introduced a compression-accelerated search algorithm
that boosts the speed while maintaining accuracy of tools in the
protein BLAST family. Our approach scales sub-linearly with
the size of the database being searched, and linearly with the
size of the unique data. We expect that as the NR database con-
tinues to grow exponentially, the beneﬁts of this compressive
approach will become more pronounced.

In contrast to genomic sequence compression (Loh et al.,
2012), which appears on its surface to be similar, subtle differ-
ences make protein sequence compression a different problem.
The primary difference is that proteins have a larger alphabet,
and thus, random sequences will have less similarity. This results
in different parameters and compression ratios, but it also
increases the computational complexity of compression, as the
number of k—mers is exponential in the alphabet size. Another
difference is that protein sequences are discrete; therefore,
our compression algorithm must handle sequence beginnings
and ends.

We have demonstrated that our compressive approach pro-
vides signiﬁcant gains as the redundancy of the data increases,
but we also see future challenges. As the NCBI’s NR database
continues to grow in the coming years, the size of each cluster of
similar subsequences will also grow. We expect that for compres-
sion to remain tractable, further algorithmic and software-engin-
eering improvements, for example, a hierarchical compression
scheme, will be required.

Many sophisticated homology search and protein structure
prediction tools require BLAST searches of one type or another
to incorporate sequence proﬁles or structural information to im-
prove performance (Moult et al., 2011). For example, when we
introduced the BetaWrapPro method (McDonnell et al., 2006),
which requires a BLASTP search at query time, NCBI’s NR
database contained <4.5 million sequences; today it contains
>22 million sequences; thus, search requires approximately ﬁve
times the running time.

Although the original motivation for developing our compres-
sive approach was the growing running time of BLASTP
searches on NR, the results described in Figure 2a suggest that
our approach may also be useful for orthology mapping across
organisms, performing an all-against—all search between a query
proteome and a set of well-studied proteomes (Chen et al., 2007;
Hachiya et al., 2009; Moreno-Hagelsieb,G. and Latimer, 2008),
which takes an inordinate amount of time.

Our tools can be readily incorporated into these applications
to accelerate their search, pre—processing or library construction.

Our software can be easily interfaced with any programs that
use protein BLAST search tools. Another important advantage
of our methods is that the compressed database can be incremen-
tally maintained to keep current with new proteomic sequence
data.

ACKNOWLEDGEMENTS

The authors thank Norman Ramsey and Po-Ru Loh for helpful
discussions about the compression approach.

Funding: This work was partially supported by a grant from the
Simons Foundation and the NIH (to BB.) N.D., AG. and LC.
were funded in part by NIH grant (R01GM080330). M.B. was
funded in part by an NSF MSPRF grant.

Conflict of Interest: none declared.

REFERENCES

Altschul,S.F. et al. (1997) Lipman. Gapped BLAST and PSI-BLAST: a new
generation of protein database search programs. Nucleic Acids Res., 25,
3389—3402.

Boratyn,G.M. et al. (2012) Domain enhanced lookup time accelerated BLAST.
Biol. Direct, 7, 12.

Brandon,M.C. et al. (2009) Data structures and compression algorithms for
genomic sequence data. Bioinformatics, 25, 1731—1738.

Cameron,M. et al. (2007) Clustered sequence representation for fast homology
search. J. Comput. Biol., 14, 594—614.

Chen,F. et al. (2007) Assessing performance of orthology detection strategies
applied to eukaryotic genomes. PloS One, 2, e383.

Chen,X. et al. (2002) DNACompress: fast and effective DNA sequence compres-
sion. Bioinformatics, 18, 1696—1698.

Cherry,J.M. et al. (2012) Wong. Saccharomyces Genome Database: the genomics
resource of budding yeast. Nucleic Acids Res., 40, D700—D705.

Daniels,N.M. et al. (2012) Cowen. SMURFLite: combining simpliﬁed
Markov random ﬁelds with simulated evolution improves remote homology
detection for beta-structural proteins into the twilight zone. Bioinformatics,
28, 1216—1222.

Griesemer,R. et al. (2009) The G0 Programming Language. http://golang.org/
(3 June 2013, date last accessed).

Gross,M. (2011) Riding the wave of biological data. Curr. Biol, 21, R204—R206.

Hachiya,T. et al. (2009) Accurate identiﬁcation of orthologous segments among
multiple genomes. Bioinformatics, 25, 853—860.

Huttenhower,C. and Hofmann,O. (2010) A quick guide to large-scale genomic data
mining. PLoS Comput. Biol., 6, 61000779.

Kahn,S.D. (2011) On the future of genomic data. Science, 331, 728—729.

Kircher,M and Kelso,J. (2010) High-throughput DNA sequencing—concepts and
limitations. BioEssays, 32, 524—536.

Kortschak,R.D. (2011) BioGo. http://github.org/kortschak/biogo (3 June 2013,
date last accessed).

Kosloff,M. and Kolodny,R. (2008) Sequence-similar, structure-dissimilar protein
pairs in the PDB. Proteins, 71, 891—902.

Kumar,A. and Cowen,L. (2009) Augmented training of hidden Markov models
to recognize remote homologs via simulated evolution. Bioinformatics, 25,
1602—1608.

Kumar,A. and Cowen,L. (2010) Recognition of beta-structural motifs using
hidden Markov models trained with simulated evolution. Bioinformatics, 26,
i287—i293.

Loewenstein,Y. et al. (2009) Protein function annotation by homology-based infer-
ence. Genome Biol., 10, 207.

Loh,P.R. et al. (2012) Compressive genomics. Nat. Biotechnol, 30, 627—630.

McDonne11,A. et al. (2006) Fold recognition and accurate sequence-structure
alignment of sequences directing -sheet proteins. Proteins, 63, 976—985.

Moreno-Hagelsieb,G. and Latimer,K. (2008) Choosing BLAST options
for better detection of orthologs as reciprocal best hits. Bioinformatics, 24,
319—324.

 

1e /810'sreu1no [pJOJXO'SOIlBIIIJOJUIOIQ/ﬁdllq 11101; popeommoq

9IOZ ‘091sn8nv uo ::

N.M.Daniels et al.

 

Moult,J. et al. (2011) Critical assessment of methods of protein structure prediction
(CASP%round IX. Proteins, 79 (Suppl. 10), 74—90.

Murzin,A. et al. (1995) SCOP: a structural classiﬁcation of proteins data-
base for the investigation of sequences and structures. J. Mol Biol, 247,
536—540.

Needleman,S.B. and Wunsch,C.D. (1970) A general method applicable to the
search for similarities in the amino acid sequence of two proteins. J. Mol
Biol, 48, 443—453.

Remmert,M. et al. (2012) HHblits: lightning-fast iterative protein sequence search-
ing by HMM-HMM alignment. Nat. Methods, 9, 173—175.

APPENDIX

NCBI NR Sequences

 

2e+07
l

Ie+07

Protein Sequences
5e+06
I

29+06
|

/'
/

I | I | | I | I | | I
2002 2004 2006 2008 2010 2012

Year

 

 

1e+06

 

Fig. A1. Number of sequences in NCBI’s ‘NR’ non-redundant protein
sequence database from 2002 to 2012. The y-axis is logarithmic; doubling
time is ~2 years

Rost,B. et al. (2004) The PredictProtein server. Nucleic Acids Res., 32, W321—W326.

Schatz,M.C. et al. (2010) Cloud computing and the DNA data race. Nat.
Biotechnol, 28, 691—693.

Singh,R. et al. (2008) Global alignment of multiple protein interaction networks
with application to functional orthology detection. Proc. Natl. Acad. Sci. USA,
105, 12763—12768.

SédingJ. et al. (2005) The HHpred interactive server for protein homology
detection and structure prediction. Nucleic Acids Res., 33, W244—W248.

Tatusov,R.L. et al. (2000) The COG database: a tool for genome-scale analysis of
protein functions and evolution. Nucleic Acids Research, 28, 33—36.

 

 

 

 

 

 

 

ca _
w _ I _ _ _
O
I I
I I " " " '-
I I
9 <0. _ I I
E o "
s : '
9% _ _ _ _ _ _ _I_ J
o I
Q. I
3 sr. _ I
i: O I
I
I
I
g _ ' — CaPSI-BLAST AUC:O.63
PSI-BLAST AUC: 0.63
— CaDELTA—BLAST AUC: 0.82
- - - DELTA-BLAST AUC: 0.82
g _ .... -- - - HHblits AUC: 0.71

 

 

I I | I | I
0.0 0.2 0.4 0.6 0.8 1.0

False positive rate

Fig. A2. R0C5 analysis of homology detection performance

 

i290

1e /810'sreu1no [prejxo'soriem10jurorq//:d11q 11101; popeommoq

9IOZ ‘09 lsnﬁnv uo ::

