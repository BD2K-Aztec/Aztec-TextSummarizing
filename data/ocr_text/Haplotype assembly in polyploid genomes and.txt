Vol. 29 ISMB/ECCB 2013, pages i352—i360
doi: 1 0. 1093/bioinformatics/btt2 13

 

Haplotype assembly in polyploid genomes and identical by

descent shared tracts
Derek Aguiar and Sorin Istrail"

Department of Computer Science and Center for Computational Molecular Biology, Brown University, Providence,

RI 02912, USA

 

ABSTRACT

Motivation: Genome-wide haplotype reconstruction from sequence
data, or haplotype assembly, is at the center of major challenges in
molecular biology and life sciences. For complex eukaryotic organ-
isms like humans, the genome is vast and the population samples are
growing so rapidly that algorithms processing high-throughput
sequencing data must scale favorably in terms of both accuracy and
computational efficiency. Furthermore, current models and methodol-
ogies for haplotype assembly (0 do not consider individuals sharing
haplotypes jointly, which reduces the size and accuracy of assembled
haplotypes, and (ii) are unable to model genomes having more than
two sets of homologous chromosomes (polyploidy). Polyploid organ-
isms are increasingly becoming the target of many research groups
interested in the genomics of disease, phylogenetics, botany and evo-
lution but there is an absence of theory and methods for polyploid
haplotype reconstruction.

Results: In this work, we present a number of results, extensions and
generalizations of compass graphs and our HapCompass framework.
We prove the theoretical complexity of two haplotype assembly opti-
mizations, thereby motivating the use of heuristics. Furthermore, we
present graph theory—based algorithms for the problem of haplotype
assembly using our previously developed HapCompass framework for
(D novel implementations of haplotype assembly optimizations (min-
imum error correction), (ii) assembly of a pair of individuals sharing a
haplotype tract identical by descent and (iii) assembly of polyploid
genomes. We evaluate our methods on 1000 Genomes Project,
Paciﬁc Biosciences and simulated sequence data.

Availability and Implementation: HapCompass is available for down-
load at http://www.brown.edu/Research/lstraiLLabl.

Contact: Sorin_lstrail@brown.edu

Supplementary information: Supplementary data are available at
Bioinformatics online.

1 INTRODUCTION

The genome sequence of a human individual can be modeled as
23 pairs of sequences of four nucleotide bases, A, C, G and T,
representing the 22 pairs of autosomes and the sex chromosomes.
However, ~99.5% of any two individuals’ genome sequences is
shared within a population. The ~0.5% of the nucleotide bases
varying within a population range from single-nucleotide poly-
morphisms (SNPs) to more complex structural changes, for ex-
ample, deletions or insertions of genomic material. A sequence of
genomic variants, typically SNPs, with the non-varying DNA
removed is referred to as a haplotype.

 

*To whom correspondence should be addressed.

Standard genome sequencing workﬂows produce contiguous
DNA segments of an unknown chromosomal origin. De novo
assemblies for genomes with two sets of chromosomes (diploid)
or more (polyploid) produce consensus sequences in which the
relative haplotype phase between variants is undetermined. The
set of sequencing reads can be mapped to the phase-ambiguous
reference genome and the diploid chromosome origin can be
determined but, without knowledge of the haplotype sequences,
reads cannot be mapped to the particular haploid chromosome
sequence. As a result, reference-based genome assembly algo-
rithms also produce unphased assemblies. However, sequence
reads are derived from a single haploid fragment and thus pro-
vide valuable phase information when they contain two or more
variants. The haplotype assembly problem aims to compute the
haplotype sequences for each chromosome given a set of aligned
sequence reads to the genome and variant information. The
haplotype phase of variants is inferred from assembling overlap-
ping sequence reads [Browning and Browning (2011);
Halldérsson et al. (2003); Schwartz (2010)].

The input to the haplotype assembly problem is a matrix
M whose rows correspond to aligned read fragments and col-
umns correspond to SNPs (Fig. l). The quality of Ms construc-
tion depends on the parameters of the sequencing workﬂow and
the accuracy of the read alignment algorithms. Misaligned read
fragments can introduce erroneous base calls or sampling biases
so the careful alignment of sequence reads is necessary for high-
quality haplotype assemblies. Without read alignment or sequen-
cing errors, the haplotype assembly problem can be solved in
time linear in the size of M by partitioning the fragments in
two sets whereby no fragments internal to a set share an SNP
and differ in the allele called. To address erroneous base calls or
misplaced alignments, three primary haplotype assembly opti-
mizations have been developed: minimum error correction
(MEC), minimum SNP removal (MSR) and minimum fragment
removal (MFR). The goal is to convert M into a state such that
the fragments (rows of M) can be distributed into two sets cor-
responding to the two haplotypes. All fragments in a set must
agree on the allele at each SNP site and this is accomplished
using the minimum number of SNP allele ﬂips (0 to l or vice
versa - MEC), SNP (columns of M) removals (MSR) or frag-
ment (rows of M) removals (MFR).

Lancia et al. (2001) and Rizzi et al. (2002) provide a theoretical
foundation for the MFR and MSR optimizations and describe
the fundamental SNP and fragment conﬂict graph structures.
The ﬁrst widely available haplotype assembly software package
was presented in Panconesi and Sozio (2004) in which the au-
thors describe the Fast Hare algorithm, which optimizes the ‘Min
Element Removal’ problem. Bansal et al. (2008) describe a
Markov chain model with Metropolis updating rules to sample

 

© The Author 2013. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/
by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial

re-use, please contact journals.permissions@oup.com

112 [3.10811211an[p.IOJXO'SODBIIIJOJIIIOIQ/[Z(11111 IIIOJJ papeolumoq

910K ‘09 isnﬁnV uo ::

Haplotype assembly in polyploid genomes

 

SNP content is ﬁqI—e—
extracted from

aligned sequence m
reads to construct fig-\f—

fragments.
Fragments are encoded as row vectors of
SNP alleles in M. SNP alleles may be 0, 1, or
‘—’ representing the major allele, minor allele,
or missing data respectively.

SI 52 s3 S4

 

 

SNP-fragment f1 0 0 — —
matrixM f2

 

 

 

 

 

 

- l — 1

 

Fig. 1. Construction of the input to the haplotype assembly problem

a set of likely haplotypes under the MEC optimization. In a
follow-up, the authors present a much faster algorithm on a
related graph model that relates maximum cuts to SNP allele
ﬂips (in the MEC model) [Bansal and Bafna (2008)]. Still other
authors have suggested reductions to the well-known maximum
satisﬁability problem [He et al. (2010); Mousavi et al. (2011)] The
Levy et al. (2007) algorithm is a well-known heuristic that was
used to haplotype assemble the HuRef genome; it assigns frag-
ments to haplotypes in a greedy fashion and iteratively reﬁnes
the solution by comparing the set of fragments to the assembled
haplotypes using majority rule phasings. In a recent survey,
Geraci (2010) describes the Levy et al. (2007) algorithm as, ar-
guably, the best performing algorithm tested.

The ﬁrst extension of the haplotype assembly problem that
addressed the simultaneous assembly of multiple diploid
chromosomes was presented in Li et al. (2006); however, the
beneﬁts of multi-haplotype assembly are not clear for a set of
unrelated individuals. Halldorsson et al. (2011) continued devel-
opment of this theory by describing methods for assembling in-
dividuals who share a haplotype identical by descent (IBD) using
relationships among the reads.

Aguiar and Istrail (2012) introduced a new graph data struc-
ture, algorithmic framework and the minimum weighted edge
removal (MWER) optimization, which together have several ad-
vantages over existing methods. Recall that the rows of M cor-
respond to sequence read fragments with the non-polymorphic
bases removed such that only SNPs remain. The HapCompass
model deﬁned in Aguiar and Istrail (2012) is composed of the
compass graph GC core data structure, which summarizes the
rows of M using edges weights and the MWER optimization
that aims to remove a minimum weighted set of edges from GC
such that a unique phasing may be constructed. The algorithm
operates on the spanning-tree cycle basis of GC to iteratively
remove errors that are manifested through a particular type of
simple cycle [Deo et al. (1982); Mac Lane (1937)].

In this work, we prove a number of theoretical results for the
previously described MWER optimization on compass graphs.
The main result proves MWER is NP-hard and motivates the
use of our heuristic algorithms. Further, we demonstrate how
extensions to the generalized diploid HapCompass model can
enable (i) usage of different optimizations, for example, MEC
and MWER, to be used in the local optimization step, (ii) sim-
ultaneous assembly of two individuals sharing a haplotype tract
IBD and (iii) haplotype assembly of a single polyploid organism.
Finally, we evaluate our methods on 1000 Genomes Project,
Paciﬁc Biosciences and simulated data.

2 METHODS

Let a fragment f be a sequence read with the non-polymorphic bases
removed such that only SNPs remain. Fragments may be either a
single contiguous region of DNA or contain any number of gaps between
contiguous regions (for example, one gap between two contiguous regions
in paired-end sequencing). Each SNP must be heterozygous and each row
must cover at least two SNPs to be able to extract useful haplotype phase
information from sequence reads. An SNP allele is encoded as 0 or 1
corresponding to the major or minor allele. The k’h base of the ith frag-
ment is referred to as fi, k. If f,- does not include the base k in the sequence
read (within the gap of a paired-read, for instance), then ka =‘—’. Let M
be the m x n SNP-fragment matrix with m rows corresponding to the m
fragments and n columns corresponding to n SNPs. Two fragments f,- and
ﬂ are in fragment conﬂict if

Elklfi,k #fjac /\fi,k7’é ‘—’/\fj,k75‘—’ (1)

Informally, fragment conﬂict represents two fragments that include the
same SNP but differ in the allele. The fragment conﬂict graph GF has a
vertex for each fragment in M and an edge between two fragments if they
are in fragment conﬂict. M is feasible if a bipartition exists in GF or,
equivalently, the fragments of M can be partitioned in two sets such
that no two fragments within each set are in fragment conﬂict.

2.1 The MWER optimization and HapCompass models

The HapCompass model deﬁned in Aguiar and Istrail (2012) is composed
of the compass graph GC data structure and optimizations on the span-
ning-tree cycle basis of this graph. GC is a graph with a vertex for each
SNP and an edge between two SNPs if at least one read contains both
SNPs (Fig. 2). The weight on the edge, deﬁned by the function f MWER, is
the difference between the number of fragments that suggest a (1x1) phasing
and the number of fragments that suggest (1’3).

A path in GC corresponds to a phasing of the SNP vertices by con-
catenating the phasings on the edges. For example, the (S1,S2),(S2,S4)
path in Figure 2 corresponds to the concatenation of the ‘1’}, phasing
with the (1’3) phasing, yielding the (1)3)? phasing. A number of subtle com-
binatorial properties of the diploid read information deﬁne the contiguity
of the assembly; in haplotype assembly of polyploid genomes where more
than two haplotypes exist, these combinatorial properties will be made
explicit and generalized as a basis for the development of polyploid
haplotype assembly algorithms.

A spanning tree in GC corresponds to a valid phasing of the SNPs of
GC. Simple cycles in GC have the property of being non-conﬂicting,
whereby every path in the cycle including the same set of vertices corres-
ponds to the same phasing, or conﬂicting, whereby there is no unique
phasing. Aguiar and Istrail (2012) show that a simple cycle is conﬂicting if
and only if there is a 0-weight edge or an odd number of negative weight
edges and non-conﬂicting otherwise. For the MWER optimization, the
HapCompass algorithm constructs a spanning-tree cycle basis of GC and
removes edges of small weight (in absolute value) from conﬂicting cycles
until GC is void of conﬂicts.

The generalized HapCompass model described in this work supports
multiple optimizations on compass graphs, joint haplotype assembly of
individuals sharing a haplotype tract IBD and haplotype assembly of
polyploid organisms. To support these algorithmic extensions, we exam-
ine key concepts of the HapCompass model and describe their
generalizations.

The core of the HapCompass framework constructs the compass graph
GC, a spanning-tree cycle basis of GC, and then corrects conﬂicting cycles.
One such method for correcting conﬂicting cycles was presented in Aguiar
and Istrail (2012) where edge weights are used to compute a set of edges
whose removal would eliminate conﬂicting cycles (the MWER optimiza-
tion). In principle, other methods may be used to remove edges, or entirely
new optimizations may be employed, for example, MEC. Speciﬁcally, we

 

i353

1e [glO'SIBILInO[p.IOJXO'SODBIIIJOJIIIOIQ/ﬂ(11111 IIIOJJ papeolumoq

910K ‘09 isnﬁnV uo ::

D.Aguiar and S.lstrail

 

 

SNP—Fragment Matrix

SNPs
$1 82 S3 S4

1 0
1

Compass Graph Gc

 

f1

 

f2

 

Fragments

 

 

f3
COOP

f4
|_|

 

 

 

 

 

 

 

 

 

Fig. 2. Construction of the compass graph from SNP-fragment matrix
M. The SNP-fragment matrix M (left) contains four fragments and four
SNPs. Each SNP’s pairwise phasing relationship deﬁned by the fragments
is represented on the edges of the compass graph (right). The majority
rule phasing for one of the haplotypes is shown in red on the compass
graph edges

implement an algorithm for the MEC optimization on compass graphs.
However, before an implementation of an MEC algorithm on compass
graphs can be realized, the HapCompass framework must be generalized
to allow for corrections to fragments.

Concept 1: edge weights. The HapCompass framework proposed in
Aguiar and Istrail (2012) deﬁnes edge weights as the difference between
the number of reads indicating the (1x1) and (1)}, phasings. The generalized
model includes a vector for edge e, ve, consisting of four integers corres-
ponding to the four possible haplotypes between two SNPs: 00, 01, 10, 11.
A function, f(e), maps the vector to a meaningful value interpreted by the
HapCompass algorithm. For example, in the MWER HapCompass al-
gorithm, fMWER(e) = ve[0] + ve[3] — ve[1] — ve[2] where ve[z'_| is the count
of the phasings 00, 01, 10, 11 for i = 0, 1,2, 3, respectively.

2.2 An MEC HapCompass optimization

The MEC optimization on GC aims to ﬂip the minimum number of alleles
such that all of the cycles are non-conﬂicting. The MEC algorithm pro-
ceeds by building a spanning tree cycle basis of the compass graph. The
following steps are repeated until each edge is non-conﬂicting. (i) For
each edge e in the set of conﬂicting cycles: let v1 and v2 be the two vertices
adjacent to e. (ii) If fMWER(e)<0, we check the fragments that include
both v1 and v2, and temporarily ﬂip the fragment alleles of v1 (v2 in
following iteration) to indicate (1’? phasings. The other alleles in the frag-
ments cause edges adjacent to v1 (v2) to change weight as well. We record
the number of conﬂicting cycles resolved and created by checking each
cycle in the cycle basis including an edge that was modiﬁed by the ﬂipping
of a fragment allele. (iii) The case of f MWER(e) > 0 is handled analogously
with the exception of ﬂipping the alleles to indicate (1)? phasings. (iv) Let
the number of conﬂicting cycles resolved by processing e be cm and the
number of conﬂicting cycles created be ce, 6. If maxVe(ce, , — ce, 0) 5 0, then
there does not exist a favorable switching of fragment alleles and an edge
is removed following the MWER algorithm. Otherwise, the fragment
changes giving maxVe(ce,,. — cm) 5 0 are introduced in GC. (v) When
all cycles are non-conﬂicting, we output the phasing deﬁned by any
spanning tree.

The primary data structure change in GC introduces a mapping of edges
to fragments. The primary addition to the HapCompass framework is a
deﬁnition of optimization function to remove conﬂicting cycles from GC.

2.3 IBD tracts and haplotype assembly

Thus far, the HapCompass framework has only been deﬁned for a single
diploid individual. The generalization of haplotype assembly to multiple

genomes must be selective for which individuals to assemble jointly. For
example, if two individuals do not share a haplotype by descent, one
individual’s set of reads does not provide any information for the
other. However, when two individuals do share a haplotype by descent,
the shared haplotype provides phasing information across homozygous
sites as long as one individual remains heterozygous (Fig. 3). Regions of
homozygosity in an individual, which would otherwise disconnect SNPs
and partition haplotype solutions, can be phased together as long as the
jointly assembled genotype has heterozygous SNPs within the interval.

Concept 2: multiple genotypes. The problem of joint assembly of two
individuals who share a haplotype IBD (hereafter referred to as a pair) is
different from jointly assembling two individuals who do not share a
haplotype. In the compass graph, two unrelated genotypes have the
effect that both individuals can be heterozygous but have completely
different phasings. However, if they share a haplotype, a transition
from a doubly heterozygous SNP to another doubly heterozygous SNP
forces exactly two phasings, namely ‘1’? or ‘1’}, (for example, SNP transitions
(1,2) and (4,5) in Fig. 3). For the doubly heterozygous to singly hetero-
zygous transitions, we may have exactly three of the four possible 2-SNP
haplotypes. In Figure 3, the child’s genotype is 22122 and to phase this
block using the child’s data alone, we require a read to cover at least one
of the ﬁrst two SNPs and at least one of the last two SNPs, which may be
impossible depending on the distance between the SNPs and sequence
read insert length. However, if we assemble the parent with the child, we
can use the shared haplotype to decode the parent’s phase across SNPs 2,
3 and 4 to be (3%. Because they share a haplotype, the 111 haplotype must
be the shared haplotype and it can be inferred that the child’s phased
haplotypes are 9,1,}5‘1’.

Joint haplotype assembly in HapCompass is thus encoded as follows.
Each edge now has two sets of vectors corresponding to the 2-SNP haplo-
type transitions of the parent and child. For a doubly heterozygote to
doubly heterozygote transition, the weight function can be computed as
before using the coverage from both individuals (because there are exactly
two disjoint phasings). For a singly heterozygote to doubly heterozygote
transition (or vice-versa), the weight function can solely use the hetero-
zygous—heterozygous transmission data from a single individual.

2.4 Haplotype assembly of polyploid genomes

The research literature concerning polyploid haplotype assembly is essen-
tially non-existent. The analysis of k-ploid genomes (k sets of chromo-
somes) has been hindered by the complexity of sequencing and
assembling k chromosomes concurrently. With high-throughput sequen-
cing technologies, genotype inference in polyploid organisms is manage-
able; sequence reads are mapped to a reference genome, and the relative
quantities of alleles at an SNP can be inferred from sequence coverages.
However, the basic assumption that there exists exactly two phasing be-
tween two SNPs no longer holds. We note that the polyploidy assembly
problem is similar to a number of problems in other areas of haplotype
reconstruction (when the number of haplotypes is known or unknown)
such as modeling metagenomics (organism identiﬁcation), HIV (viral
quasispecies identiﬁcation in the ‘metagenome’ of patients), cancer
(tumor and plasma) and epigenetics (regulatory region methylation re-
construction similar to ‘probabilistic haplotype’ inference).

Concept 3: uniqueness and disjoint phasings. One difﬁculty of polyploid
haplotype assembly emerges from the non-disjointness of phasing solu-
tions between SNPs. With the assumption that SNPs are biallelic, at least
one haplotype will be shared by two or more phasings between two SNPs.
In the diploid case, a read suggesting the 00 phasing could be interpreted
as evidence for 11 on the other haplotype (uniqueness of phasing) and
also evidence contradicting the ‘1’}, phasing (disjointness of haplotypes in
phasing solutions). In the tetraploid case, for example, if the genotype for
each of 2 SNPs is {0, 0, 1, 1} then there exists three possible haplotype
phasings: (00,00,11,11), (01,01,10,10), (00,01,10,11).

 

i354

1e ﬁrosleumo[pJOJXO'soi1emJOJuioiw/2d11q IIIOJJ papeolumoq

910K ‘09 isnﬁnV no 22

Haplotype assembly in polyploid genomes

 

shared
IBD

 

 

Fig. 3. A graph of the haplotype transitions deﬁned by the majority rule
phasings of a compass graph. SNPs 1, 2, 3, 4 and 5 (left to right) are
shown with both alleles (vertices), and edge transitions are encoded by a
speciﬁc type of line depending on whether the haplotype is shared IBD or
unique to the child or parent. The genotype of the parent and child are
22 222 and 22 122, respectively (where the two corresponds to the hetero-
zygote and 0 and 1 correspond to homozygous for the major and minor
alleles, respectively)

In general, the number of haplotype phasings on an edge is a function
of the ploidy of the organism and the alleles at each SNP. As in the
diploid case, each SNP must have at least one of each allele or else the
SNP is homozygous and sequence observations of an allele do not pro-
vide any phasing information. As a result, every 2-SNP haplotype in-
cludes either (I)? or (1’3).

However, unlike in the diploid case, the extension from one edge in GC
to the next may not be deterministic. For example, in diploid assembly, if
a reads suggest a (I)? phasing for SNPs 1 and 2, and a (I)? phasing for SNPs
2 and 3, the extension would give us a phasing of (ﬁg). A conﬂicting cycle
in GC could then be generated if reads connecting SNPs 1 and 3 disagreed
with this phasing. For the polyploid case, if the genotypes for each of
SNP 1 and 2 are (0,0,1), then both the (00,00,11) phasing and (00,01,10)
phasing are valid. Assume that we can compute the phasings between
SNPs 1 and 2 and SNPs 2 and 3 to be (00,00,11); we can extend as we did
in the diploid case to create the phasing (000,000,111). Then, if a read
suggests a 01 phasing between SNPs 1 and 3, we again generate a con-
ﬂicting cycle. However, if the SNPs were phased using (00,01,10) for
SNPs 1,2 and 2,3, then either phasing (000,010,101) or (001,010,100) is
possible. Both are completely valid phasings consistent with the genotype
and read data but fragments connecting SNPs 1 and 3 may constrain the
phasing solution to be unique.

Concept 4: polyploid edge decidability. The polyploid HapCompass
model retains the axiom that each edge is decidable; that is, each edge
has a unique and computable phasing as deﬁned by the reads. The com-
pass graph and spanning tree cycle basis is built from the input genotypes
and reads as before. The distribution of haplotype conﬁgurations be-
tween two SNPs are deﬁned by the genotypes, and a singular conﬁgur-
ation is computed using the available read data. The ﬁrst approach
attempts to assign reads into haplotype bins that represent the haplotype
distribution for a valid phasing between two SNPs. Given a 2-SNP geno-
type, a binning is an assignment of reads to haplotypes. For example, if
two SNPs both had two 0 alleles and two 1 alleles, there would exist three
haplotype phasings: (00,00,11,11), (01,10,11,00), (01,10,01,10), each with
4 bins. The phasing (00,00,11,11), for instance, would contain two 00 bins
and two 11 bins.

Greedy binning algorithm. Input: a maximum distance d between any
two bins, a set of haplotype phasings P and a set of reads R. Output: the
haplotype phasing most supported by the reads.

(1) For each haplotype phasing p e P
(2) For each haplotype bin b e p, do steps (3—5).

(3) Loop through steps (4—5) until all read fragments have been
assigned.

(4) Select a read r e R such that the edit distance between r and an
available haplotype bin h e b is minimal.

(5) Place r in the selected bin h and remove this read from the read set.

(6) Report the haplotype phasing with the binning of minimum total
edit distance as the optimal phasing.

We enforce that the difference of haplotypes in each bin must be at
most d haplotypes to avoid always preferring diverse haplotype phasings
[e.g. (10,10,01,01) versus (00,11,10,01)]. This condition deﬁnes which
haplotype bin is available during each iteration.

Probabilistic binning algorithm. Alternatively, probabilities of each
phasing given the set of reads can be computed and uncertainty can be
accounted for when extending phase to adjacent edges. In particular, we
wish to compute the likelihood of a phasing given the set of input sequence
reads. Let p,- be the ith phasing for two adjacent SNPs, P the set of all
possible phasings for the two SNPs, rj be the jth read and Se the probability
of a sequencing error. Then, the likelihood of a particular phasing pp is
  =  

X; P(r1, r2, . . . , rnlse,p,-)
l:

_ P(r1|Se:Pp) ' P(r2|Se:Pp) ' ' ' P(rn|Seapp)
— IPI

ZP(rlar29 ---:rn|Seapi)

i=1

 

 

which may be computed using the assumption that sequence reads are
independent. The probability of a read r,~ given sequencing error Se and
phasing p can be computed by marginalizing over all possible haplotypes
h sampled for phasing p:

ZPUZISeap) ' P(ri|Seahap) 

hep

Thus, the edge is decisive for the haplotype phasing with the maximum
likelihood for all reads that span the two SNPs. The original diploid
scoring scheme can be recreated with a manipulation of the unnormalized
phasing likelihoods: 2:721 P(r,-|se = 0, h 25(1)) — 2:721 P(r,-|se = 0, h 2(1)? .

Concept 5: conﬂicting cycles and phase extensions. Both the greedy and
probabilistic binning algorithms decide the haplotype phase of edges. In
the diploid case, the extension of phasings from edges to paths was un-
ambiguous because for each of the two phasings, exactly one haplotype
begins with 0 (or 1) and exactly one haplotype ends with 0 (or 1).
Therefore, the computation of phasings for paths and conﬂicting cycles
was easily determined given the decided edges. In polyploid genomes,
each SNP variant in GC is still assumed to have only two possible alleles
but each edge has three or more haplotypes. When extending phase from
one edge to an adjacent edge, the haplotypes on different edges that share
an allele can be used for extending phase. If this allele is present in k
haplotypes, then there are k! possible extensions.

Phase extension algorithm. We introduce the chain graph Gh, which is
deﬁned on a path or cycle in GC for a k-ploid genome. Let
(e1,e2, ...,e[) = p denote a path of edges in GC of length 1. Each edge
e,- is phased (by the greedy or probabilistic method) and each haplotype in
the phasing introduces a vertex in G, at level i. Thus, G, contains k
vertices for each e,- e p and a total of l - k vertices in total. Two haplotype
vertices are connected by an edge if and only if they share an SNP pos-
ition and allele. Because haplotypes at adjacent levels uniquely share an
SNP position in Gh, edges only exist between adjacent levels and a path
through the chain graph corresponds to a joining (or extension) of haplo-
types. Therefore, there is always a valid phasing for a G, deﬁned on a
path of GC.

Cycles introduce complexity in Gh. Gh deﬁned on a cycle retains the
characteristics of the path chain graph, but also includes source and sink
nodes: s1, ...,sk and t1, ...,tk, respectively. Let (e1,e2, ...,el,e1) =p
denote any path of edges in GC of length l with the addition of the
(e1, e1) edge. Source nodes are connected arbitrarily to haplotypes on
level 1 but haplotypes on level I are only connected to sink nodes if the
shared variant position agrees with the haplotype the source was con-
nected to; for example, in Figure 5 Top, t2 is connected to both 00

 

i355

1e ﬁrosleumo[pJOJXO'soi1emJOJuioiw/2d11q IIIOJJ papeolumoq

910K ‘09 isnﬁnV no 22

D.Aguiar and S.lstrail

 

   

Fig. 4. Compass graphs GC, g, a non-conﬂicting polyploid cycle (left), and
GQC, a conﬂicting polyploid cycle (right). The vector on the edge corres-
ponds to the haplotype counts for an edge in the format [00,01,10,11]. In
both compass graphs, the haplotypes are 000, 000 and 111, while the
reads in Gag are 000, 000 and 111, and the reads in GQC are 00—, 01—,
10—, —00, —00, —11, 0—0, 0—0 and 1—1

haplotypes at level I because s2 is connected to a haplotype starting with
0. The sources and sinks represent the (e1, e1) edge and a path from s,- to t,-
represents one valid haplotype. This intuition enables the formulation of
the k vertex disjoint paths problem on chain graphs. If there exists k

vertex disjoint, s,- to t,- paths for i = 1, ...,k, we have k valid phasings
for the cycle; otherwise, the cycle is conﬂicting and there is no valid
phasing.

To further build intuition, consider a conﬂicting cycle of GC and G, in
the diploid case. A cycle was conﬂicting if the number of negative
weighted edges in GC was odd. Relating this to the chain graph Gh, an
s, node would be connected to a 0 (or 1) and each negative edge would ﬂip
the next bit. So, a conﬂicting cycle has an odd number of negative edges,
which translates into an odd number of bit ﬂips resulting in no s, to t,~
path for i = 1, 2. Figure 4 gives an example of non-conﬂicting and con-
ﬂicting cycles in polyploid compass graphs and Figure 5 their chain
graphs.

Gh enables the (i) determination of conﬂicting cycles and (ii) compu-
tation of the phased haplotypes for a path or cycle using disjoint paths.
The k-disjoint paths problem is a well-studied optimization in the ﬁeld of
discrete mathematics [Robertson and Seymour (1995)]. A polynomial-
tirne solution is known to exist for the node disjoint paths problem
when k is known as part of the input [Robertson and Seymour (1995);
Kawarabayashi et al. (2012)], but these algorithms require manipulation
of enormous constants rendering them difﬁcult to implement in practical
settings.

Fortunately, the structure of Gh enables a much more efﬁcient solution
to the problem. All paths from s, to t,~ can be computed by a modiﬁed depth
ﬁrst search algorithm. A depth ﬁrst search is started from each source s,-
and the path from source to the current node is stored. Each node contains
a list of integers initially empty. When the algorithm either encounters the
sink node t,~, or a node already labeled with i, all nodes on the current path
have i added to their list. After each source—sink pair is processed, each
node contains a label i if there is an s,- to t,- path that includes the node. The
runtime of this algorithm is 0(kve) where k is the ploidy, and v and e are the
number of vertices and edges in Gh, respectively.

After all nodes are labeled, we iterate through each level of G, and
create an auxiliary ﬂow graph G2 where [is the level. G2 deﬁnes a bipart-
ite graph where one set of vertices corresponds to the source haplotype
paths, which are connected to a set of vertices corresponding to the
haplotypes of the phasing level I. A ﬂow in G2 of total value k where
each edge has capacity 1 corresponds to a maximum matching and thus a
valid assignment of haplotype paths to haplotypes of the phasing at level
I. This ﬂow can be found in time linear in the size of the edge set of G2. If
every level of the chain graph has a valid bijection, then the cycle is non-
conﬂicting and the path given by the matchings deﬁne a valid phasing.
Figure 6 give an example of the auxiliary ﬂow graphs for level 1 of the
chain graphs deﬁned in Figure 5.

 

Fig. 5. The chain graphs (top) Gag and (bottom) Gm corresponding to
Gag and GQC, respectively

Fig. 6. The auxiliary ﬂow graphs (top) G2,g and (bottom) G2, 6. For a k-
ploid organism (in this case k: 3), a ﬂow of k with 1 capacity on each
edge corresponds to a valid assignment of haplotype paths to haplotypes
of the phasing a level 1

3 RESULTS

3.1 Theoretical

We ﬁrst present results on the complexity of the MWER opti-
mization, and related minimum weighted vertex (SNP) removal
(MWVR) problems on the compass graph GC. These results mo-
tivate the usage of our heuristics for the diploid and polyploid
algorithms. Let L C VC be a subset of vertices in GC, and let G’C
be the resulting graph created from removing L from VC. The
MWVR optimization aims to compute an L such that the fol-
lowing conditions are satisﬁed:

(i) 2,2,6, |w(s,-)| is minimal where w(s,-) is the weight of the ith
SNP (cost of removed vertices is minimal);
(ii) All edges in G’C are decisive (each edge has a majority rule
phasing);
(iii) Choosing a phasing for each edge in G’C by majority rule
gives a unique phasing for G’C.

 

i356

1e ﬁrosleumo[pJOJXO'soi1emJOJuioiw/2d11q IIIOJJ pepeolumoq

910K ‘09 isnﬁnV no 22

Haplotype assembly in polyploid genomes

 

We omit the straightforward proofs that the MWVR and
MWER problems are in NP. It remains to be shown that known
NP-hard problems can be reduced to MWVR and MWER.

We restate the conﬂict graph generality lemma from Lippert
et al. (2002).

LEMMA 1. Let G = (V, E) be an arbitrary graph. Then there
exists an SNP-fragment matrix M such that GF(M) = G.

PROOF: Introduce a fragment f,- for each vertex v,- e V. For
every two adjacent vertices {v,-, Vj} e E, introduce a new SNP
column sk in Mwhereka = 0 andek = 1.

Let M be the SNP-fragment matrix constructed from Lemma
1, GF the corresponding fragment conﬂict graph of M and GC the
compass graph of M.

LEMMA 2. Every simple cycle of odd length in GF produces
exactly one conﬂicting simple cycle in GC.

For the proof of Lemma 2 please see Supplementary Appendix
Proof of Lemma 2.

LEMMA 3. Every conﬂicting simple cycle in GC includes exactly
one odd length simple cycle in GF.

PROOF. We now interpret conﬂicting cycles in GC as a set of
vertices of GC, which deﬁne a set of edges in G F.

Because of the previous lemma, every conﬂicting cycle in GC can
be resolved by removing an edge of GF, which corresponds to
removing a vertex in GC.

COROLLARY 1. There exists no conﬂicting cycles in GC if and
only if there are no cycles of odd length in GF.

LEMMA 4. Given an M produced from Lemma 1, the compass
graph GC(M) is the line graph of GF(M) with weights of GC as
defined by the phasing relationships of the fragments of M.

Proof. The SNPs (columns) of M contain exactly two alleles
from two fragments that conﬂict. Therefore, in GF, each SNP
uniquely deﬁnes an edge, and in GC, each SNP uniquely deﬁnes a
vertex. All that remains is to show that every two adjacent edges
in GF produce an edge in GC. Consider an SNP s whose conﬂicts
involve fragments f,- and The edge deﬁned by s in GF is adja-
cent to edges deﬁned by the other conﬂicts off,- and The vertex
s in GC is deﬁned exactly as the pairwise phasing relationships as
deﬁned by the SNP s and other SNP alleles in fragments f,- and fj,
which in turn deﬁne the adjacencies in GF.

Because GC is the line graph of GF, if k simple cycles in GC
share an edge then k simple cycles in GF share a vertex.

THEOREM 1. M WVR is NP—hard.

PROOF: See the M WVR Proof section in Supplementary
Appendix.

THEOREM 2. M WER is NP—hard.

PROOF: The reduction is from the problem of removing the
minimum number of edges of a graph to make it bipartite. Let G
be an arbitrary graph and M the SNP-fragment matrix as
deﬁned in Lemma 1. We modify GF(M) by adding two add-
itional degree 2 vertices to each edge, effectively converting

each edge to a length 3 path. Cycles of odd (even) length
retain their odd (even) length, thus odd length cycles still create
conﬂicting cycles in GC. All vertices of degree k produce cliques
of size k in GC, which do not correspond to any cycles in G F(M).
Therefore, we label all edges of clique vertices produced from a
single vertex with weight 00. All paths of G F will be encoded with
two edges of GC; both of which cannot be removed in an optimal
solution to MWER. Given a solution to the MWER optimiza-
tion, we can determine the minimum number of edges in GF to
make it bipartite.

3.2 Experimental

We evaluate the HapCompass MEC, HapCompass IBD and
polyploid HapCompass algorithms using 1000 Genomes
Project [The 1000 Genomes Project Consortium (2010)], Paciﬁc
Biosciences and simulated data.

Metrics. To evaluate the accuracy of our diploid haplotype
assembly methods, we use the following measures, which capture
different aspects of haplotype assembly quality. In Aguiar and
Istrail (2012), we introduce the fragment mapping phase relation-
ship (F MPR) distance, which counts the number of pairwise
phase relationships (as deﬁned by the input read fragments)
that do not exist in the solution. The related boolean fragment
mapping (BFM) distance counts the number of read fragments
that do not map back to the solution. The third evaluation criteria
we use is the MEC measure, which counts the number of allele
ﬂips in the fragments required to produce the phased haplotype
assembly solution. In all previously described measures, lower
values are desired. These metrics are similar to read mapping
metrics in genome and transcriptome assembly, where good-qual-
ity assemblies will allow for many reads to map back to them.

3.3 Paciﬁc biosciences data

Single molecule sequencing has great potential to become a pre-
ferred method for haplotype assembly, but current algorithmic
techniques are untested on data with high error rates. We down-
loaded the chromosome 20 data from individuals HG00321,
HG00577, HG01101, NA18861, NA19313, NA19740,
NA20296 and NA20800 [PacBio Data (2013)]. Haplotype assem-
bly solutions were produced by HapCompass, Levy et al. (2007)
and HapCUT to obtain the results in Table 1 (run times can be
found in the Pacific Biosciences run times section in
Supplementary Appendix). HapCompass outperforms the com-
petition in terms of MEC using both optimizations. Interestingly,
the Levy et al. (2007) algorithm is the most accurate in terms of
FMPR and BFM. This is likely due to the Levy et al. (2007)
algorithm processing entire read fragments each iteration while
HapCompass focuses on correcting multiple fragments at adja-
cent SNPs. Because the Paciﬁc Biosciences read lengths are long
(several kb), more emphasis is placed on matching reads with
large overlaps on the same haplotype. This result further suggests
that it is important to consider the input data and the desired
results when preparing data for a haplotype assembly experiment.

3.4 1000 genomes project data

To further evaluate the HapCompass MEC implementation, we
haplotype assembled the genome of 1000 Genomes Project

 

i357

1e ﬂJO'SIBumo[pJOJXO'soi1emJOJuioiw/2d11q IIIOJJ pepeolumoq

910K ‘09 isnﬁnV no 22

D.Aguiar and S.lstrail

 

NA12878 CEU child using our implementation of the Levy et al.
(2007) method, HapCUT (v0.5) and the HapCompass MWER
and MEC algorithms. Table 2 shows that the HapCompass
MWER algorithm clearly performs best overall. The full table
for all chromosomes is given in Supplementary Appendix (sec-
tion 1000 Genomes Project Results). Surprisingly, even though
the MWER algorithm does not directly optimize the MEC meas-
ure, it produces the best haplotypes in respect to this measure for
all but two chromosomes.

3.5 IBD haplotype assembly

Jointly assembling the haplotypes of related individuals has con-
siderable beneﬁts. The ﬁrst beneﬁt comes from the extra cover-
age on the shared haplotype, which helps with differentiating
true phasings from sequencing errors. However, the most notable
advantage is being able to extend phasing past homozygous
blocks. We compared the size of the phased haplotype blocks
when assembling chromosome 22 of the NA12878 child in the
1000 Genomes Project data alone versus jointly with the mother.
Figure 7 compares the maximum achievable haplotype block
sizes of any single individual haplotype assembly algorithm to
IBD haplotype assembly; it demonstrates that larger haplotype
blocks are achievable by assembling two individuals with a
shared haplotype together rather than separately.

3.6 Polyploid algorithm

Finally, to evaluate the polyploid algorithm, we simulated three
haplotypes at random and simulated reads from these haplo-
types. The simulated reads were guaranteed to contain two
SNPs (assuring they are useful for haplotype assembly) and
given normally distributed insert sizes. The polyploid algorithm
was run using both the greedy and probabilistic binning algo-
rithms for deciding edge phasings. Figure 8 demonstrates two

Table 1. The total FMPR, BFM and MEC scores aggregated across
individuals HG00321, HG00577, HG01101, NA18861, NA19313,
NA19740, NA20296 and NA20800 in the Paciﬁc Biosciences data

 

HapCompass MWER HapCompass MEC Levy HapCUT

 

FMPR 163 799 169 385 153 433 169 890
BFM 39 827 40 470 38 318 41 006
MEC 48 631 49 591 66 299 50 164

 

interesting results: (i) for a small number of reads, the quality
of haplotype phasing is independent of the choice of binning
method and (ii) that the probabilistic algorithm produces a
more accurate phased solution than the greedy binning method
for a large range of simulated read counts.

4 DISCUSSION

Diploid haplotype inference is still a difﬁcult task, in part due to
the exponentially many solutions given the input genotype or
sequence reads. HapCompass is a proven framework for haplo-
type assembly but there are a number of extensions that may
improve results. For instance, we did not mention the usage of
base call or read mapping quality scores in our computations.
HapCompass can ﬁlter based on user-deﬁned thresholds but a
more elegant solution would be to convert the base call quality
score for a particular allele call into a probability the base was
called correctly. This probability can then deﬁne the contribution
of weight to the edges of GC rather than the current weight
contribution of 1 for each SNP allele called. Also we demon-
strated in the Paciﬁc Biosciences experiments that the choice of
assembly method should be informed by the sequencing technol-
ogy and desired result. The Levy et al. (2007) method mapped

Haplotype size distribution for trio assembly

type of assembly
.child + mother
.child only

number of phasings
O

 

I I

2'0 4'0 6'0
phased haplotype block size

Fig. 7. Comparison between haplotype assembling the child individually

versus with a parent. The haplotype size is number of SNPs in the com-

ponent of GC, which represents the maximum number of SNPs that may

be phased together

Table 2. Haplotype assembly results for the 454 data from 1000 Genomes Project NA12878 individual for chromosomes 1—22 and algorithms

HapCompass MWER, HapCompass MEC, Levy et al. (2007) and HapCUT

 

 

HapCompass MWER HapCompass MEC Levy HapCUT
FMPR BFM MEC FMPR BFM MEC FMPR BFM MEC FMPR BFM MEC
64128 36 578 37 597 68 623 39 221 40 269 64 789 39 832 40 946 65 724 37 606 38 372

 

Note: The full table is given in the section 1000 Genomes Project Results in Supplementary Appendix.

 

i358

1e ﬂJO'SIBumo[pJOJXO'soi1emJOJuioiw/2d11q IIIOJJ pepeolumoq

910K ‘09 isnﬁnV no 22

Haplotype assembly in polyploid genomes

 

Polyploid haplotype assembly accuracy

binning algorithm
.- greedy
0.95 - .- probabilistic

0.90-

0.85-

correctly phased haplotypes (%)

0.80-

 

1ei-02 1ei-03 1ei-04 1ei-05 3ei-05

number of reads
Fig. 8. Comparison of the percentage of correctly phased polyploid SNP

pairs for the greedy and probabilistic binning algorithms for varying
number of input reads

more fragments error free than HapCompass but contained
many more single base changes in fragments required to repro-
duce the inferred haplotypes. Considering the Paciﬁc Biosciences
data has high error rates and generating an error-free read is
unlikely, a solution with the minimum number of corrected
errors is likely preferred over a solution that successfully maps
more fragments without errors.

The size of the haplotype blocks produced and, ultimately, the
quality of the assembled haplotypes is a function of several fac-
tors. The primary difﬁculty for obtaining large haplotype blocks
is the small nature and lack of diversity of insert lengths. We
demonstrated a novel modeling and computational method that
begins to address this difﬁculty by exploiting shared IBD haplo-
type structure. In general, assembling the haplotypes of related
individuals has considerable beneﬁts, which help overcome un-
desirable properties of the sequencing data. The ﬁrst beneﬁt
comes from the extra coverage on the shared haplotype,
which helps in differentiating actual phasings from sequencing
errors. However, the most notable advantage is being able to
include more SNPs into the haplotype assembly, which helps
extend the assembly (past regions of low read coverage for ex-
ample). But, the major advances in block sizes will likely be the
result of novel experimental procedures and technologies; for
instance, not only do the single molecule sequencers promise
larger read lengths, they also enable the inclusion of multiple
and large insert lengths.

Organisms having more than two sets of homologous chromo-
somes are becoming the target of many research groups inter-
ested in studying the genomics of disease, phylogenetics and
evolution [Chen and Ni (2006); Leitch and Leitch (2008)].
Polyploidy occurs in human disease usually due to the duplica-
tion of a particular chromosome, for example, in Edwards, Patau
and Down syndrome. While far fewer mammalian organisms are
polyploid, speciﬁc mammalian cells may undergo polyploidiza—
tion, for example, in human liver hepatocytes [Gentric et al.
(2012)]. In addition, polyploid organisms are ubiquitous in the

Plant and Fungi clades, present in crops that we ingest, convert
into bioenergy and feed to livestock. Understanding the gen-
omics of both the desirable—e. g. increased crop yield—and un-
desirable—e.g. susceptibility to disease—properties of plants
may lead to critical advances in many research areas but requires
untangling the polyploid genome and its variation. As more
polyploid data becomes available, our approach may be used
to infer haplotypes and begin to understand what effects haplo-
type variation may inﬂuence.

Funding: This work was supported by the National Science
Foundation [1048831 to SI].

Conﬂict of Interest: none declared.

REFERENCES

Aguiar,D. and Istrail,S. (2012) Hapcompass: a fast cycle basis algorithm for accur-
ate haplotype assembly of sequence data. J. Comput. Biol, 19, 577—590.

Bansal,V. and Bafna,V. (2008) HapCUT: an efﬁcient and accurate algorithm for the
haplotype assembly problem. Bioinformatics, 24, i153—i159.

Bansal,V. et al. (2008) An MCMC algorithm for haplotype assembly from whole-
genome sequence data. Genome Res., 18, 1336—1346.

Browning,S.R. and Browning,B.L. (2011) Haplotype phasing: existing methods and
new developments. Nat. Rev. Genet, 12, 703—714.

Chen,Z.J. and Ni,Z. (2006) Mechanisms of genomic rearrangements and gene ex-
pression changes in plant polyploids. BioEssays, 28, 240—252.

Deo,N. et al. (1982) Algorithms for generating fundamental cycles in a graph. ACM
Trans. Math. Softw., 8, 26—42.

Gentric,G. et al. (2012) Polyploidy and liver proliferation. Clin. Res. Hepatol.
Gastroenterology, 36 (1), 29—34.

Geraci,F. (2010) A comparison of several algorithms for the single individual SNP
haplotyping reconstruction problem. Bioinformatics, 26, 2217—2225.

Halldérsson,B.V. et al. (2003) Combinatorial problems arising in snp and haplotype
analysis. In: Proceedings of the 4th international conference on Discrete mathem-
atics and theoretical computer science, DM T CS ’03. Springer-Verlag, Berlin,
Heidelberg, pp. 26—47.

Halldorsson,B.V. et al. (2011) Haplotype phasing by multi-assembly of shared
haplotypes: Phase-dependent interactions between rare variants. In:
Proceedings of the Paciﬁc Symposium on Biocomputing. Kohala Coast,
Hawaii, USA, pp. 88—99.

He,D. et al. (2010) Optimal algorithms for haplotype assembly from whole-genome
sequence data. Bioinformatics, 26, i183—i190.

Kawarabayashi,K. et al. (2012) The disjoint paths problem in quadratic time.
J. Comb. Theory B, 102, 424—435.

Lancia,G. et al. (2001) SNPs problems, complexity, and algorithms. In: ESA ’01.-
Proceedings of the 9th Annual European Symposium on Algorithms. Springer-
Verlag, London, UK, pp. 182—193.

Leitch,A.R. and Leitch,I.J. (2008) Genomic plasticity and the diversity of polyploid
plants. Science, 320, 481—483.

Levy,S. et al. (2007) The diploid genome sequence of an individual human. PLoS
Biol, 5, e254.

Li,ZP. et al. (2006) A dynamic programming algorithm for the k-haplotyping prob-
lem. Acta Math. Appl. Sin. (English Series), 22, 405—412.

Lippert,R. et al. (2002) Algorithmic strategies for the single nucleotide polymorph-
ism haplotype assembly problem. Brief Bioinform., 3, 23—31.

Mac Lane,S. (1937) A combinatorial condition for planar graphs. Fundam. Math,
28, 22—32.

Mousavi,S.R. et al. (2011) Effective haplotype assembly via maximum Boolean
satisﬁability. Biochem. Biophys. Res. Commun., 404, 593—598.

PacBio Data. (2013) Broad institute hapmap paciﬁc biosciences data. https://github.
com/PacificBiosciences/DevNet/wiki/Datasets. (15 January 2013, date last
accessed).

Panconesi,A. and Sozio,M. (2004) Fast hare: a fast heuristic for single individual
snp haplotype reconstruction. In: Jonassen,I. and Kim,J. (eds) Algorithms in
Bioinformatics, volume 3240 of Lecture Notes in Computer Science. Springer,
Berlin/Heidelberg, pp. 266—277.

Rizzi,R. et al. (2002) Practical algorithms and ﬁxed-parameter tractability for the
single individual snp haplotyping problem. In: Proceedings of the Second

 

1e /810's112umo[pJOJXO'soi1emJOJuioiw/2d11q IIIOJJ pepeolumoq

910K ‘09 isnﬁnV no 22

D.Aguiar and S.lstrail

 

International Workshop on Algorithms in Bioinformatics, WABI ’02. Springer-
Verlag, London, UK, pp. 29—43.

Robertson,N. and Seymour,P. (1995) Graph minors .xiii. the disjoint paths problem.
J. Comb. Theory B, 63, 65—110.

Schwartz,R. (2010) Theory and algorithms for the haplotype assembly problem.
Commun. Inf. Syst., 10, 23—38.

The 1000 Genomes Project Consortium. (2010) A map of human genome variation
from population-scale sequencing. Nature, 467, 1061—1073.

 

i360

1e /810's112umo[pJOJXO'soi1emJOJuioiw/2d11q IIIOJJ pepeolumoq

910K ‘09 isnﬁnV no 22

