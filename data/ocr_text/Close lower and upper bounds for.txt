Vol. 26 ISMB 2010, pages i140—i148
doi: 10. 1093/bioinformatics/btq 198

 

Close lower and upper bounds for the minimum reticulate
network of multiple phylogenetic trees

Yufeng Wu

Department of Computer Science and Engineering, University of Connecticut, Storrs, CT 06269, USA

 

ABSTRACT

Motivation: Reticulate network is a model for displaying and
quantifying the effects of complex reticulate processes on the
evolutionary history of species undergoing reticulate evolution.
A central computational problem on reticulate networks is: given a
set of phylogenetic trees (each for some region of the genomes),
reconstruct the most parsimonious reticulate network (called
the minimum reticulate network) that combines the topological
information contained in the given trees. This problem is well-known
to be NP-hard. Thus, existing approaches for this problem either
work with only two input trees or make simplifying topological
assumptions.

Results: We present novel results on the minimum reticulate network
problem. Unlike existing approaches, we address the fully general
problem: there is no restriction on the number of trees that are input,
and there is no restriction on the form of the allowed reticulate
network. We present lower and upper bounds on the minimum
number of reticulation events in the minimum reticulate network
(and infer an approximately parsimonious reticulate network). A
program called PIRN implements these methods, which also outputs
a graphical representation of the inferred network. Empirical results
on simulated and biological data show that our methods are practical
for a wide range of data. More importantly, the lower and upper
bounds match for many datasets (especially when the number of
trees is small or reticulation level is low), and this allows us to solve
the minimum reticulate network problem exactly for these datasets.
Availability: A software tool, PIRN, is available for download from
the web page: http://www.engr.uconn.edufywu.

Contact: ywu@engr.uconn.edu

Supplementary information: Supplementary data is available at
Bioinformatics online.

1 INTRODUCTION

Reticulate evolution, a form of evolution with hybridization and
genetic exchanges between two species, are common in many
organisms: bacteria, plants, ﬁsh, amphibians and many others.
For better understanding of reticulate evolution, several reticulate
evolutionary models have been proposed and actively studied to
address various reticulate processes, such as hybrid speciation,
lateral gene transfer and recombination. Since most of these models
are in the forms of networks, we call them reticulate networksl.
We refer the readers to (Huson, 2007; Huson and Bryant, 2006;

 

1Other terms have been used in literature, such as phylogenetic networks and
hybridization networks

Nakhleh, 2009; Semple, 2007) for surveys of different reticulate
network models.

The key computational problem related to these models is
the inference of reticulate networks. Depending on the types of
biological processes involved, data for network inference may be in
different forms, such as phylogenetic trees for some short genomic
regions (called genes in this article) or aligned DNA sequences. In
this article, we focus on inferring reticulate networks from a set
of correlated phylogenetic trees. Here is the biological motivation
for our problem. Suppose multiple phylogenetic trees (called gene
trees in this article) are reconstructed, each from some gene for
these species. Due to reticulate evolution, different genomic regions
(say genes) may be inherited from different ancestral genomes
and their evolutionary histories may not be the same (but are still
related). Thus, these trees are correlated but not identical. No single
phylogenetic tree can faithfully model the evolution of the species,
and a more complex network model (i.e. reticulate network as
studied in e. g. Baroni et al., 2004; Huson, 2007; Huson et al., 2005;
Nakhleh et al., 2004; Semple, 2007) is needed.

Imagine we are given a set of ‘true’ gene trees and a ‘true’
reticulate network that models the evolutionary history of these
genes. The network can be considered as a compact representation
of these gene trees in the sense that one should be able to ‘trace’ a
gene tree within the network. We say such a gene tree is displayed
in the network. This motivates a natural problem, which is called
‘the holy grail of reticulate evolution’ in (Nakhleh, 2009): given
a set of gene trees, reconstruct a reticulate network that displays
every given gene tree. Such an inferred network reveals important
correlation of evolutionary history of multiple genes. Since there
exists many such networks, a common formulation is to ﬁnd the
one with the fewest reticulation events. Such a network is called
the minimum reticulate network. The central computational problem
on reticulate networks, the minimum reticulate network problem, is:
given a set of gene trees, reconstruct the minimum reticulate network
that displays these gene trees. This formulation may be reasonable
when reticulation is believed to be rare.

In general, this problem is computationally challenging: even
the case with only two gene trees is known to be NP—complete
(Bordewich and Semple, 2004, 2007; Hein et al., 1996). There
are several existing approaches for reconstructing the exact
minimum reticulate networks when there are only two gene trees
(Bordewich et al., 2007; Linz and Semple, 2009; Wu, 2009; Wu
and Wang, 2010). Clearly restricting to just two gene trees is
a big limitation: more gene trees will be more informative to
phylogenetic inference, and DNA sequences of many genes are
available. Alternatively, there are also a number of approaches
making simpliﬁcations to the reticulate network model, e. g.
by imposing additional topological constraints on reticulate

 

© The Author(s) 2010. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non—Commercial License (http://creativecommons.org/licenses/
by—nc/2.5), which permits unrestricted non—commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.

112 /§JO'SIBUJn0[pJOJXO'SOIlBIHJOJUIOIQ/ﬁdnq 11101; prBOIUAAOG

9IOZ ‘Ig lsnﬁnv uo ::

Close lower and upper bounds for the minimum reticulate network

 

networks (Gusﬁeld, 2005; Huson and Klopper, 2007; Huson
et al., 2009; Nakhleh et al., 2005) or working with small—scale tree
topological features (Huson et al., 2005; Huson and Klopper, 2007,
van Iersel et al., 2008). Such simpliﬁcation often leads to
signiﬁcantly faster approaches. However, it is sometimes unclear
how biologically meaningful these added topological constraints
are. Even in the case where additional simpliﬁcations are reasonable,
one may still want to compare with the unconstrained minimum
reticulate networks.

Contributions: In this article, we present new approaches for the
minimum reticulate network problem with three or more gene trees
for unconstrained, general, reticulate networks (e. g. without needing
to assume that the network has some restricted form, such as being
a galled—tree or galled network). Thus our work is more general
than some previous approaches (Huson and Klopper, 2007; Huson
et al., 2005; Huson et al., 2009). In particular, we develop a lower
bound (the RH bound) and an upper bound (the SIT bound) for the
minimum reticulate network problem with multiple gene trees. We
show the correctness of the bounds. We give a closed—form formula
for the RH bound for the case of three gene trees. We also show
how to compute these bounds efﬁciently in practice using integer
linear programming (ILP). Practical results on simulated and real
biological data show that the bounds can be computed for wide
range of data. Moreover, the lower and upper bounds are often close,
especially when the number of trees is small or reticulation level is
relatively low. In fact, for many simulated datasets of this type, the
lower and upper bounds often match, which means our methods
can reconstruct the exact minimum reticulate networks for these
datasets. We also show the RH bound clearly outperforms a simple
bound.

2 DEFINITIONS AND BACKGROUND

Throughout this article, we assume trees are rooted. A phylogenetic
tree is rooted and leaf—labeled by a set of species (called taxa). A
leaf of a phylogenetic tree corresponds to an extant species. An
internal vertex corresponds to a speciation event. In—degrees of all
vertices (also called nodes), except the root, in a tree are one, while
out—degrees are zero for leaves and at least two for internal nodes. A
binary phylogenetic tree requires out—degrees of internal nodes to be
two. A non—binary phylogenetic tree contains nodes with out—degree
of three or more. Many existing phylogenetic methods assume
binary phylogenetic trees, although sometimes only non—binary trees
can be reconstructed in practice.

Our deﬁnition of reticulate networks is similar to that in (Huson,
2007; Huson et al., 2005; Semple, 2007) (Hallett and Lagergren,
2001; Nakhleh, 2009; Nakhleh et al., 2004). A reticulate network
(sometimes simply network) is a directed acyclic graph with vertex
set V and edge set E, where some nodes in V are labeled by taxa.
V can be partitioned into VT (called tree nodes) and VR (called
reticulation nodes). E can be partitioned into ET (called tree edges)
and ER (called reticulation edges). Moreover,

(1) No nodes with total (in and out) degree of two is allowed.
Except the root, each node must have at least one incoming
edge.

(2) VR contains nodes whose in—degrees are two or more. VT
contains nodes whose in—degrees are one.

123452314513245 32145

Fig. 1. An illustration of a reticulate network with three reticulation events
for three trees. Each tree is displayed in the network: the tree can be obtained
by keeping one incoming edge at each reticulation node.

(3) ER contains edges that go into some reticulation nodes. ET
contains edges that go into some tree nodes.

(4) A node is labeled by some taxon iff its out—degree is zero. This
helps to ensure labeled nodes correspond to extant species and
remove some redundancy in the network.

In addition, we have one more restriction:

R1 For a reticulate network N, when only one of the incoming
edges of each reticulation node is kept and the rest are deleted,
we always derive a tree T’.

We ﬁrst consider the derived tree T’ (that is embedded in N) as in
restriction R1. When we recursively remove non—labeled leaves and
contract edges to remove degree—two nodes of T’ (called cleanup),
we obtain a phylogenetic tree T (for the same set of species as in
N). Now suppose we are given a phylogenetic tree T. We say T is
displayed in N when we can obtain an induced tree T’ from N by
properly choosing a single edge to keep at each reticulation node so
that T’ is topologically equivalent to T after cleanup. We denote the
induced T’ (if exists) as TN. See Figure l for an illustration.

Note restriction R1 implies the network is acyclic. Biologically,
reticulate networks often forbid cycles. This is because many
reticulation events need to be properly time—ordered. Thus, we focus
on acyclic reticulate networks in this paper. That is, when we refer to
a reticulate network, we mean an acyclic reticulate network (unless
otherwise stated).

There are subtle issues related to networks with nodes whose
out—degrees are more than two (called non—binary nodes). See the
Supplementary Materials for more discussion. Note that we do not
require that in—degrees of reticulation nodes are precisely two as
what was imposed in (Huson et al., 2005). We also assume the root
of each input tree T) is attached to an outgroup species 0. The root
of a reticulate network for these trees is also attached to 0.

We deﬁne the reticulation number of a reticulation node as
its in—degree minus one. For a reticulate network N, we deﬁne
the reticulation number (denoted as R N) as the summation of
the reticulation number of each reticulation node in the network.
Sometimes R N is also called the number of reticulation events in
N. For the reticulate network in Figure l, the reticulation node 2
has three entering edges, and the other reticulation node 1 has two
entering edges. Thus, R N = (3 — l)—i—(2— l) = 3. Our deﬁnition of
reticulation number is similar to that of the hybridization number in
(Bordewich et al., 2007; Semple, 2007).

Suppose we are given a set of K gene trees T1,T2,...,TK (for
the same set of species). The minimum reticulate network Nmin for
T1 , T2, . . . , TK is a reticulate network/V that displays each Ti and R N
is minimized among all possible N. We call R Nmin the reticulation
number of T1,...,TK, which is denoted as R(T1,T2, ...,TK).

 

i141

112 /§.IO'SIBUJHOIPJOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 11101; prBOIUAAOG

9IOZ ‘Ig lsnﬁnv uo ::

KWu

 

For the special case of K :2, we call DTi,Tj =R(Ti, T1) the
reticulation distance between two trees Ti and  Now we formulate
the central problem in this article.

The general minimum reticulate network (GMRN) problem: Given a
set of phylogenetic trees T ={T1, ..., TK}, reconstruct the minimum
reticulate network Nmin for T1 , T2, ..., TK. This formulation is based
on parsimony, and may be justiﬁed when reticulation is relatively
rare in the evolutionary history.

One should note that the GMRN problem can be further speciﬁed
by the type of input trees. There are two types of input phylogenetic
trees: binary or non—binary. For a non—binary tree T, we say T is
displayed in N if some reﬁnement of T (i.e. splitting the non—binary
nodes in T in some way to make T binary) is displayed in N.
When input trees are binary, network reconstruction may be easier.
For simplicity, in this following, the input trees are assumed to be
binary, unless otherwise stated. We remark that some of our results
are applicable to non—binary input trees: the RH bound in Section 3
clearly works for non—binary trees too, and the high—level approach
of the SIT bound may also be applicable to non—binary trees.
Previous work on the GMRN problem: There is an exact method
for the K :2 case of the minimum reticulate network problem
(Bordewich et al., 2007), although this special case is known to
be NP—complete (Bordewich and Semple, 2007). It is useful to
note that when we allow cycles in the network, the minimum
reticulate network problem is equivalent to the rooted subtree prune
and regraft (rSPR) distance problem. The rSPR distance problem,
another NP—complete problem (B ordewich and Semple, 2004; Hein
et al., 1996), is well known to be closely related to reticulate
evolution. Previously, we showed that the rSPR distance can often
be practically computed for many moderately sized trees (Wu,
2009). We give more background to the rSPR distance problem
in the Supplementary Material. It was shown in (Baroni et al.,
2005) that the reticulation number (called hybridization number
in (Baroni et al., 2005)) for trees T1 and T2 is closely related to
the rSPR distance between T1 and T2, although the two values are
not always equal. The main difference between the rSPR distance
and the reticulation number is that the latter forbids cycles and
thus can be more realistic biologically. Recently, we have extended
our previous approach in (Wu, 2009) to allow computing the
pairwise reticulation distance between two rooted binary trees (Wu
and Wang, 2010). Although the worst case running time of the
practical methods in (Bordewich et al., 2007; Wu, 2009; Wu and
Wang, 2010) are exponential, these methods may work reasonably
well in practice. As shown in (Bordewich et al., 2007; Wu, 2009;
Wu and Wang, 2010), exact reticulation number (with or without
cycles) can be computed for two quite different trees with 20 or
more leaves. Thus, although intractable theoretically, the two—tree
minimum reticulate network problem can be solved in practice if the
size of two trees is moderate or the two trees are not very different
topologically.

It becomes more computationally challenging when there are
three or more gene trees. There is currently no known practical
methods for either computing the reticulation number R(T1, ...,TK)
or reconstructing Nmin for trees T1,...,TK when K :3. Often
approximation is made. A common approach is to impose structural
constraints to limit the complexity of the network (Gusﬁeld, 2005;
Huson and Klopper, 2007; Huson et al., 2009; Nakhleh et al.,
2005). Although these approaches are theoretically interesting and
have been shown to work for some biological data, it is still

very desirable to explore the reconstruction of reticulated networks
displaying multiple complete gene trees without additional structural
constraints.

3 A LOWER BOUND

We now focus on developing a lower bound on R(T1, ...,TK).
The lower bound helps to better quantify the range of
R(T1, ..., TK).

Recall that several exact methods (B ordewich et al., 2007; Wu and
Wang, 2010) exist for computing the pairwise reticulation distance
DTI.’ T}. for two trees Ti, Ti, which are practical for many pairs of trees
of moderate sizes. Now suppose that we compute DTi,Tj for each
pair of trees Ti and Ti, using the methods (Bordewich et al., 2007;
Wu and Wang, 2010). We store these pairwise distances in a matrix
D, where D[i, j] =DTi,TjZ. Admittingly, computing D[i, j] for all T,-
and  can be slow when K and/or the size of trees are large (unless
Ti and  are very similar). One should note that the GMRN problem
is much more complex, and thus, calculation of D[i , j] is justiﬁable
computationally. This leads to the following question: can we use
the pairwise reticulation distances D to estimate R(T1, ..., TK) when
K 3 3?

Clearly, the largest value D[i0,j0] in D is necessarily a lower
bound of R(T1, ...,TK) when K 2 3: a reticulate network displaying
all trees certainly also displays trees Tio and Tjo and thus is a
reticulate network for Tio and TJ-O. We now show a stronger lower
bound (called RH bound) based on D values.

Here is the high—level idea. The pairwise distance DTi,Tj speciﬁes
how similar trees Ti and  are: the larger DTi,Tj is, the more
different Ti and  are. Recall that if tree T) is displayed in a network
N, we should be able to derive T) by keeping only one incoming
edge at each reticulation node and performing cleanup. The choice
(called display choice for T,) of keeping which incoming edge at
each reticulation node for a tree Ti may not be unique. However,
clearly if one makes the same display choices for Ti and  when
displaying Ti and  in N, then T,- and  will be identical. More
generally, the more similar the display choices for trees Ti and Ti,
the closer Ti and  will be. Thus, to allow an N for trees with
pairwise distances D[i , j] =DTi,Tj, we need to make display choices
for the trees different enough: if the display choices for T) and  are
too similar, it will lead to contradiction when D[i , j] suggests Ti and
T,- are more different. In the following, a rigorous analysis based on
this idea allows us to decide whether an N with a speciﬁc number
(say r) of reticulation events is feasible.

To ﬁx ideas, we ﬁrst consider the situation where each reticulation
node in N has in—degree of two. We will remove this assumption
in a moment. Suppose that N has r reticulation nodes (each with
two incoming edges). For each reticulation node, we arbitrarily call
one incoming edge the left edge and the right edge for the other. We
encode the left edge as 0 and the right edge as 1, and call these two
edges 0—edge and 1—edge. Recall that to display a tree, we need to
keep exactly one of these two edges. Since a tree Ti is displayed in
N, we create a binary vector 12,-[1 . . . r] to represent which incoming
edge Ti is kept at each reticulation node  in N. Here, 12,-[1'] is 0

 

th is not known whether pairwise reticulation distance satisﬁes the triangle
inequality, although it clearly does when cycles are allowed. In practice,
pairwise reticulation distances often obey the triangle inequality: we have
not found a counter—example from many simulation datasets.

 

i142

112 /§.IO'SIBUJHOIPJOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 111011 pop1201um0q

9IOZ ‘Ig lsnﬁnv uo ::

Close lower and upper bounds for the minimum reticulate network

 

if T) keeps the 0—edge at reticulation node V-, and 1 if T) keeps the
1—edge at  We call v,- the display vector for T). For example, in
Figure 1, consider the reticulation node labeled as 1, and we assign
the left/right edges as shown. T1 and T3 keep the left edge at this
node, while T2 keeps the right edge. Thus, v1 and v3 have value 0,
and v2 has value 1 at the node.

For a given T,- and a network N, v,- can always be constructed (at
least conceptually) based on how Ti is displayed in N. Note that if
there are multiple choices to display T), we simply pick an arbitrary
one and this does not affect our solution. We deﬁne Dh[vi,vj] as the
Hamming distance between two display vectors v,- and vi. Here, v,-
and vi (and thus Dh[v,-, vj]) depend on N. To simplify notations, we
do not explicitly include N in their deﬁnitions. Lemma 3.1 is crucial
to our lower bound.

LEMMA 3.1. For any two trees T,- and  displayed in a reticulate
network N, Dh[vi,vj] ZD[i,j].

PROOF. For contradiction, assume Dh[v,-,vj] <D[i, j]. Thus Ti and
T]- make different choices at less than D[i , j] reticulation nodes
of N. Imagine we remove from N those incoming edges at
reticulation nodes that are not kept by both T) and  This produces
a network with less than D[i , j] reticulation nodes. This is because
all reticulation nodes where v,- and vi match (and thus Ti and  keep
the same incoming edges) have only one incoming edge and are no
longer reticulation nodes in the reduced network. This contradicts
the fact that D[i , j] is the reticulation distance between Ti and  I

Lemma 3.1 implies that if a network N with r reticulation events
exists, then we should be able to ﬁnd binary vectors v,- (of length r)
for each tree T), and Dh[vi,vj] 2D[i, j] for any two such vectors v,-
and vi. On the other hand, if such vectors do not exist, we know that
at least r—i—1 reticulation events are needed (and the value r—i—1 is
a lower bound on R(T1, ...,TK)). We can illustrate this formulation
more intuitively using a binary hypercube. On a hypercube with r
binary bits per node, we want to know whether we can pick K points
v1 ...vK that are far apart enough such that the Hamming distance
between v,- and vi is at least D[i , j] for each i and j. One should note
this is not always feasible due to the limited size of the hypercube.
Formally,

The binary hypercube point placement problem: Can we choose
K nodes v1, ...,vK from a r—dimensional binary hypercube so that
Dh[v,-,vj] 2D[i,j] for each pair of v,- and vi?

A lower bound on R(T1,...,TK) based on the Hypercube Point
Placement problem is to ﬁnd (possibly in a binary search style) the
smallest integer r such that the hypercube point placement problem
has a solution. Such r is necessarily a lower bound on R(T1, . . . , TK).
We call this lower bound reticulation on hypercube bound (or RH
bound)

We do not know a polynomial—time algorithm for the binary
hypercube point placement problem with more than three trees.
When K: 3, however, the RH bound has a simple analytical form
(see Section 3.2). To develop a practical method for the general case,
we use integer linear programming (ILP) to solve this problem. We
create a binary variable Vi,k to represent the coordinates for point
vi. That is, the coordinates of v,- on the hypercube are speciﬁed
by Vi,1...V,-,r. Without loss of generality, we set V1,k=0 for all
15k5r. We create a binary variable Mid-,k for each vi, vi and
position k (1 5 k 5 r) to indicate whether two vectors v,- and vi match

at position k. Mid-,k = 1 if Vi,k = k, and 0 otherwise. Now, we have
the following formulation.

Optimization goal: none (since this is a feasibility problem)
Subject to

1 Mi,j,k+Vi,k+Vj,k Z 1, for each vi, vj, where i<j and 15
k5r.

2 Mi,j,k — Vi,k — Vj,k 2 —1a for each Vi, VJ, Where i<j and
15k5n

3 Zl=1Mi,j,k E r—DliJ], for each vi, vj, where i<j.
For each 1 5 i 5 K and 1 5 k 5 r, there is a binary variable Vi, k.

For each 1 5 i < j 5 K, and 1 5 k 5 r, there is a binary variable
Mid-’1‘.

Constraint 1 says if both VLk and Vj,k are 0, Mid-,k is 1 (i.e.
matched). Similarly, constraint 2 says if both Vi,k and Vj,k are
1, Mid-,1C is 1 (i.e. matched). Constraint 3 imposes the pairwise
Hamming distance requirement. Our experience shows that the ILP
is practical to solve for all datasets we simulated (see Section 5).

3.1 Networks with in-degree of three or more

We now resolve the remaining issue where some reticulation nodes
have in—degree of three or more. In this section, we call a reticulation
node ‘reﬁned’ if its in—degree is two, and ‘unreﬁned’ if its in—degree
is at least three.

Here, we can no longer represent a reticulation node as binary
value, as done previously. So we extend our deﬁnitions of display
vectors v,- to allow v,- to be non—binary. That is, if there are d incoming
edges at a reticulation node, we allow v,- to be from 0 to d — 1, where
the value indicates which one of the d branches T) is kept at this
node. The incoming edges are numbered starting from zero on the
left and to the right with increment of one. We still let Dh[vi,vj]
be the Hamming distance between vectors v,- and vi. In this general
case, Lemma 3.1 still holds for non—binary vectors v,- and vi. To see
this, we prune any incoming edge at reticulation nodes if it is not
chosen by Ti and  Then each remaining reticulation node has only
two incoming edges (since we only have two trees). Thus, there are
D), [vi , vj] reticulation events in this reduced network, and the rest of
proof for Lemma 3.1 follows.

We now show that it is not necessary to consider unreﬁned
reticulation nodes in the sense that if a network N with unreﬁned
reticulation nodes satisﬁes pairwise distances D, then there exists
another network N ’ that has only reﬁned reticulation nodes
and gives the binary vectors v,- satisfying the pairwise distance
constraints of D. That is, if we can not ﬁnd a network with only
reﬁned reticulation nodes, we also can not ﬁnd a network with
unreﬁned reticulation nodes and the same reticulation number.

To see this property, we consider a network N with one
reticulation node a with d 2 3 incoming edges. Then we transform N
to N ’ by replacing a with ql , . . . , qd_1 , where each qi is a reticulation
node with in—degree of two. Note that we do not have to ensure N
and N ’ are equivalent: we only need to show N ’ gives a solution
to the Binary Hypercube Point Placement problem. Clearly, N and
N ’ have the same reticulation number (although vectors for N ’ are

 

i143

112 /§.IO'SIBUJHOIPJOJXO'SOIlBIIIJOJUIOIQ/ﬁdnq 111011 pop1201um0q

9IOZ ‘Ig lsnﬁnv uo ::

KWu

 

longer). Now, suppose tree T) keeps edge j at q (where 0 5 j 5 d — 1),
we then keep edge 1 at qj in N ’ if j Z 1 (and 0 if j = 0), and keep edge
0 for all other qj/ (where j’ 75 j). In other words, we create a mapping
of the display vectors vi from N to N ’ for each Ti. Note that such
mapping ensures that if two trees keep the same edge at q, they will
keep the same edges at q1 , ...,qd_1 in N’; otherwise, they will keep
at least one different incoming edge at q1, ...,qd_1 in N’. In either
case, if the pairwise distance constraints are satisﬁed in N, they are
also satisﬁed in N ’ . So, if we can not ﬁnd display vectors N ’ for
networks with reﬁned reticulation nodes only, we also can not ﬁnd
display vectors for networks allowing unreﬁned reticulation nodes.
In other words, the RH bound holds for networks with unreﬁned
nodes.

Remark. The RH lower bound is still applicable when the input
trees are non—binary, as long as the pairwise reticulation distances
are obtained for the non—binary trees. These are easy to verify and
we omit the details due to the lack of space.

Remark. A commonly used concept in reticulate networks is the
so—called maximum agreement forest (MAF). A brief description
on MAF is given in the Supplementary Material. Also see e.g. in
(Semple, 2007) for more details. It is easy to see that the size of a
MAF of multiple trees is a lower bound on R(T1, ...,TK). However,
experience show that the RH bound is often higher than the MAF
bound (see Section 5).

3.2 Special case of three trees

The special case of K :3 allows us to study the RH bound in an
analytical way. We let d1,d2 and d3 be the pairwise reticulation
distances of the three trees, where d12d22d3. Proposition 3.2
shows the RH bound for three trees in an analytical form.

PROPOSITION 3.2. The RH lower bound for three trees T1, T2
and T3 is equal to [W] if d2+d3>d1, and equal to
dlifdz-I-d3fd1.

PROOF. We ﬁrst consider the case d2—i—d3 >d1. Clearly, the RH
bound is at least d1, which is the minimum size of the hypercube.
Now we investigate whether there exists a reticulate network with
d1 —i—e reticulation nodes for these three trees. Without loss of
generality, let T1 be the input tree where d1 =DT1,T2 and d2 =
DT1,T3, and the display vector v1 (for T1) is ﬁxed to be all—0. Then,
the display vector v2 for T2 must have at least d1 positions with value
1 (and thus v2 has no more than e positions with value 0). Similarly,
the display vector V3 must have at least d2 positions with value 1
(and thus V3 has no more than d1 —i—e—d2 positions with value 0).
Note that Dh[V2,V3] Zd3. We claim that Dh[V2,V3]§d1+Ze—d2.
This is because the Hamming distance between v2 and V3 counts
the positions where v2 has value 0 and V3 has value 1 (or vice
versa). Since the number of OS in v2 is no more than e, there are
at most e positions where v2 has 0 and V3 has 1. Similarly, there
are at most d1—i—e—d2 positions where v2 has 1 and V3 has 0.
Thus, Dh[v2,V3]5e—l—d1—l—e—d22d1—l—2e—d2. Also note that we
can always construct v2 and V3 so that Dh[v2, V3] 2 d1 —i—2e —d2. See
Figure 2 for an illustration.

Therefore, if d1 —i— 2e — d2 < d3, we can not ﬁnd three vectors v1 ,v2
and V3 satisfying the pairwise distances D and thus R(T1 , T2, T3) 3
d1 —i—e—i—1 in this case. The largest such e is equal to [M]

(which is non—negative since d2—i—d3 > d1). The RH bound is then
d1+LWJ+1= [W].

1.939 d:j
dl—H 2

EIDCIDCIDEI-Dﬂ ___________________________ _ .ElEIEICIDEIID

 

 

11lllllm“nulllllﬂﬂﬂﬂmuﬂﬂﬂﬂﬂﬂﬂ

 

 

 

Dﬂﬂmunnﬂﬂﬂﬂlllllll ....... "1111111

 

Fig. 2. Vectors V1, V2 and V3 (listed from top to bottom) that maximize the
Hamming distance between V2 and V3. V1 is all—0, while the sufﬁx of V2 and
preﬁx of V3 are zeros.

The case when d2—i—d3 5d1 is simple. We create three vectors
of d1 bits: v1 is an all—0 vector, v2 is an all—1 vector and V3
contains d2 1s. It is easy to verify these three vectors satisfy all
three pairwise distance constraints. I

In practice, it is very likely d2 —i—d3 > d1. In this case,
[W] > d1, where d1 is a trivial lower bound.

4 AN UPPER BOUND

We now present an upper bound on R(T1, ..., TK). The combination
of the RH lower bound and the upper bound quantiﬁes the range of
R(T1, ...,TK). In the best scenario, if the upper bound matches the
RH bound, these bounds would actually determine the exact value
of R(T1, ..., TK) (and also reconstruct Nmin). On the high level, the
upper bound performs stepwise insertion of trees into a reticulate
network (and thus is called the SIT bound). The SIT bound is very
accurate and also computable in practice for many datasets.

The basic idea of the SIT bound is to reconstruct a reticulate
network N in a step—by—step way: ‘insert’ the given gene trees one
by one into N in some ﬁxed order. When we say a tree T is inserted
into N, we mean adding reticulation edges into N such that T is
displayed in the updated network N ’ . Note that addition of new
reticulation edges increases R N. Thus, every time we insert a new
tree, we seek to add as few new reticulation edges as possible by
reusing existing reticulation edges. At the same time, we also ensure
no cycles exists in N’. Often, it is unclear which order of inserting
trees gives the best result. For now, we assume that K is relatively
small so that we can enumerate all possible orders of insertion to ﬁnd
the best result. See Section 4.2 for ways to handle larger K. Thus, we
can assume the order of tree insertion is ﬁxed to T1,T2, ...,TK. The
general procedure of the SIT bound (for a ﬁxed order) is as follows.

1. Initialize N to be T1.
2. for i = 2 to K

3. Insert T,- into N by adding the smallest number of new
reticulation edges.

Note that we only add reticulation edges in N and do not delete
any existing edges. Thus, any tree already displayed in N is still
displayed in the updated N ’ by choosing the original reticulation
edges when the tree is ﬁrst inserted for their display vectors in N ’ .
This ensures that each of the input trees is displayed in the ﬁnal N.
Obviously, step 3 is most critical, which we will discuss next.

4.1 Inserting tree T into N

We consider the ’min—cost tree insertion problem’, where we want to
update N by adding the fewest reticulation edges to N so that a given

 

i144

112 /§.IO'SIBUJHOIPJOJXO'SOllBIIIJOJUIOIQ/ﬁdnq 111011 pop1201um0q

9IOZ ‘Ig lsnﬁnv uo ::

Close lower and upper bounds for the minimum reticulate network

 

(E) (b)
A

325115 2136

Insert a tree [left] into if Updated N

Fig. 3. Inserting a tree (left) to a network (middle). After adding new
reticulation edges (thick lines), the resulting network (right) displays the
tree.

tree T is displayed in the updated N ’ , and N’ remains acyclic. Note
that the min—cost tree insertion problem is NP—complete because
it contains the two—tree minimum reticulate network problem (an
NP—complete problem) as a sub—problem. That is, constructing the
minimum reticulate network for trees T1 and T2 can be solved
by inserting T2 into T1 with the minimum cost. In the following,
we develop a practical method to solve the min—cost tree insertion
problem. Each node of the reconstructed network here has one or
two incoming edges (except the root), and one or two outgoing edges
(except the leaves).

After inserting T (and some new reticulation edges are added), T
is displayed in the updated network N’. Suppose we remove all the
new reticulation edges in N ’ . The edge removals break tree T(N’)
(the tree created by keeping edges in N ’ according to a display
vector of T) into a forest F (T(N ’ )). Thus, the number of newly
added reticulation edges is exactly the number of trees in F (T(N ’ ))
minus one. To minimize the number of needed new reticulation
events, we need to minimize the number of trees in F (T(N ’ )). A
useful observation is that the problem of ﬁnding F (T(N ’ )) with the
fewest subtrees is closely related to the maximum agreement forest
problem (see the Supplementary Material) as follows.

Imagine that we choose a tree T’ that is displayed in N so that the
display vector of T’ agrees with that of T for N ’ at each reticulation
node of N. Recall that N ’ may contain a number of new reticulation
nodes that are not in N. Also note T’ is not necessarily one of the
input trees T). We claim that F (T(N ’ )) is an agreement forest for T
and T’ . To see this, we note that the display choices made by T’ are
identical to T except those at the new reticulation nodes (where T’
follows the original edge and T(N’) follows the new edge). So the
subtrees in F (T(N ’ )) must also be subtrees of T’. So, we have:

LEMMA 4.1. The forest induced by removing newly added
reticulation edges of T(N’) is an agreement forest between T and
some tree T’ that is displayed in the original N.

Lemma 4.1 implies that to ﬁnd the best tree insertion, we can ﬁnd
some tree T’ displayed in N s.t. the number of trees in the maximum
agreement forest between T and T’ is minimized. Figure 3 shows an
example of tree insertion. The dashed lines in the tree (left) divide
the tree into a forest, which also appears in the existing network
(middle, thick lines). Inserting the tree into the network is to add
new reticulation edges (right, thick lines) into the networks so that
the subtrees in the forests are properly connected to match the given
tree.

When the number of reticulation nodes in N is small, we may
simply enumerate all trees T’ displayed in N and then ﬁnd which T’
gives the smallest agreement forest with T. This quickly becomes

“I X“ 
A - A

Between reticulatiun under;

{a} /( ii
if  ‘u'
r 

q

  

Between tree netles

Fig. 4. Attaching a subtree in N. Left: insert a reticulation edge between two
tree nodes r and V. Right: insert a reticulation edge between two reticulation
nodes r and V. The dashed lines are the newly added edges.

infeasible as the number of reticulation nodes in N grows: when
there are r reticulation nodes in N, there may exist 2r trees T’
displayed in N. To develop a practical method, we develop an
integer linear programming (ILP) formulation to solve the tree
insertion problem in an optimal way (without explicit enumeration).
The output of the ILP formulation includes the display choices of T’
as well as the associated agreement forest formed by cutting edges
in T. See the Supplementary Material for detailed description of the
formulation.

Updating N: after tree T’ and the associated agreement forest are
found, we update N as follows. We add new reticulation edges in N
to connect subtrees of T’ in the found agreement forest to make T
displayed in the updated network N ’ . First, we determine the order
of subtree connection with an approach similar to the algorithm
building two—tree hybridization networks in (Semple, 2007). The
subtree with the special outgroup taxon 0 acts as the base. Then we
repeatedly pick the subtree not intersecting any already connected
subtree as the next to connect. Now, for each tree connection:

(1) Find the root r of the next subtree (in N) to attach.

(2) Find the node v in the existing network as the attaching point
to accept this subtree.

(3) Create a new reticulation node in N to connect the subtree.

This operation depends on the types of r and v. Two cases are
shown in Figure 4. The other cases are similar. In all the cases, only
a single new reticulation edge is created to connect a subtree.
Cycles: a remaining issue is that cycles can be introduced when
connecting subtrees in N. There are two sources of cycles. First, the
found agreement forest may induce cycles (see (B aroni et al., 2005)).
Enhancing the ILP formulation to avoid cycles may signiﬁcantly
complicate the formulation and slow the ILP solving. A practical
observation is that cycles in an agreement forest are often caused by
two pairs of leaves a, b and c, d so that the a/b pair is ancestral to old
pair in T and the old pair is ancestral to a/b pair in T’ . Here, we say
a pair of leaves a and b is ancestral to a pair of leaves 0 and d if the
the MRCA of a and b is ancestral to the MRCA of c and d. MRCA
stands for the most recent common ancestor, and node a is ancestral
to node b in tree T if a is on the path from b to the root of T. To
forbid this type of simple cycles, we enhance the ILP formulation:
for such pairs a/b and old, we require either a and b are not in the
same subtree, or c and d are not in the same subtree of the resulting
forest. Although this does not guarantee to remove all cycles, we
found that cycles in the agreement forest are rare after this change.
This observation is also useful for the method of computing pairwise
reticulation distances in (Wu and Wang, 2010).

Second, cycles can appear in other parts of the network when
subtrees in the agreement forest are connected. In practice, however,

 

i145

112 /§.IO'SIBUJHOIPJOJXO'SOllBIIIJOJUIOIQ/ﬁdnq 111011 pop1201um0q

9IOZ ‘Ig lsnﬁnv uo ::

KWu

 

we ﬁnd this happens relatively rare. When this type of cycles does
occur, we simply start over and try another order of tree insertion.
This works well in practice: in Section 5, we build acyclic networks
successfully for all (thousands of) simulated datasets.

4.2 Handling larger datasets

When the size and the number of trees grow, the running time
increases. To handle larger datasets, we make several simpliﬁcations.
(i) Instead of enumerating all possible orders of tree insertion, we
start with an arbitrary tree. At each step, we pick a tree with the
smallest reticulation distance to one of the already inserted trees. (ii)
Solving the min—cost tree insertion problem optimally becomes more
difﬁcult when data grows. So instead of considering all possible
T’ displayed in N when inserting T, we randomly choose a ﬁxed
number (say 10) of trees T’ displayed in N (in addition to all the
inserted gene trees) and ﬁnd the best way of inserting T based on one
of the chosen T’. This heuristic is called the coarse mode (and the
original approach is called the full mode). Our experience shows that
the coarse mode works reasonably well in practice (see Section 5).

5 EXPERIMENTAL RESULTS

We have implemented a software tool called PIRN (which stands for
Parsimonious Inference of Reticulate Network) to compute the RH
and SIT bounds. Program PIRN is available for download from:
http://www.engr.uconn.edu/”ywu/. The tool is written in C++ and
uses either CPLEX (a commercial ILP solver) or GNU GLPK ILP
solver (mainly a demo of the functionalities for users without a
CPLEX license). In computing the SIT bound, PIRN can run full
mode (slower but can give better results) or coarse mode (faster but
less accurate). We test our methods for both simulated and biological
data on a 3192 MHz Intel Xeon workstation.

5.1 Simulation data

We generate simulation data using a two—stage approach: ﬁrst
simulate reticulate networks, and then generate a ﬁxed number of
trees displayed in the networks according to randomly generated
display vectors. We simulate reticulate networks using a scheme
similar to the coalescent simulation implemented in program ms
(Hudson, 2002). For a given number of taxa (denoted as n), we
start with n isolated lineages and simulate reticulation backwards
in time. At each step, there are two possible events: (i) lineage
merging, which occurs at rate 1; (ii) lineage splitting, which occurs
at rate r. We choose the next event according to relative probabilities
of all feasible events. Lineage merging generates speciation events,
while lineage splitting generates reticulation events. To speedup the
simulation, lineage splitting is disabled when the number of current
lineages is no more than three. The parameter r dictates the level
of reticulation in the simulated network: larger r will lead to more
reticulation events in simulation.

Full mode of the SIT bound: to test the performance of the bounds,
we generate data with varying number of trees K, number of
taxa n and level of reticulation r. For each settings of these three
parameters, we simulate 100 datasets. We report the percentage of
datasets where optimal solution is found (i.e. lower bound matches
upper bound) in Figure 5a. To show how close the lower and upper
bounds are, we report the average gap (the difference between
the upper and the lower bounds, divided by the lower bound)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

(a)
100 v + 100 100
</' ,5 _ _ =3 0 —e—K=3 K=3
“MI-ﬂ?” ~a_-—" I r I a K 4 1:5.0
I" v - v - v — v — rim-mo 80 - - = <
80 o 3 \3 80
)
H
60 0" r=l 0 60 60
O ‘ II.~
O \
40 D K=3 40m, ‘11. ~ 40
-E-K=4 TN,‘ ~~|:| I
20 ‘-¢-‘K=5 20 ’s,‘ 20‘ I.
N L
v \0 ‘n

 

 

 

 

 

 

 

 

 

 

o
010 20 30 40 50 10 20 30 40 50 010 20 30 40 50

% Optimal solutions found among100 datasets

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

35
35 K=3 I'=3.0 K=3 35 o 1:50
30 r=1.0 _5_K=4  _E_K=4  fl! K=3
25 "¢“K=5  ”,¢ '9-K=5  or In- _E_K=4
6’ ---n
T’ ” ‘+‘K=5
20 £4 20 «a 20 H’
15 (D ISn-—-—I3"T—u 
10 10 10
.1 1"”:1». 5 ,/°—°—°\. N
5.r‘_..—ﬁ~~~a___ 1_-_1—_1; < , 5‘
A A; 0

 

 

0 0
10 20 30 40 50 10 20 30 40 50 10 20 30 40 50

Normalized gap between the two bounds (in%)

 

 

 

 

 

 

 

 

 

(c)
12
r=l.
10 0
.0 +K=3
8 g -E- :4
O ._ . _
6 m 9-K—5
I
Dd
2 -E-K=4 2 -E-K:4
'9-K=5 1-9-1K=5

 

 

 

 

 

 

 

 

 

 

 

 

 

 

0
01o 20 30 40 50 10 20 30 40 50 10 20 30 40 50
n:numoftaxa

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Average RH bounds
3500 3500 3500
r=1.0 r=3.0 r=5.0
3000 _
K=3 3000 +K_: lg 3000 IF +K=3
- E - =
2500 _ a _K=4 2500 K I 2500 9 I — a —K=4
a '9'K=5 ' I I ._¢_.K_5
2000 v "°"K=5 2000 , 2000 i 1' _
O I l’ I
1500  1500 I 1500 '3 ’
F I, II:I ‘I’ ’I
1000 1000 , / 1000 .’ l
I ’I .I I
500 500 ' , 500 -’ '
«0 '9’ -' '
0 e  G “a. M 0 
10 20 30 40 50 10 20 30 40 50 10 20 3o 40 50

 

 

 

 

 

 

Average running time (in seconds)

Fig. 5. Performance of the RH bound and SIT bound (full mode), for 10,
20, 30, 40 and 50 taxa, number of trees K from 3 to 5, and reticulation level
r at 1.0, 3,0 and 5.0. (a). The percentage of exact reticulation number found
among 100 simulated datasets. (b) Average gaps (in percentage) between the
SIT bound and RH bound (normalized by the RH bound), and the average
RH bound is shown in (c). (d) The average running time (in seconds). The
reticulation level r for left, middle and right ﬁgures is 1.0, 3.0 and 5.0,
respectively. Horizontal axis is the number of taxa, and each curve in a
ﬁgure is for a value of K.

in Figure 5b. We also report the average lower bound in Figure 50,
which somewhat reﬂects how complex the simulated networks are.
We also give the average running time for each setting in Figure 5d.
For ﬁve larger datasets, there are a small number of test cases
that are too slow to run the full mode, and are excluded. The
percentage of unﬁnished computation is usually one or two out
of 100 datasets, except the cases with n=30/r=3.0/K =5 (18%
unﬁnished) and n: 30/r =5.0/K =4 (6% unﬁnished). This suggests
the current practical range of the full mode of the SIT bound.

 

i146

112 /§.IO'SIBUJHOIPJOJXO'SOllBIIIJOJUIOIQ/ﬁdnq 111011 pop1201um0q

9IOZ ‘Ig lsnﬁnv uo ::

Close lower and upper bounds for the minimum reticulate network

 

 

 

 

 

 

 

 

 

 

 

 

 

50‘ a Time(C) 100 l— A
_ _ w _

401} —a—Time(F) 803 8.5 “E’ varyjng K

\ - o - %OPT(C) 1 5° i: +Tfme(F)

\ + %OPT(F) \ ' E 'T'me(C)
30 \ V 60 “ + %OPT(F)
‘ K=4’ r=3-0 \ - o - %OPT(C)

A 40 “
‘ /Il

:»:u 20 b‘ g l/

v m r '

0 - - - "9' ‘ 1'" 1'." —

 

 

4050 3456789
K

Fig. 6. Comparing the coarse (C) mode and the full (F) mode of the SIT
bound. Left: ﬁx r: 3.0 and K =4, while varying n. Right: ﬁx r = 5.0 and
n = 10 and vary K. Both percentages of optimal solutions found and running
time (in minutes for the left ﬁgure and seconds for the right one) are shown.

As shown in Figure 5a, PIRN performs very well when the number
of trees K = 3 or reticulation level r is small: optimal solution can be
found for at least 80% of simulated datasets when r = 1.0 and K = 5.
Even with higher reticulation level (r = 3.0) and larger number of
taxa (say 50), still about 60% of datasets can be solved exactly
when K :3. As expected, as the number of taxa, reticulation level
and the number of trees grow, fewer datasets can be solved to exact,
and correspondingly, Figure 5b shows gaps between the RH and
SIT bounds increase. Figure 50 shows the complexity of networks
increases too. Nevertheless, the gaps are still relatively small in
these cases. For the more difﬁcult settings simulated (i.e. 30 taxa,
high reticulation level and ﬁve trees as input), the gap is about 25%.
Running time depends on the complexity of the networks. Figure 5d
shows that PIRN is practical for data of medium size.

Coarse mode of the SIT bound: we also test the coarse mode of
our methods for larger data, as described in Section 4.2. The results
are shown in Figure 6. The ﬁgure on the left shows the effects (on
accuracy and running time) of increasing the number of taxa n.
The ﬁgure on the right shows the effects of having more trees (i.e.
increasing K from three to nine) for 10 taxa and reticulation level
5.0. There is clear trade—off between the accuracy of solutions and
efﬁciency. The coarse mode under—performs in terms of the quality of
solutions, but is more scalable, especially when K increases. When
the number of taxa increases, the coarse mode is likely to run faster
than the full mode, but the difference is less signiﬁcant.

GLPK: the CPLEX solver is used in the simulation. The GLPK
version in general is less robust and can handle smaller data than
the CPLEX version. Our experience shows that the GLPK solver
can often solve for ﬁve trees with 30 taxa when reticulation level is
low and fewer number of taxa when reticulation level is higher.
The RH bound: we now compare the performance of the RH bound
with the MAF bound. We note that the MAF bound is not easy to
compute: ﬁnding the MAF of only two trees is known to be NP—
hard. When data is small, the MAF bound can be computed (e.g.
using ILP similar to that in (Wu, 2009)). In Table 1, we compare the
RH bound and the MAF bound for 100 datasets. Each data has 10
or 20 taxa and contain three to seven correlated trees. The trees are
selected from the local trees for recombining sequences generated
by a coalescent simulator, program ms (Hudson, 2002).

Table 1 shows that the RH bound outperforms the MAF bound
in a majority of the simulated datasets and only very rarely the RH
bound is lower than the MAF bound. In general, as the number of

Table 1. Compare the RH and MAF bounds for K trees

 

 

K23 K24 K25 K26 K27
n=10 RH > MAF 46 56 61 58 72
RH = MAF 54 44 38 41 27
RH < MAF 0 0 1 1 1

100 (RH—MAF/MAF) 16.5 18.4 17.2 18.0 20.9

 

n=20 RH > MAF 65 66 68 70 —
RH = MAF 34 34 30 30 —
RH < MAF 1 0 2 0 —

100 (RH—MAF/MAF) 12.6 11.9 12.1 12.8 —

 

RH > MAF: number of datasets where the RH bound is larger than the MAF bound
among 100 datasets. The average gaps (in percentage) between the RH and MAF bounds
are also shown.

Table 2. Results for the grass data

 

 

Trees n D RH SIT Time
rpoC2, waxy, ITS 10 1, 6, 6 7 7 1 s
nth, phyB, rbcL 21 4, 5, 6 8 8 1 s

nth, phyB, rbcL,rp0C2, ITS 14 I I I 3 26 min 38 s

 

Both RH and SIT bounds are shown, as well as the running time . n: the number of
taxa. D: pairwise distances.

trees increases, the RH bound tends to outperform the MAF bound
in both accuracy and running time. For example, for a dataset with
20 sequences and six input trees, CPLEX runs for over 11 h without
reporting a solution (it found a solution of 11, but did not validate its
optimality). In contrast, it only takes less than 1 minute to compute
the RH bound of value 12 (higher than the MAF result).

5.2 Biological data

To evaluate how well our bounds work for real biological data, we
test our methods on a Poaceae dataset. The dataset was originally
from the Grass Phylogeny Working Group (Grass Phylogeny
Working Group, 2001). The dataset contains sequences for six
loci: internal transcribed spacer of ribosomal DNA (ITS); NADH
dehydrogenase, subunit F (nth); phytochrome B (phyB); ribulose
1,5—biphosphate carboxylase/oxygenase, large subunit (rbcL); RNA
polymerase II, subunit ,8” (rpoC2); and granule bound starch
synthase I (waxy). The Poaceae dataset was previously analyzed
and rooted binary trees were inferred for these loci (Schmidt, 2003).
Pairwise comparison were performed in (Bordewich et al., 2007;
Wu and Wang, 2010). Here, we provide in Table 2 our results on
estimating the reticulation number using multiple (three to ﬁve)
trees. Only shared taxa of a set of trees are kept. Thus, the pairwise
distances reported here are different from those in (Bordewich
et al., 2007; Wu, 2009). As shown in Table 2, PIRN ﬁnds optimal
solutions for both datasets with three trees, and computes lower and
upper bounds that are close for the dataset with ﬁve trees. Figure 7
shows the reconstructed reticulate network for these ﬁve trees. See
Supplementary Material for a graphical display of the ﬁve grass
trees. The network contains 13 reticulation events, and the lower
bound is 11. Although the network may not be optimal, the gap
between the lower and upper bounds is relatively small.

 

i147

112 /§JO'S{BUJn0IpJOJXO'SOIlBIHJOJUlOIQ/ﬁdnq 111011 pop1201um0q

9IOZ ‘Ig lsnﬁnv uo ::

KWu

 

 

Fig. 7. A reticulate network found by program PIRN for ﬁve trees of a grass
dataset. Red (shaded) balls represent reticulation nodes.

Remark: the following lists several aspects on the performance of
PIRN. (i) Simulation shows that PIRN is often able to ﬁnd the exact
reticulation number when K or r is small, even when the number
of taxa increases to medium size (say 50). Moreover, PIRN can
compute the RH and SIT bounds for a wide range of data, despite
the fact that we do not currently have polynomial—time algorithms
for computing the bounds. We achieve this with the help of integer
linear programming. (ii) Computing the RH bound is often much
faster and more scalable than the SIT bound. Experience shows that
the ILP formulation for computing the RH bound is often very fast
to solve and computing the pairwise reticulation distances usually
takes less time than ﬁnding a good upper bound for all trees. The RH
bound computation will also beneﬁt from future improvements in
computing the pairwise reticulate distances. The simulation results
in this section are based on an earlier version of the method in
(Wu and Wang, 2010) and speedup may be possible with the latest
methods. (iii) The number of trees K and the similarity of tree
topologies have impact on PIRN ’s optimality and running time.
Using more powerful ILP solver (e. g. CPLEX) and/or more powerful
machines may also help for more difﬁcult cases. (iv) Finally, our
general approaches can be applied to larger data by using efﬁcient
computable lower bounds of pairwise rSPR distances in computing
the RH bound, and faster but less accurate heuristics to insert trees
into a network.

ACKNOWLEDGEMENT

I thank Simone Linz for useful discussions and for sharing the grass
tree dataset.

Funding: US. National Science Foundation (IIS—0803440) and the
Research Foundation of University of Connecticut.

Conﬂict of Interest: none declared.

REFERENCES

Baroni,M. et al. (2005) Bounding the number of hybridisation events for a consistent
evolutionary history. J. Math. Biol, 51, 171—182.

Baroni,M. et al. (2004) A framework for representing reticulate evolution. Ann. Comb,
8, 391—408.

B0rdewich,M. et al. (2007) A reduction algorithm for computing the hybridization
number of two trees. Evol. Bioinform, 3, 86—98.

B0rdewich,M. and Semple,C. (2004) On the computational complexity of the rooted
subtree prune and regraft distance. Ann. Comb, 8, 4094123.

B0rdewich,M. and Semple,C. (2007) Computing the minimum number of hybridization
events for a consistent evolutionary history. Dis. Appl. Math, 155, 914—928.

Grass Phylogeny Working Group (2001) Phylogeny and subfamilial classiﬁcation of
the grasses (poaceae). Ann. Mo. Bot. Gard, 88, 373—457.

Gusﬁeld,D. (2005) Optimal, efﬁcient reconstruction of Root-Unknown phylogenetic
networks with constrained and structured recombination. J. Comput. Syst, Sci, 70.
381—398.

Hallett,M. and Lagergren,]. (2001) Efﬁcient algorithms for lateral gene transfer
problems. In Proceedings of Fifth Annual Conference on Research in Computational
Molecular Biology (RECOMB 2001), ACM, New York, NY, USA, pp. 149—156.

Hein,J. et al. (1996) On the complexity of comparing evolutionary trees. Dis. Appl.
Math, 71, 153—169.

Hudson,R. (2002) Generating samples under the Wright-Fisher neutral model of genetic
variation. Bioinformatics, 18, 337—338.

Huson,D. (2007) Split networks and reticulate networks. In Gascuel,O. and
Steel,M. (eds), Reconstructing Evolution: New Mathematical and Computational
Advances. Oxford University Press, Oxford, UK, pp. 247—276.

Huson,D. and Bryant,D. (2006) Application of phylogenetic networks in evolutionary
studies. Mol. Biol. Evol., 23, 254—267.

Huson,D. and Klopper,T. (2007) Beyond galled trees - decomposition and computation
of galled networks. In Speed,T. and Huang,H. (eds), Proceeding of RECOMB 2007:
The 11th Annual International Conference Research in Computational Molecular
Biology. Vol. 4453 Of LNBI, Springer, Berlin / Heidelberg, pp. 211—225.

Huson,D. et al. (2005) Reconstruction of reticulate networks from gene trees. In
Proceeding of RECOMB 2005: The 9th Annual International Conference Research
in Computational Molecular Biology. Vol. 3500 Of LNBI, Springer, Berlin /
Heidelberg, pp. 233—249.

Huson,D. et al. (2009) Computing galled networks from real data. Bioinformatics, 25,
i85—i93.

Linz,S. and Semple,C. (2009) Hybridization in nonbinary trees. IEEE/ACM Trans.
Comput. Biol. Bioinform, 6, 30—45

N akhleh,L. (2009) Evolutionary phylogenetic networks: models and issues. In Heath,L.
and Ramakrishnan,N. (eds), The Problem Solving Handbook for Computational
Biology and Bioinformatics. Springer, New York Inc, New York, USA.

Nakhleh,L. et al. (2004) Reconstructing reticulate evolution in species - theory and
practice. In Proceeding of 8th Annual International Conference on Computational
Molecular Biology, Springer, Berlin / Heidelberg, pp. 337—346.

Nakhleh,L. et al. (2005) Reconstructing reticulate evolution in species - theory and
practice. J. Comp. Biol, 12, 796—811.

Schmidt,H. (2003) Phylogenetic trees from large datasets. PhD Thesis, Heinrich-Heine-
Universitat, Dusseldorf.

Semple,C. (2007) Hybridization networks. In Gascuel,O. and Steel,M. (eds),
Reconstructing Evolution: New Mathematical and Computational Advances.
Oxford University Press, Oxford, pp. 277—309.

van Iersel,L. et al. (2008) Constructing level-2 phylogenetic networks from triplets. In
Vingron,M. and W0ng,L. (eds), Proceeding of RECOMB 2008: The 12th Annual
International Conference Research in Computational Molecular Biology. Vol. 4955
of LNBI, Springer, Berlin / Heidelberg, pp. 450—462.

Wu,Y. (2009) A practical method for exact computation of subtree prune and regraft
distance. Bioinformatics, 25, 190—196.

Wu,Y. and Wang,J. (2010) Fast Computation of the exact hybridization number of
two phylogenetic trees. In B0r0d0vsky,M. et al. (eds) Proceeding of ISBRA 2010:
The 6th International Symposium on Bioinformatics Research and Applications,
Vol. 6053 of Lecture Notes in Bioinformatics, Springer, Berlin / Heidelberg,
pp. 203—214.

 

i148

112 /B.IO'SIBUJHOIPJOJXO'SOllBIHJOJUlOlCI/ﬁdnq 111011 pop1201um0q

9IOZ ‘Ig lsnﬁnv uo ::

