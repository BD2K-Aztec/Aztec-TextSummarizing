Vol. 30 E008 2014, pages i519—i526
doi: 10. 1 093/bioinformatics/btu4 63

 

Polytomy refinement for the correction of dubious

duplications in gene trees

Manuel Lafond”, Cedric Chauve2’3, Riccardo Dondi4 and Nadia EI-Mabrouk1 ’*

1Department of Computer Science, Université de Montreal, Montreal, Quebec H3C 3J7, Canada, 2LaBRI, Université
Bordeaux 1, Bordeaux, France, 3Department of Mathematics, Simon Fraser University, Burnaby (BC) V5A 1S6, Canada
and 4Universita degli Studi di Bergamo, Bergamo 24129 IT, Italy

 

ABSTRACT

Motivation: Large-scale methods for inferring gene trees are error-
prone. Correcting gene trees for weakly supported features often re-
sults in non-binary trees, i.e. trees with polytomies, thus raising the
natural question of refining such polytomies into binary trees. Afeature
pointing toward potential errors in gene trees are duplications that are
not supported by the presence of multiple gene copies.

Results: We introduce the problem of refining polytomies in a gene
tree while minimizing the number of created non-apparent duplications
in the resulting tree. We show that this problem can be described as a
graph-theoretical optimization problem. We provide a bounded heur-
istic with guaranteed optimality for well-characterized instances. We
apply our algorithm to a set of ray-finned fish gene trees from the
Ensembl database to illustrate its ability to correct dubious
duplications.

Availability and implementation: The C++ source code for the al-
gorithms and simulations described in the article are available at
http://www-ens.iro.umontreal.ca/~lafonman/software.php.

Contact: lafonman@iro.umontreal.ca or mabrouk@iro.umontreal.ca
Supplementary information: Supplementary data are available at
Bioinformatics online.

1 INTRODUCTION

With the increasing number of completely sequenced genomes,
the task of identifying gene counterparts in different organisms
becomes more and more important. This is usually done by clus-
tering genes sharing signiﬁcant sequence similarity, constructing
gene trees and then inferring macro-evolutionary events such as
duplications, losses or transfers through reconciliation with the
phylogenetic tree of the considered taxa. The inference of accur-
ate gene trees is an important step in this pipeline. While gene
trees are traditionally constructed solely from sequence align-
ments (Guidon and Gascuel, 2003; Ronquist and Huelsenbeck,
2003; Saitou and Nei, 1987), recent methods incorporate infor-
mation from species phylogenies, gene order and other genomic
footprint (Akerborg et al., 2009;Boussau et al., 2013; Durand
et al., 2003; Rasmussen and Kellis, 2011; Szollosi et al., 2013;
Thomas, 2010; Wapinski et al., 2007). A large number of gene
tree databases are now available (Datta et al., 2009;Flicek, 2012;
Huerta-Cepas et al., 2011; Mi et al., 2012; Schreiber et al., 2013).

But constructing accurate gene trees is still challenging; for
example, a signiﬁcant number of nodes in the Ensembl gene
trees are labelled as ‘dubious’ (Flicek, 2012). In a recent study,
we have been able to show that ~30% of 6241 Ensembl gene

 

*To whom correspondence should be addressed.

trees for the genomes of the ﬁshes Stickleback, Medaka,
Tetraodon and Zebraﬁsh exhibit at least one gene order incon-
sistency and thus are likely to be erroneous (Lafond et al., 2013).
Moreover, owing to various reasons such as insufﬁcient differ-
entiation between gene sequences and alignment ambiguities, it is
often difﬁcult to support a single gene tree topology with high
conﬁdence. Several support measures, such as bootstrap values
or Bayesian posterior probabilities, have been proposed to detect
weakly supported edges. Recently, intense efforts have been put
towards developing tools for gene tree correction (Berglund-
Sonnhammer et al., 2006; Chaudhary et al., 2011; Chen et al.,
2000; Doroftei and El-Mabrouk, 2011; Gorecki and Eulenstein,
2011a,b; Nguyen et al., 2013; Swenson et al., 2012; Wu et al.,
2012). A natural approach is to remove a weakly supported edge
and collapse its two incident vertices into one (Beiko and
Hamilton, 2006), or to remove ‘dubious’ nodes and join resulting
subtrees under a single root (Lafond et al., 2013). The resulting
tree is non-binary with polytomies (multifurcating nodes) repre-
senting unresolved parts of the tree. A natural question is then to
select a binary reﬁnement of each polytomy based on appropri-
ate criteria. This has been the purpose of a few theoretical and
algorithmic studies conducted in the past years, most of them
based on minimizing the mutation (i.e. duplication and loss) cost
of reconciliation (Chang and Eulenstein, 2006; Lafond et al.,
2012; Vernot et al., 2009; Zheng et al., 2012).

In the present article, we consider a different reconciliation
criterion for reﬁning a polytomy, which consists in minimizing
the number of non-apparent duplication (NAD) nodes. A dupli-
cation node x of a gene tree (according to the reconciliation with
a given species tree) is a NAD if the genome sets of its two
subtrees are disjoint. In other words, the reason x is a duplication
is not the presence of paralogs in the same genome, but rather an
inconsistency with the species tree. Such nodes have been ﬂagged
as potential errors in different studies (Chauve and El—Mabrouk,
2009; Flicek, 2012; Scornavacca et al., 2009). In particular, they
correspond to the nodes ﬂagged as ‘dubious’ in Ensembl gene
trees.

We introduce the polytomy reﬁnement problem in Section 2,
and we show in Section 3 how it reduces to a clique decompos-
ition problem in a graph representing speciation and duplication
relationships between the leaves of a polytomy. We develop a
bounded heuristic in Section 4, with guaranteed optimality in
well-characterized instances. In Section 5 we exhibit a general
methodology, using our polytomy reﬁnement algorithm, for cor-
recting NAD nodes of a gene tree. We then show in Section 6
that this approach is in agreement with the observed corrections
of Ensembl gene trees from one release to another.

 

© The Author 2014. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/4.0/), which permits
non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com

112 ﬂJO'smumo[pJOJXO'sopchogurorq/ﬁd11q won popcolumoq

910K ‘09 isnﬁnV no :2

M.Lafond et al.

 

2 THE POLYTOMY REFINEMENT PROBLEM

Phylogenies and reconciliations. A phylogeny is a rooted tree that
represents the evolutionary relationships of a set of elements
(such as species, genes, . ..) represented by its nodes: internal
nodes are ancestors, leaves are extant elements and edges repre-
sent direct descents between parents and children. We consider
two kinds of phylogenies: species trees and gene trees. A species
tree 8 describes the evolution of a set of related species, from a
common ancestor (the root of the tree), through the mechanism
of speciation. For our purpose, species are identiﬁed with gen-
omes, and genomes are simply sets of genes. As for a gene tree, it
describes the evolution of a set of genes, through the evolution-
ary mechanisms of speciation and duplication. Therefore, each
gene g, extant or ancestral, belongs to a species denoted by s(g).
The set of genes in a gene tree is called a gene family. A leaf-label
corresponds to a genome in a species tree, and to a gene belong-
ing to a genome in a gene tree.

Given a phylogeny T, we denote by l(T) the leaf-set and by
V(T) the node-set of T. Given a node x of T, we denote by l(x)
and call the clade of x, the leaf-set of the subtree of T rooted at x.
We call an ancestor of x any node y on the path from the root of
T to the parent of x. In this case we write y<x. Two nodes x, y
are unrelated if none is an ancestor of the other. For a leaf subset
X of T, lcaT(X), the lowest common ancestor (LCA) of X in T,
denotes the farthest node from the root of T, which is an an-
cestor of all the elements of X. In this article, species trees are
assumed to be binary: each internal node has two children,
representing its direct descendants (see 8 in Fig. 1). For an in-
ternal node x of a binary tree, we denote by xg and x, the two
children of x.

DEFINITION 1. (Reconciliation) A reconciliation between a binary
gene tree G and a species tree 8 consists in mapping each internal
or leaf node x of G (representing respect. an ancestral or extant
gene) to the species s( x ) corresponding to the LCA in of the set
{s(l), for all l e l(x)}. Every internal node x of G is labelled by an
event E( x ) verifying: E(x)= Speciation (S) if s(x) is different
from S(Xg) and s(xr), and E(x) = Duplication otherwise.

We deﬁne two types of duplication nodes of a gene tree G. A
Non-Apparent—Duplication (NAD) is a duplication node x of G
such that (Uxe1(x,)x) ﬂ (Uyelm) y) = 0. A duplication that is not an
NAD is an apparent duplication (AD) node, i.e. a node with the
left and right subtrees sharing a common leaf-label. Therefore,
any internal node x of G is of type S, AD or NAD.

The gene trees we consider might be non-binary. We call polyt-
omy a gene tree with a non-binary root (see .7: in Fig. 1).

DEFINITION 2. (Binary reﬁnement) A tree H T is a refinement of a
tree T if and only if the two trees have the same leaf-set and T can
be obtained from H T by contracting some edges. When H T refines
T, each node of T can be mapped to a unique node of H T so that the
ancestral relationship is preserved. H T is a binary refinement of T
if and only if HT is binary and is a refinement of T.

In this article, as only binary reﬁnements are considered, we
omit the term binary from now.

Problem statement. The general problem we address is the fol-
lowing: Given a non-binary gene tree G and a species tree 8, ﬁnd
a reﬁnement of G containing the minimum number of NADs with

respect to 8 . Such a reﬁnement of G is called a minimum refinement
of G w.r.t. 8.

Hence, we aim at reﬁning each non-binary node of G. We ﬁrst
show that each such non-binary node of G can be reﬁned inde-
pendently of the other non-binary nodes.

THEOREM 1. Let {Gi, for 1 5 i 5 n} be the set of subtrees of G
rooted at the n children {xi, for 1 5 i 5 n} of the root of G. Let
Hmin(G,-, 8) be a minimum refinement of G,- w.r.t. 8. Let G’ be the
tree obtained from G by replacing each G,- by Hmin(G,-, 8). Then a
minimum refinement of G is a minimum refinement of G’.

It follows from Theorem 1 that a minimum reﬁnement of G
can be obtained by a depth-ﬁrst procedure iteratively solving
each polytomy Gx, for each internal node x of G.

In the rest of this paper, we consider G as a polytomy, and we
denote by .7: the forest {G1, G2, . . . Gn} obtained from G by
removing the root. For simplicity, we make no difference be-
tween a tree G,- of .7: and its root. In particular, s(G,-) corresponds
to s(root(G,-)), where root(G,-) is the root of G,- (Fig. 1). We are
now ready to deﬁne the main optimization problem we consider.
Minimum NAD polytomy reﬁnement (MinNADref) problem:
Input: A polytomy G and a species tree 8;

Output: In the set H(G) of all reﬁnements of G, a reﬁnement H
with the minimum number of NAD nodes. Such a reﬁnement is
called a solution to the MinNADref problem.

3 A GRAPH-THEORETICAL CHARACTERIZATION

We show (Theorem 2) that the MinNADref Problem reduces to a
clique decomposition problem on a graph that represents the
impact, in terms of NAD creation, of j oining pairs of trees from .73.

The join graph of a polytomy. We ﬁrst deﬁne a graph R based
on the notion of join. A join is an unordered pair {G1, G2} where
G1, G2 6 .73. The join operation j on {G1, G2} consists in joining
the roots of G1 and G2 under a common parent; we denote by

((8.0.(gah))
((c.d).(i.k))

 

    
    
  

(g)

   

(a) ((8.0.(gah))

k))

    

   

(b,e) (i,m)
(a)

m) (h .
((a . f).( g . h»

I)
Fig. 1. A forest .7, a species tree 8 and the corresponding graph R. Each
gene tree G of .7: is attached to its corresponding node s(G) in S. In R,
joins of type AD are represented by green lines. All other lines are the
joins of type S. Non-trivial AD-components (AD-components containing
at least two nodes) are represented by green ovals. Red lines in R repre-
sent a vertex-disjoint clique W of RS. Here, R AD U W has a single con-
nected component, which leads to the binary reﬁnement H of .7: with no
NAD. After the joins of W are applied (red edges in H), the speciation-
free forest can be joined with four joins AD (green vertices in H)

 

i520

112 ﬂIO'sleumo[pIOJXO'soI1euIIOJquIq//:d11q IIIOIJ pepeolumoq

910K ‘09 isnﬁnV uo ::

Polytomy reﬁnement

 

GL2 the resulting join tree. We call the join type ofj= {G1, G2},
and denote by jt(G1, G2), the reconciliation label of the node
created by joining G1 and G2 (i.e. the root of GL2), where
jt(G1, G2) 6 {S, AD, NAD}, respectively, for speciation, AD
and NAD, w.r.t. the species tree 8.

We denote by R: (V, E) the join graph of .73, deﬁned as the
unoriented complete graph on the set of vertices V= .73, where
each edge (join) is labelled by the corresponding join type
(Fig. 1). We denote by RS and R A D the subgraphs of R deﬁned
by the edges of type, respectively, S and AD. We call a connected
component of R A D an AD-component.

Let .77 be the new forest obtained by replacing the two trees G1
and G2 of .7: by the join tree GL2. The rules given below, follow-
ing directly from the deﬁnition of speciation and duplication in
reconciliation, are used to update the join type jt(G1,2, T) for any
T E .7:\{G1, G2}.

Ruleset 1

(1) Ifjt(G1, T) = AD 0" jt(G2, T) = AD, the" jt(G1,2, T) = AD;

(2) Otherwise, if jt(G1, T)=NAD or jt(G2, T)=NAD, then
jt(ng, T) =NAD,‘

(3) Otherwise, if lca( T) is not a descendant of lca(G1,2), then
ﬂ(G1,2, T) = S;

(4) Otherwise, jt(G1,2, T)=NAD.

Clique decomposition of the join graph. Let a join sequence
J=(J1, J2, . . . , JIJI) be an ordered list of joins. We denote by
.7: (J, i) the forest obtained after applying the ﬁrst i joins of J,
starting with .73. Note that .7: (J, 0) =73, and that J,- e J is a join
on .7-"(J,i — 1). Let J denote the set of all possible join se-
quences of size |.7-"| — 1. Clearly, applying all joins of a sequence
J e J yields a single binary tree, and there exists a gene tree H
e H(G) with d NADs if and only if there exists a join sequence
J e J with d joins of type NAD. We reﬁne this property by
showing that there is a solution to the MinNADref problem
where all duplication nodes are ancestral to all speciation nodes
(see the tree H of Fig. 1 for an example). The proof (not shown)
makes abundant use of Ruleset 1.

LEMMA 1. There exists a binary refinement H e H(G) with d
NADs if and only if there exists a join sequence J e J with d
joins of type NAD such that, if J, e J is the first join not of type
S in J, then all following joins  forj> i, are of type AD or NAD.

We deﬁne a speciation tree as a gene tree in which every internal
node is a speciation node. We deduce from the previous
lemma that we can obtain a solution H to the MinNADref prob-
lem by creating a forest of speciation trees ﬁrst, then successively
joining them with joins of type AD or NAD. As the nodes of R
corresponding to the leaves of a given speciation subtree of H are
pairwise joined by speciation edges, they form a clique in R S (in
Fig. 1 the cliques in red are selected and the corresponding joins
are applied to compute reﬁnement H). The next theorem makes
the link between the number of NADs of H and the cliques of R S.
For a set W of vertex-disjoint cliques of RS, we denote by
R AD U W the graph deﬁned by the union of the edges of R AD
and W.

THEOREM 2. A solution to the MinNADref Problem has d NADs
if and only if, among all graphs RAD U W where W is a set of

vertex-disjoint cliques of RS, at least one has d + I connected com-
ponents and none has less than d + I connected components.

The proof of Theorem 2 is constructive. Given an optimal set
W of vertex-disjoint cliques of RS, it leads to an optimal reﬁne-
ment H. Unfortunately, it can be shown that, given an arbitrary
graph with two edge colours AD and S, ﬁnding if there exists a
set W yielding a given number of connected components is an
NP-hard problem (proof not shown). However, R is constrained
by the structure of a species tree, which restricts the space of
possible join graphs. An arbitrary complete graph R with edges
labelled on the alphabet {S, AD, NAD} is said to be valid if there
exists a species tree and a polytomy whose join graph is R. We
characterize below the valid graphs in terms of forbidden
induced subgraphs. The proof is partially based on well-known
results on P4-free graphs (Corneil et al. 1985).

THEOREM 3. A graph R is valid if and only if R S is {P4, 2K2}-free,
meaning that no four vertices of RS induce a path of length 4, nor
two vertex-disjoint edges.

Although we have not been able to ﬁnd an exact polynomial-
time algorithm for the MinNADref problem, this very con-
strained structure of the R graph yields a bounded heuristic for
this problem with good theoretical properties described in the
next section.

REMARK 1. The P4-free property, which was already introduced in
relation with reconciliations in (Hellmuth et al., 2013), is of special
interest, as many NP—hard problems on graphs have been shown to
admit polynomial time solutions when restricted to this class of
graphs. Unfortunately we can prove that, given an arbitrary P4-
free graph on which we add AD edges, finding an optimal W is still
NP—hard (proof not shown). However, the added 2K2-free restric-
tion imposes a rigid structure on the graph at hand, and we con-
jecture that there exists a polynomial time algorithm to find an
optimal W.

4 A BOUNDED HEURISTIC

We ﬁrst describe a general approach based on the notion of
useful speciations, followed by a reﬁnement of this approach
with guaranteed optimality criteria.

DEFINITION 3. Let J = (J1, . . . , Jljl) be a join sequence. A join J,- =
{G1, G2} ofJ is a useful speciation ifjt(G1, G2) = S and G1, G2 are
in two different AD—components of the R graph obtained after
applying the J1, . . . , Ji_1 joins.

Hence, if R has c AD-components, ﬁnding a zero NAD solu-
tion becomes the problem of ﬁnding a join sequence with c — 1
useful speciations. For example, the graph R in Figure 1 has ﬁve
AD-components (three trivial and two non-trivial), and thus the
four useful speciations represented by the red lines lead to a 0
NAD solution (the binary tree H). In the general case, the prob-
lem we face is to select as many useful speciations as possible, as
the resulting AD-components will have to be connected by NAD
joins. If we deﬁne a speciation-free forest as a forest .7: such that
no edge of its join graph R is a speciation edge, following Lemma
1, we would like to ﬁrst compute a set of useful speciations that

 

i521

112 /810's112umo[pIOJXO'soI1euIIOJHIoIq//:d11q 111011 pepeolumoq

910K ‘09 isnﬁnV uo ::

M.Lafond et al.

 

results in a speciation-free forest whose join-graph has the least
number of AD-components.

DEFINITION 4. A lowest useful speciation is a useful speciation
edge {G1, G2} of RS such that s(G1,2) is not the ancestor of any
s(Gl-J), for {G,-, Gj} being another useful speciation edge of RS.

Lowest useful speciations ﬁt naturally in the context of
bottom-up algorithms where speciations edges that correspond
to lower vertices of 8 are selected before speciations edges cor-
responding to ancestral species. The theorem below shows that
proceeding along these lines ensures that the resulting join se-
quence contains at least half of the optimal number of useful
speciation.

THEOREM 4. Let s be the maximum number of useful speciations
leading to a solution to the MinNADref problem. Then any algo-
rithm that creates a speciation-free forest through lowest useful
speciations makes at least [s/2'l useful speciations.

This theorem implicitly deﬁnes a heuristic with approximation
ratio 2 on the number of useful speciations that visits 8 in
a bottom-up way, making useful speciations (which would
thus be lowest useful speciations) whenever such an edge is
available.

We now describe an improved version of this general heuristic
principle. A detailed example is given in Figure 2. The main idea
is to consider a bottom-up traversal of the species tree 8, and
for each visited vertex s, to ﬁnd a useful set of speciation edges
by ﬁnding a matching in a bipartite graph. More precisely,
for a node s e V(S), we consider the complete bipartite graph
[3 =(X U Y, {xylx e X, y e Y}) such that the left (respectively
right) subset X (respectively Y) contains all the trees G,- of
.7: where s(G,-) is on the left (respectively right) subtree of s.
Consider the two partitions AD X and ADY of X and Y, respect-
ively, into AD-components. The key step of our heuristic is to
ﬁnd a matching M g E(B) of useful speciations between AD X
and ADy, called a useful matching. For example, in Figure 2,
the bipartite graph and matching illustrated for Step 3 corres-
pond to node l and that of Step 4 to node m of S.

Notice that not all edges of [3 correspond to useful
speciations. Indeed it is possible that for some x e X and some
y e Y, although {x, y} is a speciation edge, x and y are in the
same AD-component of R due to another tree 2 not in B such
that {x, z} and {2, y} are AD-edges. For example in Figure 1,
although {(a), (g)} is a join of type S, the trees (a) and (g) are in
the same AD-component of R due to the tree ((a, f), (g, h)). For a
vertex x of X (respectively y of Y), denote by AD(x) (respectively
AD(y)) the component of AD X (respectively ADY) containing x
(respectively y). We indicate the fact that AD(x) and AD(y)
belong to the same AD-component in R by adding two
dummy genes b1 in AD(x) and b2 in AD(y), and a bridge {b1, b2}
in E(B). Such bridges will be included in every matching, prevent-
ing to include non-useful speciation edges.

An instance P of the problem associated with a vertex s of 8 is
denoted by P: (X, Y, ADX, ADy, B) where X, Y, ADX, ADY are
deﬁned as above and B is the set of bridges induced by R. The
graph corresponding to P, i.e. the complete bipartite graph on
sides X and Y to which we added the bridge edges B, is denoted
by B(P). The whole method is summarized in Algorithm 1

(111) After Step 4: 

(1) After Step 3:

 

D
1 2 3 4 5 6 7 8 9 10 11 12 13 14

(F): A:2 B:5u D:1°1 E:1°3 F: /\ G: /\ H: 100 I: /\ J: /\ K: /\ M:/\
1 3 5 7 12 14 3 4 6 8 5 12


Step2(k): B a
E.

Fig. 2. A species tree 8 and a forest .7: of binary trees forming the
polytomy. The trees of .7: are placed on 8 according to their LCA. The
i, k, l and m nodes of S are annotated with the forest obtained after
running Algorithm 2 on these nodes. Their corresponding complete bi-
partite matching instances are illustrated at the bottom. AD joins are
represented by dotted lines, useful matching are represented by plain
lines (we omit drawing all the other edges of the complete bipartite
graphs). Note that there is a bridge induced by M between (F, K) and I
at step 4. In the fourth step, we obtain a single connected component,
which allows, in a ﬁnal step, to connect all the subtrees by AD nodes
(ﬁnal tree is on the top of the ﬁgure)

 

MinNADref(.7-", 8) and illustrated on a simple example in
Figure 2.

 

Algorithm 1: MinNADreﬂf, S).

for each node s of S in a bottom-up traversal of 8 do
Let P=(X, Y, ADX, ADy, B) be the problem instance corresponding
to s;
Find a useful matching M of B(P) of maximum size (Algorithm
MaxMatching below);
Apply each speciation of M, and update .7:
end for
For each connected component C of R A D, join the trees of C under AD
Nodes;
If there is more than one tree remaining, join them under NAD nodes.

 

 

Finding a useful matching of maximum size can be done in
polynomial time by Algorithm 2. For an instance
P = (X, Y, AD X, AD y, B), the algorithm progressively increments
the set M of speciation edges, eventually leading to a useful
matching of maximum size. At a given step, let QRM be the
graph with vertices X U Y and edges Ep,M=EAD U M, where
E A D is the set of AD edges of R connecting vertices of X U Y.
Components AD X, 6 AD X and ADY]. e ADY are linked if there is
a path in QRM linking a vertex of AD X, to a vertex of ADyj, and
not linked otherwise.

 

Algorithm 2:MaxMatching(X, Y, X X, AD y, B).

D = (b; M = B;

while D 75 XU Ydo
Find C 6 AD X U ADY of maximum cardinality with vertices not
included in D, if any; assume w.l.o.g. C= ADX, e ADX;

 

 

i522

112 /810's112umo[pIOJXO'soI1euIIOJHIoIq//:d11q 111011 pepeolumoq

910K ‘09 isnﬁnV uo ::

Polytomy reﬁnement

 

for each x e C that is not incident to an edge in M do
if there is an y e Y such that AD(y) is not linked to C then
Find such y with AD(y) of maximum cardinality;
Add the vertices x and y to D and add the speciation edge {x, y} to M;
end if
end for
Add remaining vertices of C to D;
end while

 

THEOREM 5. Given an instance P: (X, Y, ADX, ADy, B),
Algorithm 1 finds a useful matching M of maximum size.

Algorithm 1 is a heuristic, as it may fail to give the optimal
solution (reﬁnement with minimum number of NADs), as in
Figure 1 for example. In this example, a bottom-up approach
would greedily speciate a and d, which cannot lead to the optimal
solution. However, we prove in Theorem 6 that if transitivity
holds for the duplication join type, then Algorithm 1 is an
exact algorithm for the MinNADref problem. The example of
Figure 1 does not satisfy this property, as {(a), ((a, f), (g, h))} is a
join of duplication type (AD), {((a, f), (g, h)), (g)} is a join of
duplication type but {(a), (g)} is a join of speciation type.

THEOREM 6. (I) Let s be the maximum number of useful speci-
ations leading to a solution to the MinNADref problem. Then,
Algorithm 1 makes at least [s/2'l useful speciations. (2 ) If, for
every node s of 8 the instance P corresponding to s has no bridges,
then Algorithm 1 outputs a refinement of the input polytomy with
the maximum number of useful speciations.

The following corollary provides an alternative formulation of
the optimality result given by the above theorem.

COROLLARY. Algorithm 1 exactly solves the MinNADref problem
for an input (.73, 8) such that each AD—component of the corres-
ponding graph R is free from S edges (i.e. there is no S edge
between any two vertices of a given AD-component).

5 GENE TREE CORRECTION

The polytomy reﬁnement problem is motivated by the problem
of correcting gene trees. Duplication nodes can be untrusted for
many reasons, one of them being the fact that they are NADs,
pointing to disagreements with the species tree that are not due
to the presence of duplicated genes. Different observations tend
to support the hypothesis that NAD nodes may point at errone-
ous parts of a gene tree (Chauve and El-Mabrouk, 2009;
Swenson et al., 2012). For example, the Ensembl Compara gene
trees Wilella et al., 2009) have all their NAD nodes labelled as
‘dubious’. In (Chauve and El—Mabrouk, 2009), using simulated
datasets based on the species tree of 12 Drosophila species given
in (Hahn et al., 2007) and a birth-and-death process, starting
from a single ancestral gene, and with different gene gain/loss
rates, it has been found that 95% of gene duplications lead to an
AD vertex. Although suspected to be erroneous, some NAD
nodes may still be correct, due to a high number of losses.
However, in the context of reconciliation, the additional
damage caused by an erroneous NAD node is the fact that it
signiﬁcantly increases the real rearrangement cost of the tree
(Swenson et al., 2012). Therefore, tools for modifying gene

trees according to NADs are required. We show now how
Algorithm 1 can be used in this context.

In (Lafond et al., 2013), a method for correcting untrusted
duplication nodes has been developed. The correction of a du-
plication node x relies on pushing x by multifurcation, which
transforms x into a speciation node with two children being
the roots of two polytomies. Figure 3 recalls the pushing by multi-
furcation procedure. These polytomies are then reﬁned by using
an algorithm developed in (Lafond et al., 2012), which optimizes
the mutation cost of reconciliation.

In the context of correcting NADs, we use the same general
methodology, but now using Algorithm MinNADref for reﬁning
polytomies. Removing all NADs of a gene tree can then be done
by iteratively applying the above methodology on the highest
NAD node of the tree (the closest to the root).

6 RESULTS

Simulated data. Simulations are performed as follows. For a
given integer n, we generate a species tree 8 with a random
number of leaves between 0.5n and 3n. We then generate a
forest .7: =(G1, ...,G,,) of cherries by randomly picking, for
each cherry G,- e .73, one node s,- e S and two leaves, one from
each of the two subtrees rooted at s,-. Any leaf of 8 is used at
most once (possibly by adding leafs to 8 if required), leading to a
set of cherries related through joins of type S or NAD. Then, for
each pair {G,-, Gj} with join type NAD, we relate them through
AD with probability 1/2 (or do nothing with probability 1/2), by
adding a duplicated leaf.

For each pair (S, .73), we compared the number of NADs
found by Algorithm MinNADref with the minimum number
of NADs returned by an exact algorithm exploring all possible
binary trees that can be constructed from .73. We generated a
thousand random 8 and .7: for each n 2 4. We stopped at
n = 14, as the brute-force algorithm is too time-costly beyond
this point. Over all the explored datasets simulated as described
above, Algorithm MinNADref was able to output an optimal
solution, i.e. a reﬁnement with the minimum number of NADs.
Therefore, the examples on which the heuristic fails seem to be
rare, and the algorithm performs well on polytomies of reason-
able size.

We then wanted to assess how the NAD minimization criter-
ion differs from the rearrangement cost minimization criterion.
We generated 960 random instances with forests of sizes ranging
between 5 and 100 (10 instances for each 5 5 n 5 100). We

G: s; 5 G*:

   

\

C3 1 2 d1 d2 31 b1 b2 C1 C2 C3 d1 d2

     

31 C1 C2

Fig. 3. A gene tree G and a species tree 8, from which we obtain G* by
pushing x by multifurcation. Here, x is a NAD, and is pushed by taking
the forest of maximal subtrees of G that only have genes from species in
the s, subtree (green), then another forest for the s, subtree (red) in the
same manner. Both these forests are joined under a polytomy, which are
then joined under a common parent, so the root of G* is a speciation

 

i523

112 /810's112umo[pIOJXO'soI1euIIOJHIoIq//:d11q 111011 pepeolumoq

910K ‘09 isnﬁnV uo ::

M.Lafond et al.

 

compared the output of Algorithm MinNADref with that of
Algorithm MinDLref, given in (Lafond et al., 2012), which com-
putes reﬁnement minimizing the duplication+loss (DL) cost of
reconciliation with the species tree. Both algorithms gave the
exact same reﬁnement for only 12 instances (1.25%). As ex-
pected, Algorithm MinNADref always yielded a reﬁned tree
with a lower or equal number of NADs than the tree given by
Algorithm MinDLref, but always had a higher or equal DL—cost.
However, in many cases, minimizing the DL—score did not min-
imize the number of NADs, as in 377 instances (39.3%),
Algorithm MinNADref yielded strictly less NADs than
Algorithm MinDLref.

Ensembl Gene Trees.

Next we tested the relevance of the proposed gene tree correc-
tion methodology, by exploring how Ensembl gene trees are cor-
rected from one release to another. As the Ensembl general
protocol for reconstructing gene trees does not change between
releases, the observed modiﬁcations on gene trees are more likely
due to modiﬁcations on gene sequences.

We used the Ensembl Genome Browser to collect all available
gene trees containing genes from the monophyletic group of ray-
ﬁnned ﬁshes (Actinopterygii), and ﬁltered each tree to preserve
only genes from the taxa of interest (ray-ﬁnned ﬁsh genomes).
We selected from both Releases 74 (the present one) and 70 the
1096 gene trees that are present in both with exactly the same set
of genes from the monophyletic group of ﬁshes, and with less
NAD nodes in Release 74. We wanted to see to what extent our
general principle of correcting an NAD by transforming it to a
speciation node is observed by comparing Rel.70 to Rel.74. Such
a transformation requires to preserve the clade of the corrected
NAD node x of the initial tree, meaning that l(x) should also be
the leaf-set of a subtree in the corrected tree. For >90% of these
trees (993 trees), the highest NAD node clade was preserved in
Rel.74. Moreover, among all such nodes that were corrected, i.e.
were not NAD nodes in Rel.74 (641 trees), almost all were trans-
formed into speciation nodes (630 trees), which strongly supports
our correction paradigm.

0.6

 

-I-Trees with the NAD transformed
into a speciation by Ensembl
+Trm=c with the NAD francfnrmpd

0.5 \
\ into a speciation by Ensembl

 

and giving rise to a non-trivial polytomy
All trees
0.4

 as
 \ A

0 l -—' ﬁ II
0.00 — 0.10 0.10 — 0.20 0.20 — 0.30 0.30 — 0.40 0.40 — 0.50 0.50 — 0.60 0.60 — 0.70 0.70 — 0.80 0.80 — 0.90 0.90 — 1.00

 

 

- of trees

 

 

 

 

RF Dist / Max RF Dist

Fig. 4. Normalized RF-distance between corrected gene trees (by modi-
ﬁcation of the highest NAD) from Rel. 70 and corresponding gene trees
in Rel. 74. Blue curve: transformation of the highest NAD into a speci-
ation. Red curve: trees with a non-trivial polytomy after pushing by
multifurcation. Yellow curve: all trees

To evaluate our methodology for correcting NADs, we
applied it to the highest NAD node of each of the 1096 afore-
mentioned trees of Rel.70. Figure 4 illustrates a comparison be-
tween the corrected trees (Rel.70C, C standing for ‘Corrected’)
obtained by our methodology and those of Rel. 74. Pairwise
comparisons are based on the normalized Robinson—Foulds
(RF) distance (number of identical clades divided by the total
number of clades). The yellow curve shows a good correlation
between Rel.70C and Rel.74, with ~65 % exhibiting >80% similar
clades between Rel.70C and Rel.74. If we reduce the set of trees to
those for which the highest NAD node is also transformed to a
speciation node in Rel.74 (630 trees), the correlation is even better
(blue curve of Fig. 4), with 44% of trees being identical (277 over
630 trees) and ~80% exhibiting >80% similar clades between
Rel.70C and Rel.74. Now, to speciﬁcally evaluate Algorithm
MinNADref, we further restricted the set of trees to those
giving rise to a non-trivial polytomy (i.e. polytomy of degree > 2)
after the pushing by multifurcation, which leads to a set of 117
trees. Overall, the results for these trees (red curve in Fig. 4) are
close to those observed for all trees (yellow curve) detailed above.

We then wanted to evaluate our correction of the 117 afore-
mentioned trees compared with trees in Rel.74. Figure 5 provides
an evaluation of the corrected trees (yellow curve) compared with
those in Rel. 74 (blue curve) based on the normalized RF dis-
tance with the initial trees in Rel.70. Overall, the initial tree is
closer to our correction than to the one of Rel.74. Therefore,
even though gene trees of Rel.74 are likely to have stronger stat-
istical support with respect to the gene sequences provided in
Rel.74, our correction removes NADs while respecting as
much as possible the given tree topology. Finally, we considered
the reconciliation mutation cost as another evaluation criterion.
Among the 117 trees of Rel.70C, 30 are identical to the corres-
ponding trees in Rel. 74, and 60% have a lower mutation cost,
which tend to support our correction compared with the tree in
Rel.74. As for the 40% remaining trees, half of them have more
NADs than the corresponding tree in Rel.74, which suggests that
applying our correction to all NAD, instead of just the highest
one, would help to obtain better results.

117 trees having non-trivial polytomy

+V70 vs V74

WOC vs V70

81 0I trees

 

_%
0.00 — 0.100.10 — 0.200.20 — 0.300.30 — 0.400.40 — 0.500.50 — 0.600.60 — 0.700.70 — 0.800.80 — 0.900.90 — 1.00
RF Dist I Max RF Dist

Fig. 5. Normalized RF-distance between corrected trees (yellow curve)
and Rel. 74 trees (blue curve) and original Rel. 70 trees

 

i524

112 /810's112umo[pIOJXO'soI1euIIOJHIoIq//:d11q 111011 pepeolumoq

910K ‘09 isnﬁnV uo ::

Polytomy reﬁnement

 

Finally, we evaluated the effect of NAD correction on the tree
likelihood. For this purpose, we selected the 1891 Ensembl Rel. 74
gene trees of the considered monophyletic group containing at
least one NAD, and we corrected each NAD individually. The
sequences were aligned using ClustalW (Larkin et al., 2007) and
the likelihood values were computed with PhyML (Guidon et al.,
2003). For a tree T and a NAD node x, denote by T x the tree
obtained after correcting x. For each T and each x, we computed
the log-likelihood ratio L(x) = logLH(T)/logLH(Tx). Among the
4454 NAD nodes found in the considered set of trees, 95.4% of
the L(x) ratios were between 0.98 and 1.02. Although the cor-
rection algorithm is not expected to outperform the Ensembl
protocol in terms of likelihood as it ignores sequences, we
found that the likelihood of the tree has been improved
(L(x)> 1) after correction for 43.9% of the NAD nodes.
Moreover, 1180 (62.4%) trees contained at least one NAD
node improving the likelihood.

7 CONCLUSION

The present work is dedicated to the polytomy reﬁnement prob-
lem. While the mutation cost of reconciliation has been used pre-
viously as an optimization criterion for choosing an appropriate
binary tree, here we use an alternative criterion, which is the mini-
mization of NADs. The tractability of the MinNADref Problem
remains open, as is the problem to select, among all possible so-
lutions, those leading to a minimum reconciliation cost. Although
developing a gene tree correction tool is not the purpose of this
article, we show how our algorithm for polytomy reﬁnement can
be used in this context, by developing a simple algorithm allowing
to correct a single NAD. This algorithm has been applied to trees
of a previous Ensembl release, and the corrected trees have been
compared with the trees of the current Ensembl release. A good
correlation between the two sets of trees is observed, which tends
to support our correction paradigm. While minimizing NADs
cannot be a sufﬁcient criterion for gene tree correction, it should
rather be seen as one among others, such as statistical (Wu et al.,
2012), syntenic (Lafond et al., 2013) or based on reconciliation
with the species tree (Chaudhary et al., 2011; Lafond et al., 2013;
Swenson et al., 2010), that can be integrated in a methodological
framework for gene tree correction.

Funding: N.E.-M. and ML. are supported by ‘Fonds de
recherche du Quebec—Nature et technologies’ (F RQNT). CC.
and N.E.-M. are supported by the Natural Sciences and
Engineering Research Council of Canada (NSERC). R.D. is sup-
ported by the MIUR PRIN 2010—2011 grant ‘Automi e
Linguaggi F ormali: Aspetti Matematici e Applicativi’, code
H41J12000190001.

Conflict of interest: none declared.

REFERENCES

Akerborg,0. et al. (2009) Simultaneous bayesian gene tree reconstruction and rec-
onciliation analysis. Proc. Natl Acad. Sci. USA, 106, 5714—5719.

Beiko,R.G. and Hamilton,N. (2006) Phylogenetic identiﬁcation of lateral genetic
transfer events. BM C Evol. Biol, 6, 15.

Berglund-Sonnhammer,A.C. et al. (2006) Liberles. Optimal gene trees from se-
quences and species trees using a soft interpretation of parsimony. J. Mol.
Evol., 63, 240—250.

Boussau,B. et al. (2012) Genome-scale coestimation of species and gene trees.
Genome Res., 23, 323—330.

Chang,W.C. and Eulenstein,0. (2006) Reconciling gene trees with apparent poly-
tomies. In: COCOON 2006. Lecture Notes in Computer Science. Vol. 4112,
Springer, Taiwan, pp. 235—244.

Chaudhary,R. et al. (2011) Efﬁcient error correction algorithms for gene tree rec-
onciliation based on duplication, duplication and loss, and deep coalescence.
BMC Bioinformatics, 13 (Suppl.10), Sll.

Chauve,C. and El-Mabrouk,N. (2009) New perspectives on gene family evolution:
losses in reconciliation and a link with supertrees. RECOMB 2009. Lecture
Notes in Computer Science. Vol. 5541, Springer, USA, pp. 46—58.

Chen,K. et al. (2000) Notung: dating gene duplications using gene family trees.
J. Comp. Biol, 7, 429—447.

Corneil,D.G. et al. (1985) A linear recognition algorithm for cographs. SIAM
J. Comput., 14, 926—934.

Datta,R.S. et al. (2009) Berkeley phog: phylofacts orthology group prediction web
server. Nucleic Acids Res., 37, W84—W89.

Doroftei,A. and El-Mabrouk,N. (2011) Removing noise from gene trees. WABI
2011. Lecture Notes in Bioinformatics. Vol. 6833, Springer, Germany, pp. 76-
91.

Durand,D. et al. (2006) A hybrid micro-macroevolutionary approach to gene tree
reconstruction. J. Comput. Biol, 13, 320—335.

Larkin,M.A. et al. (2007) Clustalw and clustalx version 2. Bioinformatics, 23,
2947—2948.

Flicek,P. (2012) Ensembl 2012. Nucleic Acids Res., 40, D84—D90.

Gorecki,P. and Eulenstein,0. (2011a) Algorithms: simultaneous error-correction
and rooting for gene tree reconciliation and the gene duplication problem.
BMC Bioinformatics, 13 (Suppl. 10), $14.

Gorecki,P. and Eulenstein,0. (2011b) A linear-time algorithm for error-corrected
reconciliation of unrooted gene trees. ISBRA 2011. Lecture Notes in
Bioinformatics. Vol. 6674, Springer, China, pp. 148—159.

Guidon,S. and Gascuel,0. (2003) A simple, fast and accurate algorithm to estimate
large phylogenies by maximum likelihood. Syst. Biol, 52, 696—704.

Hahn,M.W. et al. (2007) Gene family evolution across 12 drosophilia genomes.
PLoS Genet, 3, e197.

Hellmuth,M. et al. (2013) Orthology relations, symbolic ultrametrics, and cographs.
J. Math. Biol, 66, 399—420.

Huerta-Cepas,J. et al. (2011) Phylomedb v3.0: an expanding repository of genome-
wide collections of trees, alignments and phylogeny-based ozrthology and par-
alogy predictions. Nucleic Acids Res., 39, D556—D560, 2011.

Lafond,M. et al. (2012) Gene tree correction guided by orthology. BMC
Bioinformatics, 14 (Suppl. 15), SS.

Lafond,M. et al. (2013) Models and algorithms for genome evolution. In: Error
Detection and Correction of Gene Trees. Springer, Canada. 2013.

Lafond,M. et al. (2012) An optimal reconciliation algorithm for gene trees with
polytomies. WABI 2012. Lecture Notes in Computer Science. Vol. 7534.
pp. 106—122.

Mi,H. et al. (2012) Panther in 2013: modeling the evolution of gene function, and
other gene attributes, in the context of phylogenetic trees. Nucleic Acids Res., 41,
D377—D386.

Rasmussen,M.D. and Kellis,M. (2011) A bayesian approach for fast and accurate
gene tree reconstruction. Mol. Biol. Evol., 28, 273—290.

Ronquist,F. and Huelsenbeck,].P. (2003) MrBayes3: Bayesian phylogenetic infer-
ence under mixed models. Bioinformatics, 19, 1572—1574.

Saitou,N. and Nei,M. (1987) The neighbor-joining method: a new method for re-
constructing phylogenetic trees. Mol. Biol. Evol., 4, 406—425.

Schreiber,F. et al. (2013) Treefam v9: a new website, more species and orthology-on-
the-ﬂy. Nucleic Acids Res, 42, D922—D925.

Scomavaeca,C. et al. (2009) From gene trees to species trees through a supertree
approach. LAT A 2009. Lecture Notes in Computer Science. Vol. 5457. pp.
702—714.

Swenson,K.M. et al. (2012) Gene tree correction for reconciliation and species tree
inference. Algorithms Mol. Biol, 7, 31.

SzOllosi,G.J. et al. (2013) Efficient exploration of the space of reconciled gene trees.
Syst. Biol, 62, 901—912.

Nguyen,T.H. et al. (2013) Reconciliation and local gene tree rearrangement can be
of mutual proﬁt. Algorithms Mol. Biol, 8, l2.

Thomas,P.D. (2010) GIGA: a simple, efﬁcient algorithm for gene tree inference in
the genomic age. BMC Bioinformatics, 11, 312.

Vernot,B. et al. (2008) Reconciliation with non-binary species trees. J. Comput.
Biol, 15, 981—1006.

 

i525

112 /810's112umo[pIOJXO'soI1euIIOJHIoIq//:d11q 111011 pepeolumoq

910K ‘09 isnﬁnV uo ::

M.Lafond et al.

 

Vilella,A.J. et al. (2009) EnsemblCompara genetrees: complete, duplication-aware
phylogenetic trees in vertebrates. Genome Res., 19, 327—335.

Wapinski,I. et al. (2007) Automatic genome-wide reconstruction of phylogenetic
gene trees. Bioinformatics, 23, i549—i558.

Wu,Y-C. et al. (2012) Treeﬁx: statistically informed gene tree error correction using
species trees. Syst. Biol, 62, 110—120.

Zheng,Y. et al. (2012) Reconciliation of gene and species trees with polytomieseprint
arXiv:1201.3995.

 

i526

112 /810's112umo[pIOJXO'soI1euIIOJHIoIq//:d11q 111011 pepeolumoq

910K ‘09 isnﬁnV uo ::

