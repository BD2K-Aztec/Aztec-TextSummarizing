APPLICATIONS NOTE V°" 23073b.11%§§/355?§ﬁ2§£§%§33§

 

Structural bioinformatics

Advance Access publication July 10, 2013

pyRMSD: a Python package for efficient pairwise RMSD

matrix calculation and handling
Victor A. Gill1 and Victor Guallar1’2’*

1Joint BSC—IRB Research Program in Computational Biology, Barcelona Supercomputing Center, 08034 Barcelona,
Spain and 2lnstitucic') Catalana de Recerca i Estudis Avancats (ICREA), Passeig Lluis Companys 23, E—0801 0 Barcelona,

Spain

Associate Editor: Anna Tramontano

 

ABSTRACT

Summary: We introduce pyRMSD, an open source standalone Python
package that aims at offering an integrative and efficient way of per-
forming Root Mean Square Deviation (RMSD)-related calculations of
large sets of structures. It is specially tuned to do fast collective RMSD
calculations, as painNise RMSD matrices, implementing up to three
well-known superposition algorithms. pyRMSD provides its own sym-
metric distance matrix class that, besides the fact that it can be used
as a regular matrix, helps to save memory and increases memory
access speed. This last feature can dramatically improve the overall
performance of any Python algorithm using it. In addition, its extensi-
bility, testing suites and documentation make it a good choice to those
in need of a workbench for developing or testing new algorithms.
Availability: The source code (under MIT license), installer, test suites
and benchmarks can be found at https://pele.bsc.es/ under the tools
section.

Contact: victor.guallar@bsc.es

Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on April 24, 2013; revised on June 11, 2013; accepted on
July 5, 2013

1 INTRODUCTION

As molecular modeling keeps expanding, obtaining the Root
Mean Square Deviation (RMSD) with optimum superposition
for a large set of structures in an efﬁcient and fast manner is a
necessity. Clustering methods, for example, which are becoming
increasingly popular as trajectory analysis and compression tools
(Karpen et al., 1993; Phillips et al., 2011), can beneﬁt from the
use of a pre-calculated pairwise distance matrix or even totally
depend on it, e. g. Spectral Clustering (Luxburg, 2007). However,
as hardware and algorithms improve, the output size of simula-
tions grows bigger, and the calculation of the distance matrix
becomes the bottleneck in any process depending on it. There
are several implementations of the different superposition algo-
rithms, which are written in wide spectra of programming lan-
guages. Almost all Molecular Dynamics packages and
biomolecule handling software include their own RMSD calcu-
lation tools. Every time programmers need to use an external
RMSD solution in a project, they have two options. The ﬁrst
one is to use an external source or library, which requires

 

*To whom correspondence should be addressed.

previous knowledge of the language in which it was written
and its dependencies. A second option is to use a precompiled
tool with a bigger scope, which means creating an interface with
their own application by writing wrappers and output converters
(with the consequent performance loss). In general, the main
problems to face are fragmentation, excess of or missing features,
bad documentation, lack of sources and the intrinsic difﬁculty of
the languages used. pyRMSD is a Python package that over-
comes all the above problems in the following way:

0 It is totally focused on the calculation of RMSD. It provides
solutions for all the usual RMSD problems and is specially
tuned for RMSD collective calculations, like pairwise RMSD
matrices, a feature that is usually missing in most utilities.

0 Python (www.python.org) is an easy to learn and use pro-
gramming language, which has an extensive library pool
that includes wrappers for almost all libraries used in sci-
ence. This makes it one of the better languages for scientiﬁc
software prototyping and development.

c As pure Python implementations have a poor performance
(even when using ﬁne tuned packages as numpy), pyRMSD
uses Python C extensions with OpenMP and CUDA code,
allowing the full use of multicore machines and Graphics
Processing Units (GPU).

o It implements the most important superposition algorithms
in the same place.

0 It is documented, well tested and open source; therefore, it
can be the perfect workbench for any experienced user who
wants to develop and test their own superposition algorithms.

2 IMPLEMENTATION

2.1 Features

pyRMSD is built around two main classes: the RMSDCalculator
and the CondensedMatrix. The RMSDCalculator class provides
a straightforward interface to three superposition algorithm
implementations, as well as some convenience methods to set
up their options: Kabsch’s superposition algorithm (Kabsch,
1978), QTRFIT (Heisterberg, 1990) and the Quaternion
Characteristic Polinomial method (QCP) (Theobald, 2005). All
have been written as Python C extensions, with serial and parallel
(OpenMP) versions for the ﬁrst two and an additional CUDA
version for the last.

 

© The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 2363

112 ﬂJO'slcumo[pJOJXO'sopchogutotq/ﬁd11q wort popcolumoq

910K ‘09 lsnﬁnV no :2

V.A. Gil and V.Guallar

 

RMSDCalculator’s methods cover all the usual scenarios for
superposition and RMSD calculation:

(1) Pairwise RMSD calculation.

(2) Reference versus the rest of the set.

(3) Reference versus following conformations.

(4) Calculation of a pairwise RMSD matrix of the whole set.

(5) Iterative superposition of a set of conformations.

Moreover, it offers two additional options that further extend
the previous methods. The ﬁrst one is allowing the modiﬁcation
of input coordinates to obtain the superposed conformations.
The second one is to the use of different coordinate sets for
superposition and RMSD calculation.

The CondensedMatrix class models a symmetric squared
matrix. It allows the same row/column access of a regular
matrix, storing only the upper triangle and thus saving half of
the memory. The class has been completely written in C, allowing
access times which are up to 6x faster compared with its Python
counterpart. As a consequence, any algorithm that requires
intensive matrix read access improves its performance. For in-
stance, our cardinality function benchmark, available in the
benchmarks folder, shows a 100x free speedup just by using it.

pyRMSD also provides two small helper classes that make the
process of generating a pairwise RMSD matrix easier. The
Reader class obtains the coordinate sets by means of a simple
and fast C written PDB reader. Finally, the MatrixHandler class
is capable of creating a distance matrix from a set of coordinates
and managing its persistence, with functions to load and save
matrices from disk.

2.2 Usage

The following code snippet illustrates the creation and access of a
pairwise RMSD matrix of a 35 k frames trajectory, available in
the ‘benchmark/data’ folder, using the QCP superposition algo-
rithm, in its CUDA version:

 

from pyRMSD.matrixHandler import MatrixHandler

from pyRMSD.utils.proteinReading import Reader

cords = Reader().readThisFile(’ amber_3 5k.pdb’ )\
.gettingOnlyCAs().read()

matrix = MatrixHandler()\
.CreateMatrix(coords, ‘QCP_OMP_CALCULATOR’)

 

 

 

Here, we can ﬁnd a minimum subset of all the features of
pyRMSD and of the MatrixHandler class itself. However, it is
a good example of how this class nicely encapsulates all the steps
of creating a matrix and of the succinct interface presented to
the user.

2.3 Performance

Using pyRMSD, we have coded a set of benchmark scripts to
understand the performance differences between the three imple-
mented algorithms. We have observed that, in all studied scen-
arios, QCP is the faster method.

We have also compared the performance of our four QCP
implementations. Compared with the serial code, our OpenMP

QCP Calculator Performance

500 s

 

 

+ OpenMP
+ Cuda
—I— Serial

 

 

 

400 s

U.)
C
O
U!

Calculation Time

N
O
O
U)

100 S- ...............  .................  ...............  .................  .................  ............... ..

 

 

 

°§k 10k 15k 20k 25k 30k 35k

Number Of Structures

Fig. 1. QCP calculator performance over a Ubiquitin trajectory (only
CAs) using a 6 cores Intel Xeon E5649 CPU with an NVIDLA M2090
GPU. OpenMP version reaches a 5x speedup. CUDA version gets a
maximum 11x speedup (almost 12 million RMSD calculations per
second)

version is 5x faster; our CUDA-based implementation shows a
11x speedup (see Fig. 1). This leads us to conclude that GPU
implementations can really make the difference in this kind of
problems.

These and other benchmarks, as well as a comparison with
other packages, are discussed in depth in the Supplementary
Data.

3 CONCLUSIONS

We have created pyRMSD, a user-friendly RMSD focused
Python package, which allows, besides other functionalities, the
efﬁcient creation of RMSD pairwise matrices. Its design provides
a natural way of accessing its functionalities making it a good
candidate to be used in bigger packages to replace slower
RMSD functions. This is specially true for those who need to
calculate and access large pairwise RMSD matrices, as cluster-
ing-related packages.

Funding: European project PELE (ERC-2009-Adg 25027).

Conﬂict of Interest: none declared.

REFERENCES

Heisterberg,D.J. (1990) QTRFIT algorithm for superimposing two similar rigid
molecules. The Ohio Supercomputer Center, Ohio State University,
Columbus, OH.

Kabsch,W. (1978) A discussion of the solution for the best rotation to relate two
sets of vectors. Acta. Crystallogr. A, 34, 827—828.

Karpen,M.E. et a]. (1993) Statistical clustering techniques for the analysis of long
molecular dynamics trajectories: analysis of 2.2-ns trajectories of YPGDV.
Biochemistry, 32, 412—420.

Luxburg,U. (2007) A tutorial on spectral clustering. Stat. Comp, 17, 395—416.

Phillips,J.L. et a]. (2011) Validating clustering of molecular dynamics simulations
using polymer models. BMC Bioinformatics, 12, 445.

Theobald,D.L. (2005) Rapid calculation of RMSDs using a quaternion-based char-
acteristic polynomial. Acta. Crystallogr. A, 61, 478—480.

 

2364

112 /810'S{12umo[pJOJXO'sot1emJOJutotw/2d11q IIIOJJ papeolumoq

910K ‘09 lsnﬁnV uo :2

