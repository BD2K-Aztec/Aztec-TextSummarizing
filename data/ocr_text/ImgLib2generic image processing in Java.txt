APPLICATIONS NOTE V°" 252,-?idiié‘iéiaiﬁgiifaﬁﬁﬁé’l;

 

Bioimage informatics

Advance Access publication September 8, 2012

ImgLib2—generic image processing in Java

Tobias Pietzschl’l, Stephan Preibisch1’2’l, Pavel Tomancak1 and Stephan Saalfeld1’*’

1Max Planck Institute of Molecular Cell Biology and Genetics, 01307 Dresden, Germany and 2Janelia Farm Research
Campus, Howard Hughes Medical Institute, Ashburn, VA 20147, USA

Associate Editor: Jonathan Wren

 

ABSTRACT

Summary: ImgLib2 is an open-source Java library for n-dimensional
data representation and manipulation with focus on image processing.
It aims at minimizing code duplication by cleanly separating pixel-
algebra, data access and data representation in memory. Algorithms
can be implemented for classes of pixel types and generic access
patterns by which they become independent of the speciﬁc dimen-
sionality, pixel type and data representation. ImgLib2 illustrates that an
elegant high-level programming interface can be achieved without
sacrificing performance. It provides efficient implementations of
common data types, storage layouts and algorithms. It is the data
model underlying ImageJ2, the KNIME Image Processing toolbox
and an increasing number of Fiji-Plugins.

Availability: ImgLib2 is licensed under BSD. Documentation and
source code are available at http:/ﬁmglib2.net and in a public reposi-
tory at https://github.comﬁmagejﬁmglib.

Supplementary Information: Supplementary data are available at
Bioinformatics Online.

Contact: saalfeld@mpi-cbg.de

Received on July 6, 2012; revised on August 21, 2012; accepted on
July 28, 2012

1 INTRODUCTION

Many algorithmic concepts from computer vision and image
processing are applicable to the analysis of biological image
data. However, re-using existing code is often difﬁcult because
it is implemented for a speciﬁc data type, limited image size or
ﬁxed number of dimensions, e.g. small 2d grayscale images.
Biological imaging techniques generate images of varying dimen-
sionality and a multitude of sample types (e.g. wavelength, fre-
quency spectra, diffusion tensors) with varying precision.
Improvements in imaging speed and resolution result in gigantic
datasets that require well-designed strategies for data handling
(e. g. tiled or compressed storage, streaming access). Writing code
that is re-usable across many combinations of dimensionality,
sample type and storage strategy is challenging and requires an
appropriate abstraction layer.

We present ImgLib2, an open-source image processing frame-
work that achieves code re-usability through a generic interface
architecture that abstracts from dimensionality, sample type and
storage strategy. It is highly extensible, providing developers with
great ﬂexibility in adding new sample types and image

 

*To whom correspondence should be addressed.
TThe authors wish it to be known that, in their opinion, the ﬁrst, second
and the last author should be regarded as joint First Authors.

representations that will seamlessly work with existing
algorithms, and vice versa. ImgLib2 shares basic concepts with
the C++ frameworks ITK Woo et al., 2002) and Vigra (Kothe,
2000) for n—dimensional, generic image processing. It is the ﬁrst
framework that introduces generic programming to the Java
image processing community (Preibisch et al., 2010). We chose
Java for its simplicity and wide acceptance among biological
researchers due to the popular image processing toolbox
ImageJ (Rasband, 2012).

2 ARCHITECTURE

The ImgLib2 core design is based on three main concepts:
Accessibles (i.e. images), Accessors and Types. We deﬁne an
image as any mapping from a subset of n—dimensional
Euclidean coordinate space to a generic pixel value type. Image
properties are expressed by Accessible interfaces: coordinates can
be either integer or real-valued, the coordinate domain can be
either bounded or inﬁnite, the image may support random access
at arbitrary coordinates and/or iteration of all samples. Consider
a conventional pixel image. It comprises samples of a speciﬁc
value type in bounded n—dimensional space, arranged on an in-
teger grid and is both random-accessible (at arbitrary integer
coordinates) and iterable. Importantly, ImgLib2 supports con-
cepts beyond the conventional pixel image, e. g. inﬁnite, proced-
urally generated images or continuous images interpolated from
sparsely sampled data.

Access to sample (pixel) values and coordinates is provided by
Accessor interfaces. These exist in variants for integer and real
coordinates, as well as iterating and random access. For iterating
accessors, iteration order is subject to implementation, specia-
lized for each memory layout to minimize access time.

Accessors provide value access via Types. ImgLib2 has a hier-
archy of Type interfaces that describe algebraic properties of
families of concrete types. Examples are Comparable types or
NumericTypes that support basic arithmetic operations
(+7—9*9/

Access patterns and type properties allow ﬁne-grained speciﬁ-
cation of algorithmic requirements. An algorithm that is built
using appropriate interfaces applies to any speciﬁc image imple-
menting those interfaces. Re-usability of algorithms is maximized
by specifying them for the minimal set of required properties.
Consider, for example, summing all pixel values in an image.
This can be implemented in two lines of Java code for, e.g. a
gray-level image stored as a byte[] array. However, it has to be
re-implemented, over and over, for every combination of data

 

© The Author(s) 2012. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/Iicenses/by/3.0), which permits
unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.

112 /810's112umo[pJOJXO'sopemJogutotq/pd11q wort pepeolumoq

910K ‘09 lsnﬁnV no :2

T.Pietzsch et al.

 

 

Fig. 1. Visualizes exemplarily the capabilities of ImgLib2. (a) shows an image, virtually extended by a mirroring strategy, arrows mark the original
image boundaries. Four algorithms were applied to sub-image views: (from left to right) anisotropic diffusion, maximally stable extremal regions, Sobel
ﬁltering, Gaussian convolution. at) shows an extrapolation of sparse data where 2,000 points were randomly sampled from the larger area indicated in
(a). (c) shows an interpolated and afﬁne transformed view of the smaller tilted area indicated in (a)

type, dimensionality and storage layout. Using ImgLib2, this can
be written generically as

for (T value : image) sum.add(va1ue);

where we specify that image implements Iterable(T) and that T
extends NumericType(T). The same code handles all pixel images
with appropriate value type, virtual views into such images, spar-
sely sampled datasets, procedural images, etc.

In Java, this level of generality requires pixels to be objects.
Storing simple pixel values (e.g. bytes) as individual objects, how-
ever, comes with signiﬁcant memory overhead. Conversely,
creating new objects per pixel access introduces signiﬁcant run-
time overhead and triggers frequent garbage collection. Both
approaches do not scale well with large images. To address this
issue, ImgLib2 uses proxy types to access pixel data that can be
mapped into Java primitive type arrays (byte[], ﬂoatl], etc.). In
this way, an accessor can re-use one proxy instance for all pixel
accesses. In the above example, a proxy of type T is instantiated
once and then re-used in every iteration, changing only internal
state. This virtualization pattern has no performance overhead
compared with direct array access, thanks to the optimizations
performed by Java’s just-in-time (JIT) compiler.

3 IMPLEMENTATION

ImgLib2 incorporates common value types (BitType, Unsigned-
ByteType, ARGBType, ComplexFloatType, etc.) efﬁciently im-
plemented as proxies that map into Java primitive type arrays.
Various implementations for pixel data in a discrete n-dimen—
sional grid (conventional pixel images) are provided: ListImg
stores pixels as individual object instances and thus supports ar-
bitrary value types, but does not scale to large numbers of pixels.
ArrayImg maps proxy types into a single primitive type array,
providing optimal performance and memory efﬁciency.
However, Java arrays are limited to a size of 231 (e.g. a square
2d image with maximally 46,340 px side length) which is easily
exceeded in today’s microscopy recordings. CellImg splits the
coordinate domain into an n-dimensional grid of cells, each map-
ping into one primitive type array. This enables signiﬁcantly
larger images (262 px) at slightly reduced performance. In
generic code we can transparently switch between image

implementations using image factories. This allows performance
tuning for speciﬁc datasets without any modiﬁcation to the al-
gorithm implementation.

We compared the performance of ImgLib2 generic code and
special purpose (ﬁxed dimensionality and value type) implemen-
tations for Java primitive type arrays and ImageJ
(Supplementary Table 51). For simple per-pixel operations, gen-
eric ImgLib2 code achieves 100% of the performance of special
purpose implementations using native arrays. For a more com-
plex operation involving an inner loop over the unknown
number of dimensions, the ImgLib2 code was on average
1.6x slower than native arrays (1.5x slower than ImageJ). We
consider this a reasonable abstraction penalty as the ImgLib2
code supports any dimensionality, image and value type. In con-
trast, native arrays and ImageJ images require specialized imple-
mentations for each supported dimensionality and value type.
For the cases tested in our benchmark, this amounts to an
order of magnitude increase in lines of code. Even so, only
ImgLib2 is able to handle all test cases due to dimensionality
and image size limits of both ImageJ and primitive type arrays.

ImgLib2 permits virtualization of sample access. We use
this for accessors that perform on-the-ﬂy coordinate and value
transformations without copying the underlying data. The
Views framework creates accessibles that provide coordinate-
transforming accessors. Integer coordinate transformations in-
clude slicing, windowing, axes permutations and 900 rotations.
Consecutive transformations are reduced and simpliﬁed, yielding
accessors with optimal performance. For real coordinates we
support n—dimensional afﬁne transformations. Interpolating
and rasterizing views convert between discrete and continuous
coordinate spaces. Finally, some algorithms (e. g. convolution)
require access to pixels outside of the image which are usually
created by padding or mirroring. This is achieved by extending
views, whose accessors generate outside values on demand. Note,
that views may be cascaded and act both as input and output for
pixel processing. Similarly, the Converters framework realizes
transparent transformation of values. For instance, a
FloatType image can be addressed as ByteType using an arbi-
trary mapping function.

ImgLib2 uses Bio-Formats (Linkert et al., 2010) to read and
write a large number of image ﬁle formats. Interoperability with

 

301 0

112 ﬁrosleumo[pJOJXO'sor1em10jurorw/2d11q uroxj pepeolumoq

910K ‘09 lsnﬁnV no :2

ImgLib2

 

ImageJ is provided by non-copying wrappers of ImageJ data
structures as ImgLib2 accessibles and vice versa. This makes it
straightforward to integrate ImgLib2 into existing ImageJ-based
processing pipelines. Light-weight wrappers for other data
models are easy to implement and currently exist for Java
AWT BufferedImage, Java primitive type arrays and remotely
stored image stacks (Saalfeld et al., 2009). ImgLib2 comprises
a growing collection of generic algorithms that are fundamental
building blocks for n-dimensional image analysis: the Fast
Fourier Transform can be used for tomography reconstruction,
pattern detection or (de-)convolution; sub-pixel edge detection
(Devernay, 1995), component trees (Nistér and Stewénius,
2008) and automatically detected interest-points (e. g. DoG and
MSER; Lindeberg, 1998; Matas et al., 2002) are important tools
for image segmentation, image registration and tracking; k—d
trees enable fast n-dimensional search.

Sparsely and irregularly sampled data are supported, stored
either as a sample list or in a k—d tree. Both implement interfaces
for nearest-neighbor search, allowing extrapolation of sparse
data into a continuous image. Sparsely sampled data, interpol-
ation, extension, coordinate transformation and several algo-
rithms are illustrated in Figure 1.

4 DISCUSSION

ImgLib2 is an open-source image processing framework that
increases code re-usability by promoting generic implementa-
tions. It provides an abstraction layer that focuses on ﬂexible
and efﬁcient image storage and access. The core paradigm is a
clean separation of pixel algebra (how sample values are manipu-
lated), data access (how sample coordinates are traversed) and
data representation (how the samples are stored, laid out in
memory or paged to disc). ImgLib2 relies on virtual access to
both sample values and coordinates, facilitating parallelizability
and extensibility.

ImgLib2 aims to connect software projects through an inter-
face design that is easily adapted to existing data structures.
ImgLib2 is the ﬁrst image processing library available for Java
that combines a ﬂexible high-level programming interface with
optimal performance. It enables developers of bioimage analysis
software to focus on the design of complex algorithms instead of
data management. Conversely, software engineers can develop
efﬁcient infrastructure without interfering with algorithm design.
This becomes particularly interesting in the emerging ﬁeld of
bioimage informatics that is coping with the enormous amount
of n-dimensional image data generated by recent developments in

microscopy. Consequently, ImgLib2 is already being used by
several high-proﬁle projects of the Java bioimaging community
(Berthold et al., 2009; Rueden et al., 2010; Schindelin et al.,
2012). It is easily integrated into other projects providing an
ideal basis for sharing interoperable, generic algorithms.

ACKNOWLEDGEMENTS

ImgLib2 and ImgLib have been supported by Fiji Hackathons
at the MPI-CBG, EMBL and LOCI. We gratefully thank all
developers and users that contributed, notably C. Rueden, B.
DeZonia, C. Dietz, M. Horn, L. Kamentsky, A. Cardona, J.
Schindelin, G. Harris, L. Lindsey, M. Longair, J .-Y. Tinevez,
N. Perry, J. Funke and S. Jaensch.

Funding: T.P., PT. and SS. were funded by MPI-CBG, S.P. was
funded by MPI-CBG and HHMI.

Conflict of Interest: none declared.

REFERENCES

Berthold,M.R. et al. (2009) Knime—the konstanz information miner: version 2.0
and beyond. SIGKDD Explor. Newsl, 11, 26—31.

Devernay,F. (1995) A non-maxima suppression method for edge detection with
sub-pixel accuracy. Technical Report RR-2724, INRLA.

K6the,U. (2000) STL-style generic programming with images. C++ Report Mag.,
12, 24—30.

Lindeberg,T. (1998) Feature detection with automatic scale selection. Int. J. Comp.
Vision, 30, 79—116.

Linkert,M. et al. (2010) Metadata matters: access to image data in the real world. J.
Cell Biol, 189, 777—782.

Matas,J., David,M. and Paul L.,R. (2002) Robust wide baseline stereo from max-
imally stable extremal regions. In: BM VC. Vol. 1, pp. 384—393.

Nistér,D., Stewénius,H., David,F., Philip,T. and Andrew,Z. (2008) Linear time
maximally stable extremal regions. In: ECC V. pp. 183—196.

Preibisch,S., Andreas,J. and Christian,M. (2010) Into imglib—generic image pro-
cessing in java. In: Proceedings of the Image] User and Developer Conference,
Luxembourg.

Rasband,W.S. ImageJ, U. S. National Institutes of Health, Bethesda, Maryland,
USA, http://rsbweb.nih.gov/ij/, 1997—2012.

Rueden,C., Andreas,J. and Christian,M. (2010) Imagejdev: next generation imagej.
In: Proceedings of the Image] User and Developer Conference,
Mondorf-les-Bains, Luxembourg.

Saalfeld,S. et al. (2009) CATMAID: collaborative annotation toolkit for massive
amounts of image data. Bioinformatics, 25, 1984—1986.

Schindelin,J. et al. (2012) Fiji: an open-source platform for biological-image ana-
lysis. Nat. Methods, 9, 676—682.

Yoo,T.S. and Westwood,J. (2002) Engineering and algorithm design for an image
processing API: a technical report on ITK—the insight toolkit. In: MM VR,
pp. 586—592.

 

301 1

112 [glO'SIBILInO[p.IOJXO'SODBIIIJOJIIIOIQ/ﬂ(11111 111011 pepeolumoq

910K ‘09 lsnﬁnV no 22

