APPLICA TIONS NOTE V0" 33.1%.iigi‘iéféiﬁéiiiiiﬁiﬁé’é

 

Sequence analysis

Advance Access publication August 20, 2014

BioBloom tools: fast, accurate and memory-efficient host species
sequence screening using bloom filters

Justin Chu*, Sara Sadeghi, Anthony Raymond, Shaun D. Jackman, Ka Ming Nip,
Richard Mar, Hamid Mohamadi, Yaron S. Butterfield, A. Gordon Robertson and lnanq Birol*

Canada’s Michael Smith Genome Sciences Centre, British Columbia Cancer Agency, Vancouver, BC V5Z 486, Canada

Associate Editor: Alfonso Valencia

 

ABSTRACT

Large datasets can be screened for sequences from a specific organ-
ism, quickly and with low memory requirements, by a data structure
that supports time- and memory-efficient set membership queries.
Bloom filters offer such queries but require that false positives be
controlled. We present BioBIoom Tools, a Bloom filter-based se-
quence-screening tool that is faster than BWA, Bowtie 2 (popular
alignment algorithms) and FACS (a membership query algorithm). It
delivers accuracies comparable with these tools, controls false posi-
tives and has low memory requirements.

Availability and implementaion: www.bcgsc.ca/platform/bioinfo/
software/biobloomtools

Contact: cjustin@bcgsc.ca or ibiro|@bcgsc.ca

Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on April 30, 2014; revised on June 26, 2014; accepted on
August 13, 2014

1 INTRODUCTION

Pipelines that detect pathogens and contamination screen for
host sequences so they do not interfere with downstream analysis
(Castellarin et al., 2012; Kostic et al., 2011; Tang et al., 2013; Xu
et al., 2014). The alignment-based algorithms that these pipelines
use provide mapping locations that are irrelevant for classiﬁca-
tion, and thus perform more computation than is needed. To
address this, we have developed BioBloom Tools (BBT).

BBT uses Bloom ﬁlters—probabilistic, constant time access
data structures that identify whether elements belong to a set
(Bloom, 1970). Bloom ﬁlters are similar to hash tables but do
not store the elements themselves; instead, they store a ﬁxed
number of bits for every element into a common bit array.
Thus, they use less memory, but queries to the ﬁlter may
return false membership (hits) because of hash collisions in the
common bit array. The false-positive rate (FPR) resulting from
these false hits can be managed by increasing the size of the ﬁlter
(Supplementary Material). Using Bloom ﬁlters for sequence cat-
egorization was pioneered by the program FACS (Stranneheim
et al., 2010). Here, we describe a Bloom ﬁlter implementation
that includes heuristics to control false positives and increase
speed.

 

*To whom correspondence should be addressed.

2 METHODS

We ﬁrst build ﬁlters from a set of reference sequences by dividing the
sequences into all possible k-mers (substrings of length k). We compare
the forward and reverse complement of every k-mer, and include the
alphanumerically smaller sequence in the ﬁlter. We calculate the bit sig-
nature of a k-mer by mapping the sequence to a set of integer values using
a ﬁxed number of hash functions (Supplementary Materials) (Broder and
Mitzenmacher, 2004). The bitwise union of the signatures of all the
k—mers constitutes a Bloom ﬁlter for the corresponding reference
sequences.

To test whether a query sequence of length l is present in the target
reference(s), we use a sliding window of k—mers. Starting at one end of the
query sequence, and shifting one base pair at a time along this sequence,
we check each k-mer against each reference’s Bloom ﬁlter. When a k-mer
matches a ﬁlter, we incrementally calculate a score:

where c is the number of contiguous stretches of adjacent ﬁlter-matching
k—mers until the current position in the query, and a,- is the length of the
i—th stretch. This heuristic penalizes likely false-positive hits. We evaluate
k—mers this way until we reach either a speciﬁed score threshold (5*) or
the end of the query sequence. If at any point we reach 5*, we categorize
the query as belonging to the reference, and terminate the process for that
query. Further, we use a jumping k-mer heuristic that skips k k—mers
when a miss is detected after a long series of adjacent hits. This efﬁciently
handles cases in which the query has a single (or a few) base mismatch(es)
with the target.

3 BENCHMARKING

We compared BBT against two widely used Burrows—Wheeler
transform-based alignment tools that have low memory usage
and high accuracy—BWA (Li and Durbin, 2003) and Bowtie 2
(BT2; Langmead and Salzberg, 2012)—and against the C++
implementation of FACS (https://github.com/SciLifeLab/facs).
Tool versions and other details are provided in the
Supplementary Materials.

3.1 Benchmarking on simulated data

We used dwgsim (https://github.com/nhl3/DWGSIM) to gener-
ate simulated Illumina reads from human, mouse and
Escherichia coli reference genomes. For each genome, we gener-
ated 1 million 2 x 150 bp paired-end (PE) reads and 1 million
100 bp single-end (SE) reads. We used Ecoli because it is a
common contaminant and is genetically distant from human.

 

© The Author 2014. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/Iicenses/by—nc/4.0/),
which permits non-commercial re—use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact

journals.permissions@oup.com

112 /310's113umo [p.IOJXO'SOTlBIHJOJUTOTCI/ﬁdllq 11101; pepBOIUAAOG

9IOZ ‘091sn3nv uo ::

BioBIoom tools

 

1.000 A

 

D-
ED
'-~.'l
U1
D
IUD-
1.4
III

5

Tim-I
-— en T

 

a'
s“ FACS

Tme Fosﬂtive Ftate
.m .
HI
ID

True Punitive Ftate
m .
U'l
“'7'

 

0.025:

0.025 {

easel - r . I .
new” 2.55mi“5 53:10” 153:10—5 1x10—
False Festive Rate

3

i
I
_I

 

 

 

'——' El 900

1'.

'ux10*:'2.sxtu'2 5x111"? T.5x10‘£ 1x10"
False Pustlve Hate

BT2 very sensitive
BT2 sensitive I
Tm BT2 fast {-

_ BBT BT2 very fast I‘

rites BWA mem I
ewe aln |

FACS l

BBT :1

111-11 2:511]

 

51:10 I 9110 211300 scion 101311.10
ICPU TIrne [mtns]

Fig. 1. Performance comparisons of BBT against FACS, BWA and BT2. Receiver operator characteristic curves of BBT and FACS using simulated
100 bp SE reads from Homo sapiens mixed with (A) E.coli and (B) Mus musculus ﬁltered against an H .sapiens Bloom ﬁlter using a k-mer size of 25 bp; (C)
CPU time benchmark comparing BT2 (for a range of built-in settings), BWA (using aln and mem settings), FACS and BBT, on one lane of human

2 X 150 bp PE Illumina HiSeq 2500 reads

With mouse, which is commonly used in xenograft studies, we
tested categorization accuracy for species that are closely related
genetically.

Because FACS does not support PE reads, we used the 100 bp
SE reads to compare the false- and true-positive rates (FPR and
TPR, respectively) of BBT and FACS. We tested a range of
scoring thresholds for both tools. Using a k—mer size of 25 bp,
BBT generally matched or outperformed FACS (Fig. 1A and B).
We note that, for shorter k-mers, performance of BBT and
FACS algorithms would deteriorate, especially in distinguishing
sequences from closely related references. For both tools, longer
k—mers gave lower FPR but also lower maximum TPR
(Supplementary Figs S1 and S2), with BBT performing increas-
ingly better than FACS for longer k—mers.

To compare BBT and FACS to BWA and BT2, we used
2 X 150 bp PE reads. In our tests, overall, BBT performed com-
parably with the aligners and outperformed ‘fast’ and ‘very fast’
settings of BT2 in both false-negative rate (FNR) and false-
discovery rate (FDR; Table 1).

3.2 Benchmarking on experimental data

We used a single lane of 2 X 150 bp PE human DNA reads
(https: //basespace.illumina.com/run/7l6717/2xl50-HiSeq-2500—
demo-NA12878) generated with an Illumina HiSeq 2500 sequen-
cer to benchmark computational performance. For a controlled
comparison, we ran at least eight replicates for each tool, and we
measured CPU time, with all applications using a single thread.

We ran BBT with 5* = 0.1 and compared it with FACS, BWA
and BT2, using a range of run modes for the latter two tools. BBT
was faster than the fastest aligner/settings combination (BT2 very
fast) by at least an order of magnitude (Fig. 1C). The mapping
rates (categorization rates for BBT and FACS) of each tool were
comparable, at 96.69 (BT2 very sensitive), 96.57 (BT2 sensitive),
96.18 (BT2 fast), 95.97 (BT2 very fast), 99.76 (BWA mem), 95.12
(BWA aln), 95.81 (FACS) and 97.27% (BBT).

3.3 Memory usage

For categorization, using the human reference and simulated
reads, the peak memory usage (GB) for each tool was 3.8
(BBT), 4.8 (FACS), 3.1 (BWA aln), 5.2 (BWA mem) and 3.4
(BT2). These ﬁgures are for categorization only and do not

Table 1. Benchmarking results using simulated paired end 2 X 150 bp
reads

 

 

Tool and Settings FNR FDR FDR
(H .Sapiens ) (M .musculus) (E.coli)

BT2 very sensitive 1.40 X 10’5 2.03 X 10’2 0

BT2 sensitive 7.52 x 10*4 9.08 x 10*3 0

BT2 fast 1.26 x 10*2 5.90 x 10*3 0

BT2 very fast 1.34 x 10*2 5.65 x 10*3 0

BWA aln 3.26X10’3 8.14X104 0

BWA mem 0 1.92 x 10*1 1.00 x 10*4
FACS 1.22 x 10*1 9.88 x 10*3 0

BBT (s* = 0.1) 8.42 x 10*3 3.78 x 10*3 0

 

Note: All reads were treated as SE reads for FACS.

include the memory usage for creating the FM-indexes or
Bloom ﬁlters. Unless slower disk-based methods are used, creat-
ing an FM-index takes at least O(nlog(n)) bits of memory, where
n is the size of the reference sequence (Ferragina et al., 2012). In
contrast, Bloom ﬁlter memory usage is the same for the creation
and categorization stages, and takes O(—nlog(f)) bits of memory,
where f is the FPR and n is the number of input sequences.

We created ﬁlters using 3.2 GB of memory for both FACS and
BBT. Assuming optimal numbers of hash functions are used,
ﬁlters with the same size should have similar FPRs. However,
in practice, we had to use different FPR settings in creating these
ﬁlters (FPR of 0.5% for FACS and 0.75% for BBT). We note
that the tools would differ from theoretical estimates because of
implementation-speciﬁc calculation differences.

Finally, to demonstrate the scalability of BBT, we built a
ﬁlter for 5182 bacterial sequences (representing 6 X 1010 unique
25-mers), using 6.8 GB of memory, corresponding to an FPR of
0.75%.

ACKNOWLEDGEMENTS

The authors thank Genome Canada, British Columbia Cancer
Foundation, and Genome British Columbia for their support,
and Irene Li, Rene Warren and Karen Mungall for useful
discussions.

 

3403

112 /810's113umo [p.IOJXO'SOIlBIHJOJUIOICI/ﬁdllq 1110131 pepBOIUAAOG

9IOZ ‘091sn8nv uo ::

J.Chu et aI.

 

Funding: The work was funded by Genome Canada, British
Columbia Cancer Foundation and Genome British Columbia.

Conﬂict of interest: none declared.

REFERENCES

Bloom,B.H. (1970) Space/time trade-offs in hash coding with allowable errors.
Commun ACM, 13, 422—426.

Broder,A. and Mitzenmacher,M. (2004) Network applications of bloom ﬁlters: a
survey. Int. Mat/1., 1, 485—509.

Castellarin,M. et al. (2012) Fusobacterium nucleatum infection is prevalent in
human colorectal carcinoma. Genome Res., 22, 299—306.

Ferragina,P. et al. (2012) Lightweight data indexing and compression in external
memory. Algorithmica, 63, 707—730.

Kostic,A.D. et al. (2011) PathSeq: software to identify or discover microbes by deep
sequencing of human tissue. Nat. Biotechnol., 29, 393—396.

Li,H. and Durbin,R. (2003) Fast and accurate short read alignment with Burrows-
Wheeler transform. Bioinformatics, 25, 1754—1760.

Stranneheim,H. et al. (2010) Classification of DNA sequences using bloom ﬁlters.
Bioinformatics, 26, 1595—1600.

Tang,K.-W. et al. (2013) The landscape of viral expression and host gene fusion and
adaptation in human cancer. Nat. Common, 4, 2513.

Xu,G. et al. (2014) RNA COMPASS: a dual approach for pathogen and host
transcriptome analysis of RNA-Seq datasets. PLoS One, 9, e89445.

 

3404

112 /810's112u1no [p.IOJXO'SOllBIIHOJUIOIQ/ﬁdllq 1110131 pep1201umoq

9IOZ ‘091sn8nv uo ::

