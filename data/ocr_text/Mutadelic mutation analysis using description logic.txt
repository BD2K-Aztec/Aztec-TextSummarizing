Bioinformatics, 31 (23), 2015, 3742—3747

doi: 10.1093/bioinformatics/btv467

Advance Access Publication Date: 12 August 2015
Original Paper

 

Genome analysis

Mutadelic: mutation analysis using description
logic inferencing capabilities
Matthew E. Holford1 and Michael Krauthammer1'2'*

1Program in Computational Biology and Bioinformatics and 2Department of Pathology, Yale University School of
Medicine, New Haven, CT, USA

*To whom correspondence should be addressed.
Associate Editor: John Hancock

Received on September 30, 2014; revised on July 31, 2015; accepted on August 4, 2015

Abstract

Motivation: As next generation sequencing gains a foothold in clinical genetics, there is a need for
annotation tools to characterize increasing amounts of patient variant data for identifying clinically
relevant mutations. While existing informatics tools provide efficient bulk variant annotations, they
often generate excess information that may limit their scalability.

Results: We propose an alternative solution based on description logic inferencing to generate
workflows that produce only those annotations that will contribute to the interpretation of each
variant. Workflows are dynamically generated using a novel abductive reasoning framework called
a basic framework for abductive workflow generation (AbFab). Criteria for identifying disease-
causing variants in Mendelian blood disorders were identified and implemented as AbFab services.
A web application was built allowing users to run workflows generated from the criteria to analyze
genomic variants. Significant variants are flagged and explanations provided for why they match
or fail to match the criteria.

Availability and implementation: The Mutadelic web application is available for use at http://

 

krauthammerlab.med.yale.edu/mutadelic.
Contact: michael.krauthammer@yale.edu

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

Distinguishing harmful from benign variants in clinical exome or
whole genome sequencing is comprised of two steps: Variant anno-
tation and interpretation. Annotation involves the labeling of vari-
ants with diverse features, including population frequencies and
effect on amino acid composition, which then guide interpretation
for finding variants with damaging effect on protein function (what
we call variant prioritization).

There are several annotation systems that assist medical geneti-
cists in the prioritization of a patients variants. Some of the existing
systems, including Annovar and VAX (Wang et al., 2010; Yourshaw
et al., 2014), can accommodate custom annotations for guiding
a geneticists decision process. As most annotations can be pre-
computed and efficiently retrieved, these systems can rapidly anno-
tate most or all variants in a human genome.

While these existing systems are an invaluable tool for medical
geneticists, they do have some shortcomings. First, they do not ad-
dress the need to accommodate several variant filters based on dis-
ease-, and often expert-dependent interpretation rules. Second, as
some annotations cannot be easily pre-computed, like complex
Indels, or substrate binding properties, the computational cost of
generating annotation for all observed variants is high. Third, as the
number of annotations increases, storing the complete set of annota-
tions for all variants is progressively costly. Fourth, as data resources
are changing over time, there is a need to recompute the entire set of
variants for retrieving the most current annotations. Fifth, there is
little emphasis on using standards or provenance when generating
variant annotations.

What we propose in this article is a fresh look at how we per-
form variant prioritization. Rather than annotating all observed

©The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 3742

9mg ‘09 isnﬁnV uo seleﬁuV soq ‘erulomeg JO AirSJeAru [1 112 ﬂJO'sleumo[pJOJXO'soneuuogurorq/ﬁdnq wort pepeolumoq

Mutadelic

3743

 

variants, with subsequent interpretation, we propose to merge the
two steps into a single process that reduces the necessary annota-
tions to the minimum number necessary. To do so, we borrow from
prior work in semantic workﬂows, and related fields such as hier-
archical task network planning. In essence, we allow geneticist to
formulate an objective (identify variants with a particular annota-
tion combination), which is sufficient to generate an efficient plan
for a series of annotation steps (a workﬂow) to which each variant
is subjected. If at any point in the workflow it is determined that the
objective cannot be reached, the variant under consideration is
dropped from further consideration. Using smart workflow plan-
ning, computationally cheap annotation steps are front-loaded. For
example, if the objective states that the geneticist is interested in
variants with a specific population frequency only (a simple data-
base lookup), many variants with higher frequency can be discarded
at an early stage and do not need further annotations. If a workﬂow
completes successfully, only the absolute necessary annotations
were computed to reach the objective. Using elements from semantic
workﬂow research, we treat each annotation step as a separate ser-
vice with semantically defined input and output criteria. The use of
a service-oriented architecture has distinct advantages; among them
a straightforward procedure for determining whether a variant
needs re-computing. For example, only variants that have been
subjected to a particular annotation service need re-processing if the
service is updated. Finally, the use of a coherent semantic frame-
work, expressed in RDF/ OWL, is not only helpful in workflow plan-
ning, but also for defining diverse sets of annotation objectives, for
generating a provenance trail, and to link annotated variants to
other resources using constrained data elements.

2 Approach

2.1 Mutadelic overview

Our system, which we call Mutadelic, is based on workflows that
are created based on the user’s objectives for variant classification
(i.e. what characteristics a mutation will have that an ordinary vari-
ant will not). To build these workflows, Mutadelic relies upon
abductive reasoning. Abductive reasoning differs from the more fa-
miliar deductive reasoning in which logical rules are used to derive
unstated inferences from an asserted KB. Abductive reasoning in-
stead takes an initial KB (KBI) and a resulting observation (0) and
determines what statements need to be added to KBI to allow 0 to
be logically inferred. Using ontologies, we express the geneticist’s
objective (identify variants with a particular annotation combin-
ation) as a variant class with a set of annotations and restrictions on
annotations. We also represent observed patient variants as individ-
uals of the variant class, with initially no annotations added. The
overall goal of the abductive reasoning workﬂow is to progressively
add annotations to the individual, until the geneticist’s defined vari-
ant class subsumes this individual. Annotation services are an im-
portant part of this process, as it is they that add the necessary
annotations. Conceptually, the process starts from the objective,
iterating through the defined annotations and restrictions identifying
those that can be addressed by the computationally cheapest service.
Once the first annotation is added to the individual (variant), and
the annotation complies with the stated restriction, the process
addresses the next annotations. Some defined annotations can only
be addressed by a combination of annotation services. In these cases,
automated workflow generation allows the chaining of services
based on semantic service descriptions. For example, if the objective

states that the ‘variant should be in a protein domain’, the workﬂow
needs to chain at least two services that first map the variant to
some amino acid position and then checks whether the position is
located in a protein domain. As the services add annotation, they
also provide provenance information that allows the reconstruction
of the chain of services.

2.2 KB representation

Mutadelic is built on a description logic (DL) model described in
the Web Ontology Language (OWL). It uses and extends classes
and properties from the Scientific Information Ontology (510)
and Genomic Element Ontology (GELO). We represent genomic
variants as subclasses of the GELO GenomicElement class. GELO
provides data properties to represent locus_start, locus_end,
(observed) sequence and strand as literal values. An object prop-
erty on_chromosome points the variant to an instance of SIO’s
chromosome class. To represent the reference sequence, we use
SIO’s is_modelled_by property and restrict it to an individual with
a string value filled by the 510 has_value data property.
Annotations of variants are represented by the following pattern.
A class Annotation is defined as an extension of the 510 descrip-
tion class. An Annotation uses the 510 cites property to connect it
to its provenance (an instance of SIO’s information_content_entity
or one of its subclasses). The variant is connected to the
Annotation via the 510 is_described_by property. The annotated
variant is connected to the actual data through the 510 refers_to
property. The refers_to property is restricted to a particular
information_content_entity or subclass thereof (e.g.
VariationOutcome, VariationDomainColocation, etc.). Many an-
notation data classes extend the SIO bioinformatic_data class, it-
self an extension of information_content_entity. Examples include
PhylopScore and SiftScore. Finally, the annotation data class is as-
signed its actual value through the has_value data property which
is filled by a literal representation of the actual data. Figure 1 illus-
trates the representation of a typical variant in OWL.

/ SiftAnnotatedVariant \
is_described_by
/ Variant \

Annotation

 

 

 

      

is_modelled_by

refe rs_to

has_locus

 

sequence

locus_end

on_chromosome

xk / /

Fig. 1. An illustration showing how variants are represented in OWL in
Mutadelic. The diagram show SiftAnnotatedVariant as an example.
Rectangles at the same vertical level reflect conjunction. For example,
SiftAnnotatedVariant is a Variant and is_described_by some Annotation

  

 

 

 

Chromosome

 

 

9mg ‘09 isnﬁnV uo sejeﬁuV soq ‘erulomeg JO AirSJeAru [1 112 ﬁlO'Sjeumo[pJOJXO'soriemJOJurorw/zdnq wort pepeolumoq

3744

M.E.Holford and M.Krauthammer

 

2.3 AbFab

2.3.1 Services

An abductive reasoning framework for workﬂow generation is a
central focus of development and a key contribution of this project.
OWL does not provide semantics for abductive reasoning and most
DL reasoners do not provide abductive reasoning capabilities out of
the box. To fill this gap, we developed the a basic framework for
abductive workflow generation (AbFab) tool. AbFab represents
workﬂows as paths connecting services. Services are OWL classes
which are constrained by the class of input that is required and the
class of output that will be generated. In OWL, this is implemented
very loosely as a Service class with restrictions on object properties
has_output and has_input that may be filled by any OWL class ex-
pression. Other than this basic requirement, AbFab can support
OWL domain models of arbitrary complexity. The service class also
contains a reference to the process that should be run when the ser-
vice is executed. In service execution, an instance fitting the input
constraint is passed to the execution process. Services add facts to
the input instance, such that the instance will be a member of the
specified service output class. By separating the actual execution of
services from the workﬂow model, AbFab allows access to proced-
ures that must, for performance reasons or because the results are
non-deterministic, operate outside the context of a DL reasoner
while still maintaining a formal logical structure over the workﬂow
as a whole. Figure 2 illustrates the structure and representation of
AbFab services.

2.3.2 Workﬂow generatiorﬂexecution

AbFab operates in two phases: staging and execution. In the staging
phase, AbFab takes as input: (i) an object called an IndividualPlus,
which consists of an OWL individual and the set of OWL axioms
describing that individual which would be added to the KB, and (ii)
an OWL class expression which describes the goal output. It uses
the KB of available services to determine a sequential path of ser-
vices which, when executed would lead to an IndividualPlus consist-
ing of the original OWL individual plus new axioms that would
cause that individual to be consistent with the goal class. There are
three types of steps which can be combined to form a path. Simple
steps execute a single service. Branches are used where two or more

/’____‘
, INPUT \‘
SERVICE II

I
fﬁ E] 1;) /'\____’,
SERVICE  .... .._
\—/-\ {TN'th'Tx
I fact1 (prov1)}

(a I

 

I fact1 (prov1)|

/ l fact2 (prov2) I

SERVICE \ I

/ 
\fﬁﬁﬁﬁ‘x‘

I fact1 (prov1) I
l fact2 (prov2) I

/ \ fact3 (prov3),
\ _ _ _ _ a

Fig. 2. The diagram on the left provides a representation of AbFab services in
OWL. The diagram on the right shows how services add information and
provenance to input such that it ultimately fulfills the constraints of the goal
criteria. This generated workflow is referred to as an AbFab path

\
- , INPUT ‘
(a

has_executable

 

 

r'9.

 

 

 

services must be called to fulfill the input criteria of the next step.
This corresponds with a logical AND condition. The output will be
a new IndividualPlus which merges the set of axioms resulting from
each service call. Conditions are used where two or more services
may be each alternatively used to fulfill the input criteria of the next
step. This corresponds with a logical OR condition. Conditions are
useful for workflows where the next step of execution is the depend-
ent on the result of the previous service and therefore not available
until the execution phase. Branches and conditions are illustrated in
Figure 3.

Internally, the path is created in reverse, by first finding ‘ter-
minal’ services (i.e. services whose output satisfies the goal class)
and then adding services whose output satisfies the input of the next
step. When the initial input satisfies the input criteria of the top ser-
vice, the path is complete. Determining whether service inputs/out-
puts are satisfied is performed by the DL reasoner through class
subsumption checking. Specifically, the output class of a service
must be subsumed by the input class of the next step. For example,
if some service 81 produces an output of class A and B, it would sat-
isfy the input criteria of a service 82 which required input of class A
but not that of a service S3 which required input of class A and B
and C. To determine if the initial input satisfies the input criteria of
the top service, an instance check is performed. This will determine
if the initial input can be declared as an instance of the input criteria
for the top service without rendering the model inconsistent.

Once all possible paths from initial input to goal output are
determined, a cost function is used to determine the best path. The
cost function is useful in that it prevents tasks that take a long time
to run or consume a large amount of computational resources from
being run unless absolutely necessary. The cost function is also used
to determine the order in which the multiple services within a
branch are executed and the sub-paths of a conditional are at-
tempted. In both cases, the cheapest services are executed first. Our
current cost function assigns a quantitative value to a service by fill-
ing the data property has_cost of a Service individual with a numer-
ical literal expressing the relative expense of execution. Statically
assigning a cost to a service is a fairly naive approach and in future

 

 

( INPUT) I INPUT)
\ _____ __,l \ _____ _,l
@151  _________________ __
- -
- - -

 

 

 

{’Tﬁﬁﬁf‘xl I’TN'I5LTf‘\I I’TN'EJf‘xl (TN—ﬁﬁf‘xl {’l—NPUT \l
I fact1 (prov1)) |\fact2 (prov2)) j fact3 (prov3)| I fact1 (prov1)) |\fact2 (prov2 I
I s_____/ \\ \

\_____ I \‘_____, _____,

\

,
\
x ’ a ’ SERVICE SERVICE

|fact2 rov2
\\fact3 grov3 I

——.’

I fact1 gprov1§ :
/

 

Fig. 3. The diagram on the left illustrates a goal which is fulfilled by the output
of three separate services A branch is formed which joins the three outputs.
The diagram on the right illustrates a case where the input criteria of different
services may be fulfilled depending on the output of a prior service. Because
this result is not known until execution time, a condition is created which
forms separate paths depending on the output ofthe prior service

9mg ‘09 1sn8nV uo sejeﬁuV soq ‘121u10111123 10 A1rSJeAruf1 112 /810'S{12umo[p101x0'831112u1101u101q/ﬁd11q 111011 pepeolumoq

Mutadelic

3745

 

versions we wish to implement cost values that are dynamically as-
signed based on input to the service. Another type of case is one in
which multiple Services are capable of fulfilling a goal criteria.
Suppose, for example, that an arbitrary ServiceA consumes more re-
sources but yields more precise or reliable results than a less costly
version, ServiceB. It may be preferable in some cases to prefer the ac-
curacy of ServiceA and in others the speed of ServiceB. The inclusion
of a quality metric to the cost function is an area of future research.
In the execution phase, the initial input IndividualPlus is passed
down the chain of services, acquiring axioms from each step as it
goes. At each level, the IndividualPlus is tested using consistency
checking to make sure that it matches the criteria to continue and in
the case of a condition whether to attempt a different fork. Since DL
reasoner operations such as consistency checking are potentially
time-consuming and computationally expensive, a variety of opti-
mizations are made to keep AbFab performing efficiently. These op-
timizations are discussed in Supplementary Methods section.

2.4 Services for Mutadelic

A number of AbFab Services were defined in this project to corres-
pond with tasks commonly used for variant analysis. These include
Services which obtain Sift scores (measuring impact of a DNA vari-
ant on protein formation), PhyloP scores (measuring the level of evo-
lutionary conservation of a genomic region), allele frequencies
(measuring the rarity of a variant in healthy populations) and infor-
mation about critical protein domains obtained from the PFAM
database. Typically these services are written in Java and will ac-
quire the data from a local database and attach it to the set of OWL
axioms held by the input object. A large amount of data is required
locally for these services. For example, the PhyloP database assigns a
score to every base on the gene-coding regions of the chromosome.
The Sift database calculates scores for all nucleotide substitution
possibilities at each exonic position. We store these large collections
of data in MongoDB (http://www.mongodb.org), one of the better-
established of a number of ‘No-SQL’ databases that have recently
come into vogue. In MongoDB, data are stored in large document-
like structure rather than relational tables; schema are ﬂexible and
dynamic. Data can be retrieved rapidly as it is stored in simple
indexed key-value pairs. We found the combination of performance
and flexibility offered by MongoDB to be ideal for our purposes.

3 Results

3.1 Mutadelic implementation

3.1.1 Motivation

The most notable disorders of red cell membranes in humans are
hereditary spherocytosis (HS), hereditary elliptocytosis (HE) and
hereditary pyropoikilocytosis (HPP). They are inherited disorders,
marked by genetic heterogeneity, that are linked to hemolytic an-
emia (Mohandas and Gallagher, 2008). HS is characterized by
erythrocytes that are spherical in shape rather than the expected
olive-shaped conformation (Perrotta et al., 2008). HS is a fairly
common disorder, especially among Northern European popula-
tions where it occurs in 1:1000—25 00 individuals. It most frequently
manifests itself in the form of mild to moderate anemia, although se-
vere anemia can occur in some cases. HS is characterized by muta-
tions in the following genes: ANK1 (ankyrin 1, erythrocytic),
SLC4A1 (solute carrier family 4, anion exchanger, member 1
[erythrocyte membrane protein band 3, Diego blood group)], SPTB
(spectrin, beta, erythrocytic), SPTA1 [spectrin, alpha, erythrocytic 1
(elliptocytosis)] and EPB42 (erythrocyte membrane protein band

4.2). Of these five, mutations in ANK1 are most frequent, followed
by SLC4A1 and SPTB (Gallagher, 2004a). HE results in elongated,
cigar-shaped erythrocytes. It is most frequently asymptomatic but
will occasionally lead to mild or even severe anemia (Gallagher,
2004b). It is also fairly common (1:2000—4000), with higher inci-
dence in African populations (estimated as high as 1:100). HPP is
related to HE but is much more severe. It is characterized by large
numbers of fragmented and misshapen erythrocytes and results in
severe hemolytic anemia. Mutations in SPTA1, SPTB and EPB42 are
associated with HE and HPP, with SPT1 being the most frequent.
Most documented mutations modify the self-association regions of
spectrin proteins which causes damage to cell membrane structure
(Zhang et al., 2001).

3.1.2 Criteria
An initial test workﬂow was created which would prove useful for
the analysis of variants on a set of five genes associated with
Mendelian blood cell disorders. The workﬂow defines a potential
mutation as one that either (i) has been recognized as a disease-caus-
ing mutation by the Red Cell Membrane Disorder Mutations
Database (http:// research.nhgri.nih.gov/RBCmembrane) or (ii) is
extremely rare in healthy populations (<0.01 MAF) and either (a)
occurs at a splice site, (b) is considered severely damaging to the re-
sulting protein (<0.05 SIFT score), (c) occurs in a highly conserved
region (>1.0 PhyloP score) or ((1) occurs in a region that codes for a
critical domain of the protein.

Specific services to perform these checks are implemented as (i)
)

TranscriptLocalSpliceService, (iib) PhylopConservedService, (iic)

KnownMutationService, (ii) VariantFrequencyRareService, (iia

SiftSevereService and (iid) InCriticalDomainService. In addition, a
handful of services are required which perform prerequisite
tasks. For example, the Red Cell Mutations database identifies vari-
ants by position relative to the transcript rather than genomic pos-
ition so a preliminary conversion from genomic to transcript-based
position is required. This conversion is handled by the
AlignVariantService. AlignVariantService is also a prerequisite for
TranscriptLocalSpliceService. Each of PhylopConservedService,
SiftSevereService and InCriticalDomainService need consider only
non-synonymous variants. Hence, a prerequisite service
(AAChangeNonSynonymous) is required. This in turn requires
the determination that a variant occurs in the protein-coding
region of a transcript. Again a prerequisite service
(TranscriptLocaleProteinCodingService) is required, which in turn
requires AlignVariantService as a prerequisite. Finally as part of the
optimization process, two marking services are generated by AbFab.
This process is discussed in detail in the Supplementary Methods
section. The first (MarkedUniqueVariantService) marks the disjunc-
tion of TranscriptLocaleSpliceService, PhylopConservedService,
SiftSevereService and InCriticalDomainService; the second
(MarkedRareAndUniqueVariantService) marks the conjunction of
VariantFrequencyRareService and MarkedUniqueVariantService.
The full criteria for interesting variants is illustrated in Figure 4.

3.1.3 Web application

Mutadelic has a web application front end. A RESTful Web Service
(Fielding and Taylor, 2002) was implemented using (http://jersey.
j ava.net), a library implementing the Java JAX-RS standard. The fol-
lowing resources are defined: Users, Workﬂows, Inputs, Variants,
Outputs and AnnotatedVariants. Workﬂows define the criteria that
is used to determine whether a variant is significant. They are owned
by Users. Inputs are bound by a Workﬂow and hold the collection

9mg ‘09 1sn8nV uo sejeﬁuV soq ‘121u10111123 10 A1rSJeAruf1 112 /810'S{12umo[p101x0'831112u1101u101q/ﬁd11q 111011 pepeolumoq

3746

M.E.Holford and M.Krauthammer

 

 

 

 

 

 

Fig. 4. An illustration showing the criteria used to identify significant variants
in Mutadelic. The map provides an overview of services which are called by
the workflow path. Auto-generated marker services are highlighted in dashes

of Variants which the user is analyzing. Outputs are tied to a par-
ticular Input and hold a collection of AnnotatedVariants which are
annotated with the results of performing the Workflow analysis.
Resources are stored in MongoDB collections and mapped to Java
classes via the Morphia Object-Relational Mapping (ORM) tool.
The web application runs on the Grizzly container for highly scal-
able Java server applications (https://grizzly.java.net).

The front end is a simple Ajax-based single-page application.
The user is allowed to input genomic variants individually or in a
file. Once variants are submitted, an instance of AbFab running on
the Mutadelic server will generate and execute workﬂow paths for
each variant. Once AbFab is finished running, the front end will
show all variants, highlighting those determined to be interested.
The user can click on a variant to view the annotations that were
added by the Mutadelic server. Annotations contributing to an inter-
esting status are highlighted. The Mutadelic web application uses
Bootstrap as a U1 design framework (http://getbootstrap.com). We
used knockout.js as a data binding library (http://knockoutjs.com)
and jQuery for Ajax interaction with the server and additional
Javascript functionality (http://j query.com).

3.2 Validation

To test the effectiveness of Mutadelic in identifying harmful vari-
ants, we attempted to validate the curated set of disease-associated
variants at the Red Cell Membrane Disorder Mutations Database.
(This is the same database we use in Mutadelic to flag variants previ-
ously determined to be disease causing. For obvious reasons, we dis-
abled that portion of the criteria for this validation.) Eliminating a
handful of intergenic variants, we tested 119 variants associated
with HS and 43 variants associated with HE/HPP (Fig. 5).
Mutadelic performed well for both sets of variants, ﬂagging 106 of
119 HS variants (89.0%) and 38 of 43 HE/HPP variants (88.4%).
Overall, performance was somewhat better for point variants (103
of 112; 92.0%) than for indels (41 of 50; 82.0%). Identification of
deleterious indels could be improved by adding a service which de-
termines if critical domains of a protein prevented from forming by
a frameshift caused by a mutation. Such a service is further
described in the Future section. Of the 18 variants not ﬂagged by
Mutadelic, only two were not at least found to be rare variants and
those two were borderline cases (0.02 and 0.05 versus the 0.01

HE HSIHPP All
Mutations Mutations Mutations

Point

Mutations

lnDel
Mutations

All
Mutations

 

Fig. 5. Mutadelic was used to validate the HS and HE/HPP associated variants
curated by the Red Cell Membrane Disorder Mutations Database. In the pie
charts, the green regions indicate disease-associated variants successfully
flagged by Mutadelic and the red regions indicate those missed

threshold). A significant number not identified (5 of 18) were in-
tronic variants and it should be noted that few effective metrics for
variant prioritization of introns exist.

4 Discussion

This work discusses clinical variant prioritization using DL reason-
ing, and bears similarities to existing ideas from the fields of seman-
tic workflow generation, and related fields such as hierarchical task
network planning. The key elements of our approach, in short, are
the ability to express a goal or objective, and a system that decides
whether an observed individual (variant) complies with the object-
ive. To do so, we need, in a staging phase, means to automatically
chain together existing variant annotation services, using semantic
descriptions of these services. There is extensive prior work in this
area (Zhao and Paschke, 2012), with several formalisms for web ser-
vice description available, such as SWASDL (Kopecky et al., 2007).
There exists integrated systems that perform workflow generation
based on such descriptions, including the WINGS system (Gil et al.,
2010, 2011) or TAVERNA (Oinn et al., 2004). These existing for-
malisms and systems are generic, and can be applied to diverse do-
mains and research areas. Unlike WINGS, which supports
automated workﬂow generation, but delegates service execution to
external systems such as PEGASUS (Deelman et al., 2005), our sys-
tem integrates workﬂow planning and execution in one formalism.
While TAVERNA’s emphasis is less on automated workflow gener-
ation, it integrates workflow planning and execution in one plat-
form. Both systems do not provide the second requirement of our
system, which uses instance checking to determine whether the out-
put of a workflow (once executed), corresponds to some stated ob-
jective. There is some prior work (Sirin et al., 2004) that uses
hierarchical task network (HTN) planning on top of semantic web
service descriptions, to achieve a similar goal. However, the
described work is based on an existing task planning system, called
SHOP2 (Nau et al., 2003), which is not easily applicable to the
RDF/OWL formalism used in our project. In the bioinformatics do-
main, our approach is similar to the Semantic Automated Discovery
and Integration (SADI) framework (Wilkinson et al., 2010). SADI
describes web services for processing biomedical data in OWL. As in

9mg ‘09 1sn8nV uo sejeﬁuV soq ‘121u10111123 10 A1rs19Aru [1 112 /810'S{12umo[pJOJXO'soneIIJJOJHrorq/ﬁd11q 111011 pepeolumoq

Mutadelic

3747

 

AbFab, OWL classes with restrictions on input and output are used
to model services. The Semantic Health And Research Environment
(SHARE) SPARQL query client also functions by connecting ser-
vices to form a path of execution. Mutadelic/AbFab and SADI/
SHARE differ however in terms of their focus and their means of im-
plementing service paths. The focus of the SHARE is on answering
queries where data is spread out across multiple locations. AbFab
focuses instead on generation of workflows to process data where
services are defined locally. SHARE matches services based upon
whether execution of them adds the predicate requested by the query
to the KB (Vandervalk et al., 2009). AbFab uses consistency check-
ing to determine fulfillment of input and output constraints. This ap-
proach allows for more flexible matching and it does not require the
user to know the specifics of what triples services add to the KB.
The SHARE method requires that a step be executed before the next
step may be determined. AbFab generates the full path before execu-
tion, potentially saving considerable expense if a path to the goal cri-
teria cannot be reached. AbFab also offers the additional features of
a cost-based determination of optimal path and structures (Branches
and Conditions) to support complex paths. The ability to change
execution flow based upon runtime output allows AbFab to support
use cases beyond workflow generation, including decision trees and
the sort of query answering targeted by SADI/SHARE. Due to their
similar structure, it would be relatively straightforward to create
AbFab services that act as wrappers for SADI services.

The criteria used to highlight mutations of interest in Mutadelic
represents a single expert view on mutation prioritization within a
particular context, in this case Mendelian blood disorders. Different
criteria could be applied to the same context or criteria could be es-
tablished for different contexts, e.g. a different disease or family of
diseases. It is easy to imagine a scenario in which multiple criteria
co-exist. In such a scenario, researchers could compare different
methodologies for the same context or analyze patient data from
multiple contexts. To do so, we hope, in the near future, to provide
a U1 framework to allow users to define their own criteria to identify
significant variations. This would facilitate comparison of
approaches to variant prioritization. The challenge would be creat-
ing a user-friendly interface with the OWL representation of the 10-
gical constraints. This would be achieved using the current set of
defined services allowing for (i) modification of the faceted restric-
tions (e.g. changing significant SIFT value from 0.05 to 0.01) and
(ii) different combinations of conjunction, disjunction and negation
(AND, OR and NOT). Another optimization would be a frame-
work, either a U1 tool or an API for definition of new service classes.
Again, there is the challenge of hiding the complexity of OWL repre-
sentation from the user/developer.

5 Conclusion

This article describes a new variant annotation paradigm that is
based on the idea of generating the minimum necessary annotations
for reaching a diagnostically relevant conclusion. It is a departure
from existing solutions, which seek to annotate all observed vari-
ants. It is also, to our knowledge, the first attempt to use semantic
workﬂows and abductive reasoning for this purpose. We believe
that our solution will contribute to a more scalable informatics

infrastructure that is appropriate for next-generation sequencing-
based clinical genetics.

Acknowledgements

We thank Drs Jon Morrow and Pei Hui (Department of Pathology) and Drs
Patrick Gallagher and Vincent Schulz (Department of Pediatrics) for their
valuable input and guidance in designing Mutadelic. We are especially grate-
ful for their input into the crafting of genetic rules for identifying disease
variants.

Funding

Dr. Krauthammer was partially supported by the Yale SPORE in skin cancer
(NCI/5P50CA121974) and Dr. Holford was supported by the NLM biomed-
ical informatics training grant at Yale (NLM/T15LM007056)

Conﬂict of Interest: none declared.

References

Deelman,E. et al. (2005 ) Pegasus: a framework for mapping complex scientiﬁc
workﬂows onto distributed systems. Sci. Program, 13, 219—237.

Fielding,R.T. and Taylor,R.N. (2002) Principled design of the modern web
architecture. ACM Trans. Internet Tecbnol. (TOIT), 2, 115—150.

Gallagher,P. (2004a) Update on the clinical spectrum and genetics of red blood
cell membrane disorders. Curr. Hematol. Rep, 3, 85—91.

Gallagher,P.G. (2004b) Hereditary elliptocytosis: spectrin and protein 4.1 r.
Semin. Hematol., 41, 142—164.

Gil,Y. et al. (2010) Assisting scientists with complex data analysis tasks
through semantic workﬂows. In: AAAI Fall Symposium: Proactive Assistant
Agents.

Gil,Y. et al. (201 1) A semantic framework for automatic generation of compu-
tational workﬂows using distributed data and component catalogues.
]. Exp. Tbeor. Artif. Intell., 23, 389—467.

Kopecky,J. et al. (2007) Sawsdl: Semantic annotations for wsdl and xml
schema. Internet Comput. IEEE, 11, 60—67.

Mohandas,N. and Gallagher,P.G. (2008) Red cell membrane: past, present,
and future. Blood, 112, 3939—3948.

Nau,D.S. et al. (2003) Shop2: An htn planning system. ]. Artif. Intell. Res.
(jAIR), 20, 379—404.

Oinn,T. et al. (2004) Taverna: a tool for the composition and enactment of
bioinformatics workﬂows. Bioinformatics, 20, 3045—305 4.

Perrotta,S. et al. (2008) Hereditary spherocytosis. Lancet, 372, 1411—1426.

Sirin,E. et al. (2004) th planning for web service composition using shop2.
Web Semantics Sci. Services Agents World Wide Web, 1, 377—396.

Vandervalk,B.P. et al. (2009) Share: a semantic web query engine for bioinfor-
matics. In: Gomez-Perez,A. et al. (eds.) The Semantic Web, pp. 367—369.
Springer, Berlin Heidelberg.

Wang,K. et al. (2010) Annovar: functional annotation of genetic variants from
high-throughput sequencing data. Nucleic Acids Res., 38, e164—e164.

Wilkinson,M.D. et al. (2010) Sadi, share, and the in silico scientiﬁc method.
BMC Bioinformatics, 11, S7.

Yourshaw,M. et al. (2014) Rich annotation of DNA sequencing variants by
leveraging the ensembl variant effect predictor with plugins. Brief. Bioinf.,
16, 25 5—264.

Zhang,Z. et al. (2001) Dynamic molecular modeling of pathogenic mutations
in the spectrin self-association domain. Blood, 98, 1645—1653.

Zhao,Z. and Paschke,A. (2012) A survey on semantic scientiﬁc workﬂow.
Semantic Web]. I OS Press, 1—5.

9mg ‘09 1sn8nV uo SQIQBIIV soq ‘121u10111123 10 A1rs19Aru [1 112 /810'S{12umo[pJOJXO'soneIIJJOJHrotq/ﬁd11q 111011 pepeolumoq

