Bioinformatics, 32(5), 2016, 722—729

doi: 10.1093/bioinformatics/btv628

Advance Access Publication Date: 31 October 2015
Original Paper

 

 

Systems biology

Enumeration and extension of non-equivalent
deterministic update schedules in Boolean
networks

Eduardo Palma‘, Lilian Salinas1'3'* and Julio Aracenaz'3

1Departamento de lngenieria lnformética y Ciencias de la Computacion, Universidad de Concepcion, Piso 3,
Concepcion, Chile. 2Departamento de lngenieria Matematica, Universidad de Concepcion, Casilla 160-C,
Concepcion, Chile and 3Centro de lnvestigacion en lngenieria Matemética, CIZMA, Casilla 160-C, Concepcion,
Chile

*To whom correspondence should be addressed.
Associate Editor: Igor Jurisica

Received on March 13, 2015; revised on October 13, 2015; accepted on October 25, 2015

Abstract

Motivation: Boolean networks (BNs) are commonly used to model genetic regulatory networks
(GRNs). Due to the sensibility of the dynamical behavior to changes in the updating scheme (order
in which the nodes of a network update their state values), it is increasingly common to use differ-
ent updating rules in the modeling of GRNs to better capture an observed biological phenomenon
and thus to obtain more realistic models.

In Aracena et al. equivalence classes of deterministic update schedules in EMS, that yield exactly
the same dynamical behavior of the network, were defined according to a certain label function on
the arcs of the interaction digraph defined for each scheme. Thus, the interaction digraph so
labeled (update digraphs) encode the non-equivalent schemes.

Results: We address the problem of enumerating all non-equivalent deterministic update sched-
ules of a given BN. First, we show that it is an intractable problem in general. To solve it, we first
construct an algorithm that determines the set of update digraphs of a BN. For that, we use divide
and conquer methodology based on the structural characteristics of the interaction digraph. Next,
for each update digraph we determine a scheme associated. This algorithm also works in the case
where there is a partial knowledge about the relative order of the updating of the states of the
nodes. We exhibit some examples of how the algorithm works on some GRNs published in the
literature.

Availability and implementation: An executable file of the UpdateLabel algorithm made in Java
and the files with the outputs of the algorithms used with the GRNs are available at: www.inf.udec.
cl/ ~lilian/UDE/

Contact: lilisalinas@udec.cl

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 IntrOduct'on data, qualitative logical models have been used for a better under-

Gene regulation networks (GRNs) consist of interacting genes and standing and simulation of GRNs. Examples of these models are the
gene products, which give rise to complex cell behaviors. Due Boolean networks (BNs), which despite their simplicity are able to
mainly to the lack of detailed kinetic information and quantitative capture key dynamical features and predict some activation patterns

©The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 722

9mg ‘09 isnﬁnV uo seleﬁuV socl ‘erulomeg JO AirSJQAru [1 112 [3.10811211an[plOJXO'SODBIILIOJIIlOlQ/ﬂ(11111 wort pepeolumoq

Non-equivalent update schedules in Boolean networks

723

 

of GRNs (Albert and Othmer, 2003; Davidich and Bornholdt,
2008).

Boolean networks were introduced by Stuart Kauffman in
Kauffman (1969) to model GRNs. The gene expression level, in this
case, is modeled by binary values, 1 or 0, indicating two transcrip-
tional states, either active or inactive, respectively, and this level
changes in time according to some local activation function which
depends on the states of a set of nodes (genes or gene products).
The interactions between the elements of a BN is represented by a
directed graph (digraph), named interaction digraph, where there is
an arc (i, j) in the interaction digraph if the state value of the node
7' depends on the state value of the node i. The dynamics of the net-
work, is governed by an update schedule which determines when
each node has to be updated.

In the original model, the updating scheme was considered to be
synchronous, that is at each time step, the state of all nodes is
updated at the same time. Some examples of GRNs modeled by syn-
chronous Boolean networks are exhibited in Albert and Othmer
(2003), Kauffman et al. (2003), Li et al. (2004), Davidich and
Bornholdt (2008) and Singh et al. (2012). However, due to the syn-
chronous scheme is considered not being very realistic many GRN
modelers have used other update schedules with different levels of
asynchronism (Fauré et al., 2006; Mendoza and Alvarez-Buylla,
1998; Thomas, 1973).

The difficulty of determining time delays of updating in a GRN
makes modelers often sample different update schedules to better
capture an observed biological phenomenon. In this context, some
used schemes are the deterministic update schedules, where the set
of nodes of a network is partitioned into blocks, which are updated
sequentially while within the blocks, the nodes are updated syn-
chronously in every time step, (see for example Demongeot et al.,
2014; Goles et al., 2013; Ruz and Goles, 2013; Ruz et al., 2014a,b;
Meng and Feng, 2014). This family of update schedules, introduced
by F. Robert in Robert (1986), includes the sequential schedules
(each group has size one), the parallel schedule (there is only one
group) and the block-sequential schedules. In the past, a lot of ana-
lytical work has been done about the dynamical behavior of BN5
with this kind of scheme (Aracena et al., 2013a; Goles and Noual,
2012; Elena, 2009; Goles and Salinas, 2008; Mortveit and Reidys,
2001; Robert, 1986).

In BN5 with deterministic update schedules the relative order of
updating of two nodes interacting can be represented by a label on
the respective arc of the interaction digraph. More precisely, we put
on the arc (i, j) the label 69 if the node i is updated after or at the
same time than 7', according to a given update schedule of the net-
work, and the label 3 otherwise. The interaction digraph of a BN
labeled in this way is called update digraph (Aracena et al., 2009).
In this paper we also deal with deterministic update schedules which
are not fully defined, that is, the relative order of updating for some
pairs of nodes is unknown. In such cases we put on the correspond-
ing arcs the label 0.

In Aracena et al. (2009) was proved that given a BN with two
different deterministic update schedules, if the schemes have the
same update digraph associated, then the dynamical behaviors of
the networks under these schemes are equal. Hence, equivalence
classes of deterministic update schedules in a given BN can be
defined according to the update digraph associated, and such that
two equivalent schemes yield exactly the same dynamical behavior
of the network. Thus, in order to know the different dynamical be-
haviors of a BN (for example to study the robustness of the dy-
namics against to changes in the updating scheme), modelers of
GNRs need to test only non-equivalent update schedules, being this

set of schemes usually much smaller than the total set (see
Supplementary information and Aracena et al., 2013b). Similarly, if
someone wants to determine the dynamics of a BN with updating
schemes that are compatible with a set of constraints (on the relative
order of updating of some pairs of nodes) then it is sufficient to test
the non-equivalent extensions of this update schedule partially
defined; this is useful, for example, when there are constraints that
come from wanting to keep some dynamical property of a BN.

In this way, two important problems to solve are determining all
non-equivalent deterministic update schedules of a BN and the non-
equivalent extensions of an updating scheme partially defined. In
this paper, we address both problems and construct efficient algo-
rithms to solve them. For that, we first build algorithms that deter-
mine the update digraphs associated to a given BN, which encoding
the non-equivalent updates schedules. Next, we use the algorithm
introduced in Aracena et al. (201 1), and shown in Supplementary in-
formation, to determine in polynomial time a scheme associated to
each found update digraph and hence to enumerate all non-
equivalent update schedules of the network.

The algorithms designed to calculate the update digraphs associ-
ated to a BN use two strategies. The first one is to avoid infeasible
solutions using a polynomial algorithm. The second one is to make
use of the structural characteristics of the digraph of interaction
associated to a BN, as the presence of bridges, to divide the problem
into subproblems, with smaller instances, which can be solved inde-
pendently and whose solutions can be combined to determine the
general solution. This procedure significantly reduces the total exe-
cution time of the main algorithm.

As example of application of the constructed algorithms we
determined in few seconds the whole set of non-equivalent determin-
istic schemes of four Boolean models of GRNs published in the
literature: Arabidopsis Thaliana regulatory network (Sanchez-
Corrales et al., 2010), Yeast transcriptional network (Kauffman
et al., 2003), the network for Body segmentation in Drosophila
Melanogaster (Albert and Othmer, 2003) and Mammalian Cell
Cycle network (Faure et al., 2006). Besides, for this latter network
we determine the non-equivalent extensions of an update schedule
partially defined, whose restrictions are necessary in order to keep
the unique limit cycle of the network synchronously updated.

2 Definitions and notation

A Boolean network N = (F, 5) is defined by a finite set V of n elem-
ents; n state variables x,, 6 {0,1}, 1) E V; a function F = (fy)y6V :
{0,1}" —> {0,1}" called global activation function, where its com-
ponent functions f,, : {0,1}” —> {0,1} are called local activation
functions, and an update schedule defined by a function
5 : V —> {1,  ,n}, where 5(1)) 2k means that in each unit of time
the state of node 1) is updated in the lath place (see an example in
Supplementary information). An update schedule 5 is also denoted
by5= {1) : 5(1)) 2 1}{1) : 5(1)) =2}---{1):5(1)) =n}.

The state values in a Boolean network with update function 5
are given by x5“ =  :u E V), where lu=le if 5(1)) §5(u) and
l“ 2 la + 1 if5(1)) > 

Given a digraph G we will denote its set of vertices as VG and its
set of arcs as Ac.

The digraph associated to a function F = (fy)y€V, called inter-
action digraph, is the directed graph GF, where VGF = V and (u, 1))
6 Ag: if and only if f,, depends on x“, i.e. if there exists x E {0, 1}”
such that  7E f,,(f“), with f“ different of x only in position u
(see an example of an interaction digraph in Fig. 1).

9mg ‘09 isnﬁnV uo seleﬁuV s01 ‘erulomeg JO £11s19A1u [1 112 ﬂJO'sleumo[pJOJXO'soneuuogurorq/ﬁdnq won pepeolumoq

724

E.Palma et al.

 

@562

(\II

@ GD

Fig. 1. Interaction digraph associated to a Boolean network. Notice that f4
does not depend on x3

f1(m) = {1:1 /\ m4
f2(.’13)= m1 V $4

f3($) = 962

f4(ar;) = .731 /\ (p.733 V :63)

Given a digraph G a label function is any function lab : AG —>
{69, e, 0}. We call labeled digraph to (G, lab). We denote AEGGJab) =
{(u,1)) E Ac|lab(u,1)) = 69}. Analogously we define AEJab) and
A(OGJab).

Given a label function lab, we call support of lab to the set
Sup(lab) = AEGGJab) U A8314“. The arcs in the support are also called
labeled arcs; remaining arcs of G will be called unlabeled arcs.

We say that (G, lab) is fully labeled if Sup(lab) 2 Ac.
Otherwise, we say that it is partially labeled (see Example 1 in
Supplementary information).

The label function lab : AG —> {69, e , Q} is an extension of lab
:AG —> {69, g , o} if Va 6 Sup(lab),lab(a) = lab(a). If 5111902179) =
A9, we call lab a full extension.

Given a digraph G and a partial label function lab. If
lab(a) = O, we define the simple extension lab“=$, as the function
where: Ve 6 AG \ {a}, lab“=$(e) = lab(e) and lab“=$(a) = 69.
Analogously, we define the simple extension lab”: 9 .

In Aracena et al. (2009) was defined the update digraph associ-
ated to a BN N = (F, 5) as (GF, labs); where lab, is the label function
related to the scheme 5, that is given by lab5(i,i) = 69 if 5(i) 25(1)
and lab5(i,i) = e if5(i) < 5(i).

In this way, given any label function lab : AG —> { e ,69}, we
say that the digraph (G,lab) is update if there exists 5 such that
(G,lab) = (G,labs), which can be found in polynomial time using
for example the algorithm exhibited in Aracena et al. (2011) (see
Supplementary information).

Example 1: In Figure 2 we show two labeled digraphs. In (a) it is
shown an update digraph. Indeed, for the update schedule 5 = {3, 4}
{5}{1, 2} we have that lab1 = labs. In (b), the labeled digraph
(G, lab) is not an update digraph. Since otherwise, for any given up-
date schedule 5, 5(3) < 5(5) < 5(4) 3 5(3), which is a contradiction.

In this work we extend the concept of update digraph to partially
labeled digraphs. We say that (G, lab) is an update digraph, if there
exists a full extension lab’ such that (G, lab’) is update (see Example
2 in Supplementary information).

We denote by S(G,lab) the set of full extensions of lab’ that
make (G, lab’) an update digraph.

The condition required for a labeled digraph to be an update di-
graph it is related to the notion of reverse graph defined as follows:
Given a labeled digraph (G, lab), we define the reverse digraph
(GR,labR), where VGR = VG,

AGR = {Obi/NW”) E A?G,zab) V (1’)“) E Nam}

and labR(u,1)) = e if (1),u) E AEJab) and labR(u,1)) = 69 other-
wise. In Figure 3 we show an example of a labeled digraph and its
associated reverse digraph.

Given a labeled digraph (G,lab), there is a reverse path, from
node 1)1 to 1),, in G, if there exists a sequence of nodes (1)1,1)2, .. . ,1),,)
which verifies:

In other words, if there exists a path from 1)1 to 1),, in the reverse
digraph.

275% rack

69% C2) @9 @
teal/e \eﬂﬁ
@—>@ @—>@

a) (G, labl) b) (G, labg)

Fig. 2. (a) Example of update digraph. (b) Example of non-update digraph,
where the gray arrows form a forbidden cycle

(a) (b) (c)

@‘e—GD—EB’G) @—e>®—$>@ @‘e—@—®’©
3))ng Ska) EBA);

Fig. 3. (a) A labeled digraph (G,lab). (b) The associated reverse digraph
(GR, labn). (c) A negative reverse path (marked by gray arrows): (6, 4,2,3,5)
in (G, lab)

There is a negative re1)erse path from 1)1 to 1)", if there exists a
path in the reverse digraph that contains a negative arc. In Figure 3c
the path marked by the gray arrows is a reverse path from 6 to 5.
This is also a negative reverse path, because the arc (3, 2) is on the
sequence.

A forbidden cycle is a negative reverse path (1)1,1)2,  ,1),,)
where 1)1 = 1),, (see an example in Fig. 2b, where the forbidden cycle
is defined by the gray arrows). It was proved in Aracena et al.
(2011) that a labeled digraph is an update digraph if and only if
there does not exist any forbidden cycle.

3 Complexity of update digraph extension
problem

In this article we are interested in finding a set of non-equivalent de-
terministic update schedules satisfying some constraints (if any)
about the relative order of updating of some nodes of a BN or
equivalently the extensions of a partially labeled digraph (eventually
with empty support) that are update digraphs. More precisely, we
address the following problem:

Update digraph extension (UDE): Given a labeled digraph (G, lab),
find the set S (G, lab) of all full extensions lab’ of lab such that (G, lab’)
is an update digraph.

To know the computational complexity of the UDE problem, we
study the following counting problem associated to UDE:

Counting update digraph extensions (CUDE): Given (G, lab)
a labeled digraph, determine the number of all full extensions lab’ of
lab such that (G, lab’) is an update digraph.

We will prove that CUDE is a difficult problem, thereby we can
conclude the complexity of the UDE problem.

Theorem 1: CUDE is #P-complete.

The proof (see Supplementary information) is based on the idea
that an acyclic labeled digraph is an update digraph if and only if its
reverse digraph is acyclic. This is because in the reverse digraph of
an update digraph the only allowed cycles have every arc labeled as
positive. In this way, it is easy to define a bijection between an up-
date digraph and the acyclic orientation of its underlaying graph.

Note that previous result tell us that the enumeration of all ex-
tensions from a partially labeled digraph is a hard problem, while

9mg ‘09 isnﬁnV uo seleﬁuV s01 ‘erulomeg JO £11s19A1u [1 112 [3108112111110fplOJXO'SODBIIIJOJIIIOIQ/ﬂdllq wort pepeolumoq

Non-equivalent update schedules in Boolean networks

725

 

the related existence problem is known to be polynomial (Aracena
etal., 2011).

4 Algorithms

In this section we present the theoretical results that lead to design
an algorithm that solves the UDE problem. In first place, we focus
on verify the existence of one solution, then we reduce our problem
contracting each positi1)e strongly connected component (i.e.
strongly connected component in the digraph induced by the posi-
tive arcs of the labeled digraph) in one vertex. In second place, we
present the two main results of this article: they are the effect of
forcing arcs, that allows to eliminate infeasible solutions in polyno-
mial time, and the division of our problem into smaller pieces using
algorithms to find bridges and strongly connected components.

4.1 Verify

First, we verify whether the labeled digraph is an update digraph.
To check this, we use the ReversePaths algorithm to search any for-
bidden cycle. ReversePaths algorithm is an adaptation of Floyd—
Warshall algorithm, where instead of finding minimum weight
paths, we determine the existence of reverse paths and negative re-
verse paths between each pair of vertices. The algorithm returns the
matrix M where: M (u, 1)) = —1 if there exists a negative reverse path
from u to 1); M(u,1)) = 1 if there is a reverse path from u to 1), but
not a negative one and M(u,1)) = 00 otherwise. See details of
ReversePaths and Verify algorithms in Supplementary information.

4.2 Reducing the size of the instances of UDE problem
As we mentioned above, the UDE problem belongs to a class of
problems for which there are not known polynomial algorithms that
solve them. Hence, the decrease in size of an instance of UDE prob-
lem is very important. In this way, we define the reduced digraph of
an update digraph which involves replacing each positive strongly
connected by a single vertex.

The following lemma is a property of the update digraphs which
allows to define correctly the reduced digraph of an update digraph.

Lemma 2: Let (G, lab) be an update digraph, G1 and G2 two posi-
tive strongly connected components of G, and lab a full extension
such that (G, lab) is a fully labeled update digraph. Then
Va,a’ 6 AG (1 (VG1 >< VGZ): lab(a) = lab(a’).

The proof of this lemma (detailed in Supplementary information)
uses the fact that if lab (a) 2125(1)) then there exists a forbidden
cycle in the labeled digraph.

From the previous lemma we know that we can preliminarily
label some arcs. This help us to avoid a multidigraph when we ob-
tain the reduced digraph or problems in its label function.

Definition 1: Let (G, lab) be an update digraph and {G1, . . . ,Gk}
its positive strongly connected components. We define its reduced
labeled digraph R(G,lab) by R(G,lab) = (Grd,labrd), where Grd
2 (Vrd,Ard), Vrd = {111, . . . ,Uk} and
Ard = {(1),,1),-)|E|(u,1)) 6 AG 0 (VG, >< VG,)}

Furthermore, labrd(1),-,1),-) = lab(u,1)), if E|(u,1)) E (VG, >< VGI.)
ﬂSup(lab) and labrd(1),-,1),-) = 0 otherwise. We say that a labeled di-
graph (G, lab) is reduced if (G, lab) 2 R(G, lab).

Note that if (G,lab) is connected, then obviously R(G,lab) is
also connected. Furthermore, as (G, lab) is an update digraph, then
R(G, lab) is an update digraph, since otherwise there would be a for-
bidden cycle.

(a) (b)

G Grd
(1)?) ﬂay): (fewer:
@‘4 Z We elf/o?

Fig. 4. (a) An update digraph. (b) The reduced digraph

 

Example 2: In Figure 4 an example of a reduced digraph is shown.
The nodes 4, 5 and 6 are in a positive strongly connected compo-
nent, so in the reduced digraph they are all represented by node V4.

Theorem 3: The elements of the solution set of the UDE problem
for (G,lab) are in bijection with those of the UDE problem for
R(G,lab).

The proof of this theorem uses the previous lemma (details in
Supplementary information). In fact, if we have an unlabeled arc be-
tween nodes in the same positive strongly connected component, this
must be labeled positive to avoid a forbidden cycle. In terms of update
schedule, that means that every node in the positive strongly con-
nected component is updated at the same time, so we can represent all
these nodes in one. Also, the arcs between different positive strongly
connected components must have the same direction in the reverse di-
graph to avoid forbidden cycles, hence we can represent all of them
by just one that has the right direction in the reverse digraph.

The application of this results leads to Algorithm 1. In this algo-
rithm we use SCCT, i.e. the algorithm that returns the positive
strongly connected components of a digraph. This is very easy to
construct using, for example, Tarjan algorithm (Tarj an, 1972).

 

Algorithm 1 Reduce

 

Require: An update digraph (G, lab).
Ensure: The reduced digraph (Grd, labrd).

1: {G1,  ,Gk} <— SCC+(G,lab)

2: VGrd <— {101,  ,wk}

3: AGrd <— Q)

4: for i=1 to la do
for j: 1 to la do

if E|(u,1)) 6 AG with u E VG, and 1) E VG]. then
AGrd (— AGrd U (wi)wi)

: for all do(u),-,u),-) E AGrcl
if Elu E VG,,1) E VG]. and lab(u,1)) = 9 then
10: lab,d(u,1)) <— e
11: else if Elu E VG,,1) E VG]. and lab(u,1)) = 69 then
12: lab,d(u,1)) <— 69
13: else
14: labrd(u,1)) <— O
15: return (Grd, labrd)

E?°°>I.°.\E."

 

4.3 Force

Given an update digraph (G, lab) with Sup(lab) 75 Ac, there are
situations in which an unlabeled arc (i, j) 6 AG may be labeled just
in one way to keep the update digraph property. In fact, if every un-
labeled arc is forced to have a unique label the solutions of the UDE
problem is unique.

Example 3: In Figure 5a we see that there exist negative reverse
paths (marked for gray arrows) from 3 to 2 (3,1,2) and from 2 to 4
(2,4), then the unlabeled arcs (2,3) and (2,4) must be labeled nega-
tive and positive respectively, as shown in b.

9mg ‘09 1sn8nV uo seleﬁuV s01 ‘121u10111123 10 A11s19A1u [1 112 /810'S{12umo[p101x0's31112u1101u101q/ﬁd11q 111011 pepeolumoq

726

E.Palma et al.

 

(a) (b)
AG) 6, AG) 6,

@‘o— @‘e—
9/0 —> 9/63
63:3369/ #GD/
(G, lab) (07 [5,1])

Fig. 5. (a) Example of update digraph where the arcs (2, 3) and (2, 4) are
forced to be negative and positive, respectively. The gray arrows define re-
verse paths. (b) (G, lab) is the maximal extension of (G, lab)

The fact that there exists an unlabeled arc forced to have an
unique label, called simply forced arc, depends only on the existence
of reverse and negative reverse paths in the interaction digraph as
shown in the following proposition.

Proposition 4: (Forced arc) Let (G, lab) be an update digraph, (i, j)
6 AG and lab(i,/') = 0. Then:

1. For all (i, j) 6 AG there exists a negative reverse path from i to i
if and only if (G, lab(i’()=$) is a nonupdate digraph; then we say
that the arc (i, j) is forced to be negative.

2. For all (i, j) 6 AG there exists a reverse path from i to j if and
only if (G, lale= e ) is a nonupdate digraph; then we say that
the arc (i, j) is forced to be positive.

Proof: We will prove the first case, the second one is analogous.

(=>) If we consider that there exists a negative reverse path from i
to i, then if we label (i, 7') positive, there will be a ne ative reverse
path (forbidden cycle) from i to 7'. Hence, (G, lab(i’()=$3
date digraph.

(<2) If G, lab(i’l):® is a nonupdate digraph and (G, lab) is, then
a forbidden cycle is produced by labeling positive the arc (i, j).

is a nonup-

Hence there exists a negative reverse path from i to i in (G, lab). I

It is important to observe that the order in which the forced arcs are
chosen to be labeled is irrelevant in the label obtained. Because, the
labeling of forced arcs does not give us additional information in terms
of reverse and negative reverse paths in the interaction digraph. Indeed,
if there exists a negative reverse path from i to i we label negative the
forced arc (i, j), i.e. we add a new negative reverse path from i to i.
Analogously, if there is a reverse path from i to j in the interaction di-
graph, we label (i, j) positive, i.e. we add a new reverse path from i to i.

To check the existence of forced arcs allows to avoid extensions
that are not update schedules. Hence, we build Algorithm 2 that
labels all the forced arcs. Applying this algorithm to an update di-
graph we obtain the maximal extension, which is the extension of G
such that every forced arc is labeled.

 

Algorithm 2 Force

 

Require: An update digraph (G, lab).
Ensure: A maximal extension of lab

1: 12:79 <— lab

2: M <— ReversePaths(G, lab)

3: for all a E Sup(lab), with a = (i, i) do

4: if Mini) toaqéhen

5 lab <— lab

6 elseif M (1;,i)a_=e—1 then
7: lab <— lab

8: return lab

 

Next, we introduce a simple algorithm that name SimpleLabel,
to find all the extensions of a given partially labeled update digraph
and which uses Force algorithm. Firstly, this algorithm finds the
maximal extension of the given label function. Thereafter, the algo-
rithm labels an unlabeled arc positive and recursively calls itself. In
this way, it finds all the solutions with this arc labeled positive, then
it repeats the procedure labeling the arc negative. Finally the total
solution is the union of both solution sets (see Algorithm 3).

 

Algorithm 3 SimpleLabel

 

Require: An update digraph (G, lab)
Ensure: The set S (G, lab) denoted by S and its cardinal

r :2 |S|

1: (S, r) <— (0,0)

2: lab <— Force(G, lab)

3: if Sup(lab) = A(G) then

4: return (lab, 1)

5: else

6: Let be a E A(G) \ Sup(lab)

7: (S1,r1) <— SimpleLabel(G,lab"=$)
8: (S2,r2) <— SimpleLabel(G, lab”: 9 )
9: (S,1')<—(S1 USz,1'1 +72)

10: return (S, r)

 

4.4 Divide and conquer

In order to improve the efficiency of the SimpleLabel algorithm, we
use structural properties of the digraph to divide the problem into
subproblems, by partitioning the arc set, such that their combined
solutions give us the solution of the original problem. To formalize
this combination of solutions we define the operator 8).

Definition 2: Given a digraph G; {A,-}f=1 a partition of AG and
{Li}:1 a family of label functions such that for every i E {1, ... ,lz},
L,- g {lab|lab : A,- —> {69, e , O}isalabelfunctionofG}, we define:

L1®  ®Lk={lab:AG—>{69, 1,...,le,lab|Ai 614}.

The following result is directly obtained from the previous
definition.

Proposition 5: Let (G, lab) be a digraph such that its connected
components are G1, . . . ,Gk, then

8(G, lab) = 8(G1, mpg) ® ... ® 8(Gk, lab|AGk ).

4.4.1 Division by bridges

The first division is to separate nodes joined by a bridge in the
underlying graph (i.e. the graph obtained by replacing all directed
edges of G with undirected edges). This idea comes from the fact
that any forbidden cycle cannot contain any bridge.

Proposition 6: Let (G, lab) be a labeled connected digraph, GU the
underlying graph of G the and uv a bridge of GU that divides G into
G1 and G2, we denote by G}, = G[{u,1)}] then

8(G, lab) 2 8(G1,lab|AGI) ® S(G;,,lab|AGb) ® 8(G2,lab|AGZ).
The proof of this proposition is detailed in Supplementary informa-

tion. In Figure 6 we can see an example of division by bridges of a
labeled digraph with the associated partition of the arc set.

9mg ‘09 1sn8nV uo sejeﬁuV sorl ‘121u10111123 10 AnsleAtu [1 112 /810'S{12umo[p101x0'sot112u1101u101q/ﬁd11q 111011 pepeolumoq

Non-equivalent update schedules in Boolean networks

 

(a) (b)

@<e—@i@ @659 @—@—@ @—@
be) ltglleﬁ/ye  l/I 
<e—@ —>@%*@ —@ —®—@

(0)

CD (De—<29 @—®>@ (De—(9
) a 16V 1: O W):
<®—@ 36) @136) @

Fig. 6. (a) Labeled digraph. (b) Underlying graph. (c) Partition of the are set
produced by the division by bridges

4.4.2 Division by strongly connected components

Another way to simplify the digraph consists in divide it by its
strongly connected components in the extended reverse digraph, i.e.
the reverse digraph where unlabeled arcs are replaced by unlabeled
arcs in both directions. As in the case of bridges, forbidden cycles
cannot use arcs connecting different strongly connected
components.

Proposition 7: Let (G, lab) be an update digraph with G1, . . . , Gk
its strongly connected components of the extended reverse digraph,
we define the set of arcs:

AT 2 QAG r1(VG, >< VGi),
1’]
which it is composed by the arcs between strongly connected com-
ponents of the extended reverse digraph of (G, lab). Then,
S(G, lab) = S(G1,lab|A~ ) ® ... (29 8(5),, lab|A~ ) ® {lab|AT}

cl Gk

where Vi E {1,  ,k}, G,- = G[VG,-l.

In Figure 7 we can see an example of division by strongly con-
nected components of an update digraph with the associated parti-
tion of the arc set.

The proof of this last proposition is similar to that of the
Proposition 6 shown in Supplementary information, and is based on
the fact that (G, lab) is an update digraph if and only if every labeled

digraph G), lab is update digraph.
Aa-

Next we define the Algorithm 4, called Label, that requires as in-
put an update digraph with a label function without forced arcs, and
which uses the divisions defined above to partition our problem. It
applies the same ideas of SimpleLabel, i.e. to force arcs, label one
and apply recursively the same algorithm.

 

Algorithm 4 Label

 

Require: (G, lab), a maximal extension of an update digraph.
Ensure: The set S(G,lab) denote by S and its cardinal num-
ber r :2 |S|

1: (S,r) <— (0, 1)

2: {(G1,labG1), . . . ,(Gk, laka)} <— Bridges(GU)

3: for i=1 to k do

4: if Sup(labG,) 2 Ac, then

5: S<—S®{labG,}

6: else

7 {(H1,labH1), . . . ,(Hp, lapr)} <— SCC+(G,', labG,)

8: if p = 1 then

9 Let a E AH1 be an arc such that lab(a) = O

727
10: lab+ <— Force(H1, labfiﬂa)
11: if Sup(lab+) 75 AH1 then
12: (5,?) <— Label(H1, MN)
13: else
14: (5,2) :— ({lab+}, 1)
15: lab‘ <— Force(H1,lab}’; e )
16: if Sup(lab‘) 75 AH1 then
17: (57,2) :— Label(H1, lab‘)
18: else
19: (Ii?) :— ({lab‘}, 1)
2o: (S,r)<—(S®(SUSV),r-(i'+i‘))
21: else
22: for/'21 topdo
23: if Sup(labHI.) 2 AH, then
24: S <— S (X) {labHi}
25: else
26: (57,2) :— Label(H,-, 11:19:11,)
27: (S,r)<—(S®S,r-i')

28: return (S, r)

 

Finally, we present the main algorithm, to solve the UDE prob-
lem, named UpdateLabel, which first checks if the labeled digraph
(G, lab) received as input is an update digraph, i.e. if S (G, lab) 75 Q)
(see Algorithm 5).

4.5 Comparison of algorithms with and without
divisions

To illustrate the efficiency of doing divisions in the main algorithm
we compare the performance of our algorithm Label against
SimpleLabel algorithm that only uses the idea of forced arcs. As the
algorithms require an update digraph as input, we use UpdateLabel
algorithm to call both. The tests were run in complete digraphs and
chains (see Fig. 8) of different sizes and with empty supports in a
laptop with Processor: 2.4 GHz Intel Core i5, RAM memory: 8 GB
1600 MHz DDR3, operating system: OS X 10.9.5. In Table 1 we
can see as the main algorithm with Label runs (column Label) faster
than with SimpleLabel (column SimpleL), even in the case of com-
plete digraphs where there is a small number of divisions. However,
when the number of solutions (i.e. |S(G, lab)|) is big it is convenient
to use SimpleLabel instead of Label, because the latter uses a lot of
RAM memory (see for example the case of K9). It is important
to mention that the times listed in columns SimpleL and Label of
Table 1 correspond to the runtimes of the implementation of
UpdateLabel algorithm available at www.inf.udec.cl/Nlilian/UDE/
with output the list of non-equivalent schemes associated to the up-
date digraphs of S(G, lab). In the cases of columns Coded and
Count, they correspond to the implementation with output S (G, lab)
and |S (G, lab)| respectively.

 

Algorithm 5 UpdateLabel

 

Require: A labeled digraph (G, lab)

Ensure: The set S(G,lab) denote by S and its cardinal num-
ber r :2 |S(G, lab)|.

1: if Verify(G, lab) 2 false then

2: return (Q), 0)

3: else

4: (Grd,labrd) <— Reduce(G,lab)

5: 12:79 <— Force(Grd,la/b£d) N

6: return Label(Grd, lab) (or SimpleLabel(Grd,lab))

 

9mg ‘09 1sn8nV uo sejeﬁuV soc) ‘121u10111123 10 AnsleAtu [1 112 /810'S{12umo[p101x0'sot112u1101u101q/ﬁd11q 111011 pepeolumoq

728

E.Palma et al.

 

(a) (b) (c)

e 63
—’ V——’ <— —>

@ e@@@@@@
ﬁg/llll/égg)

‘e— @<—@

(d) (2) G) @i@%@

$01; ETD @‘e—@/

6'1 @2 GlATl

Fig. 7. (a) Update digraph (G, lab). (b) Extended reverse digraph (G’, lab’). (0)
Strongly connected components of (G’, lab’). (d) Partition of the are set of G
produced by the division by strongly connected components

@8®8@c@8@

Fig. 8. Example of a chain P,, where n= 5

Table 1. Results obtained when the main algorithm is used with
and without divisions on some digraphs Kn and P”. Here, |V| and |
Al denote the number of nodes and arcs of each digraph,
respectively

 

 

Graph | V| |A| |S (G, lab) | Count SimpleL Label Coded
(S) (S) (S) (S)
K3 3 6 13 0.002 0.003 0.002 0.002
K4 4 12 75 0.003 0.008 0.006 0.007
K5 5 20 541 0.015 0.029 0.016 0.020
K6 6 30 4 683 0.011 0.067 0.051 0.015
K7 7 42 47293 0.022 0.254 0.113 0.071
K8 8 56 545 835 0.164 3.325 1.065 0.328
K9 9 72 7087261 1.254 51.945 — 3.326
P10 10 18 19 683 0.001 0.217 0.078 0.001
P20 20 38 1 162 261 467 0.001 — — 0.001
P30 30 58 1 094 942 099 0.001 — — 0.001

 

5 Application to genetic regulatory networks

We apply our algorithm UpdateLabel to enumerate the non-equiva-
lent deterministic update schedules of four Boolean models of GRNs
published in the literature: Mammalian Cell Cycle network (Faure
et al., 2006), Arabidopsis Thaliana regulatory network (Sanchez-
Corrales et al., 2010), Yeast transcriptional network (Kauffman et
al., 2003) and the network for body segmentation in Drosophila
Melanogaster (Albert and Othmer, 2003), also studied in (Marques-
Pita and Rocha, 2013).

The mammalian cell cycle network has 10 nodes and 31 arcs. A
detailed description of the network can be found in Supplementary
information. For this network we used the implementation of
UpdateLabel algorithm available at www.inf.udec.cl/Nlilian/UDE/
without divisions and with divisions to enumerate all non-equivalent
deterministic update schedules of the network (row Mammalian1 of
Table 2) and those that are extensions of the partially labeled inter-
action digraph shown in Supplementary information, and corres-
ponding to label eight arcs of the network as positive, in order to
preserve the limit cycle C of the synchronous dynamical behavior
also specified in Supplementary information (row Mammalian2 of
Table 2). The times listed in Table 2 correspond to the same of those

Table 2. Results obtained when the main algorithm is used with
and without divisions on some networks. Here, |V| and |A| denote
the number of nodes and arcs of the interaction digraph of each
network, respectively

 

Graph |V| |A| |S(G,lab)| Count SimpleL Label Coded
(s) (S) (S) (S)

Mammalian1 10 31 466712 0.755 5.230 2.966 1.327

 

Mammalian2 10 23 1 440 0.005 0.016 0.033 0.009
Arabidopsis 13 39 7062 567 11.349 113.851 — 19.237
Yeast 30 22 206 427 0.222 30.768 3.595 0.322
Drosophila 18 12 2 368 0.001 0.093 0.023 0.001

 

specified in Table 1. It is important to observe that the quantities
466712 and 1440 represent an upper bound for the total number of
different dynamics and for the number of possible dynamics exhibit-
ing the limit cycle C, of the mammalian cell cycle network with de-
terministic update schedules, respectively. Besides, these number
are much less than the total number of deterministic update
schedules for the network, which it is approximately 1 x 108 (see
Supplementary information). We also applied the implementation of
the algorithms to the other mentioned networks labeling some arcs
as negative when the ‘head’ vertex of the arc has associated a constant
function as local activation function. The corresponding partially
labeled interaction digraphs are shown in Supplementary information.
In the case of Arabidopsis Thaliana we only use SimpleLabel algo-
rithm because the size is too big to process in RAM Memory. The re-
sults obtained are shown in Table 2, where |S(G,lab)| is an upper
bound of the number of possible dynamics of each network when are
modeled by BN5 with deterministic update schedules. The files with
the outputs of the algorithms for each network can be found at: www.
inf.udec.cl/Nlilian/UDE/Filesl.

6 Discussion

The problem of testing different deterministic update schedules of a
BN modeling a GRN, for example to better capture an observed bio-
logical phenomenon or to study the robustness of the dynamics
against to changes in the updating scheme, is reduced to use only non-
equivalent schemes. This set, defined according to the update digraphs
associated to a network, can be much smaller than the total set of
schemes (Supplementary information and Aracena et al. 2013b). In
this article we addressed the problems of determining all non-equiva-
lent deterministic update schedules of a BN and the non-equivalent
extensions of an updating scheme partially defined. To solve them, we
first construct an algorithm, named UpdateLabel, determining the
label functions on the arcs of the interaction digraph of a BN that
have an update schedule associated (i.e. the set of update digraphs of
a BN). The UpdateLabel algorithm uses two major ideas in its design.
The first one is the base of the Force algorithm, which in polynomial
time checks whether the given labels on some arcs uniquely determine
the label in others (only possible extension), allowing to eliminate in-
feasible solutions in polynomial time. The second one is to make use
of the structural characteristics of the interaction digraph associated
to a BN, as the presence of bridges, to divide the problem into subpro-
blems, with smaller instances, which can be solved independently and
whose solutions can be combined to determine the general solution.
This procedure significantly reduces the total execution time of the
main algorithm as observed in Table 1. Next, for each update digraph
found with UpdateLabel algorithm we determine an update schedule
scheme belonging to the class, by using a polynomial algorithm

9mg ‘09 1sn8nV uo sejeﬁuV soc) ‘121u10111123 10 AnsleAtu [1 112 /810'S{12umo[p101x0'sot112u1101u101q/ﬁd11q 111011 pepeolumoq

Non-equivalent update schedules in Boolean networks

729

 

introduced in Aracena et al. (2011) and exhibited in Supplementary
information. We illustrate the application of our algorithms on four
GRNs published in the literature. The results obtained and exhibited
in Table 2 show that in few seconds we can obtain the whole set of
non-equivalent update schedules of each studied network, whose car-
dinals correspond to the maximum number of possible dynamical be-
haviors of the studied networks when they are modeled by BN5 with
deterministic update schedules. It is important to note that despite the
UpdateLabel algorithm with divisions on the interaction digraph is
faster, it is limited by the RAM memory of the computer. So for large
networks is advisable to use simply the UpdateLabel algorithm with-
out division, when the number of non-equivalent schemes 50 allows.

Funding

This work was partially supported by project Fondecyt 1131013 (J.A. and
LS.) and Master’s scholarship CONICYT (E.P.).

Conﬂict of Interest: none declared.

References

Albert,R. and Othmer,H.G. (2003) The topology of the regulatory inter-
actions predicts the expression pattern of the drosophila segment polarity
genes. ]. Theor. Biol., 223, 1—18.

Aracena,]. et al. (2009). On the robustness of update schedules in Boolean net-
works. Biosystems, 97, 1—8.

Aracena,]. et al. (2011). Combinatorics on update digraphs in Boolean net-
works. Discrete Appl. Math., 159, 401—409.

Aracena,]. et al. (2013a) Limit cycles and update digraphs in Boolean net-
works. Discrete Appl. Math., 161, 1—2.

Aracena,]. et al. (2013b) On the number of different dynamics in boolean net-
works with deterministic update schedules. Math. Biosci., 242, 188—194.
Davidich,M.I. and Bornholdt,S. (2008) Boolean network model predicts cell

cycle sequence of ﬁssion yeast. PloS One, 3, e1672.

Demongeot,]. et al. (2014) Stability, complexity and robustness in population
dynamics. Acta Biotheoretica, 62, 243—284.

Elena,A. (2009) Robustesse des réseaux d’automates booleéns a seuil aux
modes d’itération. Application a la modélisation des réseaux de regulation
génétique. Ph.D. thesis, Université Joseph Fourier (Grenoble I), Grenoble,
France.

Fauré,A. et al. (2006) Dynamical analysis of a generic Boolean model for the
control of the mammalian cell cycle. Bioinformatics, 22, 124—131.

Goles,E. and Noual,M. (2012) Disjunctive networks and update schedules.
Adz). Appl. Math., 48, 646—662.

Goles,E. and Salinas,L. (2008) Comparison between parallel and serial dy-
namics of Boolean networks. Theor. Comput. Sci., 396, 247—25 3.

Goles,E. et al. (2013) Deconstruction and dynamical robustness of regulatory
networks: application to the yeast cell cycle networks. Bull. Math. Biol., 75,
939—966.

Kauffman,S. (1969) Metabolic stability and epigenesis in randomly connected
nets. ]. Theor. Biol., 22, 437—67.

Kauffman,S. et al. (2003) Random Boolean network models and the yeast
transcriptional network. Proc. Natl Acad. Sci., 100, 14796—14799.

Li,F. et al. (2004) The yeast cell-cycle network is robustly designed. Proc. Natl
Acad. Sci. USA, 101, 4781—4786.

Marques-Pita,M. and Rocha,L.M. (2013) Canalization and control in
automata networks: Body segmentation in drosophila melanogaster. PLoS
ONE, 8, e55946.

Mendoza,L. and Alvarez-Buylla,E. (1998) Dynamics of the genetic regulatory
network for arabidopsis thaliana ﬂower morphogenesis. ]. Theor. Biol.,
193, 307—319.

Meng,M. and Feng,]. (2014) Function perturbations in Boolean networks
with its application in a d. melanogaster gene network. Eur. ]. Control,
20(2), 87—94.

Mortveit,H. and Reidys,C. (2001) Discrete, sequential dynamical systems.
Discrete Math., 226, 281—295.

Robert,F. (1986) Discrete Iterations: A Metric Study. Springer-Verlag, Berlin.

Ruz,G.A. and Goles,E. (2013) Learning gene regulatory networks using the
bees algorithm. Neural Comput. Appl., 22, 63—70.

Ruz,G.A. et al. (2014a) Dynamical and topological robustness of the mamma-
lian cell cycle network: A reverse engineering approach. Biosystems, 115,
23—32.

Ruz,G.A. et al. (2014b) Neutral space analysis for a boolean network model
of the ﬁssion yeast cell cycle network. Biol. Res., 47, 64.

Sénchez-Corrales,Y.-E. et al. (2010) The arabidopsis thaliana ﬂower organ
speciﬁcation gene regulatory network determines a robust differentiation
process]. Theor. Biol., 264, 971—983.

Singh,A. et al. (2012) Boolean approach to signalling pathway modelling in
hgf—induced keratinocyte migration. Bioinformatics, 28, i495—i5 01.

Tarjan,R. (1972) Depth-ﬁrst search and linear graph algorithms. SIAM ].
Comput., 1, 146—160.

Thomas,R. (1973) Boolean formalization of genetic control circuits. ]. Theor.
Biol., 42, 563—585.

9mg ‘09 1sn8nV uo sejeﬁuV soc) ‘121u10111123 10 AnsleAtu [1 112 /810'S{12umo[p101x0'sot112u1101u101q/ﬁd11q 111011 pepeolumoq

