APPLICA TIONS NOTE V325;2.légiiiﬁliio’iiiiiiifzéég

 

Sequence analysis

Advance Access publication September 30, 2014

A Python package for parsing, validating, mapping and formatting
sequence variants using HGVS nomenclature
Reece K. Hart1’2’*, Rudolph Ricol, Emily Harel, John Garcia‘, Jody Westbrook1 and

Vincent A. Fusaro1

1lnvitae Inc., San Francisco, CA 94107 and 223andMe Inc., Mountain View, CA 94043, USA

Associate Editor: John Hancock

 

ABSTRACT

Summary: Biological sequence variants are commonly represented in
scientific literature, clinical reports and databases of variation using the
mutation nomenclature guidelines endorsed by the Human Genome
Variation Society (HGVS). Despite the widespread use of the standard,
no freely available and comprehensive programming libraries are avail-
able. Here we report an open-source and easy-to-use Python library
that facilitates the parsing, manipulation, formatting and validation of
variants according to the HGVS specification. The current implemen-
tation focuses on the subset of the HGVS recommendations that pre-
cisely describe sequence-level variation relevant to the application of
high-throughput sequencing to clinical diagnostics.

Availability and implementation: The package is released under the
Apache 2.0 open-source license. Source code, documentation and
issue tracking are available at http://bitbucket.org/hgvs/hgvs/.
Python packages are available at PyPl (https://pypi.python.org/pypi/
hgvs).

Contact: reecehart@gmail.com

Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on June 26, 2014; revised on August 29, 2014; accepted on
September 17, 2014

1 INTRODUCTION

As high-throughput sequencing becomes commonplace in the
investigation and diagnosis of disease, it is essential that commu-
nicating variants from sequencing projects to the scientiﬁc com-
munity and from diagnostic laboratories to health-care providers
is easy and accurate. The Human Genome Variation Society
(HGVS) mutation nomenclature recommendations (Taschner
and den Dunnen, 2011) are widely endorsed by professional or-
ganizations, mandated by numerous journals and displayed by
databases and tools. The HGVS recommendations—originally
devised to standardize the representation of variants discovered
before the advent of high-throughput sequencing—are now
approved by the HGVS and continue to evolve under the aus-
pices of the Human Variome Project. The continual evolution of
HGVS guidelines makes the nomenclature difﬁcult to under-
stand and to use for experts and non-experts alike, often result-
ing in incorrect usage and potential clinical interpretation errors.

 

*To whom correspondence should be addressed.

We sought a software library for manipulating HGVS variants
that was appropriate for clinical diagnostics. Speciﬁcally, we
required the following functionality: (i) We must be able to pro-
cess patient variants locally (i.e. not sent to a remote site); (ii) we
must be able to audit, extend and control updates of the source
code and data; (iii) we must be able to map variants in regions of
genome-transcript discrepancies, particularly indels. Mutalyzer
ONildeman et al., 2008) provides a Web interface and Web
services for constructing, validating and transforming sequence
variants, but is not available for local installation. Another
Python library (https://github.com/counsyl/hgvs), similar in
spirit to the one we present here, uses a regular expression-
based parser and relies on exon structures derived from BLAT
alignments (Kent, 2002). Although other packages accept or
generate HGVS-formatted variants, such as sanff (Cingolani
et al., 2012) and VEP (Mclaren et al., 2010), they are not
intended for use as a software library.

Here we present an open-source Python library for parsing,
mapping, validating and formatting sequence variation accord-
ing to the HGVS guidelines. The library features a parser based
on a Parsing Expression Grammar and a variant mapper that
accommodates insertion/deletion discrepancies between refer-
ence genomic sequences and transcripts that confound most
existing tools.

2 PACKAGE OVERVIEW

The hgvs Python package comprises six key components: (i)
object models for representing components of HGVS-formatted
variants; (ii) a parser that generates an object representation
from an HGVS-formatted string; (iii) formatting tools that gen-
erate an HGVS-formatted string from an object representation;
(iv) mapping classes that transform variants between genomic,
CDS and protein representations; (V) validation tools that ensure
conformance to HGVS guidelines; (Vi) an interface for deﬁning
external data sources required for validation and mapping.

The core of the hgvs package is a set of object models that
provide a foundation for developers to reference any component
or property of the HGVS syntax. For example, a
SequenceVariant consists of a sequence accession, a sequence
type and PosEdits, which represent a set of individual changes
to a sequence. A PosEdit is composed of positions, such as a
BaseOffsetPosition for a CDS (c.) SequenceVariant with intronic
variants, and an Edit for Single Nucleotide Variant (SNV), del,
ins, delins, duplications and repeats. Figure 1a shows an example

 

© The Author 2014. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/4.0/), which
permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.

112 /§.IO'SIBU.IT10[p.IOJXO'SOTlBIHJOJUTOTCI/ﬁdllq 11101; prBOIIIAAOG

9IOZ ‘09 lsnﬁnv uo ::

Python hgvs package

 

(3) object model representation for a parsed variant (b}MCL1 locus and example variants

var_c1 g
A IIIIIlllIl—IIIIIIIII
ac    B ["JI.I_'.-"_-'|.I-'|,-!'_-:'I I I  I :1 i~|'1":l_:l'l~.\.| It?” I..'.-_.:'.I
pus uncertain edit 2
A M
start end ref alt 0 I-Ir-..: lI-t..".-’I.~. -;__-:-. tame-Ina. 

A A uncertain 9 HI" 
base offset base offset I -
+Hd

datum uncertain datum uncertain _

3 Hrs u*-I_:I lilﬂf'tiitl. I  I t'--T
{-3 I~II= I1:_II ;s-::-=.—;w:-. I :;~.'.st=I-~.I—;I"II-:~_:

var_c1.posedit.pos.start.ofiset == 403
var_c1.posedit.edit.rei 2: 'C'
var_c1.posedit.edit == "CL-J"

(c) annotated Python code

Parse an HGVS string into a Python structure

import hgv5.parser
hp = hgvsparserﬁarserl]:
var_c1 = hp.parse_hgv5_variantt 'NP_1H:‘?r.H.? narrowest}? Io

Infer protein changes for these transcript variants

var p1 = mm: to plvar cl]
var_p2 = vm.c_to_plvar_c21 9 6
var p1, var p2

var c1. var c1.poscd:lt.pos.start

t5cqoence¥artantlac=m 1321612. ‘t‘y'F-IFE. posedit=ﬁﬁﬂ+463E=TL
BaseuffsetPositiontoase=ﬁaﬂ. offset=4ﬂ3. datum-=1. anerta1n=i=alsell

{SequenceVarianHaFl-JP STEEL-1.1, type=p. posedit=?},
Sequmceveriantlac=HP_EitillE-1249.1.. tvpecp. posedit=t5er94Phelrl

Open the UTA public data source for mapping and Farmat the results by stringmcath“

Vilidatiﬂn srinTi' ""rnenpco {rear :11 their olll
'_:I {var_r.2} Il<{'.ral'_p2}l-
via {our q}' "".'-'II'!'Itt
var_c1=var_c1, var_pl=vat_p1,
var'_c2=var_c2, var_p2=var_p2,
var_g-va r_g} l

1rnport hgvsdatapruvidersmla
hdp = hgvs.riataproviders.IIta_rnnnect{J

Project transcript variant NM_132?63.2:c.633+403C:-T

mapped fll_lBZT53.2:E.EIEﬂ+4-EI3E:T ilth EFT-195.1:p.”
to GRCh37 primary assembly using splign alignments

1:0- l'l'l ﬁﬂllBTHBJmJBlCaT [HP ﬁﬂllﬁ-ﬂdﬂlmiEiEf'EJI-F'hell
via NE_El-3‘BEl-Bl. l :g. 1595599155311

twort hgvs.vari.antrnapper
vrn = hgvs .variantrnapper.Easvvariantr'lapperf
hII:l|:Ir prirnarv_asserrl11y='ﬁrtcnj?', att_a1n_rnethed='spl.igrl'i
var_g = vn.c_to_gtvar_cli a _ _
var 9 import hgvs.va11dator
' import hgvs_exceptions
vr = hgvs.velidator.validatorlhdp=hdpl
trv:
vr.vatidatcl hp.parsc_hgv5_variantt 'l'tr'l catterszotmesttst'i l
vr.vatioatet hp.parse_hgv5_var1antt 'rr~'l _eetlsr32u.t:c.2strer'i I
except hgvs.exceptions.HGv5Error as e:
printtei

Validate a variant

Scoucncc‘IlariantlBCe‘vlC 396961.13. type-=9. poscoit=15655991o5am

Project genomic variant to a new transcript

vrn. rete-vant_tran5c r1 pts l va r'_q I

[.m lag-“53.2.! .HH Bglgﬁﬂd.‘ .m Hanan-NIT] M1__EIEIllBT32|3.1:r_.281AaT: Valiant reference does not agree with

refe rence SEEIIJEHEE

var c2 = vm.g to ctvar g, 'rrrr ou113:32e.1 }@
var c2

SequenceVariant.[artiﬁjtillﬁﬂll. tvaEt. pu5edit=EBICaTi

Fig. 1. Using the hgvs package to project a variant in MCLl from one transcript to another Via GRCh37 chromosome 1. (a) An object representation of
the result of parsing cNM_182763.2:C.688 + 403C>T’. Selected attributes are shown beneath. 0)) A diagram of the MCLl locus with ﬁve representations
of a single variant. (c) Python code that demonstrates parsing, mapping between sequences, formatting and validating. Gray outline boxes enclose input,
and the results appear immediately beneath. Circled numbers indicate a correspondence between the variants in (a) and code in (c). An SNVO, originally
reported in literature as NM_182763.2:C.688 + 403C>T (rs20143056l), is projected onto chromosome 1 as variant (=3, and then projected to an alternative
transcript as variant. The inferred proteine changes of variants 0 and 9 are shown as protein variants9 and 6. The results are formatted by ‘stringifying’
them using standard Python printing commands. Validation for a valid variant (281C>T; no error generated) and an error for an invalid variant
(281A>T) are shown

object representation. For a full list of object classes, readers
should consult the source code.

The HGVS parser presented here is based on a parsing
expression grammar and was inspired by previous work

(Laros et al., 2011). There are 127 parsing rules to cover DNA,
RNA, CDS and protein parsing. Any rule may be invoked to
parse components of valid HGVS strings into an appropriate
type. For example, the c_edit rule may be used to parse an

 

269

112 /810'S[12umo [p.IOJXO'SotlBIIlJOJUTOTQ/ﬁdllq 11101; prBOIUAAOG

9IOZ ‘09 lsnﬁnv uo ::

R.K.Hart et al.

 

HGVS substring such as ‘c.688+403C>T’. Following Python
conventions, formatting is implemented using the str() method
of each class.

The hgvs package requires sequence data and exon structures
to map variants between the genome and transcript coordinates,
to infer protein sequence changes from transcripts and to valid-
ate variants. The data provider interface declares seven methods
required to support hgvs functionality; developers may imple-
ment a subclass of the abstract interface to use data from
other sources. The hgvs package includes a concrete implemen-
tation based on the publicly available Universal Transcript
Archive (information about UTA is available with package
documentation).

In addition to the syntactic validation provided during par-
sing, the hgvs package includes validation tools to ensure that a
SequenceVariant object conforms to the HGVS guidelines and to
catch common errors. For performance reasons, the Validator
distinguishes intrinsic and extrinsic validation: intrinsic validation
asserts internal correctness of the object, such as requiring that
the start position is less than or equal to the end position or that
the length of the location range speciﬁed for an insertion is one,
and extrinsic validation invokes external data for validation,
such as verifying that the reference sequence speciﬁed in the vari-
ant matches that from a source database.

The hgvs package provides tools to transform (‘map’) variants
between genomic (g.), mRNA (r.), CDS (c.) and protein (p.)
variants. Of particular note is the implementation of an indel
aware mapper that correctly accounts for insertions and dele-
tions in transcripts with respect to a genomic reference. These
discrepancies occur owing to natural polymorphisms and
sequencing errors, and occur in ~1.6% of current RefSeq tran-
scripts (Garla et al., 2011). The package also includes a transcript
liftover tool to migrate variants between different transcripts.
When used in conjunction with UTA, liftover may also be per-
formed between the same RefSeq transcript aligned to a genomic
reference by Splign (Kapustin et al., 2008) and BLAT (Kent,
2002). Splign and BLAT provide substantially different exon
structures for ~2.7% of RefSeq transcripts.

3 TESTING, VALIDATION AND LIMITATIONS

Reliable and robust variant manipulation is an essential goal of
this work. The hgvs package implements extensive automated
tests that are run on every commit made to the hgvs code, and
the test results are publicly accessible. Unit tests, which validate
low-level functionality, are available for nearly all code in the
package. Functional tests, which verify parsing, formatting,
transformation and validation, are extensive. In particular, 163
manually curated mappings between g., c. and p. representations
in problematic genes were developed by geneticists and curators.
Additional functional tests include >20 000 intronic and exonic
single nucleotide variants, >2000 deletions, insertions and dele-
tion-insertions variants and 11 duplications in 54 genes that ex-
ercise a variety of transcript features, such as strand, CDS start
not in exon 1 and genome-transcript indels.

In addition to the above automated tests, a comparison of
genome-to—transcript transformations generated by the hgvs

package and Mutalyzer’s batch positionConverter tool using
110125 genomic variants in 57 ACMG ‘Must Report’ genes
(Green et al., 2013) showed >99.9% concordance
(Supplementary data). Mismatches occurred only in transcripts
that have indels in the genome-transcript alignment. Because hgvs
uses an indel aware mapper and Mutalyzer does not (Peter
Taschner, personal communication), these differences are ex-
pected and highlight an advantage of the library presented here.

Like the HGVS recommendations, the hgvs package presented
here is a work in progress. The package does not yet implement
the full recommendations: important limitations, which are de-
tailed in the issue tracker, include lack of variant canonicaliza—
tion, the inability to represent compound, mosaic and chimeric
variants and lack of support for inversions. Patches and pull
requests are welcome.

4 AVAILABILITY, INSTALLATION AND USE

The hgvs source code, comprehensive documentation, examples,
installation instructions, issue tracking, test results and mailing
list are available Via the BitBucket repository. In addition, the
package is also available at PyPI; with modern versions of
Python, installation involves simply typing ‘pip install hgvs’.

Figure 1 illustrates the four primary functions provided by the
hgvs package—parsing, formatting, mapping and validating. A
variant in MCLl, NM_182763.2:C.688 +403C>T (rs20143056l),
is parsed into a variant object that exposes variant components
as Python properties. The variant is then projected onto
NM_001197320.1 Via GRCh37 and a Splign-based exon align-
ment. A validation error is demonstrated with NM_
001197320.1:c.281A>T, which speciﬁes an incorrect reference
nucleotide.

Conﬂict of interest: All authors are employed by and have equity
in the company that sponsored this work.

REFERENCES

Cingolani,P. et al. (2012) A program for annotating and predicting the effects of
single nucleotide polymorphisms, Sanff: SNPs in the genome of Drosophila
melanogaster strain wlll8; iso-2; iso-3. Fly ( Austin ), 6, 80—92.

Garla,V. et al. (2011) MU2Aireconciling the genome and transcriptome to deter-
mine the effects of base substitutions. Bioinformatics, 27, 416—418.

Green,R.C. et al. (2013) ACMG recommendations for reporting of incidental ﬁnd-
ings in clinical exome and genome sequencing. Genet. Med, 15, 565—574.

Kapustin,Y. et al. (2008) Splign: algorithms for computing spliced alignments with
identiﬁcation of paralogs. Biol. Direct, 3, 20.

Kent,W.J. (2002) BLATithe BLAST-like alignment tool. Genome Res., 12,
656—664.

Laros,J.F.J. et al. (2011) A formalized description of the standard human variant
nomenclature in Extended Backus-Naur Form. BM C Bioinformatics, 12
(Suppl 4), SS.

Mclaren,W. et al. (2010) Deriving the consequences of genomic variants with the
Ensembl API and SNP Effect Predictor. Bioinformatics, 26, 1—2.

Taschner,P.E.M. and den Dunnen,J.T. (2011) Describing structural changes by ex-
tending HGVS sequence variation nomenclature. Hum. Murat, 32, 507—511.

Wildeman,M. et al. (2008) Improving sequence variant descriptions in mutation
databases and literature using the mutalyzer sequence variation nomenclature
checker. Hum. Murat, 29, 6—13.

 

270

112 /§JO'S{12umo [p.IOJXO'SOilBIIHOJUIOIQ/ﬁdllq 111011 prBOIUAAOG

9IOZ ‘09 lsnﬁnv uo ::

