Motivation: Building the histogram of occurrences of every k-symbol long substring of nucleotide data is a standard step in many bioinformatics applications, known under the name of k-mer counting. Its applications include developing de Bruijn graph genome assemblers, fast multiple sequence alignment and repeat detection. The tremendous amounts of NGS data require fast algorithms for k-mer counting, preferably using moderate amounts of memory. Results: We present a novel method for k-mer counting, on large datasets about twice faster than the strongest competitors (Jellyfish 2, KMC 1), using about 12 GB (or less) of RAM. Our disk-based method bears some resemblance to MSPKmerCounter, yet replacing the original minimizers with signatures (a carefully selected subset of all minimizers) and using (k, x)-mers allows to significantly reduce the I/O and a highly parallel overall architecture allows to achieve unprecedented processing speeds. For example, KMC 2 counts the 28-mers of a human reads collection with 44-fold coverage (106 GB of compressed size) in about 20 min, on a 6-core Intel i7 PC with an solid-state disk. Availability and implementation: KMC 2 is freely available at http://sun.aei.polsl.pl/kmc.
IntroductionOne of common preliminary steps in many bioinformatics algorithms is the procedure of k-mer counting. This primitive consists in counting the frequencies of all k-long strings in the given collection of sequencing reads, where k is usually more than 20 and has applications in de novo assembly using de Bruijn graphs, correcting reads and repeat detection, to name a few areas. More applications can be found, e.g. in, with references therein. K-mer counting is arguably one of the simplest (both conceptually and programmatically) tasks in computational biology, if we do not care about efficiency. The number of existing papers on this problem suggests, however, that efficient execution of this task, with reasonable memory use, is far from trivial. The most successful of early approaches was Jellyfish (), maintaining a compact hash table (HT) and using lock-free operations to allow parallel updates. The original Jellyfish version [as presented in Marais and] required more than 100 GB of memory to handle human genome data with 30-fold coverage. BFCounter () employs the classic compact data structure, Bloom filter (BF), to reduce the memory requirements due to preventing most single-occurrence k-mers (which are usually results of sequencing errors and for most applications can be discarded) from being added to an HT. Although BF is a probabilistic mechanism, BFCounter applies it in a smart way, which does not produce counting errors. DSK () and KMC () are two disk-based algorithms. On a high level, they are similar and partition the set of k-mers into disk buckets, which are then separately processed. DSK is more memory frugal and may process human genome data in as little as 1.1 GB of RAM (), whereas KMC is faster but typically uses about 1116 GB of RAM. Turtle (bears some similarities to BFCounter. The standard BF is there replaced with its cache-friendly variant () and the HT is replaced with a sorting and compaction algorithm (which, accidentally, resembles a component of KMC), apart from adding parallelism and a few smaller modifications. Finally, MSPKmerCounter () is another disk-based algorithm, based on the concept of minimizers, described in detail in the next section. In this article, we present a new version of KMC, one of the fastest and most memory efficient programs. The new release borrows from the efficient architecture of KMC 1 but reduces the disk usage several times (sometimes about 10 times) and improves the speed usually about twice. In consequence, our tests show that KMC 2 is the fastest (by a far margin) algorithm for counting k-mers, with even smaller memory consumption than its predecessor. There are two main ideas behind these improvements. The first is the use of signatures of k-mers that are a generalization of the idea of minimizers (). Signatures allow significant reduction of temporary disk space. The minimizers were used for the first time for the k-mer counting in MSPKmerCounter, but our modification significantly reduces the main memory requirements (up to 35 times) and disk space (about 5 times) when compared with MSPKmerCounter. The second main novelty is the use of (k, x)-mers (x  0) for reduction of the amount of data to sort. Simply, instead of sorting some amount of k-mers, we sort a much smaller portion of (k  x)-mers and then obtain the statistics for k-mers in the post-processing phase.
ConclusionAlthough the dominating trend in IT solutions nowadays is the cloud, the progress in bioinformatic algorithms shows that even home computers, equipped with multi-core CPUs, several gigabytes of RAM and a few fast hard disks (or one SSD disk) get powerful enough to be applied for real 'omics' tasks, if their resources are loaded appropriately. The presented KMC 2 algorithm is currently the fastest k-mer counter, with modest resource (memory and disk) requirements. Although the used approach is similar to the one from MSPKmerCounter, we obtain an order of magnitude faster processing, due to the following KMC features: replacing the original minimizers with signatures (a carefully selected subset of all minimizers), using (k, x)-mers and a highly parallel overall architecture. As opposed to most competitors, KMC 2 worked stably across a large range of datasets and test settings. In real numbers, we show that it is possible to count the 28-mers of a human reads collection with 44-fold coverage (106 GB of compressed size) in about 20 min, on a 6-core Intel Core i7 PC with an SSD. With enough amounts of available RAM, it is also possible to run KMC 2 in memory only. In our preliminary tests, it gave rather little compared with an SSD (about 510% speedup) but may be an option in datacenters, with plenty of RAM but possibly using network HDDs with relatively low transfer. In this scenario, a memory-only mode should be attractive. After our work was ready, we learned about an interesting possibility of using frequency-based minimizers (). The idea is to select the (globally) least frequent m-mer in a given k-mer and it dramatically reduces the memory use in the application of enumerating the maximal simple paths of a de Bruijn graph. In our preliminary experiments freq-based minimizers reduce the memoryTimek = 28 k = 55. Dependence of KMC 2 processing time on maximal available RAM and type of disk for H.sapiens 2 dataset. There are 4 results for k  55 and 13 GB RAM. These results are for set 6 GB, 8 GB, 10 GB, 12 GB as maximal RAM usage. However, the largest bin enforced to spend at least 13 GB of RAM