Motivation: Many de novo genome assemblers have been proposed recently. The basis for most existing methods relies on the de bruijn graph: a complex graph structure that attempts to encompass the entire genome. Such graphs can be prohibitively large, may fail to capture subtle information and is difficult to be parallelized. Result: We present a method that eschews the traditional graph-based approach in favor of a simple 3 extension approach that has potential to be massively parallelized. Our results show that it is able to obtain assemblies that are more contiguous, complete and less error prone compared with existing methods. Availability: The software package can be found at
INTRODUCTIONDe novo genome assembly has been a fundamental problem in bioinformatics since the advent of DNA sequencing. The secondgeneration sequencing technologies such as Illumina Solexa and ABI SOLiD have introduced a new sense of vigor to the field. The short length of the sequences coupled with high coverage and high level of noise has transformed de novo assembly to a tractable yet challenging proposition. The ease at which paired-end read libraries can be generated on these platforms is an added advantage. A number of works have been proposed to assemble short reads. The first few de novo assemblers developed to handle highthroughput short reads were based on base-by-base 3 extension. SSAKE, VCAKE and SHARCGS () are examples using this principle. To resolve ambiguities, these methods adapted trivial heuristics such as 'selecting the base with maximum overlap' or 'selecting the base with the highest consensus'. Such arbitrary criteria results in substandard assemblies that were often a compromise between contiguity and error rate. Furthermore, the approaches were not scalable to handle medium or large genomes; therefore, their use is restricted to assembling BAC clones or small bacteria genomes. They were also not designed to make use of paired-end reads, thus greatly limiting their usefulness in assembling high-throughput data. * To whom correspondence should be addressed.The more practical approaches for assembling high-throughput short reads have spawned based on de Bruijn graph approach. Velvet () is perhaps the most widely used method for de novo genome assembly today. It is very fast in execution, fairly memory efficient and produces reasonably accurate assemblies. Similar to all other methods based on de Bruijn graph, Velvet requires the entire genome to be stored in a graph structure. In the presence of noise, the graph may be too large to be stored on system memory. Furthermore, resulting assembly generated from Velvet tends to contain many errors at small repeat regions. Another approach, Euler-USR () is very similar in concept to Velvet, but employs more sophisticated error detection and correction steps. However, in practice, we noted Velvet produces more contiguous and complete assemblies in comparison with EulerUSR. Both Velvet and Euler-USR take full advantage of paired-end read libraries. One of the major shortcomings of de Bruijn graph approaches is the inability to parallelize the assembly process. This is a critical requirement as many powerful computers utilize multiple processors where numerous threads can be run seamlessly in parallel. Introduction of ABySS () tackled this issue. The core assembly algorithm of ABySS is very similar to that of Velvet, but it allows de Bruijn graph to be distributed across multiple cores/nodes, and each core/node can operate on the graph independently to a certain extent. The assembly result of ABySS is similar to that of Velvet. However, we noticed that when executed in parallel in a multi-core single computer, Abyss does not offer any advantage over Velvet in term of execution time or memory usage. To utilize Abyss efficiently, it requires a multi-node computing cluster that may seem a disadvantage in an era where computers are increasingly made faster by adding more cores within a single CPU. SOAPdenovo () addressed many of these issues by introducing a de Bruijn graph-based method that can seamlessly takes advantage of multi-core systems. Allpaths/Allpaths2 () appears to be the most accurate method at present. It introduces an interesting hybrid approach where the genome is still stored as a large graph; however, the graph is separated into different segments and assembly of these segments can be carried independently. This makes it possible to run some stages of Allpaths algorithm in parallel. The high accuracy of Allpaths is contributed by the fact that it tries all possible ways to assemble every segments; however, this comes at a tremendous cost in terms of time and memory usage, and therefore it will not augment well for larger genomes. We propose the method PE-Assembler that is capable of handling large datasets and produces highly contiguous and accurate assemblies within reasonable time. Our approach is based on simple 3 extension approach and does not involve representing the entire genome in the form of a graph. Fundamentally, it is similar to other 3 extension approaches such as SSAKE, VCAKE and SHARCGS. However, it improves upon such early approaches in multiple ways. The extensive use of paired-end reads ensures that the dataset is localized within the region. Hence, our method can be run in parallel to greatly speedup the execution while staying within reasonable system requirements. Ambiguities are resolved using a multiple path extension approach, which takes into account sequence coverage, support from multiple paired libraries and more subtle information such as the span distribution of the paired-end reads.
DISCUSSIONPE-Assembler has demonstrated that it is possible to obtain complete and highly accurate de novo genome assemblies using high-throughput sequencing data within reasonable time and memory constraints. The highlight of PE-Assembler is that it eschews the traditional graph-based approach in favor of a simple extension approach. The advantages of this approach are numerous. Memory requirements of graph-based approaches seem to increase exponentially as genome and data size increase. This was highlighted by the inability of Velvet and Allpaths2 to cope with simulated HG18 Chr10 dataset. In contrast, PE-Assembler produced a very usable assembly within a realistic memory limit. Our approach is fundamentally similar to other 3 extension approaches such as SSAKE, SHARCGS and VCAKE, but distinguishes itself due to its extensive use of paired-end reads. Not only does it make such approach scalable to larger genomes' datasets by localizing data, it also contributes to its high accuracy. As evident from both simulated and experimental data results, PE-Assembler is the least prone of all algorithms to misassemble different regions of the genome in a continuous segment.Perhaps the most important aspect of PE-Assembler is its ability to seamlessly parallelize the assembly process. Multiple threads can simultaneously assemble the genome at various positions across the genome, while a simple detection mechanism will ensure that multiple assemblies of the same region are highly unlikely. Also noteworthy is that parallel assembly in PE-Assembler does not come at an extra cost in memory as in other methods such as Allpaths2 or ABySS. Being able to massively parallelize the assembly process at no extra overhead, it will prove valuable in assembling mammalian genomes as well as in larger metagenomics projects. With minor modifications, this approach can be extended to be run in a computer cluster across multiple nodes to further decrease the running time.