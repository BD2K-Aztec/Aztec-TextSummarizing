Motivation: A standard approach to classifying sets of genomes is to calculate their pairwise distances. This is difficult for large samples. We have therefore developed an algorithm for rapidly computing the evolutionary distances between closely related genomes. Results: Our distance measure is based on ungapped local alignments that we anchor through pairs of maximal unique matches of a minimum length. These exact matches can be looked up efficiently using enhanced suffix arrays and our implementation requires approximately only 1 s and 45 MB RAM/Mbase analysed. The pairing of matches distinguishes non-homologous from homologous regions leading to accurate distance estimation. We show this by analysing simulated data and genome samples ranging from 29 Escherichia coli/Shigella genomes to 3085 genomes of Streptococcus pneumoniae. Availability and implementation: We have implemented the computation of anchor distances in the multithreaded UNIX command-line program andi for ANchor DIstances. C sources and documentation are posted at
IntroductionThe spread of infectious diseases is nowadays often monitored by sequencing the genomes of the outbreak strains. Since a given pandemic is usually caused by the rapid expansion of a single clone, monitoring by sequencing leads to the accumulation of hundreds to thousands of similar genome sequences. For example,studied the spread of the multi-drug resistant Escherichia coli strain ST131, which causes extra-intestinal infections in humans. The authors sequenced 99 outbreak strains and reconstructed their phylogeny. This revealed that the outbreak was caused by a single lineage of ST131. On an even larger scale,studied pneumococcal carriage in a refugee camp by sequencing 3085 strains of Streptococcus pneumoniae, which causes pneumoniae in humans. Again, phylogeny reconstruction based on these genomes was an early step in the study. Classifying bacteria by clustering their genomes is set to become routine. For this purpose,computed a multiple sequence alignment of their E.coli ST131 strains using the program mugsy (). It is based on the MUMmer software (), which makes mugsy one of the fastest multiple genome aligners available: it took only 19 h to align 57 complete E.coli genomes. However, the run time of mugsy becomes unacceptable when applied to the recently collected samples of hundreds or even thousands of bacterial genomes.For their study of 3085 pneumococcal isolates,mapped the sequencing reads onto a reference genome, thereby approximating a multiple sequence alignment. Such alignment by mapping is widely used, andhave shown that its accuracy can be further improved by mapping against multiple reference genomes instead of the customary single reference. Their implementation of this idea, REALPHY, requires 2 min and 250 MB/Mbase analysed. The genome of S.pneumoniae is 2.2 Mbase long, so REALPHY would run 9.4 days on the 3085 S.pneumoniae isolates. However, a more prohibitive aspect of REALPHY might be the RAM requirement of 1.7 TB. Perhaps surprisingly, it is not necessary to compute an explicit alignment for phylogeny reconstruction. This insight has sparked interest in devising alignment-free methods for rapidly calculating pairwise distances between genomes (Haubold, 2014), which can then be clustered using various quick algorithms (). Alignment-free distance computation is either based on counting words of a certain length or recording match lengths (). When counting words, there is a choice between the traditional approach of counting exact words and a more recent method of looking for words that enclose one mismatch. The latter is implemented in the program co-phylog (), which gives better distances than exact word counting while requiring only moderate additional resources ().devised an alignment-free estimator of genetic distance based on match lengths. The expected match length is the inverse of the proportion of mismatches. For example, if 1% of positions between two genomes are mismatched, the expected match length is 100. Domazet-Loo and Haubold (2009) implemented this idea using a generalized suffix tree of all input sequences to look up the match lengths. Their program kr computes the distances between the complete genomes of 29 E.coli/Shigella strains in just 5.5 min on a single processor. However, this takes 5.3 GB RAM and kr has been criticized for excessive RAM utilization (). Moreover, Yi and Jin (2013) noted that co-phylog gave a better phylogeny when applied to the benchmarking sample of 29 E.coli/Shigella genomes. This has prompted us to devise a replacement for kr. Our new strategy is to look for mismatches that are bracketed by long exact matches, which we call anchors. We show through simulation that the resulting program andi, for ANchor DIstances, is accurate, fast and memory efficient. Moreover, we apply andi to three sets of bacterial genomes: the 29 genomes of E.coli/Shigella Yi and Jin (2013) used for benchmarking co-phylog, the 109 genomes of E.coli ST131 studied byof which they sequenced 99 strainsand the 3085 genomes of S.pneumoniae sequenced by. In each case, andi quickly recovers pairwise distances. For the E.coli samples, we compare the new distances to alignment-based distances and find they are so similar that they yield almost identical phylogenies.
DiscussionOur new distance measure, d a , approximates local alignments by anchoring them with long, unique matches (). The requirement that the matches are equidistant in the query and the subject () is equivalent to restricting the analysis to ungapped alignments. andi is therefore a cross between the early version of BLAST () and the genome aligner MUMmer (): From early BLAST it inherits the idea of ungapped local alignments, from MUMmer the idea of looking up unique matches by indexing the subject. Domazet-Loo and Haubold (2009) had previously used the power of indexing algorithms to estimate the number of substitutions from the match length distribution. Their program kr works on the same principle as the average common substring distance (), except that kr implements theory byto transform common substring lengths to mutation rates. Fast as the average common substring methods are, they suffer from two disadvantages: First, local fluctuations in the mutation rate affect the average match length. As a result, the same number of mutations can lead to different distances depending on the degree to which the mutations are clustered.have used this property to devise a test for recombination. andi does not have this problem as it counts mutations directly rather than inferring them from match lengths. The second disadvantage of match-length based methods is that matches induced by non-homologousFast and accurate estimation of evolutionary distancesregions are hard to distinguish from matches induced by highly divergent regions. Even a moderate divergence of K  0.1 implies an average match length of 10. Compare this to the expected length of a random match in a 1 Mbase sequence, which according to the theory byis 10.4. To overcome this limitation of match length distances, Leimeister and Morgenstern (2014) proposed a k-mismatch generalization. They show that this outperforms the classical zero-mismatch version of their distance. However, it remains unclear how to choose the critical parameter k when applying this method. Instead of a generalized mismatch approach, we bracket mutations with paired anchors. This should give more accurate results than kr, and andi did compute a better tree for 29 E.coli genomes than co-phylog, which in turn gave a better tree than kr. Hence, andi is substantially more accurate than kr. The accuracy of andi is excellent when applied to simulated sequences with a wide range of substitution rates, K (). However, at K  0.5 the search for suitable anchors fails increasingly often (), which cannot be overcome by lowering the minimum anchor length (Supplementary). Hence, our method is effectively limited to K 0:5. To get an intuition for the evolutionary times implied by K  0.5, consider the average synonymous substitution rate in mammals of 3:51  10 9 (). The last common ancestor that can occur in a tree restricted to K 0:5 lived 0:5=3:51=10 9 =2  71  10 6 years ago. This would allow the analysis of great apes, which diverged 15:7  10 6 years ago () and mice (Muridae, 26:9  10 6 years), but not of these two groups together (92:3  10 6 years). Apart from maximizing accuracy, we strove to minimize time and memory usage by implementing three ideas: (i) Streaming of query against subject as first implemented in vmatch speeds up suffix array construction compared with the suffix array of all input sequences underlying kr; it also uses much less memory. Our second idea was (ii) to construct only as many enhanced suffix arrays as there are genomes in the sample, rather than constructing an enhanced suffix array for each pairwise comparison. This means that for a sample of n genomes andi requires only n suffix array constructions, whereas a program like mugsy requires the computation of On 2  suffix trees. The third idea was (iii) multithreading, which allows access to the multi-processor architecture of modern computers. However, other programmers might have chosen a different combination of time/memory consumption. For example, vmatch uses half as much memory as andi for suffix array construction, but is slower than the libdivsufsort library we used. When clustering hundreds of genomes, efficiency becomes paramount. As shown in, andi uses only 1 s/Mbase and 45 bytes/bp when applied to simulated sequences. There is an intimate connection between the efficiency of andi and its limitation to closely related sequences: andi approximates local alignments by concatenating exact matches. Looking up exact matches is fast, but this strategy breaks down for divergent sequences where homologous matches become shorter than random matches. This phenomenon is also the reason why fast genome alignment programs like mauve and mugsy work best when applied to closely related genomes (). The accuracy and efficiency observed with simulated data carried over to the analysis of genomes. Here, we compared andi to co-phylog as Haubold (2014) had found this to be the best alignment-free distance estimator for long sequences. However, andi gave a more accurate tree when compared to the tree based on the mugsy alignment (). This improvement in accuracy came without a time penalty as co-phylog computed its tree 36 times faster than mugsy, while andi was a thousand times faster than the alignment. The superior speed of andi comes from the structure of its algorithm and the multithreading; without multithreading, andi would still be 1.6 times faster than co-phylog when applied to the 29 E.coli/Shigella genomes. The memory consumption of andi is strictly linear in the number of threads, while time is roughly inversely proportional to the number of threads. This gives the A B. Phylogeny of 3085 stains of S.pneumoniae (). A: Based on distances computed using co-phylog (user the opportunity to trade speed for memory and processors, depending on the hardware available. Aligning the 109 genomes of E.coli ST131 took mugsy 5.6 days and 52.7 GB RAM. Compare this to the 5 h 33 min it took mugsy to align 29 E.coli genomes. In other words, a 3.8 times larger sample took 24.6 times longer to align. In contrast, andi took with 1 min, 21 s only 4.1 times longer, yielding the correct classification of strains into clades AC in. Moreover, the memory requirement of mugsy grew 18-fold, while that of andi grew by only 7% to 7.7 GB. These comments are not meant to imply that the mugsy alignment computed in the original study was superfluous; it was used for a number of analyses apart from phylogeny reconstruction, including the detection of horizontal gene transfer (). However, quick clustering of genomes is useful, if only as a quality control step. For our final application, we chose the set of 3085 genomes of S.pneumoniae, because here an alignment program like mugsy would run far longer than anyone is willing to wait. The current method for comparing sets of bacterial genomes this size is mapping the reads to a reference genome. There is some debate as to the accuracy of the resulting trees (). andi takes as input assembled contigs, which are generated from the raw reads early on in all genome sequencing projects. Given these contigs, andi analyses them in 7 h and 35 min using 23.8 GB RAM on a 32 processor computer. Such computing resources are available in most genomics labs. The three outlier strains identified by andi are identical to those found by co-phylog after a 36.5 days run. This is gratifying and underlines the usefulness of our program.