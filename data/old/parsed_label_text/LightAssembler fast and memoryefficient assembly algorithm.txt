Motivation: The deluge of current sequenced data has exceeded Moores Law, more than doubling every 2 years since the next-generation sequencing (NGS) technologies were invented. Accordingly, we will able to generate more and more data with high speed at fixed cost, but lack the computational resources to store, process and analyze it. With error prone high throughput NGS reads and genomic repeats, the assembly graph contains massive amount of redundant nodes and branching edges. Most assembly pipelines require this large graph to reside in memory to start their workflows, which is intractable for mammalian genomes. Resource-efficient genome assemblers combine both the power of advanced computing techniques and innovative data structures to encode the assembly graph efficiently in a computer memory. Results: LightAssembler is a lightweight assembly algorithm designed to be executed on a desktop machine. It uses a pair of cache oblivious Bloom filters, one holding a uniform sample of g-spaced sequenced k-mers and the other holding k-mers classified as likely correct, using a simple statistical test. LightAssembler contains a light implementation of the graph traversal and simplification modules that achieves comparable assembly accuracy and contiguity to other competing tools. Our method reduces the memory usage by 50% compared to the resource-efficient assemblers using benchmark datasets from GAGE and Assemblathon projects. While LightAssembler can be considered as a gap-based sequence assembler, different gap sizes result in an almost constant assembly size and genome coverage.
IntroductionThe advent of next-generation sequencing (NGS) technologies has revolutionized the genomic research, but has not been able to provide a complete picture of a sequenced organism, since the relative positions of the billions of fragmented pieces are unknown without a genome assembly, which is a highly ambiguous overlapping puzzle (). De novo sequence assembly is an initial step towards downstream data analysis such as understanding evolutionary diversity across different species, evidenced by the multitude of data collection projects, including Genome 10K (). With the increasing efforts to sequence and assemble the genomes of more organisms, the assembly problem becomes more complicated and computationally intensive, especially with short inaccurate sequenced reads and genomic repeats (). Next-generation assembly algorithms play around two basic frameworks for efficiently completing their task: namely, De Bruijn and string graphs. In a De Bruijn graph, nodes are the set of distinct k-mers (substrings of length k) extracted from reads and the edges are the k  1  -overlap among them. The string graph is a simplified version of a classical overlap graph, where nodes are the sequenced reads and the non-transitive edges encode their suffix-to-prefix overlaps (). Many efforts have been made to fit the assembly graph into computer memory by the creation of resource-efficient genome assemblers. The term resource efficiency touches on both memory space and speed (). One compressed representation for a string graph is introduced in SGA () using FM-index and BurrowsWheeler transformation of the sequenced reads (). Recently, an incremental hashing technique combined with a probabilistic data structure (Bloom filter) revisited the string graph representation (Ben). The early condensed representation of De Bruijn graph is a sparse bit vector (), later implemented in a Gossamer sequence assembler (). This representation is changed in Minia () by introducing the exact representation of De Bruijn graph using the combination of a Bloom filter and a hash table that holds an approximate set of false positive nodes. The hash table is replaced in subsequent versions of Minia by a set of cascading Bloom filters for further space optimization (). The BurrowsWheeler transformation plays another role in the succinct representation of De Bruijn graph () by combining FM-index with frequency-based minimizers to reduce its complexity (). SparseAssembler () stores a subsample of k-mers in a hash table with their overlap links, recorded to maintain De Bruijn graph representation. ABySS () distributes the assembly graph nodes among different machines to reduce the representation complexity in a computer memory. Resource-efficient sequence assemblers vary in their assembly results in terms of both accuracy and contiguity measures. Each tool has a set of advantages and disadvantages according to the compromises made to achieve efficiency. Also, different evaluation studies () generally reported that the assembly algorithms differ in their outputs according to their working scenarios such as the quality of sequenced data and the complexity of the corresponding genome. There is a common conclusion that there is no one tool is best for all scenarios, and that there is still room for improvement in current assembly pipelines. In this paper, we revisit De Bruijn graph representation and introduce an optimized cache oblivious Bloom filter to the sequence assembly. Our method is inspired by Lighter's idea () to correct the sequenced errors using a pair of Bloom filters and a simple statistical test. Lighter stores a random sample of k-mers in a Bloom filter and uses them with a simple statistical test as seeds to classify the read positions as trusted or untrusted. While Lighter's goal is to use the trust-classified k-mers to correct erroneous ones, our ultimate goal is assembling these k-mers without error correction since they are already classified as trusted nodes (k-mers made by k consecutive trust-classified positions in the sequenced reads are considered to be trusted). LightAssembler obtains a uniform sample of k-mers by skipping g bases between the k-mers, where g is the gap length and stores them in a Bloom filter. The erroneous bases in a read will produce rare k-mers and are unlikely to survive in the sample compared to the abundant k-mers generated by the correct bases. The trustiness of a read position will be determined by comparing the number of k-mers that cover the position and appear in the sample to a statistically computed threshold. LightAssembler uses the k-mers made by k consecutive trust-classified reads positions as the set of assembly graph traversal nodes, while several assemblers rely on error correction modules to identify and correct the erroneous k-mers before starting the assembly process. The majority of error correction algorithms count the k-mers to determine their confidence and exclude ones with a multiplicity less than a specified threshold, which might result in missing a subset of true k-mers with low abundance. Other assemblers such as Velvet () rely on intensive graph simplification modules to resolve the erroneous structures introduced by erroneous bases such as tips and bubbles. Complex assembly pipelines combine both approaches and perform postprocessing graph filtering using mate pairs during scaffolding stage. LightAssembler uses only two passes over the sequenced reads to identify the approximate set of trusted nodes without error correction or intensive graph simplification modules. Also, one of the efficient representations of De Bruijn graph based on a Bloom filter is implemented in Minia and uses k-mer counting module to identify the set of trusted k-mers. Minia's counting algorithm follows a divide and conquer paradigm and utilizes the disk space as secondary memory storage. Our method is able to identify the set of trusted k-mers without utilizing either a counting module or disk-space overhead. We will present our comparable results to the current state-of-the-art sequence assemblers as well as resource-efficient ones using the simulated and benchmarked datasets.