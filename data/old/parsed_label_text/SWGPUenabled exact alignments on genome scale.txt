We propose SW#, a new CUDA graphical processor unit-enabled and memory-efficient implementation of dynamic programming algorithm, for local alignment. It can be used as either a stand-alone application or a library. Although there are other graphical processor unit implementations of the Smithâ€“Waterman algorithm, SW# is the only one publicly available that can produce sequence alignments on genome-wide scale. For long sequences, it is at least a few hundred times faster than a CPU version of the same algorithm. Availability: Source code and installation instructions freely available for download at
INTRODUCTIONSequence alignments are fundamental in bioinformatics, as they can provide information about unknown genes and proteins. They also have an important role in comparative sequence assembly (). In sequence alignments, both time and accuracy determine the successful performance of the method. Two classic algorithms for local alignment are Smith Waterman () and BLAST (). The SmithWaterman algorithm, an exact method, aims to find the best local alignment between two sequences. It is a variation of the dynamic programming, NeedlemanWunsch algorithm (). BLAST, a heuristic approach, runs faster and requires less space (memory). This advantage has a high relevance for the alignment of long DNA sequences. However, BLAST does not guarantee an optimal alignment. Although original SmithWaterman algorithm runs in quadratic time and space, the space complexity can be reduced to linear (). Despite the improvement in memory consumption, the SmithWaterman algorithm runs too slowly to be useful for discovering homologous genes. Hence, newer heuristic methods have been focused on reducing computation time at the expense of accuracy. Because only exact algorithms guarantee optimal alignments, there is a lack of a method for verifying results on genome scale. In addition, popular heuristic tools for global alignment, such as MUMMER () and LASTZ (), use dynamic programming algorithms in their final step.The increasing popularity of using CUDA-enabled graphical processor units (GPUs) has intensified work on accelerating the SmithWaterman algorithm. However, to the best of our knowledge, the only pairwise GPU implementation with optimized space complexity tested on the chromosome level is CUDAlign (), but it writes large amount of data to hard disk, uses a single card, and it is not publicly available. In this article, we present our parallel implementation of the SmithWaterman algorithm. highest substitution score. If the lengths of the subsequences are m and n, where m4n, parameter m 0 can be calculated as min(n(nt)/ge, m), where ge is the gap extension penalty. Padding p can then be calculated as ceil(0.5*(2*ntm 0 )). This observation is done by calculating the maximum score that a cell can reach and comparing it with the found score. The cell blocks that do not contain any of the diagonals between p and p(mn) are pruned. The reconstruction phase considers only the cells between the start and the endpoint (). We combined the wavefront method with the modified MyersMiller algorithm. This phase is done in parallel by both the CPU and the GPUs. For pruning, the banded algorithm is applied. The padding is calculated on the whole matrix and given to the solving halves for pruning. The maximum edit distance t is calculated as max(m, n)score, where m and n are the lengths of the sequences between the startpoint and the endpoint, and the score is the alignment score. The MyersMiller algorithm is applied recursively in this manner. Difference from the original algorithm is that it stops as soon as the solving submatrix size drops below defined boundaries. When this size is small enough, GPU part sends it to the CPU part. As the scores of the submatrices are known, the CPU part performs the banded algorithm with the backtracking. Finally, alignments of the submatrices are joined in the complete alignment.