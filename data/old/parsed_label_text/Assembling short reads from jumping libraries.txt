Motivation: Advances in Next-Generation Sequencing technologies and sample preparation recently enabled generation of high-quality jumping libraries that have a potential to significantly improve short read assemblies. However, assembly algorithms have to catch up with experimental innovations to benefit from them and to produce high-quality assemblies. Results: We present a new algorithm that extends recently described EXSPANDER universal repeat resolution approach to enable its applications to several challenging data types, including jumping libraries generated by the recently developed Illumina Nextera Mate Pair protocol. We demonstrate that, with these improvements, bacterial genomes often can be assembled in a few contigs using only a single Nextera Mate Pair library of short reads. Availability and implementation: Described algorithms are implemented in Cþþ as a part of SPAdes genome assembler, which is freely available at bioinf.spbau.ru/en/spades.
IntroductionIn an article titled 'De novo fragment assembly with short matepaired reads: Does the read length matter?',argued that availability of paired reads with long and accurate insert sizes (rather than the increase in the read length) is the most important factor for improving the quality of short read assemblies. However, while paired reads with long insert sizes have been extensively used in many assembly projects, robust generation of readpairs with accurate insert sizes proved to be difficult and have only been achieved recently. The recently emerged sample preparation technologies open new opportunities for genome assembly from short reads. For example, Illumina Nextera Mate Pair protocol generates long inserts (3 kb and longer) that feature rather tight insert size distribution and small rate of non-circularized fragments that result in read-pairs with abnormal distances. As discussed in, such read-pair libraries may enable assemblies approaching the quality of assemblies from long reads of length equal to the insert size. Moreover, they can potentially substitute the existing assembly approaches based on a combination of short paired-end libraries (with insert size less than 1 kb) and long jumping libraries (with insert sizes typically longer than 1 kb) by a pipeline based on a single Nextera Mate Pair library. However, even though the popular assembly algorithms perform well with the previously proposed approaches to sample preparation, they have not kept up with recent experimental innovations. To catch up, bioinfomaticians either need to design novel tools for every technology improvement or to develop a universal assembler that can be easily modified to support new data types. For example, Ray () and SPAdes () is based on the path extension framework that was proposed by the authors of the Ray assembler () and later implemented in the Telescoper () and PERGA () assemblers. Given a path P in the assembly graph (), EXSPANDER iteratively attempts to grow it by choosing one of its extension edges (all edges starting at the terminal vertex of the path P). The assembly graph is defined as simplified de Bruijn graph () of k-mers in reads after removal of bulges, tips and chimeric edges. To extend a path P, EXSPANDER computes the scoring function Score P e for each extension edge e using read-pairs with one read mapping to P and another read mapping to e (further referred to as (P, e)-connecting read-pairs). Afterward, EXSPANDER decides whether to select the top-scoring extension edge or to stop growing P. It iteratively repeats the path extension procedure starting with single-edge paths until every edge in the assembly graph is covered by at least one path and no path can be extended further. To generate equivalent contigs on both strands, EXSPANDER is implemented as a bidirectional approach that can extend a path in both directions. While the scoring function Score P e described in Prjibelski et al.(2014) works well with short libraries, it appears to be rather inefficient when using jumping libraries. The key limitation of the previously defined scoring function is that it analyses only (P, e)connecting read-pairs (where e is an extension edge of path P) and ignores read-pairs that connect path P with other edges. When an edge e is short and the variations in the insert sizes are large, there is a danger that no (P, e)-connecting read-pairs exist and thus ScoreP; e  0 even if e is the correct extension edge (). Thus, the decision rule may stop extending path P or even select an incorrect extension edge. Additionally, the approach described inis inapplicable for scaffolding procedure, since it is unable to jump over coverage gaps. In this article, we extend the EXSPANDER approach to scaffolding. This extension is important since scaffolding with jumping libraries may dramatically improve the assembly quality. We describe several algorithms that address these bottlenecks based on the following idea. Consider a set of extension paths E [rather than extension edges as in] that contain all sufficiently long paths (longer than the insert size) starting from the extension edges of the path P. Once the set E is constructed, we choose the best-scoring path E in E and extend path P by the first edge of E. Our analysis has shown that such conservative extension (by the first edge of the best-scoring extension path rather than by the entire path) provides more accurate assemblies. To perform scaffolding procedure, we allow extension paths to 'jump' over coverage gaps in the assembly graph. This intuitive approach, while appealing, is often impractical since the assembly graph is usually tangled, resulting in a prohibitively large number of extension paths. To reduce the running time, we have implemented the new algorithm based on the observation that, instead of the exhaustive search through the set of all extension paths, one can significantly prune this set using single reads and paired-end libraries (if available). We demonstrate that the new algorithm enables assemblies of nearly complete genomes from a single Nextera Mate Pair library. We also show that SPAdes, coupled with the improved EXSPANDER algorithm, outperforms other popular assemblers, such as ABySS (), IDBA-UD (), Ray (), SOAPdenovo () and Velvet () on various types of datasets.