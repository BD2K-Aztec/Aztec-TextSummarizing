
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:34+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">LightAssembler: fast and memory-efficient assembly algorithm for high-throughput sequencing reads</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Sara</forename>
								<surname>El-Metwally</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Molecular and Computational Biology</orgName>
								<orgName type="institution">University of Southern California</orgName>
								<address>
									<postCode>90089</postCode>
									<settlement>Los Angeles</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Faculty of Computers and Information</orgName>
								<orgName type="institution">Mansoura University</orgName>
								<address>
									<postCode>35516</postCode>
									<settlement>Mansoura</settlement>
									<country key="EG">Egypt</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Magdi</forename>
								<surname>Zakaria</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">Faculty of Computers and Information</orgName>
								<orgName type="institution">Mansoura University</orgName>
								<address>
									<postCode>35516</postCode>
									<settlement>Mansoura</settlement>
									<country key="EG">Egypt</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Taherhamza</forename>
							</persName>
						</author>
						<title level="a" type="main">LightAssembler: fast and memory-efficient assembly algorithm for high-throughput sequencing reads</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btw470</idno>
					<note type="submission">Received on April 2, 2016; revised on June 7, 2016; accepted on June 28, 2016</note>
					<note>Genome analysis *To whom correspondence should be addressed. Associate Editor: Inanc Birol Availability and implementation: https://github.com/SaraEl-Metwally/LightAssembler Contact: sarah_almetwally4@mans.edu.eg Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: The deluge of current sequenced data has exceeded Moore&apos;s Law, more than doubling every 2 years since the next-generation sequencing (NGS) technologies were invented. Accordingly, we will able to generate more and more data with high speed at fixed cost, but lack the computational resources to store, process and analyze it. With error prone high throughput NGS reads and genomic repeats, the assembly graph contains massive amount of redundant nodes and branching edges. Most assembly pipelines require this large graph to reside in memory to start their workflows, which is intractable for mammalian genomes. Resource-efficient genome assemblers combine both the power of advanced computing techniques and innovative data structures to encode the assembly graph efficiently in a computer memory. Results: LightAssembler is a lightweight assembly algorithm designed to be executed on a desktop machine. It uses a pair of cache oblivious Bloom filters, one holding a uniform sample of g-spaced sequenced k-mers and the other holding k-mers classified as likely correct, using a simple statistical test. LightAssembler contains a light implementation of the graph traversal and simplification modules that achieves comparable assembly accuracy and contiguity to other competing tools. Our method reduces the memory usage by 50% compared to the resource-efficient assemblers using benchmark datasets from GAGE and Assemblathon projects. While LightAssembler can be considered as a gap-based sequence assembler, different gap sizes result in an almost constant assembly size and genome coverage.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The advent of next-generation sequencing (NGS) technologies has revolutionized the genomic research, but has not been able to provide a complete picture of a sequenced organism, since the relative positions of the billions of fragmented pieces are unknown without a genome assembly, which is a highly ambiguous overlapping puzzle (<ref type="bibr" target="#b24">Nagarajan and Pop, 2013;</ref><ref type="bibr" target="#b25">Pevzner et al., 2001</ref>). De novo sequence assembly is an initial step towards downstream data analysis such as understanding evolutionary diversity across different species, evidenced by the multitude of data collection projects, including Genome 10K (<ref type="bibr" target="#b20">Koepfli et al., 2015</ref>). With the increasing efforts to sequence and assemble the genomes of more organisms, the assembly problem becomes more complicated and computationally intensive, especially with short inaccurate sequenced reads and genomic repeats (<ref type="bibr" target="#b17">Head et al., 2014</ref>). Next-generation assembly algorithms play around two basic frameworks for efficiently completing their task: namely, De Bruijn and string graphs. In a De Bruijn graph, nodes are the set of distinct k-mers (substrings of length k) extracted from reads and the edges are the k À 1 ð Þ-overlap among them. The string graph is a simplified version of a classical overlap graph, where nodes are the sequenced reads and the non-transitive edges encode their suffix-to-prefix overlaps (<ref type="bibr" target="#b13">El-Metwally et al., 2013</ref><ref type="bibr" target="#b23">Myers, 2005;</ref><ref type="bibr" target="#b24">Nagarajan and Pop, 2013</ref>). Many efforts have been made to fit the assembly graph into computer memory by the creation of resource-efficient genome assemblers. The term resource efficiency touches on both memory space and speed (<ref type="bibr" target="#b7">Chikhi et al., 2015</ref>). One compressed representation for a string graph is introduced in SGA (<ref type="bibr" target="#b31">Simpson and Durbin, 2012</ref>) using FM-index and Burrows–Wheeler transformation of the sequenced reads (<ref type="bibr" target="#b30">Simpson and Durbin, 2010</ref>). Recently, an incremental hashing technique combined with a probabilistic data structure (Bloom filter) revisited the string graph representation (Ben<ref type="bibr" target="#b0">Bassat and Chor, 2014</ref>). The early condensed representation of De Bruijn graph is a sparse bit vector (<ref type="bibr" target="#b11">Conway and Bromage, 2011</ref>), later implemented in a Gossamer sequence assembler (<ref type="bibr" target="#b10">Conway et al., 2012</ref>). This representation is changed in Minia (<ref type="bibr" target="#b9">Chikhi and Rizk, 2013</ref>) by introducing the exact representation of De Bruijn graph using the combination of a Bloom filter and a hash table that holds an approximate set of false positive nodes. The hash table is replaced in subsequent versions of Minia by a set of cascading Bloom filters for further space optimization (<ref type="bibr" target="#b27">Salikhov et al., 2014</ref>). The Burrows–Wheeler transformation plays another role in the succinct representation of De Bruijn graph (<ref type="bibr" target="#b3">Bowe et al., 2012</ref>) by combining FM-index with frequency-based minimizers to reduce its complexity (<ref type="bibr" target="#b7">Chikhi et al., 2015</ref>). SparseAssembler (<ref type="bibr" target="#b35">Ye et al., 2012</ref>) stores a subsample of k-mers in a hash table with their overlap links, recorded to maintain De Bruijn graph representation. ABySS (<ref type="bibr" target="#b32">Simpson et al., 2009</ref>) distributes the assembly graph nodes among different machines to reduce the representation complexity in a computer memory. Resource-efficient sequence assemblers vary in their assembly results in terms of both accuracy and contiguity measures. Each tool has a set of advantages and disadvantages according to the compromises made to achieve efficiency. Also, different evaluation studies (<ref type="bibr" target="#b4">Bradnam et al., 2013;</ref><ref type="bibr" target="#b12">Earl et al., 2011;</ref><ref type="bibr" target="#b19">Kleftogiannis et al., 2013;</ref><ref type="bibr" target="#b28">Salzberg et al., 2012</ref>) generally reported that the assembly algorithms differ in their outputs according to their working scenarios such as the quality of sequenced data and the complexity of the corresponding genome. There is a common conclusion that there is no one tool is best for all scenarios, and that there is still room for improvement in current assembly pipelines. In this paper, we revisit De Bruijn graph representation and introduce an optimized cache oblivious Bloom filter to the sequence assembly. Our method is inspired by Lighter's idea (<ref type="bibr" target="#b33">Song et al., 2014</ref>) to correct the sequenced errors using a pair of Bloom filters and a simple statistical test. Lighter stores a random sample of k-mers in a Bloom filter and uses them with a simple statistical test as seeds to classify the read positions as trusted or untrusted. While Lighter's goal is to use the trust-classified k-mers to correct erroneous ones, our ultimate goal is assembling these k-mers without error correction since they are already classified as trusted nodes (k-mers made by k consecutive trust-classified positions in the sequenced reads are considered to be trusted). LightAssembler obtains a uniform sample of k-mers by skipping g bases between the k-mers, where g is the gap length and stores them in a Bloom filter. The erroneous bases in a read will produce rare k-mers and are unlikely to survive in the sample compared to the abundant k-mers generated by the correct bases. The trustiness of a read position will be determined by comparing the number of k-mers that cover the position and appear in the sample to a statistically computed threshold. LightAssembler uses the k-mers made by k consecutive trust-classified reads positions as the set of assembly graph traversal nodes, while several assemblers rely on error correction modules to identify and correct the erroneous k-mers before starting the assembly process. The majority of error correction algorithms count the k-mers to determine their confidence and exclude ones with a multiplicity less than a specified threshold, which might result in missing a subset of true k-mers with low abundance. Other assemblers such as Velvet (<ref type="bibr" target="#b36">Zerbino and Birney, 2008</ref>) rely on intensive graph simplification modules to resolve the erroneous structures introduced by erroneous bases such as tips and bubbles. Complex assembly pipelines combine both approaches and perform postprocessing graph filtering using mate pairs during scaffolding stage. LightAssembler uses only two passes over the sequenced reads to identify the approximate set of trusted nodes without error correction or intensive graph simplification modules. Also, one of the efficient representations of De Bruijn graph based on a Bloom filter is implemented in Minia and uses k-mer counting module to identify the set of trusted k-mers. Minia's counting algorithm follows a divide and conquer paradigm and utilizes the disk space as secondary memory storage. Our method is able to identify the set of trusted k-mers without utilizing either a counting module or disk-space overhead. We will present our comparable results to the current state-of-the-art sequence assemblers as well as resource-efficient ones using the simulated and benchmarked datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Pattern-blocked bloom filter</head><p>A Bloom filter (<ref type="bibr" target="#b1">Bloom, 1970</ref>) is a memory-efficient data structure for storing a given subset of elements K U. In the assembly context, K is a subset of k-mers and U is the whole set of sequenced k-mers. It supports approximate membership queries on K using a compact representation of its elements (i.e. k-mers). A Bloom filter has a feature of one-sided error, which means if the filter reports yes for an element e then either e 2 K or with a small 'false positive' probability e 6 2 K. On the other hand, if the filter reports no then necessarily e 6 2 K. The standard implementation of a Bloom filter is a zero-initialized bit array B with length m and y independent hash functions. To insert an element e 2 K in a Bloom filter, the set of indices H 1 e ð Þ; H 2 e ð Þ;. .. :; H y e ð Þ are computed and their corresponding bits in B are set to one, that is 8e 2 K; B H i ðeÞ ½ ¼1, where 1 i y. The membership queries are achieved by evaluating the same set of hash functions on an element e and testing their corresponding bits. If all B H i ðeÞ ½ equal 1 then a Bloom filter answers yes and no otherwise. In a Bloom filter, each hash function has equal probability to choose a position in the bit array, so the false-positive rate p f for the bit array of size m with the number n of inserted elements is:</p><formula>p f ¼ 1 À e Ày n m À Á y</formula><p>By choosing appropriate Bloom filter parameters m and y, the false positive rate p f can be adjusted. The standard Bloom filter implementation is cache-inefficient since each insertion or membership query operation generates at most y cache misses. The cache-efficient variant of a Bloom filter (<ref type="bibr" target="#b26">Putze et al., 2007</ref>) is implemented by a sequence of consecutive blocks, each of size b that can fit into one-cache line. In this implementation, the first hash function is used to choose the block number and the subsequent hash functions are performing in the same chosen block. Therefore, a blocked Bloom filter minimizes the cache misses to one rather than y for each operation. To improve the implementation further in terms of the computation time, the precomputed hash patterns are used to set all y bits at once rather than doing this separately in each block, which is called Pattern-blocked Bloom filter. In a Pattern-blocked Bloom filter, the false-positive rate can be computed using the following equation (<ref type="bibr" target="#b33">Song et al., 2014</ref>):</p><formula>p f ¼ P B j j i b 0 i b y B j j</formula><p>where B j j ¼ m À b þ 1, size of a Pattern-blocked Bloom filter in terms of blocks; b, number of bits in one block; b 0 i , number of bits set to one in the i-th block; y; number of hash functions. The false-positive rate is increased in a Pattern-blocked Bloom filter compared to the standard implementation of a Bloom filter and the false positive generally can be managed using large m and y. LightAssembler uses the Pattern-blocked Bloom filter to hold a set of canonicalized k-mers extracted from the sequenced reads. The canonical k-mer is the minimum lexicographic k-mer of the k-mer itself and its reverse complement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">LightAssembler framework</head><p>The light version of an assembly algorithm can be viewed as the combination of two basic modules, graph construction and graph traversal as depicted in<ref type="figure" target="#fig_0">Figure 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Graph construction</head><p>The graph construction module has two stages, uniform k-mers sampling and trust/untrust k-mers filtering. The input to this module is the set of sequenced reads and the outputs are Bloom filter B and the trusted k-mers file. 2.2.1.1 Uniform k-mers sampling. The whole set of sequenced kmers are obtained using a sliding window of length k one base at a time across the input reads. The g-mers or g-spaced k-mers are obtained by skipping g bases between the k-mers. The gap values are in the range 1 g &lt; L À k þ 1, where L is the length of the sequenced read. LightAssembler uses this uniform sampling process to store a sample of k-mers (g-mers) in Bloom filter A. A gap size is chosen by a user or computed by LightAssembler parameters extrapolation module. g-mers in Bloom filter A represent a 1=g sample of the nodes diversity in De Bruijn graph of the sequenced genome. Base-called errors of the NGS technologies are typically identified as unusual events and their corresponding erroneous k-mers are occurring less frequently than the correct k-mers under the assumption of deep uniform coverage (<ref type="bibr" target="#b5">Chaisson et al., 2004;</ref><ref type="bibr" target="#b25">Pevzner et al., 2001;</ref><ref type="bibr" target="#b34">Yang et al., 2013</ref>). The most abundant sequenced k-mers will survive in the sample stored in Bloom filter A and we will use them with a simple statistical test as seeds to mark each read position as trusted or untrusted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1.2">Trusted</head><p>/untrusted k-mers filtering. A trusted k-mer is defined as a k-mer made up by k consecutive trust-classified read positions and it is untrusted otherwise. Each read position is classified as trusted or untrusted based on the following idea with illustration in<ref type="figure" target="#fig_1">Figure 2</ref>. Suppose that we have a sequenced read R ¼ r 1 r 2 r 3. .. :r L , a read position r i is overlapping by maximum x i k-mers where x i is defined as the following:</p><formula>x i ¼ i 1 i &lt; k k k i L À k þ 1 L À i þ 1 L À k þ 2 i L 8 &gt; &gt; &lt; &gt; &gt; : 9 &gt; &gt; = &gt; &gt; ;</formula><p>If a sequenced base r i is erroneously called, the overlapped x i kmers are all incorrect and occur rarely in the dataset. Accordingly, these incorrect k-mers are unlikely to survive in the sample stored in Bloom filter A. We define a statistically computed threshold for each read position r i such that if the number of overlapped x i k-mers appeared in the sample is less than the defined threshold, the read position r i is classified as untrusted. Otherwise the read position r i is classified as trusted (<ref type="bibr" target="#b33">Song et al., 2014</ref>). The multiplicity of an incorrect k-mer in the sequenced reads has been modeled previously using Poisson distribution (<ref type="bibr" target="#b6">Chaisson et al., 2009;</ref><ref type="bibr" target="#b21">Lander and Waterman, 1988;</ref><ref type="bibr" target="#b22">Melsted and Halldorsson, 2014;</ref><ref type="bibr" target="#b29">Simpson, 2014</ref>). We will assume that the erroneous k-mers will occur at some rate k e ¼ ce in the sequenced dataset and k 0 e ¼ ce=g in the sample stored in Bloom filter A where c and e are the expected coverage and error rate of the sequenced reads, respectively. Suppose M e is a random variable for the number of times an incorrect k-mer appears in the sample:<ref type="bibr">;1; Be;2; Be;3; Be;4 and Be;5</ref>The probability of an incorrect k-mer appears in the sample p 0 is defined as:</p><formula>M e $ Pois k 0 e À Á</formula><formula>p M e ! 1 ð Þ¼1 À p M e &lt; 1 ð Þ ¼ 1 À p M e ¼ 0 ð Þ ¼ 1 À e Àce=g</formula><p>By considering the false-positive rate p f of Bloom filter A that stores a sample of k-mers, we redefine p 0 as:We compute a threshold t 0 k for each x i ¼ k as the minimum integer that satisfies the following equations:</p><formula>p 0 ¼ p f þ 1 À p f À Á 1 À e À</formula><formula>p B e;k t k À 1 À Á ! 0:9 t 0 k ¼ t k þ k g " #</formula><p>Then for each x i 2 ½1; k À 1, we define other t 0 xi thresholds as:</p><formula>t 0 xi ¼ t 0 k Â x i k l m</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Graph traversal</head><p>Since our goal is efficiently using the computational recourses to construct and traverse De Bruijn graph, we found the most optimized traversal algorithm for visiting and marking the graph nodes is implemented in Minia. We modified Minia's traversal algorithm according to LightAssembler graph construction method. There are two steps in the graph traversal module: (i) computing branchingk-mers and (ii) simplifying De Bruijn graph and extending the branching-k-mers (<ref type="figure">Fig. 3</ref>). The inputs to this module are Bloom filter B and the trusted k-mers file and the output is the set of assembled contigs. 2.2.2.1 Branching-k-mers computation. The traversal algorithm starts by computing the set of branching nodes (k-mers have multiple extensions) by querying Bloom filter B for each k-mer in the trusted k-mer file. We use this file to store the set of trusted k-mers to avoid the third iteration over the dataset that might introduce false-positive nodes. The file contains only the minimum set of trusted graph nodes in a binary format. The file is removed after the branching k-mers are computed and stored in a hash table, which serves as a recording structure for the visited branching nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2.2">Graph simplification and branching</head><p>k-mers extensions. Every assembled contig represents a simple path starting from a branching node and ending with a marked branching node. Rather than marking every used node on a simple path that adds an additional space overhead, we only mark the branching nodes as terminal points for every simple path. The number of branching nodes also compared to the complete set of graph nodes is very small and depends on the genome complexity. Storing and marking only the branching nodes saves an additional space in LightAssembler implementation. The assembly graph has dead end paths called tips, LightAssembler removes the tips of length 2k þ 1 bases or shorter.</p><p>LightAssembler also resolves the bubbles that represent the multiple paths started from a branching node by traversing them until the convergence point is reached and accordingly, LightAssembler finds the best consensus sequence that is expressed by all multiple branches. LightAssembler ignores solving the complex bubbles that might solve using the paired-end information encoded in the sequenced libraries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">LightAssembler usability and scalability</head><p>LightAssembler has two parameters that a user must specify, a genome length G and a k-mer size k. A gap size g is an optional parameter, which can be set by a user or LightAssembler invokes the parameters extrapolation module to compute a gap size based on a sequenced coverage c and an error rate e. A user can utilize our suggested gap starting values presented in<ref type="figure" target="#tab_1">Table 1</ref>, which are computed based on the simulated datasets using different sequenced coverage and error rates. Also, the genome size and the k-mer size can be estimated using stand-alone tools such as KmerGenie (<ref type="bibr" target="#b8">Chikhi and Medvedev, 2014</ref>) and KmerStream (<ref type="bibr" target="#b22">Melsted and Halldorsson, 2014</ref>). Moreover, LightAssembler is a multithreaded program with an optional parameter t to specify the number of working threads, where the default value is one, for more detail of parallelized implementation see Supplementary 1 Results, section 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head><p>We evaluated the performance of LighAssembler against Minia v2.0.3 (<ref type="bibr" target="#b9">Chikhi and Rizk, 2013</ref>), SparseAssembler (<ref type="bibr" target="#b35">Ye et al., 2012</ref>) and ABySS v1.5.2 (<ref type="bibr" target="#b32">Simpson et al., 2009</ref>) using simulated datasets from the Escherichia coli reference genome<ref type="bibr">[GenBank: NC_000913.2]</ref>with different attributes listed in Supplementary 1<ref type="figure" target="#tab_1">Table 1</ref>. We also compared our results with the same assemblers, including Velvet v1.2.10 (<ref type="bibr" target="#b36">Zerbino and Birney, 2008</ref>) using real benchmark datasets from GAGE (<ref type="bibr" target="#b28">Salzberg et al., 2012</ref>) and Assemblathon 2 (<ref type="bibr" target="#b4">Bradnam et al., 2013</ref>) evaluation studies, the characteristics of benchmark datasets are presented in Supplementary 1<ref type="figure" target="#tab_2">Table 2</ref>. LightAssembler, like the other chosen assembly tools, is a<ref type="figure">Fig. 3</ref>. LightAssembler graph traversal module. The first step in the graph traversal module is computing the set of branching k-mers (k-mers have multiple extensions). (a) The successors for each trusted k-mer are computed by appending a nucleotide nt 2 A; C ; G; T f g , for example, the successors of a k-mer ¼ CATA, where k ¼ 4 are ATAA; ATAC ; ATAG; ATAT f g : (b) Bloom filter B is queried for each successor to check its presence in the sequenced reads. If the number of existing successors for each trusted k-mer is larger than one, the trusted k-mer is considered as a branching node. Otherwise, it is a simple node. (c) Each assembled contig starts from a branching node in the assembly graph, where each node is extended one nucleotide at a time and Bloom filter B is continuously queried for checking the presence of extended k-mers. The assembly graph is simplified by removing the dead end paths and resolving the simple bubbles De Bruijn graph-based assembler. LightAssembler, Minia and SparseAssembler are also considered as resource-efficient contigbased assembly tools. They do not utilize the paired-end information encoded in the sequenced libraries to perform scaffolding, while ABySS and Velvet have their own scaffolding modules. In order to make a fair comparison, we evaluated all methods based on their resulted contigs without using paired-end information such as the insert size. Then, we performed scaffold analysis based on our resulted contigs compared to those from other methods using SSPACE v3.0. 0 (<ref type="bibr" target="#b2">Boetzer et al., 2011</ref>) as one of stand-alone scaffolding tools. One of the major assembly steps is evaluating assembly results to assess their accuracy and contiguity. When a reference genome is available, the assembly results are evaluated by mapping the assembled contigs or scaffolds back to the reference with the possibility of setting a minimum length threshold for the mapping contigs/scaffolds. The assembly evaluation tools have different reported metrics and even different approaches when a reference genome is absent. GAGE, Assemblathon and QUAST (<ref type="bibr" target="#b16">Gurevich et al., 2013</ref>) are the most popular tools. The metrics used to evaluate the assembly results from the competing tools are described in Supplementary 1<ref type="figure" target="#tab_3">Table 3</ref>according to their definition in GAGE and Assemblathon studies. While QUAST has GAGE option to run the assembly evaluation using GAGE standards, we found that for the same minimum contigs threshold length, QUAST NG50 equals to GAGE N50 before performing the contigs correction step (breaking contigs at every misjoin and at every indel longer than 5 bases.). QUAST has a slightly higher N50 contig length compared to those from GAGE and Assemblathon 2. The default minimum threshold for contigs analysis in QUAST is 500 bp, which can be adjusted by the end user. GAGE has a fixed threshold contig length equals to 200 bp, while it is not specified in the Assemblathon's paper their threshold-based analysis. The scaffold-based contiguity analysis is used in Assemblathon 2 to report the contigs statistics by breaking the scaffolds into their corresponding contigs, which increases the N50 contig length compared to the length reported by the contigs-based analysis from other evaluation tools. Also, NG50 reported by the Assemblaton script equals to the N50 length reported by GAGE before doing the contigs correction step. We will use GAGE script to evaluate the assembly results from all competing programs. All conducted computer experiments and the exact command lines used for each tool are described in detail in Supplementary 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Resource requirements</head><p>The major goal of LightAssembler is to use the computational resources efficiently, in particular reducing the memory requirements for contigs production. We compared LightAssembler memory usage and the running time with those of ABySS, Minia and SparseAssembler using simulated datasets and with the same assemblers, including Velvet using real benchmark datasets. The experiments were run on a computer running Red Hat Linux with 16 2:4-GHz Xeon E5-2665 cores and 128 GB memory. The maximum memory for our computational resources is 128 GB, which is not sufficient to run Velvet and ABySS for the bird dataset from the Assemblathon project, so we used temporarily another limited-access machine with 1TB memory. The memory usage peaks for the simulated datasets with low error rate ðe % 1%Þ and real benchmark datasets are presented in Tables 2 and 3. For the simulated datasets with 3% error rate, see Supplementary 1<ref type="figure" target="#tab_4">Table 4</ref>. LightAssembler has the lowest peak memory usage for all different simulated datasets that vary in the sequencing coverage from 25Â to 280Â. Also, LightAssembler has the lowest peak for different real datasets that vary in sizes from 2:9 Mbp to 1:23Gbp. The memory usage is almost constant for different sequencing coverage of the same genome and increases slightly when the coverage is 280Â. SparseAssembler has the next lowest memory peak, but the memory peak increases greatly when the sequenced coverage is increased and the gap size is decreased. While Minia uses less memory than ABySS and Velvet, it utilizes the disk space to overcome the memory usage limitations, which increases Minia's peak for the virtual memory usage. The assembly results by Minia vary greatly when the disk space is not sufficient to run the k-mer counting module. Velvet uses less memory than ABySS, which is designed to distribute the overhead of memory usage among multiple machines. The disk size of the assembly results for real datasets is reported in Supplementary 1<ref type="figure" target="#tab_5">Table 5</ref>. We also studied the peak memory usage of LightAssembler using different gap values (see Supplementary 1 Results, section 2). We reported the running time for Velvet, ABySS and LightAssembler using only one thread (see Supplementary 1 Tables 6–8). The latest version of Minia adjusts the number of threads according to the number of the available cores without being able to modify the number of threads to a single-thread mode. SparseAssembler is a single-thread assembler where Velvet, ABySS, Minia and LightAssembler are able to run in the multithreaded mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Simulated datasets</head><p>The assembly results for all simulated datasets are presented in<ref type="figure" target="#tab_4">Table 4</ref>and Supplementary 1<ref type="figure">Table 9</ref>with more detail in Supplementary 2. Also, apart from Minia, SparseAssembler, ABySS and LightAssembler achieve the highest N50 length with low coverage dataset ðc 35xÞ and low error rate ðe % 1%Þ. When the error rate is increased to 3%, Minia and LightAssembler achieve the highest N50 length. LightAssembler outperforms all methods with the high coverage dataset ðc ! 75xÞ and low error rate ðe % 1%Þ according to the different evaluation metrics. ABySS utilizes the high coverage to overcome the sequenced errors when the error rate is increased to 3% and achieves the best results. It seems from our simulation that all assemblers have comparable results when the error rate is 1% and the average coverage c ! 75x. LightAssembler outputs the minimum number of contigs across different coverage values when the error rate is 1% and has comparable numbers to</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LightAssembler</head><p>Minia in the experiments with 3% error rate. LightAssembler, SparseAssembler and ABySS have no assembly errors across all different experiments according to the error definition in Supplementary 1<ref type="figure" target="#tab_3">Table 3</ref>, while all assemblers have indel (i.e. insertion/deletion) errors with length less than 5 bases (see Supplementary 2). For the simulated datasets, we found that the maximum corrected contig length (max corr.) and the N50 corrected length (N50 corr.) equal to their lengths before doing the correction step (see Supplementary 2). SparseAssembler produces the highest genome coverage for all simulated datasets because of the large assembly size, which increases when the sequenced coverage and error rate of datasets are increased and the gap size is decreased. SparseAssembler has also the largest chaff size, which is the total size of all contigs that are in length less than 200 bp. LightAssembler, ABySS and Minia have the constant genome coverage across different scenarios. The assembly parameters supplied to all programs are presented in Supplementary 1<ref type="figure" target="#tab_0">Table 10</ref>. Minia uses the minimum abundant parameter to filter the erroneous k-mers by implementing a k-mer counting module to remove k-mers with abundance less than a specified threshold. While the k-mers counting module has an additional overhead of the running time and disk usage, Minia's performance drops dramatically when we tried to use all k-mers in the simulated datasets (minimum abundant threshold equals one). LightAssembler and SparseAssembler use the gap size parameter to get a uniform sample of k-mers in the sequenced reads. While LightAssembler uses the sample to filter the whole set of sequenced k-mers, SparseAssembler assembles the sampled k-mers by extending their links. The assembly results changed dramatically with different gap sizes in SparseAssembler, unlike LightAssembler, which was relatively insensitive, starting from a suitable value, for datasets with low error rates (see Supplementary 3). SparseAssembler has a maximum gap size, g ¼ 25, We think that this gap size should increase for the high coverage datasets with c ! 140x. We also studied the effect of varying the gap size g and the k-mer size k on the assembly results of LightAssembler (see Supplementary 1 Results, section 3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Real datasets</head><p>The assembly parameters supplied to all programs are presented in Supplementary 1<ref type="figure" target="#tab_1">Table 11</ref>. The detailed assembly results for each assembler on each dataset are presented in Supplementary 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Accuracy of LightAssembler k-mers classification</head><p>We measured the number of correct classified k-mers by LightAssembler compared to the number of distinct k-mers in reference genomes for real datasets (<ref type="figure" target="#tab_5">Table 5</ref>). Also, we reported the number of incorrect k-mers that are kept in Bloom filter B. While LightAssembler kept some incorrect k-mers, the number of introduced errors in the final assembled contigs is comparable to Minia and SparseAssembler and is very low compared to Velvet and ABySS. In addition, we studied the effect of varying a gap value on the accuracy of LightAssembler k-mers classification with more detail in Supplementary 1 Results, section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">GAGE human chromosome 14</head><p>Human chromosome 14 is a paired-end dataset from the GAGE evaluation study. We evaluated assembly results using the GAGE evaluation metrics that are computed based on aligning the assembled sequences to the reference of Human chromosome 14 dataset. The assembly results for all assemblers are presented in<ref type="figure" target="#tab_6">Table 6</ref>. No assembler performs the best on all combined metrics. Velvet produces the highest N50 length at the expense of introducing more errors compared to the other assemblers. Minia produces the lowestnumber of errors with LightAssembler very close behind. The assembled sequence of ABySS and SparseAssembler is longer than the reference sequence, which increases their genomic coverage compared to other assemblers. Velvet and LightAssembler outputs the minimum number of contigs, while ABySS has the maximum contig length. Overall, LightAssembler performance on human chromosome 14 is comparable to other assemblers for all evaluation metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">Assemblathon 2 bird dataset</head><p>LightAssembler is designated to overcome the intensive memory requirements for assembling large genomes, so we compared LightAssembler results with other assembly tools (<ref type="figure" target="#tab_7">Table 7</ref>) using one of the vertebrate species (Melopsittacus undulatus or simply bird dataset) from Assemblathon 2. Since there is no reference genome available for the bird dataset, we evaluated different results based on the assembly contiguity metrics. We used GAGE script to compute the N50 length with the minimum threshold set at 200bp for the contigs-based contiguity analysis. SparseAssembler has the highest N50 length, while LightAssembler has the second best value. As we reported previously, ABySS and SparseAssembler have the largest assembly size and the highest number of resulted contigs. Overall, LightAssembler results for the bird dataset are comparable using all contiguity evaluation metrics.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4">Importance of error correction and data cleaning</head><p>We used two bacterial genomes (S.aureus and R.sphaeroides) from GAGE project to compare the performance of all assemblers using uncorrected and corrected sequenced reads. We used the error-free datasets corrected by ALLPATHS-LG (<ref type="bibr" target="#b15">Gnerre et al., 2011</ref>) since it has one of the best error correction modules for these datasets as mentioned in GAGE. The assembly results for all methods are increased dramatically after the error correction step (<ref type="figure" target="#tab_8">Table 8</ref>), which highlights the importance of data quality on the assembly process. Some assemblers like Velvet have extensive graph simplification modules, which resulted in high N50 length before data cleaning process at the expense of introducing more errors in the finished assembled contigs. The number of errors might be increased for some assemblers after data cleaning due to false-positive or false-negative error correction. Some error correction tools have also trimming processes, which truncate the tails of the sequenced reads at the bases with low quality scores and discard the reads that cannot be corrected. ABySS and SparseAssembler have the largest assembly size, which is reduced effectively after error correction. The large assembly size can mislead the assembly evaluation because it might result from errors in the dataset (tips or dead-ends) or repeated regions when assemblers infer different paths due to heterozygosity. More discussion can be found in Supplementary 1 Results, section 5 and Supplementary 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.5">Scaffold results for GAGE human chromosome 14</head><p>Sequence assembly is the combination of two stages: contig assembly followed by the use of paired-end reads or mate pairs to link the contigs further into scaffolds. Typically, contig assembly is the most memory-intensive stage for an assembler compared to the scaffolding stage. Some assemblers have their own built-in scaffolding modules, while others rely on the stand-alone tools to accomplish scaffolding. LightAssembler, Minia and SparseAssembler are contigbased assemblers, which are not designated to consider the pairedend information and perform scaffolding, while Velvet and ABySS have their own scaffolding modules. We assessed the contiguity and accuracy of the resulted contigs into scaffolds for all assemblers using the SSPACE scaffolding tool. The stand-alone scaffolding tools vary in their assembly results according to the number of correct/incorrect misjoins they made between the contigs as reported recently in one of the evaluation studies (<ref type="bibr" target="#b18">Hunt et al., 2014</ref>). They reported SSPACE as one of the best scaffolding tool for their defined assembly evaluation metrics. Also, Human chromosome 14 is one of the benchmark datasets used in their study. We used the contigs resulted by all assembler and GAGE short jump library for Human chromosome 14 and ran SSPACE with the same reported best parameters for this dataset. In order to make a fair comparison, we used the contigs file from Velvet and ABySS without utilizing their own scaffolding modules. The assemblers' contig files are produced using only one sequenced library and without correcting the sequenced errors as mentioned previously. The scaffolding results are presented in<ref type="figure">Table 9</ref>with more detail in Supplementary 1 Results, section 6 and Supplementary 2. The maximum scaffold length and the minimum number of scaffolds are resulted from the contigs produced by Velvet, while the lowest number of misjoins is resulted from SparseAssembler and LightAssembler. Velvet also has the highest N50 scaffold length, which is reduced dramatically after breaking scaffolds at every indel and at every misjoin. We also evaluated the scaffolding results of LightAssembler contigsLightAssemblerusing error corrected version of GAGE short jump library supplied to SSPACE, the N50 scaffold length is increased to 36426 bp. Moreover, the N50 scaffold length is increased to 46582 bp and the N50 contig length is increased to 4171 bp when we supplied the error corrected version of GAGE human chromosome 14 dataset to LightAssembler, more detail in Supplementary 3. The scaffolding results of LightAssembler contigs are comparable to other assemblers for the human chromosome 14 dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discussions</head><p>LightAssembler is a light-version of an assembly algorithm that is executed on a desktop machine. It retains the assembly accuracy and contiguity using a pair of Bloom filters, one holding a uniform sample of the sequenced k-mers and the other holding k-mers that are likely correct using a simple statistical test. While LightAssembler is a gapbased assembler, different gap sizes result in an almost constant assembly size and genome coverage with varying in the sequenced coverage. The starting value for the gap size interval is chosen according to the sequenced coverage and error rate of a dataset with the gap value increases when the sequenced coverage and error rate are increased. We compared LightAssembler results with those from Velvet, ABySS, Minia and SparseAssembler using benchmark datasets from evaluation studies such as GAGE and Assemblathon 2. The assembly results reported in those studies are based on using multiple sequenced libraries (paired-ends and mate pairs) with different insert sizes and the sequenced errors corrected before starting the assembly process. In our paper, we used only one sequenced library for each dataset without error correction to verify the validity of our method without increasing the cost of sequencing process (using more libraries) or using error correction tools. To highlight the importance of these concepts on the assembly process, we studied the effect of the error corrected dataset on increasing the performance of different assemblers. We also discussed the scaffolding results of contigs produced by LightAssembler and other assembly tools using one short jump library from GAGE evaluation study. The data quality and complexity of the assembled genome rather than the assembler itself play a key role on the assembly results. The accuracy and contiguity of the assembly results are not correlated and the large assembly size can mislead the assembly evaluation. The major goal for resource-efficient contigs-based assemblers such as LightAssembler is reducing the memory usage for contigs production, which is the most memory-intensive stage among different assembly stages. LightAssembler achieved an improvement of a 50% reduction in the memory usage compared to the lowest memory usage reported by the current state-of-the-art assembly tools.Future improvements to LightAssembler will focus on the exploitation of paired-end information via implementing a built-in scaffolding module. Also, extending LightAssembler approach to metagenomic and single-cell assembly where the coverage is highly non-uniform and the number of sequenced errors and chimeric reads are increased. One possible solution is using different sampling rates, gap values, in the first pass so Bloom filter A can be populated with k-mers of different abundance from different genomic regions. The statistically computed thresholds in the second pass will be adjusted accordingly. Moreover, LightAssembler is an initial step towards full implementation of a streaming algorithm in the sequence assembly. It is considered as a multi-pass semi-streaming algorithm with low-memory usage for sequence assembly. LightAssembler is an open-source software released under the GNU GPL license.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. LightAssembler framework</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. Overlapped k-mers for read positions. The number of overlapped k-mers, x i , for each read position r i considering the reads end effects, where x i 2 1; k ½ . When read length L ¼ 20 and k ¼ 5, x1 ¼ 1; x2 ¼ 2; x3 ¼ 3; x4 ¼ 4; x 5 ¼ 5; x 6 ¼ 5;. .. x LÀk ¼ 5; x 16 ¼ 5; x 17 ¼ 4; x 18 ¼ 3; x 19 ¼ 2 and x 20 ¼ 1. Each random variable Be;x i is defined for each x i 2 1; 5 ½ , in this example, we have Be;1; Be;2; Be;3; Be;4 and Be;5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>ce g Let B e;xi be a random variable for the number of g-mers appeared in the sample stored in Bloom filter A for an untrusted position r i and these g-mers are overlapped by x i 2 ½1; k: B e;xi $ Binomðx i ; p 0 Þ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. Suggested starting values for a gap size parameter g, for various sequenced coverage and error rates</figDesc><table>Sequenced coverage c 
Error rate e 
0:01 
Error rate e &gt; 0:01 

25Â 
3 
6 
35Â 
4 
8 
75Â 
8 
1 5 
140Â 
15 
20 
280Â 
25 
33 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 2. Memory usage (peak resident memory in GB) for simulated datasets with 1% error rate a</figDesc><table>Assemblers 
25Â 
35Â 
75Â 
140Â 
280Â 

ABySS 
1.24 
1.51 
2.72 
4.34 
8.25 
Minia 
0.29 
0.34 
0.42 
0.67 
0.83 
SparseAssembler 
0.14 
0.12 
0.18 
0.20 
0.30 
LightAssembler 
0.08 
0.08 
0.08 
0.07 
0.09 

a 

The best value for each column is shown in bold. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 3. Memory usage (peak resident memory in GB) for real benchmark datasets a</figDesc><table>Assemblers 
S.aureus 
R.sphae. 
H. chr14 
Bird 

Velvet b 
1.88 
2.65 
19.69 
281.9 
ABySS 
2.60 
3.71 
28.27 
451.24 
Minia 
0.25 
0.34 
2.84 
32.24 
SparseAssembler 
0.13 
0.23 
1.57 
13.62 
LightAssembler 
0.05 
0.06 
0.79 
6.72 

a 

The best value for each column is shown in bold. 

b 

We reported the highest peak memory usage among the two-steps assem-
bly process. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><figDesc>Table 4. Assembly statistics for simulated datasets with various sequencing depths and 1% error rate a</figDesc><table>Evaluation metrics 
Assemblers 
25Â 
35Â 
75Â 
140Â 
280Â 

num 
ABySS 
873 
743 
610 
609 
609 
Minia 
586 
381 
248 
246 
249 
SparseAssembler 
4105 
4522 
16 853 
23 418 
79 475 
LightAssembler 
474 
307 
217 
221 
224 

max (bp) 
ABySS 
111 690 
269 704 
326 386 
326 386 
326 386 
Minia 
88 437 
162 370 
326 386 
326 386 
326 386 
SparseAssembler 
63 311 
171 510 
326 391 
326 390 
296 443 
LightAssembler 
80 023 
171 498 
326 386 
326 386 
326 386 

N50 (bp) 
ABySS 
28 615 
55 252 
59 812 
59 812 
59 812 
Minia 
17 944 
39 965 
59 812 
59 812 
59 812 
SparseAssembler 
14 759 
44 088 
60 168 
60 170 
57 852 
LightAssembler 
26 488 
52 505 
60 160 
60 166 
60 166 

coverage (%) 
ABySS 
96.28 
96.27 
96.37 
96.37 
96.37 
Minia 
95.65 
95.53 
95.52 
95.61 
95.62 
SparseAssembler 
99.11 
100.05 
120.24 
128.82 
209.34 
LightAssembler 
95.55 
95.53 
95.57 
95.60 
95.56 

a 

The best value for each column is shown in bold. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 5. Accuracy of LightAssembler k-mers classification for real datasets</figDesc><table>Dataset 
Distinct 
k-mers 

Correct 
k-mers 

Accuracy (%) 
Incorrect 
k-mers 

S.aureus 
2 858 856 
2 848 016 
99.62 
337 600 
R.sphae. 
4 558 417 
4 342 986 
95.27 
75 338 
H. chr14 
86 467 655 
82 706 223 
95.65 
16 977 939 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>Table 6.</figDesc><table>Contigs statistics for the GAGE human chromosome 14 
dataset (ungapped size 88 289 540 bp) a 

Evaluation 
metrics 

Velvet 
ABySS 
Minia 
Sparse 
Assembler 

Light 
Assembler 

num 
42 939 190 356 70 469 233 840 
64 595 
max (bp) 
63 828 65 461 
47 457 55 666 
60 825 
max corr. 
63 834 65 463 
47 458 49 794 
60 823 
N50 (bp) 
4318 
3857 
3115 
3516 
3547 
N50 corr: (bp) 4138 
3742 
3064 
3434 
3472 
errors 
1473 
1044 
816 
1001 
904 
coverage (%) 
97.41 
109.20 
99.42 
110.24 
98.91 

a 

The best value for each row is shown in bold. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Table 7.</figDesc><table>Contigs statistics for Assemblathon 2 bird dataset (esti-
mated genome size 1.23 Gbp) a 

Evaluation 
metrics 

Velvet 
ABySS 
Minia 
Sparse 
Assembler 

Light 
Assembler 

num 
841 486 4 978 938 1 374 322 1 715 152 1 160 406 
max (bp) 
138 491 203 054 
138 470 
188 160 
180 702 
N50 (bp) 
3048 
1593 
2739 
5756 
3674 
coverage (%) 87.90 
124.32 
89.87 
99.41 
96.09 

a 

The best value for each row is shown in bold. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="true"><figDesc>Table 8. Comparison of assembly statistics using uncorrected and corrected reads a</figDesc><table>coverage (%) 
Velvet 
97.93 
98.16 
97.88 
98.59 
ABySS 
103.53 
98.86 
100.77 
98.25 
Minia 
98.61 
98.32 
100.31 
98.79 
SparseAssembler 
107.03 
98.04 
111.25 
97.92 
LightAssembler 
98.78 
98.38 
99.98 
98.88 

a 

The best value for each column is shown in bold. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><figDesc>Table 9.</figDesc><table>Scaffolds statistics for GAGE human chromosome 14 
dataset a 

Evaluation 
metrics 

Velvet 
ABySS 
Minia 
Sparse 
Assembler 

Light 
Assembler 

num 
23 427 170 168 48 375 
212 893 
43 841 
max (bp) 
341 738 241 036 232 760 
204 173 
218 388 
N50 (bp) 
42 400 
35 290 
26 599 
31 535 
31 293 
N50 corr: (bp) 38 567 
33 938 
25 135 
30 019 
30 141 
misjoins 
49 
42 
42 
27 
28 

a 

The best value for each row is shown in bold. </table></figure>

			<note place="foot">S.El-Metwally et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank Michael Waterman for hosting SE in his lab and his valuable inputs to this project. Also, we are grateful for Peter Ralph for helpful discussions and feedback.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">String graph construction using incremental hashing</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Ben-Bassat</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Chor</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="3515" to="3523" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Space/Time Trade/Offs in hash coding with allowable errors</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">H</forename>
				<surname>Bloom</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">422</biblScope>
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Scaffolding pre-assembled contigs using SSPACE</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Boetzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="578" to="579" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Succinct de Bruijn Graphs</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bowe</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algorithms in Bioinformatics</title>
		<editor>Raphael,B. and Tang,J.</editor>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="225" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">Assemblathon 2: evaluating de novo methods of genome assembly in three vertebrate species</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">R</forename>
				<surname>Bradnam</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page">10</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Fragment assembly with short reads</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="2067" to="2074" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">De novo fragment assembly with short matepaired reads: does the read length matter?</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="336" to="346" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">On the representation of De Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Chikhi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="336" to="352" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Informed and automated k-mer size selection for genome assembly</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Chikhi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="31" to="37" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Space-efficient and exact De Bruijn graph representation based on a Bloom filter</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Chikhi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Rizk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">22</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Gossamer–a resource-efficient de novo assembler</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Conway</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1937" to="1938" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Succinct data structures for assembling large genomes</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">C</forename>
				<surname>Conway</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">J</forename>
				<surname>Bromage</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="479" to="486" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Assemblathon 1: a competitive assessment of de novo short read assembly methods</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Earl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="2224" to="2241" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Next-generation sequence assembly: four stages of data processing and computational challenges</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>El-Metwally</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">1003345</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<monogr>
		<title level="m" type="main">Next Generation Sequencing Technologies and Challenges in Sequence Assembly. SpringerBriefs in Systems Biology</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>El-Metwally</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">High-quality draft assemblies of mammalian genomes from massively parallel sequence data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gnerre</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Natl. Acad. Sci. U. S. A</title>
		<imprint>
			<biblScope unit="volume">108</biblScope>
			<biblScope unit="page" from="1513" to="1518" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">QUAST: quality assessment tool for genome assemblies</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Gurevich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1072" to="1075" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Library construction for next-generation sequencing: overviews and challenges</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">R</forename>
				<surname>Head</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biotechniques</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">68</biblScope>
			<biblScope unit="page" from="61" to="66" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>passim</note>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">A comprehensive evaluation of assembly scaffolding tools</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Hunt</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">42</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Comparing memory-efficient genome assemblers on stand-alone and cloud infrastructures</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Kleftogiannis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">75505</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">The Genome 10K Project: a way forward</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">P</forename>
				<surname>Koepfli</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Anim. Biosci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="57" to="111" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Genomic mapping by fingerprinting random clones: a mathematical analysis</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">S</forename>
				<surname>Lander</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Waterman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genomics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="231" to="239" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">KmerStream: streaming algorithms for k-mer abundance estimation</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Melsted</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">V</forename>
				<surname>Halldorsson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="3541" to="3547" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">The fragment assembly string graph</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="79" to="85" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Sequence assembly demystified</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Nagarajan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="157" to="167" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">An Eulerian path approach to DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Natl. Acad. Sci. U. S. A</title>
		<imprint>
			<biblScope unit="volume">98</biblScope>
			<biblScope unit="page" from="9748" to="9753" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Cache-, hash-and space-efficient bloom filters</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Putze</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lect. Notes Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">4525</biblScope>
			<biblScope unit="page" from="108" to="121" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Using cascading Bloom filters to improve the memory usage for de Brujin graphs</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Salikhov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">GAGE: a critical evaluation of genome assemblies and assembly algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Exploring genome characteristics and sequence quality without a reference</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1228" to="1235" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Efficient construction of an assembly string graph using the FM-index</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="367" to="373" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of large genomes using compressed data structures</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="549" to="556" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">Lighter: fast and memory-efficient sequencing error correction without counting</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Song</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">509</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">A survey of error-correction methods for nextgeneration sequencing</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Yang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief Bioinform</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="56" to="66" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">Exploiting sparseness in de novo genome assembly</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Ye</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<analytic>
		<title level="a" type="main">Velvet: Algorithms for de novo short read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">LightAssembler</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>