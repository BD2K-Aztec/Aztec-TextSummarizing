
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:34+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">OMPPM: online multiple palindrome pattern matching</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Hwee</forename>
								<surname>Kim</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Yonsei University</orgName>
								<address>
									<postCode>120-749</postCode>
									<settlement>Seoul</settlement>
									<country key="KR">Republic of Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yo-Sub</forename>
								<surname>Han</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Yonsei University</orgName>
								<address>
									<postCode>120-749</postCode>
									<settlement>Seoul</settlement>
									<country key="KR">Republic of Korea</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">OMPPM: online multiple palindrome pattern matching</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btv738</idno>
					<note type="submission">Received on 23 August 2015; revised on 11 December 2015; accepted on 12 December 2015</note>
					<note>Sequence analysis *To whom correspondence should be addressed. Associate Editor: John Hancock Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: A palindrome is a string that reads the same forward and backward. Finding palin-dromic substructures is important in DNA, RNA or protein sequence analysis. We say that two strings of the same length are pal-equivalent if, for each possible centre, they have the same length of the maximal palindrome. Given a text T of length n and a pattern P of length m, we study the pal-indrome pattern matching problem that finds all indices i such that P and T ½i À m þ 1 : i are pal-equivalent. Results: We first solve the online palindrome pattern matching problem in O(m 2) preprocessing time and O(mn) query time using O(m 2) space. We then extend the problem for multiple patterns and solve the online multiple palindrome pattern matching problem in Oðm k MÞ preprocessing time and Oðm k n þ cÞ query time using Oðm k MÞ space, where M is the sum of all pattern lengths, m k is the longest pattern length and c is the number of pattern occurrences. Availability and implementation: The source code for all algorithms is freely available at http://toc.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Finding motifs and patterns in bio strings has been one of the most popular topics in both computer science and biology (<ref type="bibr" target="#b0">Adebiyi et al., 2001;</ref><ref type="bibr" target="#b4">Buhler, 2001;</ref><ref type="bibr" target="#b16">Parisi et al., 2003;</ref><ref type="bibr" target="#b18">Prü fer et al., 2008;</ref><ref type="bibr" target="#b19">Rigoutsos and Floratos, 1998</ref>). A palindrome is a string that reads the same forward and backward. Namely, a string w is a palindrome if w ¼ w R , where w R denotes the reversal of w. If a substring of a string is a palindrome, we say that the string has a palindromic substring or palindromic structure. It is important to find palindromes and identify similar palindromic structures in DNA, RNA or protein sequence analysis (<ref type="bibr" target="#b6">Gusfield, 1997</ref>). Since palindromic structures in bio data reflect the capability of molecules to fold and form doublestranded stems (<ref type="bibr" target="#b11">Kolpakov and Kucherov, 2009</ref>), bio data with similar palindromic structures may have similar secondary structures. Moreover, palindromic sequences are closely associated with DNA breakage during gene conversion (<ref type="bibr" target="#b12">Krawinkel et al., 1986</ref>), and palindromic substructures are presented in CRISPR/Cas9 (<ref type="bibr" target="#b13">Kunin et al., 2007</ref>), which has been used for gene editing and gene regulation in species (<ref type="bibr" target="#b14">Mali et al., 2013</ref>). Therefore, it is useful to identify palindromic substructures and palindromic equivalence efficiently. We focus on the palindrome pattern matching problem introduced by<ref type="bibr">I et al. (2013)</ref>. Given a text T of length n and a pattern P of length m, the palindrome pattern matching problem is to find all indices i such that P and T½i À m þ 1 : i have the same set of all centre-distinct maximal palindromes. See<ref type="figure">Figure 1</ref>for an example.<ref type="bibr">I et al. (2013)</ref>presented two algorithms that solve the palindrome pattern matching for an arbitrary size alphabet. We notice that both algorithms by<ref type="bibr">I et al. (2013)</ref>require a preprocessing step of T. This may slow down the whole process when T is an extremely large text and I/O for T is considerably slow due to the large but slow storages. Moreover, these algorithms might not be applicable if T is a stream data. Many researchers designed online string algorithms to avoid these problems, where each character in T is given online, and we want to report intermediate results without readingwhole T (<ref type="bibr" target="#b1">Ahmad et al., 2003;</ref><ref type="bibr" target="#b17">Paten et al., 2009</ref>). For the palindrome pattern matching problem, we want to report all matching indices i while reading T online. Based on the Knuth–Morris–Pratt algorithm (<ref type="bibr" target="#b10">Knuth et al., 1977</ref>), we first build an automaton A from P and process T using A. For a text T of length n and a pattern P of length m, our algorithm requires O(m 2 ) preprocessing time and runs in O(mn) query time using O(m 2 ) space. We, furthermore, tackle the online multiple palindrome pattern matching based on a modification of the Aho–Corasick automaton (<ref type="bibr" target="#b2">Aho and Corasick, 1975</ref>). For multiple patterns P 1 ;. .. ; P k of length m 1 ;. .. ; m k , our algorithm requires Oðm k MÞ preprocessing time and runs in Oðm k n þ cÞ query time using Oðm k MÞ space, where M is the sum of all pattern lengths, m k is the longest pattern length and c is the number of pattern occurrences. Note that the second algorithm considers multiple patterns and has the same query time as the first algorithm except the number of pattern occurrences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Strings, palindromes and finite automata</head><p>A finite-state automaton (FA) A is specified by A ¼ ðQ; R; d; s; FÞ, where Q is a set of states, R is an alphabet, d : Q Â R ! Q is a transition function, s 2 Q is the start state and F Q is a set of final states. A string w is accepted by A if there is a labeled path from s to a state in F such that the path spells out w. For complete background knowledge in automata theory, the reader may refer to textbooks (<ref type="bibr" target="#b7">Hopcroft and Ullman, 1979;</ref><ref type="bibr" target="#b20">Wood, 1986</ref>). For a string w, let w R denote the reversed string of w. A string w is called a palindrome if w ¼ w R. The radius of a palindrome w is jwj 2. The centre of a palindromic substring w½i : j of a string w is iþj 2. A palindromic substring w½i : j is called the maximal palindrome at the centre iþj 2 if no other palindromes at the centre iþj 2 have a larger radius than w½i : j; in other words, if w½i À 1 6 ¼ w½j þ 1, i ¼ 1 or j ¼ jwj. Let Pals(w) be the set of all centre-distinct maximal palindromes where each element is encoded by a pair of its centre and radius (<ref type="bibr">I et al., 2010</ref>). Namely, given a string w, PalsðwÞ ¼ ðc; rÞ w½c À r þ 0:5 : c þ r À 0:5 is a maximal palindrome at centre c ¼ 1; 1:5; 2;. .. ; n</p><formula>( ) :</formula><p>For example, if w ¼ abbacabbba, we have PalsðwÞ ¼ fð1; 0:5Þ; ð1:5; 0Þ; ð2; 0:5Þ; ð2:5; 2Þ; ð3; 0:5Þ; ð3:5; 0Þ; ð4; 0:5Þ; ð4:5; 0Þ; ð5; 3:5Þ; ð5:5; 0Þ; ð6; 0:5Þ; ð6:5; 0Þ; ð7; 0:5Þ; ð7:5; 1Þ; ð8; 2:5Þ; ð8:5; 1Þ; ð9; 0:5Þ; ð9:5; 0Þ; ð10; 0:5Þg:</p><p>For two strings w and z of the same length, we say that w and z are pal-equivalent if PalsðwÞ ¼ PalsðzÞ.<ref type="bibr" target="#b15">Manacher (1975)</ref>proved that for a string w of length m, we can compute Pals(w) in O(m) time. From now on, we assume that the elements of Pals(w) are sorted in increasing order of centrers c—the algorithm of<ref type="bibr" target="#b15">Manacher (1975)</ref>Based on Definition 2.3, we establish the following result: after running Algorithm 1, if there is a surjection of A to R where A½i 6 ¼ A½j holds for all i, j such that j 2 B½i, then PalsðP 0 Þ ¼ PalsðPÞ. Moreover, given a string w such that PalsðwÞ ¼ PalsðPÞ, there exists a surjection of A to R such that P 0 ¼ w. We analyze the time and space complexity of Algorithm 1. Computing Pals(P) takes O(m) time. Since the for loop from line 6 to line 10 takes O(m) time and line 12 also takes O(m) time, the time complexity of the algorithm is O(m 2 ). For the space complexity, A½m and P 0 requires O(m) space and B½m requires O(m 2 ) space. Therefore, the space complexity is O(m 2 ). Once we have P 0 , we can construct a special automaton A ¼ ðQ; A<ref type="bibr">[ f]</ref>g; d; s; F; R; B; d f ; HÞ that finds all occurrences of P 0 in T as follows: @BULLET Q is the set of states, @BULLET A is the array of variables (which is used as an alphabet in A) and ] is a wildcard variable, @BULLET d : Q Â A ! Q is the transition function, @BULLET s is the start state, @BULLET F is the set of final states, @BULLET R is the alphabet of the original pattern P, @BULLET B is the array for inequality conditions of variables, @BULLET d f : Q ! Q is the failure transition function, and @BULLET H : Q ! 2 AÂðA<ref type="bibr">[f]</ref>gÞ is the set of injective functions for variables.</p><p>Note that four parameters——R; B; d f ; H—are added to the definition of a traditional FA. The automaton A simulates the Knuth– Morris–Pratt algorithm, using P 0 instead of P as a pattern. In the Knuth–Morris–Pratt algorithm, when there occurs a mismatch, the algorithm uses the longest suffix of the prefix of T read so far, which is a prefix of P 0. The automaton A simulates the process when a mismatch occurs by d f , and additionally, changes surjection of A to R according to H. Algorithm 2 constructs an automaton A from P and<ref type="figure" target="#fig_3">Figure 4</ref>shows an example automaton constructed from P ¼ AGCGTA. We establish the time and space complexity of Algorithm 2 as follows: We can compute Pals(P) in O(m) time and, based on Pals(P), line 11 takes O(m) time. Since other lines in the algorithmexcept for loops require constant time, the total time complexity is O(m 2 ). For the space complexity, there are O(m) states in A. For each state, there are one out-transition, one outgoing failure transition and O(m) injective functions. Therefore, the space complexity is O(m 2 ). Now we present an algorithm that solves Pal-Matching using A. Based on the Knuth–Morris–Pratt algorithm, Algorithm 3 processes T in A and reports all end-indices of matching occurrences. We analyze the time and space complexity of Algorithm 3. Checking the condition in line 5 takes O(m) time, and the for loop in line 6 takes O(m) time. Note that lines 5–6 runs once for one execution of line 6, where l decreases. For each i, l increases by 1 in line 7. Since l ! 0, the total runtime of the while loop from line 5 to line 6 is O(mn). Combined with Algorithm 2 in line 1, the algorithm requires Oðm 2 þ mnÞ time and O(m 2 ) space. Thus, given a text T of length n and a pattern P of length m, we can solve the online palindrome pattern matching problem with O(m 2 ) preprocessing time and O(mn) query time using O(m 2 ) space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The algorithm for MPal-matching</head><p>Now we extend the previous algorithm to solve MPal-Matching. The basic idea of the algorithm is to process multiple patterns at once with a single automaton, based on the idea of the Aho– Corasick automaton (<ref type="bibr" target="#b2">Aho and Corasick 1975</ref><ref type="figure" target="#fig_5">Figure 5</ref>shows an example automaton constructed from P 1 ¼ AGA; P 2 ¼ ACTG; P 3 ¼ ATAT; P 4 ¼ TCTGC. We analyze the time and space complexity of Algorithm 4. We can compute PalsðP j Þ in Oðm j Þ time and, based on PalsðP j Þ, lines 14For each state, there are one out-transition, one outgoing failure transition, at most one outgoing pattern suffix transition and Oðm k Þ injective functions. Therefore, the space complexity is Oðm k MÞ. We design Algorithm 5 similar to Algorithm 3 on B to solve MPal-Matching with an additional process: whenever the current state q l reaches a final state q f , return all patterns that are connected by d p from q f. This additional process requires O(c) total runtime, where c is the number of pattern occurrences. Since the size of H for each state in B is bounded to m k , the algorithm requires Oðm k M þ m k n þ cÞ time and Oðm k MÞ space. Therefore, given a text T of length n and a pattern P of length m, we can solve the online multiple palindrome pattern matching problem with Oðm k MÞ preprocessing time and Oðm k n þ cÞ query time using Oðm k MÞ space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Experiments</head><p>We design three experiments to estimate the average performance of the algorithms. For Algorithm 3, we first establish two parameters— the length m of the pattern and the length n of the text—and estimated three values—the preprocessing time t p , the query time t q , the number s of variables—for random DNA patterns and texts. Second, we calculate the average number of variables for small m by considering all possible patterns of length m. Third, for Algorithm 5, we use real RNA data as a pattern set and measure the preprocessing time t p and the query time t q by two parameters—the sum M of all pattern lengths and the longest pattern length m k. The details of the experiment are as follows:</p><p>1. For the first experiment, @BULLET The length m of the pattern changes from 10 to 100 by 10, and then from 100 to 1000 by 100. The length n of the text changes from 10 000 to 100 000 by 10 000. @BULLET For each pair of m and n, we randomly generate a pattern and a text from an alphabet fA; G; C; Tg 100 times, and calculate the average value of the preprocessing time t p , the query time t q and the number of variables s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">For</head><p>the second experiment, we iterate all possible strings for 1 m 10 and calculate the average of s for each m. 3. For the third experiment, @BULLET We use 24 RNA secondary structures belonging to distinct RNA families from the Rfam database (<ref type="bibr" target="#b5">Burge et al., 2013</ref>) as a superset of a pattern set. The set of RNA secondary structures used is in the supplementary material. @BULLET We use a RNA-sequence of length 100 000 from the ArrayExpress database (<ref type="bibr" target="#b3">Brazma et al., 2003</ref>) as a text. We checked that each pattern in the superset does not appear in the text, which erases the factor c from the runtime. @BULLET We run 100 iterations. For each iteration, we first choose a pattern p k , and then select each pattern in the superset with the length less than jp k j with the probability 1 2 to form a set of patterns for the iteration. We compute the preprocessing time t p and the query time t q. We obtain the following results from our experiments (note that we have rounded our results to the nearest hundredth.):</p><p>@BULLET Preprocessing time of Algorithm 3:<ref type="figure" target="#fig_6">Figure 6</ref>shows the preprocessing time t p of Algorithm 3 according to the length m of the pattern (the table for the graph is in the supplementary material). @BULLET Query time of Algorithm 3:<ref type="figure" target="#fig_7">Figure 7</ref>shows the query time t q of Algorithm 3 according to the length m of the pattern and the length n of the text (tables for graphs are in the supplementary material). @BULLET Number of variables: In Algorithm 3, the query time is bounded to O(ns), where s is the number of variables.<ref type="figure">Figure 8</ref>shows the number of variables s according to the length of the pattern m (The table for the graph is in the supplementary material). The data for m ¼ 1–10 is the average of s for all possible cases, and the data from m ¼ 10 to m ¼ 1000 is the average for 100 random cases. @BULLET Pre-processing time of Algorithm 5:<ref type="figure">Figure 9</ref>shows the preprocessing time t p of Algorithm 5, according to the sum of all pattern lengths M and the longest pattern length m k. @BULLET Query time of Algorithm 5:<ref type="figure">Figure 10</ref>shows the query time t q of Algorithm 5 according to the longest pattern length m k and the sum of all pattern lengths M. We observe that t q is independentthe preprocessing time. We can observe that t p follows the quadratic function of m since tp ¼ Oðm 2 Þ. to M but it is not clear whether or not t q is proportional to m k. We design another experiment to determine the factor that affects m k most. @BULLET T is a randomly generated text of length 100 000. We run 1000 iterations for different sets of patterns. @BULLET For each iteration, we choose m k between 100 and 200, and generate a set of random patterns, where M is 1000.the query time. We observe that t q is proportional to n and m since tq ¼ OðnmÞ. Note that t q for n ¼ 10 000 and m ¼ 100 is 13.02, whereas t q for n ¼ 100 000 and m ¼ 10 is 31.56. This implies that the increase of m affects t q less than the increase of n<ref type="figure">Fig. 10</ref>. Query time graph for Algorithm 5, considering m k and M. m k denotes the length of the longest pattern, M denotes the sum of the lengths of all patterns and t q denotes the query time. We observe that t q is independent from M<ref type="figure">Fig. 8</ref>. Number of variable graph, where m denotes the length of the pattern and s denotes the number of variables used. For m ¼ 1–10, we observe linear increase of s as m increases. The difference of s between m and m À 1 tends to decrease as m increases, but the difference rapidly converges to 0.47, and we can easily approximate s ¼ 0:47m (Note that s ¼ 468.78 when m ¼ 1000.)<ref type="figure">Fig. 9</ref>. Preprocessing time graph for Algorithm 5. We observe that t p is proportional to M and m k since tp ¼ Oðmk MÞ<ref type="figure">Fig. 11</ref>. Query time graph for Algorithm 5, considering goback and checkall. goback denotes the number of changes on the array of variables, checkall denotes the number of pattern suffix transitions taken, and t q denotes the query time. This graph shows that t q is proportional to goback, which is Oðm k nÞ but the average value is far less than m kn and not proportional to m kn @BULLET We record the number of changes on the array of variables (which we call goback) and the number of pattern suffix transitions taken (which we call checkall).<ref type="figure">Figure 11</ref>shows the query time t q of Algorithm 5 according to goback and checkall. Theoretically, t q ¼ Oðm k n þ cÞ, the upper bound of goback is m kn and the upper bound of checkall is c. This experiment shows that t q is proportional to goback, which is Oðm k nÞ but the average value is far less than m kn and not proportional to m kn. This feature makes the algorithm much more efficient than running pattern matching algorithms for individual pattern k times.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>computes the elements of Pals(w) in this order. We first tackle the palindrome pattern matching problem in Definition 2.1. Note that while I et al. (2013) find start positions of matching occurrences, we search for end positions of matching occurrences. variables. Thus, if j 2 B½i, then the condition A½i 6 ¼ A½j holds. Now we construct P 0 as described in Algorithm 1. Figure 3 shows P 0 and B for P ¼ AGCGTA.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.3.</head><figDesc>Fig. 3. A variable pattern P 0 and an array B of inequality conditions for P ¼ AGCGTA. Variables A½i are written as A i in the figure for better readability</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Two cases in searching pal-equivalent strings. (a) There exists ðc; rÞ 2 Palsðw Þ such that c i and c þ r À 0:5 ! i. (b) There is no (c, r) satisfying the condition. Stripped boxes represent maximal palindromes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.4.</head><figDesc>Fig. 4. An automaton A constructed from P ¼ AGCGTA. Variables A½i are written as A i in the figure for better readability. A dashed transition from a state p is the failure transition d f ðpÞ and the label on the failure transition with square brackets represents the set of injective functions HðpÞ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>). Assume that given patterns P 1 ;. .. ; P k of length m 1 ;. .. ; m k are sorted by ascending order with respect to the length of the pattern and M is the sum of all pattern lengths. For P 1 ;. .. ; P k , we first compute variable patterns P 0 1 ;. .. ; P 0 k , while merging all B½m i s to one B½k½m k . It is straightforward to show that the process, which we call ConstructMultiVariablePattern, runs in Oðm k MÞ time using Oðm k MÞ space. We define an automaton B ¼ ðQ; A [ f]g; d; s; F; R; B; d f ; H; d p Þ. The definition of B is similar to the definition of A, except for an additional parameter: The pattern suffix transition function d p : Q ! Q contains transitions to find multiple matching occurrences on a single state. The automaton B simulates the Aho–Corasick algorithm, using P 0 1 ;. .. ; P 0 k instead of P 1 ;. .. ; P k as patterns. Algorithm 4 constructs B from P 1 ;. .. ; P k. We use a supplementary function StateForVP to return the state denoting the end of a given variable pattern.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.5.</head><figDesc>Fig. 5. An automaton B constructed from P1 ¼ AGA; P2 ¼ ACTG; P3 ¼ ATAT ; P4 ¼ TCTGC. Variables A½i are written as Ai in the figure for better readability. Dashed transitions represent failure transitions and dotted transitions represent pattern suffix transitions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.6.</head><figDesc>Fig. 6. Preprocessing time graph for Algorithm 3, where 10 m 1000. m denotes the length of pattern and t p denotes the preprocessing time. We can observe that t p follows the quadratic function of m since tp ¼ Oðm 2 Þ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.7.</head><figDesc>Fig. 7. Query time graph for Algorithm 3. m denotes the length of pattern and t q denotes the query time. We observe that t q is proportional to n and m since tq ¼ OðnmÞ. Note that t q for n ¼ 10 000 and m ¼ 100 is 13.02, whereas t q for n ¼ 100 000 and m ¼ 10 is 31.56. This implies that the increase of m affects t q less than the increase of n</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>V C The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 1151 Bioinformatics, 32(8), 2016, 1151–1157 doi: 10.1093/bioinformatics/btv738 Advance Access Publication Date: 16 December 2015 Original Paper</figDesc><table></table></figure>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Definition 2.1 (Palindrome Pattern Matching, Pal-Matching in Short): Given a text T of length n and a pattern P of length m, compute all positions i such that PalsðPÞ ¼ PalsðT½i À m þ 1 : iÞ. We then define the multiple palindrome pattern matching problems as follows: Definition 2.2 (Multiple Palindrome Pattern Matching, MPal-Matching in Short): Given a text T of length n and patterns P 1 ;. .. ; P k of length m 1 ;. .. ; m k , compute all pairs of a position i and a corresponding pattern P j such that PalsðP j Þ ¼ PalsðT½i À m j þ 1 : iÞ. For a pattern matching problem, we can consider an environment where we want to report all matching occurrences at position i after reading each character T½i. This often requires a preprocessing step of the pattern P—we call such a problem an online pattern matching problem. We call the time to preprocess P preprocessing time, and the time to read T and find all matching occurrences query time. 2.2 The algorithm for Pal-matching We start from designing an algorithm for Pal-Matching in Definition 2.1. The main idea of our algorithm is to design a special automaton simulating the Knuth–Morris–Pratt algorithm (Knuth et al., 1977). Before we design an algorithm, we have the following observation (See Figure. 2 for an illustration): For two strings w, z and an index i, if there exists ðc; rÞ 2 PalsðwÞ such that c i and c þ r À 0:5 ! i, then z½i ¼ z½2c À i. If there is no (c, r) satisfying the condition, then z½i 6 2 fz½2r À ijðc; rÞ 2 PalsðwÞ and c þ r À 0:5 ¼ i À 1g. Note that z½i is computed based on z½j&apos;s for j &lt; i, instead of characters in w. This leads us to define z to be a new sequence of variables, where we can assign characters to variables based on equality and inequality conditions, and the result string is palequivalent to w. Based on the observation, we define a variable pattern of P as follows: Definition 2.3: For a pattern P of length m over R of size t, a variable pattern P 0 is defined by an array A½m of variables and an array B½m of inequality conditions satisfying the following conditions: 1. P 0 ½i ¼ A½l i  for 1 i; l i m. 2. If there exists ðc; rÞ 2 PalsðPÞ where c i and c þ r À 0:5 ! i, then l i ¼ l 2cÀi , and thus, P 0 ½i ¼ P 0 ½2c À i. 3. Otherwise, for all j 2 f2r À ijðc; rÞ 2 PalsðPÞ and c þ r À 0:5 ¼ i À 1g; P 0 ½i 6 ¼ P 0 ½j. For P 0 ½i ¼ A½l i  and P 0 ½j ¼ A½l j , we use B½l i  ¼ l j and B½j ¼ i to denote P 0 ½i 6 ¼ P 0 ½j. Namely, if we assign characters to A based on inequality conditions, then PalsðP 0 Þ ¼ PalsðPÞ. Initially, we have no variables for constructing P 0. The inequality condition of Definition 2.3 implies that for every index i where every maximal palindrome with a centre c i ends before i, we need to introduce a new variable satisfying inequality conditions with respect to the previously-used variables. We construct an array A½m of variables. We also construct an array B½m that represents the inequality conditions between all pairs of Fig. 1. An example of the palindrome pattern matching. Stripped boxes below a string represent the set of all centre-distinct maximal palindromes with the length at least 1. Note that the pattern on the left is matched, while the pattern on the right is not matched due to the red-stripped box</note>

			<note place="foot">H.Kim and Y.-S.Han at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="4"> Conclusions Palindromic structures are widely studied in string processing and combinatorics and have applications in the analysis of DNA, RNA and protein sequences. For a text T of length n and a pattern P of length m, we have solved the online palindrome pattern matching in O(m 2 ) preprocessing time and O(mn) query time using O(m 2 ) space. Then we have extended the problem for multiple patterns P 1 ;. .. ; P k and solved the online multiple palindrome pattern matching in Oðm k MÞ preprocessing time and Oðm k nÞ query time using Oðm k MÞ space, where M is the sum of all pattern lengths and m k is the longest pattern length. Note that the algorithm for the multiple palindrome pattern matching does not increase the query time. We performed experiments to analyze the runtime of the algorithms, and found out that the runtime for the multiple pattern matching is much faster than expected. We believe that the algorithm can be efficiently used to find a structural similarity between multiple bio strings. Since the online multiple palindrome pattern matching is first proposed in the paper, our future work includes reducing time and space requirement of the algorithm. Moreover, we believe that the approach to solve the multiple pattern matching based on the Aho–Corasick automaton can be applied to pattern matching problems considering other structural equivalences.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We wish to thank the referees for the careful reading of the paper and many valuable suggestions including relevant references.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">An efficient algorithm for finding short approximate non-tandem repeats</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">F</forename>
				<surname>Adebiyi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="5" to="12" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">RVP-net: online prediction of real valued accessible surface area of proteins from single sequences</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Ahmad</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1849" to="1851" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Efficient string matching: an aid to bibliographic search</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">V</forename>
				<surname>Aho</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Corasick</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="333" to="340" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">ArrayExpress–a public repository for microarray gene expression data at the EBI</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Brazma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="68" to="71" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient large-scale sequence comparison by locality-sensitive hashing</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Buhler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="419" to="428" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Rfam 11.0: 10 years of RNA families</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">W</forename>
				<surname>Burge</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="226" to="232" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<monogr>
		<title level="m" type="main">Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<monogr>
		<title level="m" type="main">Introduction to Automata Theory, Languages, and Computation</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">E</forename>
				<surname>Hopcroft</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Ullman</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1979" />
			<publisher>Addison–Wesley</publisher>
			<pubPlace>Boston, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Counting and verifying maximal palindromes</title>
		<author>
			<persName>
				<forename type="first">I</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th International Conference on String Processing and Information Retrieval</title>
		<meeting>the 17th International Conference on String Processing and Information Retrieval</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="135" to="146" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Palindrome pattern matching</title>
		<author>
			<persName>
				<forename type="first">I</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">483</biblScope>
			<biblScope unit="page" from="162" to="170" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast pattern matching in strings</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">E</forename>
				<surname>Knuth</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="323" to="350" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Searching for gapped palindromes</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Kolpakov</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Kucherov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">410</biblScope>
			<biblScope unit="page" from="5365" to="5373" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Palindromic sequences are associated with sites of DNA breakage during gene conversion</title>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Krawinkel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="3871" to="3882" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Evolutionary conservation of sequence and secondary structures in CRISPR repeats</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Kunin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">61</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Cas9 as a versatile tool for engineering biology</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Mali</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="957" to="963" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">A new linear-time &quot; on-line &quot; algorithm for finding the smallest initial palindrome of a string</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manacher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="346" to="351" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">STRING: finding tandem repeats in DNA sequences</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Parisi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1733" to="1738" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Sequence progressive alignment, a framework for practical large-scale probabilistic consistency alignment</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Paten</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="295" to="301" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">PatMaN: rapid alignment of short sequences to large databases</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Prü Fer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1530" to="1531" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Combinatorial pattern discovery in biological sequences: the TEIRESIAS algorithm</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Rigoutsos</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Floratos</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="55" to="67" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<monogr>
		<title level="m" type="main">Theory of Computation</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Wood</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1986" />
			<pubPlace>Harper &amp; Row ; New York City, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>