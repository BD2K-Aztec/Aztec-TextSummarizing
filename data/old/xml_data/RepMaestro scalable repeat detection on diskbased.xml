
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:39+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Genome analysis RepMaestro: scalable repeat detection on disk-based genome sequences</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010">19 2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Nikolas</forename>
								<surname>Askitis</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Software Engineering</orgName>
								<orgName type="institution">University of Melbourne</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName>
								<forename type="first">Ranjan</forename>
								<surname>Sinha</surname>
							</persName>
							<email>sinhar@unimelb.edu.au</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Software Engineering</orgName>
								<orgName type="institution">University of Melbourne</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Genome analysis RepMaestro: scalable repeat detection on disk-based genome sequences</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">26</biblScope>
							<biblScope unit="page" from="2368" to="2374"/>
							<date type="published" when="2010">19 2010</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq433</idno>
					<note type="submission">Received on March 16, 2010; revised on July 19, 2010; accepted on July 23, 2010</note>
					<note>[13:37 28/8/2010 Bioinformatics-btq433.tex] Page: 2368 2368–2374 Associate Editor: Dmitrij Frishman RepMaestro is available at Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: We investigate the problem of exact repeat detection on large genomic sequences. Most existing approaches based on suffix trees and suffix arrays (SAs) are limited either to small sequences or those that are memory resident. We introduce RepMaestro, a software that adapts existing in-memory-enhanced SA algorithms to enable them to scale efficiently to large sequences that are disk resident. Supermaximal repeats, maximal unique matches (MuMs) and pairwise branching tandem repeats have been used to demonstrate the practicality of our approach; the first such study to use an enhanced SA to detect these repeats in large genome sequences. Results: The detection of supermaximal repeats was observed to be up to two times faster than Vmatch, but more importantly, was shown to scale efficiently to large genome sequences that Vmatch could not process due to memory constraints (4 GB). Similar results were observed for the detection of MuMs, with RepMaestro shown to scale well and also perform up to six times faster than Vmatch. For tandem repeats, RepMaestro was found to be slower but could nonetheless scale to large disk-resident sequences. These results are a significant advance in the quest of scalable repeat detection. Software availability:</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The analysis of whole genome sequences is of critical importance in bioinformatics. A significant problem in such sequence analysis is the presence of repetitive structures, the analysis of which plays a crucial role in the study and comparison of complete genomes (<ref type="bibr" target="#b1">Abouelhoda et al., 2006</ref>). These repetitive regions occur in biological strings such as in DNA, RNA and protein, and have been shown to play a functional and evolutionary role (<ref type="bibr" target="#b10">Gusfield, 1997;</ref><ref type="bibr" target="#b13">Jurka and Batzer, 1996;</ref><ref type="bibr" target="#b21">McConkey, 1993;</ref><ref type="bibr" target="#b25">Smith, 1998;</ref><ref type="bibr" target="#b27">Watson et al., 1987</ref>). The vast majority of repeats occur in larger organisms such as plants and animals belonging to the eukaryote kingdom and comparatively fewer repeats occur in prokaryote organisms such as bacteria. Significantly, families of repeats account for almost 50% of * To whom correspondence should be addressed. the human genome (<ref type="bibr" target="#b10">Gusfield, 1997</ref>) and comprise nearly 11% of the mustard weed genome and 7% of the worm genome (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref><ref type="bibr" target="#b1">Abouelhoda et al., , 2006</ref>). Surprisingly, only a very small fraction (2–3%) of the human genome sequence contains the protein-coding regions. A large fraction of the genome contain repetitive elements, the functioning of which are yet to be known. For example, long and short interspersed elements account for 21% and 13% of the genome, respectively, while repetitive elements such as micro-and minisatellites could amount to 15% of the genome. This indicates that repetitive sequences exist in abundance in the genome and several of them have been shown to result in abnormalities and diseases. During the analysis of genomes, the basic tasks include locating and characterizing repetitive sequences in the genome and finding similar repeats between two genomes. Broadly, there are two types of repeats: exact and approximate. While exact repeats are a smaller fraction of the repeats having biological interest, they form the 'core blocks of approximate repeats' (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref><ref type="bibr" target="#b1">Abouelhoda et al., , 2006</ref><ref type="bibr" target="#b19">Leung et al., 1991</ref>). Consequently, we restrict our discussion to the detection of exact repeats and do not consider approximate or inexact repeats. Nonetheless, adapting our software to detect approximate repeats presents a promising avenue for future research. Repeats play a crucial role in furthering our understanding, but the rate at which new genome sequences are being uncovered has been increasing rapidly. The genome sequencing project has been generating sequence data at an exponential rate (<ref type="bibr" target="#b3">Benson et al., 2007</ref>) and the size of GenBank has been doubling approximately every 18 months. Hence, with the growth of genomic collections as well as increasing query lengths (<ref type="bibr" target="#b28">Williams and Zobel, 2002</ref>), it is crucial that the efficiency of sequence analysis remains practical. An example of the impact of this exponential data growth is with the popular local alignment search tool BLAST (<ref type="bibr" target="#b2">Altschul et al., 1997</ref>), which has been getting slower by ∼64% each year (<ref type="bibr" target="#b6">Cameron et al., 2004</ref>) inspite of hardware improvements. Thus, we continue to need not only faster and more efficient approaches for the detection of repeats but also ones that are scalable. Two key data structures used for such tasks are the suffix tree and the suffix array (SA). These are helpful for the analysis of sequences that are large but otherwise static. There exists disk-based suffix tree (<ref type="bibr" target="#b23">Phoophakdee and Zaki, 2007</ref>) and SA construction (<ref type="bibr" target="#b9">Dementiev et al., 2008</ref>) algorithms that can create a human genome scale structure in under 5 h. However, these data structures are seldom considered for large-scale genome analysis, where these indexes primarily reside on disk. This is primarily due to the poor locality of access inherent in these structures. Our intention is to show that the enhanced SA-based structure (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref><ref type="bibr" target="#b1">Abouelhoda et al., , 2006</ref>Page: 2369 2368–2374 RepMaestro<ref type="bibr" target="#b22">Moffat et al., 2009;</ref><ref type="bibr" target="#b24">Sinha et al., 2008</ref>) scales very well to the task of repeat detection of large genomes. Furthermore, it has been shown that a SA equipped with additional information can be used to solve all problems for which a suffix tree has been traditionally used (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref>), thus our techniques could be applied to enhance the scalability of a wide array of (bottom–up traversal) problems. Fundamental problems in bioinformatics (<ref type="bibr" target="#b10">Gusfield, 1997;</ref><ref type="bibr" target="#b26">Smyth, 2003</ref>) include the detection of supermaximal repeats, maximal repeats, maximal unique matches (MuMs), maximal multiple exact matches, tandem repeats, exact pattern matching and maximal exact matches; each of which has numerous applications in comparative genomics, homology searching and finding repeat sequences. For example, tandem repeats are the markers of choice in genomic research and find applications in determining parentage, genealogical DNA tests, genotyping pathogens, morphological evolution and in human identification in forensic cases. Furthermore, variations in tandem repeats are an indication of diseases. Existing genomic search tools (<ref type="bibr" target="#b7">Chain et al., 2003</ref>) can be divided into two major groups: exhaustive and index based. The exhaustive search tools like BLAST incorporate several heuristics to compare the query to each sequence in the database, but there are growing concerns regarding its scalability. The index-based tools such as CAFE (<ref type="bibr" target="#b28">Williams and Zobel, 2002</ref>), Vmatch () and MUMmer (<ref type="bibr" target="#b17">Kurtz et al., 2004</ref>) preprocess the collection to create an index. CAFE adapts the inverted index structure for fast and scalable homology search but it remains unclear if it could be adapted to solve the other core bioinformatics problems. Vmatch, a state-of-the-art pattern recognition software, is based on an enhanced SA structure (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref>) and solves several of the core bioinformatics problems but it is restricted to sequences and indexes being memory-resident. REPuter (<ref type="bibr" target="#b16">Kurtz et al., 2001</ref>), a precursor to Vmatch, is based on the suffix tree representation and consequently has both speed and scalability concerns.<ref type="bibr" target="#b20">Lian et al. (2008)</ref>introduced a technique that builds an index on top of an external suffix tree to detect supermaximal repeats on large genome sequences. With a minimum repeat length of 10, their implementation is 2× faster than Vmatch, but its large index size is prohibitive. Thus, a primary drawback in existing systems is that the sequences and associated structures are required to be memory-resident for efficiency. The Tallymer software () addresses this concern for the task of k-mer counting and for indexing large sequence sets, by utilizing a disk-resident-enhanced SA. Tallymer offers linear processing time and space consumption, but it is unclear as to whether the software can operate with a bound on memory usage (i.e. whether or not it is scalable), as a consequence of its linear space requirement. Moreover, the authors do not investigate or propose software solutions for finding repeats such as MuMs, in a scalable manner. Consequently, there exists inherent constraints in existing software tools that we seek to improve upon. We have, therefore, developed a pattern recognition software called RepMaestro that offers scalable and memory-conscious algorithms for finding supermaximal repeats, MuMs and tandem repeats in large genome sequences on disk. Our approach, similar to the workings of Vmatch, employs an enhanced SA that is engineered to be accessed and maintained from disk. We demonstrate through careful experimental evaluations that our approach is highly scalable and in many cases, faster than Vmatch and MUMmer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS AND ALGORITHMS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Enhanced SA/SLB</head><p>Since we must process a SA and its corresponding longest common prefix (LCP) array and Burrow–Wheeler transform (BWT) array, we employ an enhanced SA (<ref type="bibr" target="#b1">Abouelhoda et al., 2006;</ref><ref type="bibr" target="#b11">Homann et al., 2009</ref>) or SLB (abbreviation for SA, LCP and BWT) array to improve access locality of large disk-resident genome sequences. To create an SLB array, we copy each SA value (4 bytes), its corresponding LCP (4 bytes) and BWT value (1 byte) into a 9-byte SLB cell (assuming a 32-bit address space; otherwise its 17 bytes). Thus, SLB<ref type="bibr">[i]</ref>represents SA<ref type="bibr">[i]</ref>,LCP<ref type="bibr">[i]</ref>,BWT<ref type="bibr">[i]</ref>, where i = 0 &lt; i &lt; n (n being the number of entries).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Supermaximal repeats</head><p>A repeat is a substring occurring in at least two different positions in any given sequence. A maximal repeat satisfies the repeat conditions but cannot be extended either to the left or right to make a longer repeat. Thus, a maximal repeated pair in a sequence S is a pair of identical substrings S 1 and S 2 in S such that the character to the immediate left or right of S 1 is different from the character to the immediate left or right of S 2 , respectively. That is, extending S 1 and S 2 in either direction would destroy the equality of the two strings. A supermaximal repeat is also a maximal repeat except that it does not occur as a substring of any other maximal repeat. Our interest is to develop an algorithm to detect supermaximal repeats efficiently on large disk-based genome sequences. We direct the reader to<ref type="bibr" target="#b1">Abouelhoda et al. (2006)</ref>for further information regarding maximal and supermaximal repeats. According to<ref type="bibr" target="#b1">Abouelhoda et al. (2006)</ref>, the detection of supermaximal repeats requires finding all L-intervals and local maximas. To find these, we need to only process the LCP array. An L-interval represents a region i to j (where 0 ≤ i &lt; j ≤ n) in the LCP array that shares a LCP length of L. A more formal definition is provided in Supplementary Material. A local maxima is defined as an L-interval i to j, where all LCP values between positions (i+1) and j are equal to L. Specifically, lcp<ref type="bibr">[k]</ref>=L for all (i+1) ≤ k ≤ j. A local maxima is recognized as a supermaximal repeat if and only if the BWT values between positions i and j are pairwise distinct. Once satisfied, positions i to j in the SA are supermaximal repeats. We need an efficient method of finding supermaximal repeats on a genome sequence (an SLB) that is stored on disk.<ref type="bibr" target="#b1">Abouelhoda et al. (2006)</ref>provide a simple linear-time algorithm that involves finding all local maxima in a sequence S, to compute supermaximal repeats. We provide the algorithm in Supplementary Material. This is an elegant solution but one that may not be particularly beneficial to a practitioner that wishes to implement it on disk. Specifically, how do we find all local maximas on disk efficiently? Moreover, why do we need to find all local maximas before we proceed to find supermaximal repeats? We, therefore, propose an algorithm that is engineered to eliminate random access to disk and also make efficient use of CPU cache, by finding all supermaximal repeats through a single scan of an SLB array. Given an SLB array, we scan it once from left-to-right, which is both I/O optimal and CPU-cache efficient. While we are scanning, our goal is to detect specific LCP and BWT patterns that signify the presence of a supermaximal repeat. We look for hat-like patterns in LCP values: the second LCP must be larger than the first, thereupon the LCP values must be equal to the second LCP followed by a fall (or equivalently, when the SLB is exhausted). Once we have established the existence of this hat-like pattern, the BWT values are checked to confirm that they are distinct (this is accomplished on-thefly). The requirements are: a pre-built SLB of S and optionally its text file, which is needed to print out the supermaximal repeats. We summarize our algorithm below.</p><p>(1) Copy the current contents from SLB<ref type="bibr">[i]</ref>(init. i = 0) into an empty (reuseable) buffer and maintain a counter C (init. 1) of its entries. Clear a (reusable) BWT bit-map that has a 1-to-1 mapping with the Page: 2370 2368–2374</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N.Askitis and R.Sinha</head><p>ASCII-7 table. Set the bit that maps to the current BWT (from SLB<ref type="bibr">[i]</ref>). Label the current LCP value as previous LCP.</p><p>(2) Fetch the next entry from the SLB (i = i+1 then SLB<ref type="bibr">[i]</ref>). Its LCP value represents the current LCP. Set the bit that maps to the current BWT. If the corresponding position is already set, raise a flag to indicate. Increment C by 1 if and only if the previous step was not Step 1.</p><p>(3) If current LCP &gt; previous LCP and C = 1, append the contents of SLB<ref type="bibr">[i]</ref>to the buffer. Update the previous LCP label then go back to Step 2 unless the BWT flag was raised in the previous step, in which case, go to Step 1.</p><p>(4) If current LCP = previous LCP and C = 1, then this is not an L-interval. Go to Step 1.</p><p>(5) If current LCP &gt; previous LCP and C ≥ 2, then it can not be a local maxima. Go to Step 1.</p><p>(6) If current LCP = previous LCP and C ≥ 2, append the contents of SLB<ref type="bibr">[i]</ref>to the buffer. Update the previous LCP label then go back to Step 2 unless the BWT flag was raised in the previous step, in which case, go to Step 1.</p><p>(7) If current LCP &lt; previous LCP (or SLB is exhausted), iterate through each entry in the buffer and print out the corresponding SA value that represents a location of a supermaximal repeat. Finish by printing the maximum LCP encountered during the iteration—the length of the repeats. Go back to Step 1 and repeat until SLB is exhausted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">MuMs</head><p>MuMs are important in computational biology for large-scale genome comparisons and sequence alignment problems. A MuM is defined as: given two sequences S1 and S2, a MuM is a sequence that occurs exactly once in S1 and once in S2, and is not contained in any longer such sequence. Global alignment algorithms (<ref type="bibr" target="#b12">Hon and Sadakane, 2002</ref>) take O(mn) time, given input sequences of length m (for S1) and n (for S2), respectively. Unfortunately, large values of m and n above 1 million characters makes it impractical. To scale to larger sequences,<ref type="bibr" target="#b8">Delcher et al. (2002)</ref>introduced a heuristic that if a long sequence occurs exactly once in the two strings, then this substring has a high chance of occurring in the global alignment. This reduced the problem to finding the MuM, aligning the MuMs and then aligning the local gaps between successive MuMs. Significantly, these phases require only O(n) time and is faster than conventional algorithms. Consequently, several tools exist that seek to align two similar genomes. During this alignment, the first task is to find the MuM of the two genome sequences. While there exists approaches using suffix trees that can compute MuMs in O(n) time and space, where n =|S1#S2| and # is a symbol not occurring in either of S1 and S2, the SA approach offers greater space efficiency and locality of access. Hence, we have used the ESA approach (<ref type="bibr" target="#b0">Abouelhoda et al., 2004;</ref><ref type="bibr" target="#b24">Sinha et al., 2008</ref>) to engineer an algorithm that can scale to large disk-resident genome sequences. We provide an existing linear time MuM algorithm (<ref type="bibr" target="#b1">Abouelhoda et al., 2006</ref>) in Supplementary Material, which we adapted for use on disk. Similar to the supermaximal repeat algorithm described earlier, the MuM algorithm requires us to find all local maximas prior to processing, which is not an efficient task on disk. We, therefore, present our modified MuM algorithm below that can find MuMs in S1#S2 with single scan of its SLB array. Our algorithm can not compute matches in the reverse strand (reverse complemented matches), though it can be readily adapted for this task at the expense of consuming more disk space for storing the necessary indexes (we provide further details in Supplemenatry Material). During the scan, we look for local maximas with spike-like patterns in LCP values. First, we find a local maxima (of only two entries) by tracking a consecutive rise-fall pattern of LCP values. Once identified, the corresponding BWT values are compared. If they are distinct and the two corresponding SA values do not appear in the same file (S1 or S2), then the SA values represent the location of a MuM.</p><p>(1) Store the contents of SLB<ref type="bibr">[i]</ref>(init. i = 0) into an empty reusable buffer and maintain a counter C (init. 1) of its entries. Label the current LCP value as the previous LCP.</p><p>(2) Fetch the next entry from the SLB (i = i+1 then SLB<ref type="bibr">[i]</ref>). Its LCP value now represents the current LCP. Increment C by 1 if and only if the previous step was not Step 1.</p><p>(3) If current LCP &gt; previous LCP and C = 1, append the contents of SLB<ref type="bibr">[i]</ref>to the buffer. Update the previous LCP label and back to Step 2.</p><p>(4) If current LCP = previous LCP and C = 1, then this is not an L-interval. Go to Step 1.</p><p>(5) If current LCP &gt; previous LCP and C ≥ 2, then this can not be a local maxima. Go to Step 1.</p><p>(6) If current LCP = previous LCP and C ≥ 2, append the contents of SLB<ref type="bibr">[i]</ref>to the buffer. Update the previous LCP label and go back to Step 2.</p><p>(7) If current LCP &lt; previous LCP (or SLB exhausted) and C = 2 then check if the first and second BWT values in the buffer are distinct; check if the first SA value in the buffer &lt;p while the second &gt;p or visa-versa (p is the location in bytes of '#' in the text file). If both these conditions are met then the local maxima is a MuM.</p><p>(8) Go back to Step 1 and repeat until SLB is exhausted.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Pairwise branching tandem repeats</head><p>Pairwise branching tandem repeats (<ref type="bibr" target="#b1">Abouelhoda et al., 2006</ref>) (which we label as a tandem repeat for brevity) consist of two or more substrings comprised of two or more nucleotides in a DNA sequence that are identical and occur adjacent to each other. For example, in the sequence ATCGATCGGCAT, the substring 'ATCG' occurs twice and is thus a tandem repeat. The tandem repeats occur frequently in genomes; for instance, nearly 10% of the human genome is composed of such repeats. Several programs to locate repeated strings in sequences exist. These include tools such as REPuter (<ref type="bibr" target="#b16">Kurtz et al., 2001</ref>), Tandem Repeats Finder (<ref type="bibr" target="#b4">Benson, 1999</ref>), Tandem Repeats Analyzer (<ref type="bibr" target="#b5">Bilgen et al., 2004</ref>) and mreps (<ref type="bibr" target="#b14">Kolpakov et al., 2003</ref>). However, existing tools are limited in the number and size of sequences, the length of repeats that can be detected and range of DNA sequence formats supported. Due to its significant applications, it is important that a scalable algorithm is developed to process large diskresident sequences. We present an existing in-memory algorithm for the computation of tandem repeats (<ref type="bibr" target="#b1">Abouelhoda et al., 2006</ref>) in Supplementary Material, which we base our following discussion on. A key step of the algorithm requires us to find and process each L-interval in a sequence where L is ≥ an LCP value (L &gt; 0). Since we are no longer restricted to processing only local maximas, we require an algorithm that finds all L-intervals in an efficient manner, which on disk implies scanning the SLB from left-to-right. Fortunately, a simple linear stack-based algorithm exists that is well suited for our purpose (<ref type="bibr" target="#b1">Abouelhoda et al., 2006</ref>). When an element is popped from the stack (which represents an L-interval), it is fed to the tandem repeat algorithm shown in Supplementary Material. However, the tandem repeat algorithm presented cannot be mapped directly to disk without incurring substantial performance penalties. We require an inverse SA also known as a rank array. Since the rank array is accessed frequently (once for every entry in the L-interval) and at random locations, maintaining it on disk is not a feasible solution. We, therefore, need to eliminate the use of the ranked array, if we are going to realize a viable solution on disk. We eliminate the rank array by using the SLB array together with an optimized binary search routine. When we are given an L-interval [i,...,<ref type="bibr">j]</ref>Page: 2371 2368–2374<ref type="figure" target="#tab_1">Table 1</ref>. The size (million base pairs approximately) of our human genome datasets with an alphabet size of 4, showing the chromosome sequence used, the largest L-interval (entries contained) with L ≥ 4, and the number ofThe # character is the divisor between two datasets. The SLB construction time (s) and disk space requirements (MB) are also shown for our 9n (default) SLB. from the stack, we seek to the position i in the SLB array and buffer all SLB entries up to j inclusive. This step incurs a potential random disk access to the SLB, but this is still better than incurring several random disk accesses to a rank array. Now that we have buffered the entire L-interval in memory, we can access the SA value of each entry in the interval, one at a time, adding L to it (temporarily) and then searching all remaining SA values in the interval for a match. If found, then we know that the current SA value +L exists within the interval i and j. However, searching each SA value n times, where n is the number of entries in the interval, is an n 2 problem. Hence, this is not an efficient solution. Instead, once we buffer the L-interval in memory, we iterate through each entry and copy (append) its SA value to an array/buffer. The array is then sorted using quick sort. Once sorted, we conduct an optimized binary search as follows: iterate through each SA value in the sorted array and conduct a binary search looking for that element +L. If found, we know that the current SA value +L exists within the interval i and j. Otherwise, we access the next element in the L-interval, add L, and redo the binary search, repeating in this manner until we exhaust the array. On each repetition (including the first), we reduce the number of items searched by 1 (truncating the start of the array). This forms an optimized binary search thats allows large L-intervals to be processed more efficiently. Another concern to performance is the access made to the text file, where two characters are fetched and compared. However, since access to the text is localized between S<ref type="bibr">[p+L]</ref>and S<ref type="bibr">[p+2L]</ref>, only a single disk seek is required to fetch a strip of text that begins at p+L and ends at p+2L inclusive. If the size of this strip exceeds some threshold, say 128 MB, then we can revert back to conducting two random seeks. However, for our data, the largest text strip was found to be only a few kilobytes long. Alternatively, we can eliminate disk accesses altogether by buffering the entire text in memory, assuming we have enough space to do so. The potential drawback of our adaptation to the existing tandem repeat algorithm is the need for sufficient memory to buffer an entire L-interval, and the corresponding text strip and/or the entire text file. Each SLB entry consumes 12 bytes of memory (9 bytes on disk but 12 bytes in-memory due to alignment constraints). Though, as we show in later experiments, even for large sequences, the amount of memory consumed in this manner is relatively small. Furthermore, an L-interval can be easily processed in smaller fragments, allowing one to impose a (reasonable) bound on space consumption. As such, our algorithm remains a scalable solution. In contrast, our disk-based implementations of the supermaximal and MuM algorithms do not require us to buffer the entire L-interval, and are thus more memory-efficient. With these two algorithms, we only need to retain the current local maxima in memory and one that adheres to strict conditions that enforce a bound on its size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RepMaestro</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EXPERIMENTAL METHODOLOGY</head><p>Our experiments were conducted on a 64-bit AMD Athlon II 240 processor running at 2.8 Ghz with 4 GB RAM and a 64-bit Linux operating system, which was kept under light load (no GUI, single user mode). We compiled our software using g++ (ver. 4.4.3) with all optimizations enabled (-O3). Further details are provided in Supplementary Material. The datasets used are shown in<ref type="figure" target="#tab_1">Table 1</ref>, derived from actual biological data, namely the complete hg19 human genome. 1 We extracted a selection of chromosomes from hg19, which were pre-processed to ensure upper case letters (otherwise RepMaestro would consider g = G for example) and also to (optionally) remove all 'N' characters, for brevity. RepMaestro assumes an alphabet size of 4 (5 including 'N'); though not recommended, it can also accept larger alphabets (including all printable ASCII characters). The Y chromosome formed our smallest dataset. We then concatenated it with an orderly sequence of chromosomes, creating eight datasets in total. By growing the datasets in this manner (as subsets), we can better illustrate the scalability of our algorithms in comparison to Vmatch. Similarly, we combined a selected pair of (pre-processed) chromosomes together to form a single sequence (five in total and increasing in size) separated by the unique # character, for use in MuM processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comparisons made: we compare the performance of RepMaestro</head><p>(on supermaximal repeats, MuM and pairwise branching tandem repeats) against Vmatch by measuring the Wall time (s) using the Linux time command. We enabled the following options in Vmatch to reduce the output size and to allow for more comparable results:-nodist-noscore-noidentity-noevalue-absolute. Measurements were averaged over 10 runs—the SD of which was low. After each run, main memory was flushed with random data and the disks were unmounted then Page: 2372 2368–2374remounted to flush system buffers, to allow for fairer comparison between an in-memory solution (Vmatch) and our disk-based solution (RepMaestro). We conducted our experiments by directing all output to /dev/null. Our results are based on our 9n SLB; 17n SLB offers the same scalable traits, but as expected, requires approximately double the disk space and processing time. Since RepMaestro is a 64-bit compatible software and considering that we used a 64-bit computing architecture, we relied on the 64-bit version of Vmatch; we also provide results of the 32-bit version in Supplementary Material. We verified the correctness of our software by cross checking with the results generated by Vmatch. In addition, we compare against SeqAn 2 and MUMmer but due to space constraints, we provide most of their results in Supplementary Material and focus on Vmatch (64 bit) below, since it is a state-of-the-art software that supports most repeats.<ref type="figure" target="#tab_2">Table 2</ref>shows the time required to find all supermaximal repeats with an LCP ≥ 30 (i.e. with an LCP of 30, or alternatively, the minimum length of matches). We also provide results for an LCP ≥ 15 in Supplementary Material. RepMaestro is consistently faster than Vmatch and scales well with increasing sequence size. With a genome sequence size of 25.7 million base pairs (Mbp) for instance, RepMaestro is marginally faster than Vmatch. As we increase the size of the sequence to 285.7 Mbp—the operational limit for Vmatch on a 64-bit system with 4 GB of RAM—RepMaestro is ∼30% faster, but more importantly, it can continue to process 363.5 and 442.4 Mbp with a linear increase in processing time. SeqAn also displayed similar performance to Vmatch, being consistently slower and less scalable than RepMaestro and rapidly exhausting main memory. These results provide a strong indication that RepMaestro is indeed a more scalable solution for finding supermaximal repeats. RepMaestro is a superior and scalable solution due to its single linear scan of the SLB array. This action results in optimal use of disk since no random accesses are made. In addition, this sequential Page: 2373 2368–2374<ref type="figure" target="#tab_4">Table 4</ref>. The genome sequences (increasing in size) represent the columns of the<ref type="figure">Table.</ref>We also vary the LCP from a minimum of 4 to a maximum of 32, represented as the rows. With an LCP ≥ 4, the locations of all tandem repeats that are at least 4 characters long are found. For all the cases considered, RepMaestro was slower than Vmatch. Unlike its application in supermaximal repeats and MuMs, when applied to tandem repeats, RepMaestro incurs a considerable amount of overhead even for small files. This is because not all tandem repeats can be found with a single scan of the SLB array. Since L-intervals can be subsets of a larger interval, we must rely on the linear stack-based algorithm described in Section 2.4 to efficiently provide us with L-intervals. We only consider L-intervals with a L-value (length of the smallest common prefix of all entries in the L-interval) ≥ the minimum LCP, which is either 4, 8, 16 or 32. Hence, the stack is small in size, but even with this pruning, we still need to buffer an entire (or ordered fragments of an) L-interval from disk. This can be an expensive ordeal relative to Vmatch, which maintains its enhanced SA in memory. As shown in<ref type="figure" target="#tab_1">Table 1</ref>, some L-intervals particularly those with small L can contain many millions of entries. As a consequence, as we reduce the minimum LCP considered from 32 to 4, the number of L-intervals processed typically increase, since more genome sequences are likely to share shorter common prefixes. This unfortunately implies more disk I/O that will impact performance as reflected in<ref type="figure" target="#tab_4">Table 4</ref>. Consider the results for our 285.7 Mbp dataset with RepMaestro that buffers the entire genome text in memory. The advantage of text file buffering is that it eliminates the random disk seek incurred when we fetch the pair of characters required by the tandem repeat algorithm (see Supplementary Material). With a minimum LCP of 32, RepMaestro requires ∼55 s. Although this is ∼44% slower than Vmatch, RepMaestro's performance is still reasonable considering that Vmatch cannot process larger sequences due to its high memory requirements. However, when we reduce the minimum LCP to 4, the time taken by RepMaestro increases by an order of magnitude— to ∼456 s. We observe similar results when we disable text file buffering, with the performance of RepMaestro degrading in all cases due to the additional disk costs associated with fetching the required characters from disk. Although RepMaestro requires more time relative to Vmatch, the cost is linear relative to sequence size. This is also the case with Vmatch, but unfortunately, Vmatch cannot process genome sequences &gt;285.7 Mbp unless sufficient memory is available— which is somewhat difficult to justify since processing a 363.5 Mbp sequence exhausts 4 GB of RAM. Processing the entire human genome (3 Gb) would, therefore, require many tens of gigabytes of RAM, which is currently uncommon in standard workstations. Thus, even though RepMaestro is slower, it compensates with scalability, offering an immediate and feasible solution for large-scale tandem repeat computations. With respect to memory consumption, RepMaestro requires enough memory (assuming no interval fragmentation) to buffer the largest L-interval considered and preferably space for the entire genome sequence—along with space for the stack, implemented as a single resizable array. Given our 442.4 Mbp genome sequence and an LCP ≥ 4, the longest L-interval processed contained 6 361 943 entries, consuming about 77 MB on a 32-bit system and around 153 MB on a 64-bit system—a relatively tiny amount; and with a total of 303 831 513 L-intervals, the maximum stack size was only 249 entries (2988 bytes). Moreover, a large L-interval can be split into smaller fragments, allowing RepMaestro to operate with a reasonable bound (say, at least 512 MB) on memory consumption. In practice, however, as discussed with supermaximal repeats and MuM, memory consumption can fluctuate by several hundred megabytes as a result of SLB prefetch. Furthermore, our results are based on conventional hard drives, which are still a common method of non-volatile storage. Solid state hard drives, however, are gaining popularity since they can offer faster and consistent transfer speeds and importantly, substantially reduced random seek costs. Our RepMaestro software is likely to further benefit from such a drive, allowing it to operate more efficiently, which is an interesting avenue for future research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N.Askitis and R.Sinha</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS AND DISCUSSION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Supermaximal repeats</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>RepMaestro</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Page: 2374 2368–2374</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>N.Askitis and R.Sinha</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>The analysis of repetitive sequences plays a key role in genome analysis. Such repetitive regions are abundant in genome sequences and these have been demonstrated to have several practical biological applications such as in the determination of parentage and in forensics. While there are several efficient algorithms available that enable the detection of repetitive sequences, these are mainly restricted to smaller memory-resident sequences and, therefore, can not scale well or operate on large sequences that are stored on disk. We have, therefore, introduced RepMaestro, a software that implements algorithms that allows us to compute supermaximal repeats, MuMs and tandem repeats of a large genome sequence stored on disk, in a scalable and memory-efficient manner. In most cases, we outperform a state-of-the-art memory-resident algorithm while simultaneously consuming significantly less (and bounded) memory. This allows RepMaestro to be an immediate solution for the problem of rapidly processing large genome sequences that are many times larger than the available main memory. RepMaestro is, however, dependant on third-party software(s) to generate the required indexes, and so, its applicability is subjected to their operational constraints (see Supplementary Material).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>supermaximal repeats and MuMs with L ≥ 30</figDesc><table>Size (Mbp) 
SLB (s) 
SLB (MB) 
Chromosome sequence 
Max. interval size, L ≥ 4 
No. repeats L ≥ 30 

25.7 
1 .1 
230.8 
chrY 
399 879 
147 681 
supermax 
60.8 
1 .3 
546.8 
chrY,chr21 
938 808 
358 314 
supermax 
95.7 
3 .5 
860.8 
chrY,chr21,chr22 
1 370 089 
709 102 
supermax 
151.5 
5 .9 
1363.1 
chrY,chr21,chr22,chr19 
2 144 861 
1 598 991 
supermax 
211.0 
1 4 .1 
1898.7 
chrY,chr21,chr22,chr19,chr20 
2 973 273 
2 131 873 
supermax 
285.7 
2 3 .7 
2570.6 
chrY,chr21,chr22,chr19,chr20,chr18 
4 148 856 
2 674 267 
supermax 
363.5 
3 7 .4 
3270.7 
chrY,chr21,chr22,chr19,chr20,chr18,chr17 
5 257 139 
3 686 434 
supermax 
442.4 
5 1 .0 
3980.7 
chrY,chr21,chr22,chr19,chr20,chr18,chr17,chr16 
6 361 943 
4 613 547 
supermax 

60.8 
1 .6 
546.8 
chrY#chr21 
− 
64 960 
MuM 
115.3 
5 .4 
1037.8 
chr19#chr20 
− 
256 311 
MuM 
156.7 
1 1 .1 
1410.1 
chr16#chr17 
− 
352 467 
MuM 
183.9 
1 1 .4 
1654.9 
chr13#chr14 
− 
279 282 
MuM 
262.4 
2 5 .0 
2361.9 
chr10#chr11 
− 
451 068 
MuM 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 2. The wall time in seconds required to find all supermaximal repeats with LCP ≥ 30 using RepMaestro supermax against Vmatch</figDesc><table>Mbp 
25.7 
6 0 .8 
9 5 .7 
151.5 
2 1 1 .0 
285.7 
363.5 
442.4 

Vmatch 
2.8 
6 .0 
9 .7 
1 5 .5 
2 2 .6 
3 1 .4 
− 
− 

RepMaestro 
2.3 
4 .8 
7 .5 
1 1 .9 
1 6 .2 
2 2 .1 
2 7 .9 
3 3 .8 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 3.</figDesc><table>The wall time in seconds required to find all MuMs with an LCP ≥ 30 

chrY#chr21 
chr19#chr20 
chr16#chr17 
chr13#chr14 
chr10#chr11 

Vmatch 
30.7 
52.3 
74.0 
77.9 
125.2 
MUMmer 
39.5 
78.4 
110.8 
134.5 
197.7 
RepMaestro 
4.8 
8.8 
12.1 
14.2 
20.1 

Datasets are increasing in size from left to right. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 4. The time required in seconds to find tandem repeats as a function of the min repeat length and the sequence size</figDesc><table>Mbp 
25.7 
6 0 .8 
9 5 .7 
151.5 
2 1 1 .0 
285.7 
363.5 
442.4 

Min LCP 
VMatch 
4 
4 .9 
1 1 .2 
1 8 .2 
3 0 .5 
4 3 .3 
5 7 .4 
− 
− 

8 
4 .2 
1 0 .9 
1 7 .6 
2 9 .2 
4 1 .5 
5 5 .0 
− 
− 

16 
3.3 
7 .3 
1 1 .8 
1 9 .9 
2 7 .8 
3 6 .2 
− 
− 

32 
2.8 
6 .0 
9 .8 
1 6 .0 
2 2 .3 
3 0 .2 
− 
− 

Min LCP 
RepMaestro (with text buffering) 
4 
3 2 .6 
8 1 .6 
135.6 
230.4 
330.1 
456.3 
607.7 
757.6 
8 
2 0 .9 
5 1 .8 
8 6 .7 
151.9 
219.5 
300.6 
395.4 
494.9 
16 
7.8 
1 6 .9 
2 9 .1 
5 6 .0 
7 9 .8 
107.7 
145.8 
187.3 
32 
5.1 
1 0 .4 
1 6 .8 
2 8 .9 
4 0 .7 
5 4 .8 
7 2 .0 
9 0 .2 

Min LCP 
RepMaestro (without text buffering) 
4 
3 8 .7 
9 5 .8 
158.3 
266.7 
381.0 
530.4 
688.4 
939.7 
8 
3 0 .6 
7 8 .3 
125.6 
207.7 
303.7 
420.7 
540.0 
846.1 
16 
17.7 
4 3 .1 
7 5 .1 
140.2 
195.4 
265.1 
342.1 
445.0 
32 
11.4 
2 5 .2 
4 2 .0 
6 9 .1 
9 9 .9 
126.9 
164.2 
210.7 

brevity). The results are shown in </table></figure>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="1"> http://hgdownload.cse.ucsc.edu/goldenPath/hg19/bigZips/hg19.2bit.</note>

			<note place="foot" n="2"> www.seqan.de/. processing also prompts efficient use of CPU cache, further boosting performance. Since the alphabet size is only 4 characters and that only one local maxima is buffered at any given time, memory consumption remains bounded. In this case, a local maxima that is a supermaximal repeat can have a cardinality of at most 4. As a result, the amount of memory consumed by RepMaestro for detecting supermaximal repeats is tiny. In practice, memory consumption will typically fluctuate by potentially several hundred megabytes, as a result of the SLB prefetch buffer, which is bounded and configurable in size (see Supplementary Material). Thus, RepMaestro, unlike Vmatch, does not require space in proportion the genome sequence size processed, making RepMaestro is an attractive solution for both high-and low-end computer systems. 4.2 MuMs We now investigate the performance of Vmatch and RepMaestro in detecting MuMs using our five MuM datasets shown in Table 1. The time required to find all MuMs with an LCP ≥ 30 is shown in Table 3. We also provide results for an LCP ≥ 15 in Supplementary Material. As observed with our previous experiments involving supermaximal repeats, RepMaestro is faster and importantly, more scalable than Vmatch as a result of its single linear scan of an SLB array. Considering chr10#chr11, which is our largest MuM sequence (262.4 Mbp), RepMaestro is over an order of magnitude faster than both Vmatch and MUMmer, and is shown to be a scalable solution with linear processing time. In this experiment, Vmatch and MUMmer also incur a performance overhead as a result of the mandatory requirement (to the best of our knowledge) of first processing the required indexes in-memory prior to computing any MuMs. Thus, our results provide a strong indication that RepMaestro is indeed a superior and scalable solution to Vmatch for finding MuMs. As discussed with our supermaximal experiments, memory usage is small and bounded in size, but in practice, it can fluctuate by potentially several hundred megabytes as a result of SLB prefetch (see Supplementary Material). 4.3 Pairwise branching tandem repeats We now investigate the performance of Vmatch and RepMaestro to detect pairwise branching tandem repeats or just tandem repeats (for</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Replacing suffix trees with enhanced suffix arrays</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">I</forename>
				<surname>Abouelhoda</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="53" to="86" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title level="m" type="main">Enhanced Suffix Arrays and Applications</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">I</forename>
				<surname>Abouelhoda</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>CRC Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="3389" to="3402" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title/>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">A</forename>
				<surname>Benson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="21" to="25" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Tandem repeats finder: a program to analyze DNA sequences</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Benson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="573" to="580" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">A software program combining sequence motif searches with keywords for finding repeats containing DNA sequences</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Bilgen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="3379" to="3386" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Improved gapped alignment in BLAST</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Cameron</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="116" to="129" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">An applications-focused review of comparative genomics tools: capabilities, limitations and future challenges</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Chain</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="105" to="123" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Fast algorithms for large-scale genome alignment and comparison</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">L</forename>
				<surname>Delcher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="2478" to="2483" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Better external memory suffix array construction</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Dementiev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM J. Exp. Algorithmics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<monogr>
		<title level="m" type="main">Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">mKESA: enhanced suffix array construction tool</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Homann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1084" to="1085" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Space-economical algorithms for finding maximal unique matches</title>
		<author>
			<persName>
				<forename type="first">W.-K</forename>
				<surname>Hon</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Sadakane</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Symposium on Combinatorial Pattern Matching</title>
		<meeting>the Annual Symposium on Combinatorial Pattern Matching<address><addrLine>Fukuoka, Japan ; London, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="17" to="29" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Human Repetitive Elements, in Encyclopedia of</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Jurka</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">A</forename>
				<surname>Batzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Molecular Biology and Molecular Medicine</title>
		<imprint>
			<publisher>VCH Publishers</publisher>
			<biblScope unit="volume">3</biblScope>
			<date type="published" when="1996" />
			<publisher>VCH Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">) mreps: efficient and flexible detection of tandem repeats in DNA</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Kolpakov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="3672" to="3678" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<monogr>
		<title level="m" type="main">Vmatch: large scale sequence analysis software</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
		<editor>www.vmatch.de</editor>
		<imprint>
			<date type="published" when="2008-09" />
		</imprint>
	</monogr>
	<note>last. accessed date</note>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Reputer: the manifold applications of repeat analysis on a genomic scale</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="4633" to="4642" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Versatile and open software for comparing large genomes</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">A new method to compute k-mer frequencies and its application to annotate large repetitive plant genomes</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genomics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1" to="18" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">An efficient algorithm for identifying matches with errors in multiple long molecular sequences</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Leung</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">221</biblScope>
			<biblScope unit="page" from="1367" to="1378" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Searching for supermaximal repeats in large DNA sequences</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">N</forename>
				<surname>Lian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Conference on Bioinformatics Research and Development</title>
		<meeting>the 2nd International Conference on Bioinformatics Research and Development<address><addrLine>Vienna, Austria ; Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="87" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<monogr>
		<title level="m" type="main">Human Genetics: The Molecular Revolution</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">H</forename>
				<surname>Mcconkey</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>Jones and Bartlett Publishers</publisher>
			<pubPlace>40 Tall Pine Drive Sudbury, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Reducing space requirements for disk resident suffix arrays</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Moffat</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Database Systems for Advanced Applications</title>
		<meeting>the Database Systems for Advanced Applications<address><addrLine>Brisbane, Australia ; Berlin/Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="730" to="744" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Genome-scale disk-based suffix tree indexing</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Phoophakdee</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Zaki</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data<address><addrLine>Beijing, China ; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="833" to="844" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Improving suffix array locality for fast pattern matching on disk</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Sinha</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM SIGMOD International Conference on Management of Data</title>
		<meeting>the ACM SIGMOD International Conference on Management of Data<address><addrLine>Vancouver, Canada ; New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="661" to="672" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<monogr>
		<title level="m" type="main">Evolutionary Genetics</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">M</forename>
				<surname>Smith</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Oxford University Press</publisher>
			<pubPlace>NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<monogr>
		<title level="m" type="main">Computing Patterns in Strings</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Smyth</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<monogr>
		<title level="m" type="main">Molecular Biology of the Gene</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Watson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1987" />
			<pubPlace>Benjamin Cummings, Menlo Park, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Indexing and retrieval for genomic databases</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">E</forename>
				<surname>Williams</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Zobel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowledge Data Eng</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="63" to="78" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>