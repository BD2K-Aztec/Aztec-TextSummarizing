
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">EPGA2: memory-efficient de novo assembler</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Junwei</forename>
								<surname>Luo</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>ChangSha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">College of Computer Science and Technology</orgName>
								<orgName type="institution">Henan Polytechnic University</orgName>
								<address>
									<postCode>454000</postCode>
									<settlement>JiaoZuo</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Jianxin</forename>
								<surname>Wang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>ChangSha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Weilong</forename>
								<surname>Li</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>ChangSha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Zhen</forename>
								<surname>Zhang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>ChangSha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Fang-Xiang</forename>
								<surname>Wu</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Division of Biomedical Engineering</orgName>
								<orgName type="institution">University of Saskatchewan</orgName>
								<address>
									<postCode>S7N 5A9</postCode>
									<settlement>Saskatchewan</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Min</forename>
								<surname>Li</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>ChangSha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yi</forename>
								<surname>Pan</surname>
							</persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Georgia State University</orgName>
								<address>
									<postCode>30302</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">EPGA2: memory-efficient de novo assembler</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btv487</idno>
					<note type="submission">Received and revised on June 19, 2015; accepted on August 13, 2015</note>
					<note>Genome analysis *To whom correspondence should be addressed. Associate Editor: John Hancock Availability and implementation: EPGA2 is publicly available for download at https://github.com/ bioinfomaticsCSU/EPGA2. Contact: jxwang@csu.edu.cn Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: In genome assembly, as coverage of sequencing and genome size growing, most current softwares require a large memory for handling a great deal of sequence data. However, most researchers usually cannot meet the requirements of computing resources which prevent most current softwares from practical applications. Results: In this article, we present an update algorithm called EPGA2, which applies some new modules and can bring about improved assembly results in small memory. For reducing peak memory in genome assembly, EPGA2 adopts memory-efficient DSK to count K-mers and revised BCALM to construct De Bruijn Graph. Moreover, EPGA2 parallels the step of Contigs Merging and adds Errors Correction in its pipeline. Our experiments demonstrate that all these changes in EPGA2 are more useful for genome assembly.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Genome assembly is one of the most important tasks in numerous applied fields (<ref type="bibr" target="#b2">He et al., 2013</ref>). When using one software to reconstruct complete genome sequence from sequence data, researchers not only emphasize assembly results but also memory efficiency. Although many softwares have been developed for genome assembly, their balance between accuracy and memory efficiency are not satisfactory due to complex data structures. We previously published EPGA (<ref type="bibr" target="#b5">Luo et al., 2015</ref>), one de novo assembler which can resolve some problems caused by complex repetitive sequence regions. Although EPGA can get satisfactory assembly results, it does not have advantage about peak memory comparing with other popular assemblers. The bottleneck of EPGA's memory efficiency primarily exists in two steps: K-mers Counting and De Bruijn Graph Constructing, because EPGA requires that all reads and K-mers reside in memory. Such storage strategy ends up with the memory consumption growing dramatically as the number of reads is increasing. DSK (<ref type="bibr" target="#b7">Rizk et al., 2013</ref>) is one K-mer counting tool which partitions reads, and each partition is separately loaded in memory. BCALM (<ref type="bibr" target="#b1">Chikhi et al., 2014</ref>) is one algorithm for building simple paths in De Bruijn Graph which clusters K-mers and iteratively loads each cluster in memory. For resolving memory problem in EPGA, we present EPGA2, which replaces some components in EPGA with DSK and BCALM. In addition, EPGA2 adds Errors Correction in its pipeline and parallels the step of Contigs Merging. The experimental results demonstrate that EPGA2 can produce more satisfactory contigs and scaffolds using small memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head><p>The EPGA2 pipeline consists of seven steps: (i) Errors Correction: there will usually be some errors in sequencing data, EPGA2 adopts</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Experiment</head><p>We evaluate the performance of EPGA2 on four real datasets which include two bacteria (Staphylococcus aureus and Escherichia coli) and two fungi (Schizosaccharomyces pombe and Neurospora crassa) provided by AllPath2 (<ref type="bibr" target="#b6">MacCallum et al., 2009</ref>). Details about these real datasets are shown in Supplementary Table S1. We compare EPGA2 with other popular assemblers: Abyss (<ref type="bibr" target="#b9">Simpson et al., 2009</ref>), Velvet (<ref type="bibr" target="#b10">Zerbino and Birney, 2008</ref>), SOAPDenvo2 (<ref type="bibr" target="#b4">Luo et al., 2012</ref>), PE-Assembly (<ref type="bibr" target="#b0">Ariyaratne and Sung, 2011</ref>) and AllPath2. To provide unbiased benchmarks, we use evaluation tool GAGE (<ref type="bibr" target="#b8">Salzberg et al., 2012</ref>) which provides corrected analysis. GAGE splits contigs and scaffolds at every error position and provides corrected results. CN50 is N50 of corrected contigs or scaffolds. Assembly results are listed in<ref type="figure" target="#tab_1">Table 1</ref>, and the explicit results are listed in Supplementary Tables S2â€“S5. We can get that EPGA2 offers substantial improvements over the original EPGA. CN50 usually can represent the accuracy of assembly results, EPGA2 gets longer S.CN50 in all real datasets. For coverage, EPGA2 mostly acquires higher coverage than EPGA for contigs and scaffolds. The improvements are caused by adding Errors Correction step which enhances the function of assembly strategies in EPGA. For the four genomes, EPGA2 only requires 0.9G, 1.7 G, 6.1 G and 15 G memory for assembly which are smaller than EPGA and other popular assemblers. This improvement is due to partition strategies of DSK and BCALM which partition reads and K-mers, and each partition is separately loaded in memory. EPGA2 parallels the step of Contigs Merging which can save time, especially for large datasets. Because the first three datasets are relatively small and the decrease of running time in Contigs Merging is smaller than the increase of running time about BLESS, EPGA2 runs longer time than EPGA in the three datasets. Paralleling Contigs Merging can save more time for large datasets, and therefore EPGA2 runs shorter time than EPGA for the last dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusion</head><p>In this article, to resolve the memory efficiency problem in EPGA, we present EPGA2, which updates some modules in EPGA. In addition, for reducing running time, EPGA2 parallels Contigs Merging. For improving accuracy of assembly results, EPGA2 adds Errors Correction using BLESS. The experimental results demonstrate the balance between assembly results and memory efficiency of EPGA2 is satisfactory. EPGA2 should be particularly appropriate for researchers with limited computing resources.C.Num, the number of contigs; C.CN50, the CN50 of contigs; C.Cov, the coverage of contigs; S.Num, the number of scaffolds; S.CN50, the CN50 of scaffolds; S.Cov, the coverage of scaffolds; time, running time; PM, peak memory. Last column is the smallest peak memory and corresponding assembler about other popular assemblers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>EPGA2</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>First, errors in reads usually cause erroneous edges and lead to lost correct edges in De Bruijn Graph, which increases the difficulty of Contig Assembly. EPGA directly employs raw read libraries to count K-mers and construct De Bruijn Graph which increases the difficulty of the following steps. To improve the correctness of De Bruijn Graph and facilitate the following steps, EPGA2 adds correction step using BLESS. Second, when counting K-mers, EPGA uses a hash table, where keys are the K-mers and the values are the counts. This simple strategy needs large memory. EPGA2 employs DSK to count K-mers and (K Ã¾ 1)-mers, which only requires a fixed user-defined amount of memory. EPGA2 only keeps solid K-mer whose frequency is larger than one and solid (K Ã¾ 1)-mer whose frequency is larger than zero. EPGA loads all reads in memory to construct De Bruijn Graph which requires too much memory. When using BCALM to generate simple paths, EPGA2 introduces one additional condition that each edge in De Bruijn Graph should be one solid (K Ã¾ 1)-mer. After simple paths created by this revised BCALM, EPGA2 transforms these simple paths to optimized De Bruijn Graph (each simple path is merged to one node and each tip is removed). In this step, the memory will be reduced more effectively. Thirdly, EPGA2 parallels the procedure of Contigs Merging.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>V C The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 3988 Bioinformatics, 31(24), 2015, 3988â€“3990 doi: 10.1093/bioinformatics/btv487</figDesc><table>Advance Access Publication Date: 26 August 2015 
Applications Note BLESS (Heo et al., 2014) to correct errors in reads. (ii) K-mers 
Counting: DSK is applied to count K-mers. (iii) De Bruijn Graph 
Constructing: the De Bruijn Graph is constructed based on the 
K-mers produced previously. (iv) Contigs Assembly: EPGA2 selects 
long nodes (whose lengths longer than insert size) in De Bruijn 
Graph as start nodes and iteratively determines their successor nodes 
and precursor nodes according to one scoring function. (v) Contigs 
Merging: one contig will be removed if it is included in another 
contig. Two contigs can be merged together if they have overlap and 
get sufficient support from paired-end reads information. 
(vi) Scaffolding: the orientation and order of contigs are determined 
using paired-end reads. (vii) Gap Filling: the gap regions will be 
filled by mate reads of reads in the ends of contigs. 
The EPGA2 includes several improvements relative to EPGA. 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>This work was supported in part by the National Natural Science Foundation of China under Grant No. 61232001, No. 61420106009, No. 61379108 and the Program for New Century Excellent Talents in University under Grant NCET-12-0547. Conflict of interest: none declared.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 1.</figDesc><table>Assembly results 

EPGA 
EPGA2 
Assemblers 

Genome C.Num C.CN50 C.Cov S.Num S.CN50 S.Cov Time PM C.Num C.CN50 C.Cov S.Num S.CN50 S.Cov Time PM 
PM 
(kb) 
(%) 
(kb) 
(%) (m) (G) 
(kb) 
(%) 
(kb) 
(%) (m) (G) 
(G) 
S.aureus 
22 
220 
99.68 
5 
597 
99.69 
15 
9 
28 
189 
99.66 
7 
753 99.68 
35 0.9 2.6 (Abyss) 
E.coli 
38 
198 
99.98 
19 
823 
99.98 
40 28 
33 
184 
99.98 
9 
1379 99.99 
89 1.7 5.3 (Abyss) 
S.pombe 
334 
70 
98.44 
103 
495 
98.47 261 97 
355 
70 
98.73 
116 
743 98.75 342 6.1 6.6 (Abyss) 
N.crassa 6206 
10 
90.08 4651 
21 
90.14 2830 198 5711 
11 
91.11 3632 
39 91.11 1721 15 25.6 (Abyss) 

</table></figure>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">PE-assembler: de novo assembly using short paired end reads</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ariyaratne</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">K</forename>
				<surname>Sung</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="167" to="174" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">On the representation of de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Chikhi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RECOMB</title>
		<editor>Sharan,R.</editor>
		<meeting><address><addrLine>Pittsburgh</addrLine></address></meeting>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="35" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">De novo assembly methods for next generation sequencing data</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>He</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Tsinghua Sci. Technol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="500" to="514" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">BLESS: bloom filter-based error correction solution for high-throughput sequencing reads</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Heo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1354" to="1362" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">SOAPdenovo2: an empirically improved memory-efficient short-read de novo assembler</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Luo</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">EPGA: de novo assembly using the distributions of reads and insert size</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Luo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="31" to="825" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">ALLPATHS 2: small genomes assembled accurately and with high continuity from short paired reads</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Maccallum</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">103</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">DSK: k-mer counting with very low memory usage</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Rizk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="652" to="653" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">GAGE: a critical evaluation of genome assemblies and assembly algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">ABySS: a parallel assembler for short-read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short-read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>