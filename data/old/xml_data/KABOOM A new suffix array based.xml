
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sequence analysis KABOOM! A new suffix array based algorithm for clustering expression data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011">2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName>
								<forename type="first">Scott</forename>
								<surname>Hazelhurst</surname>
							</persName>
							<email>scott.hazelhurst@wits.ac.za</email>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Wits Bioinformatics</orgName>
								<orgName type="department" key="dep2">School of Electrical and Information Engineering</orgName>
								<orgName type="institution">University of the Witwatersrand</orgName>
								<address>
									<addrLine>Private Bag 3</addrLine>
									<postCode>2050</postCode>
									<settlement>Johannesburg, Wits</settlement>
									<country key="ZA">South Africa</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Zsuzsanna</forename>
								<surname>Lipták</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Dipartimento di Informatica</orgName>
								<orgName type="institution">Università degli Studi di Salerno</orgName>
								<address>
									<addrLine>Via Ponte don Melillo, 1</addrLine>
									<postCode>84084</postCode>
									<settlement>Fisciano</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sequence analysis KABOOM! A new suffix array based algorithm for clustering expression data</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">27</biblScope>
							<biblScope unit="issue">24</biblScope>
							<biblScope unit="page" from="3348" to="3355"/>
							<date type="published" when="2011">2011</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btr560</idno>
					<note type="submission">Received on June 15, 2011; revised on August 26, 2011; accepted on September 20, 2011</note>
					<note>[10:29 16/11/2011 Bioinformatics-btr560.tex] Page: 3348 3348–3355 Associate Editor: John Quackenbush/p/wcdest. Runs on Linux and MacOS X. Contact: Supplementary Information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Second-generation sequencing technology has reinvigorated research using expression data, and clustering such data remains a significant challenge, with much larger datasets and with different error profiles. Algorithms that rely on all-versus-all comparison of sequences are not practical for large datasets. Results: We introduce a new filter for string similarity which has the potential to eliminate the need for all-versus-all comparison in clustering of expression data and other similar tasks. Our filter is based on multiple long exact matches between the two strings, with the additional constraint that these matches must be sufficiently far apart. We give details of its efficient implementation using modified suffix arrays. We demonstrate its efficiency by presenting our new expression clustering tool, wcd-express, which uses this heuristic. We compare it to other current tools and show that it is very competitive both with respect to quality and run time. Availability: Source code and binaries available under GPL at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The clustering of expressed sequence tags (ESTs) and other gene expression data continues to be a major challenge in bioinformatics. The emergence of new sequencing technologies such as pyrosequencing, collectively referred to as second-generation sequencing (<ref type="bibr" target="#b15">Pop and Salzberg, 2008;</ref><ref type="bibr" target="#b21">Robison, 2010</ref>), has recently reinvigorated studies using expression data. Second-generation sequencing provides the opportunity to study the transcriptomes of organisms for which good quality genomes are not known. However, new computational challenges have emerged, with much larger datasets, shorter sequence length and new error profiles (<ref type="bibr" target="#b22">Schwartz and Waterman, 2009</ref>). In expression clustering, we start with a large set of cDNA sequences, typically 10 5 or more, which have been derived from transcriptomic data in a laboratory process (commonly, these sequences are referred to as ESTs). The goal is to find a partitional clustering such that sequences derived from the same gene are * To whom correspondence should be addressed. members of the same cluster. Expression clustering can broadly be divided into two classes: (i) clustering for which a reference genome is known (supervised clustering) and (ii) clustering for which a reference genome is not known (also called ab initio or de novo clustering). In this article, we focus on the latter class. Typically, single linkage clustering is used for expression data: if two sequences are similar, their clusters are merged. Within this approach, different similarity measures can be used. Traditionally, edit distance/alignment has been used to define similarity between sequences. However, alignment-free measures are increasingly being adopted, such as q-gram distance (<ref type="bibr" target="#b25">Ukkonen, 1992</ref>) or d 2 (<ref type="bibr" target="#b24">Torney et al., 1990</ref>). These define similarity between sequences with respect to the multiplicity of substrings (subwords) of a fixed, usually small, length. Because of effects such as alternative splicing, in expression clustering typically a local similarity of a predefined length is sought. For two sequences of length m to be regarded as similar, it suffices to find a pair of similar windows. Using subword-based measures, it is possible to compute the maximum similarity between all pairs of windows of a fixed length in time O(m 2 ) [similarly, computation of an optimal local alignment score takes O(m 2 ) time]. EST clustering algorithms that use subword-based distance measures rather than alignment methods have proved successful (<ref type="bibr" target="#b7">Kalyanaraman et al., 2002;</ref><ref type="bibr" target="#b12">Miller et al., 1999</ref>). However, with the new and much larger datasets, computation time is still an issue: given n EST sequences, with average length m, computing all pairwise similarities requires (n 2 m 2 ) time. For real datasets this is prohibitive, at least without massive parallelism. Much work has gone into breaking these complexity limits. Filtering heuristics have been very successful. They test two strings in linear time to see whether they are likely to be similar, before a more expensive comparison is done. In practice, these heuristics have sped up clustering by orders of magnitude. However, the algorithms still remain quadratic in the number of sequences. In this article, we introduce the KABOOM filter, which greatly reduces the number of candidate pairs without compromising on clustering quality. This heuristic passes a pair of sequences if they share a given number of common words (substrings) of a given length, occurring at least a given distance apart. We also give details of its efficient implementation, which uses a modified suffix array. Contribution: our contribution is 2-fold:</p><p>(1) We introduce a new heuristic filter for sequence similarity.Page: 3349 3348–3355</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>KABOOM</head><p>(2) We demonstrate a method which, at least for real-world data, implements this heuristic and eliminates the need for all-versus-all comparison.</p><p>The computation of our heuristic runs in time which depends on the multiplicities of words of the given length within the set to be clustered. Although in the worst case, the computation of our heuristic could take quadratic time in n, the number of sequences, the cost on real-life data is significantly subquadratic. On the other hand, the filtration rate of the KABOOM heuristic is impressive: on all our experimental data, the number of pairwise comparisons was reduced to far below 1%. We present extensive experimentation results which show how the KABOOM heuristic has sped up our previous EST clustering tool, wcd (), without compromising clustering quality. wcd uses the subword based dissimilarity measure d 2 to cluster sequences, shown to be competitive with or even superior to many existing tools, both with respect to running time and clustering quality (), where we reported comparison studies with ESTate (<ref type="bibr" target="#b23">Slater, 2000</ref>), xsact (<ref type="bibr" target="#b9">Malde et al., 2003</ref>), PaCE (<ref type="bibr" target="#b7">Kalyanaraman et al., 2002</ref>) and the assembler tool CAP3 (<ref type="bibr" target="#b5">Huang and Madan, 1999</ref>). Here, we compare our new tool, called wcd-express, to wcd and to two other EST clustering tools, TGICL (<ref type="bibr" target="#b13">Pertea et al., 2003</ref>) and the recent tool PEACE (<ref type="bibr" target="#b18">Rao et al., 2010</ref>), which claims to have better performance than wcd. wcd-express outperforms them both with respect to run time and produces at least as good quality. We show applicability to Sanger style data as well as to 454 and Illumina data (second-generation sequencing). We believe that the new filter has the potential to achieve similar speedups for other tools which rely on pairwise comparison of a set of sequences. Related work: EST clustering tools based on common words include PaCE (<ref type="bibr" target="#b7">Kalyanaraman et al., 2002</ref>), xsact (<ref type="bibr" target="#b9">Malde et al., 2003</ref>), QUASAR (<ref type="bibr" target="#b0">Burkhardt et al., 1999</ref>), more recently our tool wcd () and PEACE (<ref type="bibr" target="#b18">Rao et al., 2010</ref>). Several of these use suffix trees or suffix arrays for finding common words. PaCE and wcd both explore a heuristic of finding candidate matches based on a shared common word to avoid all-versus-all comparison. The basic idea is to choose a length k and to do a full comparison only on those pairs of sequences that share at least one word of length k. These pairs can be found efficiently using a suffix array or suffix tree, which allows to identify all sequences that contain a given k-word. The KABOOM heuristic adapts this idea to sequence pairs which share several exact matches. Our approach is closest to that of xsact (<ref type="bibr" target="#b9">Malde et al., 2003</ref>), which also uses multiple common words as a criterion for similarity. Unlike in KABOOM, xsact uses variable size common words, which must occur in the same order in both strings. However, the biggest difference is in the implementation. The authors only report results on one fairly small dataset; in our earlier work, we found the tool was very slow on large sets, and it did not scale (). This article shows how a related approach can be efficiently implemented and integrated in a well-established EST clustering system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>We start with some formal definitions. A string (or word or sequence) over a finite alphabet is a finite sequence s = s 1 ...s n of characters from ={A,C,G,T }. * is the set of all strings over. For a string s = s 1 ...s n ∈ * , we denote by |s| its length n. For two strings s,w ∈ * , where s = s 1 ...s n and w = w 1 ...w k , w is a substring, or subword of s, denoted w s, if there exists an index 1 ≤ i ≤ n such that s i ...s i+k−1 = w 1 ...w k. Such an index i is called an occurrence of w in s. A string of length k is also referred to as a k-word.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Clustering based on pairwise string similarity</head><p>Given a set S of strings over {A,C,G,T } (sequences derived from expression data), we want to find a clustering, i.e. a partition, of S such that two sequences end up in the same cluster if and only if they have been derived from the same gene. Since it is difficult to detect when two sequences have been derived from the same gene, we formally state our problem as: Problem statement (Expression Clustering). Given a set S of sequences over the alphabet ={A,C,G,T }, compute a clustering C ={C 1 ,...,C r } of S such that (i) r i=1 C i = S, and for i = j, C i ∩C j = ∅; and (ii) for all s,t ∈ S, if s and t are similar according to the given similarity or dissimilarity measure, then s and t are in the same cluster. This is the definition for ab initio, partitional, single-linkage clustering. For definitions of other types of clustering, see e.g. (<ref type="bibr" target="#b6">Jain et al., 1999</ref>). Condition (i) states that C is a partition of S. Dissimilarity measures commonly used for string comparison in EST clustering include the edit distance (<ref type="bibr" target="#b8">Levenshtein, 1966</ref>), q-gram distance (<ref type="bibr" target="#b25">Ukkonen, 1992</ref>) and d 2 (<ref type="bibr" target="#b24">Torney et al., 1990</ref>). Usually, one decides on a threshold θ ∈ R + , and then two sequences s,t are said to be similar if d(s,t) ≤ θ, where d is the dissimilarity measure. In our tool, we use the dissimilarity measure d 2. We denote by mult(w,s) the number of occurrences of the word w in s. Definition 2.1 (Windowed d 2 ). Let s,t ∈ * , Let q (the word size) and λ (the window length) be two positive integers. Then d 2 (s,t) = min{ w∈ q mult(w,s )−mult(w,t ) 2 : s s,t t,|s |=|t |=λ}.</p><p>For a string x, let mult q (x) denote the vector of length || q containing the multiplicities of all q-words in x, for some fixed enumeration of q. If |s|=|t|=λ, then d 2 (s,t) is the Euclidean distance squared (hence the name) of mult q (s) and mult q (t). In general, the two sequences s and t need not have the same length. When at least one of the two strings s,t is shorter than λ, then the parameters θ and λ are scaled accordingly. The measure d 2 has been shown to be well suited for Sanger-style expression clustering (<ref type="bibr" target="#b12">Miller et al., 1999</ref>), using q = 6 as word size. This article and that of (<ref type="bibr" target="#b18">Rao et al., 2010</ref>) are the only ones to have examined the use of d 2 with second-generation data. A closely related dissimilarity measure employed for EST clustering is the q-gram distance (<ref type="bibr" target="#b0">Burkhardt et al., 1999;</ref><ref type="bibr" target="#b25">Ukkonen, 1992</ref>), defined as d q−gr (s,t) = w∈ q |mult(w,s)−mult(w,t)|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Filters based on common words</head><p>Because edit distance or windowed d 2 is quadratic in the length of the two strings, often filters are used: a similarity relation that the pair is first checked for before d(s,t) is computed. Our previous tool, wcd, uses the H-filter. It passes two words s,t if they have a certain number of q−words in common. For reasons</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S.Hazelhurst and Zs.Lipták</head><p>of efficient implementation, the word count is asymmetric: if a word appears x times in s and y times in t, then we add y to the count. Definition 2.2 ((H,q)-Similarity). Let H,q be positive integers. For s,t ∈ * , we say that t is (H,q)-similar to s if it has at least H occurrences of the q-words that are substrings of s [i.e. if ws,|w|=q mult(w,</p><formula>t) ≥ H].</formula><p>Typically, q ≈ 6, H ≈ 70. This similarity relation is asymmetric, as the common substrings of s and t are counted with their multiplicity in t (and not in s). For the right choice of H, the (H,q)-filter is a true, non-heuristic filter for d 2 , as stated in the following lemma. The proof can be found in the Supplementary Material. Lemma 1. Let q,θ and λ be given. Set H = λ−q+1−θ/2. If d 2 q (s,t) ≤ θ, then s is (H,q)-similar to t, t is (H,q)-similar to s.</p><p>This filter has probably good performance. Its computation is linear in the length of s and t; however, every pair has to be inspected separately. Therefore, this filter has (n 2 m) run time. In an attempt to avoid an all-versus-all comparison,<ref type="bibr" target="#b7">Kalyanaraman et al. (2002)</ref>use variants of the k-word similarity filter: Definition 2.3 (k-Word Similarity). Let k be a positive integer. For s,t ∈ * , we say that s and t are k-word-similar if they have at least one substring of length k in common.</p><p>The k-word filter can be implemented efficiently using a suffix array. Its fundamental problem is the choice of k. If k is too large, then many pairs with high similarity will be missed; if k is too small, then a quadratic number of candidate pairs will be found. The heuristic is particularly sensitive to the sequence error rate—as it increases, the largest common word that two sequences must share in order to approximately match becomes smaller. In our previous work, we found setting k = 27 was reasonably effective for many datasets. But the approach was fragile: for some datasets, k = 27 was too big (particularly for shorter sequences) or too small (particularly for sequences with repeats). We now introduce the KABOOM filter, which is an extension of the k-word filter, and combines its efficient implementation with the good filtering properties of the H-filter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The KABOOM filter</head><p>The idea behind the (k,α,β)-multiword filter (pronounced KABOOM) is to generalize the k-word approach: rather than requiring that two sequences share a relatively long common word, we require that they share several shorter common words. We claim that this has two advantages (which we substantiate through experimentation later): using multiple words allows us to test for longer regions of high similarity rather than short regions of exact similarity; and this is more likely to be biologically relevant. While we present the KABOOM filter in the context of using the d 2 dissimilarity measure and the wcd tool, the filter could in principle be used by any clustering algorithm. The KABOOM filter defines a pair of sequences to be similar if they share a fixed number α of common words (substrings) of a fixed length k, and in addition, the first and the last must occur at least a fixed distance β apart. This last condition is introduced in order to avoid too many overlapping matches. We shall count the substrings with multiplicities, i.e. if s has x occurrences of w and t has y, then we shall add xy to our count. [This count is known as D 2 in the literature (see e.g.<ref type="bibr" target="#b17">Rahmann and Rivals, 2000;</ref><ref type="bibr" target="#b19">Reinert et al., 2009</ref>), not to be confused with d 2 ]. Note that k refers to the word length used in the KABOOM filter, while q is the length of the word used in the computation of d 2 : typically k &gt; q. Definition 2.4 ((k,α,β)-Multiword Similarity). Let k,α,β be positive integers. For s,t ∈ * , let Common(s,t) ={(i,j) | s i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>..s i+k−1 = t j ...t j+k−1 }</head><p>be the set of pairs of occurrences of common k-words of s and t. We say that s and t are (k,α,β)-similar if</p><p>(1) |Common(s,t)|≥α;</p><formula>(2) ∃ (i 1 ,j 1 ),(i 2 ,j 2 ) ∈ Common(s,t) s.t. i 2 −i 1 ≥ β; and (3) ∃ (i 1 ,j 1 ),(i 2 ,j 2 ) ∈ Common(s,t) s.t. j 2 −j 1 ≥ β.</formula><p>Experiments showed that for Sanger-style data, conservative values of these parameters are k = 16, α = 3, β = 45 (for d 2-threshold of θ = 40), while for 454-type data, conservative values are k = 16, α = 3, β = 16 (for θ = 60): even though we do not have a theoretical guarantee, with these parameters, the filter produces negligibly few false negatives, i.e. pairs (s,t) which are not (k,α,β)-similar but whose d 2 score is below the threshold θ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Symmetric and asymmetric implementation:</head><p>if we drop requirement (3), we get an asymmetric KABOOM-heuristic requiring distance β only in one of the two sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ALGORITHM</head><p>In this section, we detail our algorithm for finding all pairs of sequences that are (k,α,β)-similar. The suffix array of a string s is an array of length |s| which lists the indices i according to the lexicographical order of the suffixes starting at position i (<ref type="bibr" target="#b10">Manber and Myers, 1993</ref>). By the properties of the suffix array, for any non-empty substring w s, all occurrences of w are listed contiguously in the suffix array, as all suffixes prefixed by w are contiguous in the lexicographic order. Let sa be the suffix array of the sequence data. Fix k &gt; 0. A k-block of sa is a maximal subarray of the suffix array where the first k characters of the corresponding entries in the text are equal. We define the modified suffix array to be the array sa such that the indices within each k-block of the suffix array sa are reordered in ascending order, and invs to be the inverse mapping of sa , i.e. invs[sa<ref type="bibr">[i]</ref>] = i. The modified suffix array sa has the following property, whose proof is immediate. Lemma 2. For each w with |w|=k, and every pair of occurrences</p><formula>i = i of w in s, i &lt; i ⇐⇒ invs[i] &lt; invs[i ].</formula><p>As a small example, consider a set of seven sequences: aaa, aacggt, gttaaagt, tcggt, gttat, cgg and acggt. Let k = 3. The sequences are concatenated together (the @ symbol represents a sequence break character) and the suffix array constructed.<ref type="figure" target="#fig_2">Figure 1</ref>gives a detail (lines 15–26) of the suffix array sa (left), the suffix that starts at the corresponding position in the text (centre) and the modified suffix array sa. The Supplementary Material contains the fullEach k-block is ruled-off: e.g. rows 17–20 and 23–25 are kblocks. For clarity, we show all 3-words of the text; however, in the implementation, only those are considered which are substrings of one of the sequences s i , i.e. those that do not contain @. The k-block in our example from positions 17 to 20 inclusive corresponds to all occurrences of the k-word cgg. The array sa stores the elements of this k-block, 32,37,6 and 21, according to the lexicographic order of the corresponding suffixes, while the column sa shows the entries within the block sorted. We create the modified suffix array from the suffix array by scanning through it and re-ordering it, but it could probably be done more efficiently by modifying a suffix array generation algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The algorithm</head><p>An outline of the modified clustering algorithm is shown below. Detailed pseudo-code can be found in Algorithm 1. The main loop of the algorithm considers each sequence s i in turn. While processing sequence s i , we record each sequence s j containing common kwords with s i , where j &gt; i. For each such sequence s j , we compute count<ref type="bibr">[j]</ref>:=|Common(s i ,s j )|, as well as the leftmost and rightmost occurrences of such words in s i and in s j. The variables lindI<ref type="bibr">[j]</ref>and rindI<ref type="bibr">[j]</ref>(lindJ<ref type="bibr">[j]</ref>and rindJ<ref type="bibr">[j]</ref>) store the current leftmost and rightmost positions in s i (s j ) of all common k-word of s i and s j .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>for all</head><formula>sequences s i do M ← ∅ for all words w sequence s i do M ← M ∪{j : j &gt; i,w sequence s j } for all j ∈ M where count(i,j) ≥ α ∧ rindI[j]−lindI[j]≥ β ∧ rindJ[j]−lindJ[j]≥β do if sim(s i ,s j ) then merge(cluster(i),cluster(j))</formula><p>In more detail: when processing sequence s i , we consider each (overlapping) k-word in s i. Let w be a k-word in sequence s i that starts at position r. Using the inverse of the modified suffix array invs, we find where this word occurs in sa , say at position p = invs<ref type="bibr">[r]</ref>. Then we find all occurrences of w in other sequences s j , where j &gt; i, by looking at each entry p &gt; p within the same k-block. By Lemma 2, this gives all occurrences to the right of the current occurrence of w. With this information, we update our records of which sequences s j share a k-word with s i , and also where, in both s i and s j , the leftmost and the rightmost of these common k-words are. Once all k-words in sequence s i have been processed, we know which sequences s j , for j &gt; i, share a k-word with s i , how many kwords are shared and the various leftmost and rightmost positions. Sequence s i is a candidate sequence with each of those sequences satisfying the condition of the KABOOM filter. A small example is given in the Supplementary Material. wcd-express then compares each candidate pair first with the heuristics described by Hazelhurst (2008) and then, if necessary, using d 2. However, any dissimilarity function (such as edit distance) could be used. Note that every pair (s i ,s j ), i &lt; j, is considered only once, namely in the iteration for s i .<ref type="bibr">[p]</ref>,lindJ<ref type="bibr">[j]</ref>); rindJ<ref type="bibr">[j]</ref>← max(sa'<ref type="bibr">[p]</ref>,rindJ<ref type="bibr">[j]</ref>); count<ref type="bibr">[j]</ref>++; {count: # common words of s i and s j } p++; r++; {compute d 2 (s i ,s j ) for j passing filtering phase} for all j ∈ M do if (i,j) are (k,α,β) similar then if d 2 (s i ,s j ) ≤ θ {distance of s i and s j is small} then merge(cluster(i),cluster(j)); reset lindI,rindI,lindJ,rindJ,count,M;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Analysis of algorithm</head><p>Suppose there are n sequences of average length m in set S. For Sanger-style sequencing m may be between 300 and 700. For real datasets n is unlikely to be &lt;10 4 and may be as large as 10 6 (so m &lt; n, and in large datasets m 2 &lt; n). Let k be the word length used in the suffix array algorithm step. Typical values of k will be in the range 12–20. We make the following definitions:The previous version of wcd needs (mn 2 ) time for the heuristics and (cm 2 ) time for computing the d 2 or edit distance of those pairs of sequences that have been passed by the heuristics. In wcdexpress, in the KABOOM-step, for each word w in the file, we do O(η w ) work. Each distinct word w appears η w times, so the total work done is O( |w|=k η w 2 ) = O(γEmn). Another way of looking at this is that there are mn (non-distinct) words, and for each we do γE work on average. wcd-express then applies all of wcd's heuristics on the pairs passed, which run in linear time. Thus, the total amount of work done by wcd-express is (γEmn+c K m+c X m 2 ). Since wcd-express applies all of wcd's heuristics, c X ≤ c. In practice, c ∈ O(n). Thus, provided γE &lt; n, wcd-express will run faster than wcd. However, since the constant factors due to memory behaviour are likely to be substantially larger, for practical purposes, it is important that γE n. The experimental results reported later demonstrate that in practice wcd-express runs substantially faster than wcd and that indeed γE n. For the generation of the suffix array, any of a large number of suffix array construction algorithms can be used, several of which run in linear time. In our current implementation, we use the mkESA tool (<ref type="bibr" target="#b4">Homann et al., 2009</ref>), which employs the DeepShallow algorithm (<ref type="bibr" target="#b11">Manzini and Ferragina, 2004</ref>), one of several super-linear algorithms that have been shown to perform better in practice. See (<ref type="bibr" target="#b16">Puglisi et al., 2007</ref>) for a survey of suffix array construction algorithms. wcd-express requires substantial amount of RAM to store both the suffix array and its inverse: (mnlogmn) amount of RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">IMPLEMENTATION</head><p>The algorithm is implemented as an extension to the wcd clustering tool (). The code is implemented in C. Pre-processing: pre-processing requires building a suffix array of the data file and its reverse complement. We use the mkESA tool (<ref type="bibr" target="#b4">Homann et al., 2009</ref>) to create the suffix array, which suited our needs well and performed excellently. Clustering: the wcd-express program performs clustering as presented in Algorithm 1. However, it is important to note that the call to the d 2 algorithm is preceded by the use of filtering heuristics described in;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>This section compares wcd-express to the previous version of wcd, and to two other systems, TGICL (<ref type="bibr" target="#b13">Pertea et al., 2003</ref>) and PEACE (<ref type="bibr" target="#b18">Rao et al., 2010</ref>), evaluating the impact of the KABOOM heuristic and the overall performance of wcd-express. All experiments were done on an Intel E5335 (2 GHz; dual quadcore processor with 4 MB of L2 cache per processor and 16 GB of RAM; single thread; Scientific Linux 5.4, gcc 4.1.2, O-2 for wcd-express and wcd). We used the asymmetric implementation of wcd-express, which initial experimentation showed was slightly faster (but which is controlled by a compiler-switch).Experimental results on different sets of EST datasets. # seqs is the number of sequences in thousands; size is the number of megabases. E is the average square of the frequency of the distinct words; γ is the ratio of the number of distinct words to the total number of words. wcd-express is the time our new algorithm takes including pre-processing; wcd is the time our previous version of wcd takes. All times in seconds are rounded to the nearest second. For both versions of wcd, the same parameters were used. The sensitivity of wcd-express with respect to wcd is over 0.999 in all cases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Data</head><p>The experiments use both real and synthetic Sanger-style and second-generation data. The data are described in the Supplementary Material. In summary, A686904 is a set of 686904 Arabidopsis thaliana sequences from GenBank, while other datasets of the form Ax are subsets of this; ecHuman is the EasyCluster reference set (<ref type="bibr" target="#b14">Picardi et al., 2009</ref>); chlamy a set of Chlamydomonas reinhardtii sequences used to test PEACE (<ref type="bibr" target="#b18">Rao et al., 2010</ref>). The C-series is a set of synthetic data files, generated using the ESTsim tool (<ref type="bibr" target="#b2">Hazelhurst and Bergheim, 2003</ref>); the metasim files are synthetic files simulating 454 and Illumina style sequences using the tool MetaSim (<ref type="bibr" target="#b20">Richter et al., 2008</ref>).<ref type="figure" target="#tab_1">Table 1</ref>shows the improvement in running time from wcd to wcdexpress, gained by adding the KABOOM filter. We use a number of Sanger-style datasets using the same parameters for both tools. The running times for wcd-express include the generation of the suffix array. In all cases, there is a large speed-up, and the speed-up is larger with larger datasets. Recall from Section 3.2 that the success of the algorithm depends on how γE compares to the number of sequences. As can be seen from<ref type="figure" target="#tab_1">Table 1</ref>, on all our datasets γE is two to three orders of magnitude smaller than n. Next, we explore the impact of the KABOOM filter with different word sizes on the quality of the clustering and running times.<ref type="figure" target="#fig_4">Figure 2</ref>shows the time taken and quality of the clustering of different datasets as the suffix word length k changes, on different data files (both real and synthetic). H is the parameter of the (H,q)-filter (Section 2.2). For quality, we measure sensitivity of the clustering with respect to a base case of suffix array word length of 10 (a very conservative value). The other clustering parameters are chosen extremely conservatively to avoid masking too aggressive values of other parameters. These results show that choosing a suffix word length of 16 does not significantly decrease sensitivity but that for word length at least 12 the running time improves dramatically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Impact of the KABOOM filter</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Quality comparison with other tools</head><p>Given a clustering C of a set S, quality is measured using validity indices, which compare C to a known clustering D. These give a numerical value in the range<ref type="bibr">[0,</ref><ref type="bibr">1]</ref>(1 being best value), in terms of the number of pairs (x,y) which are put into the same cluster by both C and D<ref type="bibr">[</ref><ref type="figure" target="#tab_2">Table 2</ref>compares the running times and quality of wcd-express and PEACE on several datasets with known clusterings (the first three are Sanger-style data, the others second-generation). wcdexpress and PEACE have very similar quality scores, and wcdexpress consistently outperforms PEACE with respect to run-time. A complication in comparison is that PEACE filters out lowcomplexity sequences in a pre-processing step, while the wcd tools do not. Therefore, for<ref type="figure" target="#tab_2">Table 2</ref>we adopt a pre-step before calling wcd-express of filtering out the same sequences that PEACE does. Note that our results differ from those quoted in<ref type="bibr" target="#b18">Rao et al. (2010)</ref>because we adopt a different methodology for dealing with the filtered sequences. See the Supplementary Material for a full discussion. Since TGICL incorporates filtering into its clustering step in a different way, a direct comparison with wcd-express was not possible. However, we note that (<ref type="bibr" target="#b18">Rao et al., 2010</ref>) report a comparison of TGICL with PEACE and with wcd and found the clustering quality to be competitive. The clusterings computed by wcd-express and wcd are essentially the same. Note that the scores for 454 and Illumina data in<ref type="figure" target="#tab_2">Table 2</ref>differ from those reported in (<ref type="bibr" target="#b18">Rao et al., 2010</ref>). The reason is that the default parameters of wcd were optimised for Sanger-style data, while for short read sequences, other values are appropriate. (For details see Supplementary Material.) As shown in our earlier work, the choice of parameters has a very important effect on the quality of the results (<ref type="bibr" target="#b26">Zimmermann et al., 2004</ref>). In most published work, tools are compared based on one set of parameters. This kind of study is limited, since it only proves that with one set of parameters one tool performs better or worse than another tool with its own set of parameters.We stress that it is unlikely that any tool has a set of universally optimal parameters. The range of different sequencing technologies and quality of data means that different modelling parameters will be required to cluster optimally. This makes computational performance more important. A fast tool is very helpful since it gives an experimenter the ability to cluster the same dataset with different parameters and investigate the stability of the clustering with respect to the various parameters. We also ran tests that showed that for reasonable values of k, very high levels of sensitivity can be obtained. For Sanger-style data with k = 16, even for an aggressive θ = 60, wcd-express gives less than a 0.1% FN rate. For 454 data, with k = 14, and aggressive clustering values we get less than a 0.5% FN rate. As expected, performance declines with shorter sequence length; however, second-generation sequence length is increasing as the technology improves.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Computational cost comparisons with other tools</head><p>Memory usage: the use of the suffix array and inverse creates significant memory requirements for wcd-express. The current implementation requires ∼25 bytes of RAM per byte of input so that a 200 MB input file requires ∼5 GB of RAM to run effectively. This makes wcd-express much more expensive than wcd (which required ∼0.3 bytes of RAM per byte of input). TGICL's memory footprint is very small as the input file is broken into chunks. PEACE's memory usage pattern varies. PEACE's usage is 2–10 times less than wcd-express's, with the difference diminishing on larger data (2.1 GB for the 200 MB input file mentioned above). A positive feature of wcd-express's memory usage is that memory is allocated as the data are read in—thus even on a long run, usage will be known after a minute or so. PEACE's memory usage, on the other hand, may increase throughout its execution. The Supplementary Material presents experimental evidence and discusses memory use in more detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Running times</head><p>: the tables and figure below show computational costs of wcd-express, PEACE and TGICL on a variety of data. As discussed, TGICL and PEACE do filtering while wcd-express does not. The Supplementary Material shows that this has a profound effect on quality and performance. If tool A filters and B does not, it may appear that A is faster than B, or vice-versa when the root cause is that the data to be clustered are effectively very different. In the experiments below, we adopt a filtering pre-step for wcd-express.To be fair, we do this differently in the comparisons with TGICL and PEACE, as these tools filter differently (see Supplementary Material for details). We emphasize that the times reported for wcd-express take into account all pre-processing time, including filtering and construction of the suffix array. In<ref type="figure" target="#fig_7">Figure 3</ref>, we show how the running times scale as datasets grow larger. The Arabidopsis data is a set of real ESTs.<ref type="figure" target="#fig_8">Figure 4</ref>shows the difference between wcd-express and TGICL on subsets of Human 454 ESTs of different sizes. See the Supplementary Material for additional experimentation.<ref type="figure" target="#tab_3">Table 3</ref>shows performance of wcd-express on a range of different datasets. In summary, the results show that wcdexpress outperforms PEACE, and for very large datasets does so substantially. wcd-express is also much faster than TGICL. Additional experimentation and more detailed results (including pre-processing costs) are presented in the Supplementary Material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S.Hazelhurst and Zs.Lipták</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION AND FUTURE RESEARCH</head><p>This article has introduced a new algorithm for finding candidate pairs for clustering gene expression data. The idea is that two sequences are candidates for comparison if they share α many common k-words, where the leftmost and rightmost words start at least β away from each other. This heuristic can be implemented very efficiently using a modified suffix array and its inverse. The experimental results show that the algorithm is very effective. For reasonable values of word length, substantial improvement in compute performance is achieved without degradation in quality of clustering. There are a number of areas for future work: Improvement of the algorithm implementation: there is scope for improving the current implementation, using less memory and improving cache behaviour. We currently have an experimental version of our tool that uses about half the amount of memory, with an approximate 15% run-time penalty. Parallelization: at this point, wcd-express is not parallelized (wcd has both pthreads and MPI parallelization). Parallelization should be straightforward, though given the overall cost of pre-processing, for large-scale parallelization, suffix array construction and sequence filtering must both be parallelized. A number of implementations of parallel suffix array construction are available, including in mkESA, which can be used directly. Improving clustering quality: the experiments show that the quality of clustering is very dependent on parameters used. The most important lesson is that in practice, bioinformatists should run their</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Page: 3355 3348–3355</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>KABOOM</head><p>tools several times with different parameters to evaluate the stability of their results. Work is needed to separate out the effect of the parameters used and the underlying algorithms. This is also likely to be affected by the error models of the underlying sequencing technology (e.g. the homopolymer problem for 454 data).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>[10:29 16/11/2011 Bioinformatics-btr560.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.1.</head><figDesc>Fig. 1. Detail of example suffix array and modified suffix array (k = 3).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.2.</head><figDesc>Fig. 2. The effect of word size on the quality and time. The graph on the left shows a set of mouse (Sanger) data and the graph on the right shows the Metasim 454 data. The left y-axis shows time (as a percentage of the time taken when k = 10), and the right y-axis shows sensitivity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.3.</head><figDesc>Fig. 3. Performance on the Arabidopsis dataset series on an Intel E5335 Xeon processor. We compare wcd-express with PEACE and TGICL on separate graphs to make the differences clearer and because different filtering is done by TGICL and PEACE. Note the scales on the y-axes differs. The slight jink in TGICL's performance curve was re-tested several times. (a) PEACE versus wcd and wcd-express. (b) TGICL versus wcd-express.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.4.</head><figDesc>Fig. 4. Comparison of performance wcd-express versus TGICL on subsets of a large set of Human 454 ESTs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>table.</figDesc><table>[10:29 16/11/2011 Bioinformatics-btr560.tex] 

Page: 3351 3348–3355 

KABOOM 

aaa@aacggt@gttaaagt@tcggt@gttat@cgg@acggt@ 
i sa Text from sa[i] 
sa 
15 16 agt@tcggt@gttat@cgg@acggt@ 
16 
16 29 at@cgg@acggt@ 
29 
6 
@ 
t 
g 
g 
c 
a 
@ 
g 
g 
c 
2 
3 
7 
1 
1 
2 
@ 
t 
g 
g 
c 
7 
3 
8 
1 
19 
6 cggt@gttaaagt@t. . . gt@ 
32 
20 21 cggt@gttat@cgg@acggt@ 
37 
4 
3 
@ 
t 
g 
g 
c 
a 
@ 
g 
4 
3 
1 
2 
3 
3 
@ 
t 
g 
g 
c 
a 
@ 
g 
g 
3 
3 
2 
2 
7 
@ 
t 
g 
g 
8 
3 
3 
2 
24 
7 ggt@gttaaagt@t. . . t@ 
22 
25 22 ggt@gttat@cgg@acggt@ 
38 
8 
@ 
t 
g 
9 
3 
6 
2 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Algorithm 1 Algorithm wcd-express (with KABOOM) for i ← 0 to n−1 do r ← 0; M ← ∅; { r: index in string s i } while r ≤ length(s i )−k do p ← invs[r]+1; {p: index in sa'} while (seqnumber[sa'[p]] = i ∧ not(newblock[p])) do p++; {skip further matches within s i } while not(newblock[p]) do j ← seqnumber[sa'[p]]; { j: current sequence} if j ∈ M then lindI[j] ← r; rindI[j] ← r; {first common word between s i and s j seen} M ← M ∪{j}; else rindI[j] ← r; lindJ[j] ← min(sa'</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>c : number of candidate pairs found by wcd. c K : no. of candidate pairs found by the KABOOM filter. c X : number of candidate pairs found by wcd-express, (using the KABOOM filter and all other heuristics). p : number of distinct k-words occurring in S. η w : number of occurrences of the k-word w in S. Page: 3352 3348–3355 S.Hazelhurst and Zs.Lipták γ : p mn , ratio of number distinct words to total number of k-words. (1/γ: average no. occurrences of k-words.) E: 1 p |w|=k η 2 w , ave. of squares of no. of occurrences.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><figDesc>Table 1. Comparison of new and old versions of wcd</figDesc><table>Dataset 
# seqs 
Size 
γE 
wcd-exp 
wcd 
Speed-up 
(k) 
MB 
(s) 
(s) 

A076941 
77 
32 
17 
100 
578 
5.7 
A208 
484 
208 
102 
1240 
23983 
19.3 
C10 
126 
56 
355 
511 
4512 
8.8 
chlamy 
190 
100 
139 
1000 
5989 
6.0 
Drosophila 
25 
86 
68 
184 
1542 
8.4 
ecHuman 
17 
11 
171 
135 
496 
3.7 
pubcot 
30 
17 
34 
65 
222 
3.4 
ricinus 
58 
40 
162 
840 
1518 
1.8 
xen 
233 
137 
63 
855 
9298 
10.8 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>true positives (TP)]; those which C clusters together but D does not [false positives (FP)]; those which neither clusters together [true negatives (TN)]; and those which D clusters together but C does not [false negatives (FN)]. Common indices include sensitivity SE = TP/(TP + FN), positive predictive value PPV = TP/(TP + FP) and the Jaccard index JI = TP/(TP + FN + FP).</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 2. Quality and runtime comparison of wcd-express (column labelled wcd) and PEACE on datasets where an ideal clustering is known</figDesc><table>Sensitivity 
Jaccard Index 
Time (s) 

wcd 
PEACE wcd 
PEACE 
wcd PEACE 

A076941 
0.932 0.930 
0.473 0.477 
100 
951 
chlamy 
0.949 0.949 
0.513 0.513 
907 
8823 
ecHuman 
0.996 0.998 
0.707 0.630 
50 
147 

metasim454 
0.793 0.714 
0.765 0.689 
16 
66 
metasimIllum 0.444 0.368 
0.398 0.364 
19 
1975 

The first three datasets are Sanger style data (average length 500); the second two 
are 454 (average length 240) and Illumina data (average length 60). See text and 
Supplementary Material for details. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="true"><figDesc>Table 3. Running times on different datasets (top part Sanger-style, bottom second-generation)</figDesc><table>Dataset 
No. of 
sequences (K) 

Size 
(Mb) 

Time (s) 

wcd PEACE wcd TGICL 

A076941 
77 
32 
100 
951 
166 
282 
A208 
484 
208 
1078 
36611 1620 
7111 
C10 
126 
56 
135 
1800 
278 
448 
chlamy 
190 
100 
907 
8823 
900 
4577 
droste 
83 
45 
141 
1130 
247 
431 
ecHuman 
17 
11 
50 
147 
115 
233 
pubcot 
30 
17 
43 
124 
85 
150 
ricinus 
58 
40 
783 
923 
555 
1085 
xen 
233 
137 
496 
7032 1065 
2218 

metasim454 
25 
6 
16 
66 
25 
46 
hsub128 
355 
130 
1023 25706 
964 11788 
metaIllum 
150 
9 
19 
1975 
25 
121 
soybean 
882 
173 
1626 167590 4012 39556 
SRR019551 335 
87 
876 21595 3204 63524 

All times rounded to the nearest second. See text for details. 

</table></figure>

			<note place="foot">© The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank F. Cicalese for his help and support, the referees for helpful comments, and Dr D.J. Rao for help with PEACE.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">q-gram based database searching using a suffix array (QUASAR)</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Burkhardt</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Third Annual International Conference on Research in Computational Molecular Biology (RECOMB)</title>
		<meeting>the Third Annual International Conference on Research in Computational Molecular Biology (RECOMB)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1999" />
			<biblScope unit="page" from="77" to="83" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Algorithms for clustering EST sequences: the wcd tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hazelhurst</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">South African Comput. J</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1542" to="1546" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title level="m" type="main">ESTsim: a tool for creating benchmarks for EST clustering algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hazelhurst</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bergheim</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<pubPlace>Johannesburg, S.A</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">An overview of the wcd EST clustering tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hazelhurst</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1542" to="1546" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">mkESA: enhanced suffix array construction tool</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Homann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1084" to="1085" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">CAP3: a DNA sequence assembly program</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Huang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Madan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="868" to="877" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Data clustering: a review</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">K</forename>
				<surname>Jain</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="264" to="323" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Parallel EST clustering</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Kalyanaraman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Conference High Performance Computational Biology</title>
		<meeting>IEEE Conference High Performance Computational Biology</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Binary codes capable of correcting deletions, insertions, and reversals</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Levenshtein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Soviet Phys. Doklady</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="707" to="710" />
			<date type="published" when="1966" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast sequence clustering using a suffix array algorithm</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Malde</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1221" to="1226" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Suffix arrays: a new method for on-line string searches</title>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Manber</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="935" to="948" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Engineering a lightweight suffix array construction algorithm</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="33" to="50" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">A comprehensive approach to clustering of expressed human gene sequence: the sequence tag alignment and consensus knowledge base</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Miller</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1143" to="1155" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">TIGR gene indices clustering tools (TGICL): a software system for fast clustering of large EST datasets</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Pertea</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="651" to="652" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">EasyCluster: a fast and efficient gene-oriented clustering tool for large-scale transcriptome data</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Picardi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">10</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
	<note>Suppl. . 6</note>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Bioinformatics challenges of new sequencing technology</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trends Genetics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="142" to="149" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">A taxonomy of suffix array construction algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">J</forename>
				<surname>Puglisi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="1" to="31" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Exact and efficient computation of the expected number of missing and common words in random texts</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Rahmann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Rivals</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th Annual Symposium Combinatorial Pattern Matching</title>
		<meeting>the 11th Annual Symposium Combinatorial Pattern Matching</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="375" to="387" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">PEACE: parallel environment for assembly and clustering of gene expression</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Rao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="737" to="742" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Alignment-free sequence comparison (I): Statistics and power</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Reinert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1615" to="1634" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">MetaSim – a sequencing simulator for genomics and metagenomics</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Richter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">3373</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Editorial: next generation sequencing</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Robison</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="455" to="456" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">New generations: Sequencing machines and their computational challenges</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">C</forename>
				<surname>Schwartz</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Waterman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Sci. Technol</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="3" to="9" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<monogr>
		<title level="m" type="main">Algorithms for the Analysis of Expressed Sequence Tags</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Slater</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<pubPlace>Cambridge, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<monogr>
		<title level="m" type="main">Computation of d 2 : a measure of sequence dissimilarity (eds) Computers and DNA</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Torney</surname>
			</persName>
		</author>
		<editor>Bell,G. and Marr,T.</editor>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Addison-Wesley</publisher>
			<biblScope unit="page" from="109" to="125" />
			<pubPlace>Boston, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Approximate string-matching with q-grams and maximal matches</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ukkonen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="page" from="191" to="211" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">A method for evaluating the quality of string dissimilarity measures and clustering algorithms for EST clustering</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Zimmermann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 4th IEEE International Symposium BioInformatics and BioEngineering</title>
		<meeting>the 4th IEEE International Symposium BioInformatics and BioEngineering</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Society</title>
		<imprint>
			<biblScope unit="page" from="301" to="309" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>