
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:49+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SA-SSR: a suffix array-based algorithm for exhaustive and efficient SSR discovery in large genetic sequences</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">B</forename>
								<forename type="middle">D</forename>
								<surname>Pickett</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Biology</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">S</forename>
								<forename type="middle">M</forename>
								<surname>Karlinsey</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Biology</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">C</forename>
								<forename type="middle">E</forename>
								<surname>Penrod</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Biology</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">M</forename>
								<forename type="middle">J</forename>
								<surname>Cormier</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Biology</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">M</forename>
								<forename type="middle">T W</forename>
								<surname>Ebbert</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Biology</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">D</forename>
								<forename type="middle">K</forename>
								<surname>Shiozawa</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Biology</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">C</forename>
								<forename type="middle">J</forename>
								<surname>Whipple</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Biology</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">P</forename>
								<forename type="middle">G</forename>
								<surname>Ridge</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Biology</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SA-SSR: a suffix array-based algorithm for exhaustive and efficient SSR discovery in large genetic sequences</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btw298</idno>
					<note type="submission">Received on February 10, 2016; revised on April 21, 2016; accepted on May 4, 2016</note>
					<note>Sequence analysis *To whom correspondence should be addressed. Associate Editor: John Hancock Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Simple Sequence Repeats (SSRs) are used to address a variety of research questions in a variety of fields (e.g. population genetics, phylogenetics, forensics, etc.), due to their high mut-ability within and between species. Here, we present an innovative algorithm, SA-SSR, based on suffix and longest common prefix arrays for efficiently detecting SSRs in large sets of sequences. Existing SSR detection applications are hampered by one or more limitations (i.e. speed, accuracy, ease-of-use, etc.). Our algorithm addresses these challenges while being the most comprehensive and correct SSR detection software available. SA-SSR is 100% accurate and detected &gt;1000 more SSRs than the second best algorithm, while offering greater control to the user than any existing software. Availability and implementation: SA-SSR is freely available at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Simple Sequence Repeats (SSRs), microsatellites, or short tandem repeats (STRs), are tandem repeats of short (often 2–5 bp) nucleotide strings (<ref type="bibr" target="#b3">Madesis et al., 2013</ref>). There are generally 10–100 such repeats at each SSR locus resulting in a DNA segment that is amenable to rapid molecular characterization. Given their repetitive nature, the lengths of SSR loci tend to increase or decrease due to polymerase slippage during DNA replication (<ref type="bibr" target="#b6">Schlotterer and Tautz, 1992</ref>). As a consequence, SSR loci have high mutation rates and frequently generate multiple polymorphic alleles. SSR loci are common in both nuclear and organellar genomes, and when flanked by unique sequence, PCR primers can be readily designed to amplify simple sequence length polymorphisms. SSRs have proven highly useful for a variety of molecular genetic, population genetic and phylogenetic applications because it is simple to genotype them using PCR, and because they are highly polymorphic.</p><p>While SSRs have been extensively characterized in many model species, the expense and effort traditionally required to develop SSRs has limited their use in non-model species. Fortunately, nextgeneration sequencing has enabled researchers to quickly produce large quantities of genomic and/or transcriptomic data for nearly any species. While a high quality genome is still difficult to assemble, there is usually adequate sequence information to identify thousands of unique SSR loci with minimal sequencing. Thus, researchers working in non-model systems need user friendly and customizable bioinformatics algorithms to identify SSR loci. A complete, accurate, characterization of SSRs in non-model systems increases the likelihood researchers are able to identify SSRs where flanking genotyping primers can be designed. SSR differences can be used to differentiate between related species or provide insights into specific phenotypes/adaptations. Finally, since the majority of researchers do not have formal computational training, a V C The Author 2016. Published by Oxford University Press.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1</head><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/4.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com<ref type="bibr">Bioinformatics, 2016</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Bioinformatics Advance Access published June 6, 2016</head><p>straightforward, intuitive application is likely to enable traditional bench/field scientists to use SSRs in their research. Many tools exist to find SSRs with varying degrees of utility, but few tools have both a useful command line interface for scripting and meaningful, parseable output. Identifying SSRs in a sequence is challenging because the search is prohibitive in time and memory requirements. Most existing tools use either an exhaustive, combinatorial search approach or a heuristic approach (<ref type="bibr" target="#b2">Lim et al., 2013</ref>). Exhaustive searches have time complexity that grows exponentially, while heuristic approaches trade comprehensiveness for run time. We developed an algorithm that is both efficient and complete. Conceptually, finding SSRs in a nucleotide sequence is relatively straightforward, but the size of current datasets makes it a substantial challenge. SSR detection in sequence data is a substring operation—a large class of problems common in computer science. Many algorithms and data structures have been developed to reduce the time and space requirements for string operations. The suffix tree boasts linear time and space requirements for generating its representation of the string and can be used to perform many important substring operations in O(n log n) time. After Weiner discovered suffix trees (<ref type="bibr" target="#b8">Weiner, 1973</ref>), McCreight (<ref type="bibr" target="#b5">McCreight, 1976</ref>) and Ukkonen (<ref type="bibr" target="#b7">Ukkonen, 1995</ref>) each simplified it, paving the way for the development of the suffix array (<ref type="bibr" target="#b0">Abouelhoda et al., 2004;</ref><ref type="bibr" target="#b1">Kurtz, 1999;</ref><ref type="bibr" target="#b4">Manber and Myers, 1993</ref>). Suffix arrays have the same properties as suffix trees, but are as many as five times more memory efficient (<ref type="bibr" target="#b1">Kurtz, 1999;</ref><ref type="bibr" target="#b4">Manber and Myers, 1993</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Algorithm</head><p>A suffix array is an array of character positions representing a list of all possible suffixes of a string, ordered lexicographically, and longest common prefix arrays are arrays of the lengths of the longest common prefix of each adjacent suffix in the suffix array. Using suffix and longest common prefix arrays, we designed and implemented a novel algorithm for finding SSRs in a nucleotide sequence in linear (O(n)) time and space. The algorithm makes no distinction between microsatellites or minisatellites—it can find tandem repeats of any length or period size. SSRs are identified by calculating three different parameters, k, r and p from the suffix and longest common prefix arrays, where k equals the length of an SSR repeating unit or period size, r equals the number of times it repeats after the original occurrence, and p equals the position of the first nucleotide of the first period of the SSR (see Supplementary Texts 1 and 2, and Supplementary<ref type="figure">Figure  S1</ref>for a more detailed explanation). SSRs are identified by calculating k, p and r from the suffix and longest common prefix arrays (Supplementary<ref type="figure">Fig. S1C</ref>). Let i equal the index of any entry in the suffix array (except the first position), where SA and LCPA are the suffix and longest common prefix arrays, respectively:</p><formula>k i ¼ jSA i À SA iÀ1 j (1) r i ¼ j LCPA i k i k (2) p i ¼ MINðSA iÀ1 ; SA i Þ (3)</formula><p>If r &gt; 0, an SSR of length k * (r þ 1) exists at position p in the original sequence, otherwise if r ¼ 0 there is no SSR at position p. The base unit (e.g. AG in the SSR AGAGAG) of the SSR starts at position p and ends at position p þ (k À 1). Thus, by comparing each adjacent element in the suffix array we can find SSRs in a sequence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head><p>Our algorithm requires at most 9n bytes of memory, where n is the length of the entire query sequence. For each nucleotide in the sequence, we generously assume one byte in the original sequence (using 8-bit characters), four bytes in the suffix array (using 32-bit integers) and four bytes in the longest common prefix array (using 32-bit integers). The time complexity for building a suffix array and its longest common prefix array is O(n). Our algorithm then requires 3 * (n À 1) constant time computations to find SSRs, thus keeping the total time and space complexities at O(n). We evaluated the performance of our algorithm compared to seven existing applications (see Supplementary<ref type="figure">Table S1</ref>for a list of algorithms) on the Arabidopsis thaliana (chromosome 4), Caenorhabditis elegans, Drosophila melanogaster, Escherichia coli and Zaire ebolavirus genomes (GenBank Accessions: NC_003075.7, GCA_001483305.1, GCA_001014345.1, GCA_001432175.2 and NC_002549.1, respectively), comprised of 13 121 sequences totaling 248 846 830 nucleotides. Sequences ranged in length from 516 to 18 590 000 nucleotides with a median size of 4 662 (Supplementary Figures S2–S6 show a distribution of sequence lengths). Dozens of applications exist for SSR detection. We selected algorithms for comparison that: (i) were capable of processing the Arabidopsis thaliana chromosome (the longest of the sequences), (ii) had a non-interactive, Linux, command-line interface, (iii) were freely available for immediate download and (iv) had 10 or more citations per year or were published in the last three years. Several additional algorithms met our requirements, but used antiquated shared libraries, or had compile/run-time errors. All comparisons were run on a 6-core Intel Haswell Westmere (2.67 GHz) processor with 24 GB of memory (1066 MHz DDR3). SA-SSR, like other algorithms, calls any detected sequence repeat an SSR. Reported numbers and accuracy reflect the assumption that all sequence repeats are SSRs. SA-SSR maximized the number of SSRs identified, while maintaining low memory requirements and runtime, and providing higher flexibility to the user to control desired output (results summarized in<ref type="figure">Table 1</ref>with more detailed results in Supplementary Table S2). We counted the total number of SSRs identified by SA-SSR and each of the algorithms with period sizes one to seven and minimum total length of 16 nucleotides (period sizes and lengths likely to be of most interest in common applications). Next, we determined the accuracy of each of the tested algorithms, including SA-SSR, by writing a script to scan the entire sequence to verify whether or not a reported SSR was present. Most of the tested algorithms, including SA-SSR, were 100% accurate. However, compared to other algorithms, SA-SSR, found the highest number of correct (38 088 SSRs) and unique SSRs (on average &gt;18 000 SSRs more than the other algorithms). MREPS, SSRPipeline and TRF only missed 1340, 3047 and 7423 correct SSRs detected by SA-SSR, respectively. However, TRF was only 23% accurate. Results of algorithm comparisons and software features are summarized in Supplementary Tables S2–S31. Finally, we designed SA-SSR with intuitive features and formatting requirements. Like other SSR detection applications, SA-SSR takes FASTA files as input. However, some of the other applications, including some of those with high performance, are difficult to use. For example, MREPS displays an error message if any characters are not A, C, G, T or N, or if too many N's are present. Even if a user has the skills to remove all the characters that are not A, C, G or T, this makes the output positions of SSRs incorrect because those characters are not accounted for. Additionally, MREPS output is in a relatively un-structured text document that is not trivial to parse. As another example, SSR-Pipeline can only look for one period size at a time, requiring the user to manually re-run the software repeatedly for each period size of interest. Finally, SA-SSR provides greater flexibility to the user. For example, the user can choose whether to perform an exhaustive or faster (still nearly complete) search, change output filters to report (or not) overlapping SSRs, or report only user-specified SSRs. SA-SSR is freely available at: http://github.com/ridgelab/SA-SSR.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>, 1–3 doi: 10.1093/bioinformatics/btw298 Advance Access Publication Date: 11 May 2016 Applications Note</figDesc><table></table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">B.D.Pickett et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank the Fulton Supercomputing Laboratory (https://marylou.byu.edu) at Brigham Young University for their consistent efforts to support our research.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This work was supported by start-up funds from Brigham Young University to PGR and a mentoring environment grant from Brigham Young University to CJW. Conflict of Interest: none declared.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>c</head><p>Whenever possible, we salvaged correct SSRs that were inside incorrect SSRs reported by other software packages. For example, in Drosophila melanogaster, we recovered three for PRoGeRF and 8408 for TRF. To illustrate, in sequence JXOZ01000043.1, TRF reports a CT repeated 36 times at position 2171. While TRF does correctly identify a low-complexity region with many CT repeats, there are not 36 perfect repeats in a row. In this case, we salvaged two perfect CT regions, each repeating 8 times. d</p><p>Detailed pairwise comparisons can be found in Supplementary Tables S4–S31.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SA-SSR</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Replacing suffix trees with enhanced suffix arrays</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">I</forename>
				<surname>Abouelhoda</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="53" to="86" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Reducing the space requirement of suffix trees</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw. Pract. Exp</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1149" to="1171" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Review of tandem repeat search tools: a systematic approach to evaluating algorithmic performance</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">G</forename>
				<surname>Lim</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinf</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="67" to="81" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title level="m" type="main">Microsatellites: Evolution and contribution</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Madesis</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>Springer</publisher>
			<biblScope unit="page" from="1" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Suffix arrays: a new method for on-line string searches</title>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Manber</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="935" to="948" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">A space-economical suffix tree construction algorithm</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">M</forename>
				<surname>Mccreight</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="262" to="272" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Slippage synthesis of simple sequence DNA</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Schlotterer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Tautz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="211" to="215" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">On-line construction of suffix trees</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ukkonen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="249" to="260" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Linear pattern matching algorithms. Switching and Automata Theory, 1973. SWAT&apos;08</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Weiner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference Record of 14th Annual Symposium on IEEE</title>
		<imprint>
			<date type="published" when="1973" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>