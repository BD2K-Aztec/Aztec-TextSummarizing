
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:39+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Xenome—a tool for classifying reads from xenograft samples</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Thomas</forename>
								<surname>Conway</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Software Engineering</orgName>
								<orgName type="laboratory">NICTA Victoria Research Laboratory</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<settlement>Parkville</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Jeremy</forename>
								<surname>Wazny</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Software Engineering</orgName>
								<orgName type="laboratory">NICTA Victoria Research Laboratory</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<settlement>Parkville</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Andrew</forename>
								<surname>Bromage</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Software Engineering</orgName>
								<orgName type="laboratory">NICTA Victoria Research Laboratory</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<settlement>Parkville</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Martin</forename>
								<surname>Tymms</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Monash Institute of Medical Research</orgName>
								<orgName type="institution" key="instit2">Monash University</orgName>
								<address>
									<settlement>Clayton</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Dhanya</forename>
								<surname>Sooraj</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Monash Institute of Medical Research</orgName>
								<orgName type="institution" key="instit2">Monash University</orgName>
								<address>
									<settlement>Clayton</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Elizabeth</forename>
								<forename type="middle">D</forename>
								<surname>Williams</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">Monash Institute of Medical Research</orgName>
								<orgName type="institution" key="instit2">Monash University</orgName>
								<address>
									<settlement>Clayton</settlement>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Bryan</forename>
								<surname>Beresford-Smith</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Software Engineering</orgName>
								<orgName type="laboratory">NICTA Victoria Research Laboratory</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<settlement>Parkville</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Xenome—a tool for classifying reads from xenograft samples</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="172" to="178"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts236</idno>
					<note>Copyedited by: ES MANUSCRIPT CATEGORY: [11:35 29/5/2012 Bioinformatics-bts236.tex] Page: i172 i172–i178 BIOINFORMATICS</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Shotgun sequence read data derived from xenograft material contains a mixture of reads arising from the host and reads arising from the graft. Classifying the read mixture to separate the two allows for more precise analysis to be performed.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Xenograft models are an important tool for many areas of biomedical research, including oncology, immunology and HIV pathology. A typical scenario, drawn from oncology research, is that of a human prostate cancer grown in an immunocompromised mouse model. Doing so allows researchers to investigate aspects of the cancer that are not necessarily preserved in cell lines, and it allows investigations into the interactions between the cancer and the surrounding stromal tissue. The mouse may be biopsied or harvested and samples of cancer and/or stroma collected at various time points during an experiment. Difficulties arise, when sequencing the genome or transcriptome of the samples because host (mouse) material (i.e. DNA/RNA) will inevitably comingle with the graft (human) material. If a sufficiently careful section is taken, it has been generally assumed that the level of host contamination is low enough that it may be ignored. This may be a dangerous assumption, however, since the level of gene expression is non-uniform. If the overall level of host contamination in a graft sample is measured to be 10% overall, it may still be the case for a given gene that the host homologue accounts for most or all of the expression. Contamination may be minimized by physical or biochemical techniques such as conservative sectioning, cell sorting or laser capture micro-dissection, but these techniques can be a significant source of technical bias, or in some cases may require infeasibly large amounts of starting material. Further, in the case of transcriptomic investigation, classifying host and graft in vitro may fail to adequately capture the interactions between them. An alternative strategy is to sequence an acknowledged mixture of host and graft, then use in silico methods to classify the individual sequence reads. This is the approach discussed here. We demonstrate a simple technique, based on an analysis of sequence * To whom correspondence should be addressed. reads using Tophat, and a more precise technique based on a k-mer decomposition of the host and graft reference sequences, Xenome. In both cases, the primary goal of the analysis is to classify reads into four classes: reads attributable to the host, reads attributable to the graft, reads which could be attributed to both and reads which are attributable to neither. To the best of our knowledge, there are no results in the literature examining the classification of high-throughput sequencing short reads from xenograft models. The studies we know of are concerned with microarray expression profiles or alternative methods for estimating the amount of host material or cell types in the samples. For example,<ref type="bibr">Lin et al. (2010)</ref>investigate the use of species-specific variation in gene length and a multiplex PCR to ascertain the relative amount of mouse and human DNA.<ref type="bibr" target="#b16">Wang et al. (2010)</ref>use microarray gene profiling data and in silico techniques to estimate the quantity of various tissue components. In<ref type="bibr" target="#b13">Samuels et al. (2010)</ref>, there is an analysis of a mouse xenograft model using microarray data. They conclude that if there is more than 90% human DNA then the expression profiles are not unduly skewed. They also describe an experimental method for removing homologous genes based on cross-hybridization analysis of the probes.<ref type="bibr" target="#b3">Ding et al. (2010)</ref>use short read sequencing to study a cancer genome and identify mutations/deletions. They estimate tumour cellularity using pathological assessment, and state that their xenograft is 90% tumour cells. They also map NOD/SCID (mouse) genomic data to human and mouse genomes, reporting 3.17% and 95.85% mapping rates, respectively, and so apply no correction for the murine cells. We note that in the context of non-uniform RNASeq data ignoring the contribution of the murine expression can lead to biases. Tools such as Tophat serve a different purpose than that of Xenome. The former aligns reads to a reference, and we can use those alignments for a variety of purposes, including the classification task we present here. In contrast, Xenome only performs the classification task itself. This is an important distinction, since an alignment must assign the read to zero or more positions in the genome; the classification merely has to decide if the read was more likely to arise from the genome than not. For the remainder of the article, we will assume, unless otherwise stated, that sequence reads arise from RNA-Seq. However, the techniques we present are applicable to genomic DNA sequences (including ChIP-Seq and MeDIP-Seq) and also to other mixtures of DNA species.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>Under the assumption that a graft sample has only a low level of host material contamination, the simplest analysis is to use a regular mappingbased RNA-Seq analysis tool, such as Tophat and assume that either the observed expression is dominated by the graft, which has the greatest number<ref type="figure">Fig. 1</ref>. A Venn diagram showing the different classes that a given k-mer may belong to. The marginal host (and marginal graft) partitions are for those host (and graft) k-mers that are Hamming distance 1 from a k-mer in the graft (and host) reference of input cells, or that the homology between the host species and graft species is such that reads arising from host material will tend to map poorly, and the resultant inferred level of gene expression will be negligible. In some cases, these assumptions may be true, but in the case of human cancer xenografts in mice, for example, the second assumption is false for many transcripts, and a more precise technique is desirable. Therefore, we have developed two techniques—one based on the existing RNA-Seq resequencing tool Tophat (<ref type="bibr" target="#b14">Trapnell et al., 2009</ref>), and one based on k-mer decompositions of the host and graft references. For genomic DNA, another resequencing/alignment tool could just as well be used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Xenome</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">A Tophat-based method</head><p>A more precise analysis may be performed by using Tophat (<ref type="bibr" target="#b14">Trapnell et al., 2009</ref>) to analyse the reads. First, Tophat is used to process the read set with the graft genome as reference. Secondly, Tophat is used to process the read set with the host genome as reference. Lastly, the accepted alignments from the Tophat mappings are post-processed to partition the reads into four classes: host, graft, both or neither. Tophat provides mapping quality scores in its output, but they only reflect whether or not the read mapped to multiple locations. If the quality scores reflected a measure of certainty that the read maps to the given location, a more sophisticated approach would be to extend the classification to assign reads that map with high certainty to one genome and low certainty to the other to the appropriate specific class rather than both. We do not pursue this further here. An implementation of this method may be achieved easily with Tophat, SAMtools (<ref type="bibr">Li et al., 2009</ref>) and some simple scripts. As will be apparent in the results presented in Section 3, although very few reads are misclassified (i.e. classified as host instead of graft, or vice versa), a significant proportion of the reads, even in a pure graft or pure host sample, fall into the both class. If these ambiguous reads were uniformly distributed in their origin across the genome, this would have only a small impact, but as we will elucidate in Section 4, the ambiguous reads are non-uniformly distributed. As a result, a significant number of genes cannot have their expression unambiguously pinned to the host or the graft, though at least compared with a single analysis, the set-based analysis makes clear which reads may be clearly associated with the host or the graft, and does not assume that all gene expression in the sample is explained by the graft.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">A k-mer-based method</head><p>Our method proceeds in two phases: constructing a reference data structure, then classifying reads with respect to that reference data structure. The reference structure is built from the sets of k-mers in a pair of reference sequences, which we will refer to as the host and the graft.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Definitions</head><p>Since in most sequencing protocols the reads are a mixture of forward and reverse complements with respect to the reference sequence, we cannot assume the orientation of k-mers drawn from reads will match the orientation of k-mers drawn from the reference. We could always consider both orientations, but that would entail a lot of double handling of information, so instead we normalize or canonicalize k-mers.</p><p>Definition 1. (k-mer canonicalization). Consider a k-mer x. We denote its reverse complement by ¯ x. A canonical k-merˆxmerˆ merˆx is defined by a choice function C giving a deterministic choice between x and ¯ x:</p><formula>∀x : ˆ x = C(x) = C(¯ x)</formula><p>In principle, we can choose any such function: min or max being obvious candidates, and the results of our method are identical for all choices. In Section 4, we will present our specific choice which has important performance ramifications. This definition can be extended to a set of k-mers S in the obvious way:</p><formula>ˆ S = ˆ x : x ∈ S</formula><p>Definition 2. (Marginal inclusion). Consider a set of canonical k-mersˆSmersˆ mersˆS. We say that a k-mer x is has marginal membership ofˆSofˆ ofˆS ifˆxifˆ ifˆx does not exist inˆS inˆ inˆS, but has a Hamming distance 1 neighbour y such thatˆythatˆ thatˆy is a member ofˆSofˆ ofˆS. To aid our computation of marginal inclusion, we define the function M: M(x, ˆ S) ={ˆy={ˆy : y ∈ Ham 1 (x)}∩ˆS}∩ˆ }∩ˆS where Ham 1 (x) is the set of Hamming distance 1 neighbours of x. Note thatˆy thatˆ thatˆy :</p><formula>y ∈ Ham 1 (x) = ˆ y : y ∈ Ham 1 (¯ x)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Reference construction</head><p>For both host and graft reference sequences, we construct the set of canonical k-mers ( ˆ H andˆGandˆ andˆG respectively). From these we compute a complete set of canonical reference k-mersˆSmersˆ mersˆS = ˆ H ∪ ˆ G. Note that ∀x ∈ ˆ S,x = ˆ x.</p><p>The sets of canonical k-mers tend to be large: with k = 25, there are 2.4 billion in the human genome, 2.1 billion in the mouse genome, and 4.5 billion in the union—only 12 million are shared. A naive representation (2 bits per base, packed), would use 50 bits per 25-mer, or about 26 GB. As discussed in our previous work (<ref type="bibr" target="#b2">Conway and Bromage, 2011</ref>), information theory gives a lower bound for the memory usage. For a domain of 4 k possible k-mers, the minimum number of bits required to represent a set of n k-mers is</p><formula>log 2 4 k n</formula><p>In the case of the unionˆSunionˆ unionˆS above, this is about 10 GB, or less than half what is required for the naive representation. As also discussed in our previous work, succinct data structures have been developed to give concrete representations that approach this theoretical lower bound. The one we use, due to (<ref type="bibr">Okanohara and Sadakane, 2006</ref>), works very well, requiring about 13 GB. For each reference k-mer, we determine whether it occurs in the host, the graft, both, or if it occurs in one and has a marginal occurrence in the other. These classes are denoted h, g, b or m, respectively (<ref type="figure">Fig. 1</ref>). More formally, we compute the function K for eachˆxeachˆ eachˆx ∈ ˆ S:</p><formula>K(ˆ x) = ⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩ b ifˆxifˆ ifˆx ∈ ˆ G ∧ ˆ x ∈ ˆ H g ifˆxifˆ ifˆx ∈ ˆ G ∧ ˆ x / ∈ ˆ H ∧( ˆ H ∩M(ˆ x, ˆ S) =∅) h ifˆxifˆ ifˆx / ∈ ˆ G ∧ ˆ x ∈ ˆ H ∧( ˆ G ∩M(ˆ x, ˆ S) =∅) m ifˆx ifˆ ifˆx ∈ ˆ G ∧ ˆ x / ∈ ˆ H ∧( ˆ H ∩M(ˆ x, ˆ S) =∅) ∨ ˆ x / ∈ ˆ G ∧ ˆ x ∈ ˆ H ∧( ˆ G ∩M(ˆ x, ˆ S) =∅)</formula><p>K may be extended to project not just k-mers to classes, but also a set of k-mersˆQmersˆ mersˆQ to a set of classes in the obvious way:</p><formula>K( ˆ Q) ={K(ˆ x) : ˆ x ∈ ˆ Q}</formula><p>These classes are pre-computed and stored as a sequence of 2-bit values corresponding to the k-mers in the succinctly store reference set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i173</head><p>Copyedited by: ES MANUSCRIPT CATEGORY:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T.Conway et al.</head><p>The class m denotes that the k-mer exists inˆHinˆ inˆH and has marginal membership ofˆGofˆ ofˆG or vice versa. That is, they are marginally distinctive, in the sense that a single polymorphism or sequencing error may cause a k-mer in that class to change from being marginally host to being marginally graft. Since the marginal set is symmetric (every marginal host k-mer has a corresponding marginal graft k-mer and vice versa), and represents k-mers that are not very discriminating, we combine both marginal sets into a single marginal set with the class m.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Classification</head><p>Classification proceeds by taking each read r and constructing the set of canonical k-mers that may be derived from the readˆQ readˆ readˆQ r. We then map the set of k-mers to a set of classes by the function K described above. k-mers that do not occur in the reference, ˆ S, are ignored. The k-mer classes that occur for a given read determine the classification of the read as a whole according to the following function:</p><formula>C( ˆ Q r ) = ⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩ graft if g ∈ K( ˆ Q r )∧h / ∈ K( ˆ Q r ) host if g / ∈ K( ˆ Q r )∧h ∈ K( ˆ Q r ) ambiguous if g ∈ K( ˆ Q r )∧h ∈ K( ˆ Q r ) both if K( ˆ Q r )∩{g,h}=∅∧K( ˆ Q r ) =∅ neither if K( ˆ Q r ) =∅</formula><p>The read classes graft and host denote cases where there is at least one k-mer which unambiguously comes from that k-mer class, and there are no contradictory k-mers (i.e. unambiguously from the opposing reference). The ambiguous class corresponds to the case where there are k-mers which appear to be contradictory—unambiguously host, and unambiguously graft. The both class represents cases where there are only k-mers which are either unambiguously common to both the host and graft or k-mers which may belong to either if they contain a single polymorphism or sequencing error. The last class, neither, represents those cases where there were no matching k-mers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4">Implementation concerns In Section</head><p>2.2, we introduced an abstract canonicalization function C. The most commonly used concrete function is min (or max), which selects the lexicographically/numerically smaller of the k-mers x and ¯ x:</p><formula>C min (x) = min(x,¯ x)</formula><p>We use the following definition, assuming some reasonable hash function f :</p><formula>C hash (x) = ⎧ ⎨ ⎩ x if f(x) &lt; f(¯ x) min(x,¯ x) if f(x) = f(¯ x) ¯ x if f(x) &gt; f(¯ x)</formula><p>Assuming f is a reasonable hash function, this definition effectively makes a random, but deterministic choice between x and ¯ x.</p><p>We use this definition, rather than the more common lexicographic one, because lexicographic canonicalization leads to the set of canonical k-mers being non-uniformly distributed across the set of all possible k-mers. There are two ways in which a more uniform distribution of k-mers improves performance of Xenome. The first is that the succinct bitmap representation that we use (due to<ref type="bibr">Okanohara and Sadakane, 2006</ref>) performs better on a uniform distribution of bits (that is, a uniform distribution of k-mers). The second is that it improves the performance of our intermediate hash table, from which the succinct bitmap data structure is built. The way the hash table is used is that as the input sequences are read, they are decomposed into k-mers which are stored in the hash table, which is of a fixed (controlled by a command line parameter) size. When the hash table fills (that is, unresolvable collisions arise), it is sorted and written out to disk. When all source k-mers have been read, the sorted runs are merged and the main succinct bitmap is constructed. The specific representation used is a succinct cuckoo hash table, broadly similar to (<ref type="bibr" target="#b0">Arbitman et al., 2010</ref>). The succinct representation relies on the fact that the location of the slot where a key x (in this case, a k-mer) is stored contains some of the information present in the key.</p><p>Consider an idealized hash table with load factor 1 (i.e. the number of values stored in the table equals the number of slots in the hash table), with no collisions. If the width of the hash table is 2 J , then J bits of the key are implied by the slot chosen. For keys of N bits, therefore, the entries of the hash table need store only N −J bits. The simplest way this may be realized would be to just use J bits of the key as the slot number, and store the remainder in that slot, but of course, this is likely to have an unacceptable number of collisions. Instead, we use an invertible hash function [based on a single-stage Feistel network, see Luby and<ref type="bibr" target="#b8">Rackoff (1988)</ref>] to turn a key x into a slot number s and a stored component v in such a way that given s and v we can recover x (assuming a hash function f ):</p><formula>F f (x) = x mod 2 J ⊕f ( x 2 J ),</formula><formula>x 2 J F −1 f (s,v) = s⊕f (v)+v2 J</formula><p>The size of the key data stored in the hash table is, then, 2 J (N −J ) bits.</p><formula>If 2 J 2 N , this is within 1+o(1) log 2 2 N 2 J bits</formula><p>, and hence succinct. [Of course, idealized hash tables are not possible if the set of keys is not known in advance. Hence we use cuckoo hashing (<ref type="bibr">Pagh and Rodler, 2004</ref>), in which collisions are resolved (as far as possible) using multiple hash functions.] To make the sorting of keys more efficient, our hash function preserves the N −J most significant bits of the keys, which are then stored in the hash table (along with a few bits to determine which hash function was used). This means that we can perform an initial bucketing without inverting the hash functions; the buckets can then be processed independently, using multiple threads if required. Now consider a set of random k-mers. For hash-based canonicalization, given a good hash function, there is an equal probability of observing any base in the most significant position inˆxinˆ inˆx. For lexicographic canonicalization, there is a probability of 4 10 that it is a, 3 10 that it is c, 2 10 that it is g, and only 1 10 that it is t. For a set of N random k-mers, the expected entropy at the most significant base is 2.0 bits and 1.85 bits, respectively. This matters, because hash functions are frequently vulnerable to poor behaviour in the presence of highly correlated sets of keys. In real, biologically derived sets of k-mers, the set of k-mers is non-random, so there is likely to be less entropy to begin with, and therefore loss of entropy due to canonicalization is exacerbated. This is especially problematic in the case of the above family of invertible hash functions, since it is precisely the most-significant bits of the key which are passed to the underlying hash function f. The upshot of this is that C min leads to highly correlated k-mers, which in turn lead to a high probability of unresolvable collisions even when the hash table is nearly empty, resulting in a large number of short runs. Since the set of canonical k-mers that result from C hash are less correlated, the hash table is unlikely to encounter unresolvable collisions until it is almost full (80–85% in practice).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Xenome—usage and workflow</head><p>To use the xenome tool, first it must be invoked to construct the reference data structures. A typical invocation will give the FASTA filenames for the host and graft genomes, a filename prefix for the index files, and optionally, the amount of working RAM to use (in Giga Bytes), and the number of threads to use: $ xenome index-M 24-T 8-P idx \-H mouse.fa-G human.fa This will run for some time—on the human/mouse references, around 4–6 h on an 8-core server. This need only be done once for a given pair of references, and a given k-mer size. The k-mer size defaults to 25, which seems to work well. With the reference data structures built, read data may be segregated. To make the output files easier to identify, command line flags can be used to</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i174</head><p>Copyedited by: ES MANUSCRIPT CATEGORY:If the total size of the index files is larger than RAM, xenome will perform poorly, but the flag-M can be supplied with the maximum desired working set size, and the classification will be done in multiple passes each using less memory. On a single server with 8 AMD Opteron cores running at 2 GHz and with 32 GB of RAM Xenome processes ∼15 000 read pairs per second. Having classified the reads, typical usage would be to then run Tophat and Cufflinks to perform intron-aware gapped alignments and compute gene expression. Instead of running Tophat on all of the reads, having separated the reads according to their origin, we can run it with the human genome just against the human fraction of the reads, and against the mouse genome on the mouse fraction of the reads. It may well be desirable to combine the both and ambiguous fractions with the human fraction to run against the human genome, and also with the mouse fraction to run against the mouse genome. If this is done, attention should be paid to homologous genes, since it is possible that the human and mouse homologues may be represented by the same reads. In some cases, the correct attribution of the gene expression may be apparent from the nature of the experiment. For example, a sample from a human prostate cancer grown in mouse may show ambiguous expression in MYH genes which would be reasonably attributed to the stromal mouse tissue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>Our analysis examines two questions: whether or not it is technically feasible to separate host and graft reads in silico; and whether or not the fast technique we have proposed (Xenome) yields a worthwhile improvement over the mapping (Tophat) based technique. In the first experiment, we take a sample of human cDNA sequence data (SRR342886), and a sample of mouse cDNA sequence data (SRR037689) and analyse them both with Tophat and Xenome, and compare the results. This allows us to evaluate the degree to which sequences are misclassified (assigned to human rather than mouse or vice versa), and the specificity of the classification—the proportion of sequences which are not classified as both. The use of pure human or mouse cDNA gives an experiment where the correct assignment of reads is known. The second experiment runs the same analysis on sequence data from a human prostate cancer xenograft growing in a mouse host<ref type="bibr">[BM18, see McCulloch et al. (2005)]</ref>. In this case, however, we not only classify the reads, but use the Tophat mappings to compute approximate levels of gene expression [measured in fragments per thousand bases of transcript per million mapped reads, or FPKM<ref type="bibr" target="#b15">Trapnell et al. (2010)</ref>] and use human species-specific quantitative RT-PCR (qRT-PCR) on selected genes to validate the results. In this instance, we have no gold standard by which we can judge the(Xenome), only by the Tophat analysis (Tophat) or by both Xenome and the Tophat analysis (<ref type="bibr">Concordant)</ref>results, but the qRT-PCR will give some degree of validation, and known aspects of the biology of the cancer can give some qualitative corroboration. Tophat uses a global analysis, combining the results of all the read mappings to locate exons, junctions and so on. In contrast, Xenome performs pre-computation on the two reference genomes, then classifies each read independently. Therefore, for each of the three sets of reads, we ran Tophat with the human reference genome and again with the mouse reference genome, then, as described in Section 2.1, the mappings were post-processed to determine which reads belonged to each of the four classes. Each of the four partitions of the sets of reads was then partitioned with Xenome to allow us to easily determine which reads were classified as the same by both procedures, and which were classified differently. Figures 2, 3 and 4 summarize the results. For the three samples, the proportion of reads receiving the same classification were 82, 87 and 84%, respectively. As can be seen from the human and mouse only figures, both techniques are accurate, in as much as they misclassify only a small proportion of the reads (the worst case being the Tophat-based analysis of the human cDNA which misclassified 1.2% of the reads—all the other analyses misclassified 0.2–0.3%). The main difference between the Tophat-based and Xenome analyses is that the latter yields better specificity—the fraction of reads classed as both is significantly smaller in the Xenome analysis. To check for false positives for the human cDNA dataset, we also used BLAT (<ref type="bibr" target="#b5">Kent, 2002</ref>) to map the 1.1 million reads which Xenome classed as human but which were not mapped to either genome by Tophat. Most of them were successfully mapped with high quality to the human reference by BLAT (about 90%). BLAT also mapped about 18% of them, with very variable quality, to the mouse reference. This supports our confidence in the accuracy of the Xenome algorithm. From this we can conclude that the in silico classification of sequences is feasible and accurate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i175</head><p>Copyedited by: ES MANUSCRIPT CATEGORY:The second experiment, using RNA-Seq data from a prostate cancer xenograft into a mouse demonstrates that the classification works on a real mixture. As described above, we performed the same process to partition the reads into classes, then we used the refGene genome coordinates as calculated by Tophat to assign reads to genes, from which we computed an expression level using the fragments per kilobase of transcript per million mapped reads formula (<ref type="bibr" target="#b15">Trapnell et al., 2010</ref>):</p><formula>FPKM = f ×10 9 zN</formula><p>where f is the number of fragments (reads, for single ended data or pairs for paired data), z is the combined length of the exonsThere were two RNA-Seq samples processed (biological replicates), and four replicates of the qRTPCR. For each gene, an ellipse is shown centered on the mean log 10 FPKM in the x-axis, and on the mean relative C t in the y-axis. The horizontal and vertical radii show the variance in the samples of the gene and N is the total number of mapped fragments. Although this quantification is peripheral to the technique we are presenting, we have computed expression levels for the purposes of comparing with some qRT-PCR data for the same biological data. The qRT-PCR data were available for 18 genes: ABCG2, ALDH1A1, CD177, DLL1, DLL3, GLI1, GLI2, HES1, JAG1, JAG2, LGR5, NANOG, NOTCH1, NOTCH2, NOTCH3, PTCH1, PTCH2 and SMO.<ref type="figure" target="#fig_6">Figure 5</ref>shows the log 10 FPKM versus the difference of the C t for each target gene and the C t for actin (which was used as a housekeeping gene). With the exception of NANOG, the two methods correlate reasonably well (the Pearson's correlation coefficient is 0.80). We have investigated the NANOG data, and cannot explain the low FPKM. Whether this is a sequencing issue or a biological variation in the mice is unknown, but the low level of expression does not appear to be related to the behaviour of Xenome or Tophat.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>We have presented a simple read classification method based on Tophat, and our refined classification approach, Xenome. Xenome can be used to efficiently and effectively partition the read set for subsequent processing by tools such as Tophat. What is not apparent from the results above is the relative behaviour at the level of a single gene. It should be expected that the distribution of ambiguously mapped reads (classed as both) should be non-uniform, since some genes in the two genomes are more highly conserved than others.The first result we present in<ref type="figure">Figure 6</ref>on this point is an in silico analysis showing the proportion of each human gene (ignoring introns) covered by k-mers that are not classed as human. It is clear that the vast majority of genes contain few or no k-mers that are not classed as human. The fraction of k-mers which are ambiguous gives a worst-case view of how Xenome might be expected to perform. In order for a read to be classified as both, all of its k-mers must be of the both class, or there must be at least one k-mer from each of the two genomes (which happens less than 2% of the time in the samples we have tried). Conversely, a single host or graft k-mer is sufficient to classify the read into the respective class. Therefore for a read to be classified as both, the reference must contain a sufficiently long run of consecutive k-mers of class both and/or SNPs and sequencing errors must eliminate all the distinctively host or graft k-mers. The second result we report on this point, presented in<ref type="figure">Figure 7</ref>is the relative proportion of reads which are classified as both on a per-gene basis. What is evident in this figure is that although there are many genes for which the proportion of both reads is tightly correlated between Tophat and Xenome, there are a large number of genes for which the Tophat-based analysis has significantly more both reads. There are 15 591 genes for which there were at least 20 mapped reads in the BM18 xenograft sample. Of these, there were 65 for which Xenome assigned both or ambiguous to at least half the reads mapping to the gene; there were 498 for which the Tophatbased analysis assigned both to at least half the reads mapped to the gene. For the most highly conserved genes, there is not much that can be done with this data directly—further signal processing or other data would be required to determine the relative expression in the host and graft. While we have developed Xenome with RNA-Seq on human/ mouse xenografts in mind, we anticipate it will be an effective tool for other similar mixtures. For example, capturing the differential methylation around genes between host and graft using MeDIP-Seq may shed light on the interraction between the two.<ref type="figure">7</ref>. A plot showing the distribution of human genes with respect to the proportion of xenograft reads which are classed as both by the Tophat-based analysis and the Xenome analysis. The reads considered are only those mapped by Tophat since Xenome does not yield mappings, so cannot be used to assign reads to genes. Only genes for which at least 20 reads mapped were considered. The horizontal axis corresponds to the number of reads classified as both or ambiguous by Xenome as a proportion of all the reads that might possibly be human (i.e. both, ambiguous or human). The vertical axis corresponds to the number of reads classified as both by the Tophatbased analysis, once again, as a proportion of all the reads that might possibly be human</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i176</head><p>The need for our technique is substantially motivated by the fact that for a xenograft to be viable there must be very strong homology between the host and graft organisms. This leads to a situation where there is a high probability that a read may map to either genome, and</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>T.Conway et al.</head><p>which allow for a more subtle classification procedure. These could, for example, be based on the frequency of k-mers of different classes, giving rise to the computation of the likelihood that a read originated from either the host or graft genomes. Indeed, if such likelihoods were used from read alignments (Tophat unfortunately does not produce such scores), a unified model allowing either our current k-mer based model or alignments could be used. A further extension could take into consideration the established homology between genes in the host and graft organisms. Where reads are ambiguous, non-ambiguous reads associated with the same gene homologues could be used to help disambiguate the classification. EM-based methods such as those described in<ref type="bibr" target="#b10">Newkirk et al. (2011);</ref><ref type="bibr" target="#b1">Chung et al. (2011)</ref>;<ref type="bibr" target="#b4">Hormozdiari et al. (2010)</ref>would be a good basis for such an extension. We note however, that this would require significant conceptual changes to Xenome since it requires relatively more precise alignments. It is instructive to consider a specific example of a gene where the Tophat based and Xenome analyses are very different. For the gene MYH3, in the human cDNA dataset, there are 29 reads classed as human by the Tophat-based analysis and 2 713 classed as human by Xenome. All the reads that are thus assigned by Xenome but not by the Tophat-based analysis were classed as both by the latter. This is because there is a high level of conservation in this gene between the two species, and the reads therefore aligned to both. Were Tophat to yield meaningful alignment quality scores, a statistical approach of the kind hinted at above may perform similarly to the k-mer based approach.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>[11:</head><figDesc>35 29/5/2012 Bioinformatics-bts236.tex] Page: i174 i172–i178</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>[11:</head><figDesc>35 29/5/2012 Bioinformatics-bts236.tex] Page: i175 i172–i178 Xenome name the host and graft files. If paired data is being classified, the – –pairs flag should be given—pairs are classified by computing K( ˆ Q) over all the k-mers in the pair. $ xenome classify-T 8-P idx-pairs \-graft-name human-host-name mouse \-output-filename-prefix XYZ-i XYZ_1.fastq-i XYZ_2.fastq This yields the following set of files:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Summary of the results with Human cDNA. Each of the classes of reads is divided into those reads assigned to the class only by Xenome (Xenome), only by the Tophat analysis (Tophat) or by both Xenome and the Tophat analysis (Concordant)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>[11:</head><figDesc>35 29/5/2012 Bioinformatics-bts236.tex] Page: i176 i172–i178 T.Conway et al.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.3.</head><figDesc>Fig. 3. Summary of the results with Murine cDNA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.4.</head><figDesc>Fig. 4. Summary of the results with BM18 xenograft cDNA</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.5.</head><figDesc>Fig. 5. Validation of the in silico classification of xenograft RNA-Seq data with qRT-PCR. The horizontal axis shows log 10 FPKM for the Xenomederived gene expression for the 18 test genes. The vertical axis shows the C t value for each gene relative to the C t of actin. There were two RNA-Seq samples processed (biological replicates), and four replicates of the qRTPCR. For each gene, an ellipse is shown centered on the mean log 10 FPKM in the x-axis, and on the mean relative C t in the y-axis. The horizontal and vertical radii show the variance in the samples</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.</head><figDesc>Fig. 7. A plot showing the distribution of human genes with respect to the proportion of xenograft reads which are classed as both by the Tophat-based analysis and the Xenome analysis. The reads considered are only those mapped by Tophat since Xenome does not yield mappings, so cannot be used to assign reads to genes. Only genes for which at least 20 reads mapped were considered. The horizontal axis corresponds to the number of reads classified as both or ambiguous by Xenome as a proportion of all the reads that might possibly be human (i.e. both, ambiguous or human). The vertical axis corresponds to the number of reads classified as both by the Tophatbased analysis, once again, as a proportion of all the reads that might possibly be human</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><figDesc>Copyedited by: ES MANUSCRIPT CATEGORY: [11:35 29/5/2012 Bioinformatics-bts236.tex] Page: i178 i172–i178</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Xenome Fig. 6. An in silico analysis showing the degree of ambiguity in HG19 refGene, according to the k-mer based analysis used by Xenome. In this analysis, k = 25</figDesc><table>Copyedited by: ES 

MANUSCRIPT CATEGORY: 

[11:35 29/5/2012 Bioinformatics-bts236.tex] 
Page: i177 i172–i178 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">it is this problem that Xenome specifically addresses. A side benefit is that the classification is done independently for each read, and results in groups of reads in each class; each group may then be processed independently with further tools [such as Tophat, Cufflinks (Roberts et al., 2011) or others]. Given that many kinds of analysis require global processing of the input data, being able to process a coherent subset of the data can lead to a time/space gain. This benefit extends beyond the sphere of xenografts. For example, there are situations where a parasite or pathogen cannot be cultured independently (for example Chlamydia, and some fungi), so samples will generally contain a mixture of host and pathogen. In some examples, although the pathogen can be cultured independently, there are phenotypic differences between organisms growing in culture and those growing in a host. In both cases, there are benefits to being able to classify the two groups of reads, even though straight mapping based approaches will be less sensitive to cross-talk than xenograft data. Precise alignment and alignment-free methods represent different points along a spectrum of possible classification techniques. Fundamentally, both rely on establishing homology between a read and the host and/or graft references. By substituting different algorithms for establishing homology (e.g. various alignment algorithms, k-mer spectrum methods, etc.), different sensitivity and specificity might be achieved. Although our current technique is built on simple set-based classification, there is clearly scope to develop statistical models i177 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">i178 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENT</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Backyard cuckoo hashing: Constant worst-case operations with a succinct representation</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Arbitman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2010 IEEE 51st Annual Symposium on Foundations of Computer Science</title>
		<meeting><address><addrLine>Los Alamos California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="787" to="796" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Discovering transcription factor binding sites in highly repetitive regions of genomes with multi-read analysis of ChIP-Seq data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Chung</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">1002111</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Succinct data structures for assembling large genomes</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">C</forename>
				<surname>Conway</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">J</forename>
				<surname>Bromage</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="479" to="486" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Genome remodelling in a basal-like breast cancer metastasis and xenograft</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Ding</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">464</biblScope>
			<biblScope unit="page" from="999" to="1005" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Next-generation VariationHunter: combinatorial algorithms for transposon insertion discovery</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Hormozdiari</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="350" to="357" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">BLAT—the BLAST-like alignment tool</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Kent</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="656" to="664" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Comparative studies of de novo assembly tools for next-generation sequencing technologies</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Lin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2031" to="2037" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">How to construct pseudorandom permutations from pseudorandom functions</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Luby</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Rackoff</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="373" to="386" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">BM18: a novel androgen-dependent human prostate cancer xenograft model derived from a bone metastasis</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Mcculloch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Prostate</title>
		<imprint>
			<biblScope unit="volume">65</biblScope>
			<biblScope unit="page" from="35" to="43" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">AREM: aligning short reads from ChIP-sequencing by expectation maximization</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Newkirk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1495" to="1505" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Practical entropy-compressed rank/select dictionary In: Proceedings of the Workshop on Algorithm Engineering and Experiments (ALENEX&apos;07), http://www.siam.org/proceedings/alenex Cuckoo hashing</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Okanohara</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">R</forename>
				<surname>Sadakane</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<forename type="middle">F</forename>
				<surname>Rodler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="122" to="144" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
	<note>alx07_007okanoharad2. .pdf Pagh,</note>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Identification of novel transcripts in annotated genomes using RNA-seq</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Roberts</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2325" to="2329" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Validation of a mouse xenograft model system for gene expression analysis of human acute lymphoblastic leukaemia</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Samuels</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genomics</title>
		<imprint>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">256</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">TopHat: discovering splice junctions with RNA-Seq</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Trapnell</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1105" to="1111" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Transcript assembly and quantification by RNA-Seq reveals unannotated transcripts and isoform switching during cell differentiation</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Trapnell</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="511" to="515" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">In silico estimates of tissue components in surgical samples based on expression profiling data</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cancer Res</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>