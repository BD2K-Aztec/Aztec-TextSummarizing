
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:46+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">APPAGATO: an APproximate PArallel and stochastic GrAph querying TOol for biological networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Vincenzo</forename>
								<surname>Bonnici</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Verona</orgName>
								<address>
									<addrLine>Strada Le Grazie 15 -37134</addrLine>
									<settlement>Verona</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Federico</forename>
								<surname>Busato</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Verona</orgName>
								<address>
									<addrLine>Strada Le Grazie 15 -37134</addrLine>
									<settlement>Verona</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Giovanni</forename>
								<surname>Micale</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Math and Computer Science</orgName>
								<orgName type="institution">University of Catania</orgName>
								<address>
									<addrLine>Viale a. Doria 6 -95125</addrLine>
									<region>Catania</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Nicola</forename>
								<surname>Bombieri</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Verona</orgName>
								<address>
									<addrLine>Strada Le Grazie 15 -37134</addrLine>
									<settlement>Verona</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alfredo</forename>
								<surname>Pulvirenti</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Clinical and Experimental Medicine</orgName>
								<orgName type="institution">University of Catania</orgName>
								<address>
									<addrLine>via Palermo</addrLine>
									<postCode>636 -95122</postCode>
									<region>Catania</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Rosalba</forename>
								<surname>Giugno</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Verona</orgName>
								<address>
									<addrLine>Strada Le Grazie 15 -37134</addrLine>
									<settlement>Verona</settlement>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Clinical and Experimental Medicine</orgName>
								<orgName type="institution">University of Catania</orgName>
								<address>
									<addrLine>via Palermo</addrLine>
									<postCode>636 -95122</postCode>
									<region>Catania</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">APPAGATO: an APproximate PArallel and stochastic GrAph querying TOol for biological networks</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btw223</idno>
					<note type="submission">Received on October 20, 2015; revised on March 7, 2016; accepted on April 10, 2016</note>
					<note>Systems biology *To whom correspondence should be addressed Associate Editor: Alfonso Valencia Contact: rosalba.giugno@univr.it Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Biological network querying is a problem requiring a considerable computational effort to be solved. Given a target and a query network, it aims to find occurrences of the query in the target by considering topological and node similarities (i.e. mismatches between nodes, edges, or node labels). Querying tools that deal with similarities are crucial in biological network analysis because they provide meaningful results also in case of noisy data. In addition, as the size of available networks increases steadily, existing algorithms and tools are becoming unsuitable. This is rising new challenges for the design of more efficient and accurate solutions. Results: This paper presents APPAGATO, a stochastic and parallel algorithm to find approximate occurrences of a query network in biological networks. APPAGATO handles node, edge and node label mismatches. Thanks to its randomic and parallel nature, it applies to large networks and, compared with existing tools, it provides higher performance as well as statistically significant more accurate results. Tests have been performed on protein–protein interaction networks annotated with synthetic and real gene ontology terms. Case studies have been done by querying protein complexes among different species and tissues. Availability and implementation: APPAGATO has been developed on top of CUDA-C þþ Toolkit 7.0 framework. The software is available online http://profs.sci.univr.it/$bombieri/APPAGATO.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Technological advances have led to the inference and the validation of structured interaction networks involving genes, proteins, drugs, phenotype and diseases (<ref type="bibr" target="#b0">Barabasi and Oltvai, 2004;</ref><ref type="bibr" target="#b20">Kelley et al., 2003;</ref><ref type="bibr" target="#b28">Panni and Rombo, 2015</ref>). According to the data type, such networks are referred to as (i) protein–protein interaction (PPI) networks representing either physical or functional interactions among proteins; (ii) gene regulatory networks that express how the activity of genes is regulated; (iii) metabolic networks describing biochemical reactions between chemical compound of cells; and (iv) signalling networks representing inner/outer cell communications. A typical example that highlights the advantages and possibilities of analysing interaction relationships is protein function prediction. Although sequence homology is commonly used to functionally annotate proteins, a great amount of them remained uncharacterized (<ref type="bibr" target="#b40">Yu et al., 2013</ref><ref type="bibr" target="#b39">Wang et al., 2013</ref>). In disease studies, genes showing similar phenotypes tend to be neighbours in protein interaction networks and their aggregation in connected sub-networks is effective to detect biomarkers (<ref type="bibr" target="#b10">Creixell et al., 2015;</ref><ref type="bibr" target="#b13">Fortney et al., 2010;</ref><ref type="bibr" target="#b18">Ideker et al., 2002</ref>). Also, finding similar functional and topological sub-networks helps analysing the conservation among species (<ref type="bibr" target="#b24">Lim et al., 2006</ref>). In all these applications, graphs serve as the underlying structures for representing biological networks (For the sake of clarity, in this article, we use the terms graph and network indistinctly.) and graph algorithms solve problems such as network alignment, network querying, motif extractions and network perturbation (<ref type="bibr" target="#b7">Ciriello et al., 2012;</ref><ref type="bibr" target="#b25">Ma and Gao, 2012</ref>; Malod-Dognin and Pr zulj, 2015;<ref type="bibr" target="#b28">Panni and Rombo, 2015</ref>). In this article we address the problem of approximate network querying, which finds, in a target network, similar occurrences of a so-called query network. The notion of similarity takes into account both the similarities between target nodes and query nodes, and a cost measuring the differences of nodes and their connections. An approximate network querying algorithm has to find the query occurrences, among all possible, with the maximum combined similarity. Querying tools that deal with similarities are effective in biological network analysis because they provide results also in case of noisy data. They are also suitable in the case of partial knowledge of users when formulating queries. Furthermore, they can be used to compare data from different species where some fundamental and functional structures are partially preserved. Solving approximate network querying implies applying instances of subgraph isomorphism, which is a NP-complete problem (<ref type="bibr" target="#b12">Dost et al., 2008</ref>). In literature, several heuristics have been proposed to solve such a problem in reasonable running time. Examples include restricting the topology of queries to paths or trees (<ref type="bibr" target="#b12">Dost et al., 2008;</ref><ref type="bibr" target="#b21">Kelley et al., 2004;</ref><ref type="bibr" target="#b30">Pinter et al., 2005;</ref><ref type="bibr" target="#b33">Shlomi et al., 2006</ref>), applying network alignment strategies (<ref type="bibr" target="#b15">Gulsoy and Kahveci, 2011;</ref><ref type="bibr" target="#b36">Tian et al., 2007</ref><ref type="bibr" target="#b37">Tian et al., , 2008</ref><ref type="bibr" target="#b41">Yuanyuan and Patel, 2008</ref>), dealing with node similarities and ignoring the query topology (<ref type="bibr" target="#b2">Blin et al., 2010;</ref><ref type="bibr" target="#b5">Bruckner et al., 2010</ref>), fixing the topology and computing differences of node labels (<ref type="bibr" target="#b17">Hong et al., 2015</ref>). Other methods consist of building indexes to reduce the query time (<ref type="bibr" target="#b22">Khan et al., 2013;</ref><ref type="bibr" target="#b42">Zhang et al., 2009</ref>); filtering the set of possible similar target data (<ref type="bibr" target="#b17">Hong et al., 2015;</ref><ref type="bibr">Pienta et al., 2014;</ref><ref type="bibr" target="#b32">Sahraeian and Yoon, 2012</ref>); to find only exact occurrences of the query in the network (<ref type="bibr" target="#b3">Bonnici and Giugno, 2016;</ref><ref type="bibr" target="#b4">Bonnici et al., 2013;</ref><ref type="bibr" target="#b8">Cordella et al., 2004;</ref><ref type="bibr" target="#b34">Sun et al., 2012</ref>); finding the largest part of the query exactly contained in the target graph and replace the query edges not present in the target with paths (<ref type="bibr">Pienta et al., 2014</ref>). We have created APPAGATO, a tool that relies on an iterative sampling method (<ref type="bibr" target="#b23">Lawrence et al., 1993;</ref><ref type="bibr" target="#b27">Micale et al., 2014</ref>), to compute functional and topological similarities between a query and a target network. Through a matching probability matrix and a weighted sampling procedure, it selects a seed from which the query–target matching starts. Then, by associating a cost to each approximation, it iteratively extends the match by selecting the approximations with the lowest possible cost. The algorithm runs K times and returns a set of K approximate matches. APPAGATO performs approximate network querying by considering the topology of query, taking into account node and edge deletions together with differences on node labels.</p><p>To speed-up the querying process in large biological networks, APPAGATO has been implemented to run on graphics processing units (GPUs). Owing to their low cost, high-performance and easy integration to any personal computer, GPUs have been increasingly applied to accelerate bioinformatics problems (<ref type="bibr" target="#b11">Dematté and Prandi, 2010;</ref><ref type="bibr" target="#b38">Vouzis and Sahinidis, 2011;</ref><ref type="bibr" target="#b43">Zhao and Chu, 2014</ref>). Our aim is to handle large biological networks in a reasonable time yielding accurate results. We compare APPAGATO with RESQUE (<ref type="bibr" target="#b32">Sahraeian and Yoon, 2012</ref>) and NeMa (<ref type="bibr" target="#b22">Khan et al., 2013</ref>) because, to the best of our knowledge, they are the most efficient and stable tools in literature close to APPAGATO on both the problem they address and on the approximation concept they assume. We run the tools with different PPI networks as input and compared nodes by using similarities of protein sequences and functional gene ontology annotations. We extensively compare the tools in terms of running time, costs of returned matches and accuracy in finding protein complexes among different species. The results show that APPAGATO outperforms the other two tools, yielding more accurate results on large PPI networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Materials and methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Definitions and notations</head><p>A graph G is a pair (V, E), where V is the set of nodes and E ðV Â VÞ is the set of edges. If ðu; vÞ 2 E, we say that v is a neighbour of u. G is undirected iff 8ðu; vÞ 2 E; then ðv; uÞ 2 E, i.e. u is a neighbour of v and vice versa. The degree of a node u, Deg(u), is the number of its neighbours. Given a set of labels A, the function Lab : V ! A assigns a label to each node of G. We assume that graphs are undirected and labelled only on nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Exact SubGraph Isomorphism</head><p>Let Q ¼ ðV; EÞ and T ¼ ðV 0 ; E 0 Þ be two graphs, named query and target, respectively. The exact SubGraph Isomorphism (SUBGI) problem aims to find an injective function, M : V ! V 0 , which maps each node in Q to a unique node in T, such that 8ðu; vÞ 2 E: (i) ðMðuÞ; MðvÞÞ 2 E 0 ; (ii) LabðuÞ ¼ LabðMðuÞÞ; (iii) La bðvÞ ¼ LabðMðvÞÞ. A solution of the SUBGI problem can be represented as the set m ¼ fðv 1 ; Mðv 1 ÞÞ; ðv 2 ; Mðv 2 ÞÞ;. .. ; ðv jVj ; Mðv jVj ÞÞg, called a match of Q in T. Q may have different maps m i in T.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Inexact SubGraph Isomorphism and matching costs</head><p>In this article, we deal with the Inexact SubGraph Isomorphism (ISUBGI) problem (Here called also approximate subgraph querying.), which is a variant of the SUBGI problem, and in which we admit node and edge mismatches. A mismatch occurs when (i) two nodes with different labels are mapped through a similarity function, or (ii) a query edge or (iii) a query node is missing in the target graph. The absence of a node implies mismatches for all its edges. A cost c is associated to each mismatch. For the sake of simplicity, the same cost c ¼ 1 is associated to each of the three types of mismatch. We denote with C ¼ P c the total cost of mismatches between Q and T. The goal of the ISUBGI problem is to find an injective function M : V ! V 0 , such that C is minimized. In this case, a solution for the ISUBGI, m ¼ fðv 1 ;, the nodes and the edges in Q, respectively, that have not been matched in m. Let S jVjÂjV 0 j be the label similarities between each node q 2 Q and t 2 T. The label similarity values belong to the interval ½0; 1. The computation of S is application dependent. In the case of PPI networks, the similarity can be based on sequences, functional or structural protein similarity. For example, establishing the conservation of a protein-complex CO of the species A within the species B consists of searching the subgraph Q CO , extracted from the PPI of A (named G A ), into the PPI of B (named G B ). The two PPIs may have different proteins (i.e. nodes with different names), but with similar function, detectable by looking at sequence similarities. An ISUBGI algorithm must search for occurrences of Q CO in G B that minimize sequences and topology differences. We conclude that CO is conserved in B if we find highly similar occurrences. The total matching cost C is obtained by summing all node and edge costs and by normalizing them over the number of query elements, as follows:</p><formula>C ¼ X q2Vm ð1</formula><p>À Sðq; MðqÞÞ þ jV mj þ jE mjÞ jVj þ jEj (1)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The APPAGATO algorithm</head><p>The method consists of the following three main phases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Phase 1: Computation of matching probability matrix</head><p>Before starting the search, APPAGATO computes a matrix P of matching probabilities between all possible node pairs &lt; q; t &gt; (q 2 Q and t 2 T), by combining (i) the label similarity S(q, t), (ii) the degree similarity D(q, t) and (iii) the breadth-first similarity BFS Sim ðq; tÞ. The label similarity has been defined in Section 2.1.2. In APPAGATO, the label similarity matrix, S, may be provided as input by the user. Alternatively, APPAGATO computes a Boolean similarity function to compare node labels. It assigns 1 if labels are identical, 0 otherwise. The degree similarity is a binary function D(q,t) ¼ 1 if DegðqÞ DegðtÞ, otherwise it is 0. BFS Sim ðq; tÞ is computed by performing breadth-first visits (BFSs) of the query and target graphs by starting from q and t and evaluating label and degree similarities of the visited nodes, level by level. The maximum depth of the BFS visits is a user-defined parameter l max , with l max ! 1. Given a node x, and a level l l max we denote with BFS l ðxÞ the set of nodes at level l in the BFS tree rooted at x. An edge e ¼ ðu; vÞ in the BFS tree of q is defined matchable iff there exists an edge e 0 ¼ ðu 0 ; v 0 Þ in the BFS tree of t such that Sðu; u 0 Þ and Sðv; v 0 Þ are not 0 and Dðu; u 0 Þ ¼ Dðv; v 0 Þ ¼ 1. We denote with MaxMatchðBFS l ðqÞ; BFS l ðtÞÞ a maximal set of matchable edges in the BFS tree of q at level l, with respect to the BFS tree of level l rooted in t. The BFS similarity between q and t assumes values in ½0; 1 and is defined as follows:</p><p>BFSEquation (3) ensures that P t2T Pðq; tÞ ¼ 1. In phase 2, the probability matrix is used as a transition matrix within an iterative sampling to extract the best possible matches. The upper side of<ref type="figure">Figure 1</ref>shows an example of such a matrix computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Phase 2: Seed selection</head><p>APPAGATO searches the first pair of nodes to be matched by randomly selecting q and t according to the probabilities defined in Equation (3) (see the example of<ref type="figure">Figure 1</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Phase 3: Extension</head><p>Gibbs sampling is used to navigate within a Markov chain, where each state represents a possible query-target node match. The initial state corresponds to the seed selected in phase 2. The sampling method iteratively performs a transition from a state to another, by replacing the query–target nodes pair with a new one, according to a properly defined transition probability. As an example,<ref type="figure">Figure 1</ref>shows the first two iterations of the extension phase. Transition probabilities are defined by starting from similarity scores, and by taking into account the connections of candidate nodes with already matched nodes. Let Q m and T m be the set of query–target matched nodes at a certain step of the extension process. We denote with Q m ½i (T m ½i) the i-th query (target) node added to the partial match. Let q be a query node neighbour to at least one node in Q m and t be a target node neighbour to at least one node in T m. We represent the set of connections between q and the nodes in Q m through a bit vector CP(q) of jQ m j elements, called connection profile of q, where the i-th element is defined as follows:<ref type="figure">Fig. 1</ref>. The APPAGATO approximate matching algorithm</p><formula>CPðqÞ½i ¼ 1 ifðq; Q m ½iÞ 2 E 0 otherwise ( (4)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Parallel and stochastic search</head><p>We define CP(t) in the same way. The connection profile similarity between q and t is the corresponding number of equal bits in the connection profiles of q and t: CP Sim ðq; tÞ ¼ jf1 i jCPðqÞj : CPðqÞ½i ¼ CPðtÞ½igj jCPðqÞj</p><formula>(5)</formula><p>The overall similarity score is MScoreExtðq; tÞ ¼ Sðq; tÞ Â CP Sim ðq; tÞ. The result value is normalized to obtain the final transition probability (Notice that MScore is not used in the extension phase. MScoreExt strongly influences the convergence of the approach (<ref type="bibr" target="#b23">Lawrence et al., 1993;</ref><ref type="bibr" target="#b27">Micale et al., 2014</ref>).):</p><formula>P T ðq; tÞ ¼ MScoreExtðq; tÞ X z2T MScoreExtðq; zÞ (6)</formula><p>After a number of iterations, n, which is a user-defined parameter, the algorithm returns the reached match between the query and the target node. The quality of such a match is evaluated by summing the costs of node and edge mismatches between Q and T. APPAGATO does not require any user-defined threshold for the maximum allowed cost of a match. In<ref type="figure">Figure 1</ref>, the approximate match has only a label mismatch, v Q 2 , whose label C is mapped with v T 0 having label D, and the cost of the match is C ¼ 0.1, computed by applying Equation (1). APPAGATO iterates K times phases 2 and 3 and, in each iteration, it starts the sampling procedure from a different seed. Each run of APPAGATO always returns K solutions (approximate matches), each one with the corresponding cost.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The APPAGATO parallel implementation for GPUs</head><p>APPAGATO has been implemented to take advantage of massively parallel GPU architectures. All the processing phases presented in Section 2.2 have been implemented through different CUDA kernels (http://www.nvidia.co.uk/object/cuda-parallel-computing-uk.html), which are invoked by the host CPU. This allows performing the most compute-intensive tasks of the search algorithm on the GPU device. As for the parallel implementation paradigm for GPUs, each kernel is executed in parallel by several blocks of threads. Thread blocks spread and run concurrently and independently over streaming multiprocessors. Threads of the same block efficiently cooperate through fast shared memory and by synchronizing their execution through extremely fast (i.e. HW implemented) barriers. Groups of 32 threads of the same block are called warps. Each warp executes one kernel instruction at a time in parallel on different data (i.e. single instruction multiple data-SIMD architecture) over the many stream processors (cores) of the GPU device. A warp scheduler efficiently switches between warps with the aim of hiding the latency of thread accesses to the memory. Given the query and the target graphs, Q and T, the three phases have been implemented as follows (see<ref type="figure">Figure 2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Phase 1: Parallel computation of matching probability matrix</head><p>Computing the matching probability matrix is one of the most computation-intensive part of the whole algorithm. It requires jVj ÂjV 0 j computations of Equation (3) and, in particular, OðjVj þ jV 0 jÞ BFSs over Q and T and the corresponding comparisons between the visited edges (<ref type="bibr">Equation (2)</ref>). APPAGATO implements such a phase through a customized version of BFS-4K (<ref type="bibr" target="#b6">Busato and Bombieri, 2015</ref>), a parallel implementation of BFS for GPU architectures. BFS-4K relies on the concept of frontier (<ref type="bibr" target="#b9">Cormen et al., 2009</ref>) (i.e. a FIFO queue that contains the nodes to be visited at each BFS iteration) to implement the graph visit. Through the frontier-based visiting, BFS-4K allows Equation (3) to be performed over two levels of parallelism: Each parallel warp of a block is mapped to each node of the frontier, and each parallel thread of a warp is mapped to each outgoing edge from a frontier node. APPAGATO extends the BFS visit over a third level of parallelism, by running a total number of jVj þ jV 0 j independent BFSs in parallel, one for each node of Q and T. This is done by allocating one block of threads per BFS. The block allocation is automatically done at runtime. A total number of jVj thread blocks perform, in parallel, jVj BFSs (of depth l max ) for the query graph. The result consists of source–destination matrices, one per node, which are stored in the global memory (the left-most side of<ref type="figure">Figure 2</ref>shows an example, assuming l max ¼ 2). Each matrix contains information on the labels of such edges visited during the BFS from the node along l max levels. In the example of<ref type="figure">Figure 2</ref>, the V Q 0 matrix contains information on the edges of the first-level BFS (A – B, A – C, A – D) as well as the edges of the second-level BFS (B – A, B – C, C – A, C – B, D – A). Similarly, and concurrently, a total number of jV 0 j thread blocks perform the BFSs for the target graph. The result consists of a set of<ref type="figure">Fig. 2</ref>. The parallel search of APPAGATO on the GPU device source–destination arrays, one per node, which are stored in the device shared memory. This allows an extremely fast memory access for the following comparisons between the generated node structures. The array data structure has been chosen, as it allows to represent in a more compact way the source–destination information of T in the limited shared memory. In contrast, the matrix data structure has been chosen as it guarantees a faster access to the source–destination information of Q, to be stored in the larger global memory. Finally, jV 0 j thread blocks compare, in parallel, their own source–destination array stored in the local shared memory with all the source–destination matrices in global memory. Such a data structure organization over the GPU memory hierarchy allows the complexity of Equation (3) to be reduced from OðjVj Â jV 0 jÞ as for the sequential algorithm, to a parallel complexity of O(1). The result of Phase 1 is the matrix P jVjxjV 0 j , which is stored in the device global memory (see centre part of<ref type="figure">Figure 2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Phase 2: Parallel seed selection</head><p>APPAGATO emulates the Gibbs sampling to select the K seeds for the successive extension phase. The emulation relies on two parallel primitives, prefix-sum (<ref type="bibr" target="#b1">Billeter et al., 2009;</ref><ref type="bibr" target="#b16">Harris et al., 2008</ref>) and weighed random number generation (https://developer.nvidia.com/ curand), which are efficiently implemented in the literature for GPUs. Given the similarity value of each query–target node pair p xy of P jVjÂjV 0 j , APPAGATO performs the parallel prefix-sum of such values through jVj Â jV 0 j threads (i.e. one thread per similarity value). The result is a prefix-sum array, in which each element is associated to a thread and the corresponding similarity value. As an example,<ref type="figure">Figure 2</ref>shows the prefix-sum array of four threads, t 01 ; t 02 ; t 03 and t 04 , having similarity value 0:1; 0:9; 0:8 and 0.2, respectively. The array elements have been depicted through different sizes to better represent the corresponding similarity values. Then, all the threads generate a random sequence of K values in the interval ½0; P p xy  (i.e. ½0; 2 in the example). The parallel primitive for the random number generation allows the threads to share the generation seed and, as a consequence, to generate the same sequence of random values. This allows the threads to concurrently recognize whether the own boundaries in the prefix-sum array include any randomly generated value. In the example, the sequence of random values K 1 ¼ 1:25 and K 2 ¼ 0:15 leads to the pair of nodes ðv</p><formula>Q 0 ; v T 3 Þ and ðv Q 0 ; v T 2 Þ associated</formula><p>to threads t 03 and t 02 , respectively, to be selected for the extension phase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">Phase 3: Parallel extension</head><p>The extension phase has been implemented through primitives of BFS, prefix-sum, weighed random number generation over different levels of parallelism. As a first level, the K query-target nodes selected in phase 2 are mapped to thread blocks (i.e. one pair of query-target nodes per block). They are concurrently processed as follows. Given a node pair (e.g.<ref type="figure">Figure 2</ref>) the two nodes are processed in parallel by two thread warps (second level of parallelism). The two warps perform a one-step parallel BFS (third level of parallelism) on Q and T, respectively, to visit the neighbour nodes (i.e. candidate connections) of v Q 0 and v T 3. The result is two frontiers of neighbours ({v</p><formula>ðv Q 0 ; v T 3 Þ in</formula><formula>Q 1 ; v Q 2 ; v Q 4 } and {v T 0 ; v T 1 ; v T 2 ; v T 5 }</formula><p>in the example). One step of extension over Q performs through a random selection of a node (connection) from the first frontier (v Q</p><p>(Supplementary<ref type="figure">Figs S1</ref>–S3), we assess the robustness of APPAGATO over query construction (Supplementary Figs S4 and S5) and the efficiency of both sequential and parallel versions of APPAGATO (Supplementary Figs S6 and S7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Performance</head><p>For the physical interaction networks, we report the comparison results only between APPAGATO and NeMA, as RESQUE does not support such a large dataset.<ref type="figure" target="#fig_2">Figure 3</ref>shows the average running times of the two tools on the D.rerio network. In the total running time of NeMa, we distinguish the target preprocessing and the querying time. Note that APPAGATO does not perform any preprocessing step. The results show that APPAGATO is at least three times faster than NeMA in case of small queries (i.e. 4, 8, 16 nodes). The performance difference sensibly increases with larger queries. The plots clearly show that the APPAGATO running time is almost constant when increasing the query size and the number of labels. We do not report the comparison results on M.musculus and H.sapiens because, in those networks, the running time difference is even more evident (i.e. NeMa requires &gt;10 000 s for the preprocessing phase and &gt;6000 s for the execution phase, while APPAGATO always requires around 2 s). Supplementary<ref type="figure">Figure S8</ref>in Section 3 reports the details on the APPAGATO running time in all the physical interaction networks, by showing its efficiency varying the number of labels, query size and network size.<ref type="figure">Figure 4</ref>reports the comparison of APPAGATO with RESQUE on the functional interaction networks. For the sake of clarity, we do not include the NeMa results in the comparison because in this kind of networks, RESQUE outperforms NeMa. The performance of RESQUE mainly depends on the size of query and target and on the number of possible candidates for each query node. RESQUE requires, as an input, a similarity matrix between query and target nodes. Such a matrix can be partially defined and this affects the quality of the results. If the similarity matrix is fully defined, then the algorithm execution becomes infeasible (i.e. RESQUE takes hours for a single query run). Therefore, we run several tests by changing the percentage of target nodes that can match to a specific query node. Given a threshold t, we set all entries in the similarity matrix with values less than t to 0 (i.e. making them not possible candidates). We then normalized each row by the row maximum value. We chose the percentages 10%, 5% and 1% to obtain reasonable RESQUE running times (i.e. 14, 5 and 1 s, respectively. APPAGATO always requires around 0.69 s). The RESQUE running time rapidly rises as the t threshold increases. In contrast, the APPAGATO running times are always &lt;1 s.<ref type="figure">Figure 5</ref>shows a comparison of the average response costs of APPAGATO and NeMA on the D.rerio physical PPI network. We removed the duplicated matches from the results of APPAGATO to avoid the bias coming from low-cost matches. Both algorithms are executed to return the best 10, 50, 100 matches. As expected, both algorithms are highly dependent on the query size. However, there is a clear difference in their output quality. The cost of NeMa results are often close to 1, which means they involve a high number of mismatches. In contrast, the averages of the APPAGATO costs range from 0.1 to 0.55. Supplementary Figures S9 and S10 in Section 3 confirm the accuracy of APPAGATO, also on H.sapiens and M. musculus. We measured the statistical significance of the differences between the APPAGATO and NeMa performance. We computed the P-values with a Wilcoxon rank-sum test together with a false discovery rate correction for multiple testing. Supplementary<ref type="figure">Figure  S11</ref>in Section 3 shows that APPAGATO significantly outperforms NeMa. The number of tested queries having lower P-values increases as the output size becomes larger, particularly when the number of required output matches increases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Quality measurements of matches</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Querying protein complexes among different species</head><p>We compared APPAGATO and RESQUE using 10 human protein complexes taken from CORUM and queried on the functional interaction dataset composed by M.musculus, H.sapiens, Drosophila<ref type="figure">Fig. 4</ref>. Running times of APPAGATO and RESQUE on the functional interaction networks. Results are grouped by the similarity thresholds. The running time of RESQUE highly depends on the number of target nodes that can be matched with a query node (i.e. on the similarity threshold t)<ref type="figure">Fig. 5</ref>. Average costs (and their standard deviations) by taking into account the set of distinct output matches. Analysis have been performed on the physical interaction PPI of D.rerio. Results are grouped with respect to the number of target labels and query size melanogaster and S.cerevisiae networks (see<ref type="figure">Fig. 6</ref>and Supplementary<ref type="figure">Fig. S12</ref>). We test RESQUE using two similarity threshold values, 1% and 100%. RESQUE shows the main performance limitation with a similarity threshold equal to 1% on every target network, while it provides better performance by increasing the cut-off. In all cases, APPAGATO outperforms RESQUE even on the quality of the results. To confirm this, we run the Wilcoxons rank-sum tests (see Supplementary<ref type="figure" target="#fig_2">Fig. S13</ref>). For low similarity thresholds (from 1% to 10%), APPAGATO provides Pvalues close to 1 Â 10 À12. Better P-values (between 1 Â 10 À5 and 1 Â 10 À6 ) are shown when we defined the whole similarity matrix. Nevertheless, this turned out to be unfeasible from the running time point of view. Supplementary<ref type="figure">Figure S14</ref>in Section 4 shows the functional coherence of results with respect to gene ontology. We computed the average P-value for both algorithms obtained by querying the 10 protein complexes for each of the four species. APPAGATO outperforms RESQUE on every type of target networks and similarity threshold. We refer the reader to Supplementary Sections 4 and 5 (<ref type="figure">Figs S15</ref>–S17) for details and further application of APPAGATO to compare disease modules over tissue-specific protein interaction networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusions</head><p>We have developed APPAGATO, a stochastic and parallel algorithm to find approximate occurrences of a query in biological networks. APPAGATO deals with node, edge and node label mismatches. It is implemented for GPUs. The choice of such devices is motivated by their accessible costs, high-performance and widespread availability on any personal computer. All above features allow APPAGATO to compute efficiently functional and topological node similarity together with fast searching of a large number of query matching within the target graph. The results show that APPAGATO outperforms the existing tools in terms of running time and result accuracy and, unlike competitors, it scales also on large PPI networks.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>Mðv 1 ÞÞ; ðv 2 ; Mðv 2 ÞÞ;. .. ; ðv k ; Mðv k ÞÞg with k jVj, is called an approximate match with a cost C ! 0. Let Q m ¼ ðV m ; E m Þ be the subgraph of query Q that has been mapped in the match m, that is, V m ¼ fv 2 V : ðv; MðvÞÞ 2 mg and E m ¼ fðu; vÞ 2 E : ðu; MðuÞÞ 2 m ðv; MðvÞÞ 2 m ðMðuÞ; MðvÞÞ 2 E 0 g. We define V m ¼ VnV m and E m ¼ EnE m</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>The three similarity values are linearly combined in MScoreðq; tÞ ¼ Sðq; tÞ þ Dðq; tÞ þ BFS Sim ðq; tÞ and normalized to get the matching probability:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.3.</head><figDesc>Fig. 3. The running time comparison between APPAGATO and NeMa on the D.rerio PPI network, randomly labelled with 32, 64 and 250 labels. Chart values report the average time on 100 queries. Queries are grouped with respect to the number of nodes, namely 4, 8, 16, 32, 64, 128. For each query, the tools have been run to find 10, 50 and 100 matches</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>). In this context, different algorithms and tools that V C The Author 2016. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 2159 Bioinformatics, 32(14), 2016, 2159–2166 doi: 10.1093/bioinformatics/btw223 Advance Access Publication Date: 29 April 2016 Original Paper compare biological networks have been applied to predict novel protein functions (Jiang et al., 2011; Malod-Dognin and Pr zulj, 2015;</figDesc><table></table></figure>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">V.Bonnici et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="1"> in the example). For such a node, APPAGATO generates the connection profile through a one-step parallel BFS. Such a connection profile strongly affects the extension over T, which is performed as follows. Starting from all the nodes of the second frontier, APPAGATO (i) runs one step of parallel BFS (one per node), (ii) generates the connection profiles of the visited nodes and (iii) generates the connection profile similarity of each of such nodes with the connection of Q. Through an emulation of the Gibbs sampling similar to that implemented in phase 2, APPAGATO selects the new connection for T. The algorithm iterates over the new pair of nodes (i.e. connection of Q and connection T) for a total number n ¼ jVj iterations. 2.4 Datasets Physical Interaction Networks. We used the PPI networks taken from the STRING v10.0 databases (Szklarczyk et al., 2011) of three species: Mus musculus, Homo sapiens and Danio rerio. These networks differ significantly in size (number of nodes and edges) and density (i.e. the average number of neighbours per node). For each network, we used up to 250 synthetic labels and gene ontologies annotation downloaded from BioDbNet (http://biodbnet.abcc.ncifcrf. gov). This yielded 12 different PPIs (i.e. three species, each one labelled in four different ways). We constructed the queries by randomly extracting sets of 100 connected subgraphs, from each network, by varying the size of the queries up to 128 nodes. In this dataset, the similarities matrix S jVjxjV 0 j ðq; tÞ ¼ 1 if LabðqÞ ¼ LabðtÞ, otherwise is set to 0. Functional Interaction Networks. The STRING database reports, among two proteins and beside the direct physical interactions used above, indirect functional relations such as structural similarity, similarity between the transcript sequences encoding them and functional correlations. It gives a score, ranging from 0 (namely no relation is known) to 999, which combines physical and functional (i.e. co-expression data analysis) interactions. We constructed a second dataset by taking into account such a combined score. We extracted four PPI networks related to the species M.musculus, H.sapiens, D.rerio and Saccharomyces cerevisiae. We fixed the interaction score threshold at 998 to get few but highly functional related interactions within each network. As queries, we used 10 human protein complexes taken from the CORUM database (Ruepp et al., 2010). Because CORUM only reports the set of proteins belonging to a given complex, and not their interactions, we reconstructed the topology of the complex by taking into account the interactions reported in the full STRING database with respect to the H.sapiens species. Finally, we labelled target and query nodes with the protein sequences. We computed the query-target node similarities matrix S jVjxjV 0 j , by making use of CUDASW (http:// cudasw.sourceforge.net), which implements a parallel version for GPUs of the Smith-Waterman algorithm for local alignment of sequences. We normalized the matrix by row to set to 1 the maximum similarity of the target and query node. We used this dataset to investigate the biological significance of the results. The approximate subgraph matching algorithms were capable to identify functional conservation of protein complexes among different species. We refer the reader to Supplementary Section 1 and Tables S1–S2 for more details. 3 Results and discussion We compared APPAGATO with NeMA (Khan et al., 2013) and RESQUE (Sahraeian and Yoon, 2012) on both the physical and functional datasets described in Section 2.4. All the tools solve ISubGI by taking into account the query topology. Unless differently specified, with the term APPAGATO we refer to its implementation on top of CUDA. In the Supplementary, Section 2, we report details on the APPAGATO implementation and tuning of parameters Parallel and stochastic search</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>The authors thank S M E Sahraeian and Byung-Jun Yoon for all their help to use and test their software RESQUE. We thank the authors of NeMA, Arijit Khan, Yinghui Wu, Charu C. Aggarwal and Xifeng Yan for distributing their software and their prompt support to evaluate it. We thank Dr Anna Privitera for her helpful discussion on APPAGATO application. Conflict of Interest: none declared.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Network biology: understanding the cell&apos;s functional organization</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">L</forename>
				<surname>Barabasi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<forename type="middle">N</forename>
				<surname>Oltvai</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="101" to="113" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient stream compaction on wide SIMD manycore architectures</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Billeter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on High Performance Graphics</title>
		<meeting>the Conference on High Performance Graphics<address><addrLine>New Orleans, Louisiana, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="159" to="166" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Querying graphs in protein-protein interactions networks using feedback vertex set</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Blin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="628" to="635" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">On the variable ordering in subgraph isomorphism algorithms</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bonnici</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Giugno</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="issue">99</biblScope>
			<biblScope unit="page" from="1545" to="5963" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">A subgraph isomorphism algorithm and its application to biochemical data</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bonnici</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note>Suppl. . 7</note>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Topology-free querying of protein interaction networks</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Bruckner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="237" to="252" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">BFS-4K: an efficient implementation of BFS for kepler GPU architectures</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Busato</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Bombieri</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel Distrib. Syst</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1826" to="1838" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Mutual exclusivity analysis identifies oncogenic network modules</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Ciriello</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="398" to="406" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">A (sub) graph isomorphism algorithm for matching large graphs</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">P</forename>
				<surname>Cordella</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1367" to="1372" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Cormen</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge, Massachusetts</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Pathway and network analysis of cancer genomes</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Creixell</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="615" to="621" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Gpu computing for systems biology</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Dematté</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Prandi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="323" to="333" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>cited. By 56</note>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Qnet: a tool for querying protein interaction networks</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Dost</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="913" to="925" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<monogr>
		<title level="m" type="main">Method inferring the functions of longevity genes with modular subnetwork biomarkers of Caenorhabditis elegans aging</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Fortney</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Genom Biol</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">RINQ: reference-based indexing for network queries</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Gulsoy</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Kahveci</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="149" to="158" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<monogr>
		<title level="m" type="main">GPU Gems 3: Parallel Prefix Sum (Scan) with CUDA</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Harris</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<publisher>Addison Wesley Professional</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Subgraph matching with set similarity in a large graph database</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Hong</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Knowl. Data Eng</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2507" to="2521" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Discovering regulatory and signalling circuits in molecular interaction networks</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Ideker</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="233" to="240" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
	<note>Suppl. . 1</note>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Network-based auto-probit modeling for protein function prediction</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biometrics</title>
		<imprint>
			<biblScope unit="volume">67</biblScope>
			<biblScope unit="page" from="958" to="966" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<monogr>
		<title level="m" type="main">Conserved pathways within bacteria and yeast as revealed by global protein network alignment</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Kelley</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>PNAS</publisher>
			<biblScope unit="page" from="11394" to="11399" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">PathBLAST: a tool for alignment of protein interaction networks</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Kelley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="83" to="88" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">NeMa: fast graph search with label similarity</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Khan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th International Conference on Very Large Data Bases, PVLDB&apos;13. VLDB Endowment</title>
		<meeting>the 39th International Conference on Very Large Data Bases, PVLDB&apos;13. VLDB Endowment<address><addrLine>Trento, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
	<note>Riva. del Garda</note>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Detecting subtle sequence signals: a gibbs sampling strategy for multiple alignment</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Lawrence</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">262</biblScope>
			<biblScope unit="page" from="208" to="214" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">A protein–protein interaction network for human inherited ataxias and disorders of purkinje cell degeneration</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Lim</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cell</title>
		<imprint>
			<biblScope unit="volume">125</biblScope>
			<biblScope unit="page" from="801" to="814" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Biological network analysis: insights into structure and functions</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Ma</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Gao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Funct. Genomics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="434" to="442" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">L-GRAAL: Lagrangian graphletbased network aligner</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Malod-Dognin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Pr Zulj</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="31" to="2182" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">GASOLINE: a greedy and stochastic algorithm for optimal local multiple alignment of interaction networks</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Micale</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS ONE</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">98750</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Searching for repetitions in biological networks: methods, resources and tools</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Panni</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">E</forename>
				<surname>Rombo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="118" to="136" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">A chart showing the costs of the 10 protein complexes over the S.cerevisiae and H.sapiens networks. The CORUM ID of the protein complexes is reported on the x-axis. In the top charts, the similarity threshold is equal to 1%. For those reported in the bottom side the similarity matrix has not been filtered Parallel and stochastic search Pienta, MAGE: matching approximate patterns in richlyattributed graphs</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Fig</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 IEEE International Conference on Big Data</title>
		<meeting><address><addrLine>Big Data 2014, Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10-27" />
			<biblScope unit="page" from="585" to="590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Alignment of metabolic pathways</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">Y</forename>
				<surname>Pinter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="3401" to="3408" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">CORUM: the comprehensive resource of mammalian protein complexes</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Ruepp</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="497" to="501" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>Suppl. . 1</note>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">RESQUE: Network reduction using semi-Markov random walk scores for efficient querying of biological networks</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">M E</forename>
				<surname>Sahraeian</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">J</forename>
				<surname>Yoon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="2129" to="2136" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">QPath: a method for querying pathways in a proteinprotein interaction network</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Shlomi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<date type="published" when="0199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">Efficient subgraph matching on billion node graphs</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Sun</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>. VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="788" to="799" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">The STRING database in 2011: functional interaction networks of proteins, globally integrated and scored</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Szklarczyk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="561" to="568" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<analytic>
		<title level="a" type="main">SAGA: a subgraph matching tool for biological graphs</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Tian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="232" to="239" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title level="a" type="main">Periscope/gq: a graph querying toolkit</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Tian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endow</title>
		<meeting>. VLDB Endow</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="1404" to="1407" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b38">
	<analytic>
		<title level="a" type="main">GPU-BLAST: using graphics processors to accelerate protein sequence alignment</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">D</forename>
				<surname>Vouzis</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">V</forename>
				<surname>Sahinidis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="182" to="188" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b39">
	<analytic>
		<title level="a" type="main">Function–function correlated multi-label protein function prediction over interaction networks</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="322" to="343" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b40">
	<analytic>
		<title level="a" type="main">Review of biological network data and its applications</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Yu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genomics Inform</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="200" to="210" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b41">
	<analytic>
		<title level="a" type="main">Tale: a tool for approximate large graph matching</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Yuanyuan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Patel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data IEEE 24th International Conference on Engineering</title>
		<meeting><address><addrLine>Cancun, Mexico</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="963" to="972" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b42">
	<analytic>
		<title level="a" type="main">Gaddi: distance index based subgraph matching in biological networks</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Extending Database Technology: Advances in Database Technology, EDBT &apos;09</title>
		<meeting>the 12th International Conference on Extending Database Technology: Advances in Database Technology, EDBT &apos;09<address><addrLine>New York, NY</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="192" to="203" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b43">
	<analytic>
		<title level="a" type="main">G-BLASTN: accelerating nucleotide alignment by graphics processors</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Zhao</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Chu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1384" to="1391" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>