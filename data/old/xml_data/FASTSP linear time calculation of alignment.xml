
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:30+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">FASTSP: linear time calculation of alignment accuracy</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011">2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Siavash</forename>
								<surname>Mirarab</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Texas at Austin</orgName>
								<address>
									<addrLine>1616 Guadalupe Street</addrLine>
									<postCode>78701</postCode>
									<region>Austin</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Tandy</forename>
								<surname>Warnow</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Texas at Austin</orgName>
								<address>
									<addrLine>1616 Guadalupe Street</addrLine>
									<postCode>78701</postCode>
									<region>Austin</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">FASTSP: linear time calculation of alignment accuracy</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">27</biblScope>
							<biblScope unit="issue">23</biblScope>
							<biblScope unit="page" from="3250" to="3258"/>
							<date type="published" when="2011">2011</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btr553</idno>
					<note type="submission">Sequence analysis Advance Access publication October 7, 2011 Received on June 16, 2011; revised on September 21, 2011; accepted on September 29, 2011</note>
					<note>[12:45 2/11/2011 Bioinformatics-btr553.tex] Page: 3250 3250–3258 Associate Editor: John Quackenbush Contact:</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Multiple sequence alignment is a basic part of much biological research, including phylogeny estimation and protein structure and function prediction. Different alignments on the same set of unaligned sequences are often compared, sometimes in order to assess the accuracy of alignment methods or to infer a consensus alignment from a set of estimated alignments. Three of the standard techniques for comparing alignments, Developer, Modeler and Total Column (TC) scores can be derived through calculations of the set of homologies that the alignments share. However, the brute-force technique for calculating this set is quadratic in the input size. The remaining standard technique, Cline Shift Score, inherently requires quadratic time. Results: In this article, we prove that each of these scores can be computed in linear time, and we present FASTSP, a linear-time algorithm for calculating these scores. Even on the largest alignments we explored (one with 50 000 sequences), FASTSP completed &lt;2 min and used at most 2 GB of the main memory. The best alternative is QSCORE, a method whose empirical running time is approximately the same as FASTSP when given sufficient memory (at least 8 GB), but whose asymptotic running time has never been theoretically established. In addition, for comparisons of large alignments under lower memory conditions (at most 4 GB of main memory), QSCORE uses substantial memory (up to 10 GB for the datasets we studied), took more time and failed to analyze the largest datasets. Availability: The open-source software and executables are available online at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Estimation of multiple sequence alignments for molecular datasets is fundamental to many problems in biology, including the prediction of protein function and structure and phylogeny estimation. Estimated alignments are often compared with other alignments in order to assess accuracy or to determine the features shared by two or more alignments. In addition, since different alignment methods can produce alignments that differ enough to introduce phylogenetic uncertainty (<ref type="bibr" target="#b44">Wong et al., 2008</ref>) and alignment error increases with the size of the dataset (<ref type="bibr" target="#b29">Liu et al., 2009</ref><ref type="bibr" target="#b30">Liu et al., , 2010</ref>), the use of several alignments, and comparisons of these alignments, is advisable for large-scale phylogenetic studies. * To whom correspondence should be addressed.</p><p>Of the various methods for comparing an estimated alignment to a reference alignment, four are generally in use: the Developer score (also called the SP-score, for sum-of-pairs), Modeler score, Total Column score and Cline Shift Score. The SP-score and Modeler scores are quite similar: the SP-score is the percentage of the homologies in the reference alignment that appears in the estimated alignment, and the Modeler score is the percentage of the homologies in the estimated alignment that appears in the reference alignment. Thus, each can be obtained by computing the number of shared homologies and then normalizing by either the number of homologies in the reference or true alignment. The Total Column score is the number of alignment columns shared by both alignments, and can also be normalized by the number of columns in one of the alignments. Finally, the Cline Shift Score (<ref type="bibr" target="#b18">Cline et al., 2002</ref>) is computed by averaging the Cline Shift scores for each of the induced pairwise alignments. Each of these normalized scores ranges from 0% to 100%, with 0 indicating that the two alignments are maximally dissimilar for the criterion and 100% indicating that the two alignments are considered identical with respect to the criterion. Thus, these scores represent accuracy measures, and complementing these scores (subtracting them from 100%) produces the corresponding error metrics. While several methods have been developed for comparing alignments, only qscore (<ref type="bibr" target="#b20">Edgar, 2004</ref>) and Lobster (available online at http://www.drive5.com/qscore and http://www.drive5 .com/lobster, respectively) correctly compute the SP-score. However, the computational complexity of these methods—i.e. their asymptotic running time—has never been established. Clearly, all four scores can be computed in quadratic time using bruteforce techniques, and the Cline Shift Score (by definition) requires quadratic time. However, the SP-score, Modeler score and Total Column scores might not require quadratic time. In this article, we show that the SP-score, Modeler score and Total Column scores can each be computed in linear time<ref type="bibr">[i.e. in O(nk)</ref>time where n is the number of sequences and k is the length of the longer alignment]. We present a method, FastSP, to compute the number of shared homologies between two alignments and prove that it runs in linear time. The result then follows, since each of the three scores can be obtained directly from this number. Since error scores are complements of these accuracy scores, FastSP can be used to compute error rates such as SP-FN (the percentage of true homologies missing in the estimated alignment) and SP-FP (the percentage of predicted homologies that are not present in the true alignment). Furthermore, FastSP can be used to evaluate the reliability of a given alignment with respect to a set of alignments, since it enables fast all-pairs comparisons. Thus, FastSP is a basic tool for analyzing sets of multiple sequence alignments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FASTSP</head><p>Several aspects of the algorithm design lead to the linear-time complexity of FastSP. First, we represent the set of homologies defined by a single multiple sequence alignment in an auxiliary data structure, and by toggling back and forth between the two representations of the alignment, we are able to implicitly represent the common homologies between a pair of alignments in linear time. We then show that computing the number of shared homologies from that implicit representation can also be done in linear time through the use of pre-computed values. We have also taken care with the memory usage in our implementation of FastSP; as a result, our code is not only fast, but also never used more than 2 GB on any of our datasets. We found that FastSP used much less memory than qscore, the fastest competitor. Thus, while FastSP and qscore had essentially the same running time when memory is unlimited (both completing in just a few minutes on all datasets), FastSP ran much faster when analyzing large alignments when the available memory was limited to 4 GB. Thus, FastSP improved upon all current methods for computing the accuracy scores between large alignments: it reduces running time on low memory conditions, and matches running time and reduces memory usage on high memory conditions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">APPROACH</head><p>Let S be a set of n sequences over a fixed alphabet (where is arbitrary but is typically nucleotides or amino acids). Let A and A be two input alignments on S. We can define an alignment by its set of homologies, where a homology is a pair of letters from the input sequences that occur in the same site. Although the alphabet can be arbitrary, we will illustrate the definitions using nucleotides. Consider S ={s 1 ,s 2 } where s 1 = ACAT and s 2 = GA and alignment A be given by</p><formula>s 1 =−A C A T s 2 = GA −− −</formula><p>Let alignment A be given by</p><formula>s 1 = A C A T s 2 =−G A −</formula><p>Then these two pairwise alignments share no common homologies, even though both have a site that contains two A's. That is, we need to distinguish between the different occurrences of each nucleotide within each sequence. Thus, instead of writing s 1 = ACAT , we will write</p><formula>s 1 = N 1,1 ,N 1,2 ,N 1,3 ,N 1</formula><p>,4 , so that N i,j indicates that nucleotide N appears as the j-th letter of sequence s i (if we are interested in the actual nucleotides, we would save the information that N 1,1 = A,N 1,2 = C, etc.). Then the homologies defined by an alignment consist of pairs of these subscripted nucleotides. Thus,</p><formula>A ={(N 1,1 ,N 2,2 )}, and A ={(N 1,2 ,N 2,1 ),(N 1,3 ,N 2,2 )}.</formula><p>With this representation, it is clear that although both alignments contain sites that are uniformly occupied by the nucleotide A, they do not share any common homologies. This representation of an alignment as a set of homologous pairs extends to multiple alignments by taking the union of homologous pairs of each of the pairwise alignments induced by the multiple alignment. We will denote by H(A) the set of homologous pairs defined by the alignment A, and by h(A) =|H(A)|. Note that if A has R sites and r i non-gap letters in the i-th site, then h(</p><formula>A) = R i=1 r i (r i −1) 2</formula><p>. Thus, every alignment of n sequences with length R consists of O(Rn 2 ) homologous pairs. Under the assumption that the true alignment is known, the error in an estimated alignment can be defined in several ways. One of the various ways of defining this is the SP-FN error, where 'SP' stands for sum-of-pairs, and 'FN' stands for 'false negative'. Thus, the SPFN error of an estimated alignment is the number of homologous pairs in the true alignment that are missing in the estimated alignment (i.e. false negatives). Similarly, the SP-FP error is the number of pairs that are predicted to be homologous in the estimated alignment that are not present in the true alignment (i.e. false positives). Both quantities can be then normalized by the number of homologous pairs in the relevant alignment to produce a value between 0 and 1 (so that the SP-FN error is normalized by the number of homologies in the true alignment, and SP-FP is normalized by the number of homologies in the estimated alignment). As an example, suppose we have</p><formula>S ={s 1 ,s 2 ,s 3 ,s 4 ,s 5 } where s 1 = AC,s 2 = C,s 3 = A</formula><p>,s 4 = T and s 5 = G. Let alignment A on S be given by</p><formula>s 1 = AC s 2 =−C s 3 = A− s 4 = T − s 5 = G−</formula><p>We rewrite this as</p><formula>s 1 = N 1,1 N 1,2 s 2 =−N 2,1 s 3 = N 3,1 − s 4 = N 4,1 − s 5 = N 5,1 −</formula><p>The set H(A) of homologous pairs defined by A is therefore</p><formula>H(A) ={(N 1,1 ,N 3,1 ),(N 1,1 ,N 4,1 ), (N 1,1 ,N 5,1 ), (N 3,1 ,N 4,1 ), (N 3,1 ,N 5,1 ), (N 4,1 ,N 5,1 ), (N 1,2 ,N 2,1 )}.</formula><p>Note that the first site in A has four nucleotides and hence contributes six homologous pairs to this set, whereas the second site has two nucleotides and so contributes only one homologous pair to the set. Now suppose A is another alignment on the same set S given by</p><formula>s 1 = AC s 2 =−C s 3 =−A s 4 =−T s 5 = G−</formula><p>Then we rewrite A in the same way we rewrote A (using the N i,j notation), and obtain its set of homologous pairs as H(</p><formula>A ) = { (N 1,1 ,N 5,1 ), (N 1,2 ,N 2,1 ), (N 1,2 ,N 3,1 ), (N 1,2 ,N 4,1 ), (N 2,1 ,N 3,1 ), (N 2,1 ,N 4,1 ), (N 3,1 ,N 4,1 )}.</formula><p>Thus, the set of homologies shared in common between these two alignments is H(A)∩H(</p><formula>A ) = {(N 1,1 ,N 5,1 ),(N 3,1 ,N 4,1 ), (N 1,2 ,N 2,1</formula><p>)}. If we were to treat one alignment (say, A) as the true alignment, then the alignment SP-FN error for A would be the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S.Mirarab and T.Warnow</head><p>number of homologies in A missing from A , or |H(A)−H(A )|. In this particular case, that would mean that there were four missing homologies, since the two alignments shared three common homologies and A had seven homologies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ALGORITHM</head><p>Throughout this section, we will assume that we have two alignments A and A , each on n sequences, and with k the length of the longer alignment. Several brute-force approaches can be used to calculate the number of shared homologies between two alignments, and hence the true positive rate, as well as the false positive rate. For example, if each sequence has length at most L (in the unaligned form), then each alignment can be represented as a presence/absence matrix with nL rows and columns; consequently, the true positive rate thus can be calculated in O(n 2 L 2 ) time. However, we can calculate this quantity more efficiently, as we now show. We begin by defining an equivalence relation on the letters N i,j that appear in a site x of alignment A. We say that two elements of the x-th site are equivalent if they are in the same site of A. For a given site x in A and a given alignment A , there will be t equivalence classes (where an equivalence class is a maximal set of letters that are pairwise equivalent), and we let m(i) denote the cardinality of the i-th equivalence class. For example, the nucleotides that appear in site 1 in alignment A are N 1,1 ,N 3,1 ,N 4,1 and N 5,1. In this definition, N 1,1 and N 5,1 are equivalent since they appear in site 1 in A , and N 3,1 and N 4,1 are equivalent since they appear in site 2 in A. Thus, A defines an equivalence relation on these elements of two equivalence classes (one for each site in A ), each having two elements. Note then that the number of homologous pairs that are in common between A and A is the sum, over all the sites x in A, of the number of pairs of letters that appear in site x that are equivalent to each other. Furthermore, the number of such pairs contributed by an equivalence class of size z is exactly z(z−2) 2. This means we can calculate the total number of common homologies by computing the equivalence relation defined by each site in A, and the number of elements in each of the equivalence classes for that site. We now show how to do this efficiently. The first thing we do is to replace the nucleotide entries in the alignment by entries of the form N i,j (i.e. we show the indices). In fact, the indices are the only things we need to know—we do not need to know the actual nucleotides in each position of the alignment. Given this representation of the alignment, we then define an n×k matrix S<ref type="bibr">[i,j]</ref>of ordered pairs, so that S<ref type="bibr">[i,j]</ref>=(a,b) implies that N i,j appears in site a for alignment A and in site b for alignment A. If j is larger than the length of the i-th sequence (after gaps are removed), then we set S<ref type="bibr">[i,j]</ref>to (0,0). As an example, given the alignments A and A from the previous section, we have n = 5 and k = 2. For this pair of alignments, we obtain S<ref type="bibr">[1,</ref><ref type="bibr">1]</ref></p><formula>=(1,1), S[1,2]=(2,2), S[2,1]=(2,2), S[2,2]= (0,0), S[3,1]=(1,2), S[3,2]=(0,0), S[4,1]=(1,2), S[4,2]=(0,0), S[5,1]=(1,1) and S[5,2]=(0,0).</formula><p>@BULLET Step 0: we set A(j) = j(j−1) 2 for each j = 1,2,...,n. For each site x in alignment A, let b x be theSince N(x) is the number of shared homologies for site x in A, it follows that N is the total number of shared homologies. Hence the SP-FN score is H(A)-N. As an illustration, using the alignments A and A given previously, N(1) = 2, since the first site in A contains six homologous pairs, two of which are also present in A. Similarly we see that N(2) = 1. Therefore, m(</p><formula>1) = m(2) = 2. Note that A(m(1)) = A(m(2)) = A(1) = A(2) = 1, and so N(1) = A(1)+ A(2) = 1+1 = 2. A similar calculation yields N(2) = 1. Therefore, N = N(1)+N(2) = 3</formula><p>, as expected. We now show how to compute N and h(A) efficiently. Consider a fixed site x in A. We examine alignment A and write down the (at most k) sites in A for the elements of site x. Then we examine each site x in A, and write down its nucleotides. For each i,j such that N i,j appears in site 1, we examine S<ref type="bibr">[i,j]</ref>. Since N i,j appears in site x for alignment A, S<ref type="bibr">[i,j]</ref>=(x,b), and hence N i,j appears in site b in alignment A. We then write down b in the list of sites in A associated with site x. That is, we note the set Sites(x) of A s sites y that appear, and the multiplicity m(y) with which each site y appears. As an example, consider the same pair of alignments A and A , as before. We examine the first site in A, and we see N 1,1 ,N 3,1 ,N 4,1 and N 5,1. We then examine S<ref type="bibr">[1,</ref><ref type="bibr">1]</ref>,S<ref type="bibr">[3,</ref><ref type="bibr">1]</ref>,S<ref type="bibr">[4,</ref><ref type="bibr">1]</ref>and S<ref type="bibr">[5,</ref><ref type="bibr">1]</ref>. We see S<ref type="bibr">[1,</ref><ref type="bibr">1]</ref></p><formula>=(1,1),S[3,1]=(1,2),S[4,1]=(1,2)</formula><p>and S<ref type="bibr">[5,</ref><ref type="bibr">1]</ref>=(1,1). We write down the sequence 1,2,2,1, so that Sites(x) ={1,2}, and m(1) = m(2) = 2. This sequence gives us two equivalence classes, each of size two. Thus, m(1) = m(2) = 2. The algorithm will compute the following values: @BULLET List(x): the list of sites in A that appears in site x of A. This is initialized to the empty list. @BULLET m(y): a non-negative integer for the number of occurrences of y in<ref type="bibr">List(x)</ref>, for each y that appears in List(x). This is initialized to 0 for all y = 1,2,...,k. @BULLET Processed(y): a Boolean variable that indicates that we have added A(y) to N(x). This is initialized to False for all y = 1,2,...,k. @BULLET N(x): a non-negative integer that will be</p><formula>y∈List(x) A(m(y)</formula><p>). This is initialized to 0. To set all these values, we examine the site x in A. As we visit each element of site x in A, we append the site in A to List(x). Thus, for N i,j in site x of alignment A, with (a,b) = S<ref type="bibr">[i,j]</ref>, we note that a = x and b is the site in A for N i,j. We therefore append b to List(x). We initialize m(y) ← 0 for all y = 1,2,...,k, where k is the number of sites in A. We then scan List(x), and for each element y in List(x), we add 1 to m(y). At the end of the scan of List(x), all the counts m(y) are set properly, but Processed(y) is still False for every y. We process List(x) again. For each element y of List(x), if Processed(y) is False, we set N(x) ← N(x)+A(m(y)), and set Processed(y) to True. Thus, A(m(y)) is added to N(x) exactly once during the pass through List(x). As we process List(x), we can also find out whether the entire column is aligned correctly (required for TC-score). Note that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FASTSP</head><p>column x is aligned correctly in A if and only if two conditions hold. First, there should exists only one value of y for which m(y) is non-zero. If there are multiple values of y with m(y) &gt; 0, then the column x in A has been divided into multiple columns in A. Second, the number of characters in column y of A [call this quantity c(y)] should be equal to m(y). If the first condition holds but the second condition does not hold, the column in alignment A that corresponds to column x in A has some extra characters and should not be considered correctly aligned. Therefore, to compute the column score we need to check (for each column x in A) whether m(y) has non-zero values for only one y, and that c(y) = m(y). This can be easily checked while scanning elements of List(x) by keeping a count of non-zero m(y) values and by checking m(y) against c(y). Note that c(y), the number of characters in columns of A , can be easily computed and kept in memory as matrix S is being created. TC can be computed at the end by dividing the number of correctly aligned sites by the total number of sites in A. Columns that have only one non-gap character do not represent homology statements, and are ignored in the calculation of the TC-score. After processing site x, we reset all the variables to their initial values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Running time analysis:</head><p>recall that we have n sequences and the longer of the two alignments has k sites. Calculating the matrix S<ref type="bibr">[i,j]</ref>takes O(nk) time, as follows. We initialize S<ref type="bibr">[i,j]</ref>=0 for all i,j. We rewrite each alignment so that we write each nucleotide in the form N i,j. We then visit each site in A, and for each nucleotide N i,j that appears in site x we set the first element of S<ref type="bibr">[i,j]</ref>to x. We repeat this for A , and for each nucleotide N i,j that appears in site y in A we set the second element of S<ref type="bibr">[i,j]</ref>to y. The preprocessing step of the algorithm involves the calculation of A(j) for each j = 1,2,...k, and so requires O(k) arithmetic steps involving numbers up to k; thus, the preprocessing costs O(k) (since each arithmetic step has unit cost). Calculating each N(x) involves O(n) operations, and hence calculating all N(x) involves O(nk) operations. Finally, calculating</p><formula>N = k x=1 N(x) costs O(k)</formula><p>work. Thus, this algorithm costs O(nk) time, which is linear in the input size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">THE FASTSP CODE</head><p>The algorithm described above is implemented in a publicly available Java program, FastSP. The implementation has been designed to reduce the memory usage. Therefore, although FastSP keeps the reference alignment in memory as a list of strings, it does not keep the entire estimated alignment in memory; instead, it only keeps the matrix S. Also the first elements of the tuples defined for S are not necessary and therefore our implementation omits them. In addition, the number of columns in S can be reduced to the number of non-gap characters in the longest sequence in the reference alignment. Therefore, if the reference alignment has R sites and the longest sequence has L non-gap characters, then FastSP needs Ln integers (each 4 bytes) to store S, and Rn characters (each 2 bytes) to store the reference alignment. Since L ≤ R, this means that FastSP needs only O(Rn) memory, and so scales linearly with the reference alignment size, and not also with the estimated alignment size. The implementation first reads the reference alignment and saves it in memory. It then reads the estimated alignment and creates the S matrix as an n×k array of integers. Next, it iterates over the columns of the reference alignment. In each iteration, first, referring to matrix S, a data structure is created (using a Java HashMap) that for each column of the estimated alignment holds the number of letters in that column that correspond to a letter in the reference alignment column [similar to m(y) introduced before]. Then, A(x) = x(x−1) 2 is evaluated for the elements in this data structure, and the sum of these values is added to the total number (N) of shared homologies. Each iteration also computes the number of homologies in the current column of the reference alignment, and adds this value to the total number of homologies in the reference alignment h(A). In addition, we keep track of the number of correctly aligned columns (C), using the technique described earlier. Once the iterations finish, N and h(A) provide the required information to compute the SPscore and Modeler score, and C provides the information required to compute TC. We tested our implementation on many different datasets, and compared SP, Modeler and TC scores computed to the scores computed using existing tools. For every case where there was a disagreement between our scores and those produced by other software, we were able to find a bug in existing tools (as described later in the article).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PERFORMANCE STUDY</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Datasets</head><p>We studied the performance of the proposed algorithm on a variety of datasets, both simulated and biological (see<ref type="figure" target="#tab_1">Table 1</ref>for the dimensions of a representative sample of the alignments on each of these datasets). Our datasets were selected to span a wide range of alignment sizes, from 100 to 78 000 sequences. We used four simulated nucleotide datasets, three with 100, 500 and 1000 taken from<ref type="bibr" target="#b29">Liu et al. (2009)</ref>and one much larger dataset with 78 000 sequences from<ref type="bibr" target="#b37">Price et al. (2010)</ref>; these are all available online at http://www.cs.utexas.edu/users/phylo/datasets/ (<ref type="bibr" target="#b30">Liu et al., 2010</ref>). For the biological datasets, we included the datasets used in<ref type="bibr" target="#b29">Liu et al. (2009)</ref>, taken from the Gutell Comparative Ribosomal Website (CRW) (http://www.rna.ccbb.utexas.edu/). For each of these datasets, we have a curated alignment based upon confirmed secondary (and higher order) structures, which is highly reliable. We also included another nucleotide alignment with 50 000 sequences, 16S.GG-50K, which is a random sample from a dataset of 237 882 sequences obtained from the Green Genes database (<ref type="bibr" target="#b19">DeSantis et al., 2006</ref>), and studied previously (<ref type="bibr" target="#b37">Price et al., 2010</ref>). On every dataset, we obtained at least one (typically more than three) estimated alignments and a reference alignment. On the biological datasets, in all but one case we used an available curated alignment as the reference. In the case of 16S.GG-50k, no curated alignment was available; however, the original publication of this dataset includes an automatically created alignment (<ref type="bibr" target="#b37">Price et al., 2010</ref>), which we used as our reference alignment. On the simulated datasets, we used the true alignment as the reference alignment. In total, our study involves the calculation of alignment scores for 75 pairs of alignments, one estimated and one reference alignment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Alignment methods</head><p>We included alignments estimated on these datasets using SATé (<ref type="bibr" target="#b29">Liu et al., 2009</ref><ref type="bibr" target="#b31">Liu et al., , 2011</ref>), MAFFT (<ref type="bibr" target="#b23">Katoh and Toh, 2008</ref>), MAFFTPartTree (<ref type="bibr" target="#b22">Katoh and Toh, 2007</ref>), Muscle (<ref type="bibr" target="#b20">Edgar, 2004</ref>), Prank+GT (<ref type="bibr" target="#b29">Liu et al., 2009;</ref><ref type="bibr" target="#b32">Loytynoja and Goldman, 2005</ref>), Opal (<ref type="bibr" target="#b43">Wheeler and Kececioglu, 2007</ref>) and ClustalW in its default and Quicktree versions (<ref type="bibr" target="#b42">Thompson et al., 1994</ref>). MAFFT-PartTree and ClustalWQuicktree methods are specifically designed to be used on very large datasets. Most of the alignments used in this article are available from the original studies. In addition, we obtained the following alignments. On 16S.GG-50k, we produced a PartTree alignment, and we produced SATé-II<ref type="bibr" target="#b31">[Liu et al., (2011)</ref>] alignments on the 16S.B.ALL, 16S.T and 16S.3 datasets. The alignment on the simulated dataset Price-78K is also one of the datasets obtained from<ref type="bibr" target="#b30">Liu et al. (2010)</ref>. For the other simulated datasets, we ran MAFFT, ClustalW (in its default setting) and SATé-II (in its default setting) to obtain estimated alignments. These additional alignments were produced using ClustalW version 2.0.4 (downloaded from http://www.ebi.ac.uk/Tools/msa/clustalw2/), MAFFT version 6.240 (downloaded from http://mafft.cbrc.jp/alignment/software/) and SATé-II version 1.22 (downloaded from http://phylo.bio.ku.edu/ software/sate/sate.html). In the commands for each method, given below, &lt;input&gt; is a FASTA-formatted input file containing unaligned sequences and &lt;output&gt; is the resulting FASTAformatted output file. @BULLET ClustalW: clustalw2-align-infile=&lt;input&gt;-outfile=&lt;output&gt;-output=fasta @BULLET MAFFT: mafft –localpair –maxiterate 1000 –quiet &lt;input&gt; &gt; &lt;output&gt; @BULLET MAFFT-PartTree: mafft –parttree –retree 2 –partsize 1000 &lt;input&gt; &gt; &lt;output&gt; @BULLET SATé: python run_sate.py-i &lt;input&gt;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Methods for calculating the SP-score</head><p>There are a few existing programs that compute the SP-score, or can be modified to compute this. However, not all software claiming to compute the SP-score actually calculates it correctly. For example, although bali_score is widely used, it is now known (<ref type="bibr" target="#b17">Bla˙ zewicz et al., 2009</ref>) that this calculation is incorrect in some cases: bali_score ignores sites that have &gt;20% gaps and also ignores sites that have a gap in the first sequence (<ref type="bibr" target="#b17">Bla˙ zewicz et al., 2009</ref>). Our study used three programs in addition to FastSP to compute SP-scores: qscore (<ref type="bibr" target="#b20">Edgar, 2004</ref>) (also known as the PREFAB Q-score, and downloaded from http://www.drive5.com/qscore), Lobster (downloaded from http://www.drive5.com/lobster) and BigMatrix (<ref type="bibr" target="#b30">Liu et al., 2010</ref>) (downloaded from http://www .cs.utexas.edu/users/kliu/public/BigDataMatrix.java). Lobster is a precursor to qscore, and BigMatrix implements a brute-force quadratic time algorithm for the SP-score; these are included in our experiments for completeness, but the main focus of the study is comparing qscore and FastSP. Our initial attempts to run qscore on large datasets failed (i.e. Q-scores &gt;1 were produced). After corresponding with the author, we were able to diagnose the problem as an integer overflow, which we then solved by changing the code to use 64 bit integers (more precisely, we added the following line to fastq.cpp: #define unsigned int64_t). By default, qscore computes SP-and TC-scores, both of which by FastSP is computed as well. However, there is a problem with the way qscore calculates the TC-score. Consider the two alignments given byHere, we have four correctly aligned columns (1,3,4 and 5) and therefore correct TC-score is 0.67. qscore, however, considers the number of correctly aligned columns to be 5, giving 0.83 for TCscore. qscore considers column 2 as correctly aligned, persumably</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FASTSP</head><p>because all homologies in A are present in the same column in alignment A. It seemingly ignores the fact that column 2 of alignment A has an extra character. FastSP avoids this problem by making sure the associated column in the estimated alignment does not contain extra characters. qscore can also compute the Modeler score if run with extra options, but for reasons that are not clear to us, qscore runs much slower when computing Modeler score (see the line labeled 'qscore-modeler' in<ref type="figure" target="#fig_7">Fig. 3</ref>). Also, qscore can compute Cline Shift Score (<ref type="bibr" target="#b18">Cline et al., 2002</ref>) if run with extra options, but that uses a different part of the qscore code that runs in quadratic time. We present results comparing qscore, qscore-modeler, Lobster, BigMatrix and FastSP for calculations of the SP-score. We used the following commands: @BULLET qscore: qscore-test &lt;estimated alignment&gt;-ref &lt;reference alignment&gt; @BULLET qscore-modeler: qscore-modeler-test &lt;estimated alignment&gt;-ref &lt;reference alignment&gt; @BULLET Lobster: lobster-score &lt;estimated alignment&gt;-ref &lt;reference alignment&gt; @BULLET BigMatrix: java-Xmx3500m BigDataMatrix-v &lt;reference alignment&gt;-f &lt;estimated alignment&gt;-sp @BULLET FastSP: java-Xmx2000m FastSP-e &lt;estimated alignment&gt;-r &lt;reference alignment&gt;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Evaluation procedure</head><p>We compared FastSP and qscore under three conditions—64bit machines with 2 GB, with 4 GB or with 8–32 GB of the main memory. We also ran Lobster and BigMatrix on the 8–32 GB machines as well. In our first experiment, we performed the analyses on a dedicated 64-bit Linux machine, each with 4 GB of main memory. The subsequent experiments were performed on a heterogeneous Condor cluster (<ref type="bibr" target="#b28">Litzkow et al., 1988</ref>). We compared the SP-scores calculated by different programs to make sure they were identical. After the modification to qscore to ensure that it runs on all datasets, qscore, BigMatrix, Lobster and FastSP all produced the same SP-scores on all the datasets on which they were able to run. We also gathered data regarding the peak memory usage and the running time of each execution, as reported in the next section. We note that small differences in running times should not be considered significant, due to the conditions in which the experiments were run: heterogeneous machines with varying amounts of main memory (unless limited by JVM), and on machines that were being used by other processes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">First experiment: 4 GB machines</head><p>We begin with a discussion of performance on machines with 4 GB of main memory.<ref type="figure" target="#fig_4">Figure 1</ref>shows the running time as a function of the number of cells in the two alignments together, where 'cells' are the nucleotides and gaps; therefore, the number of cells is n(k 1 +k 2 ),where each alignment is on n sequences and the first alignment has k 1 sites and the second alignment has k 2 sites. Note that qscore failed to score the largest dataset, 16S.GG.50k, with 50 000 sequences, while FastSP successfully completed all analyses. For the remaining datasets, qscore and FastSP were equally fast on the smallest of these datasets, but FastSP was computationally more efficient than qscore on the larger datasets. In particular, on the largest of the datasets on which both methods ran, qscore took &gt;5 min and FastSP finished in &lt;1 min. Averaging over all 27 datasets with more than 10 million cells, and excluding the cases where qscore fails, the running times were 0.54 and 0.25 min and memory usages were 1.38 GB and 502 MB, respectively, for qscore and FastSP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Second experiment: 2 GB machines</head><p>We then examined the running time on machines with 2 GB of main memory (<ref type="figure" target="#fig_6">Fig. 2</ref>). As expected, qscore failed to complete the analysis of the 16S.GG.50k dataset, but it also failed to complete analyses of three pairs of alignments on the 16S.B.ALL dataset, which has 27 643 sequences. In contrast, FastSP completed its analyses of all the datasets under these conditions. Thus, reducing the memory from 4 GB to 2 GB resulted in more failures for qscore. Averaging over all 27 datasets with more than 10 million cells, and excluding the cases where qscore fails, qscore and FastSP took 1.18 and 0.21 min and used 931 MB and 366 MB of memory, respectively. Also, FastSP never used &gt;3 min on any dataset, while qscore used 6 min on one of the larger datasets. All these results were obtained on 64 bit machines.with only 2 GB of main memory. We also reduced the memory available to JVM by changing JVM's-Xmx option. FastSP was able to successfully run on the 16S.GG.50k dataset using 1.47 GB of memory in 2.7 min. It also finished in 1.3 min using 865 MB of memory for 16S.B.ALL/PARTTREE, and 0.5 min and 773 MB of memory for 16S.B.ALL/SATé-II. The running times under these low JVM memory conditions are close to the running times reported on the 64 bit cluster machines, and indicate the robustness of FastSP to conditions with limited memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S.Mirarab and T.Warnow</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Third experiment: large memory machines</head><p>Our third experiment compared FastSP to all three other methods (Lobster, BigMatrix and qscore) on machines with 8–32 GB of the main memory (<ref type="figure" target="#fig_7">Fig. 3</ref>). Although FastSP and qscore succeeded in completing all their analyses, Lobster and BigMatrix failed on several datasets. In particular, Lobster failed to analyze 14 of the largest datasets, including all alignments on 16S.T, Price-78K, 16S.GG.50k, and most alignments on 16S.B.ALL and on 16S.3, while BigMatrix failed to analyze the two largest datasets, Price78K and 16S.GG.50K.<ref type="figure" target="#fig_7">Figure 3</ref>shows the running time, given in log scale, as a function of the total number of cells in both alignments together, as well as the regression line in log space for each method. In these analyses, we show results for qscore computing the default scores (SP and TC) and then also computing the Modeler score (indicated by qscoremodeler). Lobster was the slowest of the three methods, and BigMatrix was clearly much slower than either qscore or FastSP. FastSP and qscore took about the same time, and their running times increased at about the same rate. When qscore is run so that it computes the modeler score, it runs much slower, and its running time is not linear. Figures 4 and 5 provide a direct comparison of qscore and FastSP with respect to running time and peak memory usage,respectively, with qscore computing only the default scores (SP and TC). While the running times of FastSP and qscore were close, their peak memory usage differed substantially. These data show that the memory requirement of qscore scaled linearly with the total number of cells in both alignments, reaching 10 GB on the largest dataset. In contrast, the memory usage of FastSP grew more slowly. In the extreme case of the 16S.GG.50k dataset, qscore used 10 GB of peak memory, but FastSP never used more than 2 GB of peak memory.<ref type="figure">Fig. 5</ref>. Comparison of FastSP and qscore-default with respect to peak memory usage on machines with 'at least' 8 GB of main memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Page: 3257 3250–3258</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>FASTSP</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">DISCUSSION</head><p>The main observations we can make are these. When run on machines with sufficient memory (at least 8 GB for these datasets we studied), FastSP and qscore have very close running times, but qscore has higher peak memory usage. Thus, even though the two methods are not distinguishable by running time in this case, they differ substantially in terms of memory usage. On the other hand, when memory is limited to 4 GB, the two methods have substantially different running times for large alignments. Thus, in general the two methods cannot be distinguished on alignments with small numbers of taxa, but are distinguished on large alignments— either with respect to running time (if memory is limited to 4 GB) or with respect to memory usage (when memory is not limited). Although the methods have different running times, it is evident that the differences in running time are a result of differences in their memory usage. But, why do we see these differences? Recall that FastSP has memory usage that grows only linearly with the reference alignment size, and does not need to keep the estimated alignment in memory; this can reduce the memory usage substantially. The most likely explanation is a simple one: qscore uses more memory simply because it was not implemented with memory usage optimization as one of its objectives.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSIONS</head><p>This article has two main contributions. First, we provide a proof that the number of shared homologies between two alignments can be computed in O(nk) time, where n is the number of sequences and k is the length of the longer alignment. Therefore, the SP-score, Modeler Score and Total Column scores can each be computed in linear time as well. Second, we present FastSP, a new linear-time method to compute these three scores, and we explore its performance on large alignments in comparison to the current best method, qscore. The implementation we provide runs efficiently and requires very little memory: even on the very largest alignments with 50 000 sequences and thousands of sites, FastSP finished in &lt;2 min and used less than 2 GB of main memory. The best of the other methods for computing the SP-score is qscore. The comparison between FastSP and qscore shows that the two methods have roughly the same running time when run on large memory machines with 8–32 GB of main memory [thus suggesting that qscore also runs in O(nk) time], but qscore uses much more memory than FastSP on the largest dataset. In addition, when run on lower memory machines (e.g. on machines with only 4 GB of memory), qscore will fail to analyze some datasets, and will require more time than FastSP to analyze the largest datasets. Our results show that the memory usage of qscore when comparing pairs of large alignments can be quite large, using at least a few gigabytes (and in one case, using 10 GB) of peak memory, whereas FastSP never used more than 2 GB of peak memory. While this level of memory usage may not have a substantial impact for a single comparison, when several pairwise comparisons are desired, either very large memory machines or sequential pairwise analyses will be needed. In contrast, many pairwise comparisons can be run using FastSP on a single machine. There are several applications where many pairwise comparisons between alignments would be made. One obvious application is evaluating sequence alignment methods [a problem that is very important for many applications (<ref type="bibr" target="#b16">Aniba et al., 2010)]</ref>. In addition, the phylogenetics research community is increasingly aware of the importance of considering many different alignments (<ref type="bibr" target="#b24">Kemena and Notredame, 2009</ref>) and the impact of 'alignment uncertainty' on phylogenetic estimation (<ref type="bibr" target="#b44">Wong et al., 2008</ref>). In addition, rather than using one alignment technique, current molecular phylogenetics studies often explore a number of different alignments for each dataset. These alignments can be obtained directly using methods such as SATé or BAliPhy (<ref type="bibr" target="#b40">Suchard and Redelings, 2006</ref>) that explore alignment space, or using many different alignment methods. Once the set of alignments is obtained, they can be used to estimate an alignment [as in TCoffee (<ref type="bibr" target="#b34">Poirot et al., 2003</ref>) and MCoffee (<ref type="bibr" target="#b33">Moretti et al., 2007)]</ref>, to produce a consensus alignment (<ref type="bibr" target="#b35">Prasad et al., 2003</ref><ref type="bibr" target="#b36">Prasad et al., , 2004</ref>) or to evaluate the support for each homology within an alignment (<ref type="bibr" target="#b25">Kim and Ma, 2011;</ref><ref type="bibr" target="#b26">Landan and Graur, 2008</ref>). These meta-analyses can then be used to improve biological inferences, such as predicting function (<ref type="bibr" target="#b38">Satija et al., 2009</ref>). Alignments can also be compared with each other in order to train alignment estimation methods so that they produce more accurate alignments (<ref type="bibr" target="#b27">Lee et al., 2007</ref>). Thus, real-world applications exist in which many pairwise comparisons between alignments are made. Furthermore, large phylogenetic analyses are becoming the norm, and datasets with tens of thousands of taxa (such as we studied in this article) are being analyzed [e.g.<ref type="bibr" target="#b21">Goloboff et al. (2009);</ref><ref type="bibr" target="#b39">Smith et al. (2009)]</ref>. Therefore, methods, such as FastSP that can compare alignments in a time-and memory-efficient manner, are bioinformatics tools that are likely to have increasing importance for future phylogenetic analyses. Future work will seek to integrate FastSP into other software, such as alignment visualization tools or methods that annotate alignments using a set of alignments.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>[12:45 2/11/2011 Bioinformatics-btr553.tex] Page: 3251 3250–3258</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>[12:45 2/11/2011 Bioinformatics-btr553.tex] Page: 3253 3250–3258</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.1.</head><figDesc>Fig. 1. Log-scaled running time on machines with 4 GB of main memory. qscore is run only in default setting, and so computes only SP-and TCscores. Note that qscore fails to analyze the largest dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>FastSP, however, can analyze very large datasets on 32 bit desktop machines with even less memory available. To demonstrate this observation, we picked our three largest datasets (16S.GG.50k, 16S.B.ALL/PARTTREE and 16S.B.ALL/SATé) and ran FastSP on those datasets on a desktop of 32 bit 3.16 GHz machine Page: 3256 3250–3258</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.2.</head><figDesc>Fig. 2. Running time of qscore and FastSP when limited to 2 GB. qscore is run in default mode, and so computes only the TC-and SP-scores. Under these conditions, qscore fails to run on some inputs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.3.</head><figDesc>Fig. 3. Log-scaled running time on machines with 'at least' 8 GB of main memory. We show qscore run in both the default setting (where it only computes SP and TC) and also to compute the Modeler score. Not all methods succeed in analyzing all datasets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.4.</head><figDesc>Fig. 4. Comparison of FastSP and qscore-default with respect to running time on machines with 'at least' 8 GB of main memory.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>number of non-gapped entries in the site. Then the number of homologous pairs in A is h(A) = x A(b x ). @BULLET Step 1: for each site x in A, let N(x) be the number of homologies in A that are shared with the x-th site in A. Thus, N(x) = t i=1 A(m(i)), where m(i) is the number of elements in the i-th equivalence class, and there are t equivalence classes. @BULLET Let N = k x=1 N(x), where k is the number of sites in A.</figDesc><table></table></figure>

			<note place="foot">© The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The SATé software used in this study depends upon Dendropy (<ref type="bibr" target="#b41">Sukumaran and Holder, 2010</ref>). We thank Robert Edgar for</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="3250" to="3258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Warnow Table 1. Datasets and their sizes Dataset n a L Ref</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Mirarab</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">MAFFT OPAL PART PRANK QUICK SATé SATé-II 100L1-R0</title>
		<imprint>
			<biblScope unit="page" from="1089" to="2287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="m">500L1-R0</title>
		<imprint>
			<biblScope unit="page" from="1110" to="4992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="m">1000L1-R0 1000 1079</title>
		<imprint>
			<biblScope unit="page">3517</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">23s</forename>
				<forename type="middle">E</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<monogr>
		<title level="m" type="main">L is the maximum number of nucleotides in any of the sequences. Ref. is the length of the reference alignment (i.e. including gaps) The rest of the columns show the length of the alignment for each estimated alignment. An empty cell indicates that the respective alignment method was not run on that particular dataset. The first four datasets are simulated datasets, while the rest are all real biological datasets</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<monogr>
		<title level="m" type="main">We have included results from two different runs of SATé-II on 16S.B.ALL dataset. The second version had a length of 8209</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="3250" to="3258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<monogr>
		<title level="m" type="main">Warnow assistance in using Lobster and qscore, and Valerie King and Bernard Moret for discussions regarding the algorithmic approach. We also thank the anonymous reviewers for their helpful suggestions</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Mirarab</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<monogr>
		<title level="m" type="main">Funding: US National Science Foundation (Grant No. DEB0733029 to S</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title level="m" type="main">Simon Guggenheim Foundation; Faculty Research Assignment award from the University of Texas</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>John</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<monogr>
		<title level="m" type="main">US National Science Foundation; Graduate Fellowship from NSERC</title>
		<imprint/>
	</monogr>
	<note>to. S.M.</note>
</biblStruct>

<biblStruct   xml:id="b14">
	<monogr>
		<title level="m" type="main">Conflict of Interest: none declared</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">REFERENCES</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Issues in bioinformatics benchmarking: the case study of multiple sequence alignment</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Aniba</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="7353" to="7363" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Some remarks on evaluating the quality of the multiple sequence alignment based on the BAliBASE benchmark</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Bla˙ Zewicz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Appl. Math. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="675" to="678" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Predicting reliable regions in protein sequence alignments</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Cline</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="306" to="314" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Greengenes, a chimera-checked 16S rRNA gene database and workbench compatible with ARB</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">Z</forename>
				<surname>Desantis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Appl. Environ. Microbiol</title>
		<imprint>
			<biblScope unit="volume">72</biblScope>
			<biblScope unit="page" from="5069" to="5072" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">MUSCLE: multiple sequence alignment with high accuracy and high throughput</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">C</forename>
				<surname>Edgar</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1792" to="1797" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Phylogenetic analysis of 73,060 taxa corroborates major eukaryotic groups</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Goloboff</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cladistics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="211" to="230" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">PartTree: an algorithm to build an approximate tree from a large number of unaligned sequences</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Katoh</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Toh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="372" to="374" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Recent developments in the MAFFT multiple sequence alignment program</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Katoh</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Toh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="286" to="298" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Upcoming challenges for multiple sequence alignment methods in the high-throughput era</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Kemena</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Notredame</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2455" to="2465" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">PSAR: measuring multiple sequence alignment reliability by probabilistic sampling</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Kim</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="6359" to="6368" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Local reliability measures from sets of co-optimal multiple sequence aligments</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Landan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Graur</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Pac. Symp. Biocomput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="15" to="24" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Predicting and improving the protein sequence alignment quality by support vector regression</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Lee</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">471</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Condor-a hunter of idle workstations</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Litzkow</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference of Distributed Computing Systems</title>
		<meeting>the 8th International Conference of Distributed Computing Systems</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Rapid and accurate large-scale coestimation of sequence alignments and phylogenetic trees</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Liu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">324</biblScope>
			<biblScope unit="page" from="1561" to="1564" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Multiple sequence alignment: a major challenge to large-scale phylogenetics</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Liu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Curr. Tree Life</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">1198</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">SATé-II: very fast and accurate simultaneous estimation of multiple sequence alignments and phylogenetic trees</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Liu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>in. press</note>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">An algorithm for progressive multiple alignment of sequences with insertions</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Loytynoja</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Goldman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="10557" to="10562" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">The M-Coffee web server: a meta-method for computing multiple sequence alignments by combining alternative alignment methods</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Moretti</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="645" to="648" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">Tcoffee@igs: a web server for computing, evaluating and combining multiple sequence alignments</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Poirot</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="3503" to="3506" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">Consensus alignment for reliable framework prediction in homology modeling</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Prasad</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1682" to="1691" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<analytic>
		<title level="a" type="main">Consensus alignment server for reliable comparative modeling with distant templates</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Prasad</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="50" to="54" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title level="a" type="main">FastTree 2: approximately maximum-likelihood trees for large alignments</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">N</forename>
				<surname>Price</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">9490</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b38">
	<analytic>
		<title level="a" type="main">BigFoot: Bayesian alignment and phylogenetic footprinting with MCMC</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Satija</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Evol. Biol</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">217</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b39">
	<analytic>
		<title level="a" type="main">Mega-phylogeny approach for comparative biology: an alternative to supertree and supermatrix approaches</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">A</forename>
				<surname>Smith</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Evol. Biol</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b40">
	<analytic>
		<title level="a" type="main">BAli-Phy: simultaneous Bayesian inference of alignment and phylogeny</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">A</forename>
				<surname>Suchard</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">D</forename>
				<surname>Redelings</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="2047" to="2048" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b41">
	<analytic>
		<title level="a" type="main">DendroPy: a Python library for phylogenetic computing</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Sukumaran</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Holder</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1569" to="1571" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b42">
	<analytic>
		<title level="a" type="main">CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Thompson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="4673" to="4680" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b43">
	<analytic>
		<title level="a" type="main">Multiple alignment by aligning alignments</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">J</forename>
				<surname>Wheeler</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Kececioglu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="559" to="568" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b44">
	<analytic>
		<title level="a" type="main">Alignment uncertainty and genomic analysis</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">M</forename>
				<surname>Wong</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">319</biblScope>
			<biblScope unit="page" from="473" to="476" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>