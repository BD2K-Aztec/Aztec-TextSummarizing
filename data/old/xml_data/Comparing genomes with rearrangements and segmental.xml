
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:36+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Comparing genomes with rearrangements and segmental duplications</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Mingfu</forename>
								<surname>Shao</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Bernard</forename>
								<forename type="middle">M E</forename>
								<surname>Moret</surname>
							</persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">School of Computer and Communication Sciences</orgName>
								<orgName type="institution">EPFL</orgName>
								<address>
									<postCode>CH-1015</postCode>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Introduction</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Comparing genomes with rearrangements and segmental duplications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btv229</idno>
					<note>*To whom correspondence should be addressed.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Large-scale evolutionary events such as genomic rearrange.ments and segmental duplications form an important part of the evolution of genomes and are widely studied from both biological and computational perspectives. A basic computational problem is to infer these events in the evolutionary history for given modern genomes, a task for which many algorithms have been proposed under various constraints. Algorithms that can handle both rearrangements and content-modifying events such as duplications and losses remain few and limited in their applicability. Results: We study the comparison of two genomes under a model including general rearrangements (through double-cut-and-join) and segmental duplications. We formulate the comparison as an optimization problem and describe an exact algorithm to solve it by using an integer linear program. We also devise a sufficient condition and an efficient algorithm to identify optimal substruc-tures, which can simplify the problem while preserving optimality. Using the optimal substructures with the integer linear program (ILP) formulation yields a practical and exact algorithm to solve the problem. We then apply our algorithm to assign in-paralogs and orthologs (a necessary step in handling duplications) and compare its performance with that of the state-of-the-art method MSOAR, using both simulations and real data. On simulated datasets, our method outperforms MSOAR by a significant margin, and on five well-annotated species, MSOAR achieves high accuracy , yet our method performs slightly better on each of the 10 pairwise comparisons. Availability and implementation:</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In addition to the point mutations (single base-pair substitutions, insertions and deletions), in the course of evolution, genomes also undergo many large-scale events, which are usually divided into two categories, rearrangements and content-modifying events. Genome rearrangements include inversions, transpositions, circularizations and linearizations, all of which act on a single chromosome, and translocations, chromosomal fusions and fissions, which act on two chromosomes. Rearrangements can shuffle the order and switch the transcriptional orientations of the genes on chromosomes but cannot change the number of gene copies. On the other hand, the content-modifying events, which include segmental duplications, tandem duplications, gene insertions and losses, can affect the copy number of the genes. These two types of large-scale events are ubiquitous in the tree of life and have been shown playing a very important role in the variations of the individual traits. The molecular mechanisms behind them, although have been widely studied, are still very diverse<ref type="bibr">[see Gu et al. (2008)</ref>for a review]. One basic task of comparative genomics is to infer the events took place in the evolutionary history for the extant species. Many combinatorial optimization problems aiming to compute the most parsimonious number of events between two given genomes (i.e. the edit distance) are formulated, and many algorithms, heuristics or exact ones, are proposed for them. When only rearrangement events are considered,<ref type="bibr" target="#b23">Hannenhalli and Pevzner (1995)</ref>gave the first polynomial-time algorithm to compute the inversion distance, which was later improved to linear time (<ref type="bibr" target="#b11">Bader et al., 2001</ref>).<ref type="bibr" target="#b51">Yancopoulos et al. (2005)</ref>proposed a universal operation, called double-cut-andjoin (DCJ), which can unite most of the rearrangement events. Under the DCJ model, the edit distance can also be computed in linear time, but in a more simple and elegant way (<ref type="bibr" target="#b13">Bergeron et al., 2006</ref>). Because of its simplicity, DCJ model has formed the basis for the following algorithmic research on rearrangements (<ref type="bibr" target="#b14">Bergeron et al., 2009;</ref><ref type="bibr" target="#b17">Chen, 2010;</ref><ref type="bibr" target="#b48">Moret et al., 2013</ref>). All of the above efficient algorithms assume that genomes do not contain duplicated genes. In the presence of duplicated genes, most V C The Author 2015. Published by Oxford University Press.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i329</head><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/4.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com<ref type="bibr">Bioinformatics, 31, 2015</ref>, i329–i338 doi: 10.1093/bioinformatics/btv229 ISMB/ECCB 2015 of the edit distance problems are NP-hard. For two genomes with duplicated genes,<ref type="bibr" target="#b18">Chen et al. (2005)</ref>proposed an efficient heuristic to compute the inversion distance by decomposing the problem into two new optimization problems.<ref type="bibr" target="#b50">Shao et al. (2014)</ref>devised an exact algorithm to compute the DCJ distance by formulating the problem as an integer linear program. Both of the methods output a one-toone correspondence between the homologous genes and thus can be applied to assign orthologs. When only content-modifying events are considered, Kahn and Raphael (2008) devised an efficient dynamic programming algorithm to compute the duplication distance, which was later extended by introducing likelihood techniques and then applied to reconstruct the evolutionary history of the segmental duplications in human genome (<ref type="bibr" target="#b47">Kahn et al., 2010</ref>).<ref type="bibr" target="#b45">Holloway et al. (2013)</ref>proposed an alignment approach to reconstruct the ancestral genome for two genomes with segmental duplications and gene losses and applied it in a phylogenetic context to infer the evolution of the stable RNA gene content and organization in various genomes. When both rearrangements and content-modifying events are considered, El-Mabrouk (2001) proposed an efficient algorithm to compute the edit distance for inversions and deletions.<ref type="bibr" target="#b15">Braga et al. (2010</ref><ref type="bibr" target="#b16">Braga et al. ( , 2011</ref>) gave a linear time algorithm to compute the edit distance for DCJs, insertions and deletions. Notice that these algorithms also assume that the given genomes do not contain duplicated genes. Shao and Lin (2012) gave a 1.5-approximation algorithm to compute the edit distance for two genomes in the presence of duplicated genes under a model that includes DCJs, singlegene insertions and single-gene deletions.<ref type="bibr" target="#b21">Fu et al. (2007)</ref>extended the heuristics in<ref type="bibr" target="#b18">Chen et al. (2005)</ref>to unite rearrangements and single-gene duplications as a new software package, called MSOAR, which can be applied to detect in-paralogs in addition to orthologs. In this article, we compare two genomes in the presence of duplicated genes with DCJs and segmental duplications. Formally, the problem is to compute a set of segmental duplications in each genome and a bijection between the nonduplicated genes, such that the total cost of the segmental duplications and the DCJs induced by the bijection is minimized. We propose an exact algorithm for this problem by formulating it as an integer linear program. Based on studying the underlying structure of problem, we then devise an efficient preprocessing algorithm to simplify the problem while keeping the optimality. We also discuss and propose a reasonable way to balance the costs between DCJs and segmental duplications. Finally, we apply our method to assign in-paralogs and orthologs and compare its performance with MSOAR on both simulated and biological datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problem statement</head><p>We model each genome as a set of chromosomes and model each chromosome as a linear or circular list of genes. Each gene is represented by a signed (þ or –) symbol, where the sign indicates the transcriptional direction of this gene. Homologous genes are grouped into gene families. For a genome X, we use AðXÞ to denote all the gene families in X and use F(X, f) to denote the set of genes in X that come from gene family f. We say consecutive genes on one chromosome form a segment. The length of a segment s is defined as the number of genes in s, denoted by jsj. We say two segments in the same genome are independent if they do not contain the same gene. We say segments s ¼ ða 1 ; a 2 ; Á Á Á; a n Þ and t ¼ ðb 1 ; b 2 ; Á Á Á; b n Þ are homologous if a i and b i are homologous and have the same sign for all 1 i n or a i and b nþ1Ài are homologous and have the opposite sign for all 1 i n. We say segment s is possibly duplicated, if there exists segment t in the same genome such that s and t are independent and homologous. For a genome X, we use SðXÞ to denote the set of all the possibly duplicated segments in X (<ref type="figure" target="#fig_0">Fig. 1a</ref>). We say a subset S &amp; SðXÞ is independent if every two segments in S are independent. For an independent subset S &amp; SðXÞ, we use X n S to denote the new genome after removing all genes appearing in the segments in S from X. Given two genomes X and Y, we say two independent subsets S &amp; SðXÞ and T &amp; SðYÞ are consistent if X n S and Y n T have the same gene content, i.e. for each gene family f 2 AðXÞ [ AðYÞ, we have jFðX n S; f Þj ¼ jFðY n T; f Þj (<ref type="figure" target="#fig_0">Fig. 1a</ref>). In this article, we assume that the given two genomes X and Y satisfy that AðXÞ ¼ AðYÞ; otherwise we modify them by removing all the genes that are not in AðXÞ \ AðYÞ. With this assumption, there always exist two independent subsets S 2 SðXÞ and T 2 SðYÞ that are consistent. Suppose we are given two independent consistent subsets S 2 SðXÞ and T 2 SðYÞ. We denote by BðX n S; Y n TÞ the set of bijections that map each gene in X n S to a homologous gene in Y n T. If X n S and Y n T contain only singletons, i.e. we have jFðX n S; f Þj ¼ jFðY n T; f Þj ¼ 1 for all f 2 AðXÞ [ AðYÞ, then we have jBðX n S; Y n TÞj ¼ 1, and the DCJ distance between X n S and Y n T is well defined and can be computed in linear time (<ref type="bibr" target="#b13">Bergeron et al., 2006</ref>). Once a bijection B 2 BðX n S; Y n TÞ is given, we can relabel X n S and Y n T by assigning each pair of genes in B with a distinct gene family and thus results in two new genomes with only singletons. We denote by d(B) the DCJ distance between these two new genomes induced by bijection B. In this article, we study the following problem: given two genomes X and Y satisfying AðXÞ ¼ AðYÞ, and a cost function cðÁÞ, which maps each segment in SðXÞ [ SðYÞ to a positive value, compute a triple Q ¼ ðS; T; BÞ, where S &amp; SðXÞ and T &amp; SðYÞ are two independent consistent subsets and B 2 BðX n S; Y n TÞ, such that the total cost of Q, cðQÞ ¼ X s2S[T cðsÞ þ dðBÞ, is minimized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ILP formulation</head><p>We now formulate the above problem as an integer linear program. To achieve that, we first introduce the adjacency graph in Section3.1, which is the essential data structure to compute the DCJ distance. We also propose a new extension of the adjacency graph, called the extended adjacency graph, which can incorporate duplicated genes and thus forms the basis for the following ILP formulation. We then describe a capping method to remove the telomeres, in Section 3.2, which allows us only to count the number of cycles when computing the DCJ distance. On the basis of them, we finally give the ILP formulation in Section 3.3.</p><formula>(a) ( b) (c) ( d)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Adjacency graph</head><p>We first introduce some notations. The two ends of a gene a are called extremities. The head is denoted by a h and the tail is denoted by a t. The set of all extremities in genome X is called the extremity set of X, denoted by EðXÞ. If genes a and b are homologous, we also say the two corresponding extremity pairs, a h and b h , a t and b t , are homologous. Two consecutive genes a and b form one adjacency, which is represented by a set of two extremities. Thus, each adjacency comes in one of the four types: fa t ; b t g; fa h ; b t g, fa t ; b h g and fa h ; b h g. If gene a lies at one end of a linear chromosome, then this end can be represented by a set of one extremity, fa h g or fa t g, called a telomere. Suppose that we are given a triple Q ¼ ðS; T; BÞ, where S &amp; SðXÞ, T &amp; SðYÞ are two independent consistent subsets and B 2 BðX n S; Y n TÞ. We can build the adjacency graph w.r.t. Q, denoted by G(Q), as follows. We first build X n S and Y n T through removing all genes in S [ T and take all the extremities in them, i.e. EðX n SÞ [ EðY n TÞ, as the vertices of G(Q). Then for each adjacency in X n S and Y n T, we add one gray edge to connect the two extremities in it. Finally, for each pair of homologous extremities specified by B (each homologous gene pair in B specifies two pairs of homologous extremities), we add one black edge to connect them (<ref type="figure" target="#fig_0">Fig. 1a</ref>–c). Clearly, in G(Q), the degree of each vertex is at most 2, and thus it consists of a set of vertex-disjoint cycles and paths. The length of a cycle (or a path) is defined as the number of black edges in it. Let c be the number of cycles and o be the number of oddlength paths in G(Q). We have that the DCJ distance induced by B can then be computed as dðBÞ ¼ n À c À o=2, where n is the number of genes in X n S (<ref type="bibr" target="#b13">Bergeron et al., 2006</ref>). Given a triple Q ¼ ðS; T; BÞ defined above, we propose an equivalent form of G(Q), called the extended adjacency graph w.r.t. Q, denoted by G 0 ðQÞ. The set of vertices of G 0 ðQÞ includes all the extremities in X and Y, i.e. EðXÞ<ref type="bibr">[ EðYÞ.</ref>For each adjacency in X and Y, there is one gray edge connecting the two extremities in it. For each pair of homologous extremities specified by B, there is one black edge connecting them. For each gene contained in some segment in S [ T, there is one internal edge connecting the two extremities in this gene (<ref type="figure" target="#fig_0">Fig. 1d</ref>). The difference between G 0 ðQÞ and G(Q) is that, the latter one explicitly removes those extremities in the genes in S [ T, whereas the former one keeps them but adds internal edges connecting the two extremities in those genes. Clearly, G 0 ðQÞ also consists a set of vertex-disjoint cycles and paths, and there is a one-to-one correspondence between the connected components in G(Q) and that in G 0 ðQÞ. Thus, the DCJ distance induced by B can also be computed as dðBÞ ¼ n À c 0 À o 0 =2, where c 0 is the number of cycles and o 0 is the number of odd-length paths in G 0 ðQÞ, and n is the number of genes in X n S. As we will see later, this extended adjacency graph is the key point in devising the ILP formulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Add capping genes</head><p>In Shao and Lin (2012), we described a method to remove telomeres by introducing capping genes. A capping gene contains only one extremity, which combines with the adjacent telomere (or another capping gene) to form one adjacency. All capping genes are homologous to each other, forming a distinct gene family, denoted by f s. Given two genomes X and Y with l X and l Y linear chromosomes, respectively (without loss of generality, we assume that l X !l Y ), we first add one capping gene to each end of all the linear chromosomes in X and Y; then we add ðl X À l Y Þ dummy chromosomes, each of which contains only a pair of capping genes, to genome Y (<ref type="figure" target="#fig_1">Fig. 2</ref>). We denote by ^ X and ^ Y the two new genomes after adding capping genes for X and Y. Clearly, we have jFð ^ X; f s Þj ¼ jFð ^ Y ; f s Þj. Thus, given a pair of independent consistent subsets S &amp; SðXÞ and T &amp; SðYÞ, we know that ^ X n S and ^ Y n T also have the same gene content. Using the same argument as in<ref type="bibr" target="#b50">Shao et al. (2014)</ref>, we can prove that minbelongs. We say gene a is duplicated in Q Ã , if there exists one segment s 2 S Ã [ T Ã such that a 2 s and nonduplicated otherwise. We now give the ILP formulation to compute Q Ã. For each segment s 2 SðXÞ [ SðYÞ, we have one binary variable x s to indicate whether s 2 S Ã [ T Ã. For each gene a 2 X [ Y, we have one binary variable y a to indicate whether a is duplicated in Q Ã. We use the following two sets of constraints to guarantee that y a ¼ 1 if and only if there exists one segment s 2 S Ã [ T Ã such that a 2 s: y a ! x s ; 8s 2 SðXÞ [ SðYÞ and 8a 2 s; y a X s2SðXÞ[SðYÞ:a2s x s ; 8a 2 X [ Y:</p><formula>(a) ( b) (c) ( d)</formula><p>We require that these segments in S Ã [ T Ã are independent, i.e. there do not exist two of them that contain the same gene: X s2SðXÞ[SðYÞ:a2s x s 1; 8a 2 X [ Y:</p><p>We also require that X n S Ã and Y n T Ã have the same gene content, i.e. for each gene family there must be an equal number of nonduplicated genes in Q Ã in this family in each genome:</p><formula>X a2FðX;f Þ ð1 À y a Þ ¼ X b2FðY;f Þ ð1 À y b Þ; 8f 2 AðXÞ:</formula><p>And for each gene family, at least one gene is nonduplicated inFor each pair of homologous genes a 2 X and b 2 Y, we add one binary variable z a;b to indicate whether B Ã contains this pair. We require that for each gene in X [ Y, it is mapped to exactly one homologous gene in the opposite genome if and only if it is nonduplicated in Q Ã : X b2FðY;faÞ z a;b ¼ 1 À y a ; 8a 2 X;</p><formula>X a2FðX;f b Þ z a;b ¼ 1 À y b ; 8b 2 Y:</formula><p>These constraints guarantee that these pairs in B Ã form a valid bijection between the genes in X n S Ã and those in Y n T Ã. To compute dðB Ã Þ, we need to count the number of cycles in G 0 ðQ Ã Þ. We add a variable l e for each extremity e 2 EðXÞ [ EðYÞ to represent the label of e. We then assign a distinct upper bound for l e , denoted by U e (for example, we can just sort all the extremities in EðXÞ [ EðYÞ in an arbitrary order and assign U e as the index of e in the sorted list): 0 l e U e ; 8e 2 EðXÞ<ref type="bibr">[ EðYÞ:</ref>We then require that all the extremities in the same cycle in G 0 ð Q Ã Þ have the same label. This can be achieved by forcing that the two extremities connected by any edge in G 0 ðQ Ã Þ have the same label. To guarantee this, we add the following three groups of constraints, each of which corresponds to one type of edges. First, we require that the two extremities in each adjacency have the same label (these constraints correspond to the gray edges): l ei ¼ l ej ; 8fe i ; e j g form an adjacency in X or in Y: Second, we require that each pair of extremities specified by B Ã have the same label (these constraints correspond to the black edges). To achieve that, we add the following four constraints for each pair of homologous genes a 2 X and b 2 Y (if a and b are capping genes, then we have a h ¼ a t and b h ¼ b t and thus the following four constraints degenerate into two):Third, we require that the two extremities in each duplicated gene have the same label (these constraints correspond to the internal edges):</p><formula>l a h l at þ ð1 À y a Þ Á U a h ; 8a 2 X [ Y; l at l a h þ ð1 À y a Þ Á U at ; 8a 2 X [ Y:</formula><p>We then add a binary variable w e for extremity e to indicate whether l e reaches its upper bound:</p><formula>w e Á U e l e ; 8e 2 EðXÞ [ EðYÞ:</formula><p>Since all the extremities in the same cycle in G 0 ðQ Ã Þ are forced to have the same label, and all label variables have distinct upper bounds, we know that for each cycle in G 0 ðQ Ã Þ at most one extremity can have its label reaching its upper bound. Thus, we have that X e2EðXÞ[EðYÞ w e is exactly the number of cycles in G 0 ðQ Ã Þ. And dðB Ã Þ can then be computed by</p><formula>jXj À X a2X y a À X e2EðXÞ[EðYÞ w e ;</formula><p>where the first two items give the number of genes in X n S Ã. Finally, we set the objective function of the ILP as</p><formula>min X s2SðXÞ[SðYÞ cðsÞ Á x s þ jXj À X a2X y a À X e2EðXÞ[EðYÞ w e :</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Identify optimal substructures</head><p>Given two genomes X and Y after adding capping genes, we say two homologous segments s in X and t in Y form a pair of shared segments, denoted by hs; ti. Intuitively, shared segments are more likely to be nonduplicated and mapped to each other. Below, we give one sufficient condition and one algorithm to decide whether a pair of shared segments is in some optimal solution, i.e. in this optimal solution, a i and b i are nonduplicated and a i is mapped to b i , for all 1 i n. From now on, we assume that the cost function only depends on the length of the segments, i.e. we assume that if jsj ¼ jtj then we have cðsÞ ¼ cðtÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">A sufficient condition</head><p>We say gene a in genome X is isolated, if there does not exist any segment s 2 SðXÞ such that a 2 s and jsj!2. The following theorem gives a sufficient condition to decide whether a pair of shared segments of length two is an optimal substructure.Let Q ¼ ðS; T; BÞ be an arbitrary triple such that either b 1 or b 2 is duplicated in Q, or B does not contain hb 1 ; b 2 i. Below, we will show that we can always build a new triple Q 0 ¼ ðS 0 ; T 0 ; B 0 Þ in which both b 1 and b 2 are nonduplicated and B 0 contains hb 1 ; b 2 i and also verify that cðQ 0 Þ cðQÞ. Since Q is arbitrary, this proves the theorem. First, assume that in Q both b 1 and b 2 are duplicated. Let s 2 S and t 2 T be the segments containing b 1 and b 2, respectively. Since both b 1 and b 2 are isolated, we know that jsj ¼ jtj ¼ 1. Let S 0 ¼ S n fsg and T 0 ¼ T n ftg. We have that X n S 0 and Y n T 0 still have the same content. Let B 0 ¼ B [ fhb 1 ; b 2 ig. We have that dðB 0 Þ ¼ dðBÞ, since X n S 0 has one more gene than X n S, whereas GðQ 0 Þ has one more cycle than G(Q) (<ref type="figure" target="#fig_9">Fig. 3a and b</ref>). Thus, we have</p><formula>cðQ 0 Þ ¼ X u2S 0 [T 0 cðuÞ þdðB 0 Þ ¼ X u2S[T cðuÞ À cðsÞ À cðtÞ þ dðBÞ X u2S[T cðuÞ þdðBÞ ¼ cðQÞ.</formula><p>Second, assume that in Q gene, b 2 is duplicated, while b 1 is not (or symmetrically, b 1 is duplicated, while b 2 is not). Suppose that b 1 is mapped to b 3 in B, i.e. hb 1 ; b 3 i 2 B. Let S 0 ¼ S and T 0 ¼ T n ftg [ ft 0 g, where t 2 T is the segment containing b 2 and t 0 is the segment containing only gene b 3. Clearly, we also have that X n S 0 and Y n T 0 have the same content. Let B 0 ¼ B n fhb 1 ; b 3 ig<ref type="bibr">[</ref><ref type="figure" target="#fig_9">Fig. 3d and e</ref>). This implies that the number of cycles in GðQ 0 Þ is no less than that in G(Q). In addition to the fact that X n S 0 and X n S have the same number of genes, we have that dðB 0 Þ dðBÞ. Thus, we have cðQ 0 Þ ¼ X u2S 0<ref type="bibr">[</ref><ref type="bibr" target="#b50">Shao et al., 2014</ref>), we can prove that dðB 0 Þ dðBÞ. Thus, we still have cðQ 0 Þ ¼ X u2S 0 [T 0 cðuÞ þ dðB 0 Þ cðQÞ:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">An algorithm</head><p>We say a pair of shared segments p ¼ hða 1 ; a 2 ; Á Á Á ; a n Þ; ðb 1 ; b 2 ; Á Á Á ; b n Þi between genomes X and Y is half fixed, if b i is singleton for all 1 i n (and thus none of them can be duplicated) and all genes in FðX; f aiÞ are isolated for all 1 i n. Let p be such a pair of half fixed shared segments (PHFSS for short). We use AðpÞ to denote all the gene families in p, i.e. AðpÞ ¼ ff a1 ; f a2 ; Á Á Á ; f an g. In this section, we propose an algorithm to decide whether a PHFSS is in some optimal solution. Notice that for a PHFSS p, if we further know that in some optimal solution a k is mapped to b k for some 1 k n, then we can immediately conclude that the whole p is in some optimal solution by iteratively applying theorem 3.differ only on these gene families in AðpÞ. We now define a new graph to focus on AðpÞ while hiding others. Let Q be a triple and p be a PHFSS. We can build the reduced adjacency graph w.r.t. Q and p, denoted by R(Q, p), as follows. The vertices of R(Q, p) are divided into two types, the core vertices, which are exactly those extremities in the genes in the gene families in AðpÞ and the boundary vertices, which consist of these extremities that form adjacencies with core vertices (<ref type="figure">Fig. 4a and b</ref>). The edges of R(Q, p) are divided into four types, gray edges, black edges, internal edges and reduced edges. For any two vertices in R(Q, p), they are connected by gray edges or internal edges, if and only if they are connected by the same type of edge in G 0 ðQÞ. For any two core vertices in R(Q, p), they are connected by one black edge if and only if they are connected by one black edge in G 0 ðQÞ. For any two boundary vertices in R(Q, p), they are connected by one reduced edge if there exists one path connecting them in G 0 ðQÞ without going through any core vertices or boundary vertices (except its two ends). Clearly, R(Q, p) also consists of a set of vertex-disjoint cycles (Comparing genomes with rearrangements and segmental duplications i333 that corresponding to ha i ; b i i and then replace the internal edges corresponding to a i with that corresponding to a 0 i .</p><p>In summary, once we know RðQ; pÞ, i.e. whether there exists one possible path connecting them that does not go through any other core vertices or boundary vertices. Notice that this path must be alternating, i.e. the edges with odd indices must be either black edges or internal edges and the edges with even indices must be gray edges (<ref type="figure">Fig. 4c</ref>and d). There exists a linear time algorithm to decide the existence of an alternating path between two given vertices (Bang<ref type="bibr" target="#b12">Jensen and Gutin, 1998</ref>). We now adapt it for our use. Given a PHFSS p and two boundary vertices x and y, the algorithm first build a graph with V 1 [ V 2 [fx; yg as its vertices, where V 1 is the set of all extremities except all the core vertices and boundary vertices and V 2 is a copy of V 1. Two extremities in V 1 are connected by one gray edge if they form one adjacency. Two homologous extremities in V 2 in different genomes are connected by one black edge, and the two extremities in V 2 in a possibly duplicated gene are connected by one internal edge. We connect x (resp. y) to its all homologous extremities in V 2 in the opposite genome by black edges. Finally, all the counterparts between V 1 and V 2 are connected by bridging edges (<ref type="figure" target="#fig_13">Fig. 5</ref>). Clearly, all the bridging edges form a matching of size j V 1 j, denoted by M. The algorithm then computes an augmenting path w.r.t. M using the Blossom algorithm, which takes linear time. We claim that such an augmenting path exists if and only if there exists one alternating path connecting x and y without going through any core vertices or boundary vertices. In fact, if such an augmenting path exists, then the two ends of this path must be x and y, since they are the only two unmatched vertices. We claim that the edges in the augmenting path that are not in M form an alternating path connecting x and y. This is because edges in M are spanning V 1 and V 2 , whereas gray edges are all inside in V 1 and black edges and internal edges are inside in V 2. The opposite side of statement can be reasoned in a similar way. The algorithm to decide whether a given PHFSS p is in some optimal solution proceeds as follows. The first phase of the algorithm is to compute the core vertices and the boundary vertices w.r.t. p and then for each pair of boundary vertices, to check whether they can be connected by a reduced edge. If the total number of edges (reduced edges plus those among core vertices) is larger than log n, the algorithm terminates. Otherwise, the algorithm comes to the second phase. It enumerates all the possibilities of RðQ; pÞ for all the possibilities, then the algorithm concludes that p is in some optimal solution. The above algorithm runs in polynomial time. In fact, the first phase runs in polynomial-time, since we can decide the existence of a reduced edge for each pair of boundary vertices in linear time. In the second phase, the number of edges is in logarithmic-size, which implies that the number of possibilities of RðQ Ã p ; pÞ is in polynomial size. Thus, the second phase also runs in polynomial time. We remark that usually not all pairs of boundary vertices can be connected by a reduced edge (<ref type="figure" target="#fig_14">Fig. 6</ref>). In fact, if this is not the case,; pÞ contains more cycles than RðQ Ã p ; pÞ, in which case the algorithm fails. In other words, the first phase to identify possible reduced edges is very essential, which not only decreases the number of possibilities but more importantly makes the algorithm capable of identifying optimal substructures. We also remark that this algorithm is a sufficient test, i.e. if it returns 'yes', then p is guaranteed in some optimal solution. However, if it returns 'no', then it is still possible that p is in some optimal solution. This is because two reduced edges in RðQ Ã p</p><formula>(a) (b) (c) (d)</formula><p>; pÞ might not be able to coexist in G 0 ðQ Ã p Þ. We can apply the theorem in Section 4.1 and the algorithm in Section 4.2 on all shared segments to verify their optimality. If such an optimal substructure is identified, we immediately fix it and update the genomes through assigning each pair of genes in it a distinct gene family. We can iteratively repeat this process until no such optimal substructure can be found. This serves as a preprocessing algorithm to simplify the problem before calling the ILP solver. The performance of this preprocessing algorithm on real genomes is analyzed in<ref type="figure">Table 4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Set the cost</head><p>Under a parsimonious model, it is natural to set a unit cost for all segmental duplications (as we do for all DCJs). However, in this case, two segmental duplications, one in each genome, that create a pair of shared segments can be always explained as two DCJs with the same total cost. Consider the example in<ref type="figure" target="#fig_15">Figure 7a</ref>, for which we have two optimal solutions with total cost of 2: one is to regard a 2 and a 4 as duplicated genes, and the other uses two DCJs, which first cut a 2 out from X and then insert it back between c 1 and d 1. The scenario in the second case (two DCJs using one circular chromosome as intermediate) requires three inversions to explain, and therefore it is much less unlikely to happen comparing with the first scenario. Thus, to avoid the second case we set cðÁÞ &lt; 1. On the other hand, if we have cðÁÞ 0:5, then every DCJ that inverts a possibly duplicated segment can be always explained by two segmental duplications with the same or even better total cost. Consider the example in<ref type="figure" target="#fig_15">Figure 7b</ref>, for which one solution is to use only one DCJ to invert the segment ða 2 ; b 2 Þ on X. However, if we have cðÁÞ 0:5, then we can regard ða 2 ; b 2 Þ and ðÀb 4 ; Àa 4 Þ as duplicated segments, whose total cost is at most 1. Thus, to avoid the second case, we need to set cðÁÞ &gt; 0:5. Combining the above two facts, in the following experiments, we set cðÁÞ ¼ 0:75.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Infer in-paralogs and orthologs</head><p>Under a most parsimonious evolutionary scenario, the duplicated genes in the optimal triple infer the in-paralogs in each genome, whereas the bijection between the nonduplicated genes in the two genomes infers a subset of the orthology pairs [more specifically, positional orthologs (<ref type="bibr" target="#b19">Dewey, 2011)]</ref>. In the following, we apply our method to infer in-paralogs and orthologs on both simulated datasets and biological datasets and compare its performance with MSOAR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Results on simulated datasets</head><p>We simulate a pair of genomes as follows. We start from an ancestor genome with only one linear chromosome consisting of N ¼ 5000 singletons (we also test N ¼ 1000 and N ¼ 2000; the results are not presented since they agree with N ¼ 5000). We then perform S 1 segmental duplications on the ancestor genome to make some gene families contain more than one copy. A segmental duplication randomly chooses a segment of length L and inserts its copy to another random position. The two extant genomes then speciate independently from this ancestor genome. The speciation process on each branch includes randomly mixed S 2 segmental duplications and D DCJs. A DCJ randomly chooses two positions in the genome and then reverses the segment in between. We make sure that the expected number of genes per gene family in each extant genome is 1.5 (this number is comparable to that in human genome, which is 1.46), therefore we have that S 1 þ S 2 ¼ 0:5 Á N=L. We further fix S 1 ¼ 0:2 Á N=L and S 2 ¼ 0:3 Á N=L (we also test S 1 ¼ 0 and S 2 ¼ 0:5 Á N=L, and the results are almost the same). Thus, a simulation configuration is determined by parameters L and D. For each pair of simulated genomes X and Y, we take them as input to run MSOAR and our method. For MSOAR, we run its binary version downloaded from http://msoar.cs.ucr.edu/. For our method, we first apply the preprocessing algorithm described in Section 4 and then formulate the simplified problem as an ILP instance, which is solved using the GUROBI solver. We set the time limit to 2 h for each instance, i.e. if the ILP solver does not return the optimal solution in 2 h, we terminate it and return the current sub-optimal solution. Both methods return triples (S, T, B), where S and T infers the in-paralogs in the two extant genomes, respectively, and B infers the orthology pairs. We now give the measures to evaluate them. First, we regard the problem to infer in-paralogs as a standard binary classification problem: those genes that are generated by segmental duplications in the speciation process are considered as gold standard positive in-paralogs and those genes that are in the segments in S [T are considered as predicted positive in-paralogs. Thus, we use the sensitivity and specificity to measure (S, T). To evaluate the performance of B, we refer to those gene pairs in the two extant genomes that correspond to the same gene in the ancestor genome as the true orthology pairs. We therefore use the following way to evaluate B: we say a pair in B is assessable, if at least one of its two genes can be found in some true orthology pair, and the accuracy ofComparing genomes with rearrangements and segmental duplications i335 B is then defined as the ratio between the number of true orthology pairs in B and the number of assessable pairs in B. For each parameter configuration, we simulate 10 instances and compute the average sensitivity, specificity and accuracy for both methods. The performance of the two methods is shown in<ref type="figure" target="#fig_16">Figures 8</ref>–10, where the parameters L 2 f1; 2; 5g and D ranges from 250 to 2000. First, we can observe that both methods get very high sensitivity (above 90% on all configurations). However, MSOAR gets relatively low specificity. One reason for this is that MSOAR uses unit cost for both rearrangements and single-gene duplications. According to the discussion in Section 5, unit cost for all operations might misclassify in-paralogs. Second, as D increases, the performance of both methods decreases. This is because the number of DCJs is highly positively correlated to the difficulty of the problem. When D 500, i.e. roughly 10% of the size of the simulated genome (which is usually the case for real genomes, see<ref type="figure">Table 2</ref>columns d(B) for some examples), we can see that our method almost gets perfect performance. Third, observe that MSOAR is very sensitive to L even when D is very small. This might be because the evolutionary model for in-paralogs in MSOAR is single-gene duplication, which creates trouble when genomes contain long segmental duplications. Finally, our method outperforms MSOAR on all the configurations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Results on biological datasets</head><p>We compare both methods on five mammalian species, human (H.s.), gorilla (G.g.), orangutan (P.a.), mouse (M.m.) and rat (R.n.). For each species, we collect all the protein-coding genes and download their positions on the chromosomes and the Ensembl gene family names from Ensembl (http://www.ensembl.org). Two genes are considered as homologous if they have the same Ensembl gene family name. Since the tandemly arrayed genes (TAGs) have a different evolutionary model from segmental duplications, we merge each group of TAGs into only one gene through only keeping the first gene in the group while removing all the following ones. We do the pairwise comparison for all five species, and for each pair of species, we run both methods to obtain triples (S, T, B). We use the same accuracy defined in Section 6.1 to evaluate B. To compute the accuracy, we use the gene symbols (HGNC symbols for primate genes, MGI symbols for mouse genes and RGD symbols for rat genes, downloaded from Ensembl) to define true orthology pairs: those gene pairs that have the same gene symbol form the set of true orthology pairs for each pair of species. We do not have annotation data to serve as gold standard positive in-paralogs (we cannot just regard those genes that are not in the true orthology pairs as gold standard positive in-paralogs, since many genes have not yet been assigned a valid gene symbol). Thus, we are not able to compute the sensitivity and specificity of (S, T).The solid lines and dashed lines track our method and MSOAR, respectively. The circles, triangles and diamonds track L ¼ 1, L ¼ 2 and L ¼ 5, respectivelyBold values highlight larger accuracy. The last column shows the running time of MSOAR (in min).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Table 2. Comparison with MSOAR on inferred operations and total score</head><p>Species pairs jSj þ jTj d(B) Total cost MSOAR ILP MSOAR ILP MSOAR ILP The comparison on accuracy is shown in<ref type="figure" target="#tab_1">Table 1</ref>. We can observe that both methods have very high accuracy, indicating that the inferred orthology pairs from gene order data mostly agree with the annotations. On the other hand, our method gets higher accuracy than MSOAR on all the 10 pairs. The running time of MSOAR is also shown in<ref type="figure" target="#tab_1">Table 1</ref>. On average, for each instance, MSOAR takes 108 min, which is on the same level with our method (120 min for each instance). In<ref type="figure">Table 2</ref>, we compare the number of operations and total score inferred by the two methods to evaluate their ability as an optimizer. First, we can see that our method gets more segmental duplications and many fewer DCJs than MSOAR. One reason for this is that we use smaller weight for segmental duplications. Second, our method gets smaller total cost on all the 10 pairs. This shows the advantage of our exact algorithm over the heuristic applied in MSOAR. Notice that the total cost shown in<ref type="figure">Table 2</ref>is computed using our weight, i.e. dðBÞ þ 0:75 Á ðjSj þ jTjÞ, for both methods. However, if the total cost is computed using MSOAR's weight, i.e. dðBÞ þ jSj þ jTj, our method still has less total cost on all pairs. In<ref type="figure">Table 3</ref>, we analyze the distribution of the length of the inferred duplicated segments by our method. We can see that most of them are single-gene duplications. We can also observe that the rat genome contains more duplications than the other four genomes. In<ref type="figure">Table 4</ref>, we analyze the composition of B returned by our method. If a gene family is a singleton in both genomes, then this pair of genes cannot be duplicated and must be mapped to each other by definition. We call such pair a trivial pair. Observe that roughly half of the pairs in B are trivial pairs (trivial column). We also show the percentage of the pairs that are fixed through the preprocessing algorithm (predetermined column). We can see that this preprocessing algorithm is very efficient, which can fix almost all the nontrivial pairs, leaving a very small portion (remaining column) that are to be determined by the ILP. This is because these species contain many shared segments and many isolated genes (because most of the segmental duplications are single-gene duplications), and thus there are many optimal substructures that can be identified by our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion and discussion</head><p>We proposed an exact algorithm to compute a set of DCJs and segmental duplications with minimum total cost between two given genomes. As far as we know, this is the first exact algorithm to compare two genomes in the presence of duplicated genes with both rearrangements and content-modifying events. This algorithm can be applied to infer in-paralogs and orthologs, and the inferred results were showed highly agreeing with the annotations. The algorithm described in Section 4.2 has potential to extend. For example, it can be directly used to test whether a general substructure, rather than a single PHFSS, is optimal. Moreover, we made a strong assumption that all genes in the related gene families are isolated, which immediately makes the cost of the segmental duplications trivial to compare and thus allows us to focus on the number of cycles. In fact, we can relax this assumption, as long as we can guarantee that the segmental duplications induced by the substructure that is tested is optimal. Although the evolutionary model used in our algorithm, i.e. DCJ plus segmental duplication, is already quite general, there are some other events, like tandem duplications, that cannot be explained by this model. We will extend our algorithm for more general models in the future.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. (a) Two genomes X and Y. Genes in the same gene family are represented by the same symbol with different superscripts. We have SðX Þ ¼ fða 1 Þ; ða 2 Þ; ðb 1 Þ; ðb 2 Þg and SðY Þ ¼ fðc 2 Þ; ðb 3 Þ; ðc 3 Þ; ðÀb 4 Þg and S ¼ fða 2 Þg and T ¼ fðc 2 Þg are two consistent subsets. (b) The genomes X n S and Y n T and the bijection B. (c) The adjacency graph w.r.t. Q ¼ ðS; T ; BÞ. Black edges are represented by long thin lines, while gray edges by short thick lines. Head extremities are represented by circles, while tail extremities by squares. (d) The extended adjacency graph w.r.t. Q, in which internal edges are represented by double lines</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. (a) Two genomes X and Y. (b) The genomes ^ X and ^ Y after adding capping genes, where capping genes are represented by diamonds. (c) The extended adjacency graph w.r.t. (S, T, B), where S ¼ fða 2 Þg; T ¼ fðb 2 Þg and B maps a 1 , b 1 and c 1 to a 3 , b 3 and c 2 , respectively. (d) The extended adjacency graph w.r.t. ðS; T ; ^ B Þ, where ^ B consists of the two pairs mapping s 1 and s 2 to s 3 and s 4 , respectively, and those pairs in B</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>If we have a 1 and a 2 are singletons, and b 1 and b 2 are isolated, then p is in some optimal solution. i332 M.Shao and B.M.E.Moret Proof:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>fhb 1 ; b 2 ig. To compare dðB 0 Þ with d(B), consider the difference between GðQ 0 Þ and G(Q). In fact, we can transform G(Q) into GðQ 0 Þ through two DCJs on genome Y (after that we need to rename b 3 as b 2 ). We first perform one DCJ to cut b 3 out to create the adjacency fb 3 h ; b 3 t g (Fig. 3c and d). This operation might decrease the number of cycles, but the number decreased is at most 1 according to the property of the DCJ model. We then insert b 3 back as the neighbor of a 2 to form the segment ða 2 ; b 3 Þ, which will increase the number of cycles by 1 (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><figDesc>The last equality uses the assumption that the cost function only depends on the length of the segments. Third, assume that in Q both b 1 and b 2 are nonduplicated, and b 1 is mapped to b 3 while b 4 is mapped b 2. Let S 0 ¼ S; T 0 ¼ T and B 0 ¼ B n fhb 1 ; b 3 i; hb 4 ; b 2 ig [ fhb 1 ; b 2 i; hb 4 ; b 3 ig. Using the same technique in the Theorem 1 (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>; T; BÞ be the triple with smallest total cost among these triples that do not contain p (i.e. b i is not mapped to a i for all 1 i n). We now modify Q Ã</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><figDesc>Fig. 4c and d). We claim that the difference of the number of cycles between G 0 ðQ Ã p Þ and G 0 ðQ Ã p Þ is the same as that between RðQ Ã p ; pÞ and RðQ Ã p ; pÞ. In fact, the cycles that do not contain any core vertices or boundary vertices are the same between Q Ã p and Q Ã p according to the construction of Q Ã p and those cycles do not appear in either RðQ Ã p ; pÞ or RðQ Ã p ; pÞ. Moreover, for each cycle in G 0 ðQ Ã p Þ that contains some core vertices, there exists one corresponding cycle in RðQ Ã p ; pÞ, since the reduction procedure in constructing RðQ Ã p ; pÞ can only shorten the length of each cycle, while it cannot merge or split it. It is the same for G 0 ðQ Ã p Þ and RðQ Ã p ; pÞ. Thus, the claim holds. Furthermore, the reasoning used here also implies that we can construct RðQ Ã p ; pÞ directly from RðQ Ã p ; pÞ, rather than from G 0 ðQ Ã p Þ: we can first replace the black edges corresponding to ha 0 i ; b i i with</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig.3.</head><figDesc>Fig. 3. (a,b) The adjacency graph before and after adding hb 1 ; b 2 i. (c–e) Transforming G(Q) into GðQ 0 Þ using two DCJs. Irrelevant extremities are represented by stars</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head></head><figDesc>Ã p ; pÞ, we can then construct RðQ Ã p ; pÞ and compare the number of cycles in them. If the number of cycles in RðQ Ã p ; pÞ is no less than that in RðQ Ã p ; pÞ, then p is in some optimal solution. However, the problem is that we do not know RðQ Ã p ; pÞ. Our strategy is to enumerate all the possibilities of RðQ Ã p ; pÞ. The vertices of RðQ Ã p ; pÞ, i.e. all the core vertices and all the boundary vertices w.r.t. p, can be computed in advance very easily. All the genes of a i , 1 i n, are duplicated in RðQ Ã p ; pÞ by definition, and thus the two extremities in a i are always connected by one internal edge in RðQ Ã p ; pÞ. All genes in FðX; f ai Þ n fa i g are possibly mapped to b i in RðQ Ã p ; pÞ. For any two boundary vertices (maybe in the same genome), we need to check whether they can be connected by one reduced edge in RðQ Ã p</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><figDesc>Ã p ; pÞ: for each possible valid combination of the reduced edges (i.e. they form a matching that covers all the boundary vertices), it enumerates all the possible valid mappings for the genes in AðpÞ (a i cannot be mapped to b i by the definition of RðQ Ã p ; pÞ) and the mapping that yields the maximum number of cycles, plus the current combination of the reduced edges, forms one possibility of RðQ Ã p ; pÞ. After that, for each possibility of RðQ Ã p ; pÞ, it then builds RðQ Ã p ; pÞ and compares the number of cycles between them. If the number of cycles in RðQ Ã p ; pÞ is always no less than that in RðQ Ã p</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><figDesc>Fig. 4. X ¼ ða 3 ; c 1 ; a 1 ; b 1 ; d 1 ; b 3 ; e 1 Þ; Y ¼ ðd 2 ; a 2 ; b 2 ; c 2 ; Àd 3 ; e 2 Þ. p ¼ hða 1 ; b 1 Þ; ða 2 ; b 2 Þi. The four subgraphs show G 0 ðQ Ã p Þ; G 0 ðQ Ã p Þ; RðQ Ã p ; pÞ and RðQ Ã p ; pÞ, respectively. The core vertices are shown as solid patterns, and the boundary vertices are shown as patterns with one inner point. Reduced edges are shown as dashed lines</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig.5.</head><figDesc>Fig. 5. The underlying graph used to decide the existence of an alternating path connecting c 1 h and e 1 t w.r.t. p for the same instance in Figure 4. All bridging edges are shown as dotted lines</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig.6.</head><figDesc>Fig. 6. All the possible reduced edges in RðQ Ã p ; pÞ for the same instance in Figure 4. We can verify that among all possibilities of RðQ Ã p ; pÞ, the number of cycles in RðQ Ã p ; pÞ is always no less than that in RðQ Ã p ; pÞ. Thus, in this instance, p is optimal</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig.7.</head><figDesc>Fig. 7. (a) An example in which there are two optimal solutions if cðÁÞ ¼ 1. (b) An example in which there are two optimal solutions if cðÁÞ ¼ 0:5</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig.8.</head><figDesc>Fig. 8. Sensitivity of the inferred in-paralogs. The solid lines and dashed lines track our method and MSOAR, respectively. The circles, triangles and diamonds track L ¼ 1, L ¼ 2 and L ¼ 5, respectively</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Fig.9.</head><figDesc>Fig. 9. Specificity of the inferred in-paralogs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_18"><head>Fig.10.</head><figDesc>Fig. 10. Accuracy of the inferred orthologs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head></head><figDesc>Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. Comparison with MSOAR on accuracy</figDesc><table>Species pairs 

Assessable 
Accuracy 
Time 
MSOAR ILP 
MSOAR (%) ILP (%) 

G.g. and H.s. 
14 898 
14 807 
98.9 
99.1 
43 
G.g. and M.m. 
12 946 
12 923 
98.7 
99.0 
100 
G.g. and P.a. 
11 308 
11 262 
98.7 
99.0 
71 
G.g. and R.n. 
10 831 
10 779 
97.2 
98.0 
292 
H.s. and M.m. 
14 030 
13 989 
99.1 
99.3 
61 
H.s. and P.a. 
12 004 
11 955 
99.1 
99.3 
32 
H.s. and R.n. 
11 748 
11 685 
97.5 
98.1 
127 
M.m. and P.a. 
10 574 
10 537 
98.9 
99.3 
68 
M.m. and R.n. 
12 332 
12 280 
97.7 
98.2 
130 
R.n. and P.a. 
8788 
8745 
97.6 
98.2 
157 

</table></figure>

			<note place="foot">M.Shao and B.M.E.Moret at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">^ B2Bð ^ XnS; ^ Y nTÞ dð ^ BÞ ¼ min B2BðXnS;YnTÞ dðBÞ; and the optimal B can be recovered from the optimal ^ B through discarding the pairs with capping genes. This statement allows us to add capping genes to remove telomeres on the two given genomes without affecting the optimal bijection. Since the two new genomes ^ X and ^ Y do not contain telomeres, we have that for any triple Q ¼ ðS; T; ^ BÞ, where S &amp; SðXÞ, T &amp; SðYÞ and ^ B 2 Bð ^ X n S; ^ Y n TÞ, both G(Q) and G 0 ðQÞ contain only cycles (Fig. 2). This property allows us only to count the number of cycles when computing the DCJ distance, which simplifies the following ILP formulation. 3.3 ILP formulation Let X and Y be two given genomes after adding capping genes. Let Q Ã ¼ ðS Ã ; T Ã ; B Ã Þ be the optimal triple minimizing X s2S Ã [T Ã cðsÞ þ dðB Ã Þ, where we have S Ã &amp; SðXÞ; T Ã &amp; SðYÞ and B Ã 2 BðX n S Ã ; Y n T Ã Þ. (Notice that here X and Y may contain capping genes, but we define SðXÞ and SðYÞ are in terms of the original genomes, which do not contain segments with capping genes.) To facilitate our description, we use a 2 X to denote that gene a is contained in genome X. We use a 2 s to denote that gene a is contained in segment s. We denote by f a the gene family to which gene a</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">S</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">S</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">S</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">M</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">M</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">N</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">References</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">A fast linear-time algorithm for inversion distance with an experimental comparison</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Bader</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="483" to="491" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Alternating cycles and trails in 2-edge-coloured complete multigraphs</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Bang-Jensen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Gutin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Math</title>
		<imprint>
			<biblScope unit="volume">188</biblScope>
			<biblScope unit="page" from="61" to="72" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">A unifying view of genome rearrangements</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bergeron</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th Workshop on Algorithms in Bioinformatics (WABI&apos;06)</title>
		<meeting>the 6th Workshop on Algorithms in Bioinformatics (WABI&apos;06)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="163" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">A new linear-time algorithm to compute the genomic distance via the double cut and join distance</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bergeron</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">410</biblScope>
			<biblScope unit="page" from="5300" to="5316" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Genomic distance with DCJ and indels</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Braga</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Workshop on Algorithms in Bioinformatics (WABI&apos;10)</title>
		<meeting>the 10th Workshop on Algorithms in Bioinformatics (WABI&apos;10)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="90" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Double cut and join with insertions and deletions</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Braga</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1167" to="1184" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">On sorting permutations by double-cut-and-joins</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Conference On Computing and Combinatorics (COCOON&apos;10)</title>
		<meeting>the 16th Conference On Computing and Combinatorics (COCOON&apos;10)<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="439" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Assignment of orthologous genes via genome rearrangement</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<publisher>ACM</publisher>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="302" to="315" />
			<date type="published" when="2005" />
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Positional orthology: putting genomic evolutionary relationships into context</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Dewey</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="401" to="412" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Sorting signed permutations by reversals and insertions/deletions of contiguous segments</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>El-Mabrouk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="105" to="122" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">MSOAR: a high-throughput ortholog assignment system based on genome rearrangement</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Fu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1160" to="1175" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Mechanisms for human genomic rearrangements</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Gu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pathogenetics</title>
		<imprint>
			<biblScope unit="issue">1 4</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<monogr>
		<title level="m" type="main">Transforming cabbage into turnip (polynomial algorithm for sorting signed permutations by reversals)</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hannenhalli</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th Annual ACM Symposium Theory of Computing (STOC&apos;95</title>
		<meeting>the 27th Annual ACM Symposium Theory of Computing (STOC&apos;95<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<biblScope unit="page" from="178" to="189" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<monogr>
		<title level="m" type="main">Table 3 Distribution of the length of the segments in S and T Species pairs S 1 S 2 S !3 jSj T 1 T 2 T !3 jTj G.g. and H.s</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">S</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">S</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">N</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">M</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">M</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">N</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<monogr>
		<title level="m" type="main">S k (respectively, T k ) contains the percentage of the segments of length k in S (respectively, T)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<monogr>
		<title level="m" type="main">Table 4. Composition of B Species pairs Trivial (%) Predetermined (%) Remaining (%) jBj</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b39">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">S</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b40">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">S</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b41">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">M</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b42">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">M</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b43">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">N</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b44">
	<monogr>
		<title level="m" type="main">Comparing genomes with rearrangements and segmental duplications i337</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b45">
	<analytic>
		<title level="a" type="main">Ancestral genome organization: an alignment approach</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Holloway</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="280" to="295" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b46">
	<analytic>
		<title level="a" type="main">Analysis of segmental duplications via duplication distance</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Kahn</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Raphael</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="133" to="138" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b47">
	<analytic>
		<title level="a" type="main">Parsimony and likelihood reconstruction of human segmental duplications</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Kahn</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="446" to="452" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b48">
	<analytic>
		<title level="a" type="main">Rearrangements in phylogenetic inference: compare, model, or encode? Models and Algorithms for Genome Evolution</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Moret</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Biology</title>
		<editor>Chauve,C. et al.</editor>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="147" to="172" />
			<date type="published" when="2013" />
			<publisher>Springer Verlag</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b49">
	<analytic>
		<title level="a" type="main">Approximating the edit distance for genomes with duplicate genes under DCJ, insertion and deletion</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Shao</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Lin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>Suppl. 19</note>
</biblStruct>

<biblStruct   xml:id="b50">
	<analytic>
		<title level="a" type="main">An exact algorithm to compute the DCJ distance for genomes with duplicate genes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Shao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Computations of Molecular Biology</title>
		<meeting>the 18th International Conference on Computations of Molecular Biology<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="280" to="292" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b51">
	<analytic>
		<title level="a" type="main">Efficient sorting of genomic permutations by translocation, inversion and block interchange</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Yancopoulos</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="3340" to="3346" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b52">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Shao</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">M E</forename>
				<surname>Moret</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>