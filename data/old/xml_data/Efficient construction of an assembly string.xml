
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:52+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient construction of an assembly string graph using the FM-index</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010">2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Jared</forename>
								<forename type="middle">T</forename>
								<surname>Simpson</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Wellcome Trust Sanger Institute</orgName>
								<orgName type="institution" key="instit2">Wellcome Trust Genome Campus</orgName>
								<address>
									<postCode>CB10 1SA</postCode>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Richard</forename>
								<surname>Durbin</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Wellcome Trust Sanger Institute</orgName>
								<orgName type="institution" key="instit2">Wellcome Trust Genome Campus</orgName>
								<address>
									<postCode>CB10 1SA</postCode>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient construction of an assembly string graph using the FM-index</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">26</biblScope>
							<biblScope unit="page" from="367" to="373"/>
							<date type="published" when="2010">2010</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq217</idno>
					<note>[12:13 12/5/2010 Bioinformatics-btq217.tex] Page: i367 i367–i373 BIOINFORMATICS</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>Contact: js18@sangeracuk</keywords>
			</textClass>
			<abstract>
				<p>Motivation: Sequence assembly is a difficult problem whose importance has grown again recently as the cost of sequencing has dramatically dropped. Most new sequence assembly software has started by building a de Bruijn graph, avoiding the overlap-based methods used previously because of the computational cost and complexity of these with very large numbers of short reads. Here, we show how to use suffix array-based methods that have formed the basis of recent very fast sequence mapping algorithms to find overlaps and generate assembly string graphs asymptotically faster than previously described algorithms. Results: Standard overlap assembly methods have time complexity O(N 2), where N is the sum of the lengths of the reads. We use the Ferragina–Manzini index (FM-index) derived from the Burrows– Wheeler transform to find overlaps of length at least τ among a set of reads. As well as an approach that finds all overlaps then implements transitive reduction to produce a string graph, we show how to output directly only the irreducible overlaps, significantly shrinking memory requirements and reducing compute time to O(N), independent of depth. Overlap-based assembly methods naturally handle mixed length read sets, including capillary reads or long reads promised by the third generation sequencing technologies. The algorithms we present here pave the way for overlap-based assembly approaches to be developed that scale to whole vertebrate genome de novo assembly.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The sequence assembly problem is one of the most important and difficult problems in bioinformatics. Most genomes, particularly eukaryotic genomes, are highly repetitive that complicates their assembly by obscuring true relationships between reads with many false options. To help disambiguate the true relationships between the reads from those induced by different copies of repeats, it is useful to construct a graph where all the copies of a repeat are collapsed into a single segment. Such a graph is commonly referred to as a repeat graph. This structure is a natural consequence of the de Bruijn graph method of sequence assembly as the deconstruction of the sequence reads into k-mers (short subsequences of the reads of length k) collapses repeats that share the same k-mer into a single vertex (<ref type="bibr" target="#b20">Pevzner et al., 2001</ref>). An alternative formulation was proposed by Gene Myers and is called the string graph (<ref type="bibr" target="#b18">Myers, 2005</ref>). The string graph is built by first constructing a graph of the pairwise overlaps between sequence reads and transforming it into a string graph by removing transitive edges. The string graph shares with the de Bruijn graph the property that repeats are * To whom correspondence should be addressed. collapsed to a single unit without the need to first deconstruct the reads into k-mers. Because it is based on maximal overlaps, which are typically longer than de Bruijn k-mers, it also disambiguates shorter repeats that de Bruijn methods would only resolve in later processing steps (if at all). The string graph is much more expensive to construct, however, as the set of all pairwise, inexact overlaps between sequence reads must be found. For this reason, the majority of assemblers of short read sequence data have been based on the de Bruijn approach (<ref type="bibr" target="#b4">Chaisson and Pevzner, 2008;</ref><ref type="bibr" target="#b23">Simpson et al., 2009;</ref><ref type="bibr" target="#b25">Zerbino and Birney, 2008</ref>). A notable exception is the Edena assembler (<ref type="bibr" target="#b9">Hernandez et al., 2008</ref>) that uses a suffix array to compute exact overlaps between reads that are then used to construct the string graph. We address the construction of a string graph with a related approach by indexing the set of sequence reads using the Burrows–Wheeler transform(BWT)/Ferragina— Manzini(FM)-index, which has recently been used for the short read alignment problem (<ref type="bibr" target="#b12">Langmead et al., 2009;</ref><ref type="bibr" target="#b13">Li and Durbin, 2009;</ref><ref type="bibr" target="#b13">Li et al., 2009</ref>). We show how to efficiently compute the set of overlaps needed to construct the string graph from the FMindex. Furthermore, we show that the string graph can be constructed directly using the FM-index without the need for explicitly finding all overlaps and a subsequent transitive removal step, yielding a space and time efficient construction algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Definitions and notation</head><p>Let X be a string of symbols a 1 ,...,a l from an alphabet. The length of X is denoted |X|. We consider all strings to be terminated by a sentinel symbol $ that is not in and is lexographically lower than all the symbols in. X<ref type="bibr">[i]</ref>=a i is the i-th symbol of X and X<ref type="bibr">[i,j]</ref>is the substring a i ,...,a j. A substring X<ref type="bibr">[k,|X|]</ref>is a suffix of X and a substring X<ref type="bibr">[1,k]</ref>is a prefix of X. Let X = a l ,a l−i ,...,a 1 denote the reverse of X.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Genomes and sequence reads</head><p>We define a genome to be a long string from the alphabet {A,C,G,T } representing the complete DNA sequence of an individual, for simplicity ignoring potential subdivisions into chromosomes. A sequence read is a short substring from a genome. DNA is a double stranded molecule and sequence reads can originate from either strand. We use the notation X for the reverse-complement of a read X. In a shotgun sequencing experiment, a set of sequence reads, which we denote by the indexed set R, is randomly sampled from a genome with an unknown sequence. The sequence assembly problem is to reconstruct the sequence of the genome given R. We say that two reads X and Y overlap if a prefix of X is equal to a suffix of Y or vice versa. If X and Y originate from opposite strands, they overlap if the reverse complement of one of them</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>J.T.Simpson and R.Durbin</head><p>overlaps the other. To help distinguish true overlaps from spurious overlaps, we set a threshold of τ on the minimum acceptable overlap length. We assume for the moment that sequence reads are perfect representations of the genome—there are no sequencing errors. We discuss how to relax this constraint in the discussion at the end of this article.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Overlap and string graphs</head><p>To help reconstruct the source genome from R, we can build a graph of the relationships between sequence reads. One such graph is the overlap graph. In the overlap graph, each sequence read in R is a vertex and two vertices are joined by an edge if their corresponding reads overlap. Myers' string graph is a refinement of such a graph. In the string graph, reads that are contained within some other read, that is they are a substring of (or perhaps identical to) another read, are considered to be redundant and are not vertices in the graph. Each edge in a string graph is bidirectional to model the double-stranded nature of DNA and labelled with the unmatched substrings of the sequence reads. More formally, let X and Y be two reads wherethe entirety of X is matched by Y and X is said to be contained by Y. If Y is also contained by X (s yx = 1 and e yx =|Y |), X and Y are identical. In this case, we break the tie by saying the read with the higher index in R is contained within the read with the lower index. If neither X nor Y are contained and X<ref type="bibr">[s xy ,e xy ]</ref>is a prefix of X (s xy = 1) and Y [s yx ,e yx ] is a suffix of Y (e yx =|Y |), or vice versa, we say the overlap between X and Y is proper. If X and Y are reads from opposite strands of the genome they can still form an overlap. In this case, X<ref type="bibr">[</ref>must be prefixes or both must be suffixes. All non-contained reads are vertices in the string graph. For each proper overlap between two reads, we add a bidirected edge to the graph X ↔ Y. The bidirected edge describes the nature of the overlap between the reads and has two labels, one for each of the unmatched substring of the reads. We denote the tuple of data for each edge as (type xy ,type yx ,label xy ,label yx ). We define the type xy property (respectively, type yx ) as:</p><formula>type xy = B if s xy = 1 E if e xy =|X|</formula><p>In other words, type xy is B if the matched portion of X is a prefix of X, otherwise the matched portion of X must be a suffix and type xy is E. Note that since the graph does not have contained reads these cases are mutually exclusive. The label xy property is</p><formula>label xy = Y [e yx +1,|Y |] if s yx = 1 Y [1,s yx −1] if e yx =|Y |</formula><p>Restated, label xy is the unmatched suffix of Y if the matched portion of Y is a prefix and vice versa. The concatenation of X and label xy is an assembly of reads X and Y — the resulting string contains both the sequence of X and Y. If the overlap between X and Y is reverse complemented, i.e. X<ref type="bibr">[</ref>in the case of an edge built from a reverse-complement overlap, type xy is necessarily the same as type yx. To perform a walk in the string graph, if one enters a vertex on an edge of type B then an edge of A Btype E must be used to exit and vice versa.<ref type="figure" target="#fig_0">Figure 1</ref>depicts a simple string graph built from three overlapping reads. The initial graph built from the overlaps between reads is not a string graph yet. Consider a read X that overlaps reads Y and Z, which mutually overlap. The initial string graph will contain the edges X ↔ Y , X ↔ Z and Y ↔ Z. If Y and Z overlap the same end of X, i.e type xy = type xz , then Y and Z must share a common substring of X which is a prefix or suffix of one of Y or Z. This implies that there is a valid path that visits each of the three reads in succession. Let X → Y → Z be such a path. The string corresponding to this path is a valid assembly of the three reads which is identical to the string corresponding to the path X → Z. In this case, we say that the edge X ↔ Z is transitive. We will refer to non-transitive edges as irreducible. The transitive edges can be removed from the graph without losing any information—the transitive edges (and their corresponding overlaps) could be inferred from the irreducible edges. We can determine useful properties of transitive and irreducible edges. As the graph does not have contained reads, the length of the overlap between X ↔ Y is necessarily larger than the overlap between X ↔ Z. Equivalently, the length of label xy is shorter than label xz , and label xz can be seen as the concatenation of label xy and label yz. In other words, label xy of the irreducible edge is a prefix of label xz of the transitive edge.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">The suffix array, BWT and FM-index</head><p>The suffix array data structure was introduced by Manber and Myers (1990) as a succinct representation of the lexographic ordering of the suffixes of a string. The suffix array of a string X, denoted SA X , is a permutation of the integers {1,2,...,|X|} such that SA X<ref type="bibr">[i]</ref>=j iff X<ref type="bibr">[j,|X|]</ref>is the i-th lexographically lowest suffix of X. For example, if X =AAGTA$ then SA X =<ref type="bibr">[6,</ref><ref type="bibr">5,</ref><ref type="bibr">1,</ref><ref type="bibr">2,</ref><ref type="bibr">3,</ref><ref type="bibr">4]</ref>. Since the suffix array is a sorted data structure, the start positions of all the instances of a pattern Q in X will occur in an interval in SA X. We refer to such an interval as a suffix array interval and associate with it a pair of integers<ref type="bibr">[l,u]</ref>denoting the first and last index in SA X that correspond to a position in X of an instance of Q. Using SA X and the original string X, l and u can be efficiently found with a binary search for Q. Ferragina and Manzini developed a related method of indexing text, called the FM-index, which requires considerably less memory than a suffix array and can compute l and u in O(|Q|) time, independent i368Page: i369 i367–i373</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>String graph construction</head><p>of the size of the text being searched. Central to the FM-index is the BWT. Originally developed for text compression (<ref type="bibr" target="#b3">Burrows and Wheeler, 1994</ref>) the BWT of X, denoted B X , is a permutation of the symbols of X such that</p><formula>B X [i]= X[SA X [i]−1] if SA X [i] &gt; 1 $ i f SA X [i]=1</formula><p>Restated, B X<ref type="bibr">[i]</ref>is the symbol preceding the first symbol of the suffix starting at position SA X<ref type="bibr">[i]</ref>. Ferragina and Manzini (2000) extended the BWT representation of a string by adding two additional data structures to create a structure known as the FM-index. Let C X (a) be the number of symbols in X that are lexographically lower than the symbol a and Occ X (a,i) be the number of occurrences of the symbol a in B X<ref type="bibr">[1,i]</ref>. We note that C X and Occ X include counts for the sentinel symbol, $. Using these two arrays, Ferragina and Manzini provided an algorithm to search for a string Q in X (<ref type="bibr" target="#b6">Ferragina and Manzini, 2000</ref>). Let S be a string whose suffix array interval is known to be<ref type="bibr">[l,u]</ref>. The interval for the string aS can be calculated from<ref type="bibr">[l,u]</ref>using C X and Occ X by the following:</p><formula>l = C X (a)+Occ X (a,l −1) (1) u = C X (a)+Occ X (a,u)−1 (2)</formula><p>We encapsulate Equations (1)</p><p>and</p><p>(2) in the following algorithm, updateBackward.</p><formula>Algorithm 1 updateBackward([l,u], a) l ← C X (a)+Occ X (a,l −1) u ← C X (a)+Occ X (a,u)−1 return [l,u]</formula><p>To search for a string Q, we need to first calculate the interval for the last symbol in Q then use Equations (1) and (2) to iteratively calculate the interval for the remainder of Q. The interval for a single symbol is simply calculated from C X. The backwardsSearch algorithm presents the searching procedure in detail. If backwardsSearch returns an interval where l &gt; u, Q is not contained in X otherwise SA X<ref type="bibr">[i]</ref>is the position in X of each occurrence of Q for l ≤ i ≤ u.</p><formula>Q i ←|Q| l ← C X (Q[i]) u ← C X (Q[i]+1)−1 i ← i−1 while l ≤ u &amp; i ≥ 1 do [l,u]←updateBackward([l,u],Q[i]) i ← i−1 end while return [l,u]</formula><p>The backwardsSearch algorithm requires updating the suffix array interval |Q| times. As each update is a constant-time operation, the complexity of backwardsSearch is O(|Q|). To save memory Occ X (a,i) is stored only for i divisible by d (typically d is around 128). The remaining values of Occ X can be calculated as needed using the sampled values and B X .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">The generalized suffix array</head><p>We can easily expand the definition of a suffix array to include multiple strings. Let T be an indexed set of strings and T i be element T<ref type="bibr">[i]</ref>. We define SA T<ref type="bibr">[i]</ref>=(j,k) iff T j [k,|T j |] is the i-th lowest suffix in T. In the generalized suffix array, unlike the suffix array of a single string, two suffixes can be lexographically equal. We break ties in this case by comparing the indices of the strings. In other words, we treat each string in T as if it was terminated by a unique sentinel character $ i where $ i &lt; $ j when i &lt; j. We extend the definition of the BWT to collections of strings as follows. Let SA T<ref type="bibr">[i]</ref>=(j,k) then</p><formula>B T [i]= T j [k −1] if k &gt; 1 $ i fk = 1</formula><p>Like the BWT of a single string, B T is a permutation of the symbols in T ; therefore, the definitions of the auxiliary data structures for the FM-index, C T (a) and Occ T (a,i), do not change.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">METHODS</head><p>The construction of the string graph occurs in two stages. First, the complete set of overlaps of length at least τ is computed for all elements of R. The initial overlap graph is then built as described in Section 2.3 and transformed into the string graph using the linear expected time transitive reduction algorithm of Myers (2005). The first step in this process is the computational bottleneck. The all-pairs maximal overlap problem can be optimally solved in O(N +k 2 ) time using a generalized suffix tree where N = |R| i=1 |R i | and k =|R| (<ref type="bibr" target="#b8">Gusfield, 1997</ref>). It is straightforward to restrict this algorithm to only find overlaps of length at least τ at a lower computational cost; however, the amount of memory required for a suffix tree makes this algorithm impractical for large datasets. Myers' proposed the use of a q-gram filter to find the complete set of overlaps. This requires O(N 2 /D) time where D is a timespace tradeoff factor dependent on the amount of memory available. We will show that by using the FM-index of R the set of overlaps can be computed in O(N +C) time for error-free reads where C is the total number of overlaps found. We then provide an algorithm that detects only the overlaps for irreducible edges—removing the need for the transitive reduction algorithm and allowing the direct construction of the string graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Building an FM-index from a set of sequence reads</head><p>To build the FM-index of R, we must first compute the generalized suffix array of R. We could do this by creating a string that is the concatenation of all members of R,</p><formula>S = R 1 R 2 ...R m and</formula><p>then use one of the well-known efficient suffix array construction algorithms to compute SA S (<ref type="bibr" target="#b22">Puglisi et al., 2007</ref>). We have adopted a different strategy and have modified the inducedcopying suffix array construction algorithm (<ref type="bibr" target="#b19">Nong et al., 2009</ref>) to handle an indexed set of strings R where each suffix array entry is a pair (j,k) as described in Section 2.5. This suffix array construction algorithm is similar to the Ko–Aluru algorithm (<ref type="bibr" target="#b10">Ko and Aluru, 2005</ref>). A set of substrings of the text (termed LMS substrings for leftmost S-type, see<ref type="bibr" target="#b19">Nong et al., 2009</ref>) is sorted from which the ordering of all the suffixes in the text is induced. Our algorithm differs from the Nong–Zhang–Chan algorithm as we directly sort the LMS substrings using multikey quicksort (<ref type="bibr" target="#b2">Bentley and Sedgewick, 1997</ref>) instead of sorting them recursively. This method of construction is very fast in practice as typically only 30−40% of the substrings must be directly sorted. Once SA R has been constructed, the BWT of R, and hence the FM-index is easily computed as described above. We also compute the FM-index for the set of reversed reads, denoted R , which is necessary to compute overlaps between reverse complemented reads. We also output the lexographic index of R, which is a permutation of the indices {1,2,...,|R|} of R sorted by the lexographic order of the strings. This can be found directly from SA R and is used to determine the identities of the reads in R from the suffix array interval positions once an overlap has been found.Page: i370 i367–i373</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i369</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>J.T.Simpson and R.Durbin</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Overlap detection using the FM-index</head><p>We now consider the problem of constructing the set of overlaps between reads in R. Consider two reads X and Y. If a suffix of X matches a prefix of Y an edge of type (E,B) will be created in the initial overlap graph. We will describe a procedure to detect overlaps of this type from the FM-index of R. Let X be an arbitrary read in R. If we perform the backwardsSearch procedure on the string X, after k steps we have calculated the interval<ref type="bibr">[l,u]</ref>for the suffix of length k of X. The reads indicated by the suffix array entries in<ref type="bibr">[l,u]</ref>, therefore, have a substring that matches a suffix of X. Our task is to determine which of these substrings are prefixes of the reads. Recall that if a given element in the suffix array, SA R<ref type="bibr">[i]</ref>, is a prefix then B R<ref type="bibr">[i]</ref>=$ by definition. Therefore, if we know the suffix array interval for a string P, the interval for the strings beginning with P can be determined by calculating the interval for the string $P using Equations (1) and (2). This interval,</p><formula>denoted [l $ ,u $ ]</formula><p>, indicates that the reads with prefix P are the l $-th to u $-th lexographically lowest strings in R. We can, therefore, recover the indices in R of the reads overlapping X using lexographic index of R. The algorithm is presented below in findOverlaps.</p><p>Algorithm 3 findOverlaps(X, τ)-determine the reads in R that overlap X by at least τ symbols</p><formula>i ←|X| l ← C R (X[i]) u ← C R (X[i]+1)−1 i ← i−1 while l ≤ u &amp; i ≥ 1 do if |X|−i+1 ≥ τ then [l $ ,u $ ]←updateBackwards([l,u],$) if l $ ≤ u $ then outputOverlaps(X,[l $ ,u $ ]</formula><p>) end if end if<ref type="bibr">[l,u]</ref>←updateBackward(<ref type="bibr">[l,u]</ref>,X<ref type="bibr">[i]</ref>) i ← i−1 end while if l ≤ u then outputContained(X,<ref type="bibr">[l,u]</ref>) end if</p><p>The findOverlaps algorithm is similar to the backwards search procedure presented in Section 2.4. It begins by initializing<ref type="bibr">[l,u]</ref>to the interval containing all suffixes that begin with the last symbol of X. The interval<ref type="bibr">[l,u]</ref>is then iteratively updated for longer suffixes of X. When the length of the suffix is at least the minimum overlap size, τ, we determine the interval for the reads that have a prefix matching the suffix of X and output an overlap record for each entry (using the subroutine outputOverlaps). When the update loop terminates,<ref type="bibr">[l,u]</ref>holds the interval corresponding to the full length of X. The outputContained procedure writes a containment record for X if X is contained by any read in<ref type="bibr">[l,u]</ref>based on the rules described in Section 2.3. The overlaps detected by findOverlaps correspond to edges of type (E,B). We must also calculate the overlaps for edges of type (E,E) and (B,B), which arise from overlapping reads originating from opposite strands. To calculate edges of type (E,E), we use findOverlaps on the complement of X (not reversed) and the FM-index of R. Similarly, to calculate edges of type (B,B), we use findOverlaps on X (the reverse complement of X) and the FM-index of R. The overlap records created by outputOverlaps are constructed in constant time as they only require a lookup in the lexographic index of R. Let c i be the number of overlaps for read R i. The findOverlaps algorithm makes at most |R i | calls to updateBackwards and a total of c i iterations in outputOverlaps for a total complexity of O(|R i |+c i ). For the entire set R, the complexity is O(N +C) where C = |R| i=1 c i. Note that the majority of these edges are transitive and subsequently removed. We can, therefore, improve this algorithm by only outputting the set of irreducible edges, allowing the direct construction of the string graph. We address this in Section 3.3. In rare cases, multiple valid overlaps may occur between a pair of reads. In this case, the intervals detected during findOverlaps will contain intersecting or duplicated intervals. To handle this, we can modify findOverlaps to first collect the entire set of found intervals. This interval set could then be sorted and duplicated or intersecting intervals that represent sub-maximal overlaps can be removed. The outputOverlaps procedure can be called on the entire reduced interval set to output the set of maximal overlaps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Detecting irreducible overlaps</head><p>To directly construct the string graph, we must only output irreducible edges. Recall from Section 2.3 that the labels of the irreducible edges for a given read are prefixes of the labels of transitive edges. We use this fact to differentiate between irreducible and transitive edges during the overlap computation. Consider a read X and the set of reads that overlap a suffix of X, O. We could devise an algorithm to find the subset consisting only of irreducible edges by calculating the edge-labels of all members of O and filtering out the members whose label is the extension of the label of some other read. This would require iterating over all members of O, which can be quite large for repetitive reads. We will now show that the labels of the irreducible edges can be constructed directly from the suffix array intervals using the FM-index. Consider a substring S that occurs in R and its suffix array interval<ref type="bibr">[l,u]</ref>. Let a left extension of S be a string of length |S|+1 of the form aS. We can use B R<ref type="bibr">[l,u]</ref>to determine the set of left extensions of S. Let B be the set of symbols that appear in the substring B R<ref type="bibr">[l,u]</ref>. The left extensions of S are the strings aS such that a ∈ B. Note that we do not have to iterate over the range B R<ref type="bibr">[l,u]</ref>to determine B. Since Occ R (a,i) is defined to be the number of times symbol a occurs in B R<ref type="bibr">[1,i]</ref>we can count the number of occurances of a in B R<ref type="bibr">[l,u]</ref>(and hence aS in R) in constant time by taking the difference Occ R (a,u)−Occ R (a,l −1). If the $ symbol occurs in B R<ref type="bibr">[l,u]</ref>we say that S is left terminal, in other words one of the elements of R has S as a prefix. We similarly define a right extension of S as a string of length |S|+1 of the form Sa. While we cannot build the right extensions of S directly from the FM-index, the right extensions of S are equivalent to left extensions of S (the reverse of S) in R. Let S be right terminal if $ exists in B R'<ref type="bibr">[l ,u ]</ref>, in other words S is a suffix of some string in R. The procedure to find all the irreducible edges of a read X and construct their labels is to find all the intervals containing the prefixes of reads that overlap a suffix of X, then iteratively extend them rightwards until a rightterminal extension is found. The terminated read forms an irreducible edge with X and the label of the edge is the sequence of bases that were used during the right-extension. All non-terminated strings with the same sequence of extensions are transitive and, therefore, not considered further. The algorithm requires searching the FM-index in two directions, first backwards to determine the intervals of overlapping prefixes and then forwards to extend those prefixes and build the irreducible labels. Naively this would require first determining the intervals<ref type="bibr">[l,u]</ref>for each matching prefix, P, and then reversing the prefix and performing a backwards search on the FM-index of R to find the interval<ref type="bibr">[l ,u ]</ref>for P. The intervals<ref type="bibr">[l ,u ]</ref>would then be used in the extension stage to determine the labels of the irreducible edges. We can do better, however, by noting that the interval<ref type="bibr">[l ,u ]</ref>can be calculated directly during the backwards search without using the FM-index of R. We define OccLT R (a,i) to be the number of symbols that are lexographically lower than a in B R<ref type="bibr">[1,i]</ref>. Let S = X<ref type="bibr">[i,|X|]</ref>be a suffix of X and [l i ,u i ] its suffix array interval. Suppose we know the interval</p><formula>[l i ,u i ] for S in R. Let a = X[i−1]. The interval for S a =[l i−1 ,u i−1 ] is therefore l i−1 = l i +(OccLT R (a,u i )−OccLT R (a,l i −1)) (3) u i−1 = l i−1 +(Occ R (a,u i )−Occ R (a,l i −1)−1) (4)</formula><p>The interval for X<ref type="bibr">[1]</ref>is identical to that of X<ref type="bibr">[|X|]</ref>, since B R and B R' are both permutations of symbols in R, therefore, C R = C R'. We can, therefore,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i370</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>String graph construction</head><p>initialize the interval<ref type="bibr">[l ,u ]</ref>to the same initial value of<ref type="bibr">[l,u]</ref>and perform a forward search of X simulatenously while performing a backward search of X using only the FM-index of R. This does not require any additional storage as the OccLT R array can easily be computed from Occ R by summing the values for symbols less than a. This procedure is similar to the 2wayBWT search recently proposed by<ref type="bibr" target="#b11">Lam et al. (2009)</ref>. The updateFwdBwd algorithm implements Equations (3) and (4) along with updateBackward to calculate the pair of intervals. The F parameter to updateFwdBwd indicates the FM-index used — that of R or R .</p><formula>Algorithm 4 updateFwdBwd([l,u,l ,u ], a, F ) l ← l +(OccLT F (a,u)−OccLT F (a,l −1)) u ← l +(Occ F (a,u)−Occ F (a,l −1)−1) [l,u]←updateBackwards(l,u,a,F ) return [l,u,l ,u ]</formula><p>We now give the full algorithm for detecting the irreducible overlaps for a read X. The algorithm is performed in two stages, first a backwards search on X is performed to collect the set of interval pairs, denoted I, for prefixes that match a suffix of X. This algorithm is presented in findIntervals below and is conceptually similar to findOverlaps.</p><formula>Algorithm 5 findIntervals(X, τ) I ←∅ i ←|X| l ← C(X[i]) u ← C(X[i]+1)−1 [l ,u ]←[l,u] i ← i−1 while l ≤ u &amp; i ≥ 1 do if |X|−i+1 ≥ τ then [l $ ,u $ ,l $ ,u $ ]←updateFwdBwd([l,u,l ,u ],$,R) if l $ ≤ u $ then I ← I ∪[l $ ,u $ ,l $ ,u $ ] end if end if [l,u,l ,u ]←updateFwdBwd([l,u,l ,u ],X[i],R) i ← i−1 end while return I</formula><p>The interval set found by findIntervals is processed by extractIrreducible to find the intervals corresponding to the irreducible edges of X. This algorithm has two parts. First, the set of intervals is tested to see if some read in the interval set is right terminal. If so, the intervals corresponding to the right terminal reads form irreducible edges with X and are returned. If no interval has terminated, we create a subset of intervals for each right extension of I and recursively call extractIrreducible on each subset. The algorithm above assumes that there are no reads that are strict substrings of other reads (in other words, all the containments are between identical reads). If this is not the case, a slight modification must be made. If the set of reads overlapping X includes a read that is a proper substring of some other read it is possible that the first right terminal extension found is not that of an irreducible edge but of the contained read. It is straightforward to handle this case by observing that such a read will have an overlap which is strictly shorter than that of the irreducible edge. In other words, the only acceptable right terminal extension is to the reads in I that have the longest overlap with X. We can similarly modify extractIrreducible to handle overlaps for reads from opposite strands. To do this, we use findIntervals to determine the intervals for overlaps for the same strand as X and overlaps from the opposite strand of X (using the complement of X as in the previous section). When extending an interval that was found by the complement of X, we extend</p><formula>Algorithm 6 extractIrreducible(I) if I =∅ then return ∅ end if L ←∅ for all [l,u,l ,u ]∈I do [l $ ,u $ ,l $ ,u $ ]←updateFwdBwd([l ,u ,l,u],$,R ) if l $ ≤ u $ then L ← L∪[l $ ,u $ ]</formula><formula>a ∈ do I a ←∅ for all [l,u,l ,u ]∈I do [l a ,u a ,l a ,u a ]←updateFwdBwd([l ,u ,l,u],a,R ) if l a ≤ u a then I a ← I a ∪[l a ,u a ,l a ,u a ] end if end for L ← L∪extractIrreducible(I a ) end for return L it</formula><p>by the complement of a. In other words, if we are extending same-strand intervals by A, we extend opposite strand intervals by T and so on. We now offer a sketch of the complexity of the irreducible overlap algorithm. Let L i be the label of irreducible edge i. During the construction of L i at most k i intervals must be updated, corresponding to the number of reads that have an edge-label containing L i. The sum over all irreducible edges, E = i (|L i |k i ), is the total number of interval updates performed by extractIrreducible. Note that each read in R is represented by a path through the string graph. The total number of times edge i is used in the set of paths spelling all the reads in R is k i and the amount of sequence in R contributed by edge i is |L i |k i. This implies E can be no larger than N, the total amount of sequence in R, and extractIrreducible is O(N). As findIntervals is also O(N), the entire irreducible overlap detection algorithm is O(N).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>As a proof of concept, we implemented the above algorithms. The program is broken into three stages: index, overlap and assemble. The index stage constructs the suffix array and FM-index for a set of sequence reads, the overlap stage computes the set of overlaps between the reads and the assemble stage builds the string graph, performs transitive reduction if necessary, then compacts unambiguous paths in the graph and writes out a set of contigs. We tested the performance of the algorithms with two sets of simulations. In both sets of simulations, we compared the exhaustive overlap algorithm (which constructs the set of all overlaps) and the direct construction algorithm (which only outputs overlaps for irreducible edges). First, we simulated Escherichia coli read data with mean sequence depth from 5× to 100× to investigate the computational complexity of the overlap algorithms as a function of depth. After constructing the index for each dataset, we ran the overlap step in exhaustive and direct mode with τ = 27. The running times of these simulations are shown in<ref type="figure">Figure 2</ref>. As expected,Overlap (exhaustive) Overlap (direct)<ref type="figure">Fig. 2</ref>. The running time of the direct and exhaustive overlap algorithms for simulated E. coli data with sequence depth from 5× to 100×. The direct overlap algorithm scales linearly with sequence depth. As the number of overlaps grows quadratically with sequence depth, the exhaustive overlap algorithm exhibits above-linear scaling. the direct overlap algorithm scales linearly with sequence depth. The exhaustive overlap algorithm exhibits the expected abovelinear scaling as the number of overlaps for a given read grows quadratically with sequence depth. To assess the quality of the resulting assembly, we assembled the data using the direct overlap algorithm and compared the contigs to the reference. For each level of coverage, we selected τ to maximize the assembly N50 value. The N50 values ranged from 1.7 kbp (5× data, τ = 17) to 80 kbp (100× data, τ = 85). We aligned the contigs to the reference genome with bwa-sw (<ref type="bibr" target="#b14">Li and Durbin, 2010</ref>) and found that no contigs were misassembled. We also simulated data from human chromosomes 22, 15, 7 and 2 to assess how the algorithms scale with the size of the genome. We pre-processed the chromosome sequences to remove sequence gaps then generated 100 bp error-free reads randomly at an average coverage of 20× for each chromosome. The results of the simulations are summarized in<ref type="figure" target="#tab_1">Table 1</ref>. The running time of the exhaustive and direct overlap algorithms are comparable. As the sequence depth is fixed at 20×, both overlap algorithms scale linearly with the size of the input data. The final stage of the algorithm, building the string graph and constructing contigs, is much shorter for the direct algorithm as the transitive reduction step does not need to be performed. In addition, this step requires considerably less memory as the initial graph constructed by the direct algorithm only contains irreducible edges. The bottleneck in terms of both computation time and memory usage is the indexing step, which builds the suffix array and FMindex for the entire read set. This required 8.5 h and ∼55 GB of memory for chromosome 2. Extrapolating to the size of the human genome indicates it would require ∼4.5 days and 700 GB of memory to index 20× sequence data. While the computational time is tractable, the amount of memory required is not practical for the routine assembly of human genomes. We address ways to reduce the computational requirements in Section 5.For the overlap and assemble rows,-e and-d indicate the exhaustive and direct algorithms, respectively. The last column is the ratio between chromosome 2 and 22.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>String graph construction</head><p>lower the amount of memory required by exploiting the redundancy present in a set of sequencing reads by using a compressed index. The compressed suffix array is one such index and a method was recently developed to merge two compressed suffix arrays that possibly allows a distributed construction algorithm (<ref type="bibr" target="#b24">Sirén, 2009</ref>). Additionally, efficient external memory (disk-based) BWT construction algorithms have been developed that allow the construction of the FM-index for very large datasets while using a limited amount of main memory (<ref type="bibr" target="#b5">Dementiev et al., 2008;</ref><ref type="bibr" target="#b7">Ferragina et al., 2010</ref>). It is worth investigating the equivalency of the de Bruijn graph and string graph formulations (<ref type="bibr" target="#b21">Pop, 2009</ref>). This has been studied in terms of the computational complexity of reconstructing the complete sequence of the genome and both formulations have been shown to be NP-hard (<ref type="bibr" target="#b17">Medvedev et al., 2007</ref>). We would like to know the equivalence in terms of the information contained in the graph. Consider the case where all sequence reads are of length l and every l-mer in the genome has been sampled once. In this case, the de Bruijn graph and string graph constructions (using parameters k = l −1 and τ = l −1 respectively) are equivalent. In the realistic case where the genome is unevenly sampled, the relationship is not clear. In the original paper on the EULER assembler Pevzner presents an algorithm to recover the information lost during the deconstruction of reads into k-mers by finding consistent read-paths through the k-mer graph (<ref type="bibr" target="#b20">Pevzner et al., 2001</ref>). It is conceivable that if this procedure is able to perfectly reconstruct the information lost the resulting graph would be equivalent to Myers' string graph. This is not clear, however, and the equivalency of these formulations is a question we would like to address.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Diagram of a simple string graph. Three overlapping reads (R 1 ,R 2 ,R 3 ) are shown in (A). (B) shows the string graph constructed from the overlaps between the reads. The arrowheads pointing into the nodes depict an edge of type B and arrowheads pointing away from the nodes depict edges of type E. The edge R 1 ↔ R 3 is transitive.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>[12:13 12/5/2010 Bioinformatics-btq217.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>Algorithm 2 backwardsSearch(Q)-find the interval in SA X for the pattern</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>X[s xy ,e xy ]=Y [s yx ,e yx ]. We call X[s xy ,e xy ] the matched portion of X and the remainder unmatched. If s xy = 1 and e xy =|X|</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>s xy ,e xy ]=Y [s yx ,e yx ] and both X[s xy ,e xy ] and Y [s yx ,e yx ]</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>s xy ,e xy ]=Y [s yx ,e yx ] then label xy and label yx are also reverse complemented. Note that</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>end if end for if L =∅ then return L end if for all</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Table 1.</figDesc><table>Simulation results for human chromosomes 22, 15, 7 and 2 

chr 22 
chr 15 
chr 7 
chr 2 
ratio 

Chr. size (Mb) 
34.9 
81.7 
155.4 
238.2 
6.8 
Number of reads (M) 
7.0 
16.3 
31.1 
47.6 
6.8 
Contained reads (k) 
684 
1668 
3103 
4709 
6.9 
Contained (%) 
9.8 
10.2 
10.0 
9.9 
– 
Transitive edges (M) 
38.0 
93.0 
177.7 
274.6 
7.2 
Irreducible edges (M) 
6.3 
14.9 
28.7 
44.4 
7.0 
Assembly N50 (kbp) 
4.0 
4.6 
4.2 
4.7 
– 
Longest contig (kbp) 
31.9 
47.7 
53.1 
48.6 
– 
Index time (s) 
2606 
9743 
19 779 
30 866 
11.8 
Overlap -e time (s) 
2657 
6572 
12 970 
18 060 
6.8 
Overlap -d time (s) 
2885 
6750 
13 271 
19 437 
6.7 
Assemble -e time (s) 
1836 
4043 
8112 
13 095 
7.1 
Assemble -d time (s) 
423 
1161 
2044 
3226 
7.6 
Index memory (GB) 
8.0 
18.6 
35.4 
54.5 
6.8 
Overlap -e mem. (GB) 
2.4 
5.5 
10.5 
16.1 
6.7 
Overlap -d mem. (GB) 
2.4 
5.5 
10.4 
16.1 
6.7 
Assemble -e mem. (GB) 
5.9 
14.2 
27.2 
41.9 
7.1 
Assemble -d mem. (GB) 
2.7 
6.3 
12.1 
18.6 
6.9 

</table></figure>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Page: i371 i367–i373</note>

			<note place="foot" n="5"> DISCUSSION We have described an efficient method of constructing a string graph from a set of sequence reads using the FM-index. This work is the first step in the construction of a new, general purpose sequence assembler that will be effective for both short reads of the current generation of sequence technology and the longer reads of the sequencing instruments on the horizon. Unlike the de Bruijn graph formulation, the string graph is particularly well-suited for the assembly of mixed length read data. While the primary algorithms are in place, a considerable amount of work remains. Most pressing is the issue of adapting the assembler to handle real sequence data that contains base-calling errors. This amounts to adapting the algorithms to handle inexact overlaps. The BWA, Bowtie and SOAP2 aligners implement a number of strategies and heuristics for dealing with base mismatches and small insertion/deletions (Langmead et al., 2009; Li and Durbin, 2009; Li et al., 2009). These strategies directly translate to finding overlaps. Let be the maximum allowed difference between two overlapping reads. When performing the backwards search to find overlaps, we can allow the search to proceed to mismatched bases or gaps while ensuring that the bound is respected. We can similarly modify the irreducible overlap detection algorithm by allowing the right-extension phase to extend to mismatch bases or gaps. Here, we would only consider an interval to be transitive with respect to one of the irreducible intervals if the inferred difference between the intervals is less than. Our intention is to build an assembler that can handle genomes up to several gigabases in size, such as for human or other vertebrate genomes and our initial results indicate that our algorithms scale well. The introduction of sequencing errors will increase the complexity of the irreducible overlap identification step but this step is straightforward to parallelize if necessary because it is carried out for each non-contained read. The construction of the suffix array is currently the computational bottleneck; however, there are a number of established ways to improve this. We can i372 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">i373 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank Veli Mäkinen and members of the Durbin group for discussions related to string matching and sequence assembly.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">125</biblScope>
			<biblScope unit="page" from="13" to="25" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>btq217. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="373" to="367" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Fast algorithms for sorting and searching strings</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">L</forename>
				<surname>Bentley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Sedgewick</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA &apos;97: Proceedings of the Eighth Annual ACM-SIAM Symposium on Discrete Algorithms</title>
		<meeting><address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="360" to="369" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">A block-sorting lossless data compression algorithm</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Burrows</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Wheeler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Technical report 124, Digital Equipment Corporation</title>
		<meeting><address><addrLine>Palo Alto, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Short read fragment assembly of bacterial genomes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="324" to="330" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Better external memory suffix array construction</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Dementiev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Exp. Algorithmics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Opportunistic data structures with applications</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Symposium on Foundations of Computer Science</title>
		<meeting>the 41st Symposium on Foundations of Computer Science<address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="390" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Lightweight data indexing and compression in external memory</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Latin American Theoretical Informatics Symposium</title>
		<meeting>the Latin American Theoretical Informatics Symposium<address><addrLine>Heidelberg, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<monogr>
		<title level="m" type="main">Algorithms on Strings, Trees, and Sequences : Computer Science and Computational Biology</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">De novo bacterial genome sequencing: millions of very short reads assembled on a desktop computer</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Hernandez</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="802" to="809" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Space efficient linear time construction of suffix arrays</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ko</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Aluru</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithm</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="143" to="156" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">High throughput short read alignment via bi-directional bwt</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">W</forename>
				<surname>Lam</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Bioinformatics and Biomedicine</title>
		<imprint>
			<publisher>IEEE</publisher>
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page" from="31" to="36" />
			<date type="published" when="2009" />
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with BurrowsWheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Fast and accurate long-read alignment with BurrowsWheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="589" to="595" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Soap2: an improved ultrafast tool for short read alignment</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1966" to="1967" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Suffix arrays: a new method for on-line string searches</title>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Manber</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SODA &apos;90: Proceedings of the first annual ACM-SIAM symposium on Discrete algorithms</title>
		<meeting><address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="319" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Computability of models for sequence assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Algorithms in Bioinformatics Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="289" to="301" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">The fragment assembly string graph</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">suppl_2</biblScope>
			<biblScope unit="page" from="79" to="85" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Linear suffix array construction by almost pure induced-sorting</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Nong</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DCC &apos;09 Proceedings of the IEEE Conference on Data Compression</title>
		<meeting><address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="193" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">An eulerian path approach to DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA, 98</title>
		<meeting>. Natl Acad. Sci. USA, 98</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9748" to="9753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Genome assembly reborn: recent computational challenges</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief Bioinform</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="354" to="366" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">A taxonomy of suffix array construction algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">J</forename>
				<surname>Puglisi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Abyss: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Compressed suffix arrays for massive data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Sirén</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">String Processing and Information Retrieval</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="63" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>