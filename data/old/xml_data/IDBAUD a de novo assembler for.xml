
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:42+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">IDBA-UD: a de novo assembler for single-cell and metagenomic sequencing data with highly uneven depth</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Yu</forename>
								<surname>Peng</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<addrLine>Pokfulam Road</addrLine>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Henry</forename>
								<forename type="middle">C M</forename>
								<surname>Leung</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<addrLine>Pokfulam Road</addrLine>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">S</forename>
								<forename type="middle">M</forename>
								<surname>Yiu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<addrLine>Pokfulam Road</addrLine>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Francis</forename>
								<forename type="middle">Y L</forename>
								<surname>Chin</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<addrLine>Pokfulam Road</addrLine>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">IDBA-UD: a de novo assembler for single-cell and metagenomic sequencing data with highly uneven depth</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="issue">11</biblScope>
							<biblScope unit="page" from="1420" to="1428"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts174</idno>
					<note type="submission">Sequence analysis Advance Access publication April 11, 2012 Received and revised on March 26, 2012; accepted on April 2, 2012</note>
					<note>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [06:58 7/5/2012 Bioinformatics-bts174.tex] Page: 1420 1420â€“1428 Associate Editor: Michael Brudno</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Next-generation sequencing allows us to sequence reads from a microbial environment using single-cell sequencing or metagenomic sequencing technologies. However, both technologies suffer from the problem that sequencing depth of different regions of a genome or genomes from different species are highly uneven. Most existing genome assemblers usually have an assumption that sequencing depths are even. These assemblers fail to construct correct long contigs. Results: We introduce the IDBA-UD algorithm that is based on the de Bruijn graph approach for assembling reads from single-cell sequencing or metagenomic sequencing technologies with uneven sequencing depths. Several non-trivial techniques have been employed to tackle the problems. Instead of using a simple threshold, we use multiple depthrelative thresholds to remove erroneous k-mers in both low-depth and high-depth regions. The technique of local assembly with paired-end information is used to solve the branch problem of low-depth short repeat regions. To speed up the process, an error correction step is conducted to correct reads of high-depth regions that can be aligned to highconfident contigs. Comparison of the performances of IDBA-UD and existing assemblers (Velvet, Velvet-SC, SOAPdenovo and Meta-IDBA) for different datasets, shows that IDBA-UD can reconstruct longer contigs with higher accuracy. Availability: The IDBA-UD toolkit is available at our website</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Since, over 99% of microbes cannot be cultivated, single-cell sequencing and metagenomic sequencing technologies are used to study these microbes (<ref type="bibr" target="#b9">Chitsaz et al., 2011;</ref><ref type="bibr" target="#b25">Wooley et al., 2010</ref>). Single-cell sequencing technology amplifies and sequences genome of an individual cell without cultivation (<ref type="bibr" target="#b9">Chitsaz et al., 2011</ref>). Since the amplification bias, the sequencing depths at different regions of the genome can be extremely uneven. Metagenomic sequencing studies a microbe community as a whole (<ref type="bibr" target="#b25">Wooley et al., 2010</ref>) and has similar problem of uneven sequencing depths of genomes because different species in a sample have different abundances. Almost all existing de novo assembly tools were designed for single genome with uniform sequencing depth and were used by some recent studies on microbes (<ref type="bibr" target="#b22">Rodrigue et al., 2009;</ref><ref type="bibr" target="#b26">Woyke et al., *</ref>To whom correspondence should be addressed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2009</head><p>). However, these tools may not be able to produce long contigs when applying to data with highly uneven sequencing depths. Many existing de novo assembly tools for the next-generation sequencing reads adopt the de Bruijn graph approach (<ref type="bibr">Butler et al., 2008;</ref><ref type="bibr" target="#b8">Chaisson et al., 2009;</ref><ref type="bibr" target="#b14">Li et al., 2010;</ref><ref type="bibr" target="#b17">Peng et al., 2010;</ref><ref type="bibr" target="#b21">Pevzner et al., 2001;</ref><ref type="bibr" target="#b23">Simpson et al., 2009;</ref><ref type="bibr" target="#b27">Zerbino and Birney, 2008</ref>) in which a vertex represents a unique length-k substring called k-mer and an edge connects vertices u and v if and only if u and v appear consecutively in a read. Each read is represented by a path of k-mers in the de Bruijn graph. After error detection and removal, a simple path in the de Bruijn graph represents a contig. There are three major problems in this approach (<ref type="bibr">Peng et al.</ref>,</p><formula>2010):</formula><p>(a) Incorrect k-mers: Sequencing errors introduce many incorrect k-mers (vertices) that make the de Bruijn graph complicated.</p><p>(b) Gap problem: When k is large, especially in regions with lower sequencing depths, some k-mers (i.e. vertices, also edges, in the de Bruijn graph) are missing.</p><p>(c) Branching problem: Due to repeat regions or erroneous reads, many branches are introduced in the de Bruijn graph especially when k is small. For Problem (a), some of these errors can be removed by the topological structure of the graph. For the remaining errors, based on the assumption of uniform sequencing depth and the observation that the multiplicity of an erroneous k-mer is usually smaller than that of a correct k-mer, existing tools use a simple threshold to either prune contigs if the contigs are formed by k-mers of low multiplicity [e.g. Velvet (<ref type="bibr" target="#b27">Zerbino and Birney, 2008;</ref><ref type="bibr" target="#b28">Zerbino et al., 2009</ref>) and Abyss (<ref type="bibr" target="#b23">Simpson et al., 2009)]</ref>or directly remove k-mers with low multiplicity [IDBA (<ref type="bibr" target="#b17">Peng et al., 2010</ref>) and EULER-SR (<ref type="bibr" target="#b7">Chaisson and Pevzner, 2008)]</ref>. Note that this also solves some of the branching problems<ref type="bibr">[Problem (c)</ref>] due to incorrect k-mers. For Problems (b) and (c), using a small k will induce more branches whereas using a large k will result in more gaps. Most existing tools [e.g. Velvet (<ref type="bibr" target="#b27">Zerbino and Birney, 2008</ref>) and SOAPdenovo (<ref type="bibr" target="#b14">Li et al., 2010)]</ref>just pick an appropriate k, some intermediate value, to balance the two problems. On the other hand, the IDBA assembler (<ref type="bibr" target="#b17">Peng et al., 2010</ref>) provides a better solution which, instead of using a single k, iterates from k = k min to k = k max. At each iteration, the constructed contigs are used as reads for the next iteration. These contigs carry the k-mers of the current iteration, which may be missing in the next iteration, to the next iteration, thus solving some of the gap problems. It then relies on larger k to resolve the branches for the repeat regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>IDBA-UD</head><p>However, when applying to single cell or metagenomic assembling, highly uneven sequencing depth aggravates these problems further that affect the performance of these tools substantially due to the following issues. Issue (A): erroneous vertices and branches in high-depth regions; Issue (B): gaps in low-depth short repeat regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problems (a) and</head><p>(c) due to Issue (A): Due to highly uneven sequencing depth, the assumption of an incorrect k-mer having lower multiplicity is not valid. Those incorrect ones in the high-depth regions may even have higher multiplicity than the correct ones in the low-depth regions, thus simply using a single threshold to remove incorrect vertices will not work. Setting the threshold too low induces many incorrect vertices and edges (those in high-depth regions) in the graph. Setting the threshold too high will remove many correct vertices and edges in low-depth regions. We remark that there exist some error correction algorithms for reads/k-mers (<ref type="bibr" target="#b7">Chaisson and Pevzner, 2008;</ref><ref type="bibr" target="#b12">Kelley et al., 2010;</ref><ref type="bibr" target="#b15">Medvedev et al., 2011</ref>), but they do not perform very well in datasets with very uneven sequencing depths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problems (b) and (c) due to Issue (B):</head><p>Recall that most existing assemblers do not have a good method to resolve Problems (b) and (c) probably, except IDBA. Even for IDBA, in low-depth short repeat regions [For very long repeats (longer than the whole span of a paired-end read), it is almost impossible to resolve it.], when k is small, the branching problem makes it difficult to construct a contig to be passed to the next iteration. When k is increased, due to the low-depth issue, we still have the missing k-mer problem (the gap problem). Velvet-SC (<ref type="bibr" target="#b9">Chitsaz et al., 2011</ref>) is the only tool that tries to address the assembling problem of single-cell sequencing data with very uneven sequencing depths. Following Velvet, Velvet-SC picks an appropriate k to balance the gap and the branching problem; and uses variable thresholds to address problems related to Issue (A). Short erroneous contigs are filtered iteratively using different thresholds from low to high sequencing depths based on a global average of the multiplicity of all k-mers. Its performance is already better than existing tools designed for even sequencing depth. However, problems related to Issue (B) are not yet handled. In this article, we propose an assembler called IDBA-UD for de novo assembly of reads with uneven sequencing depths that tackles both issues. To resolve Issue (A), IDBA-UD extends and enhances the idea of variable thresholds of Velvet-SC (<ref type="bibr" target="#b9">Chitsaz et al., 2011</ref>) to filter out erroneous contigs. To cater for very extreme sequencing depths, instead of using a global average of the multiplicity of all k-mers, we adopt variable 'relative' thresholds depending on the sequencing depths of their neighboring contigs based on the idea that short contigs with much lower sequencing depths than their neighboring contigs tend to be erroneous For the gap and branching problems, we follow the approach of IDBA and iterate from a small k to a large k so that the missing k-mers for large k can be obtained from contigs constructed in the iterations of small k. Then we tackle Issue (B) as follows. The problem of Issue (B) is due to the low-depth short repeat regions such that using small k, we cannot get the contig out since it is a repeat region and the branches may be complicated due to the ambiguity of using a small value of k. When k increases, however, due to the low sequencing depths some k-mers are missing. Even if we iterate from small k to large k, this problem of missing k-mers cannot be resolved. So, we employ the technique of local assembly with paired-end information to handle these cases. Paired-end reads with one end aligned to some long confident contigs are grouped together. Local assembly is performed on the unaligned ends. Since we consider only the read pairs with one end aligned to the contig, the ambiguity due to small k is removed. If the insert size is longer than the repeat involved, it is likely that we can extend the contig over this repeat region, thus constructing the missing k-mers for large k. Note that this local assembly step can also help to resolve some branching problems in high-depth regions too. To further reduce the size of the de Bruijn graph and to speed up the assembly process, at every iteration, we conduct an additional error correction step by aligning the erroneous reads from the highdepth regions to confident contigs (i.e. with many supporting reads) which turns out to be very effective. We compared the performance of IDBA-UD with other assemblers on data in actual situations when the sequencing depths are extremely uneven, e.g., with the ratios larger than 100:1. Experiments on both simulated and real datasets showed that IDBAUD produces much longer contigs than existing assemblers with higher coverage and precision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>A flowchart of the major steps of IDBA-UD is shown in<ref type="figure" target="#fig_1">Figure 1</ref>. IDBA-UD iterates the value of k from k min to k max. In each iteration, an 'accumulated de Bruijn graph' H k for a fixed k is constructed from the set of input reads and the contigs (C kâˆ’s and LC kâˆ’s ) constructed in previous iterations, i.e. these contigs</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Y.Peng et al.</head><p>are treated as input reads for constructing H k. In each iteration, IDBA-UD also progressively increases the value of depth cutoff thresholds for removing some low-depth contigs so as to get longer confident contigs (C k ) in H k. Error in reads are corrected by aligning the reads to some confident contigs. Some missing k-mers in reads can be recovered from those contigs (LC k ) reconstructed by local assembling of a small set of paired-end reads with one end aligned to a confident contig. Information of these missing k-mers will be passed on to the next iteration through these contigs (LC k ) for the construction of H k+s. Finally, all outputted contigs are used to form scaffolds using paired-end reads information. Algorithm 1 shows the pseudocode of IDBA-UD for assembling a set of paired-end reads R with insert distance d and SD Î´. In the first iteration when k = k min , H k is equivalent to a de Bruijn graph for vertices whose corresponding k-mers have multiplicity at least m (2 by default) times in all reads. During all the subsequent iterations, some sequencing errors are first removed according to the topological structure of H k , e.g. dead-end contigs and bubbles [Steps (b) and</p><p>(c)]. The dead-end contigs (tangling paths in H k of lengths shorter than 2k) are likely to be false positives (<ref type="bibr" target="#b14">Li et al., 2010;</ref><ref type="bibr" target="#b23">Simpson et al., 2009;</ref><ref type="bibr" target="#b27">Zerbino and Birney, 2008</ref>). Paths (bubbles) representing very similar contigs except at one position and with the same starting vertex and ending vertex are likely to be caused by an error or a single-nucleotide polymorphism (SNP) and they should be merged together into one contig (<ref type="bibr" target="#b11">Hernandez et al., 2008;</ref><ref type="bibr" target="#b23">Simpson et al., 2009;</ref><ref type="bibr" target="#b27">Zerbino and Birney, 2008</ref>). When constructing H k+s from H k , each length s+1 path in H k is converted into a vertex (k +s)-mer and there is an edge from between two vertices if the corresponding (k +s+1)-mer appears f (1 by default) times in reads or once in contigs in C k âˆª LC k. In the following subsections, we will describe the other steps of IDBA-UD in detail.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Progressive relative depth</head><p>The sequencing depth, 'depth' in short, of each simple path (contig) in H k (H k which is a copy of H k is used in Algorithm 1 so as to preserve H k after the implementation of this step) is used to remove errors. The 'depth of a contig' is the average number of reads covering each k-mer in the contig. Note that long contigs are usually correct, because long simple paths can unlikely be formed by erroneous reads; similarly for high-depth contigs which have supports from many reads. For a contig, whether its length is long or short and whether its depth is high or low cannot be judged by its absolute values as the length of a contig depends on the value of k and the depth of a contig depends on the depths of its neighboring contigs (neighboring contigs can be identified by their adjacency in the de Bruijn graph). Even though wrong contigs in highdepth regions may have higher depths than correct contigs from low-depth regions, 'short' (&lt;2k) and 'relatively low depth' (less than a fraction Î² of its neighboring contigs' average depth) contigs are likely to be erroneous and can be removed. There is still a risk of removing short and relatively low-depth correct contigs because some relatively low-depth correct contigs with high-depth neighbors may be broken into short contigs by some wrong contigs (as branches in H k ). Based on the observation that these short and relatively low-depth correct contigs usually have higher depths than the short wrong contigs, we can filter out these wrong contigs first by increasing the depth cutoff threshold progressively from low to high. After the wrong contigs or branches are removed by a low-depth cutoff threshold, the relative low-depth correct contigs will be linked together to form long confident contigs which will be considered as reads for the next iteration. The key idea to consider the depth progressively and relatively is shown in Algorithm 2. T (c) represents the depth of contig c and T neighbor (c) represents the mean depth of c's neighboring contigs. The filtering depth cutoff threshold t is increased by a factor Î± progressively (Î± is âˆ¼10%). A geometric increase, instead of absolute increase (as used in Velvet-SC), in the depth cutoff threshold value improves implementation efficiency because the threshold difference is more sensitive at the low-depth values than the high-depth values. In each iteration, short contig c is removed if its depth T (c) is lower than the minimum of cutoff threshold t and the relative threshold Î²*T neighbor (c) where Î² is in the range of 0.1â€“0.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 IDBA-UD(R, d, Î´):</head><p>1 Pre-Error-Correction (optional) 2 Repeat from k := k min to k max with step s (a) If k = k min , then construct H k from R else construct H k from H kâˆ’s and RâˆªC kâˆ’s âˆª LC kâˆ’s (b) Remove dead-ends with length &lt;2k (c) Merge bubbles</p><formula>(d) H k := H k (e) Progressive-Relative-Depth(H k , k) (f) Get all potential contigs C k of H k (g) Error-Correction(C k , R) (h) LC k := Local-Assembly(C k , R, d, Î´) 3</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Local assembly</head><p>IDBA makes use of the contigs (containing the information of some missing k-mers for larger k) constructed in each iteration for the construction of the de Bruijn graphs of larger k. These missing k-mers may not exist in any of the reads but they might help to fill the gaps in the de Bruijn graphs for larger k. This approach still has a limitation that not all the missing k-mers, i.e. contigs containing these k-mers, can be constructed (so not all the gaps can be filled) because of branches. The main contribution of local assembly is to construct these contigs for the missing k-mers, especially in the lowdepth regions, based on the information of paired-end reads to eliminate the branches introduced from other parts of the genome. We shall illustrate this main idea of local assembly through an example (<ref type="figure" target="#fig_2">Fig 2)</ref>. Let us consider the construction of a de Bruijn Graph for k = 3, based on two reads, ...AACT and ACTG..., we have a simple path connecting the 3mers, AAC, ACT and CTG. IDBA can reconstruct the missing 5mer AACTG (not appeared in any reads) by forming a simple path containing it. However, as given in<ref type="figure" target="#fig_2">Figure 2</ref>, when ACT is a length-3 repeat in the genome (the repeat regions are apart by more than the insert distance) and there are reads covering the region ...TACTT... containing the other repeat. The 3mer ACT in the de Bruijn graph for k= 3 now has two in-branches and two out-branches (refer to the left diagram of<ref type="figure" target="#fig_3">Figure 3</ref>where vertex v represents the 3mer ACT; vertices u, w, u and w are for 3mers AAC, CTG, TAC and CTT, respectively). Under this situation, even when k is increased to 4 and 5 in IDBA (this part of graph will be disconnected in H 4 and H 5 ), the missing critical 5mersThe repeat region is a single k-mer, uvw and u vw appear in the genome. After the iteration, repeat v is resolved AACTG cannot be reconstructed because of the branches. However, when considering the de Bruijn graph when k = 3, IDBA-UD will align the pairedend reads to the contig ACGATCGTAGCTGA (<ref type="figure" target="#fig_2">Fig. 2</ref>) whereas the reads of the other ends covering the repeat regions will only be ...AACT and ACTG... (reads covering the other repeat region ...TACTT... are not involved because they are far away). Thus, local assembly (by considering the reads locally) can produce a simple path containing the critical 5mer AACTG to resolve branches as if there were no repeats.Let C k be the set of contigs (simple paths) in H k. The set of paired-end reads R c are those with one read aligned with the ends of each long contig c (with length at least twice of read length) in C k (c rc stands for the reverse complement of contig c). The other unaligned ends of these aligned pairedend reads, which would cover the genome regions extended about an insert distance beyond each end of a long contig, are extracted separately. Assume the insert distances of paired-end reads satisfy the normal distribution N(d,Î´). IDBA-UD groups the last d +3Î´ bases of c/c rc and R c /R rc c together and then locally assembles them into the set of local contigs LC k using IDBA [Algorithm 1 without Steps (e), (g) and</p><p>(h)] as shown in Algorithm 3. Since those reads which are far away from the contig c will not be mixed up with these unaligned ends, the contig c and these unaligned ends (reads) of R c can be used to construct a smaller and simpler de Bruijn graph whose simple paths (represented by the set of contigs LC k ) might reconstruct some of the missing k-mers and be considered as reads for the next iteration. Thus, the contigs can be extended longer and longer at each iteration. The expected number of resolved branches can be computed by Theorem 3 (Appendix).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Error correction</head><p>To reduce the errors in reads, error correction on some erroneous bases is performed based on the alignment between reads and confident contigs. Errors in reads are corrected only if they can be aligned to contigs with certain similarity, say 95%. The reads which can be multi-aligned to different contigs will not be considered for corrections. This approach of error correction is especially effective for high-depth regions because the confident contigs are well-supported by many reads. A position of a contig is labeled as 'confirmed' if one base type appears over 80% in all reads aligned to that position. Each read, aligned to a contig region with all positions confirmed and the number of different bases no &gt;3, will be corrected according to the confirmed bases. A pre-error-correction step for improved efficiency can be used to remove errors in high-depth regions as the first step in IDBA-UD if the sequencing depths are extremely uneven. A medium k-value and filtering threshold will be used to assemble reads to form contigs and errors in reads are corrected based on its alignment with the output contigs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Scaffold</head><p>The reads are finally aligned to contigs so as to build a scaffold graph in which each vertex u represents a contig and each edge (u, v) represents the connection between u and v with a support of &gt; p (3 by default) paired-end reads. After the scaffold graph is built, scaffold algorithm (<ref type="bibr" target="#b14">Li et al., 2010</ref>) will be applied to further connect contigs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>To evaluate the performance of our algorithm, experiments (All experiments were done on a machine with 8-core 2.40 GHz Intel CPU and 144 GB memory. The tested assembler was run with multiple threads, if it supports.) are carried out on several datasets with different properties. Results on existing general purpose assemblers like Velvet (<ref type="bibr" target="#b27">Zerbino and Birney, 2008</ref>), SOAPdenovo (<ref type="bibr" target="#b14">Li et al., 2010</ref>), IDBA (<ref type="bibr" target="#b17">Peng et al., 2010</ref>) and special purpose assemblers like Velvet-SC (<ref type="bibr" target="#b9">Chitsaz et al., 2011</ref>), Meta-IDBA (<ref type="bibr" target="#b20">Peng et al., 2011</ref>) were compared. Different k-values were tried for each assembler and the result with best performance are shown and compared. Two most important statistics, N50 and coverage are calculated to evaluate the contiguity and completeness of assembly results. N50 is the length of the longest contig such that all the contigs longer than this contig cover at least half of the genome being assembled (<ref type="bibr" target="#b10">Earl et al., 2011</ref>). Coverage is the proportion of the genome being covered by output contigs. In this article, only correct contigs are considered in the calculation of N50 and coverage. A contig is considered as correct if it can be aligned to the genome reference by BLAT (<ref type="bibr" target="#b13">Kent, 2002</ref>) with 95% similarity. For correct contigs, the substitution errors are computed by comparing the alignment between contigs and genome reference. For unaligned contigs, the number of contigs and the number of bases are recorded for comparison.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Error correction</head><p>The performance of our error correction algorithm is assessed by correcting the simulated reads sampled from Lactobacillus delbrueckii genome (âˆ¼1.85 Mb). The simulated dataset contains 1.85 million length-100 reads (100Ã—) uniformly sampled from the reference with 1% error rate. The error correction algorithm was executed on this dataset with output contigs of IDBA with k = 60 (k min = k max in this case). The correction result is shown in<ref type="figure" target="#tab_1">Table 1</ref>. There are 1 856 822 error bases in the dataset. Our algorithm corrected 1 627 727 bases with 1 626 929 (99.95%) being true positive. Note that our target of error correction is to reduce the errors without introducing other errors. The remaining erroneous reads either contain too many errors to be aligned to contigs or are from those regions which cannot be assembled correctly. This highprecision and low-sensitivity error correction algorithm is suitable</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Y.Peng et al.</head><p>for IDBA-UD, because the remaining errors could be handled by other means in the later iterations. Note that error correction which simplifies the graph for next iterations improves efficiency tremendously.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Low depth assembly</head><p>Lactobacillus plantarum (âˆ¼3.3 Mb) was used as genome reference for simulating low-depth dataset. 10Ã— length-100 paired-end reads were simulated for testing. The assembly results of IDBA-UD, Velvet, SOAPdenovo and IDBA are shown in, which is nearly twice of N50 of scaffolds constructed by other assemblers. Although N50 of scaffolds generated by different assemblers are similar, the coverage of scaffolds generated by all assemblers is much lower than that of contigs except IDBAUD. IDBA-UD made the least misassembly during the scaffolding process, because of having longer and more accurate contigs. In general, IDBA-UD achieved its best performance by iterating k from 20 to 100, whereas Velvet, SOAPdenovo and IDBA had best performance when k is set to a small value (21, 31 and 20â€“40, respectively). Since, the local assembly procedure can reconstruct missing k-mers, IDBA-UD can iterate k to a large value to construct very long contigs. The other assemblers are not able to reconstruct missing k-mers so that a reasonably small k is used to balance the gaps and branches problem. The running time and memory cost are more or less the same among all assemblers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Local assembly</head><p>The expected number of resolved branches (Theorem 3 in Appendix) by IDBA-UD, IDBA and the actual numbers by all assemblers for different repeat lengths k are shown in<ref type="figure" target="#tab_3">Table 3</ref>. We ran all assemblers with a specific k (k max ) and measured repeats with length (kâ€“10,k). Since SOAPdenovo and Velvet cannot handle even values of k due to the palindrome problem, 29, 39 etc. are considered in<ref type="figure" target="#tab_3">Table 3</ref>. The number of resolved branches by IDBA-UD is slightly smaller than the expected number because some of the (k +2)-mers</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Single cell assembly</head><p>Two single-cell short read sequencing datasets; Escherichia coli (lane 1) and Staphylococcus aureus (<ref type="bibr" target="#b9">Chitsaz et al., 2011</ref>; http://bix .ucsd.edu/projects/singlecell/) were used to test the performance of IDBA-UD, SOAPdenovo, Velvet and Velvet-SC (Velvet-SC was run after EULER error correction as the authors suggested. The assembly result we presented is slightly different from that in Velvet-SC paper, because we calculated the N50 for aligned contigs rather than all contigs.). Genome sequences of E</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.coli str. K-12 substr. MG1655 and S.aureus subsp. aureus USA300_FPR3757</head><p>were downloaded from NCBI and were used as reference for validation. The statistics of the assembly results of different assemblers are summarized in Tables 4 and 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">De novo assembly of E.coli</head><p>According to (<ref type="bibr" target="#b9">Chitsaz et al., 2011</ref>), the average sequencing depth of single-cell sequencing data of E.coli is âˆ¼600Ã— and the reads are sampled very unevenly. For contigs, SOAPdenovo and Velvet have similar N50 (6428 and 7679); Velvet-SC has the second best N50 (34 454), as it considers the property of uneven depth to remove errors; IDBA-UD has the longest N50 (82 007), as it considers uneven relative depth to remove errors and uses local assembly to reconstruct missing k-mers in low-depth regions. The contigs constructed by IDBA-UD also have the highest coverage. IDBA-UD and Velvet-SC have the least number of substitution errors. All assemblers constructed some contigs cannot be aligned to the reference. Some of them are really misassembled contigs, but the alignment of reads against contigs andThe read length is 100, insert distance is âˆ¼215 and the average depth is âˆ¼600Ã—.The read length is 100, insert distance is âˆ¼265, and the average depth is âˆ¼2300Ã—. reference showed that some non-aligned contigs are from regions with structure variations. After scaffolding, all assemblers produced longer scaffolds and lower coverage, but the difference between contigs and scaffolds is not much except SOAPdenovo. SOAPdenovo increased the N50 from 6428 to 25 244, but the coverage dropped from 92.42% to 86.49%. This means that the uneven depth of single cell assembly makes the scaffolding very difficult so that assemblers either cannot construct long scaffolds or make many mistakes in scaffolding procedure. Since IDBA-UD produced very long contigs, although scaffolding did not connect many contigs, the scaffolds generated by IDBA-UD have the longest N50 and highest coverage.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">De novo assembly of S.aureus</head><p>The sequencing depth of single-cell sequencing data of S.aureus is âˆ¼2300Ã—, much higher than that of E.coli. SOAPdenovo and Velvet performed better for dataset with higher sequencing depth. The contig N50 of SOAPdenovo and Velvet became 12 214 and 15 800, about twice of that of E.coli. IDBA-UD and Velvet-SC had similar performance as before, and handle reads with uneven depth quite well. Generally, higher sequencing depth does not affect the quality of assembly result much. The scaffolding also increases N50 and reduces coverage. The substitution error rates are very low for all assemblers for this high sequencing depth. SOAPdenovo is the fastest assemblers among four assemblers IDBA-UD took about twice the time of SOAPdenovo to perform de novo single cell assembly. The memory cost of IDBA-UD is much less than the others, as it did the filtering on k-mers. Depending on the nature of assemblers, different assemblers achieved its best performance with different k-values. SOAPdenovo got its best performance by using relatively large k-values (75 and 95) to reduce errors in high-depth regions and introducing more gaps problem at the same time It then relies on paired-end information to connect contigs to form scaffolds. Therefore, it produced more and shorter contigs and more gaps in its scaffolds than the others. Velvet preferred a relatively small k-values (45 and 55), probably because it contains a very sophisticated algorithm to remove the errors in de Bruijn graph. Velvet-SC had best performance with a moderate k-value (55) and relies on iteratively removing low-depth erroneous contigs to form long contigs. IDBA-UD is able to iterate k-values from small to large to build a de Bruijn graph with less gaps and less branches and obtain the best performance, through local assembly producing missing k-mers and iterate depth for reducing the errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Metagenomic assembly</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1">De novo assembly of simulated metagenomics data</head><p>To evaluate the performance of IDBA-UD on metagenomic data, we considered a simulated dataset with extremely uneven depth. This dataset was synthesized by combining simulated reads of three species L.plantarum (âˆ¼3.3 Mb), L.delbrueckii (âˆ¼1.85 Mb) and Lactobacillus reuteri F275 Kitasato (âˆ¼2 Mb) from the same genus. Length-100 reads were sampled from these three species with sequencing depth 10Ã— (low depth), 100Ã— (moderate depth) and 1000Ã— (high depth), respectively, with 1% error rate. The simulated paired-end reads have an insert distance following normal distribution N(500, 50). IDBA-UD, SOAPdenovo, Velvet and MetaIDBA were executed on this simulated metagenomic sequencing dataset. Since the depth is highly uneven, the Pre-Error-Correction of IDBA-UD was activated to remove errors. The experiment results are showed inThe sequencing depth of these species are 10Ã—, 100Ã— and 1000Ã—, respectively. The read length is 100, error rate is set to 1% and the insert distance follows normal distribution N(500, 50).). It is because they make a tradeoff between low-depth and high-depth regions and cannot handle them together. SOAPdenovo and Velvet have the best performance in N50 and coverage when k = 45. Small k is chosen because the genome size of low-depth species (âˆ¼3.3 Mb) is larger than high-depth species (âˆ¼2 Mb). In fact, their performance for k = 55 are similar except that the coverage of lowdepth species decreases, the coverage of moderatedepth species remains the same and the coverage of highdepth species increases. Meta-IDBA designed for metagenomic assembly iterates k from small to large to capture both low-depth and high-depth regions. At each iteration, missing k-mers in low-depth and moderate-depth regions introduce fragmentation in the assembly result. Thus, MetaIDBA outperforms SOAPdenovo and Velvet, but performs worse than IDBA-UD. The contigs constructed by Meta-IDBA covered &gt;99% of the regions in high-depth species, slightly &lt;90% of the regions in lowdepth species and moderate-depth species. As expected, IDBA-UD outperforms SOAPdenovo, Velvet and Meta-IDBA in all aspects. N50 (44 879) of contigs constructed by IDBA-UD is âˆ¼10 times of the second best N50 (4588) of contigs constructed by Meta-IDBA. IDBA-UD also has the best coverage (99.15%), âˆ¼10% higher than the second highest by Meta-IDBA. The contigs constructed by IDBA-UD covered almost all the region of three species, the uneven depth does not affect the assembly quality of IDBA-UD. Similar to single-cell assembly, scaffolding in all assemblers produced longer contigs but lower coverage. As for substitution error rate, IDBA-UD and Meta-IDBA have much higher accuracy and IDBA-UD constructed the least number of misassembled contigs. The running time of all assemblers are similar, but IDBA-UD and Meta-IDBA used about half of memory as SOAPdenovo and Velvet.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2">De novo assembly of human gut microbial short read data</head><p>Real human gut microbial sequencing data were used to assess the performance of IDBA-UD. The datasets (SRR041654 and SRR041655) were downloaded from NCBI for assembly. The reads were generated by Illumina Genome Analyzer II with read length 100 and insert distance 260. IDBA-UD, SOAPdenovo, Velvet and Meta-IDBA were compared with this dataset (The Pre-ErrorCorrection of IDBA-UD was activated.) Since there is no reference, we used the largest total contig size of all assemblers as the estimated genome size (98 407 199) for N50 calculation, and did not analyze the completeness of assembly by comparing genome coverage. MetaGeneAnnotator (<ref type="bibr" target="#b16">Noguchi et al., 2008</ref>; only complete genes predicted by MetaGeneAnnotator are considered as recovered) was applied to the output of each assembler to predict the number of genes recovered. The statistics of assembly results are summarized in<ref type="figure" target="#tab_7">Table 7</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.3">De novo assembly of simulated metagenomic data with different similarity level</head><p>To show the performance of IDBA-UD on data with different similarity level, we constructed three kinds of datasets with genomes in same genus, family and class. For each similarity level, five test cases with three species are selected randomly and sampled with low-depth (10Ã—), middle-depth (50Ã—) and high-depth (250Ã—) regions. The average of assembly results are shown in<ref type="figure" target="#tab_8">Table 8</ref>. In general, all assemblers have the best performance on dataset in class level and the worst performance on dataset in genus level. Contigs and scaffolds generated by IDBA-UD have the largest N50 and highest coverage in all three kinds of datasets. Velvet generated the second highest coverage, but it produced the shortest N50. The scaffolds generated by SOAPdenovo have the second largest N50, but they covered the least portion of genomes. Meta-IDBA is somehow in the middle, because it is designed to handle similar subspecies problem rather than different expression levels. In the assembly results of IDBA-UD, all species got similar coverage. All the other assemblers generated high coverage for middle-depth (50Ã—) species but lower coverage for low-depth and high-depth species, because they balanced the gap problems in low-depth species and high-depth species and benefited the middledepth species Consistent with previous experiments, IDBA-UD outperformed all the existing assemblers in sequencing data with highly uneven depth in all these experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head><p>Branches may be caused by erroneous reads (k-mers), variations (SNPs) or repeats. The branches caused by erroneous k-mers can be solved by the graph structure, such as dead-end or bubbles. The branches caused by a length-k repeats can be resolved if we have a (k +2)-mers covering the repeat, which can be obtained if the corresponding (k +2)-mers covering the repeat are sampled in reads or the (k +2)-mer is obtained by local assembly.<ref type="figure" target="#fig_3">Figure 3</ref>shows an example of H k and H k+1 for resolving a lengthk repeat v and its associated branches. Since it is impossible to resolve these branches by H k itself, reads and contigs are considered in each iteration from H k to H k+1 to resolve them. If the (k +2)-mers covering repeat v, e.g. uvw and u vw , exist in reads, these (k +2)mers can be used to convert branches to simple paths. If some of these (k +2)-mers are missing in reads due to low depth or errors, then local assembly can be used to reconstruct them as shown in<ref type="figure" target="#fig_2">Figure 2</ref>. In this section, we try to calculate the expected number of branches caused by repeats that can be resolved by (k +2)-mers which already exist in reads or reconstructed by locally assembly. Theorem 2 gives the expected number of (k +2)-mers covering a repeat being sampled f times (applied by IDBA). Theorem 3 gives the expected number of (k +2)-mers covering a repeat being sampled f times or reconstructed by local assembly (applied by IDBA-UD). Thus, the difference between these two expected numbers as given in Theorems 2 and 3 indicates the expected number of repeats resolved by local assembly.</p><p>Theorem 1. Assume t length-l reads are uniformly sampled from a length-g genome with error rate e, the probability that a k-mer v appearing x (g &gt;&gt; x) times in the genome being sampled at least m times is at least</p><formula>P k,m,x = 1âˆ’ mâˆ’1 i=0 t i p i (1âˆ’p) tâˆ’i where p = (lâˆ’k+1)x gâˆ’l+1 Ã—(1âˆ’e) k</formula><p>Proof. Pr(v is sampled in a read) â‰¤ Pr(a read containing v is sampled) Pr(v is sampled | a read containing v is sampled)</p><formula>= (l âˆ’k +1)x gâˆ’l +1 Ã—(1âˆ’e) k</formula><p>The probability that a correct k-mer v appears &lt; m times is at most mâˆ’1 i=0 t i p i (1âˆ’p) tâˆ’i , so the result follows.</p><p>Theorem 2. Assume t length-l reads are uniformly sampled from a length-g genome with error rate e and R k is the set of repeats with length k. If the support requirement for resolving a branch is f , then the expected number of resolved branches S k from k to k+1 is at least</p><formula>râˆˆR k b=Y (r) P k+2,f ,x(b)</formula><p>where Y (r) is the set of the (k +2)-mers covering repeat r in the genome and x(b) is the number of times that b appear in the genome.</p><p>Proof. To resolve a repeat of length k, a (k +2)-mer appearing at least f times in the reads is needed and the probability of such (k +2)-mer is P k+2,f ,x(b) (<ref type="bibr">Theorem 1</ref>). If reads are localized to a specific region of genome, then the branches caused by distant repeats may disappear and convert to simple paths. In this way, local assembly may generate local contigs which help to resolve branches.</p><p>Theorem 3. Assume t length-l reads are uniformly sampled from a length-g genome with error rate e, R k is the set of repeats with length k and LR k is the set of length-k repeats occurring at least twice in the genome within insert distance. If the support requirement for resolving a branch is f and IDBA-UD is applied on the data from k to k+1, then the expected number of resolved branches LS k is at least</p><formula>|R k âˆ’LR k |+ bâˆˆLR k b=Y (r) P k+2,f ,x(b)</formula><p>where Y (r) is the set of the (k +2)-mers covering repeat r in the genome and x(b) is the number of times that b appears in the genome. Proof. If a repeat does not appear twice within insert distance, then it can be resolved by IDBA-UD, i.e. |R k âˆ’LR k | and those repeats occurring more than once within the insert distance can only be resolved by the (k+ 2)-mers appearing at least f times in reads (Theorem 2).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [06:58 7/5/2012 Bioinformatics-bts174.tex] Page: 1421 1420â€“1428</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.1.</head><figDesc>Fig. 1. Flowchart of IDBA-UD</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Example of reconstructing missing k-mer in local assembly. ACT is a repeat region in the genome and no reads containing AACTG or TACTT for resolving repeat branches. In local assembly, ACT is no longer a repeat so that a simple path (local contig) covering AACTG can be reconstructed from local reads</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. Example of resolving repeats by iteration from k to k +1. The repeat region is a single k-mer, uvw and u vw appear in the genome. After the iteration, repeat v is resolved</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>. The contigs of SOAPdenovo and Velvet have similar N50, whereas SOAPdenovo produced much more contigs than Velvet. The total contig size of SOAPdenovo is 92 059 177. Meta-IDBA produced the smallest number of contigs, but N50 of contigs constructed by Meta-IDBA is larger than SOAPdenovo and Velvet. According to the analysis of the assembly result of simulated data, it is probably because Meta-IDBA reconstructed most of the highdepth regions but missed some lowdepth regions. IDBA-UD has the largest total contig size and the highest N50 (18 658). The contigs constructed by IDBA-UD contain the largest number of predicted genes (66 298), which is 50% more than that of SOAPdenovo and Velvet. The results reveal that IDBA-UD can assemble metagenomic data better than all the other assemblers. The running time of IDBAUD is between SOAPdenovo and Velvet. The memory cost of IDBA-UD and Meta-IDBA is also about half of SOAPdenovo and Velvet. Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [06:58 7/5/2012 Bioinformatics-bts174.tex] Page: 1427 1420â€“1428 IDBA-UD</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Construct scaffolds 4 return C kmax and scaffolds Algorithm 2 Progressive-Relative-Depth(G, k): 1 t := 1 2 repeat 3 for each contig c in G 4 if len(c) &lt;2k and T (c) &lt; min(t, Î²*T neighbor (c)) 5 remove c from G 6 t := t * (1+Î±) 7 until t t &gt; max c âˆˆ G T (c)</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>1 Remove contigs shorter than 2l from C 2 Align reads in R to contigs in C 3 For each (r,s) âˆˆ R 4 ifr uniquely aligned to last d +3Î´ bases of c, R c := R c âˆª {s} 5 ifr uniquely aligned to last d +3Î´ bases of c rc , R rc c := R rc c âˆª {s} 6 For each c âˆˆ C 7 LC c := IDBA({last d +3Î´ bases of c} âˆªR c 8 LC rc c := IDBA({last d +3Î´ bases of c rc } âˆªR rc c 9 return âˆª câˆˆG (LC c âˆª LC rc c )</figDesc><table>Algorithm 3 Local-Assembly(C, R, d, Î´ ): 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 1. Error correction result on simulated 100Ã— length-100 reads of L.delbrueckii (âˆ¼1.85 Mb) with 1% error rate</figDesc><table>No. of errors 
No. of corrected 
No. of TP 
No. of FP 

1 856 822 
1 627 727 
1 626 929 (99.95%) 
798 (0.05%) </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 2. IDBA-UD has the longest N50 (36 523), which is several folds of the N50 of Velvet, SOAPdenovo and IDBA (1584, 13 761 and 8350). IDBA-UD also has the highest coverage (99.56%), which is higher than the coverage of Velvet, SOAPdenovo and IDBA (98.36, 98.09 and 98.52%). IDBA-UD and IDBA have the least number of erroneous bases. Only 10 contigs (4437 bases) constructed by IDBA-UD and 3 contigs (3301 bases) by IDBA cannot be aligned to the genome reference, compared with 1079 contigs (112 505 bases) by SOAPdenovo and 5 contigs (15 921 bases) by Velvet. Among aligned contigs, all assemblers have similar substitution error rate. IDBA-UD also constructed the longest scaffolds with N50 being 194 322</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Table 3. Expected numbers of resolved branches by IDBA-UD, IDBA and the real number of all assemblers on the same dataset in Table 2 are removed as dead-end. As the k-value increases, the number of resolved branches drops and the number of wrong contigs also increases because of the missing (k +2)-mers. Comparing with other assemblers, IDBA-UD can resolve more repeats by increasing k and gets longer contigs.</figDesc><table>k 
29 
39 
49 
59 69 79 89 99 

All branches 
5509 2117 1019 618 375 288 195 149 
IDBA-UD (expected) 5507 2115 1018 616 373 284 190 142 
IDBA-UD 
5328 2025 962 557 331 223 129 98 
IDBA (expected) 
5499 2103 1000 584 329 215 103 33 
IDBA 
5298 1986 933 513 280 156 65 32 
SOAPdenovo 
5259 1861 795 282 41 27 20 
0 
Velvet 
3515 1356 617 219 35 27 20 
0 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 2. The assembly results on simulated 10Ã— lenght-100 reads of L.plantarum (âˆ¼3.3 Mb) with 1% error rate</figDesc><table>k 
Contigs 
Scaffolds 
Time (s) Mem (M) 

No. 
N50 
Max 
Cov 
Sub.err Err no. 
No. N50 
Max 
Cov 
Sub.err Err no. 
len 
(%) 
(%) 
(len) 
len 
(%) 
(%) 
(len) 

IDBA-UD 
20â€“100 
210 36 513 201 860 99.56 0.0225 
104 437 
83 194 322 406 269 99.55 0.0218 
53 784 
63 
432 
SOAPdenovo 31 
3346 
1584 
8691 98.36 0.0572 1 079 112k 147 121 214 246 514 92.50 0.0483 1 087 283k 31 
852 
Velvet 
21 
473 13 761 
48 489 98.09 0.0323 
515k 111 111 871 225 438 96.81 0.0291 
667k 43 
526 
IDBA 
20â€“40 
672 
8350 
37 391 98.52 0.0164 
33 301 
60 119 931 308 798 97.55 0.0161 
39 420 
24 
414 </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="true"><figDesc>Table 4. The assembly results on real single-cell sequencing data of E.coli (âˆ¼4.64 Mb)</figDesc><table>k 
Contigs 
Scaffolds 
Time (s) Mem (M) 

No. 
N50 
Max 
Cov 
Sub.err Err no. 
No. 
N50 
Max 
Cov 
Sub.err Err no. 
len 
(%) 
(%) 
(len) 
len 
(%) 
(%) 
(len) 

IDBA-UD 
40â€“100 
187 82 007 224 018 95.01 0.0017 
87 347 
148 98 306 224 018 95.00 0.0016 
73 346 35 
3.2 
SOAPdenovo 75 
6008 
6428 
50 965 92.42 0.0421 693 335 4419 25 244 118 128 86.49 0.0448 588 653 30 
19 
Velvet 
45 
1736 
7679 
68 395 92.69 0.0095 160 266 1707 
7795 
68 395 92.59 0.0095 154 272 91 
11 
Velvet-SC 
55 
372 34 454 157 931 92.74 0.0019 
78 279 
46 
8.3 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="true"><figDesc>Table 5. The assembly result on real single-cell sequencing data of S.aureus (âˆ¼2.87 Mb)</figDesc><table>k 
Contigs 
Scaffolds 
Time (s) Mem (M) 

No. 
N50 
Max 
Cov 
Sub.err Err no. 
No. N50 
Max 
Cov 
Sub.err Err no. 
len 
(%) 
(%) 
(len) 
len 
(%) 
(%) 
(len) 

IDBA-UD 
60â€“100 
122 87 502 175 236 94.46 0.0027 
14 247 
78 100 895 308 777 93.54 0.0019 
17 271 
29 
3.8 
SOAPdenovo 95 
1005 12 214 
92 978 96.63 0.0067 791 220 696 
22 632 149 602 91.44 0.0072 746 364 
11 
12 
Velvet 
55 
520 15 800 
67 677 94.14 0.0043 
7999 516 
16 038 
67 677 94.13 0.0042 
77 100 135 
15 
Velvet-SC 
55 
322 29 719 221 773 93.12 0.0042 
43 312 
224 
41 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><figDesc>Table 6. In addition to the statistics we presented before, the sequencing depth of each species was considered for comparison. SOAPdenovo and Velvet did not perform well on this simulated metagenomic dataset. N50 of SOAPdenovo and Velvet are only 461 and 418, respectively. The contigs constructed by SOAPdenovo and Velvet covered most regions of moderate-depth species (95.39% and</figDesc><table>Copyedited by: TRJ 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="true"><figDesc>Table 6. The assembly result on simulated metagenomic dataset of L.plantarum (âˆ¼3.3 Mb), L.delbrueckii (âˆ¼1.85 Mb) and L.reuteri F275 Kitasato (âˆ¼2 Mb)</figDesc><table>k 
Contigs 
Scaffolds 
Time (min) Mem (G) 

No. 
N50 
Cov 
10Ã— 
100Ã— 1000Ã— Err no. 
No. 
N50 
Cov 
10Ã— 
100Ã— 1000Ã— Err no. 
(%) 
(len) (k) 
(%) 
(len) (k) 

IDBA-UD 
20â€“100 
546 44 879 99.15 99.31 98.48 99.52 
94 
335 104 696 97.80 99.23 95.90 97.21 
1069 35 
6.9 
SOAPdenovo 45 
16 266 
461 79.57 95.45 95.39 39.40 
1 347 166 10 036 
1356 74.01 83.43 95.37 39.28 
1 404 641 30 
18 
Velvet 
45 
12 018 
418 72.73 94.66 95.24 16.66 
6 200 710 11 976 
418 72.58 94.34 95.24 16.66 
6 219 724 91 
18 
Meta-IDBA 
20â€“100 
2636 
4588 89.62 85.29 86.96 99.09 
127 292 
46 
6.2 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><figDesc>Table 7.</figDesc><table>The assembly results on human gut microbial short read data (SRR041654 and SRR041655) from NCBI 

k 
Contigs 
Scaffolds 
Gene no. Time (min) Mem (G) 

No. 
N50 
Max 
Total 
No. 
N50 
Max 
Total 
len 
length 
len 
length 

IDBA-UD 
20â€“100 
39 221 18 658 
39 221 
18 658 37 512 20 737 673 651 98 243 412 
66 298 
138 11 
SOAPdenovo 55 
99 213 
2066 113 678 92 059 177 93 961 
4575 319 705 90 788 489 
41 093 
61 31 
Velvet 
55 
33 165 
3476 171 410 65 630 428 30 419 
5065 358 885 65 887 174 
40 914 
176 35 
Meta-IDBA 
20â€“100 20â€“100 19 978 
7710 
325 768 
48 693 
49 12 

The read length is 100 and the insert distance is 260. 

95.24%) and low-depth species (95.45% and 94.66%) but a small 
portion of high-depth regions (39.40% and 16.66%</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><figDesc>Table 8. The assembly results on simulated metagenomic datasets in different taxonomic levels k Contigs Scaffolds</figDesc><table>No. 
N50 
Cov 
10Ã— 
100Ã— 1000Ã— Err no. 
No. 
N50 
Cov 
10Ã— 
50Ã— 
250Ã— Err no. 
(%) 
(len) (k) 
(%)</table></figure>

			<note place="foot">Â© The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="4"> DISCUSSION AND CONCLUSION In this article, we proposed a new assembler IDBA-UD, an extension of IDBA, to assemble short sequencing reads with highly uneven depth. Besides iterating k from small to large, IDBAUD reconstructs missing k-mers by local assembly and removes errors by iteratively removing low-depth contigs. The experiment results on both simulated and real datasets showed that IDBA-UD outperformed all existing assemblers in assembling datasets with highly uneven depth. For metagenomic data, there are more common k-mers between genomes from subspecies of the same species than genomes from different species. This information is used in MetaIDBA for assembling metagenomic data. As a future work, we should study how to integrate this information in IDBA-UD for better performance. Funding: This work was supported in part by HKGRF funding (HKU 7116/08E, HKU 719709E) and HKU Genomics SRT funding. Conflict of Interest: none declared.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Len</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Meta-Idba</forename>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="143" to="551" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Idba-Ud</forename>
				<surname>Family</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Meta-Idba</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Idba-Ud</forename>
				<surname>Class</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Meta-Idba</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">For each level, five test cases with three randomly selected species are generated for testing. The depths of three species are set to 10Ã—, 50Ã— and 250Ã—, respectively. The read length is 100, error rate is set to 1% and the insert distance follows normal distribution N(500, 50) The values presented in this table are average results offive test cases ALLPATHS: de novo assembly of whole-genome shotgun microreads</title>
	</analytic>
	<monogr>
		<title level="j">REFERENCES Butler,J. et al. Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="810" to="820" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Short read fragment assembly of bacterial genomes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="324" to="330" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">De novo fragment assembly with short mate-paired reads: Does the read length matter?</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="336" to="346" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of single-cell bacterial genomes from short-read data sets</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Chitsaz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="915" to="921" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Assemblathon 1: a competitive assessment of de novo short read assembly methods</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Earl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="2224" to="2241" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">De novo bacterial genome sequencing: millions of very short reads assembled on a desktop computer</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Hernandez</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="802" to="809" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Quake: quality-aware detection and correction of sequencing errors</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Kelley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">116</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">BLATâ€“the BLAST-like alignment tool</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">J</forename>
				<surname>Kent</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="656" to="664" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Error correction of high-throughput sequencing datasets with non-uniform coverage</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="137" to="141" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">MetaGeneAnnotator: detecting species-specific patterns of ribosomal binding site for precise gene prediction in anonymous prokaryotic and phage genomes</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Noguchi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">DNA Res</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="387" to="396" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">IDBA â€“ a practical iterative de Bruijn graph de novo assembler</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RECOMB</title>
		<meeting><address><addrLine>Lisbon</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<monogr>
		<title level="m" type="main">2012 Bioinformatics-bts174.tex] Page: 1428</title>
		<imprint>
			<biblScope unit="page" from="1420" to="1428" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Meta-IDBA: a de Novo assembler for metagenomic data</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="94" to="101" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">An Eulerian path approach to DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA, 98</title>
		<meeting>. Natl Acad. Sci. USA, 98</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9748" to="9753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Whole genome amplification and de novo assembly of single bacterial cells</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Rodrigue</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<monogr>
		<title level="m" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">A primer on metagenomics</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">C</forename>
				<surname>Wooley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">1000667</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Assembling the marine metagenome, one cell at a time</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Woyke</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Pebble and rock band: heuristic resolution of repeats and scaffolding in the velvet short-read de novo assembler</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">8407</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>