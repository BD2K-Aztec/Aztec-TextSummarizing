
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:33+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">DSK: k-mer counting with very low memory usage</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2013">2013</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Guillaume</forename>
								<surname>Rizk</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">ENS Cachan Brittany/IRISA</orgName>
								<address>
									<addrLine>Campus de Beaulieu</addrLine>
									<postCode>35700</postCode>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Dominique</forename>
								<surname>Lavenier</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">ENS Cachan Brittany/IRISA</orgName>
								<address>
									<addrLine>Campus de Beaulieu</addrLine>
									<postCode>35700</postCode>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Rayan</forename>
								<surname>Chikhi</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">ENS Cachan Brittany/IRISA</orgName>
								<address>
									<addrLine>Campus de Beaulieu</addrLine>
									<postCode>35700</postCode>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Algorizk</forename>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">ENS Cachan Brittany/IRISA</orgName>
								<address>
									<addrLine>Campus de Beaulieu</addrLine>
									<postCode>35700</postCode>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Paris</forename>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">ENS Cachan Brittany/IRISA</orgName>
								<address>
									<addrLine>Campus de Beaulieu</addrLine>
									<postCode>35700</postCode>
									<settlement>Rennes</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">DSK: k-mer counting with very low memory usage</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">29</biblScope>
							<biblScope unit="issue">5</biblScope>
							<biblScope unit="page" from="652" to="653"/>
							<date type="published" when="2013">2013</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btt020</idno>
					<note type="submission">Sequence analysis Advance Access publication January 16, 2013 Received on October 19, 2012; revised on December 26, 2012; accepted on January 9, 2013</note>
					<note>Associate Editor: Michael Brudno</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Counting all the k-mers (substrings of length k) in DNA/RNA sequencing reads is the preliminary step of many bioinformatics applications. However, state of the art k-mer counting methods require that a large data structure resides in memory. Such structure typically grows with the number of distinct k-mers to count. We present a new streaming algorithm for k-mer counting, called DSK (disk streaming of k-mers), which only requires a fixed user-defined amount of memory and disk space. This approach realizes a memory, time and disk trade-off. The multi-set of all k-mers present in the reads is partitioned, and partitions are saved to disk. Then, each partition is separately loaded in memory in a temporary hash table. The k-mer counts are returned by traversing each hash table. Low-abundance k-mers are optionally filtered. DSK is the first approach that is able to count all the 27-mers of a human genome dataset using only 4.0 GB of memory and moderate disk space (160 GB), in 17.9 h. DSK can replace a popular k-mer counting software (Jellyfish) on small-memory servers. Availability: http://minia.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Determining the abundance of each distinct k-mer in a set of sequencing reads is a conceptually simple yet fundamental task. It is used in many bioinformatics applications related to sequencing, e.g. genome and transcriptome assembly, variants detection and read error correction. For de novo assembly, one is often interested in counting k-mers to discard those with low abundance, which likely stem from sequencing errors. State of the art methods for k-mer counting rely on hash tables (Jellyfish; Marc¸aisMarc¸ais and<ref type="bibr" target="#b0">Kingsford, 2011</ref>) and/or Bloom filters (BFCounter;<ref type="bibr" target="#b1">Melsted and Pritchard, 2011</ref>). These structures need to reside in memory for random access. Sequencing errors induce erroneous k-mers, in a volume typically greater or comparable with that of correct k-mers. Hence, counting k-mers for a human dataset with either a single hash table or a Bloom filter is a task that requires tens of gigabytes of memory. In Section 2, we describe a fixed-memory and fixed-disk space streaming algorithm, DSK (disk streaming of k-mers), and its worst-case complexity is analysed in function of the desired memory and disk usage. In Section 3, DSK is used to count all the 27-mers of a whole-genome human dataset. The trade-off between memory and disk space is analysed on two smaller datasets. We conclude with a discussion of the advantages of DSK over related methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>Algorithm 1 describes the DSK k-mer counting algorithm. The hash function hðÁÞ maps a k-mer to a numeric value in ½0; H, where H is a large integer (typically 2 64 ). In the following analysis, we make a simplifying assumption. Let d be the total number of distinct k-mers in the input; we assume that the number of distinct k-mers having a given hash value x 2 ½0; H is at most d=H AE Ç . In other words, the set of distinct k-mer values can be uniformly partitioned by this hash function. Each k-mer is encoded using the classical 2 bits representation in the smallest available integer type, i.e. using 2 log 2 ð2kÞ d e bits. The abundance of each k-mer is stored as a 32 bits integer. For convenience, let b ¼ 2 log 2 ð2kÞ d e. Each k-mer m present in S is examined n iters ¼ vb=D AE Ç times (once per iteration) and is written to disk only once, at the ðhðmÞ mod n iters Þ-th iteration. Using the uniform repartition hypothesis, a multi-set of v=n iters D=b AE Ç k-mers are written to disk at each iteration. As each k-mer is encoded using b bits, the maximal disk usage of the algorithm is D bits. The maximal memory usage of the algorithm is M bits, as Steps 7–11 require constant memory, and Steps 12–17 load a single partition in T that requires exactly M bits. With an open-addressing mechanism, each distinct k-mer occupies exactly (b þ 32) bits in T. To prove that the algorithm terminates, it suffices to show that T never overflows, i.e. strictly</p><p>Algorithm 1. The DSK algorithm 1: Input: The set S of sequences, k-mer length k, target memory usage M (bits), target disk space D (bits) and hash function hðÁÞ5: for each iteration i ¼ 0::n iters do 6: Initialize a set of empty lists fd 0 , :::, d np g stored on disk 7: for each sequence s in S do 8: for each k-mer m in s do 9: if ðhðmÞ mod n iters Þ ¼ i then 10: j hðmÞ=n iters mod n p 11: Write m to disk in d j 12: for each index j ¼ 0::n p do 13: Initialize a hash table T with M bits of memory 14: for each k-mer m in d j do 15: T½m T½m þ 1, if m is present in T 1, otherwiseHash tables accesses and insertions (Step 15) are done in constant expected time with open-addressing, as long as the load factor is strictly 51 (which was proved earlier in the text). Hence, the expected time complexity of Steps 12–17 (including the iteration loop) is O(v). Thus, Algorithm 1 runs in expected time Oðv 2 b=DÞ: The algorithm runs in expected linear time with respect to v when D ¼ ÂðvÞ, e.g. setting D equal to the sum of input bases. In practice, the simplifying assumption on the uniform repartition of the hash function h does not hold exactly. Some partitions contain a slightly larger number of distinct k-mers than v=H AE Ç . Hence, the actual disk usage of the algorithm is slightly above D, and the load factor of T could, in theory, be40.7 (because of high k-mer redundancy, this is not the case in practice).The dataset used is the NA18507 human genome (SRX016231), unfiltered, consisting of 1.4 billion reads of average length 100 bp (160 GB file size). Jellyfish used eight threads, DSK-SSD used four threads and DSK and BFCounter are single-threaded. The disk column indicates the temporary amount of disk space used by each method. a</p><formula>2: v P s2S jsj À k þ 1 ð Þ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>0</head><p>Executed on a desktop computer equipped with two hard drives, including an SSD.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>*</head><figDesc>To whom correspondence should be addressed. less than M/(b þ 32) distinct k-mers are inserted in T. At each iteration ðv=n iters Þ, k-mers are split into n p partitions. Each partition contains at most v=ðn iters n p Þ 0:7M=ðb þ 32Þ AE Ç k-mers. In the worst case, all these kmers are distinct; thus, the load factor is upper-bounded by 0.7 (a classical threshold above which hash table performance degrades). The time complexity of Steps 7–11 (including the iteration loop) is Oðv 2 b=DÞ. The algorithm creates ðn iters n p Þ vðb þ 32Þ=ð0:7MÞ AE Ç temporary hash tables, inserting at most ð0:7M=ðb þ 32Þ AE Ç elements in each.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.1.</head><figDesc>Fig. 1. Execution time of DSK (k ¼ 21) as a function of memory and disk usage, on the E.coli (Illumina DNA SRR001665, 20:8 Á 10 6 reads of average length 36 bp) and D.ananassae datasets (Illumina RNA-Seq SRR332538, 9:1 Á 10 6 reads of average length 150 bp)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>200 400 E. coli DNA Disk space (MB)</figDesc><table>Time (s) 

115 
1150 
4600 

0 

500 

1000 

Drosophila RNA 

Disk space (MB) 

Time (s) 

148 
743 
2975 

Memory (MB) 

10 
100 
1000 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 1.</figDesc><table>Wall-clock time and memory usage for counting 27-mers in 
whole-genome human data 

Program 
Time (h) 
Memory (GB) 
Disk (GB) 

DSK 
17.9 
4 
160 
DSK-SSD a 
3.5 
4 
240 
BFCounter 
41.2 
56 
0 
Jellyfish 
3.5 
70 
211 

</table></figure>

			<note place="foot">ß The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> RESULTS In Table 1, we compared the execution time and memory usage of DSK with Jellyfish (version 1.1.5) and BFCounter (version 0.2) on a human genome Illumina dataset. The target disk usage of DSK was set to 160 GB, equal to the size of the reads file. As the algorithm relies heavily on I/O to the disk, we also tested DSK with a solid-state drive (DSK-SSD). The reads file was placed on a standard hard disk drive, and partitions of redundant k-mers were written on a 256 GB SSD. In this configuration, we noticed the algorithm is no longer limited by disk I/O and could benefit from multi-threading. The two for loops lines 7 and 12 were parallelized using openMP (four threads). DSK-SSD ran for 3.5 h using 4 Â 1 GB of memory. Although this experiment required specific hardware, it is worth noting that the running time of DSK can be greatly reduced with an SSD and multi-core parallelism. To further assess the trade-off between time, memory and disk usage, we executed DSK (using a standard hard drive) on two smaller Escherichia coli and Drosophila ananassae datasets, with various target memory and disk usage parameters (Figure 1). For the executions with 100 MB and 1 GB memory usage, the running time of DSK on both datasets decreases as the target disk space increases. This is a consequence of the decreasing number of iterations n iters. The running times reach a plateau at roughly the reads file size (where n iters ¼ 1). The execution time generally seems to be unaffected by the target memory usage. However, at the smallest tested memory usage (10 MB), the execution time on both datasets is slightly higher, possibly because of consecutive disk writes to a large number of partitions. Note that in practice, the memory usage of DSK cannot be arbitrarily low: it is limited by the number of files that can be simultaneously opened on the system (partitions fd 0 ,. .. , d np g are all opened simultaneously). 4 DISCUSSION Contrary to other methods, DSK does not provide random access to k-mer counts. However, it benefits from three strong points: Low-memory usage: Only an arbitrarily small subset of kmers is loaded in memory at any time. In contrast, BFCounter stores all the k-mers with count ! 2 in a hash table. In principle, Jellyfish can use arbitrarily small hash tables; however, storing the intermediate results requires a prohibitive amount of disk (! 1 TB for human genome reads using a hash table of size 5 GB). Parameters are automatically inferred: The only mandatory argument is the k-mer length. Optionally, target memory and disk usages can be specified. Jellyfish and BFCounter require the user to specify a hash table size and an upper-bound on the number of distinct k-mers, respectively. Supports arbitrarily large values of k: As opposed to up to 32 for Jellyfish (unbounded for BFCounter). Funding: ANR MAPPI, ANR-10-COSI-0004. Conflict of Interest: none declared.</note>

			<note place="foot">DSK: k-mer counting at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Marc¸aismarc¸ais</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Kingsford</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="764" to="770" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient counting of k-mers in DNA sequences using a bloom filter</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Melsted</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Pritchard</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">333</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>