
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:28+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Genome analysis Ruffus: a lightweight Python library for computational pipelines</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010">. 21 2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Leo</forename>
								<surname>Goodstadt</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Physiology, Anatomy and Genetics</orgName>
								<orgName type="laboratory">Medical Research Council Functional Genomics Unit</orgName>
								<orgName type="institution">University of Oxford</orgName>
								<address>
									<postCode>OX1 3QX</postCode>
									<settlement>Oxford</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Genome analysis Ruffus: a lightweight Python library for computational pipelines</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS APPLICATIONS NOTE</title>
						<imprint>
							<biblScope unit="volume">26</biblScope>
							<biblScope unit="page" from="2778" to="2779"/>
							<date type="published" when="2010">. 21 2010</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq524</idno>
					<note type="submission">Received on August 4, 2010; revised on August 31, 2010; accepted on September 9, 2010</note>
					<note>[13:31 6/10/2010 Bioinformatics-btq524.tex] Page: 2778 2778–2779 Associate Editor: Martin Bishop</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Computational pipelines are common place in scientific research. However, most of the resources for constructing pipelines are heavyweight systems with graphical user interfaces. Ruffus is a library for the creation of computational pipelines. Its lightweight and unobtrusive design recommends it for use even for the most trivial of analyses. At the same time, it is powerful enough to have been used for complex workflows involving more than 50 interdependent stages. Availability and implementation: Ruffus is written in python. Source code, a short tutorial, examples and a comprehensive user manual are freely available at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Large-scale computational analyses are now integral to many biological studies. 'Workflow' management systems have accordingly proliferated, including Taverna (<ref type="bibr" target="#b3">Oinn et al., 2004</ref>), Biopipe (<ref type="bibr" target="#b2">Hoon et al., 2003</ref>) and Pegasys (<ref type="bibr" target="#b4">Shah et al., 2004</ref>). These are highly featured, designed for automated and robust operation even by nonexpert users, managed using graphics user interfaces and specified in XML or proprietary domain-specific languages. However, these workflow systems can be too cumbersome for explorative and empirical studies with novel datasets. The appropriate scientific approach cannot always be determined a priori. On the other hand, the advantages of computational pipelines over ad hoc scripts, even for simple tasks, are all more apparent with increasingly complex datasets and the use of parallel processing. The standard Unix build (software construction) system 'make' has been widely used to keep track of dependencies in scientific pipelines. 'Makefiles'specify the files names of data for the input and output of each stage of a pipeline as well as the 'rules' (commands) for generating each type of output from its corresponding input. The entire pipeline is represented by a statically inferred dependency (directed acyclic) graph for the succession of data files. The same 'rule' can be applied to multiple data files at the same time, for example, to run BLAST searches on many sequence files in parallel. Automatic data tracking in pipelines allows only the out-of-date parts of the analyses to be rescheduled and recalculated, with minimal redundancy. This is necessary when parts of the pipeline are subject to rapid cycles of development or where the underlying data is being generated continually. Unfortunately, 'make' is not a good fit for the design of scientific pipelines. 'Make' specifications are written in an obscure and limited language. (This is mitigated in 'make' replacements such as 'scons' or Ruby 'rake'). Pipeline dependencies are not specified directly but inferred by the 'make' program by linking together 'rules' in the right order. This means that scientific pipelines can be difficult to develop, understand and debug. So-called 'embarrassingly parallel' problems are particularly common in bioinformatics; examples include BLAST and HMMer searches of sequence databases, or region-by-region genome annotation. The number of parallel operations needed varies at 'runtime' with the presented data: a larger sequence file might be split up into smaller fragments to be processed in parallel. However, 'make' systems and their kin require all operations in a pipeline to be determined when the build script is analysed, because of the reliance on static, pre-calculated dependency graphs. They cannot easily deal with, for example, the splitting up of large problems into smaller fragments to be computed in parallel, if the number of such fragments depends on the input data and runtime conditions, and can only be determined in the middle of running the pipeline. In this article, we present a new lightweight library for computational pipelines that explicitly supports these programming tasks. Some of its main advantages of Ruffus are:</p><p>@BULLET Ruffus configuration files are normal Python scripts. Python is a modern dynamically typed programming language known for its elegance, simplicity, and that is already widely used in the bioinformatics community (<ref type="bibr" target="#b1">Cock et al., 2009</ref>). Standard Python tools can be used to develop and debug Ruffus scripts.</p><p>@BULLET Like 'makefiles', Ruffus scripts can run only the out-of-date parts of the pipeline, using parallel processing if appropriate.</p><p>@BULLET Pipeline dependencies are specified explicitly for maximal clarity and ease of documentation. @BULLET A flowchart of the pipeline can be printed out in a variety of graphical formats. Detailed trace output is available, documenting which operations are up-to-date or will be run (<ref type="figure" target="#fig_1">Fig. 1</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DESIGN</head><p>Ruffus is a module for the python language that adds lightweight support for computational pipelines. Each stage of the pipeline is a separately written (normal) python function. By convention, strings contained in the first two arguments of pipelined functions are assumed to be names of input and output files for this stage. The modification times of the underlying files are used to determine if this part of the pipeline is up-to-date or not, and should be re-run.Page: 2779 2778–2779Ruffus ensures that these pipeline functions are called in the right order with appropriate arguments. For example, when the pipeline specifies BLAST (<ref type="bibr" target="#b0">Altschul et al., 1990</ref>) searches on four sequence files, three separate calls to the appropriate python function will be made, in parallel if necessary. To register pipeline stages, Ruffus provides some simple keywords (<ref type="figure" target="#tab_1">Table 1</ref>) using standard python syntax. These python 'decorators' placed before each function indicates how the stages of the pipeline are linked together, the type of operation and what arguments to supply to each stage of the pipeline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ruffus</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">FUNCTION AND EXAMPLES</head><p>A standard bioinformatics task for running a blast search efficiently in parallel might involve splitting the initial large sequence file into smaller pieces, calling the BLAST executable for each, and then combining the separate high scoring segment pairs (HSPs) into the final list of matches. These three operations would be represented by three python functions 'decorated' by the 'split', 'transform' and 'merge' Ruffus keywords. The syntax (in outline) would be as follows:This will run the three-stage pipeline using up to five processors in parallel, firstly splitting up the starting sequence file 'original.fasta' into multiple files with the suffix '.segment', then running the BLAST program (<ref type="bibr" target="#b0">Altschul et al., 1990</ref>) to produce corresponding files with the '.blastResult' suffix, and finally combining all these into the file 'final.blast_results'. The trace file for this simple pipeline, as well as its flowchart produced by Ruffus, is shown in<ref type="figure" target="#fig_1">Figure 1</ref>. More challenging examples using, for example, the full power of regular expressions to manage pipeline data files, can be found in the Ruffus documentation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONCLUSION</head><p>Ruffus is a python library for programming computational pipelines with lightweight, unobtrusive syntax. It provides all the power of traditional build systems such as automatic data tracking, but in a modern package suited to the needs of bioinformatics. Sample flowcharts of Ruffus pipelines, a tutorial, a detailed manual as well as source code are freely available from http://www.ruffus.org.uk and http://code.google.com/p/ruffus.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>[13:</head><figDesc>31 6/10/2010 Bioinformatics-btq524.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.1.</head><figDesc>Fig. 1. Trace output and flowchart for a simple Ruffus pipeline.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. Examples of Ruffus 'decorator' keywords</figDesc><table>Ruffus Keyword 
Function of annotated pipeline function 

Split 
Splits up input file into a number of output files 
(a one-to-many operation) 
Transform 
Transforms each input into a corresponding output 
Merge 
Merges multiple input into a single output 
(a many-to-many operation) 
Collate 
Group together subsets of input, summarizing each 
as a separate output. 

</table></figure>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Basic local alignment search tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="403" to="410" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Biopython: freely available Python tools for computational molecular biology and bioinformatics</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">J</forename>
				<surname>Cock</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1422" to="1423" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Biopipe: a flexible framework for protocol-based bioinformatics analysis</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hoon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1904" to="1915" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Taverna: a tool for the composition and enactment of bioinformatics workflows</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Oinn</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="3045" to="3054" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Pegasys: software for executing and integrating analyses of biological sequences</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">P</forename>
				<surname>Shah</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">40</biblScope>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>