
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:57+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Systems biology Algorithms and complexity of enumerating minimal precursor sets in genome-wide metabolic networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">19 2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName>
								<forename type="first">Vicente</forename>
								<surname>Acuñ</surname>
							</persName>
							<email>vicente77@gmail.com, pvmilreu@gmail.com or marie-france. sagot@inria.fr</email>
							<affiliation key="aff0">
								<orgName type="institution">Université de Lyon</orgName>
								<address>
									<postCode>F-69000</postCode>
									<settlement>Lyon</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory" key="lab1">UMR5558</orgName>
								<orgName type="laboratory" key="lab2">Laboratoire de Biomé trie et Biologie Evolutive</orgName>
								<orgName type="institution" key="instit1">Université Lyon 1</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-69622</postCode>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="laboratory">Center for Genome Regulation (Fondap 15090007) and Center for Mathematical Modeling (UMI 2807 CNRS)</orgName>
								<orgName type="institution">University of Chile</orgName>
								<address>
									<settlement>Mathomics, Santiago</settlement>
									<country key="CL">Chile</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">INRIA Rhô ne-Alpes</orgName>
								<address>
									<postCode>38330</postCode>
									<settlement>Montbonnot Saint-Martin</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Paulo</forename>
								<surname>Vieira Milreu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">Université de Lyon</orgName>
								<address>
									<postCode>F-69000</postCode>
									<settlement>Lyon</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory" key="lab1">UMR5558</orgName>
								<orgName type="laboratory" key="lab2">Laboratoire de Biomé trie et Biologie Evolutive</orgName>
								<orgName type="institution" key="instit1">Université Lyon 1</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-69622</postCode>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">INRIA Rhô ne-Alpes</orgName>
								<address>
									<postCode>38330</postCode>
									<settlement>Montbonnot Saint-Martin</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Ludovic</forename>
								<surname>Cottret</surname>
							</persName>
							<affiliation key="aff4">
								<orgName type="laboratory" key="lab1">Laboratoire d&apos;Ingé nierie des Systè mes Biologiques et des Procé dé s (LISBP)</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5504</orgName>
								<orgName type="institution">INRA 792</orgName>
								<address>
									<postCode>31000</postCode>
									<settlement>Toulouse</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alberto</forename>
								<surname>Marchetti-Spaccamela</surname>
							</persName>
							<affiliation key="aff5">
								<orgName type="department">Dip. di Informatica e Sistemistica</orgName>
								<orgName type="institution">University of Rome La Sapienza</orgName>
								<address>
									<postCode>00184</postCode>
									<settlement>Rome, Italy</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Leen</forename>
								<surname>Stougie</surname>
							</persName>
							<affiliation key="aff6">
								<orgName type="department">Department of Economics and Business Administration</orgName>
								<orgName type="institution">VU University</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Marie-France</forename>
								<surname>Sagot</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">Université de Lyon</orgName>
								<address>
									<postCode>F-69000</postCode>
									<settlement>Lyon</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory" key="lab1">UMR5558</orgName>
								<orgName type="laboratory" key="lab2">Laboratoire de Biomé trie et Biologie Evolutive</orgName>
								<orgName type="institution" key="instit1">Université Lyon 1</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-69622</postCode>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">INRIA Rhô ne-Alpes</orgName>
								<address>
									<postCode>38330</postCode>
									<settlement>Montbonnot Saint-Martin</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Systems biology Algorithms and complexity of enumerating minimal precursor sets in genome-wide metabolic networks</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="2474" to="2483"/>
							<date type="published" when="2012">19 2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts423</idno>
					<note type="submission">Received on February 16, 2012; revised on June 6, 2012; accepted on June 29, 2012</note>
					<note>BIOINFORMATICS ORIGINAL PAPER 1087 HV Amsterdam and Centrum voor Wiskunde en Informatica (CWI), 1098 XG Amsterdam, The Netherlands Associate Editor: Trey Ideker/site/pitufosoft ware/download. Contact:</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: In the context of studying whole metabolic networks and their interaction with the environment, the following question arises: given a set of target metabolites T and a set of possible external source metabolites S, which are the minimal subsets of S that are able to produce all the metabolites in T. Such subsets are called the minimal precursor sets of T. The problem is then whether we can enumerate all of them efficiently. Results: We propose a new characterization of precursor sets as the inputs of reaction sets called factories and an efficient algorithm to decide if a set of sources is precursor set of T. We show proofs of hardness for the problems of finding a precursor set of minimum size and of enumerating all minimal precursor sets T. We propose two new algorithms which, despite the hardness of the enumeration problem, allow to enumerate all minimal precursor sets in networks with up to 1000 reactions. Availability: Source code and datasets used in our benchmarks are freely available for download at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>We recently introduced the concept of a minimal precursor set which corresponds to a set of metabolites that an organism may obtain from its environment and that enables it to produce a set of metabolic targets of interest (see<ref type="bibr" target="#b1">Cottret et al. (2008)</ref>for the initial definition of this concept). In this model, we propose a definition of precursor set which does not consider the stoichiometry of reactions. Indeed, the values given for such stoichiometry may often not be accurate. For instance, 51% of the reactions in the Kyoto Encyclopedia of Genes and Genomes (KEGG) were considered to be unbalanced in 2004 (<ref type="bibr" target="#b4">Feist et al., 2009</ref>) and solving these cases may become challenging for more complex reactions (<ref type="bibr" target="#b11">Thiele and Palsson, 2010</ref>). To overcome this problem, we propose instead a model based only on the topology of a metabolic network, that is that considers the set of substrates and products of each reaction without considering the amounts involved. The collection of precursor sets defined should therefore be considered as potential/candidate solutions which could be confirmed or discarded a posteriori by other sources of information. The method we developed in<ref type="bibr" target="#b1">Cottret et al. (2008)</ref>to enumerate all minimal precursor sets for a given set of targets was then applied in<ref type="bibr" target="#b2">Cottret et al. (2010a)</ref>to a relatively complex symbiotic system. In this case, the environment was represented by an insect. Homalodisca coagulata, which hosts within its cells two bacteria, respectively, Baumannia cicadellinicola and Sulcia muelleri. The identification of the precursor sets for the sets of metabolites each bacterium gives to the symbiotic system (host and co-resident endocytobiont), enabled to refine the analysis that had been done previously (<ref type="bibr" target="#b8">McCutcheon and Moran, 2007</ref>) of the complementarity between the metabolisms of the two bacteria and their host. It also suggested that both B. cicadellinicola and S. muelleri might be completely independent of the metabolites output by the co-resident endocytobiont to produce the carbon backbone of the metabolites provided to the symbiotic system. The algorithms in Cottret et al. (2010a) and Cottret et al.</p><p>(2008) suffered of a memory problem due to the necessity to construct a huge tree—called the 'replacement tree'. Moreover, the enumeration procedure followed using such a tree was not the most efficient way either to enumerate all minimal precursor sets. For small networks (5250 nodes), the previous method runs in a acceptable time, but for bigger networks it usually runs out of memory. In this article, we present new algorithms for enumerating all minimal precursor sets that address both memory requirements and time efficiency (Section 4). We also provide full proofs for the complexity results that were just indicated in<ref type="bibr" target="#b1">Cottret et al. (2008)</ref>(Section 3). We use for this a simpler characterization of a *To whom correspondence should be addressed. y The authors wish it to be known that, in their opinion, the first two authors should be regarded as joint First Authors.</p><p>precursor set that makes the concept, and the subsequent proofs, formally easier to grasp (Section 2). Finally, we show by extensive tests that the new algorithms are indeed able to deal with much larger networks, up to 1000 reactions (Section 5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DEFINITIONS AND CHARACTERIZATIONS</head><p>A metabolic network is modelled as a directed hypergraph G ¼ ðC; RÞ with C the set of vertices corresponding to metabolites (also called compounds) and R the set of hyperarcs corresponding to reactions. A directed hyperarc of a reaction r 2 R is an ordered pair of metabolite sets r ¼ ðSubsðrÞ; ProdðrÞÞ; where Subs(r) is the set of substrates of r and Prod(r) is the set of products of r. Reactions are supposed to be irreversible: each originally reversible reaction is replaced by two irreversible reactions of opposite direction. We consider also a set of sources S C representing the metabolites that are potentially available in infinite external supply. Sources used as substrates of reactions produce other metabolites, thereby increasing the set of available ones. In addition, the set T C denotes the target set, that is a set of metabolites that it is interesting to produce. Given a source set S and a target set T of metabolites, the aim is to find subsets of S which are able to produce all metabolites of T. We need now to formally define the meaning of: being able to produce the target. When stoichiometric information is missing or not (fully) reliable, two definitions have been proposed to model this concept that can give different solutions to a particular instance. Before comparing the two approaches, we introduce some notation. Let M be a set of metabolites of C. We define Reac(M) as the set of reactions that can be fired when the metabolites in M are present. In other words, ReacðMÞ ¼ fr 2 R j SubsðrÞ Mg: For a given set of reactions R R, we define the sets SubsðRÞ ¼ [ r2R SubsðrÞ and ProdðRÞ ¼ [ r2R ProdðrÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Sequencial production of the target</head><p>The forward propagation of M, denoted by Fwd(M), is the set of metabolites successively produced from M using the reactions of the network. Formally, Fwd(M) is the result of the recursion M iþ1 ¼ M [ ProdðReacðM i ÞÞ starting from M 0 ¼ M and until a fixed point is reached. For instance, in the network of<ref type="figure" target="#fig_0">Figure  1</ref>, if M 0 ¼ fa; b; cg then M 1 ¼ fa; b; c; eg; M 2 ¼ fa; b; c; e; hg and so on until the fixed point fa, b, c, e, h, i, t} is reached. Thus, Fwd(fa, b, c}) ¼ fa, b, c, e, h, i, t}. Romero and Karp (2001) considered a subset X of the sources S as a precursor set of a target T, when T FwdðXÞ. For instance, the set of sources X ¼ fa, b, c} is a precursor set of the target set T ¼ ft} since Fwd(fa, b, c}) contains t. This iterative way to calculate what is available from X may however not be enough to model some real cases. Indeed, the network could have cycles whose metabolites need to be consumed and produced all at the same time. For instance, in<ref type="figure" target="#fig_0">Figure 1</ref>reactions r 1 and r 2 form a cycle that consumes metabolites c and d to produce f and g. However, Fwd(fc, d}) ¼ fc, d}, that is it contains neither f nor g.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Including cycles in the target production</head><p>In our work, we used the model proposed in<ref type="bibr" target="#b1">Cottret et al. (2008)</ref>which defines a precursor set using a different approach. Instead of starting the propagation from a subset of the sources, the authors allow from the beginning the inclusion of other metabolites (called internal supply) provided that such metabolites are produced by some reaction in a future step of the forward propagation (besides production of the target). Formally, the authors define Fwd Z ðMÞ, the forward propagation of M with Z (as internal supply), as the result of the recursion M iþ1 ¼ M [ ProdðReacðM i [ ZÞÞ starting from M 0 ¼ M and until a fixed point is reached. A subset X of the sources is a precursor set of T if T and Z are both included in Fwd Z ðXÞ. For instance, in the network of<ref type="figure" target="#fig_0">Figure 1</ref>, Fwd ffg ðfc; dgÞ ¼ fc; d; f; g; e; h; i; tg. Thus, it produces t but also re-produces f to maintain the cycle working. DEFINITION 1. A set of sources X S is a precursor set of T C if there exists a set Z C such that T [ Z Fwd Z ðXÞ. In this case, we say that Z is an internal supply of the precursor set X. Of course, the internal supply may be not unique for a given precursor set. In<ref type="figure" target="#fig_0">Figure 1</ref>, both Z ¼ f f } and Z ¼ fg} are internal supplies for the precursor set X ¼ fc, d }. Observe also that any set of metabolites which is a precursor set by the Romero and Karp definition will continue being a precursor set for this definition just considering Z ¼ ;. Suppose now that the target is a set of metabolites whose production we want to avoid. In this case, we can define the notion of a precursor cut set or simply cut set, that is a subset X of sources such that, if they are not present, then the target cannot be produced by any combination of the remaining sources. This concept has a biological application, for instance, in the case where we want a bacterium to avoid producing some given metabolite while providing it with a maximal set of resources that enables it to continue doing its other specific tasks. As an example, in<ref type="figure" target="#fig_0">Figure 1</ref>, the set fa, d} is a cut set of ft}. DEFINITION 2. A set of sources X S is a cut set of T C if and only if the set S n X is not a precursor set of T.</p><p>If the target contains more than one metabolite, a cut will avoid the production of the whole target set but could stillAlgorithms and complexity of enumerating minimal precursor sets produce some of their elements (a strict subset of T). If we want to block each element of the target, we can modify slightly the network in the following way: given T ¼ ft 1 ;. .. ; t ' g, we can define a new target metabolite t target and reactions r t1 ;. .. ; r t' with Subsðr ti Þ ¼ ft i g and Prodðr ti Þ ¼ ft target g. Clearly, a cut set of the new target T 0 ¼ ft target g must block the production of each metabolite in T.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">New characterization using factories</head><p>We give now a simpler and more natural way to grasp the characterization of a precursor set X of T by considering, instead of metabolites, a set of reactions F R that connects X with T. Clearly, the reactions must verify these two properties: 1. (Feasibility of reactions) Each substrate of the reactions in F is contained in X or is produced by some reaction in F; 2. (Production of target) Each metabolite in the target T (which is not in X) is produced by some reaction in F.</p><p>These two conditions can be summarized in one: T [ SubsðFÞ X [ ProdðFÞ. In this case, we say that F is a factory from X to T. THEOREM 1. A set of sources X S is a precursor set of T C if and only if there exists a factory from X to T. PROOF. If X is a precursor set of T, there exists Z C such that T [ Z Fwd Z ðXÞ ¼ X [ ProdðReacðFwd Z ðXÞÞÞ. The set of reactions F ¼ ReacðFwd Z ðXÞÞ is such that T X [ ProdðFÞ and SubsðFÞ Fwd Z ðXÞ X [ ProdðFÞ. Therefore, F is a factory from X to T. Inversely, let F be a set of reactions such that T [ SubsðFÞ X [ ProdðFÞ. Defining Z ¼ Subs(F), we have Fwd Z ðXÞ ¼ X [ Prod ðReacðFwd Z ðXÞ [ SubsðFÞÞÞ which clearly contains X [ ProdðFÞ. Therefore, T [ Z Fwd Z ðXÞ. oe</p><p>In the example of<ref type="figure" target="#fig_0">Figure 1</ref>, the set fc, d} is a precursor set of ft}, since the set of reactions F ¼ fr 1 ; r 2 ; r 3 ; r 6 g is such that ftg [ fc; d; f; g; hg fc; dg [ ff; g; h; i; tg.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">COMPLEXITY RESULTS</head><p>Given a metabolic network G ¼ ðC; RÞ with S C a set of sources and T C a set of target metabolites, we address the theoretical complexity of the following three problems: MINIMALPS(T): find a minimal precursor set X S of T. MINSIZEPS(T): find a minimum size precursor set X S of T. ALLPS(T): enumerate all minimal precursor sets X S of T.</p><p>We also consider the analogous problems where what is searched are precursor cut sets: MINIMALPCS, MINSIZEPCS and ALLPCS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Finding a minimal precursor set and a minimal cut set</head><p>Given a set X S of sources, we can compute the maximal set of reactions F max that satisfy the first condition of the factory definition (feasibility of reactions). Thus, to decide whether X is a precursor set of a given T, we can compute F max of X and check whether T is included in the products of F max. To obtain this set, we use the following recursion: starting from the whole set of reactions F 0 ¼ R, compute the set F iþ1 ¼ ReacðX [ ProdðF i ÞÞ until a fixed point is reached. Defining K ¼ max r2R ðjSubsðrÞj þ jProdðrÞjÞ, we have the following result. THEOREM 2. Given a subset X S of sources and a target set T C, we can decide in polynomial time OðjCjjRj þ jRj 2 KÞ whether X is a precursor set of T. PROOF. We show the maximality of F max. Let F 0 be another set of reactions such that SubsðF 0 Þ X [ ProdðF 0 Þ. Clearly, if F 0 F i then F 0 ReacðX [ ProdðF 0 ÞÞ ReacðX [ ProdðF i ÞÞ ¼ F iþ1 , Since we start with F 0 ¼ R, we conclude that F 0 F max .</p><p>The algorithm iterates at most jRj À jF max j times. Computing F i takes OðjCj þ jRjKÞ time. Therefore, the running time of the whole procedure is OðjCjjRj þ jRj 2 KÞ. oe</p><p>This method provides also a way to find a minimal precursor set of T. Starting from X ¼ S, we successively check if removing a metabolite of X the target is still produced, maintaining in X only those that are needed to produce T. We obtain a minimal precursor set in jSj iterations. A similar procedure is also valid to find a minimal cut set starting from X 0 ¼ ; and adding sources while the target is not produced. The set X ¼ S n X 0 is a minimal cut set. COROLLARY 3. Both MINIMALPS(T) and MINIMALPCS(T) can be solved in polynomial time OðjCjjRjjSj þ jRj 2 jSjKÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Minimum size precursor set and cut set</head><p>Although finding one minimal precursor set of a target is easy, obtaining a (minimal) precursor set of minimum size is NP-hard. This result is proved by a reduction from the NP-complete problem HITTINGSET (<ref type="bibr" target="#b5">Garey and Johnson, 1979</ref>): given a finite set of elements U and a collection of subsets I ¼ fI 1 ;. .. ; I n g of U, find a minimum cardinality subset of elements H U such that H intersects all the subsets in I. THEOREM 4. The problem MINSIZEPS(T) is NP-hard. PROOF. We show hardness by proving completeness of the decision version where we ask if a precursor set of size at most k exists. Theorem 2 implies that this decision version is in NP.</p><p>We make a polynomial time reduction from the decision version of HITTINGSET, asking if there exists a hitting set of size at most k. Consider H; I and k a hitting set instance with I ¼ fI 1 ;. .. ; I n g. For each element h in H, we create a vertex h in C, and for each set I j in I , we create a vertex I j in C (<ref type="figure" target="#fig_2">Fig. 2</ref>). We create an extra vertex t in C. For each h 2 I j , we create in R an arc r hj going from h to I j. Moreover, we create the hyperarc r t having Subsðr t Þ ¼ fI 1 ;. .. ; I n g and Prodðr t Þ ¼ ftg. We define t to be the only target metabolite, and we define the vertices corresponding to the elements of H as the sources S of G. oe</p><p>Observe that in the above reduction, there is a one-to-one relation between hitting sets and precursor sets, and a related pair is of the same size. This implies that MINSIZEPS is as hard to approximate in polynomial time as HITTINGSET, which is known to be APX-hard (<ref type="bibr" target="#b0">Ausiello et al., 1999</ref>). Namely, no polynomial time algorithm for MINSIZEPS can have approximation ratio oðlog nÞ unless P ¼ NP (<ref type="bibr" target="#b9">Raz and Safra, 1997</ref>).A similar proof shows NP-hardness for the problem of finding a minimum size cut set. We consider in this case the same reduction but with two modifications (<ref type="figure" target="#fig_3">Fig. 3</ref>, left): (i) replace the hyperarc r t (from fI 1 ;. .. ; I n g to t) by n separate reactions, from each I j to t, for j 2 f1;. .. ; ng and (ii) replace, for each I j , the set of reactions producing I j by a single reaction r j producing I j from the whole set of elements of I j. In this case, each hitting set corresponds to a cut set. Therefore, MINSIZEPCS(T) is NP-hard and APX-hard. Related hardness results are as follows:</p><p>PROPOSITION 5. Given a precursor set X of T, the following two problems are NP-hard: 1. Find a minimum cardinality set of metabolites Z such that Z is an internal supply of X.</p><p>2. Find a minimum cardinality set of reactions F such that F is a factory from X to T. PROOF. We modify the reduction presented in the proof of Theorem 4 as follows (<ref type="figure" target="#fig_3">Fig. 3</ref>, right): for each element h in H, we create another extra vertex h 0 in C, and two reactions r hh 0 and r h 0 h from h to h 0 and from h 0 to h, respectively, the set of sources S is empty and the remaining of the construction stays the same. It is easy to see that the only minimal precursor set of T is the empty set. Using similar arguments as in the previous reduction, we have that any possible set Z corresponds to a hitting set. Analogously, any possible factory F corresponds also to a hitting set. oe</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Enumerating all minimal precursor sets and cut sets</head><p>We showed that MINIMALPSðG; S; TÞ can be solved in polynomial time. Nevertheless, if we are interested in finding all minimal precursor sets of T, the number of solutions can grow exponentially. We are therefore interested in knowing whether ALLPS can be solved in polynomial total time, that is, polynomial in the size of the input and output (<ref type="bibr" target="#b7">Johnson et al., 1988</ref>). Given a boolean ^; _Àformula f (that is with no negation), a prime implicant is a minimal set of variables such that if they are all TRUE then f is TRUE (for instance, fp, s} is a prime implicant of f ¼ ðp _ qÞ ^ ðr _ ðp ^ sÞÞ ^ s ). Enumerating the set of all prime implicants of f cannot be done in polynomial total time unless P ¼ NP (<ref type="bibr" target="#b6">Gurvich and Khachiyan, 1999</ref>). We show that this problem can be reduced to ALLPS. THEOREM 6. The enumeration problem ALLPS cannot be solved in polynomial total time unless P ¼ NP. PROOF. Let f be an ^; _-formula. The set C of metabolites corresponds to the set of variables plus one metabolite for each conjunction and disjunction inside the formula (<ref type="figure" target="#fig_4">Fig. 4</ref>). The sources are the metabolites corresponding to each single variable. The set of hyperarcs is as follows: for each metabolite representing a conjunction c in f, there is a single hyperarc from the clauses of c to the metabolite c, and for each metabolite representing a disjunction d, there are arcs from each term of d to the metabolite d. The target set is a singleton containing the metabolite representing f. Clearly, a minimal precursor set of T corresponds to a prime implicant of f and vice versa. oe</p><p>Observe that the reduction holds even in the case of networks without cycles (for any reasonable definition of cycle). This result is also valid if we consider the enumeration of all minimal precursor cut sets of T. Indeed, in the reduction of Theorem 6, a minimal cut set corresponds exactly to a prime implicate of the boolean function f, that is to a minimal set of variables such that if all are FALSE then f is FALSE. As for prime implicants, enumerating the set of prime implicates cannot be done in polynomial total time unless P¼NP (<ref type="bibr" target="#b6">Gurvich and Khachiyan, 1999</ref>). Thus, the enumeration problem ALLPCS cannot be solved in polynomial total time unless P ¼ NP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Simultaneous enumeration of precursor sets and cut sets</head><p>Although enumeration of minimal precursor sets and enumeration of minimal cut sets are both hard problems, we now show that the enumeration of both problems simultaneously can be done in quasi-polynomial total time (that is in time N OððlogNÞ c Þ for some c fixed and N the size of the input and output). Indeed, we can represent any set of sources X S as a vector of f0; 1g jSj. We denote by P T the collection of all minimal precursor sets ofAlgorithms and complexity of enumerating minimal precursor sets T, and by C T the collection of all minimal cut sets of T. We define the function F : f0; 1g jSj ! f0; 1g as F(X) ¼ 1 if X is a precursor set of T and F(X) ¼ 0 otherwise. It is easy to see that F is a monotone boolean function (although it is not explicitly expressed as a conjunction and disjunction of literals) whose prime implicants are exactly P T and whose prime implicates are exactly C T. In Gurvich and Khachiyan (1999), the authors show an incremental method to enumerate both prime implicants and prime implicates of a monotone boolean function at the same time. Roughly, given a collection P 0 [ C 0 of solutions already found (with P 0 P T and C 0 C T ), the method finds a set X S such that X is not superset of any minimal precursor set in P 0 and S n X is not superset of any minimal cut set in C 0. Since either X is a precursor set or S n X is a cut set, we have found a new solution not in P 0 [ C 0. The algorithm finds this new solution in Oðnð þ nÞÞ þ m Oðlog mÞ , where n is the number of variables, m the number of solutions already found and is the time to compute the value F(X). By Theorem 2, is OðjCjjRj þ jRj 2 KÞ. Therefore, given m solutions in P T [ C T , we can obtain a new solution in time OðjSjjCj 2 þ jSjjCjjRjK þ jSj 2 Þ þ m Oðlog mÞ. COROLLARY 7. The collections P T and C T can be jointly enumerated in quasi-polynomial incremental (and hence total) time.</p><p>Observe that applying the same method to enumerate only one collection (i.e. discarding the solutions of the other) can be very inefficient. Some instances can have exponentially more cut sets than precursor sets (that is jP T j5 5jC T j), and thus obtaining all precursor sets can take more than quasi-polynomial time compared with jP T j. Analogously, there are instances where jC T j5 5jP T j. In the next section, we present algorithms to enumerate all precursors sets by taking advantage of the network topology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">PRECURSOR SETS ENUMERATION</head><p>We present two new algorithms that compute the collection of all minimal precursor sets of a target set T. To facilitate the exposition, we suppose that the metabolic network studied has the following properties: (i) each source x 2 S is not produced by any reaction and (ii) each reaction belongs to at least one factory from the sources to the target. It is not difficult to see that by applying the following steps, we transform any network in order to satisfy these conditions without changing the collection of precursor sets of a target T: 1. Sources are not products: rename as x 0 each x in S that is the product of at least one reaction. Then, add a new reaction with substrate a new metabolite labelled x and product x 0. The set of sources continues to be S.</p><p>2. All reactions in a factory: compute the maximal factory (see proof of Theorem 2) and remove all reactions in the complement. Remove all unconnected metabolites.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Backtracking from the target to the sources</head><p>The general approach to enumerate P T (the collection of all minimal precursor sets of T) proceeds by backtracking: starting from the target, the method performs a kind of depth-first search on the hypergraph using reactions in opposite direction. In this way, the factories that produce T starting from any minimal source sets are covered. Since we are considering hyperarcs, each factory is composed by more than one path of the depth-first search from the target to the sources. We thus obtain the whole set of solutions only at the end of the algorithm, when all paths have been travelled. A similar idea was already presented in<ref type="bibr" target="#b1">Cottret et al. (2008)</ref>. The algorithm PITUFO was proposed to enumerate all minimal precursor sets by building a replacement tree which represented all paths obtained by going from T to the sources by using the reactions in reverse order. In a second step, this tree was compacted from the sources to the target until it reaches depth 2, on which the solutions were easily recognizable. The main problem of this method is the huge amount of memory needed to build the replacement tree, which made the algorithm useful only for small networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Decomposing into subproblems</head><p>We decompose the problem into subproblems where each subproblem has M as target set. Starting from M :¼ T, two kinds of subproblem decompositions are successively applied: 1. Target decomposition: given a target M ¼ fm 1 ;. .. ; m k g and X a precursor set of M, then X can be written as X ¼ [ k i¼1 X i , where each X i is a precursor set of M i ¼ fm i g. Thus, we can enumerate P M by enumerating P fmg (the minimal precursor sets of fm}) for each metabolite m 2 M and taking all the corresponding unions of solution sets (one set from each collection). 2. Reaction decomposition: if the target is a singleton M ¼ fm} and r 1 ;. .. ; r ' is the set of all reactions producing m (which is not empty if m is not a source), then X is a precursor set of M if and only if X is a precursor set of some M i ¼ Subsðr i Þ with i 2 f1;. .. ; 'g. Thus, to enumerate P fmg , we can enumerate P SubsðrÞ for all the reactions r that produce m, and then take the union of the collections.</p><p>In both decompositions, solutions are obtained after discarding the possible non-minimal sets obtained. Successively alternating these decompositions, the aim is to have subproblems where the target is a singleton source fs}, which has the set fs} itself as the only precursor set, that is P fsg ¼ ffsgg.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Including available metabolites in the input</head><p>The difficulty in implementing the above described approach is given by the presence of cycles in the network. Indeed, cycles can make the algorithm enter into an endless loop. For this reason, we must include explicitly in the input of the subproblems the set of available metabolites, that is the metabolites already analysed in previous steps of the algorithm. In this way, we can avoid continuing the search for precursor sets of these metabolites. Thus, given a set A of available metabolites, we conveniently consider the following generalization of the precursor set definition. DEFINITION 3. Given a set of sources S, a target M and a set A of available metabolites, we say that a set X S is a precursor set of M when A is available if there is a factory from X [ A to M. Observe that, if P M ðAÞ denotes the collection of all precursor sets of M when A is available, then P T ð;Þ is exactly the collection of all minimal precursor sets of T. Thus, starting from T and having A ¼ ; available, we successively apply the target and reaction decompositions increasing, at each step, the set of available metabolites. We finally need to solve the subproblems P fmg ðAÞ which are composed of one of these two base cases:</p><p>(a) m is available: if m is in A, then P fmg ðAÞ contains only the empty set as element, i.e. P fmg ðAÞ ¼ f;g.</p><p>(b) m is not available but is a source: if m 2 S n A, then P fmg ðAÞ ¼ ffmgg.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Increasing the set of available metabolites</head><p>We show how the set of available metabolites can be increased in each subproblem decomposition. Observe that increasing the set A of available metabolites is not only necessary to avoid cycling. The bigger is this set, the shorter are the factories that produce the given target when A is available, that is we can arrive faster to the base case (a). Thus, in each decomposition, we try to maximize the set of available metabolites that can be added without changing the solution of the original problem. As mentioned before, to enumerate the collection P M ðAÞ, we can enumerate the collections P fmig ðAÞ for each m i 2 M and compute all possible unions of its elements (one from each collection). In fact, in the enumeration of the solutions of P fmig ðAÞ, we can include as available any other metabolite in M different from m i , that is P fmig ðA [ ðM n fm i gÞÞ. Indeed, we know that these metabolites will be produced by the precursor sets given by the other parallel subproblems called. In the next lemma, for a given collection of sets X, minimal<ref type="bibr">[X]</ref>is the collection of all sets of X that are not supersets of any other set of X. LEMMA 8. Given the sets M ¼ fm 1 ;. .. ; m ' g C and A C, we have the following relation:</p><formula>P M ðAÞ ¼ minimal [ ' i¼1 X i s:t:X i 2 P fmig A [ ðM n fm i gÞ ( ) " # :</formula><p>PROOF. Given X 2 P M ðAÞ, there is a factory F such that M [ SubsðFÞ X [ A [ ProdðFÞ. Therefore, fm i g[ SubsðFÞ X [ A [ ProdðFÞ for all m i 2 M. Adding ðM n fm i gÞ to the right side, we conclude that F is a factory from X [ ðM n fm i gÞ [ A to fm i g for all m i 2 M.</p><p>Conversely, given for all m i 2 M the sets X i 2 P fmig ððM n fm i gÞ [ AÞ, there exist sets F i such that</p><formula>fm i g [ SubsðF i Þ X i [ ðM n fm i gÞ [ A [ ProdðF i Þ for all m i 2 M. This implies that m i 2 X i [ A [ ProdðF i Þ, and also implies that M [ SubsðFÞ X [ M [ A [ ProdðFÞ; where F ¼ [ i F i and X ¼ [ i X i. These two relations in turn imply M [ SubsðFÞ X [ A [ ProdðFÞ. oe</formula><p>In the case of reaction decomposition, computation of P fmg ðAÞ (when we are not in one of the base cases) requires to compute P SubsðrÞ ðAÞ for any reaction r producing m. Clearly, since r produces m, we can include m as available in the subproblems, that is P SubsðrÞ ðA [ fmgÞ (which avoids getting into an endless loop). Furthermore, we can also include any other product of r, that is P SubsðrÞ ðA<ref type="bibr">[ ProdðrÞÞ.</ref>LEMMA 9. Given m 2 C and A C, if m = 2 S [ A, then we have the following relation:</p><formula>P fmg ðAÞ ¼ minimal h [ 8r producing m P SubsðrÞ À A [ Prod ðrÞ Á i :</formula><p>PROOF. Consider X 2 S and F R such that SubsðrÞ [ SubsðFÞ A [ ProdðrÞ [ X [ ProdðFÞ. Since m 2 ProdðrÞ, we have fmg [ Subsðfrg [ FÞ A [ X [ Prodðfrg [ FÞ. Hence, frg [ F is a factory from A [ X to fm}. Conversely, consider and F R a factory from X [ A to the target fm}. Then, F must contain a reaction r that produces m. Therefore, SubsðrÞ [ SubsðFÞ ¼ SubsðFÞ A [ X [ ProdðFÞ A [ ProdðrÞ [ X [ ProdðFÞ. F is also a factory from X [ A [ ProdðrÞ to Subs(r). Hence, the collection of sets X having a factory from X [ A to the target fm} is the same as the collection of sets of X having a factory from X [ ProdðrÞ [ A to Subs(r) for any r producing m. By considering minimality on each side, we conclude the proof. oe</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Pruning solutions by minimality</head><p>While performing reaction decomposition, there might exist reactions that can be a priori discarded because they do not give any minimal solution. Indeed, if r and r 0 produce m, and furthermore if the set of substrates of r that are not in A is a subset of the set of substrates of r 0 that are not in A, then for any solution to the subproblem defined on Subsðr 0 Þ, we have a solution smaller or equal on Subs(r). In other words, any solution given by r 0 is not minimal or is included in the solutions given by r. Therefore, we can avoid computing P Subsðr 0 Þ ðProdðr 0 Þ [ AÞ without losing minimal precursor sets. LEMMA 10. Let r and r 0 be two reactions producing m such that</p><formula>SubsðrÞ n A Subsðr 0 Þ n A. Then for any solution X 0 2 PðSubsðr 0 Þ; Prodðr 0 Þ [ AÞ, there is a solution X 2 PðSubsðrÞ; ProdðrÞ [ AÞ such that X X 0. PROOF. Since X 0 2 P Subsðr 0 Þ ðProdðr 0 Þ [ AÞ, there exists X 0 such that Subsðr 0 Þ [ SubsðFÞ Prodðr 0 Þ [ A [ X 0 [ ProdðFÞ. Therefore, SubsðF [ fr 0 gÞ [ A A [ X 0 [ ProdðF [ fr 0 gÞ.</formula><p>By hypothesis, SubsðrÞ Subsðr 0 Þ [ A, and then we can add Subs(r) to the left side of the previous equation: SubsðrÞ [ SubsðF [ fr 0 gÞ [ A A [ X 0 [ ProdðF [ fr 0 gÞ. By removing the union of A on the left and adding the union of Prod(r) on the right, we obtain SubsðrÞ [ SubsðF [ fr 0 gÞ A [ ProdðrÞ [X 0 [ ProdðF [ fr 0 gÞ. In other words, F [ fr 0 g is a factory from A [ ProdðrÞ [ X 0 to Subs(r). We conclude that there exists X X such that X 2 P SubsðrÞ ðProdðrÞ<ref type="bibr">[</ref>Thus, if we compute the solutions of P fmg ðAÞ by using Lemma 9, we can first compute SubsðrÞ n A for all reactions r producing m and not consider those reactions where this set is not minimal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithms and complexity of enumerating minimal precursor sets</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm TRD: target–reaction decomposition</head><p>Our first algorithm, called TRD, consists in successively applying target and reaction decompositions using the procedures TDecomp and RDecomp below until reaching the base cases. The first method uses the subroutine CrossUnions(U, P m ) that computes the collection of all unions of one set of U and one set of P m. Running TDecomp(M, A), we obtain exactly all the minimal precursor sets of M when A is available. Algorithm TRD is therefore given by the execution of TDecomp(T,;). TDecomp(M C; A C): U :¼ ½fg; For each metabolite m 2 M do If m is in A then P m :¼ ½fg else if m is in S then P m :¼ ½fmg else P m :¼ RDecomp(m, A [ ðM n fmgÞ);</p><formula>U :¼ CrossUnions(U; P m ); Return the collection minimalðUÞ. RDecomp(m 2 C; A C): P :¼ ½ ; For each reaction r producing m with SubsðrÞ n A minimal do U r :¼ TDecomp(Subs(r), A [ ProdðrÞ); P :¼ P [ U r ;</formula><p>Return the collection minimalðPÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Including factories as pseudo-reactions</head><p>A main limitation of TRD is the following. Method RDecomp(m, A) outputs all precursor sets of fm} when A is available. This means that, if X is a set included in the output, we know that there exists a factory from X [ A to fm}. If RDecomp is called again as a subproblem on the same metabolite m with a similar available set A 0 , then most of the successive decompositions will be repeated again until the base cases are reached. In this sense, the algorithm has no memory about the factories previously computed. We propose a new algorithm that, each time that a decomposition is finished, includes this information in the network by adding pseudo-reactions representing the previously computed factories. For instance, if in the network there is a factory from X [ A to fm} given by reactions r 1 and r 2 , then we include a pseudo-reaction r 1þ2 with Subsð r 1þ2 Þ ¼ X [ A and Prodð r 1þ2 Þ ¼ fmg. Clearly, this operation is safe: the precursor sets of T do not change. Moreover, we do not want to lose the information about the remaining of the metabolites produced by the factory, which are used to increment the set A of available metabolites. For this reason, we associate to each pseudo-reaction r a set Intð rÞ of internal available metabolites which contains any metabolite produced by the reactions represented by r. Thus, if we use this reaction in a future decomposition, we can consider this set as available. If we define IntðrÞ ¼ ProdðrÞ for any original reaction r of the network, then we do not need to distinguish between reactions and pseudo-reactions. In the previous example, we have then that Intð r 1þ2 Þ ¼</p><formula>Intðr 1 Þ [ Intðr 2 Þ.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Reaction replacement</head><p>Adding new pseudo-reactions to the network decreases the number of reactions of the factories from X to fm}. However, to really decrease the time, we need to ensure that the algorithm will not consider again the original factory. Otherwise, if m is revisited, the algorithm would analyse both the original factory and the new one containing the new added reactions. To avoid this, we delete the original reaction producing m but while guaranteeing that the collection of minimal precursor sets of T is maintained. Suppose that we want to delete a reaction r producing m. Notice that any factory from X to m that contains r must also contain at least one reaction producing each substrate of r (except the sources). Thus, if r is merged with each set of such reactions then r can be removed without modifying the minimal precursor sets. More formally, given a reaction r, we say that a set of reactions R is a predecessor reaction set of r, if R produces all the substrates of r that are not sources, that is ProdðRÞ SubsðrÞ n S. Let R min ðrÞ be the collection of all minimal predecessor reaction sets of r. Clearly, any factory containing r must also contain a set R 2 R min ðrÞ. The following method Replace(r) removes reaction r and adds pseudo-reactions corresponding to the merge of r with every reaction set R 2 R min ðrÞ (<ref type="figure">Fig. 5</ref>). Replace(r 2 R) Compute R min ðrÞ ¼ minfR R j ProdðRÞ SubsðrÞ n Sg; For each set R 2 R min do Add a new reaction r R to the network with Prodð r R Þ :¼ ProdðrÞ, Intð r R Þ :¼ IntðRÞ<ref type="bibr">[</ref><ref type="figure">Fig. 5</ref>. Example of the application of Replace to reaction r 0. Left: reaction r 0 has internal production m and f (enclosed in a rectangle). The substrates of r 0 are s (which is a source), a and b. The collection R min ðr 0 Þ contains the minimal sets of reactions that produce a and b, that is R min ðr 0 Þ ¼ ½fr 1 ; r 3 g; fr 2 ; r 3 g. Right: we replace r 0 by new reactions corresponding to the merge of r 0 to each set of reactions of R min ðr 0 Þ. Thus, reaction r 0 is replaced by reactions r 013 and r 023. Notice that the substrates of r 013 do not include substrates of r 3 since they are internally produced by r 1 and r 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V.Acuñ a et al.</head><p>LEMMA 11. Let r 2 R be a reaction of the network G and let G 0 be the network that results from applying the procedure Replace(r). Then, X is a precursor set of T in G if and only if X is a precursor set of T in G 0. PROOF. The factories in G which do not include r are factories also in G 0. Let F R be a factory from X to T in G which contains r. Clearly, F must contain a set R 2 R min ðrÞ. Thus, the set F 0 ¼ F [ f r R g n frg is a factory from X to T in G 0. Conversely, if F 0 is a factory from X to T in G 0 containing the set R new ¼ f r R1 ;. .. ; r Rk g of new reactions added by Replace(r), then F ¼ ðF 0 n R new Þ [ frg [ S k i¼1 R i is a factory from X to T in G. oe</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm NS: network shortcutting</head><p>We define a new algorithm ns to compute all precursor sets of a target T based on reaction replacement. The following preprocessing of the network is required: a new metabolite t and a new reaction r t are created, such that Subsðr t Þ ¼ T and Prodðr t Þ ¼ ftg. Clearly, the minimal precursor sets of ft} are exactly the minimal precursor sets of T. Starting from r :¼ r t , NS traverses the network in the same way that TRD does. However, instead of computing the minimal solutions, NS goes deep in the recursion until finding a reaction r satisfying the following two conditions: (a) not all substrates of r are in the base cases and (b) all substrates of all reactions in the next level of the recursion are in the base cases. When such a reaction is found, then it is replaced by new reactions. Successively removing and adding reactions in this way, we decrease the size of the factories from S to ft}. Finally, the last reaction removed is r t which is replaced by new reactions producing t and having only sources as substrates. The substrates of each reaction correspond exactly to a minimal precursor set of ft}. Running NS(r t ; ;) we obtain a network where the minimal precursor sets are exactly the substrate sets of all the reactions that produce t. The network can also contain many other reactions, but they are not even connected to t. NS(r 0 2 R; A C): M :¼ Subsðr 0 Þ; If M contains a metabolite not in A [ S then For each metabolite m 2 M n ðA [ SÞ do NewA :¼ A [ ðM n fmgÞ; For each r producing m with SubsðrÞ n NewA minimal do NS(r, NewA [ IntðrÞ); Replace(r 0 );</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PERFORMANCE ANALYSIS</head><p>Extensive tests were performed in order to measure the performance of the different algorithms on real metabolic networks. These algorithms were compared for several different singleton target sets (for instance, amino-acids, metabolites related to the synthesis of the cell wall, DNA, RNA, membranes, etc.) in seven networks of different sizes and topologies downloaded from MetExplore (<ref type="bibr" target="#b3">Cottret et al., 2010b</ref>). Ubiquitous metabolites were filtered out and the split reactions using pairs of co-factors option was chosen. We adopted an automatic process to define the set of sources based on the topology of the network. A metabolite m is considered a source if it satisfies one of these two conditions: (a) m is not the product of any reaction or (b) m is involved in only two reactions corresponding to both directions of an originally reversible reaction (i.e. m is substrate in one and product in the other). The target sets were chosen based on their role: amino-acids, metabolites related to the synthesis of the cell wall or DNA, etc.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Removing bad cycles</head><p>There are some cycles that we know a priori that are not realistic since they are able to produce compounds outside the cycle without the need of any input. In particular, the two directions of an originally reversible reaction form a cycle which can produce its metabolites without using any external source. These bad cycles must be avoided in factories since they may create fake solutions in which an empty set of metabolites produces the target. In order to avoid bad cycles in factories, we preprocess the input network breaking this kind of cycles by removing some reactions. Specifically, starting from a set M of metabolites containing only the target and an empty set R of reactions, we include in R a randomly chosen reaction producing a metabolite of M unless its inclusion generates a bad cycle. The substrates of the added reactions are included in M. Successively repeating this process we obtain a network with no bad cycles. Notice that this process corresponds to a heuristic whose result depends on the order in which reactions are chosen to be included in R.<ref type="figure" target="#tab_1">Table 1</ref>presents an extract of the results for PITUFO, the algorithm described in<ref type="bibr" target="#b1">Cottret et al. (2008)</ref>and the two different algorithms described in this article (TRD and NS) with and without the test of minimality. The targets presented are those for which finding the minimal precursor sets required more time for the new algorithms with minimality check. The table shows, for each network, the size of the sets of metabolites and reactions, and for each target, the size of the preprocessed network, the number of precursor sets found and the time in seconds that each algorithm spent. All algorithms have been implemented in Java and the running times were collected using a cluster for the computation and setting a limit of 1 GB of RAM memory for each process. Although PITUFO may be fast for small networks, its use is limited since, as the size of the networks grows, the method takes a long time to finish, and for some targets, it does not finish in the given time limit of 24 h. This already justifies the new methods presented in this work, since they do not present the same behaviour for larger networks. Concerning the minimality check, we may observe that it is not necessarily true that it improves the running time. In some cases, doing the check may even lead to worse results (example Yeast, target FADH2, NS method), while in others it may have a strong positive impact on the execution time of the algorithm which becomes 700 times faster (example, Escherichia coli, target L-aspartate, TRD method).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Benchmarks</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithms and complexity of enumerating minimal precursor sets</head><p>Notice also that as the size and complexity of the networks increase, the number of different minimal precursor sets found increases also, and it does this at a rate faster than the increase of the time needed to compute them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Computing solutions for several preprocessed networks</head><p>As mentioned before, the network free of bad cycles that is given by the heuristic proposed depends on the order in which reactions are added to R. Thus, different orders can generate different minimal precursor sets. To recover as many solutions as possible, we can repeat the search for precursors on several different results of the preprocessing part. In order to analyse the effect of this heuristic on the algorithms, we successively repeated this random process while computing, at each repetition, the number of new precursor sets obtained. The process stopsAll methods were applied to the same preprocessed network on each target. In the cases marked '*', the algorithm did not finish within 24 h. For each target, the size of metabolites and reactions after bad cycle deletion is indicated.Each iteration corresponds to repeating the heuristical random preprocessing and computing the minimal precursor sets using trd with minimality. For each target, we show the iteration where the convergence is reached, the time required, the total number of different minimal precursor sets (at the convergence), and the iterations in which a given percentage of this total number of solutions is recovered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>V.Acuñ a et al.</head><p>when no new precursor set is recovered in 10 consecutive repetitions. Analysing the results for three different targets of E. coli, this convergence criterium was reached in5100 iterations. In the three cases, 450% of the solutions were recovered in the first six repetitions and 480% in the first 50 iterations (<ref type="figure">Table 2</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>Despite the proved hardness of enumerating all precursor sets of a given target, the algorithms presented in this article can find all solutions for networks of up to around a 1000 reactions. If we restrict ourselves to the benchmark built for this article, the TRD method with minimality check is the one that presented the best behaviour on average. However, the methods vary widely depending on the target chosen. Our benchmark does not allow us to conclude which algorithm has a better performance between TRD with a minimality test and NS with and without minimality test for bigger networks. This justifies the utility of each method individually and leaves an open space for further improvements. Funding: This work was partially funded by the following projects: the French project ANR MIRI BLAN08-1335497, the French project ANR NEMO ANR-08-BLAN-0304-01, the ERC Advanced Grant Sisyphe held by Marie-France Sagot, the INRIA Associated Team SIMBIOSI, the INRIA International Partnership AMICI, the Dutch NWO-CLS MEMESA project and the Chilean FONDAP 15090007 project. Conflict of Interest: none declared.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. A metabolic network. Nodes represent metabolites and hyperarcs represent reactions. Grey nodes are sources while the black node is the target.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>V.</head><figDesc>Acuñ a et al.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Reduction of an instance of the hitting set problem. Each hitting set of I ¼ fI 1 ; I 2 ; I 3 g corresponds to a precursor set of ft} (and vice versa).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. Modification of the hitting set reduction to the proof of hardness of MINSIZEPCS (left) and to the proof of Proposition 5 (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.4.</head><figDesc>Fig. 4. Graphical representation of the reduction presented in Theorem 6.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>AÞ. oe</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. Runtime (in seconds) for computing minimal precursor sets of three singleton targets in seven different networks using five methods: PITUFO, TRD without and with the minimality pruning (respectively All and Min) and NS without and with the minimality pruning (respectively All and Min)</figDesc><table>Network (jCj=jRj) 

PITUFO 
TRD 
NS 

Target (jCj=jRj after preprocess) 
All 
Min 
All 
Min 

S. muelleri (75/65) 
L-Arginine (33/22) 
0.017 
0.062 
0.02 
0.015 
0.018 
L-Isoleucine (32/21) 
0.008 
0.069 
0.02 
0.015 
0.016 
L-Lysine (31/20) 
0.014 
0.084 
0.019 
0.021 
0.016 

Carsonella Ruddii (114/126) 
L-Leucine (86/56) 
0.005 
0.106 
0.046 
0.035 
0.047 
L-Isoleucine (83/49) 
0.055 
0.105 
0.032 
0.036 
0.040 
L-Valine (83/49) 
0.037 
0.091 
0.030 
0.028 
0.035 

B. cicadellinicola (236/229) 
Octapremyl diphos, (149/160) 
0.726 
0.283 
0.209 
0.221 
0.195 
Tetrahydrofolate (148/149) 
0.337 
0.227 
0.170 
0.237 
0.179 
Heme-O (150/161) 
1.164 
0.319 
0.208 
0.217 
0.172 

B. aphidicola (396/338) 
Pyruvate (219/87) 
0.082 
0.131 
0.105 
0.105 
0.104 
dGTP (206/76) 
0.099 
0.138 
0.126 
0.118 
0.101 
UTP (219/87) 
0.113 
0.117 
0.099 
0.148 
0.104 

Yeast (703/1010) 
FADH2 (444/314) 
* 
14.39 
5.55 
7.27 
14.55 
L-Histidine (415/269) 
* 
5.55 
4.80 
5.02 
6.62 
L-Aspartate (410/ 274) 
176.40 
4.53 
4.65 
4.82 
4.66 

Human (997/1225) 
L-Alanine (710/359) 
5058.27 
5.15 
3.34 
10.76 
10.78 
Seriapterine (698/329) 
* 
3.19 
2.96 
6.85 
2.88 
L-Cysteina (150/161) 
5579.85 
3.32 
3.32 
4.22 
3.17 

E. coli (1010/1164) 
L-Aspartate (714/507) 
* 
2139.01 
3.32 
10.57 
47.72 
L-Metionine (737/545) 
* 
632.20 
13.62 
14.08 
14.17 
Glycine (706/503) 
* 
553.21 
11.55 
11.01 
13.90 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 2.</figDesc><table>Computation of minimal precursor sets of the E. coli network 
for three targets, using several different preprocessed networks 

Target 
Convergency 
Prec. 
sets 

Iteration reaching 
X% of Prec. sets 

Iteration Time (s) 
25% 50% 80% 95% 

L-Aspartate 

71 
3128 
267 
1 
6 
49 
57 

L-Metionine 

94 
2738 
399 
1 
5 
46 
80 
Glycine 
73 
2693 
242 
1 
4 
19 
56 

</table></figure>

			<note place="foot">ß The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">V.Acuñ a et al.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<monogr>
		<title level="m" type="main">Complexity and Approximation: Combinatorial Optimization Problems and Their Approximability Properties</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Ausiello</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Springer</publisher>
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Enumerating precursor sets of target metabolites in a metabolic network</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Cottret</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Algorithms in Bioinformatics (WABI)</title>
		<meeting>the 8th International Workshop on Algorithms in Bioinformatics (WABI)<address><addrLine>Karlsruhe, Germany ; Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer Verlag</publisher>
			<date type="published" when="2008-09-15" />
			<biblScope unit="page" from="233" to="244" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">A Graph-based analysis of the metabolic exchanges between two co-resident intracellular symbionts, Baumannia cicadellinicola and Sulcia muelleri, with their insect host, Homalodisca coagulata</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Cottret</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">1000904</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Metexplore: a web server to link metabolomic experiments and genome-scale metabolic networks</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Cottret</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="132" to="137" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Reconstruction of biochemical networks in microorganisms</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">M</forename>
				<surname>Feist</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Microbiol</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="129" to="172" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title level="m" type="main">Computers and Intractability: A Guide to the Theory of NP-Completeness. Series of books in the mathematical sciences</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Garey</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Johnson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1979" />
			<publisher>W.H. Freeman</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">On generating the irredundant conjunctive and disjunctive normal forms of monotone boolean functions</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Gurvich</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Khachiyan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Appl. Math</title>
		<imprint>
			<biblScope unit="page" from="96" to="97" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">On generating all maximal independent sets</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">S</forename>
				<surname>Johnson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="119" to="123" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Parallel genomic evolution and metabolic interdependence in an ancient symbiosis</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">P</forename>
				<surname>Mccutcheon</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">A</forename>
				<surname>Moran</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="19392" to="19397" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">A sub-constant error-probability low-degree test, and a sub-constant error-probability PCP characterization of NP</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Raz</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Safra</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Ninth Annual ACM Symposium on Theory of Computing. STOC&apos;97</title>
		<meeting>the Twenty-Ninth Annual ACM Symposium on Theory of Computing. STOC&apos;97</meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="475" to="484" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Nutrition-related analysis of pathway/genome databases</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Romero</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">D</forename>
				<surname>Karp</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pacific Symposium on Biocomputing&apos;01</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="470" to="482" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">A protocol for generating a high-quality genome-scale metabolic reconstruction</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Thiele</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">O</forename>
				<surname>Palsson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Protoc</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1750" to="2799" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title level="m" type="main">Algorithms and complexity of enumerating minimal precursor sets</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>