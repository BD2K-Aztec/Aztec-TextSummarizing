
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-11T00:00+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Optimization strategies for fast detection of positive selection on phylogenetic trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Mario</forename>
								<surname>Valle</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Swiss National Supercomputing Centre</orgName>
								<orgName type="laboratory">Scientific Computing Group</orgName>
								<address>
									<settlement>Lugano</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Hannes</forename>
								<surname>Schabauer</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Ecology and Evolution</orgName>
								<orgName type="institution">University of Lausanne</orgName>
								<address>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">SIB Swiss Institute of Bioinformatics</orgName>
								<address>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Christoph</forename>
								<surname>Pacher</surname>
							</persName>
							<affiliation key="aff3">
								<orgName type="department">Safety &amp; Security Department</orgName>
								<orgName type="institution">AIT Austrian Institute of Technology</orgName>
								<address>
									<settlement>Vienna</settlement>
									<country key="AT">Austria</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Heinz</forename>
								<surname>Stockinger</surname>
							</persName>
							<affiliation key="aff4">
								<orgName type="department">Vital-IT Group</orgName>
								<orgName type="institution">SIB Swiss Institute of Bioinformatics</orgName>
								<address>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alexandros</forename>
								<surname>Stamatakis</surname>
							</persName>
							<affiliation key="aff5">
								<orgName type="department">Heidelberg Institute for Theoretical Studies</orgName>
								<orgName type="laboratory">Scientific Computing Group</orgName>
							</affiliation>
							<affiliation key="aff6">
								<orgName type="department">Institute for Theoretical Informatics</orgName>
								<orgName type="institution">Karlsruhe Institute of Technology</orgName>
								<address>
									<settlement>Karlsruhe</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Marc</forename>
								<surname>Robinson-Rechavi</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Ecology and Evolution</orgName>
								<orgName type="institution">University of Lausanne</orgName>
								<address>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">SIB Swiss Institute of Bioinformatics</orgName>
								<address>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Nicolas</forename>
								<surname>Salamin</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Ecology and Evolution</orgName>
								<orgName type="institution">University of Lausanne</orgName>
								<address>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">SIB Swiss Institute of Bioinformatics</orgName>
								<address>
									<settlement>Lausanne</settlement>
									<country key="CH">Switzerland</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Optimization strategies for fast detection of positive selection on phylogenetic trees</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="issue">8</biblScope>
							<biblScope unit="page" from="1129" to="1137"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btt760</idno>
					<note type="submission">Phylogenetics Advance Access publication January 2, 2014 Received on June 20, 2013; revised on December 19, 2013; accepted on December 23, 2013</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Associate Editor: David Posada Availability and implementation: ftp://ftp.vital-it.ch/tools/FastCodeML/. Contact:</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: The detection of positive selection is widely used to study gene and genome evolution, but its application remains limited by the high computational cost of existing implementations. We present a series of computational optimizations for more efficient estimation of the likelihood function on large-scale phylogenetic problems. We illustrate our approach using the branch-site model of codon evolution. Results: We introduce novel optimization techniques that substantially outperform both CodeML from the PAML package and our previously optimized sequential version SlimCodeML. These techniques can also be applied to other likelihood-based phylogeny software. Our implementation scales well for large numbers of codons and/or species. It can therefore analyse substantially larger datasets than CodeML. We evaluated FastCodeML on different platforms and measured average sequential speedups of FastCodeML (single-threaded) versus CodeML of up to 5.8, average speedups of FastCodeML (multi-threaded) versus CodeML on a single node (shared memory) of up to 36.9 for 12 CPU cores, and average speedups of the distributed FastCodeML versus CodeML of up to 170.9 on eight nodes (96 CPU cores in total).</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The development of evolutionary models has a long tradition in phylogenetics, and recent advances have enhanced our understanding of the molecular mechanisms involved. At the heart of these advances is the democratization of the use of the likelihood framework, which was made possible by algorithmic developments (<ref type="bibr" target="#b6">Felsenstein, 1981</ref>) and the wide availability of powerful computing platforms. The surge of genomic data is, however, pushing the limits of current implementations [e.g. (<ref type="bibr" target="#b21">Rannala and Yang, 2008</ref>)] and demands for the developments of better and more efficient ways to compute the phylogenetic likelihood function (PLF). The development of codon models is a good example to illustrate these current challenges and the benefits that can be reached by improving the efficiency of current likelihood calculations (<ref type="bibr" target="#b8">Gil et al., 2013</ref>). There are clear advantages to use codon models in phylogenetics (<ref type="bibr" target="#b25">Seo and Kishino, 2008</ref>), but these are currently not widely used because of the large computational burdens involved (<ref type="bibr" target="#b0">Anisimova and Kosiol, 2009</ref>). Further, the detection of positive selection has been facilitated by the development of new codon models. However, their application to genome-scale data comprising a large number of species, or individuals in the case of population genomic studies, remains challenging. Thus, there exists an urgent need for improved implementations and novel optimization techniques to analyse emerging genomic datasets (<ref type="bibr" target="#b16">Lemey et al., 2012;</ref><ref type="bibr" target="#b18">Murrell et al., 2012;</ref><ref type="bibr" target="#b23">Schabauer et al., 2012</ref>). The prevalent approach for detecting positive selection in protein-coding genes is to use Markov models of codon substitution to estimate the ratio of non-synonymous to synonymous changes along the branches of a phylogenetic tree (<ref type="bibr" target="#b33">Yang, 2006</ref>). The branch-site model (BSM)<ref type="bibr" target="#b33">[Yang, 2006</ref>(Section 8.4);<ref type="bibr" target="#b36">Zhang et al., 2005]</ref>allows to detect positive selection that affects a subset of codon sites for a subset of branches in a phylogenetic tree. This model is particularly useful to perform interspecific comparisons and is probably the most widely used approach for this specific purpose. The test compares a model that assumes positive selection on one branch or on a set of a priori specified branches (hypothesis H 1 ) with a null model that does not incorporate positive selection (hypothesis H 0 ). If the test is significant, the Bayes Empirical Bayes (BEB) method is used to compute the posterior probability of each particular codon to evolve under positive selection along the specified branches (<ref type="bibr" target="#b34">Yang et al., 2005</ref>). In CodeML, the test is usually applied iteratively and independently to each branch of a given phylogenetic tree (<ref type="bibr" target="#b1">Anisimova and Yang, 2007;</ref><ref type="bibr" target="#b29">Studer et al., 2008</ref>). This approach is compute bound, and although alternatives have recently been proposed, the limiting factor of such analyses *To whom correspondence should be addressed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>y</head><p>The authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors. ß The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/bync/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com still lies with the repeated calls to compute the PLF. For example, the estimation of positive selection on a large genomic vertebrate dataset (<ref type="bibr" target="#b20">Proux et al., 2009)</ref>shows the enormous computational requirements of such analyses [approx. 100 CPU years for each release of the Selectome database (<ref type="bibr" target="#b14">Kraut et al., 2010)]</ref>. As a consequence, large gene trees, comprising more than 100 sequences, are usually excluded and faster implementations of the BSM are urgently needed. This clearly illustrates the need to further optimize current software and to develop more efficient computational approaches for maximum likelihood inference on phylogenetic trees. Several recent studies introduced techniques for efficiently computing positive selection on the branches of a phylogenetic tree. One idea is to use stochastic mapping to count substitutions along the branches of a tree and thereby derive dN/dS ratios (<ref type="bibr" target="#b5">Dutheil et al., 2012;</ref><ref type="bibr" target="#b16">Lemey et al., 2012</ref>). While this approach is fast, it is computationally distinct. Alternatively, new models have been proposed to avoid the likelihood ratio test (LRT) estimation of positive selection for all branches of the tree. Instead, branch assignments are considered as a random effect within a mixed effect framework (<ref type="bibr" target="#b18">Murrell et al., 2012</ref>). Their model notably differs from the BSM (<ref type="bibr" target="#b36">Zhang et al., 2005</ref>) in that putative positive selection is not optimized on a priori defined branches, but over a subset of branches which are determined by the software. This technique reduces the computational cost of the test, but the accuracy and robustness of this new model is not yet fully characterized. Moreover, the authors introduced solutions for parallelizing BSM computations, but the parallel approach is not discussed in their article. The bottleneck in efficiency of phylogenetic software is commonly the PLF, as the majority of runtime is spent here. In (Stamatakis, 2011, p.2), the PLF is reported to consume 495% of total execution time in maximum likelihood and Bayesian tools for phylogenetic tree reconstruction. Although this was estimated when searching for the best tree topology, which is a key component of phylogenetic computations but not the focus of this article, the PLF is still the core element in all phylogenetic applications using maximum likelihood. All these areas would therefore benefit from an optimized PLF. Recent discussions have proposed to use data augmentation strategies to speed up the likelihood calculations by using heuristics to simplify the estimation of the conditional vectors at each node (<ref type="bibr" target="#b22">Rodrigue and Aris-Brosou, 2011</ref>). However, there are still opportunities for improving the PLF with respect to sequential efficiency and parallelization techniques. Our main objective is therefore to propose methodological and algorithmic improvements and parallelization strategies to compute the PLF without modifying the underlying evolutionary model. Our optimizations and parallelizations yield substantial speedups in the likelihood computations. Hence, we can apply the BSM to large trees of several hundreds of sequences and obtain results in feasible times. These computational optimizations are thus of broad applicability to further likelihoodbased phylogenetic software, including but not limited to nucleotide-and amino acid-based phylogenetic analyses in both the maximum likelihood and Bayesian frameworks (<ref type="bibr" target="#b19">Nielsen, 2005</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Number of elementary tree operations</head><p>In the BSM framework, four site classes 0, 1, 2a and 2b are applied to model combinations of purifying selection, neutral evolution, and positive selection on foreground and background branches. When computing hypotheses H 0 and H 1 , each site class has its distinct proportion according to its contribution to the overall likelihood (cf. the supplementary material for an introduction to the BSM). These proportions only depend on the two parameters p 0 and p 1 ; each site class has a specific ! value for its selective pressure in the foreground and in the background. ! 0 is in the interval (0,1), ! 1 ¼ 1 and either ! 2 41 (foreground for H 1 ) or ! 2 ¼ 1 (foreground for H 0 ). Q f0, 1, 2g corresponds to ! f0, 1, 2g , respectively. Computing the likelihood requires computing the transition probabilities for a given branch length t by computing the matrix exponential P t ¼ e Qt ¼ e SÅt , where Q is the instantaneous substitution rate matrix, S is the symmetric codon substitution matrix and Å is the diagonal matrix of codon frequencies. The resulting probability matrix P t is used to update the corresponding conditional probability vector (CPV) w, that is, w 0 ¼ P t w. Each CPV models the site-wise transition between 61 codon states (universal genetic code) along each branch of the phylogenetic tree. This operation is applied to all sites of the multiple sequence alignment (MSA) and to all nodes of the tree by means of a post-order tree traversal. The CPU-intensive computation of the CPV entails the following three computational kernels that operate on real dense matrices (similar to SlimCodeML, see Section 2.1.2): (i) eigendecomposition of a symmetric matrix [see, e.g. (<ref type="bibr" target="#b2">Bai et al., 2000)]</ref>, (ii) multiplication of a matrix by its transpose (resulting in a symmetric matrix) and (iii) multiplication of a symmetric matrix by a vector.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.1">How many decompositions?</head><p>To compute e Qt we need to decompose Q for each distinct combination of parameters (transition to transversion rate), j and !. The j are constant over site classes and parameter optimization steps; may change at each parameter optimization step (but is constant over site classes); ! varies among optimization steps and site classes. For each distinct value of !, Q is distinct and therefore needs to be decomposed separately. There are three distinct ! values over all site classes; hence, we need to decompose three Q matrices in the first parameter optimization step. For subsequent steps, ! 1 ¼ 1 remains constant, but Q 1 may change because of a new value. The total number of Q decompositions does not depend on the number of branches in the tree nor on the number of sites in the MSA. In the general case, the number of Q matrices depends on the number of unique substitution matrices in the model, which can be large in mixture models [e.g. (<ref type="bibr" target="#b15">Lartillot and Philippe, 2004;</ref><ref type="bibr" target="#b32">Venditti et al., 2008)]</ref>. With respect to other evolutionary models, similar optimizations may be applicable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.2">How many matrix</head><p>–matrix multiplications? P t has to be computed for each combination of Q and t. For our case of binary trees, the number of branches in the phylogeny equals 2nÀ2 where n is the number of extant taxa. For each distinct Q, branches have to be computed separately. The BSM applies Q 0 and Q 1 to each branch, but Q 2 only to foreground branches. In other words, P t has to be computed for all branches using Q 0 and Q 1 (site classes 0 and 1), and in addition on the foreground branch(es) by using Q 2 (site classes 2a and 2b). Therefore, we need to compute P t 2m þ l times for m branches in the phylogeny and l foreground branches; this yields ð2 Â ð2n À 2ÞÞ þ 1 ¼ 4n À 3 branches when using a single foreground branch. Overall, we need to compute 17 distinct P matrices in our example 1. This matrix–matrix multiplication is also applied in further evolutionary models based on substitution matrices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.3">How many matrix</head><p>–vector computations? In a straightforward approach, each CPV is computed along each branch for all sites and all site classes. In our example this makes 8 Â 4 Â 2 ¼ 64 CPV computations. If a CPV connected to a leaf is computed on 'clean' data [no ambiguity symbols in MSA (<ref type="bibr" target="#b3">Comnish-Bowden, 1985)]</ref>, the CPV at the leaf only contains a single 1 (0 elsewhere). In this case, computing the resulting CPV simplifies to selecting the corresponding column of the P matrix. In the general case, an upper limit of the number of involved matrix–vector multiplications per site class is the number of branches in the phylogeny Â the number of sites in the MSA. Certainly, this number can be decreased depending on similarities in the codons as discussed in Section 2.1.1 ('subtrees reuse'). Likewise, this step is important to all other evolutionary models based on substitution matrices. Further computational savings are possible. In this context, we refer to a 'subtree' as a connected part of the phylogeny where at least one node is a leaf. Whenever a particular branch of a single site applies the same P and all other CPVs of its subtree match, the particular CPV has a 'twin' in another site class and needs to be computed only once. In<ref type="figure">Figure 1</ref>, such matching CPVs are identified by matching indexes. For example, CPV23 appears in site class 1 and in site class 2b, as also CPV20 and CPV21 have twins, and they pairwise apply matching P matrices (here, all based on Q 1 ). These redundancies are caused by matching ! 0 values for site classes 0 and 2a and by matching ! 1 values for site classes 1 and 2b. In our example, this means that only 40 out of 64 (62.5%) CPVs have distinct values and will hence have to be computed. CPVs are computed recursively via a postorder traversal propagating from the leaves towards the root (<ref type="bibr" target="#b6">Felsenstein, 1981</ref>). Hence, for the BSM in general, the number of distinct CPVs depends on the location of the foreground branch in the tree (the closer to the root, the less CPV computations are required).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">IMPROVEMENTS</head><p>Here we discuss optimization techniques that we propose. Note that we have not added any heuristics, and each of the following improvements is supposed to be beneficial independent of the number of species and independent of the number of alignment sites. Specific implementation issues are described along with each optimization technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Sequential improvements</head><p>be advantageous to implement the second approach, where the additional cost for storing or linking site patterns is compensated by a faster lookup. In FastCodeML, we identify reusable subtree patterns in a preprocessing step and tag each node with the codon sequence identified by the subtree rooted in this node. Subsequently, a lookup of these tags for all sites with identical subtrees is done. Once identified, the CPV that can be re-used is linked via a pointer in the reusing tree, that is, this saves the costs of computing this particular CPV. The unused subtree can be freed to reduce memory consumption. In the example of<ref type="figure">Figure 2</ref>, computing the two CPVs incident to two leaves in box ‹ and the CPV at › are redundant, because both codon sites feature an identical subtree: all involved CPVs match. Thus three CPV computations can be saved. Related techniques for extending pattern detection and re-use in the MSA to the subtree level have already been proposed (<ref type="bibr" target="#b11">Izquierdo-Carrasco et al., 2011;</ref><ref type="bibr" target="#b28">Stamatakis et al., 2002;</ref><ref type="bibr" target="#b30">Sumner and Charleston, 2010</ref>). However, they focus on detecting patterns and avoiding redundant likelihood computations on trees whose topologies change in the course of ML tree search. For dynamically changing trees, a trade-off between the pattern detection and memory storage costs and the amount of saved computations needs to be achieved. To reduce the cost of pattern detection, the initial implementation of the Subtree Equality Vector (SEV) technique (<ref type="bibr" target="#b28">Stamatakis et al., 2002</ref>) only considered subtree patterns that contained a single identical character. The book keeping was subsequently further simplified to sites consisting entirely of gaps (<ref type="bibr" target="#b11">Izquierdo-Carrasco et al., 2011</ref>). In Kosakovsky<ref type="bibr" target="#b12">Pond and Muse (2004)</ref>, the authors suggest to sort nucleotide-based MSAs by site similarity to avoid redundant computations. This approach minimizes memory consumption, as only a subset of sites needs to be kept in memory. However, this incurs additional costs for rearranging the sites in order to maximize the number of lookups from neighboring sites. The memory consumption for our application scenario (Selectome database updates) does not represent a limiting factor. Hence, all CPVs can be kept in memory, avoiding the expensive reordering of sites. However, especially for memoryintensive approaches, it may be more effective to keep only a subset of all CPVs in memory and consider site sorting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">New matrix exponential and CPV computation</head><formula>w 0 ¼ e Qt w ¼ ^ Y ^ Y &gt; ðÅwÞ, ð1Þ</formula><p>where ^ Y ¼ Å À1=2 Xe Ãt=2 : ð2Þ</p><p>Note that ^ Y ^ Y &gt; is by construction a symmetric matrix, whereas Å À1=2 YY &gt; Å 1=2 is generally asymmetric. The advantage of this modification is that the symmetry reduces the number of necessary matrix memory accesses by approx. 50% (<ref type="bibr">Golub and Van Loan, 2013, p.18</ref>). This technique has been implemented in FastCodeML.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">LRT optimization</head><p>When optimizing parameter values for H 0 and H 1 one after the other, one can save on parameter optimization steps. Each step in the parameter optimization procedure improves the associated lnL of the tree until convergence has been reached. In this discussion, the optimizer may modify all parameter values at each single step. One can either (i) optimize H 0 first with high accuracy and iteratively improve H 1 afterwards: once 2ðlnLðH 1 Þ À lnLðH 0 ÞÞ becomes larger than ð 2 1 Þ À1 ð1 À Þ, the parameter optimization for H 1 can be stopped because the LRT is already significant. This potentially saves optimization steps for H 1. Or we can (ii) optimize H 1 first, then proceed analogously: the parameters of H 0 are optimized until 2ðlnLðH 1 Þ À lnLðH 0 ÞÞ becomes smaller than ð 2 1 Þ À1 ð1 À Þ. In general, a significant LRT (i.e. detecting positive selection) is a relatively rare event (<ref type="bibr" target="#b13">Kosiol et al., 2008;</ref><ref type="bibr" target="#b29">Studer et al., 2008</ref>). Strategy (i) saves optimization steps if positive selection occurs; strategy (ii) saves optimization steps if not. Consequently, without prior knowledge of the frequency of occurrence of positive selection in the MSA at hand, strategy (ii) (implemented in FastCodeML) will yield larger savings. If the LRT is significant, a BEB is applied to identify the sites under positive selection. Otherwise, FastCodeML does not execute the BEB, in contrast to CodeML. In the general case, this optimization is applicable if different models are compared, where each of them is optimized iteratively.<ref type="figure">Fig. 2</ref>. Subtrees reuse strategy depicted for two (not necessarily neighboring) sites in the MSA; in (a) subtree (1) contains identical codons for both sites; consequently, in (b) the CPVs for both sites are identical and need to be computed only once (dotted line)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Parallelization</head><p>While the parallelization of ML-based nucleotide-protein-and codon models has already been addressed (<ref type="bibr" target="#b26">Stamatakis, 2011</ref>) (e.g. RAxML, IQPNNI, HyPhy), it has mostly been in the context of tree topology optimization, and not for the likelihood itself. The main challenge in parallelizing ML-based phylogeny computations comes from the tree structure that leads to an irregular domain decomposition (<ref type="bibr" target="#b31">Tomko, 1995</ref>). An efficient parallelization of the BSM is even more challenging due to its site classes and dependencies in between. Our implementation optimizes simultaneously all the parameters. The maximizer acts as an impenetrable boundary for parallelization, and we distinguish parallelization 'above' (coarsegrain) and 'within' (fine-grain) this boundary (cf. supplementary material,<ref type="figure">Fig. 1).</ref>2.2.1 Coarse-grain parallelization: Gene-wise parallelization. Because distinct genes typically have different evolutionary histories with distinct branch lengths and evolutionary parameters, phylogenies for genes are commonly estimated independently for each gene. Consequently, single genes cannot be concatenated into multi-gene alignments to attain high scalability by means of a fine-grain parallelization of the likelihood function [see, e.g. (<ref type="bibr" target="#b27">Stamatakis and Ott, 2009)]</ref>. Here we test for selection independently (gene-wise), these analyses can be carried out in an embarrassingly parallel way [see, e.g. (<ref type="bibr">Foster, 1995, p.21)]</ref>. Foreground branch parallelization. A further BSM parallelization option is the simultaneous analysis of distinct foreground branches. This is possible because we want to test for positive selection on each branch of a given phylogeny. Thus, the 2n À 3 tests for positive selection, where n is the number of taxa, can be conducted in parallel by duplicating the tree data structure and CPVs. Under this parallelization strategy, a dedicated master process broadcasts all model parameters, tree topologies and branch lengths to all worker nodes. The workers then conduct the tests independently of each other on different foreground branches of the same tree. Afterwards, the worker nodes return the estimated parameter values and the lnL scores to the master process. We implemented this approach using MPI (<ref type="bibr">Message Passing Interface Forum, 1994</ref>). The foreground-branch based parallelization can be combined with a site-wise fine-grain parallelization of the per-tree likelihood computations (Section 2.2.2) into a hybrid parallelization scheme. Hypotheses parallelization. Note that for each foreground branch, hypotheses H 0 and H 1 can be computed independently and simultaneously, thus increasing the degree of parallelism. However, the simultaneous computation of H 0 and H 1 prevents us from using the aforementioned LRT optimization (Section 2.1.3). Although the LRT and the subsequent BEB must be computed after H 0 and H 1 , they can be parallelized between different foreground branch computations. This parallelization strategy can be applied whenever two evolutionary models are compared. It is implemented in FastCodeML via the same master-worker scheme. 2.2.2 Fine-grain parallelization: Site-wise parallelization. A common way to parallelize likelihood computations on shared memory architectures is by parallelizing over the sites of the MSA. This site-wise parallelization can be implemented using OpenMP or POSIX Threads. MPI-based implementations exist but focus on large MSAs that are outside the scope of this article. However, while our subtree patterns re-use scheme (Section 2.1.1) reduces the number of computations along the branches, it poses a load balance challenge: (i) a particular CPV for a site can only be computed after the site whose results it reuses (i.e. data dependency) has been computed and (ii) a site that reuses a previously computed CPV exhibits a smaller workload which leads to load imbalance. The load balancing strategy we use in FastCodeML subdivides the alignment sites into groups such that each group exclusively reuses subtrees from the previous groups (<ref type="figure" target="#fig_3">Fig. 3</ref>). Each group is assigned a rank value starting from zero. CPVs from groups with lower rank values can potentially be reused. The first group does not reuse any subtree. All subtrees of a group can be parallelized, because they are independent of each other. The groups are then computed sequentially in order of rank. To balance the load for each group, subtrees can be moved to higher ranked groups. To increase parallelism, the trees of each group are replicated for each site class that should be computed until no lower rank group depends on it. The parallelization inside each group has been implemented using OpenMP. This site-wise parallelization strategy including load balancing can likewise be applied to nucleotide-or protein-based MSAs. The parallel performance may vary due to different computational load per site.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Implementation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EVALUATION</head><p>We measure median runtimes of 10 individual runs for each evaluation (three on the large scale analysis in Section 3.5). Speedup values are determined by S ¼ T1 T2 , where T 1 is theLoad balancing strategy: the sites of the tree are grouped so that each group depends only on groups at its left (continuous lines). A tree can be moved to a group to its right (dashed line) only if it has no dependencies from other trees in intermediate groups 1133 FastCodeML runtime (elapsed time, wall-clock time) of the reference execution and T 2 the runtime of the execution to be evaluated on the same dataset; for a relative speedup T 1 and T 2 denominate runtimes of the same executable, while for the absolute speedup T 1 is strictly the original CodeML. Initial branch lengths were read from file, while model parameters are initialized randomly. Memory consumption of CodeML, SlimCodeML and FastCodeML for these datasets is not a limiting factor and therefore not performance critical. Although a single executable can be used for all subsequent evaluations, we built sequential, OpenMP parallelized, MPI parallelized and hybrid executables separately. A summary of the platforms used can be found in the supplementary material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Datasets</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Accuracy</head><p>In<ref type="figure" target="#tab_2">Table 2</ref>we analyse the accuracy of FastCodeml with respect to lnLs and LRT scores. We use SlimCodeML as a proxy for good accuracy, as it gives very similar results as CodeML (<ref type="bibr" target="#b23">Schabauer et al., 2012</ref>), which is the established gold standard. We note that the accuracy of computed lnLs is much higher than typically required to discriminate between significant and insignificant LRTs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Sequential runtimes</head><p>Sequential speedups of FastCodeML (single-threaded) versus CodeML and SlimCodeML for five datasets (H 0 and H 1 , respectively) on platform Macpro (cf. supplementary material) are depicted in<ref type="figure" target="#fig_5">Figure 4</ref>; here, FastCodeML includes the following improvements: faster matrix exponentiation (Section 2.1.2) and subtrees reuse (Section 2.1.1). LRT optimization (Section 2.1.3) is not considered, as either H 0 or H 1 is computed per run. We observe speedups of FastCodeML versus CodeML ranging from 2.6 to 5.8. The sequential FastCodeML is significantly faster than both CodeML and SlimCodeML on all five datasets.<ref type="figure">Figure 5</ref>shows the scaling of FastCodeML on a site-wise (OpenMP based) parallelizationslightly worse than without subtrees reuse, absolute runtimes on this particular platform and dataset suggest to enable subtrees reuse on 1–11 cores but not on 12. The worse scaling of subtrees reuse is presumably caused by load imbalance. Due to differences in the sequential performance of subtrees reuse, we also expect the performance of parallel subtrees reuse to vary with different datasets. In general, the effectiveness of parallel subtrees reuse is a trade-off between the number of redundant branches versus the data dependencies introduced.<ref type="figure">Figure 6</ref>depicts the relative scaling of FastCodeML on a foreground-branch based parallelization strategy. The evaluation has been done for dataset D3 on 1–7 worker nodes (single thread per node). Due to the master–worker scheme used, performance gains are observed for two or more worker nodes. The analysis is done for all possible 22 foreground branches, where the runtime for CodeML is measured only on a single foreground branch but multiplied by 22; running CodeML on all foreground branches is expected to consume more than a day. We observe relative speedups of up to 5.9 on 7 worker nodes, which corresponds to absolute speedups from 3.3 to 19.4. In general, the relative speedup for foreground branch-based parallelizations benefits from a high ratio of foreground branches to available nodes, as the workload can more easily be divided into balanced parts.<ref type="figure" target="#fig_6">Figure 7</ref>cores per node and by reusing subtrees (Section 2.1.1). We analysed D6 for H 0 and H 1 running FastCodeML (multithreading) on 12 CPU cores and determined average runtimes of three test runs. The average runtime of FastCodeML on dataset D6 is 21.9 h for H 0 and 31.9 h for H 1. Due to time restrictions, we evaluated only a single iteration of CodeML for D6 which took 2.2 h on H 0 (367 iteration steps) and 2.3 h on H 1 (426 iteration steps) on the same platform. As we apply the same parameter optimization codes, we use the average number of optimization steps of FastCodeML on dataset D6 for the following speedup metric: we extrapolate that CodeML would have finished executing in approximately 2:2 Â 367 ¼ 807:4 h (i.e. ca. 33.6 days) for H 0 and 2:3 Â 426 ¼ 979:8 h (i.e. ca. 40.8 days) for H 1. The estimated speedups comparing the single threaded CodeML with FastCodeML running in 12 threads is thus 36.9 for H 0 and 30.7 for H 1. In this example, the LRT optimization saves 268 optimization steps for H 1 (63%).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Parallel runtimes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Site-wise parallelization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">Foreground branch-based parallelization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.3">Hybrid parallelization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONCLUSIONS</head><p>We introduced here three sequential code optimizations: an improved matrix exponential, subtrees reuse and LRT optimization.</p><p>We observed significant speedups versus both CodeML and our previous version SlimCodeML, and the first two optimizations can be used in various likelihood computations in phylogenetics. Moreover, we present a parallelization strategy that uses a finegrain and a coarse-grain approach. Overall, our improvements allow for testing selection on phylogenetic trees which exceed the possibilities of the original CodeML software; this is crucial to tackle the genomic data avalanche. The discussed improvements are motivated by the branch-site model but can, due to the likelihood framework, be extended to nucleotide-and amino acid-based MSAs as well as Bayesian approaches. We briefly identified such opportunities where applicable, but an extensive discussion is subject to future work. The optimization of the likelihood surface for phylogenetics problems is complex and we have started experimenting with the alternative parameter optimizers available in NLopt (http://abinitio.mit.edu/wiki/index.php/NLopt). It may be interesting to compare different implementations of the Broyden–Fletcher– Goldfard–Shanno (BFGS) optimization method, but a deeper investigation of the global and derivative-free optimizers is needed to better understand the potential solutions to find the maximum likelihood estimator for complex evolutionary models. In a future version the dependencies between nodes could be modelled as a directed acyclic graph and the parallelism be based on a dataflow model (<ref type="bibr" target="#b35">YarKhan et al., 2011</ref>) to study and potentially further improve parallel performance. Moreover, the site classes could be included into the dependency graph. This way a more fine-grained parallelism could be achieved. Increasing the parallel performance becomes crucial with the trend of more parallelism in future computer platforms (<ref type="bibr" target="#b4">Dongarra, 2012</ref>).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>In Schabauer et al. (2012), we transformed the problem of computing the matrix exponential of non-symmetric Qt into a symmetric problem as follows: we define the symmetric matrix AAn additional modification transforms the final asymmetric matrix–vector multiplication e Qt w into a symmetric matrix– vector product:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>FastCodeML has been implemented from scratch (except for the BEB that was largely taken from the CodeML codebase) in ISO Cþþ 2003 utilizing BLAS and LAPACK for linear algebra operations, and Spirit (http://www.boost.org/doc/libs/release/libs/ spirit/) for tree parsing. We use the parameter optimization codebase of CodeML.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. Load balancing strategy: the sites of the tree are grouped so that each group depends only on groups at its left (continuous lines). A tree can be moved to a group to its right (dashed line) only if it has no dependencies from other trees in intermediate groups</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.5.Fig.6.</head><figDesc>Fig. 5. Parallel site-wise relative (top) and absolute (bottom) speedups of FastCodeML on Castor on dataset D2 for H 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.4.</head><figDesc>Fig. 4. Sequential speedups of FastCodeML in comparison with CodeML and SlimCodeML on Macpro for H 0 and H 1 , respectively</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.7.</head><figDesc>Fig. 7. Parallel hybrid (OpenMP and MPI based) scaling of FastCodeML for dataset D3 on Castor for H 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Table 1 contains</figDesc><table>the six datasets we used for evaluation. With 
respect to the Selectome database, these empirical datasets are 
representative for the cases: (D1) small number of species/ 
medium sequence length; (D2) small number of species/large se-
quence length; (D3) medium number of species/small sequence 
length; (D4) large number of species/short sequence length; (D5) 
a simulated dataset with positive selection based on dataset D1 
(using PAML's evolver choosing 'evolverNSbranchsites' for the 
BSM with ! 2 ¼ 5). Finally, we analyse in D6 a very large rbcL 
dataset (Grass Phylogeny Working Group II, 2012) which 
cannot be processed in a feasible time by CodeML. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 2.</figDesc><table>Accuracy of SlimCodeML and FastCodeml on Macpro; Á H0ðH1Þ is the absolute difference of lnLs comparing either SlimCodeML or 
FastCodeML with CodeML on H 0 (H 1 ), respectively 

Dataset 
Á H0 
Á H1 
LRT 
pos. selection 

SlimCode versus CodeML 
D1 
1:5 Á 10 À5 
3:5 Á 10 À6 
5:4 Á 10 À5 
no (3) 
D2 
3:5 Á 10 À1 
5:7 Á 10 À2 
7 Á 10 À1 
no (3) 
D3 
7:8 Á 10 À6 
9:9 Á 10 À3 
2:2 Á 10 À5 
no (3) 
D4 
9:1 Á 10 À8 
9:6 Á 10 À7 
2:3 Á 10 À6 
no (3) 
D5 
8:5 Á 10 À10 
6:8 Á 10 À11 
10.4 
site 239 (3) 
FastCodeML versus CodeML 
D1 
1:1 Á 10 À2 
4:5 Á 10 À6 
À2:1 Á 10 À2 
no (3) 
D2 
3:4 Á 10 À1 
2:8 Á 10 À2 
À5:1 Á 10 À1 
no (3) 
D3 
2:2 Á 10 À2 
2:1 Á 10 À3 
À3:9 Á 10 À2 
no (3) 
D4 
1:5 Á 10 À6 
1:2 Á 10 À6 
À4:5 Á 10 À9 
no (3) 
D5 
4:9 Á 10 À10 
1:6 Á 10 À9 
10.4 
site 239 (3) 

Note: '3' indicates agreement of the computed result with CodeML. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 1.</figDesc><table>Test datasets of our analyses; remaining branches is the percentage of non-redundant branches for the given data over all sites of the alignment; 
dataset D5 is generated based on ENSGT00390000016702.Primates.1 with ! 2 ¼ 5 

Abbr. 
Full name 
No. of species 
No. of branches 
Remaining branches [%] 
Length (codons) 

D1 
ENSGT00390000016702.Primates.1 
7 
12 
37.74 
299 
D2 
ENSGT00530000063518.Primates.1 
95 
188 
75.49 
39 
D3 
ENSGT00550000073950.Euteleostomi.7 
25 
48 
56.31 
67 
D4 
ENSGT00580000081590.Primates.1 
6 
10 
20.92 
5004 
D5 
Generated by evolver (PAML) 
7 
12 
38.04 
282 
D6 
Grass_rbcL 
506 
1242 
19.54 
414 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 3. Overall parallel performance of FastCodeml versus CodeML on Castor for dataset D3 on all possible foreground branches for H 1 ; CodeML runtime for absolute speedups is extrapolated from computing a single foreground branch</figDesc><table>Worker 
nodes (cores) 

FastCodeML 
runtime [s] 

Rel. 
speedup 

Abs. 
speedup 

1 (12) 
429 
1 
27.6 
2 (24) 
218 
2 
54.2 
3 (36) 
151 
2.9 
78.4 
4 (48) 
114 
3.8 
103.7 
5 (60) 
93 
4.7 
126.5 
6 (72) 
81 
5.4 
145.3 
7 (84) 
69 
6.3 
170.9 </table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">M.Valle et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="2">.1.1 Subtrees reuse The per-site likelihoods for a MSA are independent of each other and can thus be computed in an arbitrary order. If two or more sites of the MSA are identical, it suffices to only compute the logarithmic likelihood (lnL) on one site and multiply it by the number of identical sites to obtain the total lnL. This technique is used in most likelihood-based software, but there are further redundant computations caused by re-occurring patterns in the MSA. In each subtree, there is a potential to economize CPV computations for different sites of the MSA. If the same state appears at two or more sites of a sequence, all occurrences yield identical CPVs at the particular leaf. If the patterns of the sub-alignment induced by a subtree match are identical for two or more sites, the corresponding CPVs for the two sites are also identical. However, identical patterns in the sub-alignments induced by a subtree need to be identified first. The identification of such identical patterns in sub-alignments can be done, e.g. by searching (i) sequentially or (ii) using a symbol table (Sedgewick and Wayne, 2011, p.361). In the latter case, the key is the index of the CPV within the tree, and the value associated with the key is its CPV. In the straightforward approach (i), there are no costs on storing values, but up to m – 1 lookups for a matching subpattern, where m is the length of the MSA. For huge MSAs, it may Fig. 1. Analysis on how many elementary subtree computations are necessary in the branch-site model; CPVm correspond to m distinct conditional probability vectors, where matching m need to be computed only once; Q 0, 1, 2 f g identify three distinct Q matrices for distinct ! 0, 1, 2 f g values 1131 FastCodeML at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank Se´bastienSe´bastien Moretti and Walid Gharib for providing test datasets and feedback on FastCodeML. The computations on Castor were performed at the Swiss National Supercomputing Centre (http://www.cscs.ch), and those on Vital-IT at the VitalIT (http://www.vital-it.ch) Center for high-performance computing of the SIB Swiss Institute of Bioinformatics.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Investigating protein-coding sequence evolution with probabilistic codon substitution models</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Anisimova</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Kosiol</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="255" to="271" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Multiple hypothesis testing to detect lineages under positive selection that affects only a few sites</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Anisimova</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Yang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1219" to="1228" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title level="m" type="main">Templates for the Solution of Algebraic Eigenvalue Problems: A Practical Guide</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Bai</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<pubPlace>SIAM, Philadelphia</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Nomenclature for incompletely specified bases in nucleic acid sequences: recommendation 1984</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Comnish-Bowden</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="3021" to="3030" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">High performance computing systems: status and outlook</title>
		<author>
			<persName>
				<surname>Absolute Speedup Fastcodeml Vs</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">J</forename>
				<surname>Codeml Dongarra</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Numerica</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="379" to="474" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient selection of branch-specific models of sequence evolution</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">Y</forename>
				<surname>Dutheil</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1861" to="1874" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Evolutionary trees from DNA sequences: a maximum likelihood approach</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Felsenstein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Evol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="368" to="376" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<monogr>
		<title level="m" type="main">Designing and Building Parallel Programs</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<forename type="middle">T</forename>
				<surname>Foster</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">CodonPhyML: fast maximum likelihood phylogeny estimation under codon substitution models</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Gil</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1270" to="1280" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<monogr>
		<title level="m" type="main">Matrix Computations</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">H</forename>
				<surname>Golub</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">F</forename>
				<surname>Van Loan</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>Johns Hopkins University Press</publisher>
			<pubPlace>Baltimore, MD</pubPlace>
		</imprint>
	</monogr>
	<note>4th. edn</note>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">New grass phylogeny resolves deep evolutionary relationships and discovers C 4 origins</title>
	</analytic>
	<monogr>
		<title level="j">Grass Phylogeny Working Group II. New Phytol</title>
		<imprint>
			<biblScope unit="volume">193</biblScope>
			<biblScope unit="page" from="304" to="312" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Algorithms, data structures, and numerics for likelihood-based phylogenetic inference of huge trees</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Izquierdo-Carrasco</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Column sorting: rapid calculation of the phylogenetic likelihood function</title>
		<author>
			<persName>
				<forename type="first">Kosakovsky</forename>
				<surname>Pond</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Muse</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">V</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="685" to="692" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Patterns of positive selection in six mammalian genomes</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Kosiol</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<monogr>
		<title level="m" type="main">Phylogenetic code in the cloud – can it meet the expectations</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Kraut</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<publisher>HealthGrid. IOS Press</publisher>
			<biblScope unit="page" from="55" to="63" />
			<pubPlace>Birmingham, AL</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">A bayesian mixture model for across-site heterogeneities in the amino-acid replacement process</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Lartillot</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Philippe</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1095" to="1109" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">A counting renaissance: combining stochastic mapping and empirical Bayes to quickly detect amino acid sites under positive selection</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Lemey</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="3248" to="3256" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">MPI: a message-passing interface standard</title>
	</analytic>
	<monogr>
		<title level="j">Message Passing Interface Forum. Int. J. Supercomput. Appl. High Performance Comput</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="3" to="4" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Detecting individual sites subject to episodic diversifying selection</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Murrell</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PloS Genet</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">1002764</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<monogr>
		<title level="m" type="main">Statistical Methods in Molecular Evolution</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Nielsen</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Selectome: a database of positive selection</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Proux</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="404" to="407" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Phylogenetic inference using whole genomes</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Rannala</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Yang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Genomics Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="217" to="231" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Fast bayesian choice of phylogenetic models: prospecting data augmentation-based thermodynamic integration</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Rodrigue</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Aris-Brosou</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="881" to="887" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">SlimCodeML: an optimized version of CodeML for the branch-site model</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Schabauer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">11th International Workshop on High Performance Computational Biology (HiCOMB</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="700" to="708" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title/>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Sedgewick</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Wayne</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms</title>
		<imprint>
			<publisher>Addison-Wesley</publisher>
			<date type="published" when="2011" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
	<note>4th. edn</note>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Synonymous substitutions substantially improve evolutionary inference from highly diverged proteins</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">K</forename>
				<surname>Seo</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Kishino</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="367" to="377" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<monogr>
		<title level="m" type="main">Orchestrating the phylogenetic likelihood function on emerging parallel architectures Bioinformatics—High Performance Parallel Computer Architectures</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Stamatakis</surname>
			</persName>
		</author>
		<editor>Schmidt,B.</editor>
		<imprint>
			<date type="published" when="2011" />
			<publisher>CRC Press</publisher>
			<biblScope unit="page" from="85" to="115" />
			<pubPlace>Singapore</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<monogr>
		<title level="m" type="main">Load balance in the phylogenetic likelihood kernel</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Stamatakis</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Ott</surname>
			</persName>
		</author>
		<editor>ICPP. IEEE</editor>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="348" to="355" />
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">AxML: a fast program for sequential and parallel phylogenetic tree calculations based on the maximum likelihood method</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Stamatakis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Bioinformatics Conference</title>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="21" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Pervasive positive selection on duplicated and nonduplicated vertebrate protein coding genes</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">A</forename>
				<surname>Studer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1393" to="1402" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Phylogenetic estimation with partial likelihood tensors</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Sumner</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Charleston</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Theor. Biol</title>
		<imprint>
			<biblScope unit="volume">262</biblScope>
			<biblScope unit="page" from="413" to="424" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<monogr>
		<title level="m" type="main">Domain Decomposition, Irregular Applications, and Parallel Computers</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">A</forename>
				<surname>Tomko</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<pubPlace>Michigan</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">Phylogenetic mixture models can reduce node-density artifacts</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Venditti</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="286" to="293" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<monogr>
		<title level="m" type="main">Computational Molecular Evolution</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Yang</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<publisher>Oxford University Press</publisher>
			<pubPlace>Oxford</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">Bayes empirical bayes inference of amino acid sites under positive selection</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Yang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1107" to="1118" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<monogr>
		<title level="m" type="main">QUARK Users&apos; Guide: QUeueing and Runtime for Kernels</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Yarkhan</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<pubPlace>Tennessee</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<analytic>
		<title level="a" type="main">Evaluation of an improved branch-site likelihood method for detecting positive selection at the molecular level</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="2472" to="2479" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">FastCodeML</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>