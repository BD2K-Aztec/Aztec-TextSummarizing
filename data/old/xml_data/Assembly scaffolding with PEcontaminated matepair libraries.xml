
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:47+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Assembly scaffolding with PE-contaminated mate-pair libraries</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Kristoffer</forename>
								<surname>Sahlin</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computer Science and Communication</orgName>
								<orgName type="laboratory">Science for Life Laboratory</orgName>
								<orgName type="institution">KTH Royal Institute of Technology</orgName>
								<address>
									<settlement>Solna</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Rayan</forename>
								<surname>Chikhi</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="laboratory">UMR 9189</orgName>
								<orgName type="institution">CNRS</orgName>
								<address>
									<addrLine>Villeneuve D&apos;ascq 59650</addrLine>
									<settlement>CRIStAL</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Lars</forename>
								<surname>Arvestad</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">Swedish e-Science Research Centre</orgName>
								<orgName type="department" key="dep2">Department of Numerical Analysis and Computer Science</orgName>
								<orgName type="laboratory">Science for Life Laboratory</orgName>
								<orgName type="institution">Stockholm University</orgName>
								<address>
									<settlement>Stockholm</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Assembly scaffolding with PE-contaminated mate-pair libraries</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btw064</idno>
					<note type="submission">Received on June 9, 2015; revised on January 29, 2016; accepted on February 1, 2016</note>
					<note>Genome analysis *To whom correspondence should be addressed. Associate Editor: John Hancock Contact: ksahlin@kth.se Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Scaffolding is often an essential step in a genome assembly process, in which contigs are ordered and oriented using read pairs from a combination of paired-end libraries and longer-range mate-pair libraries. Although a simple idea, scaffolding is unfortunately hard to get right in practice. One source of problems is so-called PE-contamination in mate-pair libraries, in which a non-negligible fraction of the read pairs get the wrong orientation and a much smaller insert size than what is expected. This contamination has been discussed before, in relation to integrated scaf-folders, but solutions rely on the orientation being observable, e.g. by finding the junction adapter sequence in the reads. This is not always possible, making orientation and insert size of a read pair stochastic. To our knowledge, there is neither previous work on modeling PE-contamination, nor a study on the effect PE-contamination has on scaffolding quality. Results: We have addressed PE-contamination in an update to our scaffolder BESST. We formulate the problem as an integer linear program which is solved using an efficient heuristic. The new method shows significant improvement over both integrated and stand-alone scaffolders in our experiments. The impact of modeling PE-contamination is quantified by comparing with the previous BESST model. We also show how other scaffolders are vulnerable to PE-contaminated libraries, resulting in an increased number of misassemblies, more conservative scaffolding and inflated assembly sizes. Availability and implementation: The model is implemented in BESST. Source code and usage instructions are found at https://github.com/ksahlin/BESST. BESST can also be downloaded using PyPI.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Genome assembly is still a challenging process, especially for large genomes, and scientists experiment with different combinations of data and tools to reduce errors, improve contiguity and avoid ambiguity. An important step in the assembly process is scaffolding, in which contigs are ordered, oriented and joined to form a larger scaffold unit. The input is a set of contigs and one or several genome mappings of paired short reads from either paired-end (PE) sequencing or mate-pair (MP) sequencing. Evaluations (e.g.<ref type="bibr" target="#b8">Hunt et al., 2014</ref>) have shown that scaffolders make many mistakes, perhaps more than one might expect from what could appear a straightforward computational problem. The input to a scaffolder is however both large and noisy, and the data characteristics can vary a lot depending on the organism and V C The Author 2016. Published by Oxford University Press.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1925</head><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/4.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited. assembler. Although contiguity and errors are the most important metrics to evaluate a scaffolder by, we came to note that there are other artifacts from scaffolders not reported in these metrics. We observed that assemblies could increase in size by up to 106% after scaffolding and this mostly affects fragmented assemblies. We call this effect assembly inflation. A successful scaffolding will have some assembly inflation due to, e.g. unsequenced regions, but it should in general be very small. The type of technology, PE or MP, and their main parameter, the insert size, determine how far apart the reads are distributed on the genome and thereby at what distances contigs can be connected into scaffolds. Whether it is PE or MP also determines if the reads are read towards (PE) or apart (MP) from each other. There are numerous complications with PE and MP reads. For example, the insert size is not perfectly controlled and larger insert size typically means a larger variance in the distribution of distances between the reads, making scaffolding harder (<ref type="bibr" target="#b19">Sahlin et al., 2014</ref>). A largely ignored problem (on the computational side) is so-called PE contamination of MP libraries, which is a consequence of the MP library preparation. During the process, an unknown fraction of fragments that do not contain the circularization junction are sequenced. These misreads behave like PE reads, with opposite read direction from MP (see<ref type="figure" target="#fig_0">Fig. 1</ref>) and effectively with a much smaller insert size (<ref type="bibr">Illumina, 2012</ref>). Hence, PE contamination reads may confuse a scaffolder that assumes an MP library is clean from contamination, suggesting a different relative order of contigs. When designing a scaffolder, one can take the stance that PE contamination is (1) an experimental issue which should be controlled in the wet-lab and (2) it can be treated as noise in the MP that will get filtered away in a scaffolding optimization procedure anyway. Regarding (1), we probably have to accept PE contamination as a largely unavoidable difficulty and, in that case, we argue that the PE should be explicitly modeled in MP datasets to reduce errors. Although a decent MP library will contain more true MP reads than PE, and hence overshadow PE contaminants in many cases, assumption (2) will not hold for fragmented assemblies as there are many short contigs close to each other making PE links dominate MP links. The ambition can also be set higher: perhaps we can start utilizing PE contamination as valuable short-range information rather than nuisance that needs to be filtered away? One may also ask how sensitive the current generation of standalone scaffolders are to MP libraries with a high amount of PE contamination? If scaffolders have been designed for near ideal datasets, what can one expect in a more difficult situation? PE-contamination has been discussed in relation to integrated scaffolders in end-to-end assemblers such as ALLPATHS-LG (<ref type="bibr" target="#b6">Gnerre et al., 2011</ref>) and MaSuRCA (<ref type="bibr" target="#b21">Zimin et al., 2013</ref>). These methods rely on the orientation being observable, e.g. by finding and removing the adapter sequence. In practice that is not always the case, as a fraction of read pairs will not contain the adapter (depending on shearing size) and orientation will not be observable. A method that does not rely on adapters being observable has the additional benefit of not putting a constraint on the fragment shearing size (in the re-fragmentation step of the circularized fragments in the library construction protocol). Smaller shearing size yields more 'identifiable' mate-pairs (adapter is present in the end of at least one read), but a higher contamination content of PE-fragments and chimeric reads (adapter present in the start or middle of a read). On the other hand, larger shearing size gives fewer identifiable mate-pairs but larger amount of true mate pairs as well as fewer PE-fragments and chimeric reads—due to the increased probability of sequencing full length reads on both sides of the adapter on a larger fragment. Scaffolding with a library with larger fragment shearing size also has the advantage that span coverage of the PE-contamination increases, giving better short range connections. As this contamination has neither been modeled nor examined in terms of how it degrades scaffolding results, we decided to investigate this. We developed a scaffolder that models PE contamination reads in the scaffolding process on MP libraries. We show that modeling PE-contamination improves scaffolding. Our design utilizes an integer linear program (ILP) for the MP/PE classification and uses information from the interval structure of the contig graph to heuristically obtain a set of linear programs (LP) to solve. The heuristic method is very fast and finds the correct order of contigs in all cases given the model assumptions, as seen on our simulated data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head><p>The presented work builds on the BESST scaffolder (<ref type="bibr" target="#b19">Sahlin et al., 2014</ref>), which iterates over PE and/or MP libraries in the order of their mean insert size. For each library, BESST scaffolds in two steps. In the first step, safe linking, large contigs are scaffolded using a greedy statistical scoring heuristic (a contig is large if it is unlikely that a read-pair can span over the contig). In a second step, improved linking, smaller contigs are placed within gaps of the larger contigs, or between larger contigs that were not linked in the first step (e.g. because their distance was larger than the insert size). The second step is done with a breadth-first search where the highest scoring paths (i.e. sets of contigs in the contig graph, see<ref type="bibr" target="#b19">Sahlin et al., 2014</ref>) are selected. The methods presented here are applied to the output of the improved linking step, that is, to paths of smaller contigs. Each path is a local subset of the contig graph, thus naturally dividing the contig graph into subregions in which the contigs needs to be oriented, ordered, and positioned accurately (deciding distance between contigs in a scaffold). If PE contamination is present, it can confuse the ordering as PE reads have the opposite orientation to MP reads.<ref type="figure" target="#fig_0">Figure 1</ref>shows the two possible orderings for two contigs joined by a paired read link, notice however that the relative orientation between the contigs remains the same. We will here define the problem of ordering and positioning contigs with PE-contamination as an ILP. For m contigs linked with paired reads, we can have up to m! possible orderings and it is not feasible to try them all. We therefore find a solution to this ILP by solving a reduced set of Linear Programs (LP) where each LP is induced by fixing the order of the contigs. With a fixed ordering of the contigs, solving the LPs will reduce to finding optimal gap sizes between contigs using the gap model by<ref type="bibr" target="#b18">Sahlin et al. (2012</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Integer linear program formulation</head><p>The following paragraphs introduce the ILP formulation. We first consider a fixed contig ordering where the contigs are linked only byThe corresponding contig graphs where '5' and '3' denotes the 5 0 and 3 0 ends of contigs MP links. We then add PE links to the formulation via an unknown variable representing the order of contigs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Fixed ordering objective without contamination</head><p>Let a contig graph G be an undirected graph created by contigs and read pair links where each contig is represented by two vertices (for the 5 0 and 3 0 end respectively) and an intra-contig edge. Let an intercontig edge be an edge in G that connects two vertices that come from different contigs if one or more read pairs suggest those two contigs are linked and the read pair(s) suggest the same orientation and distance of contigs (known as 'link-bundling',<ref type="bibr" target="#b9">Huson et al., 2002</ref>). The intra-contig edges are used in the implementation but does not contribute to the ILP problem and we will from now on only discuss inter-contig edges. Notice that a read pair can give rise to two different edges in G, depending on if the read pair is assumed to be in PE or MP orientation, see<ref type="figure" target="#fig_0">Figure 1</ref>. Assume that we have a connected subgraph of G induced by contigs c 1 ;. .. ; c m and a set E of inter-contig edges (not all contigs need to have edges between them), see supplemental<ref type="figure" target="#fig_0">Figure S1</ref>for an example of a contig region. A linear order of m contigs has m – 1 gaps g 1 ;. .. g mÀ1. Let us focus on the edge e between contigs c i and c j , defined by w e links. Using only the links between c i and c j , assume that we have an estimate ^ d e of the distance between these two contigs, see<ref type="figure" target="#fig_0">Figure 1</ref>. Note that this distance is not to be confused with the gaps g 1 ;. .. g mÀ1 , as c i and c j might not be adjacent in the given ordering. How to get the estimate of ^ d e accurately is described in (<ref type="bibr" target="#b18">Sahlin et al., 2012</ref>). From ^ d e and o e (see<ref type="figure" target="#fig_0">Fig. 1</ref>), we naturally get the average insert size of the links that spans c i and c j as ^ l e ¼ o e þ ^ d e , where o e is the average observation. That is, ^ l e is the average insert size suggested by the links between c i and c j. Notice that we define the insert size to include the read lengths (sometimes denoted the fragment length). In a given placement of the m contigs, c i and c j will be at distance P jÀ1 k¼iþ1 jc k j þ X jÀ1 k¼i jg k j þ o e , adding up the j À i À 1 contigs and j – i gaps between c i and c j. The objective is to minimize the discrepancy between the placement in the current ordering and ^ l e , that is, to minimize</p><formula>z e :¼ j^ l e À X jÀ1 k¼iþ1 jc k j þ X jÀ1 k¼i jg k j þ o e ! j:</formula><p>Sinceis constant, we omit this denominator in the objective. Note that higher uncertainty gives lower relative penalty. We have the objective function as</p><formula>min X e2E w e z MP e r PE þ w e z PE e r MP :</formula><p>As seen in the objective, edges with larger weights w will penalize a possible distance discrepancy more.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">Fixed ordering constraints</head><p>Due to the MP library insert size, we do not allow gaps larger than l MP þ kr MP , with k empirically set to 2. Therefore, we have m – 1 constraints g i l MP þ kr MP :</p><p>Notice that even though a gap is an integer value, we choose to work with a relaxed problem to be able to apply LP.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.4">Formulating an ILP for unknown orientation and ordering</head><p>The unknown in this problem is the orientation of contigs in a region. Let I MP e be the indicator function for edge e having MP orientation. The full ILP has the variables g, z and I MP and is written as</p><formula>minimize X e2E ½w e z MP e r PE I MP e þ w e z PE e ð1 À I MP e Þr MP  subjectto X i g i l MP þ kr MP I MP e 2 f0; 1g; e 2 E</formula><p>We can use the minimum objective value to this ILP to evaluate contig orderings. For m contigs, there are m! possible orderings, thus we need a way to efficiently choose a subset of orderings to run the ILP on. For each assignment of I MP e ; e 2 E, the problem is a regular LP (remember the assumption g 2 R) and we use common LP methods to express the LP on standard form, i.e. introducing help variables to remove absolute values and negative valued variables. This implies that we have 2ðm À 1Þ þ jEj constraints in practice. The jEj extra constraints comes from the fact that z e is an absolute value and 2ðm À 1Þ constraints because the gap variables are allowed to be negative (letting g i ¼ x i À y i , for x i ; y i &gt;¼ 0). We solve the LP with the simplex method which we denote with SðÁÞ. S takes a path (translated into an LP instance) as argument and returns a real valued objective value.In this step, the permutation gives paths with contig orderings of the type ðc 1 ;. .. c i ; c iÀ1 ;. .. c m Þ; 8i 2 ½3; m À 1. We choose the path with the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Solving the ILP</head><p>Assembly scaffoldinglowest objective for the next iteration as p 1 ¼ argmin p2P0 SðpÞ. If p 1 6 ¼ p 0 0 (i.e. there has been a change in ordering), we will remove the index i from E 0. This means that the edge between contig c iÀ1 and contig c i is more likely to be a PE edge. That is, we have calculated the objective values of each candidate ordering formed by only permuting each consecutive pair of contigs, and we chose the one with the lowest objective. Notice that we 'switch' at most one MP link to a PE link by this procedure. We have now outlined the first iteration step of the algorithm. A general iteration step j has three substeps. Substep 1: We form m À j À 2 contig orderings p 0 j ;. .. ; p mÀjÀ3 j made from permutations, 8i 2 E j , inserting segment c k ;. .. ; c i at position aðc iÀ1 ; p jÀ1 Þ, where aðc k ; p jÀ1 Þ ¼ aðc iÀ1 ; p jÀ1 Þ þ 1, i.e. c k comes immediately after c iÀ1 in p jÀ1. Notice that the indices i always refer to the initial ordering in p 0 0 i.e. ðc 1 ;. .. ; c m Þ. In a general step j, c iÀ1 and c i might no longer be adjacent (hence we needed to introduce the function aðÁ; ÁÞ). Substep 2: We calculate S(p), 8p 2 P j and let</p><formula>p jþ1 ¼ argmin p2P j ¼ SðpÞ (1)</formula><p>Substep 3: If p jþ1 ¼ p 0 j , we return the final path p 0 j. That is, no candidate orderings obtained a lower objective than the identity permutation. Otherwise, if p jþ1 ¼ p i j for i 6 ¼ 0, we let E jþ1 ¼ E j ni. That is, we accepted the MP edge between c i ; c iþ1 as being PE oriented.</p><p>(4) Return to step (1). See<ref type="figure" target="#fig_0">Figure S1</ref>for an illustration of the algorithm in practice. The algorithm stops either when p jþ1 ¼ p 0 j or when the set of candidate edges are empty, which happens when j ¼ m À 3. This algorithm will at most compute ðmÀ3ÞðmÀ4Þ 2 LPs. In practice, on the datasets we have scaffolded, m is almost always smaller than 15 and we have never observed m over 25. Notice that changing relative orientation of contigs would yield pairs of orientation FF or RR, which are invalid according to our model, thus no such operation is allowed. A solution to each LP gives a set of real valued gaps g i , i 2 ½1; m À 1 that are used to place the contigs accurately as information from several edges are used simultaneously for each gap. The model is implemented in the workflow of BESST, and after applying BESST's scaffolding procedure (<ref type="bibr" target="#b19">Sahlin et al., 2014</ref>), we obtain ranked clusters of contigs (created by splitting the contig graph based on longer contigs) where the rank is based on how many supporting versus contradicting links a cluster has. Here, we start solving the ILPs, with the highest ranked cluster first. Paths containing contigs that are already included in higher ranked paths are discarded. As described, each ILP i is solved by solving a set of LPs. Our heuristic solution works well when the PE distribution has a short span. If the PE fragment length distribution is wide, and a significant number of PE-links would link non-neighboring contigs, more permutations would be needed. Thus, the permutation of adjacent contigs is efficient if most PE read pairs link adjacent contigs in the true ordering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results and discussion</head><p>We have compared our new implementation of BESST, called BESST-v2 below, with SSPACE (<ref type="bibr" target="#b0">Boetzer et al., 2011</ref>), OPERA (<ref type="bibr" target="#b5">Gao et al., 2011</ref>), SOPRA (<ref type="bibr" target="#b2">Dayarian et al., 2010</ref>), SCARPA (<ref type="bibr" target="#b3">Donmez and Brudno, 2013</ref>) and SCAFFMATCH (<ref type="bibr" target="#b16">Mandric and Zelikovsky, 2015</ref>). Version 1 of BESST (<ref type="bibr" target="#b19">Sahlin et al., 2014</ref>) is included for reference. We also include integrated scaffolder results provided by GAGE, labeled 'INTEGRATED'. SSPACE, SCARPA, SOPRA and OPERA were run with mappings from Bowtie (<ref type="bibr" target="#b13">Langmead et al., 2009</ref>) as suggested by<ref type="bibr" target="#b8">Hunt et al. (2014)</ref>when comparing the aligners BWA (<ref type="bibr" target="#b15">Li and Durbin, 2010</ref>), Bowtie and Bowtie2 (<ref type="bibr" target="#b12">Langmead and Salzberg, 2012</ref>). SCAFFMATCH is coupled with Bowtie2. BESST was run with BWA-MEM (<ref type="bibr" target="#b14">Li, 2013</ref>). Full running instructions and details on resource usage are given in Supplementary data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Datasets</head><p>We have included a simulated dataset, sim, which we developed the model on. A genome of size 500 000 bp was simulated and contigs of either 5000 (P ¼ 0.2) or 500 bp (P ¼ 0.8) were generated from this genome with no gap between contigs. The random generation of contig sizes ensure different complexities on the subproblems. The longest stretch of smaller contigs between border contigs consisted of 20 consecutive small contigs. Based on the reference genome, a MP library with 50Â coverage of 2Â 100 bp reads was simulated. The MP library had insert-size distribution N(3000, 300) and 30% of the reads were PE contamination with insert size chosen from N(400, 40). Simulated data from the Assemblathon 1 study (<ref type="bibr" target="#b4">Earl et al., 2011</ref>) is denoted assemblathon3k. We assembled contigs with Minia (<ref type="bibr" target="#b1">Chikhi and Rizk, 2013</ref>) from the paired-end reads provided by GAGE (<ref type="bibr" target="#b20">Salzberg et al., 2012</ref>). This gave approximately 74 000 contigs. The contigs were scaffolded with the 3 kbp MP library provided by Assemblathon 1. It contains mate pairs with insert-size distribution N(3000, 300) and 20% PE contamination with an insertsize distribution of N(500, 50). Three cases, Staphylococcus aureus, Rhodobacter sphaeroides and human chromosome 14, were taken from the Genome Assembly Gold-standard Evaluation (GAGE) study (<ref type="bibr" target="#b20">Salzberg et al., 2012</ref>), a comprehensive evaluation of large-scale genome assembly algorithms. We denote them staph, rhodo and hs14, and GAGE provides 8, 9 and 9 contig assemblies, respectively. These assemblies were scaffolded with the original shortjump libraries provided by GAGE. By aligning these libraries to the reference genomes with BWA-MEM (<ref type="bibr" target="#b14">Li, 2013</ref>) we detected a natural PE contamination in the rhodo and hs14 libraries at 41% and 33%, respectively, with mean insert size of 211 and 200 bp, respectively (see Supplemental Figs S2 and S3). The staph library had almost no PE contamination with the given alignments ((1%, see<ref type="figure" target="#fig_0">Fig. S1</ref>). We created additional libraries for each reference genome to study the effect of increased levels of PE contamination and PE span coverage. The parameter c added is introduced to indicate the percentage of added PE reads in a library. The original GAGE libraries have c added ¼ 0 (0% added contamination). The c added ¼ 15 libraries were formed by simulating PE reads from the genomes with distribution N(300, 30) and adding them to the original read library. Similarly, the c added ¼ 40 libraries were formed by simulating PE reads from the genomes with distribution N(400, 40) and adding them to the original library. We used NxTrim (O'<ref type="bibr">Connell et al., 2015</ref>) and FastQC (http:// www.bioinformatics.babraham.ac.uk/projects/fastqc) to find adapters within the GAGE datasets but a very small fraction of adapters were found (in 0–9% of the read pairs), hence MP and PE orientation could not be determined on the large majority of the reads— which inhibits the use of an adapter filtering tool to filter out PEcontamination. We therefore include additional evaluation of BESST-v2 scaffolding with all read pairs against BESST scaffolding with only MP-filtered read pairs on two datasets where a significant number of adapters can be found, see section S3 for detailed results and discussion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Evaluation method</head><p>Assembly evaluation is known to be difficult (<ref type="bibr" target="#b4">Earl et al., 2011;</ref><ref type="bibr" target="#b8">Hunt et al., 2014;</ref><ref type="bibr" target="#b20">Salzberg et al., 2012</ref>), as there are many metrics to consider. Ultimately, the end result of an assembly should be as long error-free sequences as possible. However, two assemblies with the same lengths on error free sequences can still differ if one of the assemblers/scaffolders contains false joins, making the assembly look more contiguous. Thus, errors is another important metric. We therefore choose to look at the number of errors and the adjusted E-size (<ref type="bibr" target="#b20">Salzberg et al., 2012</ref>, the expected length of error free sequence in the assembly,) which we denote by E 0. Moreover, we need an informative way to present the quality increase/decrease of an assembly from contigs to scaffolds. Since the GAGE datasets contains assemblies of varying quality (with respect to contig errors and E 0 ) of each organism, we present the quality improvement between contigs and scaffolds. Let E 0 c and E 0 s denote the adjusted E-size of the original contig assembly and the scaffolded assembly. We report the increase in errors from original contigs to scaffolds as well as the ratio E 0 s =E 0 c. Tables S2–S18 in Supplementary data contains results for individual experiments and the summary tables presented here shows the average increase on each organism and library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Assembly size inflation</head><p>As another aspect of scaffolding quality, we also show how total assembly size grows after scaffolding. We observed that some scaffolders increase the assembly size more than others and we wanted to find the cause. Since no scaffolder (in this comparison) puts a contig sequence in multiple places (e.g. repeats) or derive new sequence from the reads, inflation is due to added gaps (stretches of N's). We categorize inflation into three possible causes: (1) The genomic content between two contigs is not present in the assembly, thus an approximately correct number of N's is inserted. This is correct behaviour from a scaffolder and, to some extent, it improves the quality of the assembled genome. (2) The genomic content between two contigs a and c is present in another contig b in the assembly, but the scaffolder is unable to place b. The scaffolder creates (a correct number of) N's between a and c and leaves b isolated in the output file. This increases the assembly size, as there are two versions of a single location in the assembly, represented by b and N's respectively. It is not a misassembly, but it can confuse downstream analysis, and it negatively affects the assembly quality through size inflation. (3) Errors: a gap between contigs is inserted due to a false join, or the gap sequence significantly differs in length to the real gap length. This is seen as a misassembly that decreases the quality of the assembly. When we discuss assembly inflation we will refer to these three causes as (1), (2) or (3). We also report the ratio of scaffolded assembly size compared to initial contig size, labeled inflation in the tables, and find that some scaffolders are prone to (2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Note on evaluation</head><p>Snakemake (K€ oster and<ref type="bibr" target="#b11">Rahmann, 2012</ref>) was used to run our evaluation pipeline. QUAST (<ref type="bibr" target="#b7">Gurevich et al., 2013</ref>) was used for evaluating the scaffolders as it uses alignments to a reference to identify misassembly breakpoints. Support for computing E-size was added. QUAST classifies a misassembly as a breakpoint in the scaffold where the left and right flanking bases differs more than N base pairs from the reference sequence. We have set N ¼ 100 to allow for reasonable variation in gap size estimations. Also, QUAST does not handle allele shifting of contigs on scaffolds from a diploid genome with a diploid reference. As the assemblathon3k dataset provides both copies of each chromosome, the evaluation was performed by giving only one of the copies of each chromosome (copy A) as reference to QUAST. Therefore, some of the errors occur due to the omitted reference copy. For example, the original assembly of minia is free from misassemblies if both copies is given as references. The scenario is however the same for all scaffolders so relative performance can still be compared.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Inflated assembly sizes</head><p>All scaffolders increase the assembly size to some extent but there is large variation among them. On the simulated dataset, all scaffolders except BESST-v2 and SCARPA inflate the assembly size by 18% or more even though all contigs have the potential to be linked (see<ref type="figure" target="#tab_1">Table 1</ref>). SCAFFMATCH inflates the assembly size the most (106.6%) and manual inspection reveals that this is due to a mix of cause (2) and (3). SCAFFMATCH uses an approach (maximum matching) that only permits one neighbour of every contig to be joined; a limitation on fragmented assemblies, making mate pairs link to several neighbors. SCAFFMATCH addresses this limitation by including a separate insertion-step that attempts to place remaining singleton contigs, but it does not perform well on this dataset. SSPACE also inflates the assembly size of the dataset sim to a large extent, but has only one error. The inflation is from (2), which is a result of SSPACE's heuristic; SSPACE extends scaffolds greedily by choosing (only) one neighboring contig with the most links. OPERA, SOPRA and BESST show vulnerability by making orientation mistakes (as in<ref type="figure" target="#fig_0">Fig. 1</ref>) due to creating many joins where the link is interpreted as a MP instead of a PE. SCARPA has low inflation on this dataset. On the assemblathon3k dataset, see<ref type="figure" target="#tab_2">Table 2</ref>, BESST-v2 is able to increase the adjusted E-size with a factor of 22 while keeping the size of the assembly relatively constant. SCAFFMATCH, SSPACE, BESST and SCARPA inflate the assembly size significantly, but the large amount of errors and small E 0 s =E 0 c (for SSPACE and SCAFFMATCH) suggests that this is due to cause (3). As the PE oriented read has mean insert size of 500, this is the dataset where PE contamination has the highest span coverage and therefore most likely poses the biggest challenge. On the GAGE datasets (<ref type="figure" target="#tab_3">Table 3</ref>) the inflation levels vary significantly among scaffolders. This phenomenon is most evident for SCAFFMATCH and SSPACE and is likely an artifact of theirSSPACE gives only one error but places very few contigs and has an inflation of 43.5% from type (2). OPERA and BESST are the most sensitive to PE contamination with respect to misassemblies. 'Contigs' denotes the initial contig assembly metrics from which the relative inflation, increase in errors and corrected contiguity are computed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Assembly scaffolding</head><p>methodology. SCAFFMATCH inflates the assembly size the most and shows larger inflation as contamination increases (up to 19.2% and 28.7% on average on rhodo and hs14 respectively). SSPACE also shows high inflation rate on the GAGE assemblies already with the original libraries (c added ¼ 0), e.g. 6% on hs14. The contamination further worsens this behavior for SSPACE to 17% on average on rhodo and 9% on hs14 for c added ¼ 40. SCARPA and BESST are also affected by assembly inflation, but not to the same extent as SSPACE and SCAFFMATCH. Notably, SCAFFMATCH, SSPACE and SCARPA show an extreme inflation in assembly size on the two most fragmented assemblies on rhodo (ABySS and SGA) with inflation between 28 and 49% on ABYSS and 58 and 103% on SGA (Supplemental data,<ref type="figure">Table S7</ref>–S9), and a similar trend for the most fragmented assemblies on hs14 (Supplemental data,<ref type="figure" target="#tab_1">Table S11</ref>– S13). Such extreme inflation is clearly not correct as it almost doubles the assembly size, especially when the contig assembly size is already larger than the true genome size. We also argue that even subtle inflation increase on these datasets are artifacts as BESST-v2 in general has the fewest errors and highest increase in contiguity with only a small increase in assembly size. Inflation/deflation level vary among the integrated scaffolders. For example, SGA contig assemblies are generally significantly larger than the genome size and SGA's scaffolder removes a lot of sequence in the scaffolding step. In the hs14 assemblies, the integrated scaffolders in Velvet, Bambus2, MSR-CA and SOAPdenovo inflate assembly size the most and also introduce significantly more errors than the other scaffolders.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Summary inflation</head><p>In total, our results indicate that assembly inflation is more likely due to poor scaffolding (cause<ref type="bibr">(3)</ref>) or the inability to place many contigs in a fragmented scaffold (cause (2)) rather than correctly added sequence gaps (1) for both stand alone and integrated scaffolders. This is supported by investigating the individual assemblies (Tables S2–S14). The more fragmented assemblies show significantly higher inflation and error rate than the higher quality ones. We suggest users of scaffolders to look at similar metrics after the scaffolding step is performed. Notably, BESST-v2 reduces the assembly size slightly with increased PE contamination (<ref type="figure" target="#tab_3">Table 3</ref>). This is due to the fact that BESST-v2 can use the extra short range information to place smaller contigs, thus lowering inflation by reducing gapped sequence, i.e. gaps caused by (2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Errors and contiguity</head><p>The sim and assemblathon3k datasets show how strongly PE contamination can affect scaffolding (Tables 1–2). There are extreme differences in inflation, errors and E 0 s among the scaffolders on these two datasets. The differences in result between BESST and BESSTv2, as well as the number of errors of, e.g. OPERA, SOPRA and SCAFFMATCH, indicate that a large part of the links created in the scaffolding graph are from PE contamination. BESST-v2 corrects all errors on sim and the majority of errors on assemblathon3k, which indicates that it is an efficient method for finding the correct ordering. The GAGE datasets (<ref type="figure" target="#tab_3">Table 3</ref>) further show that PE contamination affects scaffolding significantly, especially when assemblies are more fragmented, as is common for more complex genomes (see hs14,<ref type="figure" target="#tab_3">Table 3</ref>). OPERA and BESST seem to be the most vulnerable to contamination with significant increase in errors and lower E 0 s across most assemblies as the contamination level increases. SCARPA is another scaffolder where introduced contamination changes the results drastically across single assemblies. However, one assembly (MSRCA) is missing from SCARPA on hs14 due to our computational time constraint and the average is therefore somewhat distorted for hs14 with c added ¼ 40. The effect on individual assemblies is an increasing number of misassemblies (see Tables S12–S14). SSPACE takes a more conservative approach as it only chooses one neighboring contig to extend the scaffold with, which is reflected with increased level of inflation. This results in a slightly lower E 0 s for the c added ¼ 40 libraries. On rhodo (<ref type="figure" target="#tab_3">Table 3</ref>), however, there is a large increase in errors, where almost the entire increase is on the two fragmented assemblies ABySS and SGA. Due to the number of failed runs by SOPRA on hs14 (from the time constraint), no general conclusion about trend can be made with the averaged data presented here. However, as with the other scaffolders, SOPRA is the most affected by fragmented assemblies and greatly increases the number of errors on SGA and Velvet on hs14 when contamination is present (<ref type="figure" target="#tab_1">Table S12</ref>–S14). SCAFFMATCH shows fairly consistent number of misassemblies and E 0 s across all datasets and with a relatively good E 0 s. However, it always has significantly more misassemblies than other scaffolders. With the GAGE libraries, BESST-v2 has the second fewest to fewest misassemblies and second highest to highest E 0 s for almost all runs. The E 0 s even increases on rhodo (<ref type="figure" target="#tab_3">Table 3</ref>) as contamination is introduced due to the extra read pair information. Although average number of misassemblies increases slightly for BESST-v2 with the contamination level in the GAGE runs, the difference is relatively small. In fact, the number of misassemblies at c added ¼ 40 made by BESST-v2 are competitive also at c added ¼ 0 with other scaffolders. The tradeoff between misassemblies and increase in E 0 s gives BESSTv2 favorable results to the other scaffolders.<ref type="figure" target="#tab_3">Table 3</ref>for hs14 with c added ¼ 0 shows that BESST-v2 lowers the misassemblies with almost 40%, with the most significant decrease on ABySS, ABySS2, SGA and Velvet. This suggests that a large part of the edges formed in a fragmented contig graph comes from PE contamination. Notably, BESST-v2 also improves scaffolding compared with integrated scaffolders across almost all datasets (see Tables S4, S7 and S12). On hs14, BESST-v2 has both fewer errors and higher corrected contiguity for all assemblies except for ABySS and ABySS2, where contiguity is 3-fold higher but at the cost of more errors. In conclusion, stand-alone scaffolders introduce a large number of misassemblies on the fragmented assemblies with contamination present (e.g. ABySS and SGA in rhodo,<ref type="figure">Table S7</ref>–S9, or ABySS, SGA and Velvet in hs14,<ref type="figure" target="#tab_1">Table S12</ref>–S14). By comparing the two versions of BESST, we see that BESST-v2 corrects most of these<ref type="figure">Table  S7</ref>–S9 and hs14,<ref type="figure" target="#tab_1">Table S12</ref>–S14, in Supplementary data). Modeling PE contamination in the scaffolding step is important for larger and more complex genomes where assemblies tends to be fragmented, thus the proportion of PE links increases. This is supported by looking at the number of errors that is corrected in the hs14 assemblies on real data; with original GAGE libraries BESST-v2 reduce 54% of BESST's errors when scaffolding the SGA assembly and 53% on the ABySS assembly (See Supplemental<ref type="figure" target="#tab_1">Table S13</ref>). Finally, BESST-v2 generally gives preferable results over integrated scaffolders on GAGE data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.1">Runtime and alignments</head><p>We also measured runtime and peak memory of the tools, see Supplementary Tables S36–S47. Resource usage is not the main objective in this study and has been studied in other work (<ref type="bibr" target="#b8">Hunt et al., 2014;</ref><ref type="bibr" target="#b19">Sahlin et al., 2014</ref>). However, we note that BESST, BESSTv2, SSPACE, OPERA and SCAFFMATCH (with the greedy approach) all have runtimes that should be practical on most genomes. There is no big difference in speed and memory demand between BESST-v2 and BESST.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusions</head><p>We have designed a scaffolder that can identify and make use of read pairs with PE orientation in a MP library, so called PE contamination. The scaffolder (BESST-v2) accurately infers scaffolds, even with high levels of contamination, and we showed that other scaffolders are vulnerable to PE-contaminated libraries. Our results indicate that, when modeled, PE contamination helps scaffolding, serving as short-range linking information which complements longranging mate-pair reads. This combination of reads helps placing<ref type="figure" target="#tab_3">Table 3</ref>. GAGE contig assemblies for Staph, rhodo and hs14 scaffolded with GAGE's shortjump MP-library, c added ¼ 0, with an added 15% PE contamination reads, N(300, 30), c added ¼ 15, and with an added 40% PE contamination reads, N(400, 40),The numbers are averaged over each assembly. Full tables are found in Supplementary data. 'Contigs' denotes the initial contig assembly metrics from which the relative. Boldfaced numbers indicates fewest scaffolding errors and highest ratio of increase in corrected E-size between contigs and scaffolds. small contigs in fragmented assemblies. We also showed that inflated assembly sizes after scaffolding are more often a result of the inability of scaffolders to place all contigs in a scaffold or erroneous gaps, rather than correctly inserted missing sequence from the contig assembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This work was in part funded by the Swedish Research Council (grant 20104634). The computations were performed on resources provided by the Swedish National Infrastructure for Computing through Uppsala Multidisciplinary Center for Advanced Computational Science (UPPMAX) under project b2013169.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict</head><p>of Interest: none declared.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Left: Two possible placements of contigs if we do not know the relative orientation of the read pair link. Right: The corresponding contig graphs where '5' and '3' denotes the 5 0 and 3 0 ends of contigs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>each edge have w e links, we would like to minimize min X e2E w e z e taken over the possible orderings. 2.1.2 Fixed ordering objective with contamination Let ^ l MP e denote the estimated average insert size of links from edge e between two contigs given that the links are oriented as mate pairs in a given placement, and similarly let ^ l PE e be the estimated average paired end insert size of edge e. Analogously, define the distance discrepancies z MP e and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>BESST's improved linking step yields the ILP instances modeled in the previous section. A suggested path corresponds to a set of ordered contigs c 1 ; c 2 ;. .. ; c m where a consecutive pair c i ; c iþ1 is connected by an edge with MP orientation, and c 1 and c m are 'border' contigs (defined in Sahlin et al., 2014)—their positions within the path are fixed. We call the edges connecting consecutive contigs c i ; c iþ1 ; i 2 ½2; m À 2 'ambivalent'—the edges we infer PE or MP order over, see supplemental Figure S1 (non-consecutive contigs in the initial path may also be connected by edges). Let p 0 ¼ ðc 1 ; c 2 ;. .. ; c m Þ be a path found by BESST. Let E 0 be the set of indices i in p 0 where c i ; c iþ1 are connected by an 'ambivalent' edge. Initially, a path of m contigs has exactly m – 3 ambivalent edges, i.e. jE 0 j ¼ m À 3, see supplemental Figure S1. Let a(c, p) be the function that takes a contig c and an ordering p and returns the current position of c in the ordering p. For p 0 , we create m – 2 contig orderings P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. Results on the sim dataset. BESST-v2 finds the correct order, orientation and approximate positions of all contigs and joins the contigs into a single scaffold</figDesc><table>Tool 
Infl. 
Scf-errors 
E 0 
s =E 0 

c 

BESST-v2 
1.002 
0 
130.9 
BESST 
1.370 
199 
2.4 
SSPACE 
1.435 
1 
5.5 
OPERA 
1.406 
255 
1.0 
SOPRA 
1.179 
73 
2.0 
SCARPA 
1.015 
9 
5.4 
SCAFFMATCH 
2.066 
95 
2.5 

Size 
Ctg-errors 
E 0 

c 

Contigs 
496 500 
0 
3692.0 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 2. Assemblathon3k, the original Assemblathon 1 dataset with 3 kbp short jump library. BESST-v2 removes 83.6% of BESST's errors and has superior contiguity and number of misassemblies to the other scaffolders</figDesc><table>Tool 
Infl. 
Scf-errors 
E 0 
s =E 0 

c 

BESST-v2 
1.016 
2088 
21.4 
BESST 
1.152 
15329 
4.1 
SSPACE 
1.110 
26410 
1.0 
OPERA 
1.015 
10161 
1.7 
SCARPA 
1.070 
15038 
1.2 
SCAFFMATCH 
1.200 
34124 
1.0 

Size 
Ctg-errors 
E 0 

c 

Contigs 
120 105 427 
7 
5374.9 

SOPRA is missing from the table because it did not meet the runtime 
constraint. </table></figure>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">K.Sahlin et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Scaffolding pre-assembled contigs using SSPACE</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Boetzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="578" to="579" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Space-efficient and exact de bruijn graph representation based on a bloom filter</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Chikhi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Rizk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">22</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">SOPRA: Scaffolding algorithm for paired reads via statistical optimization</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Dayarian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinf</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">345</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">SCARPA: scaffolding reads with practical algorithms</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Donmez</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Brudno</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="428" to="434" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Assemblathon 1: a competitive assessment of de novo short read assembly methods</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Earl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="2224" to="2241" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Opera: reconstructing optimal genomic scaffolds with high-throughput paired-end sequences</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1681" to="1691" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">High-quality draft assemblies of mammalian genomes from massively parallel sequence data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gnerre</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci. USA</title>
		<meeting>. Natl. Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1513" to="1518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">QUAST: quality assessment tool for genome assemblies</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Gurevich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1072" to="1075" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">A comprehensive evaluation of assembly scaffolding tools</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Hunt</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">42</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">The greedy path-merging algorithm for contig scaffolding</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="603" to="615" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Data processing of Nextera mate pair reads on Illumina sequencing platforms</title>
	</analytic>
	<monogr>
		<title level="j">Illumina</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Snakemake – a scalable bioinformatics workflow engine</title>
		<author>
			<persName>
				<forename type="first">K€</forename>
				<surname>Oster</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Rahmann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="2520" to="2522" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<monogr>
		<title level="m" type="main">Aligning sequence reads, clone sequences and assembly contigs with BWA-MEM</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast and accurate long-read alignment with Burrows–Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="589" to="595" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Scaffmatch: Scaffolding algorithm based on maximum weight matching</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Mandric</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Zelikovsky</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="31" to="2632" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Nxtrim: optimized trimming of illumina mate pair reads</title>
		<author>
			<persName>
				<forename type="first">O &apos;</forename>
				<surname>Connell</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="31" to="2035" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Improved gap size estimation for scaffolding algorithms</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Sahlin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="2215" to="2222" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">BESST – efficient scaffolding of large fragmented assemblies</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Sahlin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinf</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">281</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">GAGE: A critical evaluation of genome assemblies and assembly algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">The MaSuRCA genome assembler</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">V</forename>
				<surname>Zimin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="2669" to="2677" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>