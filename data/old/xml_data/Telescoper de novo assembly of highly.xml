
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:49+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Telescoper: de novo assembly of highly repetitive regions</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<surname>Ma &apos;ayan Bresler</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Sara</forename>
								<surname>Sheehan</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Andrew</forename>
								<forename type="middle">H</forename>
								<surname>Chan</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yun</forename>
								<forename type="middle">S</forename>
								<surname>Song</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of EECS</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Statistics</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>94720</postCode>
									<settlement>Berkeley</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Telescoper: de novo assembly of highly repetitive regions</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="311" to="317"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts399</idno>
					<note>Copyedited by: MANUSCRIPT CATEGORY: ECCB [16:38 9/8/2012 Bioinformatics-bts399.tex] Page: i311 i311–i317 BIOINFORMATICS Availability: Telescoper is publicly available for download at sourceforge.net/p/telescoper. Contact: yss@eecs.berkeley.edu Supplementary Information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: With advances in sequencing technology, it has become faster and cheaper to obtain short-read data from which to assemble genomes. Although there has been considerable progress in the field of genome assembly, producing high-quality de novo assemblies from short-reads remains challenging, primarily because of the complex repeat structures found in the genomes of most higher organisms. The telomeric regions of many genomes are particularly difficult to assemble, though much could be gained from the study of these regions, as their evolution has not been fully characterized and they have been linked to aging. Results: In this article, we tackle the problem of assembling highly repetitive regions by developing a novel algorithm that iteratively extends long paths through a series of read-overlap graphs and evaluates them based on a statistical framework. Our algorithm, Telescoper, uses short-and long-insert libraries in an integrated way throughout the assembly process. Results on real and simulated data demonstrate that our approach can effectively resolve much of the complex repeat structures found in the telomeres of yeast genomes, especially when longer long-insert libraries are used.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Recent advances in high-throughput sequencing (HTS) technologies have dramatically reduced the cost of producing reference genomes for new species and characterizing whole-genome variations in multiple individuals of a population. However, the assemblies produced by current algorithms are often incomplete.<ref type="bibr" target="#b0">Alkan et al. (2011)</ref>report that a de novo shotgun assembly of the human genome using short-reads is 16% shorter than the reference assembled using more laborious means, and that &lt; 1% of segmental duplications are represented. Indeed, it is well recognized that there is room for better algorithmic use of the data, especially for repetitive regions, which are one of the primary challenges in assembly. Telomeres are particularly complex and repetitive, and thus very difficult to assemble correctly. Not only does each telomere contain repeats within itself, but often telomeres on different chromosomes are very similar. Existing assembly algorithms thus frequently fail to assemble telomeric regions from short-read data. Due to this lack of complete assembly, telomere evolution has not been fully characterized, though a great deal is to be gained from it, as telomeres have been linked to ageing (<ref type="bibr" target="#b13">McEachern et al., 2000</ref>). High-quality * To whom correspondence should be addressed.</p><p>telomere assemblies could help us learn more about the variation in telomeres within and between species. In addition, characterizing telomere gene families and their regulation could help us clarify the function of telomeres and how they change as we age. Genome assembly is the challenge of piecing together reads to reconstruct the original genome. Reads are obtained from various technologies, with varying read length, error rates and coverage. Sanger-chemistry reads range in length from around 500 to 1000 bases. Newer technologies such as Illumina, Complete Genomics (<ref type="bibr" target="#b4">Drmanac et al., 2010</ref>), Helicos (<ref type="bibr" target="#b7">Harris et al., 2008</ref>), 454 Life Sciences (<ref type="bibr" target="#b12">Margulies et al., 2005</ref>), SOLiD (<ref type="bibr" target="#b14">McKernan et al., 2009</ref>) and Ion Torrent (<ref type="bibr" target="#b20">Rothberg et al., 2011</ref>) provide reads at vastly lower costs for greater throughput, but at the expense of length. Initial improvements in assembly from short-read data focused on how to process the sheer quantity of data and how to detect overlaps. The de Bruijn graph proved a useful data structure for this purpose (<ref type="bibr" target="#b19">Pevzner et al., 2001</ref>) and is used by pioneering short-read assemblers such as Velvet (<ref type="bibr" target="#b25">Zerbino and Birney, 2008</ref>) and EULER-USR (<ref type="bibr" target="#b2">Chaisson et al., 2009</ref>), and subsequent assemblers including SOAPdenovo (<ref type="bibr" target="#b10">Li et al., 2010</ref>), ALLPATHS 2 (<ref type="bibr" target="#b11">MacCallum et al., 2009</ref>), ABySS (<ref type="bibr" target="#b22">Simpson et al., 2009</ref>) and Cortex (<ref type="bibr" target="#b8">Iqbal et al., 2012</ref>). Many HTS platforms produce paired-end or mate-pair reads, which we collectively refer to as read-pairs. The paired nature of these reads constitutes a powerful source of information, significantly facilitating genome assembly. Improved use of readpair information lies at the heart of recent works such as ALLPATHSLG (<ref type="bibr" target="#b6">Gnerre et al., 2011</ref>), the PE-Assembler (<ref type="bibr" target="#b1">Ariyaratne and Sung, 2011</ref>) and the Paired de Bruijn Graph (<ref type="bibr" target="#b15">Medvedev et al., 2011</ref>), innovations of which are primarily in earlier use of short-insert read-pairs. ALLPATHS-LG requires reads of length around 100 bases sequenced from short fragments of length ≈ 180 bp so that, on average, each read-pair overlaps by ∼20 bases. This means that in general each read-pair can be merged into a single longer read corresponding to the fragment. A drawback of this approach is in the very specific type of data required, which differs from the standard library construction of fragments 300–500 bp in size. The PE-Assembler builds short stretches in non-repetitive regions first, similar to unitigs (see Section 2 for a definition) in a de Bruijn graph, and then extends these iteratively using reads with mates that map to the increasing already-assembled portion. (A similar idea is also used in<ref type="bibr" target="#b17">Parrish et al. (2011)</ref>for resequencing with a reference, where insertions are assembled as iterative extensions of existing sequences.) The Paired de Bruijn Graph method entails building a so-called A-Bruijn graph in which vertices track pairs of reads instead of single reads, with two vertices being merged only if the merging is consistent with the associated pairs of reads. To our knowledge, this method remains largely theoretical at this time, and it has been tested only on simulated data with perfect reads. A theoretical observation from<ref type="bibr" target="#b15">Medvedev et al. (2011)</ref>is that longer long-insert libraries can substantially improve assembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Copyedited by:</head><p>MANUSCRIPT CATEGORY: ECCB<ref type="bibr">[</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M.Bresler et al.</head><p>Recent innovations (<ref type="bibr" target="#b18">Peng et al., 2012</ref>) in library construction may bring such libraries into the mainstream, so it is timely to develop algorithms that take full advantage of such data. In this article, we describe a new algorithm to improve de novo assembly of highly repetitive regions. Although the ideas presented here are applicable to the assembly of any genomic region, our algorithm was developed with the specific aim of assembling highly repetitive regions such as telomeres. In our method, which we name Telescoper, we incorporate the following three algorithmic ideas, the latter two of which make novel use of read-pairs: 1. Iterative extensions: a seed sequence is extended iteratively using reads localized to a particular region by their mates, thus allowing for gradual extension into difficult regions. See Section 3.1 for details. As mentioned above, this idea is not new, but it has not yet been fully exploited in a well-used algorithm, despite several potential advantages.Each of the above ideas helps to resolve repetitive regions. Implicit throughout our algorithm is the principle that in order to assemble difficult regions, one cannot make only safe simplifications, but must also explore several alternative extensions and use downstream analysis to find and reject false extensions. We tested the performance of our method on both real and simulated data from the telomeres of the Saccharomyces cerevisiae genome, which consists of 16 chromosomes. This is a particularly challenging problem since all such telomeres have a core repetitive component called X (≈ 475 bp long) as well as several combinatorial repeats and sometimes a larger repetitive component (see Saccharomyces Genome Database, www.yeastgenome.org). In addition, because S.cerevisiae underwent an ancient genome duplication (<ref type="bibr" target="#b9">Kellis et al., 2004</ref>), telomeric regions of different chromosomes typically share highly similar repetitive regions. We show that Telescoper is capable of generating more complete and continuous assemblies in the telomeric regions than other state-of-the-art de novo assembly algorithms, especially when longer long-insert libraries are used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Simultaneous</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">TERMINOLOGY</head><p>We adopt the following terms commonly used to describe the output of sequencing technologies and the resulting assemblies: @BULLET Read-pair: refers to a pair of sequenced reads from a fragment. The fragment size determines the distance between the two reads, often called the 'insert' size. The insert distribution is frequently approximated by a normal distribution. We use the term read-pair regardless of whether the insert is short or long.</p><p>@BULLET Mate: refers to the partner of a read R in a read-pair. When R is oriented with respect to a sequence, we know its mate's relative position and can refer to it as a 'left-mate' or 'rightmate' (or, as a 'left-read' or 'right-read').</p><p>@BULLET Contig: a sequence, which ideally belongs to the original genome, produced from assembling a group of reads. The standard output from an assembly algorithm is a set of contigs. Contigs are often ordered to produce 'scaffolds', which may contain stretches of unknown sequence between the contigs.</p><p>@BULLET Read-overlap graph: also called a read-graph, is a graph in which each vertex is a read and directed edges between reads represent overlapping sequence, i.e. in the error-free case, the last k bases of one read are the same as the first k bases of its neighbor read, where k is greater than some threshold.</p><p>@BULLET Unitig: a path through the read-graph that can be unambiguously merged into a single sequence. A 'unitig graph' is an extension of the read-overlap graph idea (similarly for a unitig path), where the vertices are now unitigs.Telescoper<ref type="figure">Fig. 1</ref>. High-level description of the algorithm. Beginning with the seed string S 0 , the algorithm iteratively performs the steps described to construct an e-graph data structure, from which a contig or contigs can be read. For simplicity, only a few example arcs are shown; in reality, red arcs are present between each consecutive pair of e-nodes, and orange arcs can be present between a given e-node and any of its preceding e-nodesIn the following description, we assume without loss of generality that we are extending to the right.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Iterative extension of assembly</head><p>The extension step consists of finding possible extensions of a given e-node; the extensions will in turn become e-nodes themselves. We fix the length of each e-node so that most right-reads in the new extension will have leftmates mapping to the e-node rather than behind it. In our implementation, we choose this length, denoted N tot , to be the mean insert length plus the standard deviation of the short-insert library. In the case of multiple shortinsert libraries, one can use the largest short-insert length for computing N tot. The extension step is depicted in<ref type="figure" target="#fig_1">Figure 2</ref>. It begins by mapping all the left-reads to the e-node to obtain right-mates extending off the right end of the e-node into unknown region yet to be assembled, i.e. the left-mate maps to the e-node and the right-mate dangles off the end, as illustrated in<ref type="figure" target="#fig_1">Figure 2a</ref>. We say that these right-mates form a read 'cloud'. The reads in the read cloud are error-corrected, then used to construct a read-overlap graph, which is transformed into a unitig graph as depicted in<ref type="figure" target="#fig_1">Figure 2b</ref>. More details on error-correction and read-overlap graph construction are provided in the Supplementary Material. The unitig graph encodes a list of candidate extensions for the contig, as illustrated in<ref type="figure" target="#fig_1">Figure 2c</ref>. Each new e-node consists of N new bases of new extension plus (N tot −N new ) bases from the end of the previous e-node. There are several advantages to this localized assembly. First, it reduces ambiguities caused by repeats. For a read-pair from another location to interfere with the area under construction, its left-read must map to the previous e-node while the right-read must overlap with another read in theread cloud. Second, because it restricts assembly to a small region, there is ample memory to store complicated information about the reads and their relationships. This information can be thrown out as we move to other regions of the graph. This local use of information enables more complex use of read-pairs, as described in Sections 3.2 and 3.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Simultaneous use of short-insert read-pairs in statistical scoring of extensions</head><p>Although existing assembly algorithms make use of read-pairs in various ways, the information contained in read-pairs has not yet been fully exploited. In other assemblers, read-pairs are used primarily to connect unitigs with expected insert sizes. We can obtain additional power by scoring potential extensions according to the features derived from the aligned read-pairs. We first evaluate extensions based on the likelihood of gaps in shortinsert read-pair coverage. Each extension consists of an ordered sequence of unitigs, as in<ref type="figure" target="#fig_1">Figure 2c</ref>. Each right-read in an assembled unitig will have a left-mate mapping to earlier sequence in the previous e-node. The set of left-mates associated with reads in unitig U is denoted M U (<ref type="figure" target="#fig_2">Fig. 3a</ref>). In our model, we make the simplifying assumption of a uniform coverage distribution. Let x denote the distance from the right end of a left read relative to the start of unitig U , as pictured in<ref type="figure" target="#fig_2">Figure 3b</ref>. We denote by f U (x) the expected number of left-reads in M U spanning position x (<ref type="figure" target="#fig_2">Fig. 3c</ref>). We compute f U (x) by convolving the expected insert distribution h(·) with the uniform distribution over the stretch of U on which right mates can begin:</p><formula>f U (x) = L(U )− t=0 λ·h(x +t),</formula><formula>(1)</formula><p>where L(U ) is the length of U , is the read length and λ is the probability of a read arriving at position t; note that λ is equal to C/(2), where C is the coverage. False unitigs will typically have gaps in the empirical distributionˆf distributionˆ distributionˆf U (x), as illustrated in<ref type="figure" target="#fig_3">Figure 4b</ref>. Let Gap(U ) denote the set of such gaps associated with U. For a gap g ∈ Gap(U ) of length ≥ /2, we compute a penalty equal to the number of mates expected in g, obtained by summing f U (x) over g's coordinates. The preliminary score for an extension is then the sum of these penalties over all gaps and all unitigs in the extension:</p><formula>p ext = U ∈extension g∈Gap(U ) x∈g f U (x).</formula><formula>(2)</formula><p>To produce a final score P ext for each possible extension, we add p ext to a 'contig gap penalty', equal to λ times the largest gap size (denoted by g c in<ref type="figure" target="#fig_3">Fig. 4c</ref>) between two adjacent unitigs, i.e. the expected number of reads to fall in that gap. The best extensions (i.e. those with the lowest P ext scores) are kept, as described in more detail in Section 3.4.<ref type="figure">Figure 1</ref>, scoring an e-node's possible extensions using short-insert read-pairs. (a) The penalty for unitig U 2 is 0 because no gaps of size ≥ /2 exist (where is the read length). (b) The penalty for unitig U 3 is &gt; 0 because a gap, denoted g, of size ≥ /2 exists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i313</head><formula>(c)</formula><p>The size of contig gap g c is the distance between the reads that define the end and start of two adjacent unitigs</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Simultaneous use of long-insert libraries</head><p>Telescoper uses all libraries simultaneously during assembly, rather than using long-insert libraries only during scaffolding or gap-filling, as is typical in other assembly algorithms. The main idea is that once long paths have been formed in the e-graph, any further extension can be evaluated on the basis of its agreement with the current e-graph according to each library. Having produced and pruned a set of extensions using just the short-insert library in Steps 1 and 2 of our algorithm (<ref type="figure">Fig. 1</ref>), the third step aims to confirm that a proposed extension is supported by read-pair information from all other libraries simultaneously. For there to be ambiguity in extension choice, there must be repeats at lengths corresponding to all library sizes. To test for long-insert read-pair support of a potential extension, we first gather all read-pairs of which right reads map to the extension and left-reads map to the previous e-nodes in the path up the e-graph. Then, if the right reads fully cover the proposed extension, even possibly without overlaps, we consider the extension to be fully supported. Partial support is computed as a linear function of the fraction of the extension that is covered by the right reads. This support measure is then multiplied by the short-insert score P ext to obtain a single final score.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Choosing extensions for continuation</head><p>For a given e-node, upon finding all its possible extensions, at most B top scoring (the lower the better) extensions are retained for computational tractability. In our analysis, we use B = 4. We create a new e-node for each of these top scoring extensions and assign a running score equal to the sum of its extension score and its parent e-node's running score. Then, at each depth in the e-node graph, the B top scoring e-nodes are marked for pursuit. An e-node is terminated if it cannot be lengthened by the extension operation, if its extension score plus the scores of two previous ancestral extensions exceeds a threshold, or if a specified maximum depth is reached. To track the parallel success of alternative e-node paths and keep their number in check, we use breadth first search to explore the e-graph. If two different sequences of e-nodes end with equivalent e-nodes at a particular depth, we allow the two e-nodes to merge. This kind of merging of e-nodes reduces the computational burden.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EMPIRICAL RESULTS</head><p>In this section, we compare Telescoper's performance with that of other short-read assembly algorithms, including ABySS (<ref type="bibr" target="#b22">Simpson et al., 2009</ref>), ALLPATHS 2 (<ref type="bibr" target="#b11">MacCallum et al., 2009</ref>), SGA (<ref type="bibr" target="#b23">Simpson and Durbin, 2012</ref>), SOAPdenovo (<ref type="bibr" target="#b10">Li et al., 2010</ref>) and Velvet (<ref type="bibr" target="#b25">Zerbino and Birney, 2008</ref>). Because of limited space, we focus on short-read data in the ensuing discussion. However, as detailed in the Supplementary Material, we also considered a combination of short-insert short-read data and long-insert Sanger read data, and observed that Telescoper compares favourably with other algorithms, including Celera (<ref type="bibr" target="#b16">Myers et al., 2000</ref>), which was designed for Sanger reads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Data and experiment setup</head><p>We studied the performance on both simulated and real data from strain S288C of S. cerevisiae. We obtained a reference genome from Saccharomyces Genome Database (www.yeastgenome.org), which was created through extensive, systematic sequencing to produce a very accurate assembly, including the telomeric regions. As mentioned earlier, because of ancient genome duplication and complex yeast telomere structure, the telomeres of different chromosomes typically share highly similar repetitive regions, which poses challenges to assembly. We considered different types of data to test the robustness of the algorithms and to study the effect of insert distributions on performance:<ref type="bibr" target="#b24">Nieuwerburgh et al. (2012)</ref>, were sorted using DeLoxer into reads categorized as short-insert (0–400 bp fragments, mean 220 bases) or long-insert (1–5 kb, mean 2.3 kb). The reads varied in length from 30–100 bp. We truncated reads to 50 bases in order to provide algorithms with high-quality, uniform-length reads. We used coverage 120× for the short-insert data and 40× for the long-insert data. The performance of Telescoper does not degrade with higher coverage data. We sought to assess assembly for the 40-kb telomeric regions at the ends of each of S. cerevisiae's 16 chromosomes. To this end, we simulated data only from this region. For the real data, we used the full dataset, but restricted evaluation statistics of the produced contigs to those alignable to the 32 telomeres, each of length 40 kb. Details of running the various algorithms, including parameter settings and runtimes, can be found in the Supplementary Material. To optimize the performance of the other algorithms, insert distribution and coverage parameters were provided where appropriate. We did not include SGA for D2 and D3 since it was designed for reads of at least 100 bp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Assembly performance</head><p>Several standard metrics exist for measuring assembly performance in the absence of a reference genome. They include the length of the largest contig, the total length of all contigs, and N50 (which is equal to the longest contig length such that the sum of the lengths i314of all longer contigs is half the total output assembly). An additional metric is NG50 (<ref type="bibr" target="#b5">Earl et al., 2011</ref>), which is similar to N50 but more comparable across assembly algorithms. When the genome length is known, then rather than using each algorithm's estimate of the genome size, which can fluctuate widely depending on the threshold at which small contigs are output, one can use the true genome size. Thus NG50 is defined as the length of the longest contig such that the sum of all longer contigs is half the total genome size. We considered the above-mentioned metrics in our study. To investigate assembly accuracy, we mapped each contig to the reference genome using NUCmer from the MUMMER package (<ref type="bibr" target="#b3">Delcher et al., 2002</ref>). For each contig, we determined to which telomere it maps best according to the total number of aligned bases. The number of aligned bases in each contig forms a more useful foundation for accuracy-informed continuity statistics than the direct number of bases in each contig. Therefore, we also computed the aforementioned metrics using these aligned lengths. The results of our study for simulated data are summarized in<ref type="figure" target="#tab_1">Table 1</ref>, while the results for the real data are shown in<ref type="figure" target="#tab_2">Table 2</ref>. These results are for the 32 telomeric regions, each of length 40 kb. As the tables show, Telescoper exhibited the best performance under most metrics, with notable margins from the second best method. As shown in<ref type="figure" target="#tab_1">Table 1</ref>, reducing the read length from 101 to 50 bp while keeping all other parameters the same worsened the performance of most algorithms, with ABySS being the most affected.<ref type="figure" target="#fig_8">Figure 5</ref>provides a more detailed picture of contig length distribution. These plots show the cumulative proportion for all aligned contigs exceeding the contig size indicated on the x-axis. NG50 can be read from the plots as the x-coordinates at which each curve hits the 50% mark of bases output relative to the reference.The best possible curve is the constant function y = 1, so the closer a curve is to that line, the better the performance. Note that for any given minimum contig size (the x-axis value), Telescoper produced more alignable bases than all other methods compared, for all three datasets. Furthermore, Figures 5a and b illustrate that Telescoper is more robust to a decrease in read length than are the other algorithms. For Telescoper, the observed difference between the corresponding curve in<ref type="figure" target="#fig_8">Figure 5b</ref>and that in<ref type="figure" target="#fig_8">Figure 5c</ref>is largely attributable to the difference in the insert-size distribution. On simulated 50 bp data with long inserts with mean length 2.2 kb and short inserts with mean length 400 bp, the performance of Telescoper was similar to that shown in<ref type="figure" target="#fig_8">Figure 5c</ref>(see Supplementary Material), suggesting that Telescoper is robust the complications of real data and that the observed good performance i315</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M.Bresler et al.</head><p>of Telescoper in<ref type="figure" target="#fig_8">Figure 5b</ref>is due to its improved ability to take advantage of a longer (10 kb instead of 2.2 kb) long-insert distribution. Of further importance is the extent to which an algorithm produces false bases or contigs. Because we forced each contig to align to a single telomere, chimeric contigs created by joining portions of different telomeres were penalized as having bases that do not align. As shown in the '% Aligned' column of<ref type="figure" target="#tab_1">Table 1</ref>, Telescoper was the top performer in this regard for D2, and followed ALLPATHS 2 and Velvet closely for D1. Finally, we considered visually examining the alignments of contigs onto each telomeric region.<ref type="figure" target="#fig_9">Figure 6</ref>shows the results for two chromosomes, with contigs from each assembly algorithm aligned to them. For each algorithm, each contig is represented by a different colour, so more colours per method indicates a larger number of contigs. For each telomeric region shown, Telescoper produced a single contig for almost the entire region, while other algorithms often produced many small contigs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>We have introduced several new ideas for de novo genome assembly, geared towards highly repetitive regions. Our preliminary assembler, Telescoper, proceeds by iteratively extending paths and selecting between them using the empirical distributions formed by both longinsert and short-insert paired-end reads. The utility of Telescoper was validated in a study on both real and simulated data from the 40 kb telomeric regions of each chromosome of S.cerevisiae. For all three datasets tested, Telescoper produced more continuous assemblies than the other algorithms considered. In our evaluations, we tried to include the strongest and most popular algorithms with available implementation. Unfortunately, ALLPATHS-LG (<ref type="bibr" target="#b6">Gnerre et al., 2011</ref>) could not be included, because of its small-fragment library requirement mentioned in Section 1. We considered several standard metrics for comparing assemblies, but we note that the task of comparing genome assemblies is a large one, with several papers exclusively devoted to it (<ref type="bibr" target="#b5">Earl et al., 2011;</ref><ref type="bibr" target="#b21">Salzberg et al., 2012</ref>). Other researchers are currently working on algorithms for identifying assembly errors using features derived from read mapping. Rather than having this be a downstream process, we believe that it would help to incorporate such features directly into an assembly algorithm. Here, we make an effort in this direction by scoring assembly extensions according to read-mapping statistics. Although the scoring scheme used in this article may not be optimal, we have demonstrated that the idea of simultaneously pursuing multiple extensions, and concurrently using multiple libraries to score and select among them is promising. The current implementation of Telescoper can be used as a finishing algorithm to extend contigs into repetitive regions and produce better assemblies for telomeres. Other applications include targeted de novo assembly of structural variants and highly variant regions such as human leukocyte antigen. Future work will include extending the ideas presented here to whole-genome assembly, improving error correction, producing more exhaustive listings of potential paths and more thorough evaluation of the alternate paths. Also, additional validation metrics such as those explored by<ref type="bibr" target="#b21">Salzberg et al. (2012)</ref>can be incorporated as well.We often see cases where, if we took the union of all assemblies, we could produce a much better final product. This suggests that assembly is not a solved problem, and that the strengths of different algorithms can potentially be combined to produce better assemblies. We believe the ideas behind Telescoper have the potential to improve de novo assembly significantly and provide a comprehensive picture of previously unresolved repetitive regions.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. Illustration of Step 1 of Figure 1, finding an e-node S's possible extensions. (a) A read 'cloud' consists of those right-reads with left-mates that map to S. (b) The reads in the cloud are then error corrected and organized into a read-graph, which is in turn converted into a unitig graph. (c) Paths through the unitig graph correspond to possible extensions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.3.</head><figDesc>Fig. 3. Computing the expected number of left-reads mapping back from a unitig U 2 to the previous e-node S. (a) M U 2 denotes the set of reads mapping from unitig U 2 to the previous e-node S. (b) For a right-read R r located at position t in unitig U 2 , the probability of its left-mate R l mapping to S at a distance x behind U 2 is h(x +t), where h(·) is the expected insert distribution. (c) The expected number of reads at position x behind unitig U 2 is given by f U (x) defined in Equation (1)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.4.</head><figDesc>Fig. 4. Illustration of Step 2 of Figure 1, scoring an e-node's possible extensions using short-insert read-pairs. (a) The penalty for unitig U 2 is 0 because no gaps of size ≥ /2 exist (where is the read length). (b) The penalty for unitig U 3 is &gt; 0 because a gap, denoted g, of size ≥ /2 exists. (c) The size of contig gap g c is the distance between the reads that define the end and start of two adjacent unitigs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>Simulated Data D1 consisted of read-pairs with two insert distributions, one short and one long. The read length was 101 bp for both types. The short-insert reads had coverage depth 100× and an insert distribution with mean 400 bp and variance 75 bp. The long-insert reads had coverage depth 20× and an insert distribution with mean 10 kb and variance 1 kb. Simulation details are provided in the Supplementary Material. Simulated Data D2 consisted of two read-pair datasets with the same insert distributions and coverages as D1, but with a reduced read length of 50 bp. Real Data D3 consisted of Illumina read-pairs from a sequencing library preparation using Cre-Lox recombination. The reads, as described in Van</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>Simulated data D1: 101 bp reads, 10 kb long-insert mean Simulated data D2: 50 bp reads, 10 kb long-insert mean Real data D3: 50 bp reads, 2.3 kb long-insert mean</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.5.</head><figDesc>Fig. 5. The cumulative proportion of all aligned contigs exceeding the contig size indicated on the x-axis. These plots illustrate the continuity and completeness of different assemblies. For any given minimum contig length, Telescoper produced more aligned bases. NG50 can be read from this graph as the x-coordinates at which each curve hits the 50% mark of bases output relative to the reference. (a) Results on simulated data D1. (b) Results on simulated data D2. (c) Results on real data D3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig.6.</head><figDesc>Fig. 6. Contig continuity results for real data D3. The left and right telomeric regions (separated by the dotted line) for two different chromosomes are shown, with the aligned contigs displayed for each assembly algorithm. Different colours represent different contigs in the produced assembly, so more colours per method indicates a larger number of contigs. For each telomeric region shown, Telescoper produced a single contig for almost the entire region, while other algorithms often produced many small contigs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 1.</figDesc><table>Summary of assembly results based on simulated data from 32 telomeric regions each of length 40 kb. '%Aligned' is the ratio of Total Aligned to 
Total Produced, while '%Covered' is the fraction of the telomeric regions covered by contigs 

Results for simulated data D1 (read length = 101 bp) 

Produced (kb) 
Aligned (kb) 

Assembler 
N50 
NG50 
Max 
Total 
N50 
NG50 
Max 
Total 
%Aligned 
%Covered 

Telescoper 
40.0 
40.0 
41.0 
1208 
40.0 
40.0 
40.0 
1172 
97.0 
90.4 
ABySS 
31.0 
31.0 
39.0 
1296 
31.8 
31.8 
39.3 
1244 
95.9 
84.7 
ALLPATHS2 
35.2 
33.0 
39.0 
1047 
35.2 
33.4 
40.0 
1032 
98.5 
80.6 
SOAPdenovo 
25.0 
24.0 
39.0 
1149 
28.6 
24.6 
40.0 
1068 
92.9 
82.3 
Velvet 
13.9 
9.0 
31.0 
964 
13.9 
9.5 
31.6 
947 
98.2 
73.7 
SGA 
31.2 
27.0 
39.0 
1110 
31.6 
27.2 
40.0 
1075 
96.8 
82.0 

Results for simulated data D2 (read length = 50 bp) 

Produced (kb) 
Aligned (kb) 

Assembler 
N50 
NG50 
Max 
Total 
N50 
NG50 
Max 
Total 
%Aligned 
%Covered 

Telescoper 
39.0 
38.0 
39.0 
1162 
38.8 
38.3 
39.8 
1155 
99.4 
90.3 
ABySS 
12.1 
8.0 
31.0 
1097 
13.7 
8.9 
31.6 
966 
88.0 
75.0 
ALLPATHS2 
32.0 
27.0 
39.0 
968 
32.8 
27.7 
40.0 
950 
98.2 
74.3 
SOAPdenovo 
25.0 
21.0 
39.0 
988 
24.6 
20.8 
40.0 
954 
96.5 
74.3 
Velvet 
14.0 
9.0 
31.0 
955 
14.2 
9.5 
31.9 
939 
98.3 
73.2 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 2. Summary of results for real data D3. The contigs produced by each algorithm were aligned to the 32 telomeric regions each of length 40 kb. As before, '%Covered' is the fraction of the telomeric regions covered by contigs</figDesc><table>Aligned (kb) 

Assembler 
N50 
NG50 
Max 
Total 
%Covered 

Telescoper 
34.5 
32.8 
39.2 
980 
75.8 
ABySS 
12.0 
8.3 
31.3 
971 
75.3 
ALLPATHS2 
26.3 
16.5 
40.0 
923 
70.1 
SOAPdenovo 
21.4 
16.2 
39.3 
879 
68.6 
Velvet 
11.8 
6.9 
31.3 
928 
72.2 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> METHODS We have two main aims in our algorithm: (i) rather than performing a greedy read-by-read assembly procedure, we build a number of alternative extensions, and score them according to the alignment of read-pairs to each extension and (ii) we use long-insert read-pairs not only for scaffolding or gap filling but also as part of the assembly itself, to check that the local assembly is consistent on a longer scale. Our algorithm begins with a set of non-repetitive &apos;seed strings&apos;, as could be taken from a reference genome, if it exists, or be assembled from a de Bruijn graph. At present, we use seeds of length 500 bp from the reference, at position 40 kb from the end of the chromosome, although contigs produced from any other algorithm could be used. The goal is to then independently extend each contig to produce a more complete assembly. A high-level overview of the algorithm is illustrated in Figure 1. The algorithm proceeds by extending the end of the contig iteratively by a fixed amount, N new , per iteration, as detailed in Section 3.1. We fix the extension length (usually a few hundred bases) as a conservative measure. Because multiple extensions are frequently possible, the result is an &apos;extension graph&apos; (e-graph) in which each extension node (e-node) contains N new bases of new sequence that serve as a possible extension for that e-node&apos;s parent. A path from the root (the seed string) to a leaf represents a series of extensions that form a single lengthened contig. The aim is for the e-graph to contain a path corresponding to the true sequence, ideally terminating close to the end of the desired chromosome, and for this path to be identifiable as the best. Our algorithm will be most tractable if the e-graph is sparse, so at each iteration, there are as few extensions as possible (and the true extension is among them). The criteria for pruning and terminating the e-graph are discussed in Section 3.4. We first explain our methods for (i) listing possible extensions for a given e-node in the e-graph, (ii) scoring each extension based on the alignment of short-insert read-pairs and (iii) scoring each extension based on the alignment of long-insert read-pairs. i312 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">i317 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank Jasper Rine, Oliver Zill and Devin Scannell for their motivation of the problem and for useful discussions. We also thank Paul Jenkins and Jeremy Maitin-Shepard for helpful discussions. Funding: In part by NSF Graduate Research Fellowships (to M.B. and S.S.), an NDSEG Graduate Fellowship (to A.H.C.), and an NSF CAREER Grant DBI-0846015 (to Y.S.S.). Conflict of Interest: none declared.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Limitations of next-generation genome sequence assembly</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Alkan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="61" to="65" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">PE-assembler: de novo assembly using short pairedend reads</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ariyaratne</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">K</forename>
				<surname>Sung</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="167" to="174" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">De novo fragment assembly with short mate-paired reads: does the read length matter?</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J P</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="336" to="346" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Fast algorithms for large-scale genome alignment and comparision</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Delcher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="2478" to="2483" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Human genome sequencing using unchained base reads on self-assembling DNA nanoarrays</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Drmanac</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">327</biblScope>
			<biblScope unit="page" from="78" to="81" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Assemblathon 1: a competitive assessment of de novo short-read assembly methods</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">A</forename>
				<surname>Earl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="2224" to="2241" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">High-quality draft assemblies of mammalian genomes from massively parallel sequence data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gnerre</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci USA</title>
		<meeting>. Natl. Acad. Sci USA</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1513" to="1518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Single-molecule DNA sequencing of a viral genome</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">D</forename>
				<surname>Harris</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">320</biblScope>
			<biblScope unit="page" from="106" to="109" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">De novo assembly and genotyping of variants using colored de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Iqbal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Genet</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="226" to="232" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Proof and evolutionary analysis of ancient genome duplication in the yeast Saccharomyces cerevisiae</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kellis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">428</biblScope>
			<biblScope unit="page" from="617" to="624" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel shortread sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">ALLPATHS 2: small genomes assembled accurately and with high continuity from short paired reads</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Maccallum</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">103</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Genome sequencing in microfabricated high-density picolitre reactors</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Margulies</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">437</biblScope>
			<biblScope unit="page" from="376" to="380" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Telomeres and their control</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Mceachern</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="331" to="358" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Sequence and structural variation in a human genome uncovered by short-read, massively parallel ligation sequencing using two-base encoding</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">J</forename>
				<surname>Mckernan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1527" to="1541" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Paired de Bruijn graphs: a novel approach for incorporating mate pair information into genome assemblers</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Research in Computational Molecular Biology</title>
		<meeting>Research in Computational Molecular Biology</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="238" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">A whole-genome assembly of Drosophila</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">287</biblScope>
			<biblScope unit="page" from="2196" to="2204" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Assembly of non-unique insertion content using next-generation sequencing</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Parrish</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">S3</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>Suppl. . 6</note>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Generation of long insert pairs using a Cre-LoxP inverse PCR approach</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Peng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">29437</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">An Eulerian path approach to DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci</title>
		<meeting>. Natl. Acad. Sci<address><addrLine>USA, 98</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9748" to="9753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">An integrated semiconductor device enabling non-optical genome sequencing</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Rothberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">475</biblScope>
			<biblScope unit="page" from="348" to="352" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">GAGE: a critical evaluation of genome assemblies and assembly algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">ABySS: a parallel assembler for short-read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of large genomes using compressed data structures</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="549" to="556" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Illumina mate-paired dna sequencing-library preparation using Cre-Lox recombination</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Van Nieuwerburgh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page">24</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short-read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>