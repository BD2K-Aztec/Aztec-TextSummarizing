
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sequence analysis Gossamer — a resource-efficient de novo assembler</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Thomas</forename>
								<surname>Conway</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Systems</orgName>
								<orgName type="laboratory">NICTA Victoria Research Laboratory</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<postCode>3010</postCode>
									<settlement>Parkville</settlement>
									<region>Victoria</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Jeremy</forename>
								<surname>Wazny</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Systems</orgName>
								<orgName type="laboratory">NICTA Victoria Research Laboratory</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<postCode>3010</postCode>
									<settlement>Parkville</settlement>
									<region>Victoria</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Andrew</forename>
								<surname>Bromage</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Systems</orgName>
								<orgName type="laboratory">NICTA Victoria Research Laboratory</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<postCode>3010</postCode>
									<settlement>Parkville</settlement>
									<region>Victoria</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Justin</forename>
								<surname>Zobel</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Systems</orgName>
								<orgName type="laboratory">NICTA Victoria Research Laboratory</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<postCode>3010</postCode>
									<settlement>Parkville</settlement>
									<region>Victoria</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Bryan</forename>
								<surname>Beresford-Smith</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computing and Information Systems</orgName>
								<orgName type="laboratory">NICTA Victoria Research Laboratory</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<postCode>3010</postCode>
									<settlement>Parkville</settlement>
									<region>Victoria</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sequence analysis Gossamer — a resource-efficient de novo assembler</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS APPLICATIONS NOTE</title>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="issue">14</biblScope>
							<biblScope unit="page" from="1937" to="1938"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts297</idno>
					<note type="submission">Received on January 9, 2012; revised on April 5, 2012; accepted on May 15, 2012</note>
					<note>Copyedited by: TRJ MANUSCRIPT CATEGORY: APPLICATIONS NOTE [10:50 18/6/2012 Bioinformatics-bts297.tex] Page: 1937 1937–1938 Associate Editor: Michael Brudno</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: The de novo assembly of short read high-throughput sequencing data poses significant computational challenges. The volume of data is huge; the reads are tiny compared to the underlying sequence, and there are significant numbers of sequencing errors. There are numerous software packages that allow users to assemble short reads, but most are either limited to relatively small genomes (e.g. bacteria) or require large computing infrastructure or employ greedy algorithms and thus often do not yield high-quality results. Results: We have developed Gossamer, an implementation of the de Bruijn approach to assembly that requires close to the theoretical minimum of memory, but still allows efficient processing. Our results show that it is space efficient and produces high-quality assemblies. Availability: Gossamer is available for non-commercial use from http://www.genomics.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>High-throughput sequencing technologies have enabled researchers to produce unprecedented volumes of short read data. The de novo assembly of such data is a core problem in bioinformatics with numerous applications in the analysis of genomes, metagenomes, and transcriptomes. There are several common approaches to the de novo assembly of short read data, including those based on greedy extension (<ref type="bibr" target="#b8">Warren et al., 2006</ref>), overlap layout extension (<ref type="bibr" target="#b2">Hernandez et al., 2008</ref>), and de Bruijn graphs (<ref type="bibr" target="#b0">Chaisson et al., 2009;</ref><ref type="bibr" target="#b10">Zerbino et al., 2009</ref>). Our assembler, Gossamer, is an extension of a prototype based on the succinct representation of de Bruijn assembly graphs as a bitmap or set of integers (<ref type="bibr" target="#b1">Conway and Bromage, 2011</ref>). It assembles base-space paired reads such as those from an Illumina sequencing platform.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>Gossamer operates in a series of explicit passes to give the user control of the assembly process. Broadly, assembly proceeds through the following phases: graph construction, graph 'cleaning' to remove spurious edges, alignment of pairs to the Eulerian super-graph, Eulerian super-path lifting, scaffolding and finally contig production. We have constructed a front-end shell script (gossple.sh) which invokes these from a single command line, suitable for simple assemblies. * To whom correspondence should be addressed.</p><p>For a given k, we construct the de Bruijn graph by extracting from the input all graph edges of length ρ = k +1, the ρ-mers and their reverse complements; the graph's k-mer nodes are implied by their incident edges. Gossamer accepts FASTA and FASTQ input and uncompresses files on the fly. The current version of Gossamer allows for values of k ≤ 62. To attain its memory efficiency, Gossamer uses a compressed bitmap representation of the de Bruijn graph (<ref type="bibr" target="#b1">Conway and Bromage, 2011</ref>). In brief, for a collection of reads containing m distinct ρ-mers, the bitmap has 4 ρ entries, each of which is 1 if it corresponds to a ρ-mer from the dataset and 0 otherwise. For realistic datasets, these bitmaps are extremely sparse, and the theoretical minimum number of bits required to represent them isDurbin, 2012) on the same datasets, employing the same assembly 'recipes' that were used in the published GAGE result. The SOAPdenovo results were generated by SOAPdenovo 1.0.5 and SOAPGapCloser 1.12. We used version 0.9.19 of SGA in combination with ABySS 1.2.5 (<ref type="bibr" target="#b6">Simpson et al., 2009</ref>), which SGA requires to perform scaffolding. Running SGA with a more recent version of ABySS (1.3.2) yielded scaffolds with almost no improvement over the original contigs. The GAGE datasets are available in three forms: original reads and two varieties of corrected reads. Each assembler was run on all datasets and the best result selected. We have done the same in our evaluation of Gossamer. The results of the assemblies are shown in<ref type="figure" target="#tab_1">Table 1</ref>. All figures, other than time and memory usage, were generated by the publicly available GAGE evaluation and validation scripts. Because no reference exists for Bombus impatiens, the number of errors and corrected N50 cannot be calculated. We report the minimum amount of memory 'required' by each assembler to run to completion. During initial graph construction, Gossamer can make use of additional memory to hold temporary buffers, potentially saving some writes to disk, and thereby improving runtime. The use of this additional memory is only incidental, however, and does not affect the assembler's output. For all the tests, we used a single server with 8 AMD Barcelona cores and 32GB RAM running Ubuntu Linux, and we have configured the assemblers to use as many cores and as much of that memory as possible. Note that although the published GAGE figures include a result for SGA on the human chromosome 14 datasets, we were unable to run the assembler satisfactorily on our machines on account of its memory usage. As mentioned in the published GAGE result, SGA is not able to run on the Bombus impatiens data. For the Staphylococcus aureus and Rhodobacter sphaeroides datasets, Gossamer's scaffolds contain a number of errors that have no significant bearing on the N50 score. SOAPdenovo's S. aureus result has the same feature, but for the larger genomes the drop in quality is significant. Where it was able to run, SGA has produced the shortest contigs, but with the fewest errors. Overall, Gossamer requires consistently less memory for assembly than SOAPdenovo and SGA. This is especially significant for the larger genomes. SOAPdenovo was, without exception, the quickest of the assemblers tested, while SGA's memory usage and runtimes are significantly higher than the other assemblers'. The large difference between assemblers in the Bombus impatiens results requires further investigation. Without a reference, we cannot be sure of the quality of the generated sequences. We note that, at least for the other data assemblies, Gossamer's N50 results appear more stable in the presence of assembly errors, and so Gossamer's N50 for the Bombus impatiens dataset may be a more reliable indicator of the actual assembly quality.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>Funding: National ICT Australia (NICTA) is funded by the Australian Government's Department of Communications; Information Technology and the Arts; Australian Research Council through Backing Australia's Ability and ICT Centre of Excellence programs. Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>log 2 4 ρ m . The Bombus impatiens dataset used in Section 3 below contains</figDesc><table>Copyedited by: TRJ 

MANUSCRIPT CATEGORY: APPLICATIONS NOTE 

[10:50 18/6/2012 Bioinformatics-bts297.tex] 
Page: 1938 1937–1938 

T.Conway et al. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 1. Comparison of assembly results for Gossamer (Go), SOAPdenovo (SO) and SGA (SG), when run on the GAGE datasets: Staphylococcus aureus (SA), 2.9 Mb; Rhodobacter sphaeroides (RS), 4.6 Mb, human chromosome 14 (HG), 88.3 Mb; and Bombus impatiens (BI), estimated 250 Mb. the number of sequences produced; N50, the N50 statistic calculated with respect to the genome size; E-size, the most likely size of the contig or scaffold containing some random base in the genome, [see (Salzberg et al., 2011) for detail]; Errs, the number of misjoins and for the contig value, also the number of indels &gt;5 bases; and N50C, the N50 calculated after splitting all contigs/scaffolds at error locations. The best result in each column, for each dataset, is indicated in bold.</figDesc><table>Data Tool Time (s) Mem (MB) 
Contigs 
Scaffolds 

Num 
N50 (kb) E-size (kb) Errs 
N50C (kb) Num 
N50 (kb) E-size (kb) Errs N50C (kb) 

SA 

Go 
197 
483 
135 
48.1 
73.0 
21 46.1 
31 
828 
612 
7 
828 
SO 
71 
704 
114 
271.5 
218 
48 56.3 
100 
331 
299 
4 
331 
SG 
2688 
1293 
1183 
4.0 
4.7 
11 
4.0 
536 
113 
150 
0 
113 

RS 

Go 
258 
531 
744 
12.2 
15.3 
19 12.0 
270 
132 
131 
2 
132 
SO 
94 
833 
210 
138.9 
161 
328 17.6 
174 
667 
478 
5 
343 
SG 
4100 
2089 
2695 
2.2 
3.2 
11 
2.2 
1739 
47.2 
46 
0 
42.5 

HG 

Go 
7156 
2721 
29 622 
4.6 
6.9 
1697 
4.3 
6932 
369 
681 
172 182 
SO 
1770 
8812 
41692 
2.2 
3.5 
4589 
2.2 
13 436 
402 
487 
254 
83 
SG 
− 
39372 
− 
– 
– 
– 
– 
– 
– 
– 
– 
– 

BI 
Go 
48 916 
7926 
51 518 
10.9 
17.2 
NA 
NA 
25 996 
240 
297 
NA 
NA 
SO 
21 664 
23730 
56557 
9.0 
13.0 
NA 
NA 
6013 1429 
1728 
NA 
NA 

The columns read as follows: Num, </table></figure>

			<note place="foot" n="1"> 119 868 977 different ρ-mers at k = 45. The theoretical minimum size for this dataset according to the above definition is about 8 GB. The bitmap we construct actually requires ∼9.2 GB of space, which is close to the minimum. In contrast, storing the ρ-mers themselves, using a straightforward 2 bitsper-base representation, would require almost 15.7 GB. Note that we have not considered the additional space required to store edge counts, which we also represent compactly. The figures given above represent the amount of space required to store all of the ρ-mers from the example dataset. Realistically, many of those will correspond to errors in the data. Gossamer provides multiple operations for removing spurious edges from the graph, both spectral and structural. The spectral error removal operation is the trimming of low-frequency edges. The structural error removal operations are the pruning of tips, and the elimination of bubbles, both based on the algorithms present in Velvet (Zerbino and Birney, 2008). Unlike the Euler family of assemblers, Gossamer does not attempt to correct errors and removes them from the graph. After these graph-cleaning passes, the resulting de Bruijn graph contains many fewer spurious edges, and the unbranched paths can be read off as preliminary contigs. Read pair information is utilized by aligning both ends of the pair to the de Bruijn graph to find pairs of &apos;anchors&apos; into parts of the graph judged to be most likely unique (i.e. copy-number one) in the underlying genome. For each pair of anchors with sufficient support, a search is performed to find a unique path that is consistent with the bounds defined by the distribution of insert sizes. Where such paths are found, an Eulerian super-path is constructed. In the case where a supporting path is not found, the alignment of the read pairs can be used to perform scaffolding, by inferring the relative orientation and displacement of contigs. 3 RESULTS We have evaluated Gossamer&apos;s performance on the datasets used in the GAGE (Genome Assembly Gold-Standard Evaluations) study (Salzberg et al., 2011). GAGE is a recent attempt to assess the capabilities of a collection of modern assemblers on a range of datasets, ranging from small bacterial genomes, to a human chromosome and an entire bumblebee genome. For comparison with Gossamer, we have rerun the most recent versions of SOAPdenovo (Li et al., 2010) and SGA (String Graph Assembler) (Simpson and © The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">De novo fragment assembly with short mate-paired reads: does the read length matter?</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="336" to="346" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Succinct data structures for assembling large genomes</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">C</forename>
				<surname>Conway</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">J</forename>
				<surname>Bromage</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="479" to="486" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">De novo bacterial genome sequencing: Millions of very short reads assembled on a desktop computer</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Hernandez</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="802" to="809" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">GAGE: a critical evaluation of genome assemblies and assembly algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of large genomes using compressed data structures</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="549" to="556" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<monogr>
		<title level="m" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Assembling millions of short dna sequences using ssake</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">L</forename>
				<surname>Warren</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="500" to="501" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Pebble and rock band: heuristic resolution of repeats and scaffolding in the velvet short-read de novo assembler</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS ONE</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page">8407</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>