
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:53+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Exploring single-sample SNP and INDEL calling with whole-genome de novo assembly</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName>
								<forename type="first">Heng</forename>
								<surname>Li</surname>
							</persName>
							<email>lh3/fermi Contact: hengli@broadinstitute.org</email>
							<affiliation key="aff0">
								<orgName type="department">Medical Population Genetics Program</orgName>
								<orgName type="institution">Broad Institute</orgName>
								<address>
									<addrLine>7 Cambridge Center</addrLine>
									<postCode>02142</postCode>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Exploring single-sample SNP and INDEL calling with whole-genome de novo assembly</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="issue">14</biblScope>
							<biblScope unit="page" from="1838" to="1844"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts280</idno>
					<note type="submission">Sequence analysis Advance Access publication May 7, 2012 Received on April 3, 2012; revised on May 2, 2012; accepted on May 3, 2012</note>
					<note>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [10:34 18/6/2012 Bioinformatics-bts280.tex] Page: 1838 1838–1844 Associate Editor: Michael Brudno</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Eugene Myers in his string graph paper suggested that in a string graph or equivalently a unitig graph, any path spells a valid assembly. As a string/unitig graph also encodes every valid assembly of reads, such a graph, provided that it can be constructed correctly, is in fact a lossless representation of reads. In principle, every analysis based on whole-genome shotgun sequencing (WGS) data, such as SNP and insertion/deletion (INDEL) calling, can also be achieved with unitigs. Results: To explore the feasibility of using de novo assembly in the context of resequencing, we developed a de novo assembler, fermi, that assembles Illumina short reads into unitigs while preserving most of information of the input reads. SNPs and INDELs can be called by mapping the unitigs against a reference genome. By applying the method on 35-fold human resequencing data, we showed that in comparison to the standard pipeline, our approach yields similar accuracy for SNP calling and better results for INDEL calling. It has higher sensitivity than other de novo assembly based methods for variant calling. Our work suggests that variant calling with de novo assembly can be a beneficial complement to the standard variant calling pipeline for whole-genome resequencing. In the methodological aspects, we propose FMD-index for forward– backward extension of DNA sequences, a fast algorithm for finding all super-maximal exact matches and one-pass construction of unitigs from an FMD-index.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The rapidly decreasing sequencing cost has enabled whole-genome shotgun (WGS) resequencing at an affordable price. Many software packages have been developed to call variants, including SNPs, short insertions and deletions (INDELs) and structural variations (SVs), from WGS data. At present, the standard approach to variant calling is to map raw sequence reads against a reference genome and then to detect differences from the reference. It is well established and has been proved to work from a single sample to thousands of samples (1000<ref type="bibr">Genomes Project Consortium, 2010</ref>). Nonetheless, a fundamental flaw in this mapping-based approach is that mapping algorithms ignore the correlation between sequence reads. They are unable to take full advantage of data and may produce inconsistent outputs which complicate variant calling. This flaw has gradually attracted the attention of various research groups who subsequently proposed several methods to alleviate the effect, including postalignment filtering (<ref type="bibr" target="#b31">Ossowski et al., 2008</ref>), iterative mapping (<ref type="bibr" target="#b24">Manske and Kwiatkowski, 2009</ref>), read realignment (<ref type="bibr" target="#b0">Albers et al., 2010;</ref><ref type="bibr" target="#b4">Depristo et al., 2011;</ref><ref type="bibr" target="#b11">Homer and Nelson, 2010;</ref><ref type="bibr" target="#b21">Li, 2011</ref>) and local assembly (<ref type="bibr" target="#b2">Carnevali et al., 2011</ref>). However, because these methods still rely on the initial mapping, it is difficult for them to identify and recover mismapped or unmapped reads due to highsequence divergence, long insertions, SVs, copy number changes or misassemblies of the reference genome. They have not solved the problem from the root. Another distinct approach to variant calling that fundamentally avoids the flaw of the mapping-based approach is to assemble sequence reads into contigs and to discover variants via assembly-toassemby alignment. It was probably more widely used in the era of capillary sequencing. The assembly based method became less used since 2008 due to the great difficulties in assembling 25 bp reads, but with longer paired-end reads and improved methodology, de novo assembly is reborn as the preferred choice for variant discovery between small genomes. For variant discovery between human genomes, however, the assembly based approach has not attracted much attention. Assembling a human genome is far more challenging than assembling a bacterial genome, firstly due to the sheer size of the genome, secondly to the rich repeats and thirdly due to the diploidy of the human genome. Many heuristics effective for assembling small genomes are not directly applicable to the human genome assembly. As a result, only a few de novo assemblers have been applied on human short-read data. Among them, ABySS (<ref type="bibr" target="#b36">Simpson et al., 2009</ref>), SOAPdenovo (<ref type="bibr" target="#b20">Li et al., 2010</ref>) and SGA (<ref type="bibr" target="#b35">Simpson and Durbin, 2012</ref>), as of now, do not explicitly output heterozygotes. Although in theory it is possible to recover heterozygotes from their intermediate output, it may be difficult in practice as the assemblers may not distinguish heterozygotes from sequencing errors. Cortex (<ref type="bibr" target="#b15">Iqbal et al., 2012</ref>) is specifically designed for retaining heterozygous variants in an assembly, but it may be missing heterozygotes. ALLPATHS-LG (<ref type="bibr" target="#b10">Gnerre et al., 2011</ref>) also paid particular attention to keep heterozygotes, but it still has a relatively low sensitivity. In addition, ALLPATHS-LG only works with reads from libraries with distinct insert size distributions and prefers read pairs with mean insert size below three times of the read length, whereas many resequencing projects do not meet these requirements and thus ALLPATHS-LG may not be applied or work to the best performance. Even if we also include de novo assemblers developed for capillary sequence reads, the version of the Celera assembler used for assembling the HuRef genome (<ref type="bibr" target="#b18">Levy et al., 2007</ref>) is the only one that retains heterozygotes while capable of assembling a mammalian genome. At last, one may think to map sequence reads</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Variant calling from de novo assembly</head><p>back to the assembled contigs to recover heterozygous events, but this procedure will be affected by the same flaw of read mapping. To the best of our knowledge, no existing de novo assemblers are able to achieve the sensitivity of the standard mapping-based approach for a diploid mammalian genome. In this article, we will show that the assembly based variant calling can achieve an SNP accuracy close to the standard mapping approach and have particular strength in INDEL calling, confirming previous studies (<ref type="bibr" target="#b15">Iqbal et al., 2012</ref>). In addition, the de novo assembly algorithm, fermi, developed for this practice is also a capable assembler for human assembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>The methods section is organized as follows. We first review the history of de novo assembly in the theoretical aspects, which leads to the rationale behind fermi: to use unitigs as a lossless representation of reads. We then summarize the notations used in the article and introduce bidirectional FMindex for DNA sequences. We will present several algorithms for assembling using the bidirectional FM-index. The key algorithm is based on previous works (<ref type="bibr" target="#b34">Simpson and Durbin, 2010</ref>), but we need to adapt it to our new index. We also remove the recursion in the original algorithm. Finally we will discuss practical concerns in implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Theoretical background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">A history of the OLC paradigm</head><p>Computer assisted sequence assembly can be dated back to the late 1970s (<ref type="bibr" target="#b9">Gingeras et al., 1979;</ref><ref type="bibr" target="#b38">Staden, 1979</ref>).<ref type="bibr">In 1984, Peltola et al. first</ref>formulated the DNA assembling problem as finding the shortest string (the assembly) such that each sequence read can be mapped to the assembly within a required error rate. To solve the problem, they proposed a three-step procedure, which is essentially the overlap-layout-consensus (OLC) approach.<ref type="bibr" target="#b27">Myers (1995)</ref>pointed out that reducing DNA assembly to a shortest string problem is flawed in the presence of repeat. He further proposed the concept of overlap graph, where a vertex corresponds to a read and a bidirectional edge to an overlap. Naively, the DNA assembling problem can be cast as finding a path in the overlap graph such that each vertex/read is visited exactly once (though edge/overlap caused by repeats are not required to be traversed), equivalent to a Hamilton path problem which is known to be NPcomplete. This has led many to believe that the OLC approach is theoretically crippled. However, it is worth pointing out that although the assembly problem can be reduced to a Hamilton path problem, it can be reduced to other problems as well and in practice almost no assemblers try to solve a Hamilton path problem. We note that a fundamental difference between a generic graph and an overlap graph is the latter can be transitively reduced while retaining the read relationship. More formally, if v 1 → v 2 , v 2 → v 3 and v 1 → v 3 are all present, edge v 1 → v 3 is said to be reducible. When we removed all the contained reads and reducible edges, a procedure called transitive reduction, the resulting graph is still a loyal representation of the overlap graph (<ref type="bibr" target="#b27">Myers, 1995</ref>), but the path corresponding to the assembly is not a Hamilton path any more because reads from repetitive regions need to be traversed multiple times. In a transitively reduced graph, if there exists v 1 → v 2 with the out-degree of v 1 and in-degree of v 2 both equal to 1, we are able to merge v 1 and v 2 into one vertex without altering the topology of the graph. After we performed all possible merges, we get a unitig graph in which each vertex corresponds to a unitig, representing a maximal linear sequence that can be resolved by reads. Multiple copies of a repeat may be collapsed to a single unitig. The concept of unitig helps to greatly simplify an assembly graph. It has played a central role in the Celera assembler (<ref type="bibr" target="#b28">Myers et al., 2000</ref>). Finding the optimal tour in a unitig graph is still NP-hard (<ref type="bibr" target="#b25">Medvedev et al., 2007</ref>), but such a formulation may not be useful in practice as we can rarely assemble the entire genome into one string. A more practical solution is to compute a traversal count for each edge by solving a minimum cost network flow problem (<ref type="bibr" target="#b29">Myers, 2005</ref>) and to drop edges with zero count as false overlaps. In the resulting graph, each unambiguous path can be considered to spell a contig. Computing traversal counts in a transitively reduced graph can be conducted in small subgraphs separated by some unambiguous edges. The overall time complexity is not much worse than linear—the worst case almost never happens globally. However, deriving an overlap graph takes O(N 2 ) time, where N is the number of reads, and transitive reduction takes at least O(E) time, where E is the number of edges which is usually much larger than N. This still makes an OLC-based approach less favorable in short-read assembly where N can be of the order of 10 9. A breakthrough achieved by Simpson and Durbin (2010) finally solved this last remaining problem at least when we only consider exact overlaps. These authors developed an O(N ) algorithm to find all the irreducible edges, effectively replacing the overlapping and transitive reduction phases. In summary, in the OLC paradigm, contig sequences can be constructed in a time roughly linear in the total length of reads, though deriving a singleassembled sequence is NP-hard in theory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">De Bruijn graph and read coherence</head><p>The de Bruijn graph is an alternative graph representation of sequence reads (<ref type="bibr" target="#b13">Idury and Waterman, 1995</ref>). It can be trivially constructed with a simple linear-time algorithm and finding the optimal tour has polynomial-time solutions. These make the de Bruijn graph approach very attractive for assembling many short reads. However, de Bruijn is 'lossy'. From a theoretical point view, a de Bruijn graph is equivalent to an overlap graph built by splitting a long read into overlap k-mers and requiring (k −1)-mer exact overlaps between nonredundant k-mers. Such a graph does not have transitive edges. Because long reads all effectively work as k-bp reads in a de Bruijn graph, longrange information is lost. As a result, a path in the graph may be invalidated by reads. In contrast, in a unitig graph or equivalently a string graph each path models a valid assembly from input reads.<ref type="bibr" target="#b29">Myers (2005)</ref>called this property of path consistency as read coherence. Losing long-range information in reads, a de Bruijn graph by itself has reduced power to resolve short repeats. This flaw is usually amended by solving a Eulerian superpath problem (<ref type="bibr" target="#b33">Pevzner et al., 2001</ref>) whereby we map reads back to the graph and bisect repeats shorter than the reads, a procedure some also called as read threading. Many de Buijn graph-based assemblers essentially take this strategy (<ref type="bibr" target="#b3">Chaisson et al., 2009;</ref><ref type="bibr" target="#b20">Li et al., 2010;</ref><ref type="bibr" target="#b39">Zerbino et al., 2009</ref>), though they may use different terminologies. With read threading, it is possible to transform a de Bruijn graph to a coherent graph, but finding the optimal solution is known to be NP-hard (<ref type="bibr" target="#b25">Medvedev et al., 2007</ref>) and may be complex to implement given rich repeat structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">Concluding remark</head><p>We noted that we only focused on the theoretical aspects of de novo assembly. In practice, many assemblers derived the final assembly by applying heuristics on the simplified graph instead of solving a network flow problem or a Eulerian problem. Furthermore, correcting errors, utilizing read pairs and controlling memory usage all pose challenges to large-scale de novo assembly. Many practical problems are not solved perfectly. De novo assembly is still a field under active development.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Rationale</head><p>Being coherent, a perfectly constructed unitig graph annotated with perunitig read counts in fact encapsulates all the information of reads and encodes no information invalidated by reads. In this sense, any unitig-based analysis has an equivalent read-based analysis, and vice versa. This article just uses this property to explore the applications for which we usually rely on reads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H.Li</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Strings and FM-index</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Strings with multiple sentinels Let</head><p>={$,A,C,G,T,N} be the alphabet of DNA sequences with a predefined lexicographical order $ &lt; A &lt; C &lt; G &lt; T &lt; N, where 'N' represents an ambiguous base and '$' is a sentinel that marks the end of a string. An element in is called a symbol and a sequence of symbols is called a string. Given a string T , let |T | be the length of the string, T<ref type="bibr">[i]</ref>, i = 0,...,|T |−1, be the i-th symbol in the string, T [i,j], 0 ≤ i ≤ j &lt; |T |, be a substring and T i = T [i,|T |−1] be a suffix of T (<ref type="figure" target="#tab_1">Table 1</ref>). Following the definition by Siren (2009), we define a string terminated with '$' as a text. A text may have multiple sentinels. In a text T , if T [i]=$ and T<ref type="bibr">[j]</ref>=$, we mandate T [i] &lt; T [j] if and only if i &lt; j. Thus when we compare two suffixes of T , we do not need to compare beyond a sentinel because each sentinel has a different lexicographical rank. For two strings P and W , let P @BULLETW be their string concatenation. We may sometimes write P @BULLETW as PW if it is unambiguous in the context. Given an ordered set of texts, we call their ordered string concatenation as a collection, which is also a text. For example, suppose we have two reads. The first is ACG and the second is GTG. The collection of the two reads is T = ACG$GTG$. Suffix T 2 &lt; T 6 because the first sentinel is lexicographically smaller than the second. For convenience, we assign an integer from 0 to 5 to '$', 'A', 'C', 'G', 'T' and 'N', respectively. We may use both the integer and the letter representations throughout the article. In addition, given a symbol a, we define a as the Watson–Crick complement of a. We regard the complement of '$' and 'N' is identical to itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">FM-index The suffix array S</head><p>of text T is a permutation of integers between 0 and |T |−1, where S(i), 0 ≤ i &lt; |T |, is the position of the i-th smallest suffix of T. Given a string P, the suffix array interval I l (P),I u (P)] of P in T is defined as I l (P) = min{k : P is the prefix of T S(k) } I u (P) = max{k : P is the prefix of</p><formula>T S(k) }</formula><p>For convenience, we also define I s (P) = I u (P)−I l (P)+1 as the size of the interval. The Burrows–Wheeler Transform (<ref type="bibr" target="#b1">Burrows and Wheeler, 1994</ref>), or BWT, of T is a permutation of symbols in T. The BWT string B is computed as B<ref type="bibr">[i]</ref>=T [S(i)−1] for S(i) &gt; 0 and B<ref type="bibr">[i]</ref>=$ otherwise. Given a text T , also define the accumulative count array C(a) as the number of symbols in T that are lexicographically smaller than a, and the occurrence array O(a,i) as the occurrence of symbols a in B<ref type="bibr">[0,i]</ref>. FM-index (<ref type="bibr" target="#b7">Ferragina and Manzini, 2000</ref>) is a compressed representation of the BWT B, the occurrence array O(a,i) and the suffix array S(i). The keyT String: T = a 0 a 1 ...a n−1 with a n−1 = $ |T | Length of T including sentinels: |T |=n T<ref type="bibr">[i]</ref>The i-th symbol in string T :</p><formula>T [i]=a i T [i,j] Substring: T [i,j]=a i ...a j T i Suffix: T i = T [i,n−1] S</formula><formula>I l (aP) = C(a)+O(a,I l (P)−1) (1) I u (aP) = C(a)+O(a,I u (P))−1 (2)</formula><p>and I l (aP) ≤ I u (aP) if and only if aP is a substring of T. We note that these two equations are different from the ones in our previous paper (<ref type="bibr" target="#b19">Li and Durbin, 2009</ref>) in that C(a) and O(a,i) defined here include the sentinels, but the two arrays in the previous paper exclude them. Given a collection T = Q 0 Q 1 ...Q n−1 , we can retrieve sequence Q i in linear time with Algorithm 1 (<ref type="bibr">Mäkinen et al., 2009</ref>). The second return value is the rank of Q i which equals |{Q j : Q j &lt; Q i }|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">FMD-index</head><p>Given DNA texts R 0 ,...,R n−1 , define</p><formula>T = R 0 R 0 R 1 R 1 .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>..R n−1 R n−1 as the bidirectional collection</head><p>of the texts. We call the FM-index of T as the FMD-index of R 0 ,...,R n−1 and define the bi-interval of a string P as</p><formula>[I l (P),I l (P),I s (P)]</formula><p>. We will show how to compute the bi-interval of aP and Pa when we know the bi-interval of P. We note that when we know the bi-interval of P, I l (aP) and I s (aP) can be readily computed with Equation (1).</p><formula>[I l (aP),I u (aP)</formula><p>] is a sub-interval of</p><formula>[I l (P),I u (P)</formula><p>] because P is a prefix of aP = P @BULLETa. Due to the innate symmetry of T , I s (cP) = I s (cP) for all c ∈ with c I s (cP) = I s (P) = I s (P). We can compute I s (cP) for all c ∈ with Equation (1), use these interval sizes to divide</p><formula>[I l (P),I u (P)] and finally derive [I l (aP),I u (aP)]</formula><p>. This completes the computation of the bi-interval of aP (Algorithm 2). Furthermore, when we backward extend P, we actually forward extend P. Conversely, backward extension of P yields forward extension of P (<ref type="bibr">Algorithm 3</ref>). An FMD-index is bidirectional. In comparison to the bidirectional BWT (<ref type="bibr" target="#b16">Lam et al., 2009</ref>) which uses two FM-indices, the FMD-index builds both forward and reverse strand DNA sequences in one index. Although the FMD-index is not applicable to generic texts, it is conceptually more consistent with double-strand DNA and improves the speed of exact matching as we only need to search against one index. For example, BWA-SW (<ref type="bibr" target="#b20">Li and Durbin, 2010</ref>) gets a 80% speedup when we adopt the FMD-index as the data structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Unitig construction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1">Labeling reads and overlaps</head><p>Given a bidirectional collection</p><formula>T = R 0 R 0 ...R n−1 R n−1</formula><p>, fermi labels the i-th input read R i with an ordered integer pair<ref type="bibr">[k,l]</ref>, where k is the rank of R i and l the rank of R i. The pair<ref type="bibr">[k,l]</ref>can be computed by GetSeq(2i) and GetSeq(2i +1), respectively. Obviously, if read R i is labeled by<ref type="bibr">[k,l]</ref>, R i should be labeled by<ref type="bibr">[l,k]</ref>, with the two integer swapped. For two reads labeled by<ref type="bibr">[k,l]</ref>and<ref type="bibr">[k ,l ]</ref>, if the tail (3 end) of read<ref type="bibr">[k,l]</ref>overlaps the head (5 end) of<ref type="bibr">[k ,l ]</ref>, we use an unordered integer pair l,k to label the overlap. Such is a tail-to-head overlap. Similarly, we usel ,k for a head-to-tail overlap, l,l for tail-to-tail and k,k for a headto-head overlap. The four types of overlaps correspond to the four types of bidirectional edges in the bidirectional overlap graph (<ref type="bibr" target="#b27">Myers, 1995</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.2">Finding irreducible overlaps</head><p>Finding irreducible overlaps plays a central role in fermi as well as in SGA. Given its importance, we present a restructured version of this algorithm (SD10; Simpson and Durbin 2010) using our notations (Algorithm 4). In Algorithm 4, Line 1 computes the bi-interval of a single symbol. The loop at Line 2 uses backward extensions to find all the reads overlapping with the input string P. The loop at Line 3 uses forward extensions base by base to exclude reducible overlaps found at the previous step. W is this loop keeps the common substring of reads overlapping P extended from the 3 end of P. If in an iteration we find the sentinel of a read R (Line 5), then all the reads sharing the same W with R must overlap with both R and P and therefore their overlaps with P are reducible. In this case, no further forward extensions are necessary (Lines 4 and 6). Similar to the original algorithm, Algorithm 4 requires that there are no contained reads. Fermi actually implements a modified version that detects reads containment on the fly, but we think the algorithm is a little overcomplicated. It is probably easier to filter contained reads first and then run Algorithm 4, as SGA does.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.3">Unitig construction</head><p>Unitig construction is a process of unambiguous merge of overlapped reads. If<ref type="bibr">[k,l]</ref>and<ref type="bibr">[k ,l ]</ref>have an irreducible overlap l,k and can be unambiguously merged, we label the merged sequence with<ref type="bibr">[k,l ]</ref>; the similar can be applied to other three types of overlaps. With this simple labeling procedure, we are able to fully keep track of the graph topology during the unitig construction and without staging the graph in RAM. This procedure can also be easily multi-threaded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Finding the SMEMs</head><p>An FMD-index can be used to find supermaximal exact matches (SMEMs) between a reference and a query sequence. Formally, a maximal exact match (MEM) is a an exact match that cannot be extended in either direction of</p><formula>4 [k ,l ,s ]←ForwardExt([k,l,s],0); if s = 0 then 5 Finished ← Finished∪{W }; I ← I ∪{[k ,l ,s ]}; continue; 6 for a ← 1 to 5 do [k ,l ,s ]←ForwardExt([k,l,s],a); if s = 0 and [k ,l ,s ]</formula><p>is not in Curr then Append (<ref type="bibr">[k ,l ,s ]</ref>,Wa) to Curr;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Swap Curr and Prev return IrrOvlp</head><p>the match. An SMEM is a MEM that is not contained in other MEMs on the query sequence. Fermi uses SMEMs to map reads back to the unitigs. Algorithm 5 describes the details. Basically, we use forward–backward extension to extend an exact match and detect the boundary of a maximal match by tracking the change of interval sizes. Fermi implements a variant of Algorithm 5. It finds full-length read matches and can optionally exclude matches identical to the query sequence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Other implementation details</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7.1">Constructing FM-index</head><p>To compute suffix arrays for strings with multiple sentinels, we modified an optimized implementation of the SA-IS algorithm (<ref type="bibr" target="#b30">Nong et al., 2011</ref>) by Yuta Mori. We used the established algorithm to merge BWTs of subsets of reads (<ref type="bibr" target="#b8">Ferragina et al., 2010;</ref><ref type="bibr" target="#b12">Hon et al., 2007;</ref><ref type="bibr" target="#b37">Siren, 2009</ref>). The BWT string is run-length encoded with the length in the delta encoding (<ref type="bibr" target="#b6">Elias, 1975</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7.2">Error correction</head><p>Fermi corrects potential sequencing errors using an algorithm similar to solving the spectrum alignment problem (<ref type="bibr" target="#b33">Pevzner et al., 2001</ref>), correcting bases in underrepresented k-mers. It also shares similarity to HiTEC (<ref type="bibr" target="#b14">Ilie et al., 2011</ref>). Nonetheless, the fermi's algorithm differs in that it is quality aware and does not rely on a user defined threshold on the k-mer occurrences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H.Li</head><p>Algorithm 5: Finding SMEMs Input: String P and start position i 0 ; P<ref type="bibr">[−1]</ref>=0 Output: Set of bi-intervals of SMEMs overlapping i 0 Function SuperMEM1(P,i 0 ) begin Initialize Curr, Prev and Match as empty arrays;</p><formula>[k,l,s]←[C(P[i 0 ]),C(P[i 0 ]),C(P[i 0 ]+1)−C(P[i 0 ])]; for i ← i 0 +1 to |P| do if i =|P| then Append [k,l,s] to Curr else [k ,l ,s ]←ForwardExt([k,l,s],P[i]); if s = s then Append [k,l,s] to Curr if s = 0 then break; [k,l,s]←[k ,l ,s ]</formula><p>Swap array Curr and Prev;</p><formula>i ←|P|; for i ← i 0 −1 to −1 do Reset Curr to empty; s ←−1; for [k,l,s] in Prev do [k ,l ,s ]←BackwardExt([k,l,s],P[i]); if s = 0 or i =−1 then if Curr is empty and i +1 &lt; i +1 then i ← i; Append [k,l,s] to Match if s = 0 and s = s then s ← s ; Append [k,l,s] to Curr</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>if Curr is empty then break Swap Curr and Prev; return Match</head><p>Fermi corrects errors in two phases. In the first phase, it collects all 23 mer occurring 3 or more times using a top-down traversal over the trie represented by the FMD-index. For each such 23 mer, fermi counts the occurrences of the next (i.e. the 24-th) base and stores the information in a hash table with the 23 mer being the key. In the second phase, fermi processes each read by using the 23 mer hash table to correct errors by minimizing a heuristic cost function of base quality and the occurrences of the 24-th base. Roughly speaking, fermi tries to correct a low-quality base if by looking up its 23 mer prefix we know the base is different from an overwhelmingly frequent 24-th base. This algorithm can be adapted to correct INDEL sequencing errors in principle, but this has not been done. More works are needed to perform minimization efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7.3">Simplifying complex bubbles</head><p>A bubble is a directed acyclic subgraph with a single source and a single sink having at least two paths between the source and the sink. A closed bubble is a bubble with no incomming edges from or outgoing edges to other parts of the entire graph, except at the source and the sink vertices. A closed bubble is simple if there are exactly two paths between the source and the sink; otherwise it is complex. In de novo assembly, a bubble is frequently caused by sequencing errors or heterozygotes. Most short-read assemblers uses a modified Dijkstra's algorithm to pop bubbles progressively. Such an algorithm works fine for haploid genomes, but it is not straightforward to distinguish heterozygotes from errors when the bubble is complex. Fermi uses a different algorithm. It effectively performs topological sorting from the end of a vertex while keeping track of the top two paths containing most reads. A bubble is detected when every path ends at a single vertex. It then drops vertices not on the top two paths and thus turns a complex bubble to a simple one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7.4">Using the paired-end information</head><p>Given paired-end reads with short-insert sizes, fermi maps reads back to the unitigs with Algorithm 5. If two unitigs are linked by at least five read pairs, fermi will locally assemble the ends of unitigs together with unpaired reads pointing to the gap under a relax setting. Fermi tries to align the ends of unitigs using the Smith–Waterman algorithm, which may reveal imperfect overlaps caused by sequencing errors or heterozygotes. Fermi also uses paired-end reads to break contigs at regions without bridging read pairs. This helps to reduce misassemblies during the unitig construction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>We evaluated fermi on 101 bp paired-end reads from NA12878 (<ref type="bibr" target="#b4">Depristo et al., 2011</ref>). The total coverage of the original data is ∼70-fold, but we only used half of them. We assembled the 35-fold reads with fermi on a machine with 12 CPUs and 96 GB memory in ∼5 days. The peak memory usage is 92 GB. We obtained unitigs of N50 1022 bp, totaling 3.83 Gb. After collapsing most heterozygotes and closing gaps with paired-end reads, we got longer contigs (<ref type="figure" target="#tab_4">Table 4</ref>). Unitigs are short and redundant mainly because they break at heterozygotes. For SNP and INDEL calling, we aligned unitigs to the reference genome using BWA-SW (<ref type="bibr" target="#b20">Li and Durbin, 2010</ref>) with command line options '-b9-q16-r1-w500'. We called SNPs with the SAMtools caller and called INDELs by directly counting INDELs from the pileup output. We did not run a standard INDEL caller as short-read INDEL callers do not work well with long contig sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Performance on de novo assembly</head><p>We obtained the HuRef capillary read assembly (<ref type="bibr" target="#b18">Levy et al., 2007</ref>) and the ALLPATHS-LG NA12878 contigs (AC:AEKP01000000) from NCBI, the SGA scaffolds from http://bit.ly/jts12878 (<ref type="bibr" target="#b35">Simpson and Durbin, 2012</ref>) and the ABySS assembly provided by Shaun Jackman (personal communication). For both SGA and ABySS scaffolds, we split at any ambiguous bases to get contigs; for the HuRef assembly, we split at contiguous 'N' longer than 20 bp. The ABySS, fermi and SGA assemblies are derived from essentially the same input reads. ALLPATH-LG uses a superset of reads at 100-fold coverage, including reads from multiple long-insert libraries. From Table 2, we can see that the HuRef assembly has much better contiguity than short-read assemblies. It appears to yield more alignment break points, some of which may be caused by true SVs not easily detectable with short reads. The quality of short-read assemblies varies in terms of contiguity, misassembly rate and redundancy between contigs, but overall, they are largely comparable to each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Performance on SNP and INDEL calling</head><p>One of the key motivations of fermi is to explore the power of de novo assembly in calling short variants. We collected several SNP and INDEL call sets (<ref type="figure" target="#tab_3">Table 3</ref>) and compared the performance of fermi (Tables 4 and 5).Contigs over 150 bp in length are aligned to the human reference genome GRCh37 with BWA-SW using option '-b33-q50-r17'. A type-1 break point is detected if a contig is split during alignment and mapped to two distict locations, and at each location the alignment is longer than 500 bp and the mapping quality is no less than 10. Type-2 break points exclude type-1 break points which can be patched with gaps no longer than 500 bp.Ts/tv is the transition-to-transversion ratio of SNPs. DN50 is calculated as follows. The reference genome is masked according to the align-ability mask (http://bit.ly/snpable) and segmented into intervals at heterozygous SNPs. DN50 is computed such as 50% of unique positions in the genome are in intervals longer than DN50. DN2 is calculated similarly and D2/DN50 is the ratio of DN2 and DN50. DN50 measures the sensitivity; the smaller the better. DN2/DN50 measures the precision of heterozygous SNPs; the higher the better. For SNP calling (<ref type="figure" target="#tab_4">Table 4</ref>), fermi misses 3% of SNPs called in SS, but finds more additional ones. Manual examination reveals that the additional calls are mainly caused by two factors. Firstly, in the single-end mode, BWA-SW is very conservative. It may consistently give a correct alignment a low-mapping quality which are all downweighted by samtools. Fermi is able to assemble such reads into longer sequences which increase the power of BWA-SW.INDELs that start within a homopolymer run longer than 6 bp are excluded in all call sets. An INDEL in call set R (indexed by row) is said to be found in call set C (indexed by column) if there exists an INDEL in C such that the left-aligned starting positions of the two INDELs are within 20 bp from each other. An INDEL in R is considered to be found in 'ALL' if it is found in one of the other INDEL sets in the table, plus the AC call set. In the table, a number on the diagonal equals |R|, the number of INDEL calls in the call set. The fraction equals |{g ∈ R : g is found in C}|/|R|.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Variant calling from de novo assembly</head><p>Secondly, in the fermi alignment, some regions may be mapped with a high-mismatching rate. These may be due to small-scale misassemblies in fermi unitigs or in the reference assembly, or copynumber variations. It is possible that these clustered SNPs contain more errors. Such errors may lead to reduced ts/tv, but tend not to break long homozygous blocks due to very recent coalescences. That is why FC has a good DN2/DN50 ratio, which measures how often false heterozygotes arise from a long homozygous block.<ref type="figure" target="#tab_5">Table 5</ref>shows the comparison between different INDEL call sets. We excluded INDELs around long homopolymer runs in all call sets because INDEL sequencing errors tend to occur around long homopolymer runs and their error profile is still unclear (the 1000 Genomes Project Analysis group, personal communication). In addition, we have excluded the SS INDEL call set which is nearly contained in BS due to the use of the same INDEL caller. For the call sets in<ref type="figure" target="#tab_5">Table 5</ref>, MD and CG are relatively small due to the use of very short reads. CV uses 26X 100 bp reads. It is a small call set due to the high-false negative rate of the calling method (<ref type="bibr" target="#b15">Iqbal et al., 2012</ref>). The fermi call set FC is slightly smaller than BS, but it has larger overlap with other call sets than BS, and more FC calls are confirmed by others. One explanation to the lower overlapping ratio between BS and ALL is that BS is the only call set that uses 101 bp paired-end information, which gives it higher power for INDELs not detectable with single-end or very short reads. Nonetheless, purely based on<ref type="figure" target="#tab_5">Table 5</ref>, fermi appears to have higher overall accuracy. Even with all short-read call sets combined, as many as 14% of double-hit INDELs called by<ref type="bibr" target="#b26">Mills et al. (2011)</ref>are missed. We manually checked 30 missing INDELs in an alignment viewer. For half of the cases, the short-read alignment and fermi alignment strongly suggest no variations, and for all these cases, the HuRef sequences are identical to GRCh37. In addition, there are a few cases called from regions under clear copy-number changes. In all, we believe INDELs called by<ref type="bibr" target="#b26">Mills et al. (2011)</ref>only may have higherror rate. With short reads, we can recover most of short INDELs found by capillary sequencing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSIONS</head><p>In this article, we derived FMD-index by storing both forward and reverse complement DNA sequences in FM-index. This simple modification enables faster forward–backward search than</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H.Li</head><p>bi-directional BWT (<ref type="bibr" target="#b16">Lam et al., 2009</ref>) and makes FMD-index a more natural representation of DNA sequences. Based on FMD-index, we developed a new de novo assembler, fermi, which achieves similar quality to other mainstream assemblers. We demonstrated that it is possible to call SNPs and short INDELs by aligning assembled unitigs to the reference genome. This approach has similar SNP accuracy to the standard mappingbased SNP calling and arguably outperforms the existing methods on INDEL calling in terms of both sensitivity and precision. Assembly based variant calling is a practical and beneficial complement to mapping-based calling. In the course of evaluating INDEL accuracy, we found that outside long homopolymer regions, INDEL call sets do not often contain false positives, but they may have high-false negative rate, which leads to the apparent small overlap between call sets (<ref type="bibr" target="#b17">Lam et al., 2012</ref>). As a theoretical remark, we note that with read counts kept, unitigs are a lossless but reduced representation of sequence reads. They are 'reduced' in that individual reads are lost; they are 'lossless' in that all the information in reads, such as small variants, copy numbers and structural changes are fully preserved in unitigs, as long as they are constructed correctly. For single-end reads, it is theoretically possible to 'compress' reads to unitigs, which are largely nonredundant and much smaller in size. Accurately and efficiently constructing unitigs might provide an interesting alternative to data storage and downstream analyses in future, though practical challenges, such as the high-computational cost and the lack of accuracy of unitigs, remain at present.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [10:34 18/6/2012 Bioinformatics-bts280.tex] Page: 1840 1838–1844</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [10:34 18/6/2012 Bioinformatics-bts280.tex] Page: 1842 1838–1844</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [10:34 18/6/2012 Bioinformatics-bts280.tex] Page: 1843 1838–1844</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [10:34 18/6/2012 Bioinformatics-bts280.tex] Page: 1844 1838–1844</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 1. Notations Symbol Description</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Suffix array; S(i) is the position of the i-th smallest suffix B BWT: B[i]=T [S(i)−1] if S(i) &gt; 0 or B[i]=$ otherwise C(a) Accumul. count array: C(a) =|{0 ≤ i ≤ n−1 : T [i] &lt; a}| O(a,i) Occurrence array: O(a,i) =|{0 ≤ j ≤ i : B[j]=a}| P @BULLETW String concatenation of string P and W Pa String concatenation of string P and symbol a: Pa = P @BULLETa P Watson–Crick reverse complement of DNA string P property of FM-index is</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Algorithm 1: Sequence retrieval Input: Sequence index i ≥ 0; B, O and C defined in the text Output: Sequence P and k, the rank of P Function GetSeq(i) begin k ← i; P ← empty string; while true do a ← B[k]; k ← C(a)+O(a,k)−1; if a = 0 then return (P,k) P ← aP</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>de novo assembly Algorithm 2: Backward extension Input: Bi-interval [k,l,s] of string W and a symbol a Output: Bi-interval of string aW Function BackwardExt([k,l,s],a) begin for b ← 0 to 5 do k b ← C(b)+O(b,k −1) s b ← O(b,k +s−1)−O(b,k −1) l 0 ← l; l 4 ← l 0 +s 0 ; for b ← 3 to 1 do l b ← l b+1 +s b+1 l 5 ← l 1 +s 1 ; return [k a ,l a ,s a ] Algorithm 3: Forward extension Input: Bi-interval [k,l,s] of string W and a symbol a Output: Bi-interval of string Wa Function</figDesc><table>Copyedited by: TRJ 

MANUSCRIPT CATEGORY: ORIGINAL PAPER 

[10:34 18/6/2012 Bioinformatics-bts280.tex] 
Page: 1841 1838–1844 

Variant calling from ForwardExt([k,l,s],a) begin 
[l ,k ,s ]←BackwardExt([l,k,s],a); 
return [k ,l ,s ] 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>Algorithm 4: Finding irreducible overlaps Input: Read P and the minimum overlap length x Output: Set of bi-intervals of reads having irreducible overlaps with the 3 end of P Function</figDesc><table>IrrOverlap(P,x) begin 
Initialize Curr and Prev as empty arrays; 
a ← P[|P|−1]; 
[k,l,s]←[C(a),C(a),C(a +1)−C(a)]; 

1 

for i ←|P|−2 to 0 do 

2 

if |P|−i −1 ≥ x then 
[k ,l ,s ]←BackwardExt([k,l,s],0); 
if s = 0 then 
Append ([k ,l ,s ],,) to Curr; 

[k,l,s]←BackwardExt([k,l,s],P[i]); 

Reverse array Curr, and swap Curr and Prev; 
Finished =∅; 
I =∅; 
while Prev is not empty do 

3 

Reset Curr to empty; 
for ([k,l,s],W ) in Prev do 
if W ∈ Finished then 
continue; 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Table 2.</figDesc><table>Statistics on human whole-genome assemblies 

ABySS AllPaths-LG Fermi SGA 
HuRef 

Aligned contig bp 
2.73 G 2.62 G 
2.82 G 2.74 G 2.88 G 
Aligned N50 
9.0 k 
22.6 k 
15.6 k 9.8 k 
81.4 k 
Covered ref. bp 
2.69 G 2.59 G 
2.74 G 2.70 G 2.78 G 
No. of type-1 breaks 5856 
13 738 
5704 
6049 
16 318 
No. of type-2 breaks 1617 
3823 
1120 
1735 
6626 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="true"><figDesc>Table 3. Evaluated SNP and INDEL call sets</figDesc><table>Label Data 
Assembler 
Mapper 
Caller 

AC 
96X Illumina PE a 
AllPaths-LG BWA-SW b 
SAMtools c 
BS 
70X Illumina PE 
BWA d 
SAMtools 
CG 
Complete Genom. 
cgatools2 e 
cgatools2 
CV 
26X Illumina SE f 
Cortex 
Cortex-var 
FC 
35X Illumina SE f 
Fermi 
BWA-SW b 
SAMtools c 
MD 
60X multiple 
MAQ 
1000 g pilot g 
MI 
Capillary reads h 
SS 
35X Illumina SE f 
BWA-SW 
SAMtools 

a AS uses reads from Illumina jumping and fosmid libraries. 
b BWA-SW is invoked with 'bwa bwasw -b9 -q16 -r1 -w500'. 
c INDELs are called from pileup without using the SAMtools caller. 
d Realigned by GATK (Depristo et al., 2011) also around known INDELs. 
e By Complete Genomics (Drmanac et al., 2010); only 'VQHIGH' calls retained. 
f CV, FC and SS do not use the pairing information in calling. 
g 1000 Genomes Project pilot calls; generated from Dindel and multiple SNP callers. 
h INDEL calls by Mills et al. (2011). 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><figDesc>Table 4.</figDesc><table>Statistics of SNP call sets 

FC 
CV 
SS 
BS 
CG 
MD 

No. of SNPs (M) 
3.37 
2.20 
3.24 
3.50 
3.34 
2.69 
No. of hets (M) 
1.97 
1.04 
1.94 
2.11 
2.04 
1.65 
Ts/tv 
2.04 
2.03 
2.08 
2.11 
2.12 
2.06 
DN50 (bp) 
3593 
6662 
3523 
3392 
3447 
3992 
DN2/DN50 
22.3 
20.8 
23.4 
22.7 
22.3 
22.9 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="true"><figDesc>Table 5. Fraction of INDELs found in other call sets</figDesc><table>MD 
CG 
BS 
CV 
FC 
MI 
ALL 

MD 240 424 
0.819 
0.937 
0.678 
0.947 0.054 0.977 
CG 
0.752 264 696 
0.915 
0.629 
0.924 0.052 0.965 
BS 
0.564 
0.597 404 646 
0.498 
0.844 0.044 0.906 
CV 
0.708 
0.726 
0.882 251 769 
0.902 0.052 0.923 
FC 
0.588 
0.624 
0.873 
0.522 393 841 0.045 0.952 
MI 
0.593 
0.618 
0.790 
0.527 
0.804 23 216 0.864 

</table></figure>

			<note place="foot">© The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We are grateful to David Reich, Evan Eichler and Peter Sudmant for providing additional data and computing resources for evaluating fermi, to David Altshuler and the GSA group at Broad for the helpful discussions and to Richard Durbin and Jared Simpson for their comments on the initial draft of the manuscript. We also thank Shaun Jackman for providing the ABySS assembly and Michael Brudno for his insight into the algorithm time complexity.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Dindel: accurate indel calls from short-read data</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">A</forename>
				<surname>Albers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="961" to="973" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">A block-sorting lossless data compression algorithm</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Burrows</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Wheeler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital Equipment Corporation</title>
		<meeting><address><addrLine>Palo Alto, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Computational techniques for human genome resequencing using mated gapped reads</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Carnevali</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="279" to="292" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">De novo fragment assembly with short mate-paired reads: Does the read length matter?</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="336" to="346" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">A framework for variation discovery and genotyping using next-generation DNA sequencing data</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">A</forename>
				<surname>Depristo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="491" to="498" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Human genome sequencing using unchained base reads on self-assembling DNA nanoarrays</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Drmanac</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">327</biblScope>
			<biblScope unit="page" from="78" to="81" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Universal codeword sets and representations of the integers</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Elias</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="194" to="203" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Opportunistic data structures with applications</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FOCS</title>
		<meeting><address><addrLine>Redondo Beach, California, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="390" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Lightweight data indexing and compression in external memory</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>López-Ortiz, A.</editor>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">6034</biblScope>
			<biblScope unit="page" from="697" to="710" />
			<date type="published" when="2010" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Computer programs for the assembly of DNA sequences</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">R</forename>
				<surname>Gingeras</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="529" to="545" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">High-quality draft assemblies of mammalian genomes from massively parallel sequence data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gnerre</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci. USA</title>
		<meeting>. Natl. Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1513" to="1518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Improved variant discovery through local realignment of short-read next-generation sequencing data using SRMA</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Homer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Nelson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">99</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">A space and time efficient algorithm for constructing compressed suffix arrays</title>
		<author>
			<persName>
				<forename type="first">W.-K</forename>
				<surname>Hon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="23" to="36" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">A new algorithm for DNA sequence assembly</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">M</forename>
				<surname>Idury</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Waterman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="291" to="306" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">HiTEC: accurate error correction in high-throughput sequencing data</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Ilie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="295" to="302" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">De novo assembly and genotyping of variants using colored de bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Iqbal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="226" to="232" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">High throughput short read alignment via bi-directional BWT</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">W</forename>
				<surname>Lam</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In BIBM</title>
		<imprint>
			<biblScope unit="page" from="31" to="36" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Performance comparison of whole-genome sequencing platforms</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">Y K</forename>
				<surname>Lam</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="78" to="82" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">The diploid genome sequence of an individual human</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Levy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">254</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with BurrowsWheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Fast and accurate long-read alignment with BurrowsWheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="589" to="595" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Improving SNP discovery by base alignment quality</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1157" to="1158" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Storage and retrieval of individual genomes</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Mäkinen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RECOMB</title>
		<editor>Batzoglou,S.</editor>
		<meeting><address><addrLine>Tucson, AZ, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="121" to="137" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">SNP-o-matic</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">M</forename>
				<surname>Manske</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">P</forename>
				<surname>Kwiatkowski</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2434" to="2435" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Computability of models for sequence assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">WABI</title>
		<editor>Giancarlo,R. and Hannenhalli,S.</editor>
		<meeting><address><addrLine>Philadelphia, PA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="289" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Natural genetic variation caused by small insertions and deletions in the human genome</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">E</forename>
				<surname>Mills</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="830" to="839" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Toward simplifying and accurately formulating fragment assembly</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="275" to="290" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">A whole-genome assembly of drosophila</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">287</biblScope>
			<biblScope unit="page" from="2196" to="2204" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">The fragment assembly string graph</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="79" to="85" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Suppl. . 2</note>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Two efficient algorithms for linear time suffix array construction</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Nong</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="1471" to="1484" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">Sequencing of natural strains of arabidopsis thaliana with short reads</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Ossowski</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="2024" to="2033" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">SEQAID: a DNA sequence assembling program based on a mathematical model</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Peltola</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="307" to="321" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">An eulerian path approach to DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci. USA, 98</title>
		<meeting>. Natl. Acad. Sci. USA, 98</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9748" to="9753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">Efficient construction of an assembly string graph using the FM-index</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="367" to="373" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of large genomes using compressed data structures</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="549" to="556" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<analytic>
		<title level="a" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title level="a" type="main">Compressed suffix arrays for massive data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Siren</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">String Processing and Information Retrieval</title>
		<meeting><address><addrLine>Saariselkä, Finland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="63" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b38">
	<analytic>
		<title level="a" type="main">A strategy of DNA sequencing employing computer programs</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Staden</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="2601" to="2610" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b39">
	<analytic>
		<title level="a" type="main">Pebble and rock band: heuristic resolution of repeats and scaffolding in the velvet short-read de novo assembler. PLoS ONE, 4, e8407. 1000 Genomes Project Consortium. (2010) A map of human genome variation from population-scale sequencing</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">467</biblScope>
			<biblScope unit="page" from="1061" to="1073" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>