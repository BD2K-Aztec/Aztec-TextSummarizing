
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:32+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Gene expression ODES: an overlapping dense sub-graph algorithm</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010">. 21 2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">James</forename>
								<surname>Long</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">International Arctic Research Center</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Chris</forename>
								<surname>Hartman</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Alaska Fairbanks</orgName>
								<address>
									<postCode>99775</postCode>
									<settlement>Fairbanks</settlement>
									<region>AK</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Gene expression ODES: an overlapping dense sub-graph algorithm</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS APPLICATIONS NOTE</title>
						<imprint>
							<biblScope unit="volume">26</biblScope>
							<biblScope unit="page" from="2788" to="2789"/>
							<date type="published" when="2010">. 21 2010</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq514</idno>
					<note type="submission">Received on July 6, 2010; revised on August 23, 2010; accepted on August 31, 2010</note>
					<note>[13:36 6/10/2010 Bioinformatics-btq514.tex] Page: 2788 2788–2789 Associate Editor: Trey Ideker</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Enumeration of the dense sub-graphs of a graph is of interest in community discovery and membership problems, including dense sub-graphs that overlap each other. Described herein is ODES (Overlapping DEnse Sub-graphs), pthreads parallelized software to extract all overlapping maximal sub-graphs whose densities are greater than or equal to a specified cutoff density of at least 1/2. Availability and Implementation: http://dense.sf.net</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Algorithms that infer community membership are important in a number of network problems (<ref type="bibr" target="#b0">Adamcsek et al., 2006;</ref><ref type="bibr" target="#b1">Hu et al., 2005;</ref><ref type="bibr" target="#b2">Palla et al., 2005</ref>). In an algorithm like CODENSE (<ref type="bibr" target="#b1">Hu et al., 2005</ref>), mRNA interaction maps are generated from microarray data and represented as graphs, where vertices are mRNAs and edges are expression correlations. One is interested in enumerating those groups of mRNAs that have high-correlated expression over different conditions, suggesting that proteins produced from such mRNAs interact with one another in biological modules. Modules have high connectivity between members, and thus would form dense sub-graphs within a map. mRNAs belonging to more than one module lie in the intersection of dense sub-graphs, and algorithms that delineate the modules must be able to distinguish overlapping dense sub-graphs. We describe herein an exact algorithm to find, within some large graph, overlapping maximal dense sub-graphs whose densities are greater than or equal to a specified cutoff density of at least 1/2, where 'density' of a graph with e edges and n vertices is defined as the number of edges divided by the total number of possible edges, i.e. 2e/n(n−1), and where 'maximal' denotes that the inclusion of an additional vertex would lower the density below the cutoff. The algorithm constrains the brute force search-space, yielding acceptable performance on dense subgraphs of 20 vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Theory</head><p>We prove a theorem that any connected graph with three or more vertices and density at least 1/2 contains a vertex whose removal neither disconnects the graph, nor diminishes its density. Since the resulting graph will be connected * To whom correspondence should be addressed.and have density at least as large, it qualifies for inductive rounds of vertex removal consistent with the theorem, which may continue until there is a single-edge graph remaining, which has density 1. The algorithm to discover dense sub-graphs in some larger graph is based upon reversing this procedure to build up the dense subgraphs from single-edge sub-graphs of the larger graph.</p><p>Theorem A connected graph G, with den(G) ≥ 1/2, and n ≥ 3, has at least one non-cut vertex w, with degree d(w) ≤ d ave , the average degree. Removal of w from G does not decrease the density of G.</p><p>Proof. Given a connected graph G, with e edges, n vertices and den(G) ≥ 1/2, pick some vertex v where d(v) ≤ d ave. If v is not a cut vertex, then we are done, and w = v. If v is a cut vertex, then let S be the smallest component of G−v, and let A = S +v and B = G\A. Setting x = |V (S)| and y = |V (B)|, we have x ≤ y, n = x +y+1, and |V (A)| = x +1 (<ref type="figure" target="#fig_0">Fig. 1</ref>). It is well known that there exist at least two non-cut vertices in any connected graph with more than one vertex, and thus there must be at least one such vertex w in A that is different from v. Since w is not a cut vertex in A, it is not a cut vertex in G. To show that d(w) ≤ d ave = 2e/n, we note that den</p><formula>(G) ≥ 1/2 ⇒ 2e/n(n−1) ≥ 1/2, or d ave ≥ (n−1)/2 = (x +y)/2. Now d (w ) ≤ |V (A )|−1 = x = x +x 2 ≤ x +y 2 ≤ d ave .</formula><p>Removal of w from G does not decrease the density of G:</p><formula>d (w ) ≤ 2e n ⇒ nd (w ) ≤ 2e ⇒ nd (w )−ne ≤ 2e−ne ⇒ n (e−d (w ) )≥ e (n−2 )⇒ (e−d (w ) ) (n−2 ) ≥ e n ⇒ 2 (e−d (w ) ) (n−1 ) (n−2 ) ≥ 2e n (n−1 ) ⇒ den (G−w ) ≥ den (G ). Q.E.D.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Algorithm</head><p>Within a large graph G, any maximal sub-graph with density above a specified minimum D ≥ 1/2 may be found in the following manner. Initialize a list S with all single-edge sub-graphs S i of G. Then, for each S i in S, successively examine every vertex v adjacent to S i whose degree in S i +v is less than or equal to the average degree of S i + v, and whose addition to S i maintains the density of S i +v above D, i.e. search for every v that satisfy den(S i ) ≥ den(S i +v) ≥ D ≥ 1/2. For each v that qualifies, insert S i +v into a sorted list L, provided that S i +v is not already in L, determined by a binary search. When no other</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>An overlapping dense sub-graph algorithm</head><p>entries can be added to L, the contents of L become the new S, and another iteration with an initially empty L commences. If no entries have been made into L, the process terminates. The list of dense sub-graphs to return is built by appending any S i that is not extended within an iteration, assuming its order (number of vertices) exceeds some specified minimum. Implementing the algorithm in the above manner, however, has the drawback that the current density of each S i must be tracked in order to ensure that den(S i ) ≥ den(S i +v). But any S i +v that increases the density of S i , and is not already in L, is really a pre-computation of some other subgraph S k with a different adjacent vertex w added consistent with the theorem, i.e. S i +v can be reordered as S k +w, v = w, by our theorem, and may thus be added to L early. Thus it is sufficient to insure only that den(S i +v) ≥ D ≥ 1/2, eliminating the need to track current densities. Each round of extending candidate sub-graphs S i by one vertex is independent of previous rounds, and can thus be handled by a separate thread of execution. Candidate sub-graphs from one thread are passed to the next thread 'mod NUM_THREADS', and handled asynchronously. In the place of L, each thread maintains a sorted list of sub-graphs it has passed to the next thread, which is cleared when the order of sub-graphs being handled is incremented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Complexity</head><p>Worst-case performance is when G is a clique. For a clique of n vertices, a vertex is either in a sub-graph, or it is not, resulting in O(2 n ) sub-graphs to examine. This worst case is ameliorated when G is not a clique by the ordering property of the theorem, which forces initial seed graphs to be of high density, e.g. searching for sub-graphs of density 0.7 forces all initial seed graphs with three vertices to be a clique, and subsequent four vertex seed graphs to have five of six possible edges, etc. In practice, this works well for biological networks that typically exhibit a power law distribution of vertex degree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Implementation</head><p>ODES is implemented with pthreads in the C programming language as a function call, returning a list of maximal dense sub-graphs. The function signature is composed of the input graph, the minimum desired density of a subgraph, and the minimum number of vertices that a dense sub-graph must contain.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Cut vertex v.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>[13:36 6/10/2010 Bioinformatics-btq514.tex] Page: 2789 2788–2789</figDesc></figure>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> RESULTS Figure 2 records timings using four threads on graphs G i of 20 vertices each, whose density varies over values that range from a minimum cutoff density D to 1, and where G i is not embedded in any larger graph. Six plots are shown, corresponding to each of six values for D, and the time shown is how long it takes for the algorithm to return G i. We observe that the ordering property of the theorem has the greatest effect on reducing the search time when the actual density of G i is close to the cutoff D, rather than being appreciably denser than D, showing a 3-fold speedup for densities close to D and exhibiting roughly constant running time for densities of G i close to D as D increases. Embedding G i within a 10 000-vertex graph, where the average degree of a vertex is 4, increases the runtime ∼10%. 4 FUTURE WORK (i) Density bins: Figure 2 suggests that as the number of threads available on modern multi-core processors increases, the algorithm Fig. 2. Running times for various cutoff densities. should be restructured to run over a collection of density bins, where a set of threads is dedicated to each density bin that handles only those sub-graphs whose density has decreased below the cutoff for the bin above it, thus finding all maximal dense sub-graphs of the same order in roughly constant running time. All single-edge subgraphs would start off in the bin that handles the highest density range. (ii) Hash function: profiling reveals a large percentage of time spent in binary searches of the sorted list of sub-graphs passed to the next thread; a suitable hash function may increase performance. (iii) Overlap indication: some indication of which graphs overlap, and where, is desired. (iv) Edge exclusion from the initial single-edge sub-graph list: due to its high complexity, ODES does not scale well to largedense sub-graphs. The guarantee of finding all overlapping dense sub-graphs, however, makes its use attractive in conjunction with heuristic methods, where heuristically determined edges from large dense sub-graphs would be excluded from the initial single-edge sub-graph list for ODES, but still retained in the subsequent search space, thus allowing overlaps with the large dense sub-graphs.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">CFinder: locating cliques and overlapping modules in biological networks</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Adamcsek</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1021" to="1023" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Mining coherent dense subgraphs across massive biological networks for functional discovery</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="213" to="221" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Suppl. . 1</note>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Uncovering the overlapping community structure of complex networks in nature and society</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Palla</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">435</biblScope>
			<biblScope unit="page" from="814" to="418" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>