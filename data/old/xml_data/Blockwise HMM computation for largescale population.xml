
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:54+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Blockwise HMM computation for large-scale population genomic inference</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Joshua</forename>
								<forename type="middle">S</forename>
								<surname>Paul</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Division</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yun</forename>
								<forename type="middle">S</forename>
								<surname>Song</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Division</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Jeffrey</forename>
								<surname>Barrett</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Statistics</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>94720</postCode>
									<settlement>Berkeley</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Blockwise HMM computation for large-scale population genomic inference</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="issue">15</biblScope>
							<biblScope unit="page" from="2008" to="2015"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts314</idno>
					<note type="submission">Genetics and population analysis Advance Access publication May 28, 2012 Received on March 3, 2012; revised on April 18, 2012; accepted on May 22, 2012</note>
					<note>Copyedited by: SK MANUSCRIPT CATEGORY: ORIGINAL PAPER [09:56 5/7/2012 Bioinformatics-bts314.tex] BIOINFORMATICS ORIGINAL PAPER Associate Editor: Supplementary Information: Supplementary data are available at Bioinformatics online. Contact:</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: A promising class of methods for large-scale population genomic inference use the conditional sampling distribution (CSD), which approximates the probability of sampling an individual with a particular DNA sequence, given that a collection of sequences from the population has already been observed. The CSD has a wide range of applications, including imputing missing sequence data, estimating recombination rates, inferring human colonization history and identifying tracts of distinct ancestry in admixed populations. Most well-used CSDs are based on hidden Markov models (HMMs). Although computationally efficient in principle, methods resulting from the common implementation of the relevant HMM techniques remain intractable for large genomic datasets. Results: To address this issue, a set of algorithmic improvements for performing the exact HMM computation is introduced here, by exploiting the particular structure of the CSD and typical characteristics of genomic data. It is empirically demonstrated that these improvements result in a speedup of several orders of magnitude for large datasets and that the speedup continues to increase with the number of sequences. The optimized algorithms can be adopted in methods for various applications, including the ones mentioned above and make previously impracticable analyses possible. Availability: Software available upon request.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>With the cost of genomic sequencing rapidly decreasing, there is a growing need for statistical methodologies that can efficiently accommodate genomic-scale data for many individuals while accounting for complex patterns of variation (e.g. linkage disequilibrium) caused by evolutionary processes such as mutation and recombination. The applicable underlying statistical model is the coalescent with recombination, which describes the distribution of genealogical histories for a collection of individuals. Known methods for inference under this model are generally intractable at the genomic scale, so practicable methods must realize a balance * To whom correspondence should be addressed. between computational efficiency and approximating key properties of the coalescent with recombination. A promising class of such methods use the conditional sampling distribution (CSD). A CSD approximates the probability (under the coalescent with recombination) of sampling an individual with a particular DNA sequence, given that a collection of sequences from the population has already been observed. Intuitively, recombination partitions the newly sampled sequence into segments, each of which is a copy of the corresponding segment in a previously sampled sequence, with imperfections introduced by mutation. For computational efficiency, this construction is often cast as a hidden Markov model (HMM). The hidden state at a site indicates the previously sampled sequence being copied and the associated observed state the allele of the new sample. Even within this framework there are alternatives, as it is possible to trade-off fidelity to the underlying coalescent process for computational efficiency. The CSD of<ref type="bibr" target="#b25">Paul et al. (2011)</ref>, for example, is the most accurate but is a constant factor slower than CSDs proposed by<ref type="bibr" target="#b7">Fearnhead and Donnelly (2001)</ref>and by<ref type="bibr" target="#b18">Li and Stephens (2003)</ref>, with the latter being the fastest, but least accurate. CSDs for more complex models, incorporating gene conversion (<ref type="bibr" target="#b10">Gay et al., 2007;</ref><ref type="bibr" target="#b32">Yin et al., 2009</ref>), diploidy (<ref type="bibr" target="#b20">Marchini et al., 2007</ref>), demography (<ref type="bibr" target="#b2">Davison et al., 2009;</ref><ref type="bibr" target="#b12">Hellenthal et al., 2008</ref>) and admixture (<ref type="bibr" target="#b26">Price et al., 2009;</ref><ref type="bibr" target="#b30">Sundquist et al., 2008</ref>), have also been proposed. Methods incorporating the CSD generally fall into one of several categories. Likelihoods can be approximated using CSD-based importance sampling (De<ref type="bibr">Iorio and Griffiths, 2004a, b;</ref><ref type="bibr" target="#b7">Fearnhead and Donnelly, 2001;</ref><ref type="bibr" target="#b11">Griffiths et al., 2008;</ref><ref type="bibr" target="#b28">Stephens and Donnelly, 2000</ref>) coupled with composite methods (<ref type="bibr" target="#b8">Fearnhead and Donnelly, 2002;</ref><ref type="bibr" target="#b15">Hudson, 2001</ref>) or directly as a product of CSDs (<ref type="bibr" target="#b18">Li and Stephens, 2003</ref>). In conjunction with expectation–maximization or Markov chain Monte Carlo, these methods have been used for estimation of fine-scale recombination rates (<ref type="bibr" target="#b1">Crawford et al., 2004;</ref><ref type="bibr" target="#b9">Fearnhead and Smith, 2005;</ref><ref type="bibr" target="#b18">Li and Stephens, 2003;</ref><ref type="bibr" target="#b22">McVean et al., 2004</ref>), gene conversion parameters (<ref type="bibr" target="#b10">Gay et al., 2007;</ref><ref type="bibr" target="#b32">Yin et al., 2009</ref>), population demography (<ref type="bibr" target="#b2">Davison et al., 2009;</ref><ref type="bibr" target="#b12">Hellenthal et al., 2008</ref>) and population structure (<ref type="bibr" target="#b16">Lawson et al., 2012</ref>). It is also possible to infer and use the hidden states in the HMM CSD computation. This has been used for admixture inference (<ref type="bibr" target="#b26">Price et al., 2009;</ref><ref type="bibr" target="#b30">Sundquist et al., 2008;</ref><ref type="bibr" target="#b31">Wegmann et al., 2011</ref>), in which genomic segments corresponding to ancestral populations are identified and also within a pseudo-Gibbs sampling framework to phase genotype sequence data into haplotype sequence data and to impute missing data (<ref type="bibr" target="#b14">Howie et al., 2009;</ref><ref type="bibr" target="#b19">Li et al., 2010;</ref><ref type="bibr" target="#b20">Marchini et al., 2007;</ref><ref type="bibr" target="#b29">Stephens and Scheet, 2005</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Blockwise HMM computation</head><p>Nearly, all of these methods rely on iterative Monte Carlo or expectation–maximization techniques. As a result, they are computationally intensive, often requiring several hours, or, in some cases, days, to produce a result, even for modest non-genomic datasets (<ref type="bibr" target="#b14">Howie et al., 2009</ref>); directly extending the methods to large genomic datasets is thus often impractical. Moreover, nearly all of the running time is expended on CSD computation, and so the choice of CSD is often made on the basis of efficiency and (arguably) at the expense of accuracy (<ref type="bibr" target="#b0">Browning and Browning, 2007;</ref><ref type="bibr" target="#b14">Howie et al., 2009;</ref><ref type="bibr" target="#b18">Li and Stephens, 2003;</ref><ref type="bibr" target="#b27">Scheet and Stephens, 2006</ref>;<ref type="bibr" target="#b29">Stephens and Scheet, 2005</ref>). In this article, we help to overcome these limitations by proposing two related optimizations to the relevant HMM-based CSD computations. Consider sampling a large number of sequences from a population. If the sampled sequences are very long, it is likely that nearly all of them will be unique. However, for most relatively short regions, the number of unique subsequences will be reduced. This intuition forms the basis of the first optimization, which locally reduces the complexity of the CSD computation, thereby improving efficiency. The collection of locally unique subsequences on which this optimization depends are formalized as a partition C of the sampled sequences; we characterize the optimal partition given the sampled sequences and provide a fast algorithm for approximating this optimum. A second common feature of the sampled sequences is an abundance of non-polymorphic sites. These sites are informative— for example, a local over-abundance of non-polymorphic sites indicates a recent common ancestor, which in turn indicates a low propensity for recombination—and should be included in the analysis. Indeed, Li and Durbin (2011) used the physical distribution of polymorphic and non-polymorphic sites between a pair of sequences to infer past population sizes of humans. Using the fact that non-polymorphic sites do not differentiate the sequences, we show that it is possible to reduce the complexity of the CSD computation at non-polymorphic sites. We stress that our solution is different from simply ignoring non-polymorphic sites; we are proposing algorithmic improvements to incorporate non-polymorphic sites into the analysis in an efficient way. In formally describing and evaluating our optimizations, we restrict attention to the most accurate HMM-based CSD, ˆ π SMC , proposed by<ref type="bibr" target="#b25">Paul et al. (2011)</ref>and consider the problem of computing the conditional sampling probability (CSP), denotedˆπ denotedˆ denotedˆπ SMC (α|n), of a particular individual α given a collection n of previously sampled individuals. (Incidentally, in the case the size n of the previously observed sample n is 1, the HMM underlyingˆπ underlyingˆ underlyingˆπ SMC is equivalent to the HMM used in the aforementioned work of Li and Durbin; we anticipate thatˆπthatˆ thatˆπ SMC provides one way of extending this line of work to many sequences). On simulated data, our algorithmic improvement leads to a speedup of about 550× for n = 5000 previously sampled individuals; by making regularity assumptions on mutation and recombination rates, this speedup increases to about 1850×. Importantly, we show that the empirically observed speed-up increases with the number n of previously sampled individuals. Although we describe our optimizations in the context of computingˆπcomputingˆ computingˆπ SMC (α|n), they are more generally applicable. We provide two sufficient conditions for our optimizations and use them to show the applicability to other HMM-based CSDs, including those of Fearnhead and Donnelly (</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2001) and Li and Stephens</head><p>(2003), as well as CSDs for more complex demographic models and population genetic HMMs. Also, in the Supplementary Material, we describe extending our algorithms to allow for efficient inference of hidden states, often termed posterior decoding. We stress that the work presented here is fundamentally different from previous works on 'approximating' CSD-based population genetic inference.<ref type="bibr" target="#b14">Howie et al. (2009)</ref>consider a fixed-size subset of the haplotype configuration n, chosen using a measure of 'closeness' to the sampled haplotype α, in order to reduce the state space of the HMM-based CSD and speed up computation. Similarly, Scheet and Stephens (2006) and Browning and Browning (2007) consider an HMM with reduced state space by compacting the configuration n into a substantially smaller haplotype model. More recently,<ref type="bibr" target="#b5">Delaneau et al. (2012)</ref>have proposed an approximate HMM formulation relying on a partition of the sampled sequences similar to that proposed herein (Section 2.6). As described earlier, using such heuristics improves computational efficiency, but ultimately at the expense of accuracy. The purpose of this article is to provide highly optimized 'and exact' computation for a large class of approximate CSDs, rather than to introduce additional approximations to the underlying models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>Herein, we describe the HMM formulation ofˆπofˆ ofˆπ SMC , the algorithms that are currently being used to computê π SMC (α|n) and the optimizations we are proposing to improve the running time. We remark that the theoretical analysis of our algorithms is limited to asymptotic time (and space) complexity. As a measure of real-world performance, asymptotic analyses often leave much to be desired. Consider, for example, a sample in which 1 out of every 1000 sites is polymorphic. If we denote by k the total number of sites and k p the number of polymorphic sites, then formally O(k) = O(k p ). Nevertheless, we would like to distinguish between an algorithm that operates on each of the k sites and an algorithm that operates only on the k p polymorphic sites, as the the latter will be some 1000× faster; we thus write the complexities for the two algorithms as O(k) and O(k p ), respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Notation</head><p>We consider haplotypes in the finite-locus finite-alleles setting. Throughout, we suppose that there are k loci, and that recombination may occur between any adjacent pair of loci (,+1) where 1 ≤ &lt;k. The space of all such haplotypes is denoted by H, and given a haplotype h ∈ H, the allele at locus is denoted by h<ref type="bibr">[]</ref>and the sub-haplotype for a range of loci ≤ is denoted by h<ref type="bibr">[ : ]</ref>. A sample configuration of haplotypes is specified by a vector n = (n h ) h∈H , with n h being the number of haplotypes of type h in the sample. The set of 'unique' haplotypes associated with configuration n is denoted by H n ={h ∈ H : n h &gt; 0}. Finally, the total number of haplotypes is denoted by |n|=n, the number of unique haplotypes by |H n |=n u and the number of polymorphic loci, which generally depends on the sample n, by k p .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">A brief description ofˆπofˆ ofˆπ SMC</head><p>Suppose that, conditioned on having already observed a haplotype configuration n, we wish to sample a new haplotype α. By generalizing the technique of<ref type="bibr" target="#b11">Griffiths et al. (2008)</ref>based on the diffusion process, Paul and Song (2010) introduced the CSDˆπCSDˆ CSDˆπ PS intended to approximate key properties of the coalescent with recombination, the model under which inference is to be performed. The central idea ofˆπofˆ ofˆπ PS is to fix the unknown ancestry of n to be the 'trunk genealogy' A * (n), in which lineages associated with the haplotypes do not mutate, recombine, or coalesce with one another, but ratherwith the shading indicating the allelic type at that locus. Time is represented vertically, with the present (time 0) at the bottom. The marginal genealogies at the first, second and third loci are shown as dotted, dashed and solid lines, respectively. Mutation event, along with resulting allele, is indicated by small arrow. Absorption events at each locus, and the corresponding absorption time (t (a) and t (b) ) and haplotype (h (a) and h (b) , respectively), are indicated by horizontal lines extend infinitely into the past. Having fixed the ancestry of n, a conditional genealogy C associated with haplotype α is sampled; within C, lineages evolve backwards in time subject to mutation, recombination, coalescence and 'absorption' into one of the lineages of A * (n). When every lineage of C has been absorbed, the process terminates; the type of every lineage of C is now determined and a sample for α is generated. Although a recursion for computing the CSPˆπCSPˆ CSPˆπ PS (α|n) is known, it is computationally intractable for all but the smallest datasets. To remedy this limitation,<ref type="bibr" target="#b25">Paul et al. (2011)</ref>adopted a sequentially Markov framework (<ref type="bibr" target="#b23">McVean and Cardin, 2005</ref>) for the conditional genealogy C. The central idea is to consider the 'marginal' conditional genealogy s associated with each locus , which is described, disregarding mutation events, by the pair s = (t ,h ), where t ∈[0,∞) is the absorption time and h ∈ H n is the absorption haplotype. The conditional genealogy C can thus be represented as a sequence of marginal conditional genealogies {s }. See<ref type="figure" target="#fig_0">Figure 1</ref>for an illustration. In general, the random sequence of marginal conditional genealogies is not Markov, due to the potential for coalescence events within the conditional genealogy. Nonetheless, it is possible to 'approximate' this sequence as Markov by using a two-locus transition distribution. Mutation can then be realized at each locus independently as a Poisson process on the marginal conditional genealogy, thereby generating a sample for α. The resulting CSD is denoted byˆπbyˆ byˆπ SMC .<ref type="bibr" target="#b25">Paul et al. (2011)</ref>found that the Markov approximation underlyingˆπunderlyingˆ underlyingˆπ SMC has minimal effect on accuracy compared withˆπwithˆ withˆπ PS , coinciding with findings in similar domains (<ref type="bibr" target="#b21">Marjoram and Wall, 2006;</ref><ref type="bibr" target="#b23">McVean and Cardin, 2005</ref>). Owing to its Markov structure, the CSDˆπCSDˆ CSDˆπ SMC can be cast as an HMM wherein the th hidden state is the marginal conditional genealogy s = (t ,h ) and the th observed state the conditionally sampled allele α<ref type="bibr">[]</ref>. In order to use standard dynamic programming methodologies for inference, the state space of the HMM must be finite, and so absorption time is discretized by partitioning [0,∞) into a (possibly large) finite number m of intervals I and considering an absorption interval, denoted by d ∈ I, rather than an absorption time. The discretized hidden state at the th locus is then s = (d ,h ), and the initial, transition and emission distributions for the discretizedˆπdiscretizedˆ discretizedˆπ SMC HMM are denoted by ζ (·), φ (·|·) and ξ (·|·), respectively.</p><p>Interested readers should consult Paul and Song (2010) and<ref type="bibr" target="#b25">Paul et al. (2011)</ref>for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Computation withˆπwithˆ withˆπ SMC</head><p>The CSPˆπCSPˆ CSPˆπ SMC (α|n) under the discrete-space HMM can be efficiently computed using the 'forward algorithm', a dynamic program associated with the HMM forward recursion:</p><formula>ˆ π SMC (α|n) = d∈I h∈Hn F k (d,h),</formula><formula>(1) where F (d,h) = ξ (α[]|d,h) d ∈I h ∈Hn φ −1 (d,h|d ,h )F −1 (d ,h ),</formula><formula>(2)</formula><p>with base case F 0 (d,h) = ζ (d,h).</p><formula>(3)</formula><p>Importantly, this recursion, and the associated dynamic program with time complexity O(k(n u m) 2 ), is applicable to a general HMM. In the following, we examine the transition and emission distributions more carefully and obtain a series of refined recursions and the associated dynamic programs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Improving efficiency through the transition distribution</head><p>Consider the description ofˆπofˆ ofˆπ SMC given above and more rigorously defined in<ref type="bibr" target="#b25">Paul et al. (2011)</ref>. If a recombination does not occur between loci −1 and , then (d −1 ,h −1 ) = (d ,h ); moreover, if recombination does occur, the absorbing haplotype h is independent of h −1 and uniformly distributed. As a result, we have the following property (We remark that Property 1 is a sufficient, though not necessary, condition for the algorithmic optimizations described in this and subsequent sections. For example, as stated, the transition distribution imposes a uniform distribution on the absorbing haplotype in the case of a recombination; in fact, the algorithms can be generalized to accommodate an arbitrary distribution over haplotypes that does not depend on d or h. In Section 4, we discuss the applicability of these optimizations to more general (and more specialized) classes of approximate CSDs.):</p><formula>ζ (d,h) = x (d) · n h n , φ (d,h|d ,h ) = y (d ) ·δ d ,d δ h ,h +z (d ,d) · n h n , where x (d) , y (d ) and z (d ,d)</formula><p>are known analytic expressions. Using Property 1 in conjunction with definitions</p><formula>Q (d) = h∈Hn F (d,h) and U (d) = d ∈I z (d ,d) Q (d ),</formula><formula>(4)</formula><p>we can express equations (1)–(3) asˆπ</p><formula>asˆ asˆπ SMC (α|n) = d∈I Q k (d),</formula><formula>(5) where F (d,h) = ξ (α[]|d,h) y (d) −1 F −1 (d,h)+ n h n U −1 (d) ,</formula><formula>(6)</formula><p>with base case</p><formula>F 0 (d,h) = x (d) · n h n .</formula><formula>(7)</formula><p>Using these recursions, the dynamic program in Algorithm 1 can be used to computê π SMC (α|n). Within the pseudocode description, the time complexity of Lines 6, 7 and 8 are O(m), O(n u ) and O(n u ), respectively. As a result, the time complexity of Lines 5–9, and for the algorithm as a whole, is O(km(m+n u )). This represents a substantial improvement over the quadratic dependence on n u in the naive forward algorithm for HMMs. This simple optimization has already been generally adopted (<ref type="bibr" target="#b7">Fearnhead and Donnelly, 2001;</ref><ref type="bibr" target="#b18">Li and Stephens, 2003;</ref><ref type="bibr" target="#b25">Paul et al., 2011</ref>) and serves as a baseline for improvement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Improving efficiency through the emission distribution</head><p>The state of thê π SMC HMM at locus is a tuple (d ,h ). However, the emission probability of α<ref type="bibr">[]</ref>is governed only by the time interval d and the allele h<ref type="bibr">[]</ref>. As a result, the following property holds:@BULLET For every haplotype h ∈ H n and 1 ≤ ≤ k, there exists 'exactly' one</p><formula>(B,, s ,, e ) ∈ C with h ∈ B and s ≤ ≤ e .</formula><p>For a given locus , a configuration partition C induces a partition of the haplotypes H n , denoted by C , and Property 2 applies to each B ∈ C. In the next sections, we present new sets of recursions and dynamic programming algorithms valid for an arbitrary partition C. The computational complexity of these algorithms will depend on C through two functions, namely (C)</p><p>and (C), defined as follows: For locus , define ψ (C) =|C |, the number of blocks in C and define ω (C) to be the total number of haplotypes in blocks of the configuration partition 'ending' at locus. Then,</p><formula>(C) = k =1 ψ (C) = k =1 |C |,</formula><formula>(C) = k =1 ω (C) = (B,,s,,e)∈C |B|.</formula><p>In some cases, we are primarily concerned with polymorphic loci, and so we define p (C) to be the analog of (C) summed over 'only' polymorphic loci. Finally, we define the trivial partition C T for haplotype configuration n as the partition containing a single block ({h},1,k) for each h ∈ H n. Note that</p><formula>(C T ) = k ·n u and (C T ) = n</formula><p>u. See<ref type="figure">Figure 2</ref>for an illustration of both C T and two non-trivial configuration partitions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1">A general configuration partition</head><formula>Q (d,B) = h∈B F (d,h) so that Q (d) = B∈C Q (d,B).</formula><formula>(8)</formula><p>Now suppose (B,, s ,, e ) ∈ C. Applying Definition (8) and Property 2 to equation (6), then for s ≤ ≤ e , Q (d,B) = ξ (α<ref type="bibr">[]</ref>|d,B)</p><formula>y (d) −1 Q −1 (d,B)+ n B n U −1 (d) ,</formula><formula>(9)</formula><formula>F (d,h) =T (d,B)·F s−1 (d,h) + n h n B Q (d,B)−T (d,B)Q s−1 (d,B) ,</formula><formula>(10)</formula><p>where T (d,B) = =s ξ (α<ref type="bibr">[ ]</ref>|d,B)·y</p><formula>(d)</formula><p>−1 , and solves the recursion, T (d,B) = ξ (α<ref type="bibr">[]</ref>|d,B)·y</p><formula>(d) −1 ·T −1 (d,B),</formula><formula>(11)</formula><p>for s ≤ ≤ e , with base case T s−1 (d,B) = 1. For each block (B,, s ,, e ) ∈ C, we take advantage of equations (9) and (11) to directly compute Q (d,B) and T (d,B) at every locus s ≤ ≤ e. At the end of each block, when = e , the finer-grain values F (d,h) are computed for each h ∈ B using equation (10), and subsequently used to compute initial values for blocks beginning at locus +1. The associated dynamic program to compute the CSPˆπCSPˆ CSPˆπ SMC (α|n) is given in Algorithm 2. Within Algorithm 2, the time complexity of Line 7 is O(m); of Line 8 is O(ψ (C)) and of Lines 9 and 10 is O(ω (C)). Thus, the time complexity of Lines 6–11, and the dynamic program, is O(km 2 +m((C)+(C))). Observe that Algorithm 1 is a special case of Algorithm 2 for C = C T. Thus, if it is possible to obtain a configuration partition C for n such that (C)+(C) is substantially less than (C T )+(C T ) = kn u +n u , our new algorithm may be considerably faster than Algorithm 1; constructing such a configuration partition is the subject of Section 2.6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.2">The absence of polymorphism</head><p>In many reasonable evolutionary scenarios, a great many loci will not be polymorphic. Accommodating such loci in the analysis is important and can be done efficiently making use of Property 2. In particular, for a non-polymorphic locus , Property 2 applies to the trivial set B 0 = H n , and therefore the emission distribution can be written ξ (·|d,B 0 ) = ξ (·|d) and moreover, Q (d,B 0 ) = Q (d). Suppose consecutive loci * s ,...,, * e are not polymorphic. Rewriting equations (9) and (10) for block</p><formula>(B 0 ,, * s ,, * e ) yields, for * s ≤ ≤ * e , Q (d) = ξ (α[]|d)· y (d) −1 Q −1 (d)+U −1 (d) ,</formula><formula>(12) and for * s ≤ ≤ * e and h ∈ B 0 = H n , F (d,h) = T (d)·F * s −1 (d,h)+ n h n Q (d)−T (d)Q * s −1 (d) ,</formula><formula>(13)</formula><p>where T (d)</p><formula>(d,B) = 1, ∀(B,1,, e ) ∈ C 4. Compute Q 0 (d) using (8) 5. end for 6. for = 1 → k and d ∈ I do 7. Compute U −1 (d) using (4) 8.</formula><p>Compute Q (d,B) and T (d,B) using (9) and (11),</p><formula>∀(B,, s ,, e ) ∈ C such that s ≤ ≤ e ; compute Q (d) using (8) 9. Compute F (d,h) using (10), ∀h ∈ B and ∀(B,, s ,,) ∈ C 10. Compute Q (d,B) using (8) and T (d,B) = 1, ∀(B,,+1,, e ) ∈ C 11. end for 12. Computê π SMC (α|n) using (5)</formula><p>Algorithm</p><formula>(d) = 1 ∀d ∈ I and * s = 1 2. for = 1 → k and d ∈ I do 3.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>if locus is polymorphic then</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>if locus −1 is not polymorphic then</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>Compute Q −1 (d,B) and T −1 (d,B) using (15) and (16) 6.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>end if</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7.</head><p>Algorithm 2, lines 7–10 8.Now, let C be a configuration partition with (B,, s ,, e ) ∈ C. Suppose that there is a stretch of non-polymorphic loci</p><formula>Set T (d) = 1 and * s = +1 9. else 10. Compute U −1 (d), Q (d), and T (d) using (4),</formula><formula>* s ,...,, * e and that s ≤ * s ≤ * e ≤ e. Applying Definition (8) to equation (13), yields, for * s ≤ ≤ * e , Q (d,B) = T (d)Q * s −1 (d,B)+ n B n Q (d)−T (d)Q * s −1 (d) .</formula><formula>(15)</formula><p>Similarly, considering the definition of T (d,B) along with equation (14),</p><formula>T (d,B) = T (d)·T * s −1 (d,B).</formula><formula>(16)</formula><p>Algorithm 2 can be modified to accommodate such stretches of nonpolymorphic loci as a special case, making use of equations (12) and (14) to directly compute the values of Q (d) and T (d) at each non-polymorphic locus. If we then assume (without loss of generality) that each (B,, s ,, e ) ∈ C has e at a polymorphic locus, then at the final non-polymorphic locus, for which = * e , equations (15) and</p><p>(16) may be used to compute Q (d,B) and T (d,B) for each B ∈ C. This modification is detailed in Algorithm 3. Within Algorithm 3, the time complexity of Lines 5 and 8 is O(1), of Line 7 is O(m+ψ (C)+ω (C)) and of Line 10 is O(m). As a result, the time complexity of Lines 2–12, and of the dynamic program, is</p><formula>O(km 2 +m( p (C)+(C))</formula><p>). Relative to Algorithm 2, less computation needs to be done for non-polymorphic loci; thus, in the typical case of many nonpolymorphic loci, this dynamic program will have a decreased running time. For C = C T , the time complexity is O(km 2 +k p mn u ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.3">An optimization for non-polymorphic loci</head><p>The key recursions (12)</p><p>and</p><p>(14) for non-polymorphic loci can be written in matrix form as</p><formula>Q = E (Y +Z )Q −1 and T = E Y T −1</formula><p>, where Q and T are m-dimensional column vectors having dth entry Q (d) and T (d), respectively; E and Y are (m×m)-dimensional diagonal matrices having (d ×d)th entry ξ (α<ref type="bibr">[]</ref>|d) and y</p><formula>(d) −1 , respectively; and Z is an (m×m)-dimensional matrix having (d,d )th entry z (d ,d) −1 .</formula><p>Now, suppose that the mutational model is symmetric and the mutation rate constant for all loci. Then, E = E does not depend on , for all nonpolymorphic loci. Similarly, if the recombination rate between each pair of loci is constant, then Y = Y and Z = Z do not depend on. With these</p><formula>assumptions, for * s ≤ ≤ * e , Q = E(Y +Z)Q −1 = (E(Y +Z)) − * s +1 Q * s −1 , T = EYT −1 = (EY) − * s +1 T * s −1 ,</formula><formula>(17)</formula><p>and the values of (E(Y +Z)) r and (EY) r can be pre-computed (either by eigenvalue decomposition or repeated multiplication) for a relevant range of r-values. Using this technique for explicitly computing only the necessary values of Q (d) and T (d), stretches of non-polymorphic loci can be 'analytically' skipped. The modified dynamic program associated with this optimization is given in Algorithm 4. The time complexity of Line 4 is O(m) and of Line 6 is O(m+ψ (C)+ω (C)). Thus, the time complexity for the dynamic program is</p><formula>O(k p m 2 +m( p (C)+(C))</formula><p>). This refinement once again reduces the computation required for nonpolymorphic loci, and so we might expect substantial improvements in performance over Algorithms 2 and 3. For the choice C = C T , the time complexity is O(k p m(m+n u )). Note that the assumptions necessary for Algorithm 4, namely a symmetric mutation model and uniform mutation and recombination rates, can be relaxed, but at the expense of additional pre-computation. For example, given non-uniform, but locally similar, recombination rates, pre-computation might be performed for each of several rates; each stretch of non-polymorphic loci could then use the pre-computed values associated with the closest recombination rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">A fast algorithm for configuration partitions</head><p>In Section 2.5, we assumed a configuration partition C to be specified and showed that, for Algorithms 2–4, the time complexity depends on C through the functions (C) (or p (C)) and (C) and more particularly their sum. It is intuitively clear that a configuration partition minimizing will maximize (as in C T ), and vice versa, and in general these quantities are inversely related; minimizing a convex combination of these quantities is therefore difficult. In this section, we propose a fast and simple parametrized algorithm for constructing reasonably good configuration partitions. Given a configuration n, the algorithm proceeds sequentially over the loci: initially, let, for a particular configuration n and an arbitrary α ∈ H n. Several values of s ∈ (2,...,500) were used, and each circle corresponds to a particular value of s. The curve of circles demonstrates the trade-off between small p (small s-values) and small (large s-values). As predicted by the asymptotic time complexity results, running time appears to depend linearly on both p-and-values, and fitting a linear model indicates the constant associated with p is ∼1.5 times greater than the constant associated with . The configuration n was generated using coalescent simulation for 500 individuals, each having 10 5 bi-allelic loci, using population-scaled mutation rate θ = 0.005 per locus and population-scaled recombination rate ρ = 0.001 between each pair of adjacent loci, and resulting in k p = 1724 polymorphic loci and n u = 324 unique haplotypes block B and add (B,, s ,, e ) to the configuration partition. Set s = e +1 and repeat until locus k is reached. An example configuration partition resulting from this algorithm is shown in<ref type="figure">Figure 2c</ref>. Applying this procedure to configuration n with threshold parameter s results in a configuration partition which we denote C s. Observe that for s =|H n |, we obtain C s = C T , which minimizes. On the other hand, for s = 2 (in the bi-allelic case), the algorithm produces a configuration partition that minimizes p. Intermediate values of s produce the intermediate results that are of interest. In order to gauge the effect of different combinations of p and on the running time, the CSPˆπCSPˆ CSPˆπ SMC (α|n) was computed using the configuration partition C s for each of several values of s, and the times recorded; the results are plotted in<ref type="figure" target="#fig_4">Figure 3</ref>. As our intuition suggested, the running time depends substantially on the choice of C and, in accordance with the asymptotic time complexity results depends linearly on both p and . Furthermore, as anticipated, the values of p and are inversely related.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Blockwise HMM computation</head><p>By fitting a linear model to the data, we can deduce the constants associated with p and , which the asymptotic results cannot provide. Although these constants will depend on the implementation and hardware, their ratio should be relatively stable, and therefore informative for choosing an optimal trade-off between p and. We find that the constant associated with p is ∼1.5 times that associated with , suggesting that running time is minimized for a choice of C that minimizes 1.5· p (C)+(C). Furthermore, making use of the above algorithm, we define</p><formula>s * = argmin s 1.5· p C s + C s , and C * = C s * .</formula><p>In practice the value s * is found using binary search and determining C * is very fast. This definition will be used frequently in Section 4, as C * (and the analogous result for Algorithm 1, using in place of p ) provides a good, though not necessarily optimal, choice for C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>We have presented three optimized algorithms for computing the conditional sampling probability (CSP) ˆ π SMC (α|n). Briefly,</p><formula>C = C T General C Algorithm 2 O(km(m+n u )) O(km 2 +m((C)+(C))) Algorithm 3 O(km 2 +k p mn u ) O(km 2 +m( p (C)+(C))) Algorithm 4 O(k p m(m+n u )) O(k p m 2 +m( p (C)+(C)))</formula><p>Recall that Algorithm 2 with C = C T is equivalent to Algorithm 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>J.S.Paul and Y.S.Song</head><p>(b) (a)performance substantially, particularly as the number of haplotypes n increases. Given the results for Algorithm 3 in particular, it is clear that the key quantity p (C)+(C), taken from<ref type="figure" target="#tab_1">Table 1</ref>, increases more slowly with n for C = C * than for C = C T. Finally, as in the previous case, the asymptotic results for general C indicate that computation is dominated by the</p><formula>O(m( p (C)+(C))</formula><p>) term for both Algorithms 3 and 4; the associated convergence of running times appears to be occurring in<ref type="figure" target="#fig_3">Figure 4b</ref>, though more slowly than in<ref type="figure" target="#fig_3">Figure 4a</ref>; thus, Algorithm 4 is a practically useful alternative to Algorithm 3, even for larger values of n. Although general trends are clear from<ref type="figure" target="#fig_3">Figure 4</ref>, the logarithmic scale makes it difficult to appreciate the magnitude of the effects of the optimizations. As mentioned earlier, assuming rough homogeneity over the genome, the computation time increases linearly with the number of loci. In<ref type="figure" target="#tab_2">Table 2</ref>, we summarize the constant associated with this linear behaviour as the time required to process 1×10 5 loci, along with the speedup relative to the baseline, Algorithm 1. Observe that Algorithm 3, with C = C * , which can be applied in complete generality, provides a speedup of 15×, 250× and 546× for conditional sample sizes n = 100,2000, and 5000, respectively; and in most cases, Algorithm 4 can be applied, which increases these speedups to 320×,1300× and 1845×. Importantly, the speedup increases with the conditional sample size n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>We have presented a number of optimized algorithms for computing the CSPˆπCSPˆ CSPˆπ SMC (α|n). Our optimizations are based on two intuitive observations: first, the number of unique haplotypes in a genomic sample is dramatically reduced within relatively short regions and second, the large number of non-polymorphic loci in a genomic sample, though informative, do not distinguish between haplotypes. These observations are formalized and leveraged to refine the recursive equations for computingˆπcomputingˆ computingˆπ SMC (α|n), yielding optimized, yet exact, algorithms. We have described our optimization algorithms in the context of the HMM associated with the CSDˆπCSDˆ CSDˆπ SMC proposed by<ref type="bibr" target="#b25">Paul et al. (2011)</ref>. It is natural to question whether similar optimizations are applicable to related CSDs, such as those proposed by Fearnhead and Donnelly (2001) and by<ref type="bibr" target="#b18">Li and Stephens (2003)</ref>. In Section 2, we described two sufficient conditions: Property 1, which stipulates that, upon recombination, a new hidden haplotype is chosen independently and uniformly at random and Property 2, which stipulates that the emission distribution depends only on the allele at the current locus of the hidden haplotype. The aforementioned CSDs do satisfy both of these properties; in particular, stronger forms of Property 1 hold for both CSDs, enabling additional optimizations. We have not empirically analysed the resulting optimized algorithms, but by considering the resulting asymptotic time complexities, analogous to those in<ref type="figure" target="#tab_1">Table 1</ref>, we anticipate that the speedups obtained will be qualitatively comparable to those observed forˆπforˆ forˆπ SMC , though the corresponding magnitudes are difficult to estimate. It is also interesting to consider CSDs for more complex demographic scenarios. A theoretically straightforward extension ofˆπ ofˆ ofˆπ SMC to variable population size, for example, will continue to satisfy both Properties 1 and 2 and will therefore be amenable to very similar optimizations. On the other hand, extension to structured populations, populations that are divided into several demes between which there is limited migration, will not satisfy Property 1 as the new hidden haplotype chosen upon recombination depends on</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Blockwise HMM computation</head><p>the deme in which recombination occurs. Nonetheless, a relaxed version of Property 1 will be satisfied along with Property 2, and we anticipate analogous optimizations will be possible. The outcome is similar ifˆπifˆ ifˆπ SMC is extended to conditionally sampling diploid, rather than haploid, individuals. Related optimizations may be possible in other contexts as well. For example, Li and Durbin (2011) make use of a population genetic HMM which satisfies conditions that correspond to Properties 1 and 2 and is used to analyse genomic data. It is interesting to note that, in order to make their method practicable, Li and Durbin consider non-overlapping 100 bp windows as their set of loci; using the optimization detailed in this article may render such compromises unnecessary. It is less clear whether our optimizations are applicable to other population genetic HMMs, such as those considered by<ref type="bibr" target="#b13">Hobolth et al. (2007) and</ref><ref type="bibr" target="#b6">Dutheil et al. (2009)</ref>; nonetheless, we hope that our work will foster progress in this area. We conclude by recalling that a broad range of population genetic methods have been developed and will continue to be developed, based on the CSD. These methods are generally computationally intensive, and approximations are often made on the basis of efficiency and at the expense of accuracy; with the advent of inexpensive genomic sequencing, such computational problems will be compounded. We have introduced several optimizations for CSD computation that can potentially speed up this computation by several orders of magnitude without introducing additional approximations. We believe that these optimizations will enable analyses that were previously impracticable, particularly for large genomic datasets. We also hope that the optimizations will encourage more accurate methods, and in particular more accurate CSDs, to be developed and used for population genomic inference.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Illustration of a sequentially Markov framework for the conditional genealogy C. The trunk genealogy A * (n) is indicated. The three loci of each haplotype are each represented by a circle, with the shading indicating the allelic type at that locus. Time is represented vertically, with the present (time 0) at the bottom. The marginal genealogies at the first, second and third loci are shown as dotted, dashed and solid lines, respectively. Mutation event, along with resulting allele, is indicated by small arrow. Absorption events at each locus, and the corresponding absorption time (t (a) and t (b) ) and haplotype (h (a) and h (b) , respectively), are indicated by horizontal lines</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>Let C be a configuration partition of n. Begin by defining</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig</head><figDesc>Fig. 2. Illustration of three alternative configuration partitions. Each row represents a haplotype, with white and black circles representing the allele at each of eight polymorphic loci. The line style of each sub-haplotype indicates the block to which it belongs. (a) The trivial configuration partition C T ; p (C T ) = 40 and (C T ) = 5. (b) A non-trivial configuration partition, C; p (C) = 24 and (C) = 12. (c) The configuration partition C s found by the</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Algorithm4</head><figDesc>Computation ofˆπofˆ ofˆπ SMC (α|n) improved by considering Properties 1 and 2, and a special 'optimized' case for non-polymorphic loci, for a configuration partition C such that ∀</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.3.</head><figDesc>Fig. 3. Empirically observed running time of Algorithm 4 used to computêcomputê π SMC (α|n), for a particular configuration n and an arbitrary α ∈ H n. Several</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>Copyedited by: SK MANUSCRIPT CATEGORY: ORIGINAL PAPER [09:56 5/7/2012 Bioinformatics-bts314.tex] Page: 2014 2008–2015</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.4.</head><figDesc>Fig. 4. Log-scaled plots of the running time (in milliseconds) required to computê π SMC (α|n) for n with 2×10 5 loci and |n|=n, as a function n, for each of Algorithms 2–4. Configurations were generated using coalescent simulation as described in the text and results obtained on a single core of a MacPro with dual quad-core 3.0 GHz Xeon CPUs. (a) C = C T , the trivial configuration partition. (b) C = C * , the configuration partition described in Section 2.6</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>Copyedited by: SK MANUSCRIPT CATEGORY: ORIGINAL PAPER [09:56 5/7/2012 Bioinformatics-bts314.tex] Page: 2015 2008–2015</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>∈ I do and d ∈ I do 6. Compute U −1 (d) using (4) 7. Compute F (d,h) using (6), ∀h ∈ H n 8.</figDesc><table>Copyedited by: SK 

MANUSCRIPT CATEGORY: ORIGINAL PAPER 

[09:56 5/7/2012 Bioinformatics-bts314.tex] 
Page: 2011 2008–2015 

Blockwise HMM computation 

Algorithm 1 Computê 
π SMC (α|n) using a forward-type recursion improved 

by considering Property 1 

1. for all d 2. 

Compute F 0 (d,h) by (7), ∀h ∈ H n 

3. 

Compute Q 0 (d) using (4) 
4. end for 
5. for = 1 → k Compute Q (d) using (4) 
9. end for 
10. Computê 
π SMC (α|n) using (5) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Property 2. Consider a subset B ⊂ H n such that there exists an allele a with h[]=a for all h ∈ B. Then, for each absorption interval d ∈ I, the emission distribution ξ (·|d,h) is identical for all h ∈ B. We indicate this fact by writing ξ (·|d,h) = ξ (·|d,B) for all h ∈ B. With this in mind, define a 'partition' C of the haplotype configuration n to be a collection of blocks of the form (B,, s ,, e ), such that @BULLET For every (B,, s ,, e ) ∈ C, there exists a sub-haplotype x such that h[ s : e ]=x for all h ∈ B.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>. 2. Illustration of three alternative configuration partitions. Each row represents a haplotype, with white and black circles representing the allele at each of eight polymorphic loci. The line style of each sub-haplotype indicates the block to which it belongs. (a) The trivial configuration partition C T ; p (C T ) = 40 and (C T ) = 5. (b) A non-trivial configuration partition, C; p (C) = 24 and (C) = 12. (c) The configuration partition C s found by the algorithm described in Section 2.6 for s = 3; p (C s ) = 24 and (C s ) = 15 where n B = h∈B n h. Similarly, by induction and making use of equations (6) and (9), it is possible to show that, for s ≤ ≤ e and h ∈ B,</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>1. for all d ∈ I do 2. Compute F 0 (d,h) using (7), ∀h ∈ H n 3. Compute Q 0 (d,B) using (8) and T 0</figDesc><table>= 


=  *  

s 

ξ (α[ ]|d)·y 

(d) 

−1 and solves the recursion 

T (d) = ξ (α[]|d)·y 

(d) 

−1 ·T −1 (d), 
(14) 

for  *  
s ≤ ≤  *  
e , with base case T  *  s −1 (d) = 1. Copyedited by: SK 

MANUSCRIPT CATEGORY: ORIGINAL PAPER 

[09:56 5/7/2012 Bioinformatics-bts314.tex] 
Page: 2012 2008–2015 

J.S.Paul and Y.S.Song 

Algorithm 2 Computê 
π SMC (α|n) using a forward-type recursion improved 

by considering Properties 1 and 2, for a configuration partition C 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>3 Computation ofˆπofˆ ofˆπ SMC (α|n) improved by considering Properties 1 and 2, and a special case for non-polymorphic loci, for a configuration partition C such that ∀(B,, s ,, e ) ∈ C, e is polymorphic 1. Algorithm 2, lines 1–5; and set T 0</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><figDesc>s = 1. Given s , find the largest polymorphic locus e such that s ≤ e ≤ k, and the number of unique sub-haplotypes between loci s and e is at most some threshold parameter s. Then, for each unique sub-haplotype x between s and e , group all h ∈ H n such that h[ s : e ]=x into the same</figDesc><table>Copyedited by: SK 

MANUSCRIPT CATEGORY: ORIGINAL PAPER 

[09:56 5/7/2012 Bioinformatics-bts314.tex] 
Page: 2013 2008–2015 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><figDesc>Table 1. A summary of the proposed algorithms along with their asymptotic time complexities</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><figDesc>Table 2. A summary of several key statistics from Figure 4 C = C T n = 100 n = 2000 n = 5000 = C * n = 100 n = 2000 n = 5000</figDesc><table>Algorithm 2 
45 (1.0×) 
870 (1.0×) 
2153 (1.0×) 
Algorithm 3 
3.5 (13×) 
21 (41×) 
54 (40×) 
Algorithm 4 
0.63 (71×) 
18 (48×) 
49 (44×) 

C Algorithm 2 
3.8 (12×) 
7 .8 (110×) 
1 0 .3 (208×) 
Algorithm 3 
3.0 (15×) 
3 .5 (250×) 
3 .9 (546×) 
Algorithm 4 
0.14 (320×) 
0 .68 (1300×) 
1 .17 (1845×) 

The table indicates the time (in seconds) required to compute the CSPˆπCSPˆ CSPˆπ SMC (α|n) for 
|n|=n, per 1×10 5 loci. The speed-up versus Algorithm 2 with C = C T , equivalent to 

the commonly used Algorithm 1, is given in parentheses. 

</table></figure>

			<note place="foot">© The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank Anand Bhaskar and Matthias Steinrücken for fruitful discussion on both the theoretical and practical aspects of this work.</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Rapid and accurate haplotype phasing and missing data inference for whole genome association studies using localized haplotype clustering</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">L</forename>
				<surname>Browning</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">R</forename>
				<surname>Browning</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">81</biblScope>
			<biblScope unit="page" from="1084" to="1097" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Evidence for substantial fine-scale variation in recombination rates across the human genome</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">C</forename>
				<surname>Crawford</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="700" to="706" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">An approximate likelihood for genetic data under a model with recombination and population splitting</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Davison</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Popul. Biol</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="331" to="345" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Importance sampling on coalescent histories. I. Adv</title>
		<author>
			<persName>
				<forename type="first">De</forename>
				<surname>Iorio</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Griffiths</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">C</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Appl. Prob</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="417" to="433" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Importance sampling on coalescent histories. II: Subdivided population models</title>
		<author>
			<persName>
				<forename type="first">De</forename>
				<surname>Iorio</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Griffiths</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">C</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Appl. Prob</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="434" to="454" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">A linear complexity phasing method for thousands of genomes</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Delaneau</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="179" to="181" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Ancestral population genomics: the coalescent hidden markov model approach</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">Y</forename>
				<surname>Dutheil</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">183</biblScope>
			<biblScope unit="page" from="259" to="274" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Estimating recombination rates from population genetic data</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Fearnhead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Donnelly</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">159</biblScope>
			<biblScope unit="page" from="1299" to="1318" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Approximate likelihood methods for estimating local recombination rates</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Fearnhead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Donnelly</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Royal Stat. Soc. B</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="657" to="680" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">A novel method with improved power to detect recombination hotspots from polymorphism data reveals multiple hotspots in human genes</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Fearnhead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">G</forename>
				<surname>Smith</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">77</biblScope>
			<biblScope unit="page" from="781" to="794" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Estimating meiotic gene conversion rates from population genetic data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Gay</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">177</biblScope>
			<biblScope unit="page" from="881" to="894" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Importance sampling and the two-locus model with subdivided population structure</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">C</forename>
				<surname>Griffiths</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Appl. Probab</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="473" to="500" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Inferring human colonization history using a copying model</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Hellenthal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Genomic relationships and speciation times of human, chimpanzee, and gorilla inferred from a coalescent hidden markov model</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Hobolth</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">7</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">A flexible and accurate genotype imputation method for the next generation of genome-wide association studies</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">N</forename>
				<surname>Howie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">1000529</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Two-locus sampling distributions and their application</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">R</forename>
				<surname>Hudson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">159</biblScope>
			<biblScope unit="page" from="1805" to="1817" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Inference of population structure using dense haplotype data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Lawson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">1002453</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Inference of human population history from individual whole-genome sequences</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">475</biblScope>
			<biblScope unit="page" from="493" to="496" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Modelling linkage disequilibrium, and identifying recombination hotspots using SNP data</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Stephens</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">165</biblScope>
			<biblScope unit="page" from="2213" to="2233" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Mach: Using sequence and genotype data to estimate haplotypes and unobserved genotypes</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genet. Epidemiol</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="816" to="834" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">A new multipoint method for genome-wide association studies by imputation of genotypes</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Marchini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="906" to="913" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Fast &quot; coalescent &quot; simulation</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Marjoram</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Wall</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genet</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">16</biblScope>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">The fine-scale structure of recombination rate variation in the human genome</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">A T</forename>
				<surname>Mcvean</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">304</biblScope>
			<biblScope unit="page" from="581" to="584" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Approximating the coalescent with recombination</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">A</forename>
				<surname>Mcvean</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">J</forename>
				<surname>Cardin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Philos. Trans. R. Soc. Lond. B Biol. Sci</title>
		<imprint>
			<biblScope unit="volume">360</biblScope>
			<biblScope unit="page" from="1387" to="1393" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">A principled approach to deriving approximate conditional sampling distributions in population genetics models with recombination</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">S</forename>
				<surname>Paul</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<forename type="middle">S</forename>
				<surname>Song</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">186</biblScope>
			<biblScope unit="page" from="321" to="338" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">An accurate sequentially markov conditional sampling distribution for the coalescent with recombination</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">S</forename>
				<surname>Paul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">187</biblScope>
			<biblScope unit="page" from="1115" to="1128" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Sensitive detection of chromosomal segments of distinct ancestry in admixed populations</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">L</forename>
				<surname>Price</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">1000519</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">A fast and flexible method for large-scale population genotype data: applications to inferring missing genotypes and haplotypic phase</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Scheet</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Stephens</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="629" to="644" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Inference in molecular population genetics</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Stephens</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Donnelly</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. R. Stat. Soc. Ser. B Stat. Methodol</title>
		<imprint>
			<biblScope unit="volume">62</biblScope>
			<biblScope unit="page" from="605" to="655" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Accounting for decay of linkage disequilibrium in haplotype inference and missing-data imputation</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Stephens</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Scheet</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">76</biblScope>
			<biblScope unit="page" from="449" to="462" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Effect of genetic divergence in identifying ancestral origin using HAPAA</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Sundquist</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="676" to="682" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">Recombination rates in admixed individuals identified by ancestry-based inference</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Wegmann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="847" to="853" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">Joint estimation of gene conversion rates and mean conversion tract lengths from population SNP data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Yin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="231" to="239" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>