
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:47+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An algorithm for computing the gene tree probability under the multispecies coalescent and its application in the inference of population tree</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Yufeng</forename>
								<surname>Wu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of Connecticut</orgName>
								<address>
									<postCode>06269</postCode>
									<settlement>Storrs</settlement>
									<region>CT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An algorithm for computing the gene tree probability under the multispecies coalescent and its application in the inference of population tree</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btw261</idno>
					<note>Contact: ywu@engr.uconn.edu Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Gene tree represents the evolutionary history of gene lineages that originate from multiple related populations. Under the multispecies coalescent model, lineages may coalesce outside the species (population) boundary. Given a species tree (with branch lengths), the gene tree probability is the probability of observing a specific gene tree topology under the multispecies coales-cent model. There are two existing algorithms for computing the exact gene tree probability. The first algorithm is due to Degnan and Salter, where they enumerate all the so-called coalescent histories for the given species tree and the gene tree topology. Their algorithm runs in exponential time in the number of gene lineages in general. The second algorithm is the STELLS algorithm (2012), which is usually faster but also runs in exponential time in almost all the cases. Results: In this article, we present a new algorithm, called CompactCH, for computing the exact gene tree probability. This new algorithm is based on the notion of compact coalescent histories: multiple coalescent histories are represented by a single compact coalescent history. The key advantage of our new algorithm is that it runs in polynomial time in the number of gene lineages if the number of populations is fixed to be a constant. The new algorithm is more efficient than the STELLS algorithm both in theory and in practice when the number of populations is small and there are multiple gene lineages from each population. As an application, we show that CompactCH can be applied in the inference of population tree (i.e. the population divergence history) from population haplotypes. Simulation results show that the CompactCH algorithm enables efficient and accurate inference of population trees with much more haplotypes than a previous approach. Availability: The CompactCH algorithm is implemented in the STELLS software package, which is available for download at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Consider n gene lineages sampled from one population. When we trace these lineages backward in time, sooner or later two of these lineages will find a common ancestor. When this occurs, we say these two lineages coalesce or the coalescent of these two lineages occurs. Gene lineages coalesce in a stochastic way, which is influenced by multiple population genetic parameters, such as population sizes. Therefore, coalescents may potentially reveal important aspects of population evolution.<ref type="bibr" target="#b8">In 1982</ref><ref type="bibr" target="#b8">, Kingman (1982</ref>introduced the coalescent theory, which provides the analytical foundation for the study of coalescents. Since then, coalescent theory has quickly become a very active research subject in population genetics. There are numerous theoretical results in coalescent theory, along with many coalescent-based software tools. See Wakeley (2008) and<ref type="bibr" target="#b3">Hein et al. (2005)</ref>for an overview of the growing field of coalescent theory. While mathematically appealing, coalescent is known to be challenging computationally. One of the most important problems on coalescents is computing the coalescent likelihood. That is, we want to compute the probability of observing some population variation V C The Author 2016. Published by Oxford University Press.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i225</head><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/4.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com<ref type="bibr">Bioinformatics, 32, 2016, i225</ref>â€“i233 doi: 10.1093/bioinformatics/btw261 ISMB 2016 data under a coalescent model. However, coalescent likelihood is well known to be difficult under most formulations [see e.g.<ref type="bibr" target="#b3">Hein et al., 2005;</ref><ref type="bibr">Wakeley, 2008]</ref>. At present, there are few polynomial time algorithms for computing coalescent likelihood except under very restricted conditions. Almost all existing approaches for coalescent likelihood computation are based on statistical techniques such as Markov chain Monte Carlo (MCMC) or importance sampling (<ref type="bibr">Wakeley, 2008</ref>). These statistical approaches can be very useful in practice. However, from the computational point of view, these approaches cannot compute the exact coalescent likelihood. Moreover, approaches using MCMC tend to be very slow. Since coalescent likelihood is usually used in the inference of population evolution, accurate and efficient coalescent likelihood computation is highly desirable. Since the work by<ref type="bibr" target="#b8">Kingman (1982)</ref>, the basic coalescent has been extended to address more aspects of population evolution. The multispecies coalescent is one such extension, and is the focus of this article. Multispecies coalescent concerns the coalescents among gene lineages from multiple populations where coalescents may cross the population boundary. Multispecies coalescent is fundamental to population evolution (<ref type="bibr" target="#b1">Degnan and Salter, 2005;</ref><ref type="bibr" target="#b11">Rosenberg, 2002</ref>). Multispecies coalescent has also found applications in other domains, such as species tree inference [see, e.g.<ref type="bibr" target="#b4">Heled and Drummond, 2010;</ref><ref type="bibr" target="#b9">Mirarab et al., 2014;</ref><ref type="bibr" target="#b17">Wu, 2012]</ref>. A key computational problem on multispecies coalescent is the computation of the gene tree probability (<ref type="bibr" target="#b1">Degnan and Salter, 2005;</ref><ref type="bibr" target="#b17">Wu, 2012</ref><ref type="bibr" target="#b18">Wu, , 2015</ref>). Here, we are given a gene tree topology (without branch lengths) and a species tree (with branch lengths in the standard coalescent units). Note that the gene tree may not be bifurcating and there can be more than one gene lineages for a population (or taxon) in the gene tree. The gene tree probability is the probability of the gene tree topology as a result of the multispecies coalescent within the given species tree. There are only two existing algorithms for the exact gene tree probability computation. The first such algorithm is due to<ref type="bibr" target="#b1">Degnan and Salter (2005)</ref>. However, their algorithm has the exponential running time and there are no known cases of species and gene trees for which their algorithm runs in polynomial time. A much faster algorithm is given in<ref type="bibr" target="#b17">Wu (2012)</ref>, which is implemented in the program STELLS. However, the STELLS algorithm computes the gene tree probability in polynomial time only for some very special types of gene trees and species trees. We are not aware of any statistical approaches for computing the gene tree probability. The closest related approach is the MCMC approach in<ref type="bibr" target="#b4">Heled and Drummond (2010)</ref>, which is also based on multispecies coalescent. However, the likelihood computed in Heled and Drummond (2010) is for DNA sequences, not for gene trees. In this article, we present a new algorithm, called CompactCH, for computing the exact gene tree probability. The main advantage of CompactCH is that it runs in polynomial time for any gene tree topologies and species trees when the number of taxa (populations) is fixed to be a constant. That is, the CompactCH algorithm is efficient for gene tree topologies with large number of gene lineages if the number of populations is small (i.e. there can be many gene lineages from each population). Note that although the number of gene lineages in many phylogenetic studies tends to be relatively small, the number of gene lineages in large-scale genetic studies can be large. Therefore, CompactCH may become more useful when more gene lineages are sampled from a population which is the case in genetic projects such as the 1000 Genomes Project (2015). To the best of our knowledge, CompactCH is the first algorithm for computing the gene tree probability in polynomial time that allows arbitrary gene trees and species trees when the number of populations is fixed to a constant. Note that if gene tree topologies are considered to be observed, then the gene tree probability is the likelihood of the observed gene tree topologies given the species (population) tree. In this regard, the coalescent likelihood of gene tree topologies can be computed in polynomial time under the assumption of small number of populations. We show through theoretical analysis and empirical simulations that CompactCH outperforms the existing STELLS algorithm when the number of populations is small and the gene tree contains multiple gene lineages (alleles) per taxon. We also present a new method for the inference of population divergence history (called the population tree) from large population samples, which is based on the CompactCH algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Background</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Multispecies coalescent and incomplete lineage sorting</head><p>In this article, we use population and species interchangeably. Multispecies coalescent process (or just multispecies coalescent) concerns the coalescents of gene lineages that may occur outside the species boundary. See<ref type="figure">Figure 1</ref>for an illustration. Multispecies coalescent lies at the intersection of population genetics and phylogenetics, and has been widely used in phylogenetic and population inference [see e.g.<ref type="bibr" target="#b4">Heled and Drummond, 2010;</ref><ref type="bibr" target="#b17">Wu, 2012]</ref>. We use a rooted bifurcating tree T s (with branch lengths) to represent the population divergence history. We use a rooted tree topology T g to represent the genealogical history of gene lineages at a single locus. It is important to note that T g does not have branch lengths. Also T g may be multifurcating if the gene genealogy cannot be fully determined from the given genetic data. A common observation is that T s<ref type="figure">Fig. 1</ref>. A gene tree (in thin lines) in the species tree (in thick lines) shown in (a). Gene lineages a 1 , a 2 and a 3 originate from species A, b 1 and b 2 from B and c 1 from C. The species tree T s is shown separately in (b), so is the gene tree T g in (c). Internal nodes of both T g and T s are labeled. Coalescents: internal nodes of T g. Branches of trees are represented by their lower nodes i226 Y.Wu and T g do not always have the same topology. This phenomenon is called incomplete lineage sorting. We define the gene tree probability to be the probability of observing T g for a given T s under the multispecies coalescent model. Computing the probability of gene genealogies under multispecies coalescent is central both to phylogenetic inference of a species (or population) tree and to population genetic inference of gene flow between populations [e.g.<ref type="bibr" target="#b1">Degnan and Salter, 2005;</ref><ref type="bibr" target="#b4">Heled and Drummond, 2010;</ref><ref type="bibr" target="#b6">Hudson, 1983;</ref><ref type="bibr" target="#b11">Rosenberg, 2002;</ref><ref type="bibr" target="#b17">Wu, 2012</ref><ref type="bibr" target="#b18">Wu, , 2015</ref>. When T s and T g are small, simple closed-form formulas are known to calculate the gene tree probability (<ref type="bibr" target="#b6">Hudson, 1983;</ref><ref type="bibr" target="#b11">Rosenberg, 2002</ref>;<ref type="bibr" target="#b13">Takahata and Nei, 1985</ref>). When T g and T s become larger, computation by hand is no longer feasible and an algorithm is needed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Computing gene tree probability using coalescent history</head><p>Degnan and Salter (2005) gave the first algorithm for computing the gene tree probability of a gene tree topology T g and a species tree T s. Their algorithm is based on the notion of coalescent history. We give parts of technical details of their algorithm because our new algorithm is an improvement over their algorithm. In the following, we use the lower (i.e. closer to the leaves) node of an edge to refer to the branch in a tree T. For example, when we say branch g in<ref type="figure">Figure 1c</ref>, we mean the branch with lower node g in T g. Each internal node v in T g corresponds to a coalescent event between two lineages. For simplicity, we use v to also refer to the coalescent at v. For example, in<ref type="figure">Figure 1</ref>, the node g corresponds to a coalescent between lineages a 1 and a 2. A coalescent history determines, for each coalescent v in T g , on which species tree branch v occurs. In<ref type="figure">Figure 1a</ref>, for example, the embedded T g within T s corresponds to a coalescent history. In this history, coalescent g occurs on species tree branch A, p on D and h, q and r on E (the root branch). Note that the precise positions of these coalescents within T s are not important since T g does not have branch lengths and thus branches of T g may be stretched or shrunk as long as the coalescents occur within the same species tree branches. Degnan and Salter's algorithm enumerates all possible coalescent histories h for the given T g and T s. We denote the set of all coalescent histories for T g and T s as HÃ°T g jT s Ãž. We let m be the number of branches in T s and use an integer b 2 Â½1. .. mÂŠ to refer to a branch in T s. We let k b be the branch length of the branch b in T s. Then.Here, we call the number of gene lineages at the bottom (respectively top) of a species tree branch b the lower (respectively upper) lineage count of b and denote as u b (respectively v b ). Recall that a coalescent history h specifies along which species tree branch each coalescent occurs. Thus, when h is given, both the upper and lower lineage counts of each species tree branch are known. So we use u b Ã°hÃž and v b Ã°hÃž to refer u b and v b specified by h. For example, consider the branch A and let h be the coalescent history shown in<ref type="figure">Figure 1a</ref>. Then u A Ã°hÃž Â¼ 3 and v A Ã°hÃž Â¼ 2. p uv Ã°TÃž is the probability of u lineages coalesce into v lineages within time T (where T is the in the standard coalescent units). Equation (2) is a classic result (<ref type="bibr" target="#b13">Takahata and Nei, 1985;</ref><ref type="bibr" target="#b14">TavarÃ¨, 1984;</ref><ref type="bibr" target="#b15">Watterson, 1984</ref></p><formula>(2)</formula><p>The reason why there are terms w b Ã°hÃž d b Ã°hÃž in Equation (1) is that p uv Ã°TÃž does not impose the order of coalescents as specified in T g. For example, consider the coalescent history h shown in<ref type="figure">Figure</ref>iÃ°i Ã€ 1Ãž 2 :</p><formula>(3)</formula><p>The w b Ã°hÃž term is a little more complex. It is equal to the number of ways of coalescents on branch b as specified by h where these coalescents match the topology of T g. Note that there are c b Ã°hÃž Â¼ u b Ã°hÃž Ã€ v b Ã°hÃž coalescents on branch b. We denote these coalescents as C b Ã°hÃž. For convenience, we use c b Ã°hÃž to denote the number of coalescents along a species tree branch b. There are c b Ã°hÃž! ways of ordering these coalescents, but only a subset of these ways match T g. For each coalescent u 2 C b Ã°hÃž, let n u Ã°h; bÃž be the number of coalescents in C b Ã°hÃž that are within the subtree rooted at node u in T g. Here, u is included in the subtree. For example, we again consider the coalescent history h in<ref type="figure">Figure 1a</ref>. Then n r Ã°h; EÃž Â¼ 3 and n h Ã°h; EÃž Â¼ n q Ã°h; EÃž Â¼ 1. Note only coalescents within branch E are considered here and thus the coalescents p and g are not counted for n h Ã°h; EÃž and n q Ã°h; EÃž. Note that among all possible permutations of c b Ã°hÃž coalescents (with u being one of the coalescents), we want those with u be placed after the n u Ã°h; bÃž Ã€ 1 coalescents. There is precisely one out of n u Ã°h; bÃž permutations with this property. Then, we have (<ref type="bibr" target="#b1">Degnan and Salter, 2005</ref>):1 n u Ã°h; bÃž :</p><formula>(4)</formula><p>As an example, for the coalescent history h in<ref type="figure">Figure 1a</ref>,</p><formula>w E Ã°hÃž Â¼ c E Ã°hÃž! 1 nrÃ°h;EÃž</formula><p>However, except the simple caterpillar trees (or trees very similar to caterpillar), there are no known cases where STELLS can compute the gene tree probability in polynomial time. Usually the STELLS algorithm becomes slow when the sizes of T g and T s increase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The CompactCH algorithm for computing gene tree probability</head><p>We now present a new algorithm, called CompactCH, for computing the exact gene tree probability. CompactCH builds on Degnan and Salter's algorithm, and is very different from the STELLS algorithm. The key idea of the CompactCH algorithm is combining multiple coalescent histories into a compact coalescent history and thus making the computation in Equation (1) more efficient. For the ease of exposition, we assume gene trees are bifurcating unless otherwise stated. We will later extend to the multifurcating gene tree case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Gene tree probability computation using compact coalescent history</head><p>Since our algorithm involves a number of notations, we provide a list of notations in the Supplemental Materials. We first recall that Equation (1) is a summation of products over coalescent history h. Each product consists two terms for each species tree branch b: the coalescent factor term w b Ã°hÃž d b Ã°hÃž and the coalescent probability term p u b Ã°hÃžv b Ã°hÃž Ã°k b Ãž. The coalescent probability term only depends on the upper and lower lineage counts of the branch b. Suppose we group the coalescent histories with the same upper and lower lineage counts for every species tree branch into a compact coalescent history ch. Then all these histories will have the same coalescent probability terms. More precisely, a compact coalescent history is a list of upper lineage counts at all species tree branches (except the root branch). For example, consider the coalescent history shown in<ref type="figure">Figure 1a</ref>. We arrange the upper lineage counts for species tree branches in the order of A, B, C and D. Then the corresponding compact coalescent history ch is represented as: {2, 2, 1, 3}. That is, there are two, two, one and three gene lineages at the top of A, B, C and D, respectively. We denote the set of all possible compact coalescent histories for the given T g and T s as CHÃ°T g jT s Ãž. A compact coalescent history can be viewed as the combination of one or multiple coalescent histories. As an example, consider T g and T s in<ref type="figure">Figure 1</ref>. There are total seven compact coalescent histories as shown in<ref type="figure" target="#tab_1">Table 1</ref>. The compact history {2,2,1,3} combines two coalescent histories: the history shown in shown in<ref type="figure">Figure 1a</ref>and the history with h as the only coalescent occurring within branch D and p occurring within the branch E.</p><p>While a compact coalescent history only specifies the upper lineage counts, Lemma 3.1 shows that both upper and lower lineage counts as well as the number of coalescent events on all species tree branches (including the root branch) are all fully determined by a compact coalescent history. Lemma 3.1. The lower and upper lineage counts, and the numbers of coalescent events along all species tree branches are determined by a compact coalescent history.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof.</head><p>Recall a compact coalescent history specifies the numbers of gene lineages on top of each species tree branch (except the root branch). Note that for the root r, the upper lineage count v r is always one. This is because all gene lineages must coalesce into one lineage within the root branch. Consider a species tree branch b. If b is a leaf branch (i.e. one of the nodes of b is a leaf in T s ), its lower lineage count is equal to the number of sampled linages from this leaf, which is given as part of the input. This is because there is no time for coalescent to occur at a leaf of T s. Let b be an internal branch. Let Desc(b) be the set of descendant branches of T s (i.e. these branches are the outgoing edges from the lower node of b). For example, in<ref type="figure">Figure 1</ref>, DescÃ°EÃž Â¼ fC; Dg and DescÃ°DÃž Â¼ fA; Bg. Then, u b Â¼ P x2DescÃ°bÃž v x. This is because the lineages at the top of the descendant branches of b enter b from below. Thus, the set of lineages at the lower node of b is simply the merged set of the sets of lineages at the top of all b's descendant branches. Note that this merging process is instantaneous and there is no time for coalescent to occur. Note that the number of coalescents on b is simply equal to the difference between the lower and the upper lineage counts at b. Therefore, the number of coalescent events on b is fully determined by the compact history for all b. From Lemma 1, we use u b Ã°chÃž and v b Ã°chÃž to denote the lower and upper lineage count at branch b, and c b Ã°chÃž as the number of coalescents on b, which are specified by the compact coalescent history ch. We now consider Equation (1) again. Note that each coalescent history can be mapped to a compact coalescent history. For a compact coalescent history ch, let HÃ°chÃž be the set of coalescent histories combined in ch. We now group the coalescent histories in HÃ°chÃž together for each ch when applying Equation (1). Note that for all histories h in HÃ°chÃž, u b Ã°hÃž (respectively v b Ã°hÃž) are the same. Thus they have identical coalescent probability terms p u b Ã°chÃžv b Ã°chÃž Ã°k b Ãž terms in the summation over HÃ°chÃž. Moreover, we have the same 1 d b Ã°chÃž terms. This is because according to Equation (3), 1 d b Ã°hÃž only depends on u b Ã°hÃž and v b Ã°hÃž, which are identical for histories in HÃ°chÃž. This allows us to extract the common product of theCCH: compact coalescent history (the numbers are the numbers of upper lineage counts for species tree branches A, B, C and D). For each compact history, we give the number of coalescent histories that are merged into this compact history (denoted as #histories). i228 Y.Wu</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Efficient computation of coalescent coefficient</head><p>We first note in Equation (4), c b Ã°hÃž Â¼ u b Ã°hÃž Ã€ v b Ã°hÃž. Thus, for all h in HÃ°chÃž, c b Ã°hÃž can be written as the same c b Ã°chÃž. So,</p><formula>CÃ°chÃž Â¼ X h2HÃ°chÃž Y m bÂ¼1 c b Ã°hÃž! Y u2C b Ã°hÃž 1 n u Ã°h; bÃž Â¼ Y m bÂ¼1 c b Ã°chÃž! X h2HÃ°chÃž Y m bÂ¼1 Y u2C b Ã°hÃž 1 n u Ã°hÃž Â¼ Y m bÂ¼1 c b Ã°chÃž!C 1 Ã°chÃž: (6) In Equation (6), C 1 Ã°chÃž Â¼ P h2HÃ°chÃž Q m bÂ¼1 Q u2C b Ã°hÃž 1</formula><p>nuÃ°hÃž. Note that the species tree branch b is implicit in C 1 Ã°chÃž. In C 1 Ã°chÃž, the term 1 nuÃ°hÃž depends on specific h because the numbers of coalescents along species tree branches depend on h. When the number of h is large, direct summation of these 1 nuÃ°hÃž terms is inefficient. We now show C 1 Ã°chÃž can be computed efficiently using a recurrence. For the remaining part of this section, we consider a specific ch. Thus, we omit ch [e.g. by writing C 1 Ã°chÃž as C 1 and<ref type="bibr">HÃ°chÃž as H]</ref>. We consider each coalescent (internal node) c in T g. We denote the species tree branch on which c occurs as b c. We denote the number of coalescent events that are within the subtree of T g rooted at c and occur on b c as n c. We denote the set of species tree branches below (and including) b as BÃ°bÃž. That is, b 2 BÃ°bÃž. Here, c itself is considered to be within the subtree rooted at c and thus is included in n c. We denote S c as the set of species tree branches where the coalescent c may occur. For example, In<ref type="figure">Figure 1</ref>, BÃ°DÃž Â¼ fA; B; Dg and S g Â¼ fA; D; Eg. b h Â¼ E, b q Â¼ E, n r Â¼ 3 (including coalescents r, h and q) in the coalescent history shown in<ref type="figure">Figure 1a</ref>. We denote the list of the numbers of coalescents on each species tree branch as n. We define unit vector v i as the vector where v i Â½iÂŠ Â¼ 1 and v i Â½jÂŠ Â¼ 0 when j Â¼ i. For a specific integer list n of length m, we say n s is a sublist of n if 0 n s Â½iÂŠ nÂ½iÂŠ for all 1 i m. We denote the set of all possible sublists of n as SÃ°nÃž. For example, suppose n Â¼ Â½2; 2; 1; 3ÂŠ. Then a possible sublist is<ref type="bibr">[1,</ref><ref type="bibr">1,</ref><ref type="bibr">1,</ref><ref type="bibr">2]</ref>. For a coalescent c, a branch b s of T s and an integer list n, we define:</p><formula>C 2 Ã°c; b s ; nÃž Â¼ X h2H;bcÂ¼bs;ncÂ¼nÂ½cÂŠ Y b2BÃ°bÃž Y u2C b Ã°hÃž 1 n u Ã°hÃž :</formula><p>That is, C 2 Ã°c; b s ; nÃž restricts C 1 to the subtree rooted at c where c occurs on b s and the numbers of coalescents within the subtree rooted at c is n. We impose the following constraints for C 2 Ã°c; b s ; nÃž. If any of the constraints is violated, we have C 2 Ã°c; b s ; nÃž Â¼ 0. (1). n only specifies coalescent numbers for species tree branches in BÃ°b s Ãž (i.e. either at b s or within the subtree below b s Ãž: nÂ½bÂŠ Â¼ 0 for any b 6 2 BÃ°b s Ãž.</p><formula>(2)</formula><p>. There is at least one coalescent at b s : nÂ½b s ÂŠ ! 1. Moreover, b s 2 S c. We let b r be the root branch of T s and c r be the root of T g. Note that we assume there is at least one gene lineage from each species. Then c r must occur on b r. We have:</p><formula>C 1 Ã°chÃž Â¼ C 2 Ã°c r ; b r ; cÃ°chÃžÃž: (7)</formula><p>Here, cÃ°chÃž refers to the list of upper lineage counts implied by the compact history ch. We initialize the computation of C 2 Ã°c; b s ; nÃž for the coalescent c, where there is no coalescent within the subtree of T g rooted at c except c (i.e. c is the lowest coalescent in T g Ãž:Case 2: both immediate descendants c 1 and c 2 of c are internal nodes. In this case, we need to split n Ã€ v bs into two parts, one for c 1 and one for c 2. Then, we may sum over all such partitions and all possible species tree branches where c 1 and c 2 may occur.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The CompactCH algorithm for computing the gene tree probability</head><p>The CompactCH algorithm for computing the gene tree probability is as follows.</p><p>1. Enumerate and compute all coalescent coefficients for T g and T s as in Equations (8) or (9). 2. Enumerate all compact coalescent histories ch for T g and T s. The enumeration can be performed in a bottom-up way. Compute the terms p u b Ã°chÃžv b Ã°chÃž Ã°k b Ãž and d b Ã°chÃž for each species tree branch b. Obtain CÃ°chÃž using Equations (6) and (7). 3. Compute the gene tree probability by summing over all compact coalescent histories using Equation (5).CompactCH runs in polynomial time in the number of gene lineages when the number of populations is fixed to be a constant. The gene tree probability computation in Equation (5) depends on the number of compact coalescent histories N Ã°T g ; T s Ãž for the given T g and T s , which in turn depends on the number of gene lineages n and the number of species tree branches m. The main advantage of our new algorithm is that it runs in polynomial time when there are constant number of species. The algorithm is more efficient than the existing algorithms when there are multiple gene lineages per species. Thus, we assume m is fixed to a constant. We first show that N Ã°T g ; T s Ãž is polynomial in terms of n when m is a constant. We then show that coalescent coefficient is polynomial time computable for each compact history. First, recall that a compact coalescent history consists of a list of the upper lineage counts, one for each species tree branch. For a T s with m species tree branches, the length of this list is m â€“ 1, and at each position of the list the upper lineage count is at most n â€“ 1. So the number of choices for each position is n. Therefore, there are at most n mÃ€1 compact histories. When m is fixed to be a constant, this is polynomial in n. For each compact history, Equation (5) takes O(m) time. So, the total time is OÃ°mn mÃ€1 Ãž. We now show coalescent coefficient computation in Equation</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Analysis of the CompactCH algorithm</head><p>(6) runs in polynomial time for a given compact coalescent history ch in a bifurcating T g when m is a constant. These coalescent coefficients are pre-computed before Equation (5) is evaluated. By Equation (7), we need to show C 2 Ã°c r ; b r ; cÃ°chÃžÃž can be computed efficiently. Note that C 2 Ã°c r ; b r ; cÃ°chÃžÃž is computed using a recurrence over C 2 Ã°c; b; nÃž. Here, c is a coalescent in T g , b is a species tree branch and n is the list of coalescent counts (i.e. the number of coalescents) for the branches with the subtree of T s rooted at b. The number of such C 2 Ã°c; b; nÃž is bounded by Ã°n Ã€ 1ÃžmÃ°n Ã€ 1Ãž m , which is a polynomial of n when m is a constant. Each C 2 Ã°c; b; nÃž can be computed by Equations (8) or (9) in OÃ°m 2 Ã°n Ã€ 1Ãž m Ãž time. So, all coalescent coefficients can be computed in OÃ°nm 3 Ã°n Ã€ 1Ãž 2m Ãž time. Therefore, we have: Theorem 3.2. The CompactCH algorithm runs in OÃ°m 3 n 2mÃ¾1 Ãž time for a bifurcating T g , which is polynomial in n when the number of species in T s is a constant. REMARK. The CompactCH algorithm computes the gene tree probability runs in polynomial time in n when m is fixed to be constant. At the first glance, the CompactCH algorithm appears to be very slow: when m Â¼ 3 (i.e. two populations), the running time is OÃ°n 7 Ãž. In practice, CompactCH appears to be significantly faster than the STELLS algorithm when m is small. This is because we may overestimate the number of needed steps (e.g. for computing the coalescent coefficients).<ref type="figure" target="#tab_2">Table 2</ref>shows that when there are two populations, the CompactCH algorithm can remain practical when n is as large as 200 where the STELLS algorithm becomes very slow. See the Section 5 for empirical performance of this algorithm. It can be shown that STELLS runs in exponential time in the number of gene lineages when there two populations. See the Supplemental Materials for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Multifurcating gene trees</head><p>So far, gene trees are assumed to be bifurcating. The original STELLS algorithm (<ref type="bibr" target="#b17">Wu, 2012</ref>) and the algorithm in Degnan and Salter (2005) also assume bifurcating gene trees. Multifurcating gene trees, however, may be preferred for gene tree probability computation in some cases. For example, it is possible that some splits in the gene trees do not have sufficient support and thus multifurcating gene trees may be used to allow uncertainty in gene tree topologies. The STELLS algorithm was extended to allow multifurcating gene trees in Wu (2015). The STELLS algorithm is slower for multifurcating trees than bifurcating trees. Our new algorithm can be extended to compute the gene tree probability for multifurcating gene trees. Compact coalescent histories remain the same as the bifurcating gene tree case. For each species tree branch b, we specify the number of gene tree lineages at the top of b. Note that at a multifurcating gene tree node v of outdegree d, there are d Ã€ 1 coalescents at v. For a given compact coalescent history ch and a species tree branch b, the terms p u b Ã°chÃžv b Ã°chÃž Ã°k b Ãž and d b Ã°chÃž can all be easily computed as before. This is because these terms only depend on the numbers of gene lineages at specific positions of T s , which are fully determined by ch. These terms do not depend on the topology of T g. The main difference of the multifurcating gene tree case is on the coalescent coefficient computation. At a gene tree internal node c with out-degree d, recurrences in Equations (8) and (9) need to be modified. Let D c be the set of c's children in T g that are internal nodes. We let SÃ°D c Ãž be the set of all possible proper subsets of D c. We define C 3 Ã°c; b s ; S; nÃž for S 2 SÃ°D c Ãž, a branch b s of T s and an integer list n in the same way as C 2 Ã°c; b s ; nÃž when we treat the lineages in S form a new split in T g. Then, following the same reasoning as in Equations (8) and (9):</p><formula>C 2 Ã°c; b s ; nÃž Â¼ 1 nÂ½b s ÂŠ X S2SÃ°DcÃž;n 0 ; n 00 C 3 Ã°c; b s ; S; n 0 ÃžC 3 Ã°c; b s ; D c Ã€ S; n 0 0Ãž:</formula><p>Here, n 0 and n 00 are two integer lists which combine to n Ã€ v bs. Thus, coalescent coefficients for multifurcating T g can be computed in a recursive way, similar to the bifurcating case. The running time for coalescent coefficient computation depends on the maximum degree d max in T g. Since there are 2 dmax Ã€ 2 non-empty proper subsets for d max gene lineages, the algorithms becomes slow when d max is large. If d max is bounded by a constant, the gene tree probability for a multifurcating tree can be computed efficiently when the number of species is small.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Inference of population tree from haplotypes from pairwise population distance</head><p>In<ref type="bibr" target="#b18">Wu (2015)</ref>, we demonstrate that gene tree probability can be used in the inference of population tree (i.e. the population divergence history) when the given data is in the form of haplotypes.</p><formula>â€”) â€” (â€”) â€” (â€”) â€” (â€”) 4 &lt;1 (1) 1 (1) 1634 (218) â€” (â€”) â€” (â€”) â€” (â€”) â€” (â€”) â€” (â€”)</formula><p>Briefly, haplotypes contain the alleles (states) at closely linked genetic variation sites. See e.g.<ref type="bibr" target="#b18">Wu (2015)</ref>for some background on haplotypes. Assuming population haplotypes satisfy the infinite sites model of mutations (<ref type="bibr" target="#b7">Kimura, 1969</ref>) and no intra-locus recombination, we may infer the underlying genealogical tree topologies, although these trees are usually multifurcating [see, e.g.<ref type="bibr" target="#b2">Gusfield, 1991]</ref>. For a single locus, there is a unique gene tree topology and there are mutations on the branches of the gene tree. Under the infinite sites model of mutations and with no recombination, the probability of haplotypes is exactly equal to the probability of the unique gene tree with mutations [see, e.g.<ref type="bibr">Wakeley, 2008]</ref>. For the sake of computational efficiency, the approach in Wu (2015) uses the probability of the gene tree topology (i.e. ignoring mutations) to approximate the probability of haplotypes. The probability of gene tree topology is easier to compute than that of haplotypes and can be used to infer the population tree by maximum likelihood (<ref type="bibr" target="#b18">Wu, 2015</ref>). See Wu (2015) for more details. We use the same approximation in this article. In Wu (2015), we demonstrate that population tree inference with gene tree probability performs well when compared with the program TreeMix (<ref type="bibr" target="#b10">Pickrell and Pritchard, 2012</ref>). STELLS infers population trees by searching the tree space to find the maximum likelihood estimate of the population tree. However, one main computational challenge in Wu (2015) is the computational efficiency: population tree inference becomes slow when the numbers of taxa and hapotypes increase (see the Section 5). Genetic studies now routinely involve ten or more populations, and multiple haplotypes are collected from each population. For example, the 1000 Genomes Project (2015) recently released over 1000 genomescale haplotypes from more than 20 populations. Such large-scale genetic data imposes huge challenges for inference. In this article, we develop a new population tree inference method based on the CompactCH algorithm. This method is distance based, and does not perform maximum likelihood inference. The main idea of our method is (i) first infer the distance of pairs of two populations using haplotypes from the two populations, and (ii) construct the population tree using neighbor joining from the inferred pairwise population distances. The key is in the population distance estimate. There is exactly one population tree topology (i.e. population divergence history) of two populations A and B. With the haplotypes from A and B (and the implied gene genealogies), we can infer the branch lengths d A and d B. Here d A (respectively d B ) is the length of the branch connecting A (respectively B) and the common ancestor of A and B in the species tree of A and B. This can be done by optimizing d A and d B to maximize the gene tree probability of the genealogies. See<ref type="bibr" target="#b17">Wu (2012</ref><ref type="bibr" target="#b18">Wu ( , 2015</ref>) for more details. Once d A and d B are estimated, the pairwise distance between A and B is estimated to be d A Ã¾ d B. Then these pairwise distances are then used to infer the population tree of all populations by neighbor joining. The CompactCH algorithm enables fast pairwise population distance estimate from large number of haplotypes. In the Section 5, we demonstrate that this simple method can give accurate population tree inference using more haplotypes per population than the original method in Wu (2015) can handle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results</head><p>We have implemented our new CompactCH algorithm as part of the STELLS program (http://www.engr.uconn.edu/ywu/STELLS. html). We compare with the STELLS algorithm, which is currently the best algorithm for computing the gene tree probability. We first show that CompactCH outperforms the original STELLS when the number of species is small and there are multiple gene lineages per species. Then, as an application, we show that CompactCH allows fast and accurate inference of population trees from haplotypes when there are multiple haplotypes from each population.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Performance of CompactCH in gene tree probability computation</head><p>We evaluate the efficiency of CompactCH in computing the gene tree probability. We first set the number of populations m p to be two, three and four. We randomly generate species trees. We let the number of gene copies g c to be 1, 2, 5, 10, 20, 50 and 100. Note the total number of haplotypes n is g cm. We generate 500 bifurcating gene trees for a species tree using the program ms (<ref type="bibr" target="#b5">Hudson, 2002</ref>). The running times of using CompactCH and STELLS to compute the probability of these 500 gene tree topologies for each simulated species tree are shown in<ref type="figure" target="#tab_2">Table 2</ref>. Both algorithms are very slow on many settings where both m p and g c are large. So no results are collected on these settings. Here, we say the computation is too slow if the computation does not finish within 15 days on a 3192 MHz Intel Xeon workstation running Linux (with 32 GB memory). Our second simulation aims to investigating the efficiency with larger number of populations. We fix g c to be one, and then run CompactCH and STELLS on the data. The results are shown in<ref type="figure" target="#tab_3">Table 3</ref>. As expected, the STELLS is more efficient than CompactCH for larger number of populations. Overall, CompactCH is much faster than STELLS when m is relatively small and g c is relatively large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Using CompactCH in population tree inference from haplotypes</head><p>We run CompactCH and STELLS to infer population trees on simulated data. The design of simulations is similar to that in<ref type="bibr" target="#b18">Wu (2015)</ref>. Briefly, we generate simulated datasets as follows. We use randomly generated populations trees with m p populations to model the population divergence history. Here, we let m p to be eight. The population trees are the same as in<ref type="bibr" target="#b17">Wu (2012)</ref>. The length of each branch in the tree is assigned to a length that is uniformly chosen between 0.0 and 1.0. We then scale the population trees so that the trees satisfy clock property and the trees have fixed heights (being either 0.1 or 0.5). Note that CompactCH does not require clock-like population trees. The clock property is mainly for the ease of simulation, where we can reduce the number of parameter combinations. Then we simulate haplotypes for 100 loci from a given population tree using the program ms Hudson (2002), where there are g c gene lineages per species. Mutation parameters are fixed to be 20. We assume constant population size, no recombination within each locus and no migration between populations. Recall that the inferred genealogical tree topologies from haplotypes are usually multifurcating, and CompactCH becomes slow when the gene tree topologies have large degree at internal nodes. Thus, we discard gene trees with node degree larger than 10. We use the normalized Robinsonâ€“Foulds (RF) distanceAlgorithm for computing the gene tree probability i231 to measure the inference error in the topology. That is, for the inferred population tree topology T and the true tree T Ãƒ with n taxa, the normalized RF distance is bÃ°T ; T Ãƒ Ãž Â¼ jBÃ°T ;T Ãƒ Ãžj nÃ€3. Here, BÃ°T ; T Ãƒ Ãž is the number of splits in T Ãƒ but not in T. It has been demonstrated in<ref type="bibr" target="#b18">Wu (2015)</ref>that the inference of population trees from these inferred genealogical tree topologies can give accurate results. In<ref type="figure" target="#tab_4">Table 4</ref>, we show that more accurate inference results can be obtained by using the pairwise population distance approach (denoted as CompactCH) in Section 4 than the STELLS approach (denoted as STELLS), when more haplotypes are used. These simulations are conducted on a computer cluster. STELLS is more accurate than CompactCH when only two haplotypes are used for each population. The main advantage is that CompactCH is much more scalable than STELLS: STELLS takes more than 5 h on average for each dataset with two alleles per population. CompactCH only takes seconds in this case. Note that STELLS can be more accurate than the results by CompactCH because STELLS uses the maximum likelihood approach to search in the tree space while CompactCH builds trees from pairwise distances. The accuracy of CompactCH increases when more haplotypes are provided. For example, when 20 or more haplotypes per population are used for the population trees of height 0.1, the inference error of CompactCH is only about one-third of that of STELLS which uses two alleles per population. It appears CompactCH performs relatively better for the species tree of height 0.1 than those of height 0.5. We also note that CompactCH becomes slow if a large number of haplotypes are analyzed. For comparison, we also run TreeMix on these data. Our results indicate that CompactCH outperforms TreeMix in most of the cases, especially for the case of shorter species tree height.These gene trees are then used to infer the population trees. Here, we discard gene trees that have out-degrees at internal nodes of nine or larger because gene trees with large degrees greatly slow down the computation. We first infer the population tree for four populations: CEU, CHB, JPT and YRI. As expected, CHB and JPT are close siblings and in the population tree, and the ancestral population of CHB and JPT is the sibling of CEU. We then infer the population tree for all ten populations (which takes less than 2 h). The inferred neighbor joining tree is shown in<ref type="figure" target="#fig_7">Figure 2</ref>. Note that the tree should be viewed as an un-rooted tree. As expected, African, European and Asian populations cluster on the tree. The tree agrees mostly with the result in<ref type="bibr" target="#b18">Wu (2015)</ref>with small differences (e.g. the location of GBR).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Inference with the 1000 Genomes Haplotypes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Discussion and conclusions</head><p>In this article, we present the CompactCH algorithm for computing the gene tree probability under the multispecies coalescent model. While CompactCH is much faster than the STELLS when the number of populations is small, computing the exact gene tree probability for more populations remains a challenging task (<ref type="figure" target="#tab_2">Table 2</ref>). Nonetheless, we show in this article that efficient computation of gene tree probability for small number of (say two) populations can find applications in the inference of population history. We believe the CompactCH algorithm is a step forward for more efficient computation on coalescent models. The key idea of CompactCH is using compact coalescent histories. While merging multiple entities is a common idea in algorithm design, designing a working algorithm for coalescent computation based on this high-level idea is not trivial, as we show in this article. Our work suggests that coalescent computation can indeed be made more efficient by a well-designed algorithm<ref type="bibr">[see Wu (2010)</ref>for an algorithm that speeds up coalescent computation under a different formulation]. We note that coalescent histories (in particular the mathematical properties of coalescent histories) have been actively studied recently [see e.g.<ref type="bibr" target="#b12">Rosenberg 2013]</ref>. Our result presented here demonstratesAverage over 50 replicates. Eight populations. Inference error: normalized RF distance. Population tree height (Ht): 0.1 or 0.5. 100 loci. g c : number of haplotypes per population. Time: in seconds (s), minutes (m) and hours (h). Results for TreeMix are inside the parentheses. The original STELLS is only feasible for g c Â¼ 2 and so only the results for the g c Â¼ 2 case are provided for the original STELLS.that computation based on coalescent history can also be improved computationally. The CompactCH approach may also lead to speedup in coalescent computation in other formulations, where more complex coalescent models are used and computational efficiency is highly desirable. For example, the coalescent likelihood computed by MCMC in Heled and Drummond (2010) considers sequences, not the gene trees inferred from the sequences. Our techniques may be applied to speed up the computation of such likelihood.</p><p>Funding: This work is partly supported by US National Science Foundation grant<ref type="bibr">[IIS-0953563]</ref>. Parts of simulations are performed on a computer cluster that is supported under grant<ref type="bibr">[</ref></p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>1a. We have u E Ã°hÃž Â¼ 4 and v E Ã°hÃž Â¼ 1. Then, p 41 Ã°k E Ãž only requires four lineages coalesce to a single lineage within time k E , but does not impose the condition that g and b 1 must coalesce and also p and c 1 must coalesce. That is, p 41 Ã°k E Ãž allows, for example, the coalescent of g and c 1 , which violates the topology of T g. Degnan and Salter define d b Ã°hÃž as the number of all possible ways of coalescing u b Ã°hÃž lineages into v b Ã°hÃž lineages. Since any pairs of lineage can coalesce, we have (Degnan and Salter, 2005):</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>We call CÃ°chÃž the coalescent coefficient of ch. We now show for a given ch, its coalescent coefficient can be computed efficiently.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>If c is not the lowest coalescent, then c</head><figDesc>may have one or two children that are also internal nodes. Recall that we assume bifurcating gene trees in this section. We have two cases. Case 1: c 1 is the only descendant internal node. Note that if there are still more coalescents along b s (i.e. nÂ½b s ÂŠ ! 2), c 1 must also occur along b c. If there is only a single coalescent on b s , c 1 has to occur in some branch in BÃ°b s Ãž. Then:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>.</head><figDesc>(8) and (9) can be written in a more compact form because many terms contained in these two equations are zero. This is because many partitions of n lead to violations to constraints 1 and 2. The current exposition is a simplification to avoid overly complicated formula. EXAMPLE. To illustrate the process of computing the C 2 terms, we show how to calculate these terms for the compact history ch Â¼ f2; 2; 1; 3g in Figure 1a. We have cÃ°chÃž Â¼ f1; 0; 0; 1; 3g. Starting from the more recent (i.e. close to the extant time) coalescents,Then, C 1 Ã°chÃžÂ¼ C 2 Ã°r;E;f1;0;0;1;3gÃž is equal to 1 3 Ã°C 2 Ã°h;D;f1;0;0;1;0gÃžC 2 Ã°q;E;f0;0;0; 0;2gÃ¾ C 2 Ã°h;E;f1;0;0;0;1gÃžC 2 Ã°q;E;f0;0;0;1;1gÃžÂ¼ 0:5. Here, we omit all terms in C 2 calculations that are zero.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><figDesc>We use CompactCH to infer population trees with haplotypes from the 1000 Genomes Project (2015). We use haplotypes from the following ten populations in the 1000 Genomes Project: Han Chinese in Beijing, China (CHB), Japanese in Tokyo, Japan (JPT), Southern Han Chinese (CHS), Utah Residents with Northern and Western European ancestry (CEU), Toscani in Italia (TSI), Finnish in Finland (FIN), British in England and Scotland (GBR), Iberian population in Spain (IBS), Yoruba in Ibadan, Nigera (YRI), and Luhya in Webuye, Kenya (LWK). We use ten diploid individuals (i.e. 20 haplotypes) for each population. We choose the loci where there are few recombinations, and then construct gene trees from haplotypes within these loci. See Wu (2015) for details on how the loci are picked. We infer one gene tree topology from the haplotypes at each locus.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.2.</head><figDesc>Fig. 2. The inferred population tree from ten populations in the 1000 Genomes Project using 20 haplotypes from then individual per population. Branch length shown is the estimated time in coalescent units</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><figDesc>S10-RR027140] from National Institutes of Health. Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>) [also see Wakeley (2008) and Rosenberg (2002)] in coalescent theory which gives a closed form formula for calculating p uv Ã°TÃž.</figDesc><table>p uv Ã°TÃž Â¼ 
X u 

kÂ¼v 

e Ã€kÃ°kÃ€1ÃžT=2 Ã°2k Ã€ 1ÃžÃ°Ã€1Ãž kÃ€v 
v!Ã°k Ã€ vÃž!Ã°v Ã¾ k Ã€ 1Ãž 

Ã‚ 
Y 

kÃ€1 

yÂ¼0 

Ã°v Ã¾ yÃžÃ°u Ã€ yÃž 
Ã°u Ã¾ yÃž 
: 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. The list of all compact coalescent histories CHÃ°T g jT s Ãž for the trees T s and T g in Figure 1</figDesc><table>CCH 
#histories 

ch 1 
{3,2,1,5} 
1 
ch 2 
{3,2,1,4} 
2 
ch 3 
{3,2,1,3} 
2 
ch 4 
{3,2,1,2} 
1 
ch 5 
{2,2,1,4} 
1 
ch 6 
{2,2,1,3} 
2 
ch 7 
{2,2,1,2} 
1 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>We now analyze the running time of the CompactCH algorithm in Section 3.3. It can be shown that CompactCH runs in exponential time when the number of populations is unbounded. See the Supplemental Materials for more details. We now show that Algorithm for computing the gene tree probability i229</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 2. Running time of CompactCH (outside the parenthesis) and the STELLS algorithm (inside parenthesis) for computing gene tree probability for 500 simulated gene trees</figDesc><table>m p 
1 
2 
5 
10 
15 
20 
50 
100 

2 
&lt;1 (&lt;1) 
&lt;1 (&lt;1) 
1 (1) 
3 (7) 
20 (453) 
94 (21 516) 
21 974 (â€”) 
1 166 613 (â€”) 
3 
&lt;1 (&lt;1) 
1 (&lt;1) 
11 (5) 
2062 (18747) 
83 272 (</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Table 3.</figDesc><table>Running time of CompactCH (outside the parenthesis) and 
the STELLS algorithm (inside parenthesis) for computing gene tree 
probability for 50 simulated gene trees and g c Â¼ 1 (i.e. 1 allele per 
population) 

2 
3 
4 
5 
1 0 
1 5 

&lt;1 (&lt;1) 
&lt;1 (&lt;1) 
&lt;1 (&lt;1) 
&lt;1 (&lt;1) 
3 (1) 
208 (1) 

Columns: number of populations. Time: in seconds. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 4. Accuracy and time for inferring population trees using pairwise population distances</figDesc><table>Ht 
Accuracy/Time 
g c 

2 
4 
10 
20 
30 
0.1 
Inf. error 
0.38 (0.47) STELLS: 0.30 
0.20 (0.34) 
0.20 (0.24) 
0.11 (0.18) 
0.11 (0.16) 
Time 
8 s (44 h,18 m, 8 s) 
33 s 
21 m, 49 s 
7 h, 2 m, 4 s 
36 h, 42 m, 49 s 
0.5 
Inf. error 
0.23 (0.22) STELLS:0.14 
0.20 (0.15) 
0.10 (0.12) 
0.12 (0.14) 
0.12 (0.13) 
Time 
6 s (25 h, 30 m, 37 s) 
29 s 
7 m, 18 s 
1 h, 33 m, 5 s 
5 h, 56 m, 55 s 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="1"> n h Ã°h;EÃž 1 nqÃ°h;EÃž Â¼ 3! 1 3 1 1 1 1 Â¼ 2: The exact gene tree probability can be computed if all coalescent histories are enumerated for T g and T s. However, as shown in Degnan and Salter (2005), the number of coalescent histories grows rapidly when the sizes of T g and T s grow. In fact, when T g and T s have matching topology [assumed in most analytical results on coalescent history; see e.g. (Rosenberg, 2013)], there exists no known cases where lead to polynomial number of coalescent histories. Recently, an algorithm called STELLS was developed in Wu (2012). The STELLS algorithm is based on dynamic programming on a data structure called ancestral configuration (or AC). The STELLS algorithm is much faster than the algorithm by Degnan and Salter. Moreover, it is known that the number of ACs is bounded by a polynomial when T g and T s have matching topology and the topology is the maximal-asymmetric (i.e. caterpillar) tree. So in this special case, STELLS computes the gene tree probability in polynomial time. Algorithm for computing the gene tree probability i227 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Results are not given if it takes longer than 15 days. m p : number of populations. Columns: g c , the number of gene alleles per population. Time: in seconds. i230 Y.Wu at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">The 1000 Genomes Project Consortium (2015) A global reference for human genetic variation</title>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">526</biblScope>
			<biblScope unit="page" from="64" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Gene tree distributions under the coalescent process</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">H</forename>
				<surname>Degnan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">A</forename>
				<surname>Salter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolution</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="24" to="37" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title level="m" type="main">Efficient algorithms for inferring evolutionary history. Networks</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="19" to="28" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title level="m" type="main">Gene Genealogies, Variation and Evolution: A Primer in Coalescent Theory</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Hein</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Schierup</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Wiuf</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Oxford University Press</publisher>
			<pubPlace>UK.</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Bayesian inference of species trees from multilocus data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Heled</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">J</forename>
				<surname>Drummond</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="570" to="580" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Generating samples under the Wright-Fisher neutral model of genetic variation</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">R</forename>
				<surname>Hudson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="337" to="338" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Testing the constant-rate neutral allele model with protein sequence data</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">R</forename>
				<surname>Hudson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolution</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="203" to="217" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">The number of heterozygous nucleotide sites maintained in a finite population due to steady flux of mutations</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kimura</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="page" from="61" to="893" />
			<date type="published" when="1969" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">The coalescent</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">F C</forename>
				<surname>Kingman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Stochast. Process. Appl</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="235" to="248" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Astral: genome-scale coalescent-based species tree estimation</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Mirarab</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="541" to="548" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Inference of population splits and mixtures from genome-wide allele frequency data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">K</forename>
				<surname>Pickrell</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">K</forename>
				<surname>Pritchard</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">1002967</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">The probability of topological concordance of gene trees and species trees</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">A</forename>
				<surname>Rosenberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Popul. Biol</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="225" to="247" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Coalescent histories for caterpillar-like families</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">A</forename>
				<surname>Rosenberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1253" to="1262" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Gene genealogy and variance of interpopulational nucleotide differences</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Takahata</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Nei</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">110</biblScope>
			<biblScope unit="page" from="325" to="344" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Line-of-descent and genealogical processes, and their applications in population genetics models Coalescent Theory: An Introduction</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>TavarÃ¨</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Popul. Biol Wakeley,J</title>
		<imprint>
			<publisher>Roberts and Company Publishers</publisher>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="119" to="164" />
			<date type="published" when="1984" />
			<publisher>Roberts and Company Publishers</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Lines of descent and the coalescent</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">A</forename>
				<surname>Watterson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Popul. Biol</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="77" to="92" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Exact computation of coalescent likelihood for panmictic and subdivided populations under the infinite sites model</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Wu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="611" to="618" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Coalescent-based species tree inference from gene tree topologies under incomplete lineage sorting by maximum likelihood</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Wu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolution</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="page" from="763" to="775" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">A coalescent-based method for population tree inference with haplotypes</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Wu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="691" to="698" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<monogr>
		<title level="m" type="main">Algorithm for computing the gene tree probability i233</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>