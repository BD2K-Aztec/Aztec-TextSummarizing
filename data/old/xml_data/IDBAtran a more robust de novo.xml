
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:57+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">IDBA-tran: a more robust de novo de Bruijn graph assembler for transcriptomes with uneven expression levels</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2013">2013</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Yu</forename>
								<surname>Peng</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Henry</forename>
								<forename type="middle">C M</forename>
								<surname>Leung</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Siu-Ming</forename>
								<surname>Yiu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Ming-Ju</forename>
								<surname>Lv</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Shanghai Institutes for Biological Sciences</orgName>
								<orgName type="institution" key="instit1">CAS-MPG Partner Institute for Computational Biology</orgName>
								<orgName type="institution" key="instit2">Chinese Academy Sciences</orgName>
								<address>
									<postCode>200031</postCode>
									<settlement>Shanghai</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Xin-Guang</forename>
								<surname>Zhu</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Shanghai Institutes for Biological Sciences</orgName>
								<orgName type="institution" key="instit1">CAS-MPG Partner Institute for Computational Biology</orgName>
								<orgName type="institution" key="instit2">Chinese Academy Sciences</orgName>
								<address>
									<postCode>200031</postCode>
									<settlement>Shanghai</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Francis</forename>
								<forename type="middle">Y L</forename>
								<surname>Chin</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">The University of Hong Kong</orgName>
								<address>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">IDBA-tran: a more robust de novo de Bruijn graph assembler for transcriptomes with uneven expression levels</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">29</biblScope>
							<biblScope unit="page" from="326" to="334"/>
							<date type="published" when="2013">2013</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btt219</idno>
					<note>BIOINFORMATICS Availability: http://www.cs.hku.hk/$alse/idba_tran. Contact: chin@cs.hku.hk Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: RNA sequencing based on next-generation sequencing technology is effective for analyzing transcriptomes. Like de novo genome assembly, de novo transcriptome assembly does not rely on any reference genome or additional annotation information, but is more difficult. In particular, isoforms can have very uneven expression levels (e.g. 1:100), which make it very difficult to identify low-expressed isoforms. One challenge is to remove erroneous vertices/ edges with high multiplicity (produced by high-expressed isoforms) in the de Bruijn graph without removing correct ones with not-so-high multiplicity from low-expressed isoforms. Failing to do so will result in the loss of low-expressed isoforms or having complicated subgraphs with transcripts of different genes mixed together due to erroneous vertices/edges. Contributions: Unlike existing tools, which remove erroneous ver-tices/edges with multiplicities lower than a global threshold, we use a probabilistic progressive approach to iteratively remove them with local thresholds. This enables us to decompose the graph into disconnected components, each containing a few genes, if not a single gene, while retaining many correct vertices/edges of low-expressed iso-forms. Combined with existing techniques, IDBA-Tran is able to assemble both high-expressed and low-expressed transcripts and outperform existing assemblers in terms of sensitivity and specificity for both simulated and real data.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Recent development of massively parallel cDNA sequencing (RNA-Seq) provides a more powerful and cost-effective way to analyze transcriptome data. RNA-Seq has been used successfully to identify novel genes, refine 5 0 and 3 0 ends of genes, study gene functions (<ref type="bibr" target="#b3">Graveley, 2008</ref>), locate exon/intron boundaries (<ref type="bibr" target="#b9">Nagalakshmi et al., 2008;</ref><ref type="bibr" target="#b18">Trapnell et al., 2009</ref>) and estimate expression levels of isoforms (<ref type="bibr" target="#b6">Jiang and Wong, 2009</ref>). However, transcriptome reconstruction (the reconstruction of all expressed transcripts) from RNA-seq data remains a challenging unresolved problem when there is splicing, i.e. when different combinations of regions (exons) of a single gene are decoded to multiple transcripts (isoforms) (<ref type="bibr" target="#b19">Trapnell et al., 2010</ref>). Currently, there are two computational approaches to solve this problem. Alignment-based methods, such as Cufflinks (<ref type="bibr" target="#b19">Trapnell et al., 2010</ref>) and Scripture (<ref type="bibr" target="#b4">Guttman et al., 2010</ref>), first align reads to reference genomes using splice junction mappers, such as TopHat (<ref type="bibr" target="#b18">Trapnell et al., 2009</ref>), to identify exonintron boundary and then build a graph in which exons are the nodes and two exons are connected if reads connect them. Cufflinks (<ref type="bibr" target="#b19">Trapnell et al., 2010</ref>) attaches weights to edges and models the isoform reconstruction problem as a minimum path cover problem, while Scripture (<ref type="bibr" target="#b4">Guttman et al., 2010</ref>) creates a statistical model to identify significant segments as isoforms. In contrast, de novo assembly methods, such as Trinity (<ref type="bibr" target="#b2">Grabherr et al., 2011</ref>), Oases (<ref type="bibr" target="#b13">Schulz et al., 2012</ref>), Trans-Abyss (<ref type="bibr" target="#b12">Robertson et al., 2010</ref>) and T-IDBA (<ref type="bibr" target="#b10">Peng et al., 2011</ref>), assemble transcripts directly from reads. Alignment-based transcriptome assembly methods, which rely on reference genomes and additional annotation information, may suffer from missing/erroneous information. Also, the quality of these methods depends heavily on the accuracy of the alignment tools (<ref type="bibr" target="#b18">Trapnell et al., 2009</ref>), which is also complicated by splicing and sequencing errors. As RNA-Seq technology becomes more mature, there will be an increasing need to reconstruct unknown transcriptomes without reference genome information, and de novo transcriptome assembly will become increasingly more important. Difficulties: At first glance, the de novo transcriptome assembly problem looks similar to the de novo genome assembly problem. In fact, many existing methods for de novo transcriptome assembly, like genome assembly, apply the de Bruijn graph approach with fragments of transcripts being simple paths in graph, in which a vertex is a k-mer and an edge exists between two vertices u and v if u and v appear consecutively in a read. However, two main aspects make the two assembly problems different. (1) Exons shared by multiple isoforms. In this paper, we focus on transcriptome assembly for eukaryotes with splicing since, without splicing, the problem is much easier. Consider the example (LOC_Os10g02220 from rice) in<ref type="figure">Figure 1</ref>. A to I represent different exons forming 5 isoforms (in red). Shared exons (e.g. D and H) look like repeats, and most genome assemblers try to resolve repeats at the branch level, i.e., each branch needs to be supported by paired-end reads. In our case, since all five isoforms are real, branches BD and CD as well as DE and DF will be supported. Some assemblers may stop at the junctions, reporting B, C, D, E and F as separate (short) contigs or falsely regard CDE as a transcript (provided both CD and DE have enough support). For example, running Velvet on the rice data *To whom correspondence should be addressed. ß The Author 2013. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com (see Section 3.2 for details) results in contigs of mean length 245 bp only, while the mean length of transcripts is about 1700 bp. Some metagenomic (<ref type="bibr" target="#b0">Bankevich et al., 2012</ref>) and single-cell assemblers (<ref type="bibr" target="#b20">Vyahhi et al., 2012</ref>) try to find a path with maximum paired-end reads support; however, as the insert distance of transcriptome data usually cannot cover more than one branch (splicing junction) and there are multiple correct paths (isoforms) with paired-end reads support, these assembliers also fail to reconstruct the isoforms. (2) Different expression levels of isoforms of the same gene. Isoforms of the same gene may have very different expression levels. There are two problems. First, low-expressed isoforms may have little support from reads and thus are missed by the assembler. For example, in<ref type="figure">Figure 1</ref>, if there are only a few paired-end reads supporting branch BD and FH, isoform ABDFH is unlikely to be obtained. Second, support from reads of erroneous k-mers from high-expressed transcripts may be higher than that of correct k-mers from low-expressed transcripts. These erroneous k-mers introduce branches in the de Bruijn graph and make the graph very complicated.<ref type="figure" target="#fig_2">Figure 2</ref>shows an example from a real rice transcriptome dataset (LOC-Os12g12850). This subgraph (k ¼ 50) is supposed to contain only two isoforms (<ref type="figure" target="#fig_2">Fig. 2a</ref>shows the conceptual view of the isoforms). There are 92 353 and 90 126 erroneous k-mers and branches respectively in the de Bruijn graph (<ref type="figure" target="#fig_2">Fig. 2b</ref>) when we simulated reads with 1% sequencing error (details shown in Section 3). Existing approaches usually employ a global threshold to remove erroneous k-mers and branches if the multiplicities of these components are smaller than the threshold. This simple approach will not work for transcriptome data. Since the error positions of each read are known, we can count the number of correct and erroneous k-mers for simulated data on rice (Section 3.1) for different multiplicities (<ref type="figure" target="#fig_2">Fig. 2c</ref>). No matter how we set the threshold of multiplicity for removing erroneous k-mers (draw a vertical line and consider all k-mers on the left with lower multiplicities as erroneous k-mers), some erroneous kmers will remain and correct k-mers will be removed. These complicated components will make isoform finding extremely difficult as there are many paths to be considered. In the ideal case, the de Bruijn graph should have many isolated components, each representing isoforms from one gene unless there are repeats in different genes. In most cases, the structure of the component should be simple as most genes do not contain many isoforms. To tackle this issue, we need a method to separate components that are falsely connected by erroneous k-mers and we need to remove erroneous k-mers from each component.</p><p>Existing solutions: Oases (<ref type="bibr" target="#b13">Schulz et al., 2012</ref>) and Trinity (<ref type="bibr" target="#b2">Grabherr et al., 2011</ref>) are two popular de novo transcriptome assemblers for RNA-Seq data. In order to solve the splicing problem<ref type="bibr">[Issue (1)</ref>], both apply a dynamic programming approach to identify potential paths in the graph, which are supported by many reads or paired-end reads. In other words, they try to identify isoforms more globally through a path-level analysis instead of a local branch-level analysis. The results are much better than those of genome assemblers. However, since the problem is NP-complete (proved in the Supplementary Appendix), the running time of the dynamic programming approach increases exponentially with the number of branches in the de Bruijn graph. Due to Issue (2), erroneous reads sampled from high-expressed transcripts introduce many branches (with more support than reads sampled from low-expressed transcripts) and thus dynamic programming takes a long time. In practice, these tools fall back on heuristic search instead of dynamic programming for large components. To tackle Issue (2), T-IDBA (<ref type="bibr" target="#b10">Peng et al., 2011</ref>) uses another approach to isolate components. Based on the observation that transcripts from different genes share less common vertices when k value is large, T-IDBA builds a de Bruijn graph from small k and iteratively updates the graph with larger k values. It then finds transcripts in the de Bruijn graph with large k value where transcripts from the same gene usually form a single component. However, it does not perform very well for low-expressed transcripts because there are more missing k-mers when k is large. There is no dedicated solution in T-IDBA that solves the issue of erroneous k-mers within a component and methods for isolating components are not sensitive to low-expressed isoforms. To recover low-expressed transcripts, several post-processing methods (<ref type="bibr" target="#b12">Robertson et al., 2010;</ref><ref type="bibr">Surget-Groba and MontoyaBurgos, 2010</ref>) were developed for Velvet (<ref type="bibr" target="#b21">Zerbino and Birney, 2008</ref>) and Abyss (<ref type="bibr" target="#b14">Simpson et al., 2009</ref>). They are all based on the observation that lower k values make the assembler more sensitive to low-expressed transcripts, while larger k values make it more specific to high-expressed transcripts. In order to combine the advantages of different values of k, the resultant contigs, generated by different k-mer lengths independently, are merged together. However, merging assembly results from different runs is not a straightforward task. Although output transcripts are clustered and duplicated transcripts are removed, many duplicates are difficult to detect and errors can accumulate in the cluster-remove step. As a result, multiple contigs with errors are generated for the same transcripts and the number of resulting contigs is much more than the number of expressed transcripts. Oases-M, an extension of Oases, makes use of multiple k to improve its assembly result and is now the best tool using this approach. However, since the fundamental problem of removing erroneous vertices from high-expressed isoforms while keeping correct vertices from low-expressed isoforms is not solved, there are still many false positives as well as duplicated transcripts (Section 3). Some single-cell genome assemblers (<ref type="bibr" target="#b1">Chitsaz et al., 2011;</ref><ref type="bibr" target="#b11">Peng et al., 2012</ref>) also have a problem with uneven multiplicities of correct k-mers. They resolve the problem based on the assumption that, although the multiplicities of these erroneous k-mers are high, their multiplicities should be lower than the nearby correct k-mers. Thus, they calculate a local threshold, based on<ref type="figure">Fig. 1</ref>. Example of de Bruijn graph for five isoforms from the same gene i327 IDBA-tran the multiplicities of nearby k-mers or contigs, for removing erroneous k-mers. However, as a k-mer representing the common exon of several expressed isoforms can have relatively higher multiplicity than nearby correct k-mers (<ref type="bibr" target="#b5">Li and Jiang, 2012</ref>), calculating the local threshold from only one or two nearby kmers or contigs may be misleading and the algorithms may remove many correct k-mers near these high multiplicity k-mers. Our contributions: If Issue (2) can be resolved, Issue (1) can be tackled by existing path-level analysis as the components will be simple enough. Thus, our core contribution is handling Issue (2). As mentioned before, the traditional filtering method of using one single global threshold for multiplicity cannot separate correct k-mers sampled from low-expressed transcripts from erroneous k-mers sampled from high-expressed transcripts, and single-cell genome assemblers calculating local thresholds from nearby k-mers may remove many correct k-mers. Thus, we propose a probabilistic progressive approach to solve this problem. Our proposed assembler IDBA-Tran calculates the probability that a k-mer or short simple path (contigs) contains error using not only the multiplicity of the k-mer or contig (or their neighboring k-mers or contigs) but also uses a multi-normal distribution to model the multiplicities of all k-mers in the whole connected component. Based on the multi-normal distribution and the contig length (as a short simple path is more likely to have error than a long one), IDBA-Tran calculates a local threshold for determining whether a k-mer or contig has error. By progressively removing erroneous k-mers, connected components representing isoforms from a single gene are identified. Since we successfully remove many erroneous k-mers, the size of each component is small. We can employ a path-level analysis (similar to Oases and Trinity) to identify transcripts from each component<ref type="bibr">[Issue (1)]</ref>. Thus IDBA-Tran can perform better than Oases and Trinity, producing more contigs, particularly for lowexpressed transcripts. Results show that IDBA-Tran outperforms other de novo transcriptome assembly approaches in terms of both sensitivity and specificity for both simulated and real data. IDBA-Tran also makes use of other techniques used in genome assemblers, such as tips pruning, path merging and error correction.<ref type="figure" target="#fig_4">Figure 3</ref>shows the workflow of IDBA-Tran for assembling a set of paired-end reads. In the first iteration when k ¼ k min , H k is equivalent to a de Bruijn graph for vertices whose corresponding k-mers have multiplicity of at least m (2 by default) times in all reads. During all subsequent iterations, sequencing errors are first removed according to the topological structure of H k in a slightly different way to other assemblers (Section 2.1). The tips (dangling paths in H k of length shorter than 2k) are likely to be false positives (<ref type="bibr" target="#b8">Li et al., 2010;</ref><ref type="bibr" target="#b14">Simpson et al., 2009;</ref><ref type="bibr" target="#b21">Zerbino and Birney, 2008</ref>). Similar paths (bubbles) representing very similar contigs with the same starting vertex and ending vertex are likely to be caused by errors or SNPs and they should be merged (<ref type="bibr" target="#b8">Li et al., 2010;</ref><ref type="bibr" target="#b14">Simpson et al., 2009;</ref><ref type="bibr" target="#b21">Zerbino and Birney, 2008</ref>). Then, the depth information for contigs and components is used to decompose the graph into components (Section 2.2). Paths with high support for the paired-end reads are reconstructed as transcripts in each component (Section 2.3). Errors in the assembled contigs are corrected by aligning reads to the contigs (Section 2.4). When constructing H kþs from H k , each length s þ 1 path in H k is converted into a vertex ((k þ s)-mer) and there is an edge between two vertices if the corresponding (k þ s þ 1)-mer appears f (1 by default) times in reads or once in contigs in C k [LC k [T k , where C k represents the set of contigs, LC k is the set of contigs constructed by local assembly using paired-end information (Section 2.5), and T k is the set of transcripts when considering H k. In the following subsections, we describe each step of IDBA-Tran in detail.each branch in the graph, IDBA-Tran checks each outgoing (and incoming) edge, keeps the branch which leads to the longest path, and removes all other branches (tips) which lead to paths shorter than 2k. Usually, the correct branch leads to longer paths than tips, and this method preserves correct branches. As transcriptome sequencing data contains more errors and insertions/ deletions than genome sequencing data, IDBA-Tran identifies and merges paths with same starting point and end point and higher than 98% similarity (including insertions and deletions).</p><formula>.. A … G … E … F … I .. H … B … C … D</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Pruning short tips and merge similar path</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Decomposing the graph by iterating depth</head><p>Recall that T-IDBA (<ref type="bibr" target="#b10">Peng et al., 2011</ref>) also tries to decompose the de Bruijn graph into components. It is based on the observation that there are not many repeat patterns between two transcripts from different genes while isoforms from the same gene share common exons. Thus, it decomposes the graph into different components such that there are relatively more branches inside each component and relatively fewer branches between two components. However, erroneous k-mers (from high-expressed isoforms) still cannot be removed effectively since components representing isoforms from different genes may be connected by these erroneous kmers to form a very large component preventing the assembler from determining isoforms in the component. Instead of considering the number of branches for decomposing the de Bruijn graph into components, IDBA-Tran detects and removes erroneous paths connecting two components by considering the lengths and sequencing depths (depths in short) of the paths using a probabilistic approach. The depth of a path (contig) is the average multiplicity of the k-mer on the path. Long contigs (simple paths in the de Bruijn graph) are usually correct, because long simple paths are unlikely to be formed by erroneous reads, and similarly for high-depth contigs which have supports from many reads. For a contig, whether its length is long or short and whether its depth is high or low cannot be judged by absolute values as the length of a contig depends on the value of k and the depth of a contig depends on the depths of neighboring contigs (contigs in the same component). Since erroneous contigs in high-depth regions may have higher depths than correct contigs in low-depth regions, short (5l) and relatively low-depth contigs are likely to be erroneous and can be removed. The removal takes place in an iterative manner (<ref type="bibr" target="#b1">Chitsaz et al., 2011;</ref><ref type="bibr" target="#b11">Peng et al., 2012</ref>), because after some low-depth errors are removed, some short lowdepth contigs may be connected together to form long contigs. Increasing depth cutoff progressively may help to preserve more lowdepth correct contigs. IDBA-Tran removes contigs (simple paths) shorter than l with average sequencing depth lower than where is a threshold calculated based on value of l and the depth distribution of the connected component which contains the contig. When is large, many correct contigs are removed and many true positive transcripts cannot be assembled. When is small, many erroneous contigs are not removed and transcripts from different genes may form a large component such that correct transcripts are difficult to reconstruct in later steps (Section 2.3). Thus, we should select the largest threshold such that not too many correct contigs are removed, say 51%. Consider a correct exon with length at least l. It should be represented by a simple path P in the de Bruijn graph. However, as there are sequencing errors in reads, there may be branches in P and simple path P may be broken into several shorter paths with length less than l. Consider a particular edge u!v in P with the corresponding k-mer v sampled x times (some may contain errors). There is another edge u!v' in the de Bruijn graph if at least m (the multiplicity threshold used for removing erroneous k-mers) out of the x k-mers sampled from v having the same error at the last nucleotide, i.e. v and v' differ by the last nucleotide, thus introduces branching at u. This probability can be calculated as follows. Assume the probability of a sequencing error per base is e and the probabilities that the erroneous base is changed to each other nucleotide are the same, i.e. 1/3. Although this simple assumption is not correct for real biological data, the calculation can be readily refined for different probabilities. The probability that v is sampled as v' with the last nucleotide changed to a particular nucleotide, say 'A', is</p><formula>p err ¼ e 3 ð1 À eÞ kÀ1</formula><p>As v can be sampled with error as v', i.e. at least m of the x samples have the same error at the last nucleotide. Since there are three possible v', the existence probability of v' (probability of branching at u) isIn order to estimate the value of depth x, we use a multi-normal distribution to model the depth distribution of a component as there can be multiple isoforms, say t, in a component. Given a set of k-mers with different multiplicities in the same component, we assume the multiplicities of the k-mers are sampled from t normal distributions. Although the mean and standard deviation of each normal distribution can be estimated by expectation-maximization algorithm (<ref type="bibr" target="#b17">Tanaseichuk et al., 2012</ref>), the time is too long because there are many k-mers and components. Thus IDBA-Tran applies an approximation by clustering the k-mers based on their multiplicities (the distance between two k-mers equals their difference in multiplicities) using K-means clustering method. The mean and standard deviation can then be calculated for each cluster. We set t ¼ 3 in the experiments based on the assumption that there are at most 3 transcripts in each components (at the final step). Let N(, ) be a normal distribution of depth with minimum mean depth value. The probability that we wrongly remove a correct contig with average depth is at most P false positive ð Þ ¼ 1 ffiffiffiffiffiffiffiffiffiffi</p><formula>P m, x, p err ð Þ¼3P ! 1 v 0 exist ð Þ À 3P ! 2 v 0 exist ð Þ þ P 3 v 0 exist ð Þ ¼ 3 X</formula><formula>¼ 3 X xÀm i¼0 C xÀmÀiþ2 2 p xÀi err 1 À p err ð Þ i À3 X xÀ2m i¼0 C xÀ2mÀiþ2 2 p xÀi err 1 À p err ð Þ i þ X xÀ3m i¼0 C xÀ3mÀiþ2 2 p xÀi err 1 À p err ð Þ</formula><formula>2 2 p À1 e ÀðxÀÞ 2 2 2 Á 2lPðm, x, p err Þdx</formula><p>Note that for an exon of length at least l of sequencing depth x, the probability of branching is 2lPðm, x, p err Þ. The value of l should be selected based on the length of exons. If a very large l is selected, true positive k-mers and paths are removed. If a very small l is selected, most true negative k-mers and paths cannot be removed. We should select different values for l depending on the properties of the data (we use l ¼ 2k in the experiments). Once l is selected, we can calculate the largest such that P(false positive) is lower than some value, say 1%, so as to remove most erroneous contigs without too many false positives. Algorithm 1 shows the pseudocode for the decomposing step. According to (<ref type="bibr" target="#b10">Peng et al., 2011</ref>), when the size of the component is small (with ¼ 30 contigs), the component is likely to represent isoforms from a single gene and we can use a very low depth threshold ¼ 0.1 Â T(comp), where T(comp) is the average depth of connected component comp, to prevent removing correct contigs. The filtering depth cutoff threshold t is increased by a factor of progressively (10% by default). In each iteration, short contig c is removed if its depth T(c) is lower than the minimum of cutoff threshold t and the depth threshold .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Finding transcripts</head><p>Algorithm 1. Progressive-Component-Depth(G, k) t 1 repeat until t4max c2G T(c) for each component comp in G if size(comp)4&#x0D;, then calculate , else 0.1 Â T(comp) for each contig c in comp if len(c)52k and T(c)5min(t, ) remove c from G t t Â (1 þ )</p><p>For each connected component in the de Bruijn graph, IDBA-Tran discovers those paths starting from a vertex with zero in-degree to a vertex with zero out-degree with the highest support from paired-end reads. A path is supported by paired-end reads if the paired-end reads can be aligned to the path with the distance between the aligned positions matching the insert distance of the paired-end reads. The problem definition can be simplified as follows<ref type="bibr">[</ref></p><formula>¼ {(v i , v j )}, v i , v j 2</formula><p>V, an insert distance d and error s, find t paths in G with the maximum number of supporting paired-end reads P' P. A path p has a supporting paired-end read (v i , v j ) iff p contains vertices v i and v j and the distance between v i and v j in p is between d – s and d þ s. Since the TD problem is a NP-hard problem (see Supplementary Appendix), IDBA-Tran performs a heuristic depth-first search to find paths from a zero in-degree vertex to a zero out-degree vertex with maximum supporting paired-end reads. At each branch, the path with many supporting paired-end reads will be considered before other paths. In practice, IDBA-Tran reports at most t max (default 3) potential transcripts for each zero in-degree vertex in each connected component. IDBA-Tran applies a seed and extend method for aligning reads to contigs (paths in de Bruijn graph). k-mers in a read appearing in the de Bruijn graph is considering as potential aligned position and IDBA-Tran will try to extend both ends of alignment considering substitution error only. Note that insertion and deletion error can be implemented in IDBATran easily. However, as the number of substitution errors appears much more than the insertion/deletion errors, IDBA-Tran considers substitution error only for speeding up the alignment process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Error correction</head><p>The error correction step is performed on reads and assembled contigs during the assembling process. At first, reads are aligned to each contig. The consensus of the aligned reads will replace the original contig, i.e. positions of the contig inconsistent with the majority of aligned reads will be corrected. Then aligned reads are corrected according to the aligned position in contigs, i.e. positions in the reads with nucleotides inconsistent with the consensus will be corrected. This error correction step can reduce the number of erroneous reads and branches in the de Bruijn graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Local assembly</head><p>Let C be the set of contigs. We extract the beginning and end of each contig c in C to form a set of contigs C'. Assume the insert distances of paired-end reads satisfy the normal distribution N(d, ). IDBA-Tran performs local assembly (<ref type="bibr" target="#b11">Peng et al., 2012</ref>) on the last d þ 3 bases of each end of the contig and the paired-end read with one end aligned to it. Since those reads which are far away from contig c will not mix with reads with one end aligned to c, some missing k-mers can be reconstructed and the contigs can be extended longer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Estimating expression levels</head><p>Since IDBA-Tran is designed for assembling reads to reconstruct expressed transcripts, sophisticated algorithms can be then applied to estimate the expression levels of each transcript. IDBA-Tran also provides an estimated expression level for each transcript by aligning reads to the transcript. RPKM (Reads Per Kilobase per Million mapped reads) is estimated by dividing the total length of reads uniquely aligned to a transcript by the total length of regions of transcript uniquely aligned by reads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>To evaluate the performance of IDBA-Tran, experiments were carried out on both simulated and real data. We compared IDBA-Tran with the latest transcriptome assemblers Trinity (<ref type="bibr" target="#b2">Grabherr et al., 2011</ref>) and Oases (<ref type="bibr" target="#b13">Schulz et al., 2012</ref>). We also compared IDBA-Tran with the single-cell genome assembler IDBA-UD (<ref type="bibr" target="#b11">Peng et al., 2012</ref>) and Velvet-SC (<ref type="bibr" target="#b1">Chitsaz et al., 2011</ref>), which apply multiple depths when assembling genomes. IDBA-Tran and IDBA-UD were run with k ranging from 20 to 50 with step size 5. For Oases and Velvet-SC, k values ranging from 20 to 50 with step size 5 were used, and the best result was selected as output. As the k value of Trinity was fixed to 25, the default parameters were used to run it.For transcriptome assembly, the most important indicator of assembly quality is the number of correct transcripts an assembler can reconstruct. In the experiments, known transcript references were used for benchmarking. A known transcript is reconstructed successfully if a certain portion, say 80% (referred as completeness), of its sequence is covered by a contig with 95% similarity. Similarly, the contig is considered correct if it can be aligned to at least 80% of a transcript with 95% similarity. The alignment of contigs to transcripts was performed by BLAT (<ref type="bibr" target="#b7">Kent, 2002</ref>) without considering long gaps representing introns (as we aligned contigs to transcripts instead of genome). The sensitivity and specificity were calculated to measure performance. Sensitivity is the percentage of reconstructed transcripts over all expressed transcripts. Specificity is the percentage of correct contigs over all reported contigs. We also compared the performance of IDBA-Tran and CEM (<ref type="bibr" target="#b5">Li and Jiang, 2012</ref>) on estimating expression levels of reconstructed transcripts. CEM requires the genome sequence as additional information. By aligning reads to the reference genome, CEM can predict the expressed transcript sequences and estimate the expression level of each transcript based on a statistical model (quasi-multinomial model). Since some transcripts may align to multiple contigs and some contigs may align to multiple transcripts, we considered only those transcripts and contigs with one-to-one correspondence. The Pearson's correlation between the predicted expression levels and the exact expression levels was calculated. As suggested in<ref type="bibr" target="#b5">Li and Jiang, 2012</ref>, we also calculated the Pearson's correlation between the logarithm of predicted expression levels and the logarithm of exact expression levels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Simulated data</head><p>In order to simulate more realistic data, we aligned all reads in a real RNA-Seq data of Oryza sativa Transcriptome to known transcripts of Oryza sativa in the database. Based on the alignment results, we identified the set of expressed transcripts and estimated their expression levels. Note that, since the transcript sequences were known, no long gap (representing an intron) alignments were allowed. Reads aligned to multiple transcripts were not considered for estimating the depth of the transcript. We used all transcripts with at least 80% of the region aligned by reads and with depth at least 0.5Â to generate the simulated data, i.e. there were 0.5 reads covering each nucleotide on average. We sampled paired-end reads from the transcripts according to their expression levels. The read length was 100 bp, error rate was 1% and the insert distance followed a normal distribution with mean 250 bp and standard deviation 25 bp.<ref type="figure" target="#fig_8">Figure 4</ref>shows the quality of the assembly results of the assemblers for different levels of completeness. Velvet-SC reconstructed the least number of transcripts in all completeness settings because it is designed for assembling genomic data and cannot handle multiple isoforms of the same gene well. IDBAUD, which is designed for assembling genomic and metagenomic data, handled some simple cases of multiple isoforms of the same gene and had better performance than Velvet-SC. Trinity and Oases found more transcripts than Velvet-SC and IDBA-UD because they are designed for assembling transcriptome data. Oases had its best performance when k was set to 25, the same k value for Trinity. IDBA-Tran reconstructed the most transcripts and consistently reported more correct contigs.<ref type="figure" target="#tab_1">Table 1</ref>shows the detailed figures when completeness was 0.8. The number of correct contigs and reconstructed transcripts for IDBA-Tran were the highest among the tools. IDBA-Tran also had the highest sensitivity and specificity.<ref type="figure" target="#tab_2">Table 2</ref>shows the expression level distribution of reconstructed transcripts of the assemblers when completeness was 0.8. For low-expressed transcripts with sequencing depth 55, IDBA-Tran reconstructed 664 more transcripts (33% more) than the second best tool (Trinity). This is probably due to the fact that IDBA-Tran can separate transcripts from different genes into components efficiently while preserving the low-expressed transcripts. We also checked the quality of decomposition and found that over 80% of the transcripts were still inside the same component after the decomposition step (referred to ''unbroken transcripts after decomposition). Except transcripts with very low sequencing depth (55), most transcripts were not broken after the decomposition and could be constructed successfully. Similar results were found for transcripts with sequencing depth between 5 and 10. For transcripts with higher sequencing depth, in general, IDBA-Tran also performed better (even though all assemblers had better performance for high-expressed transcripts). For IDBA-Tran, we verified the effectiveness of its component separation algorithm and show the distribution of transcripts in<ref type="figure" target="#tab_3">Table 3</ref>assembled by any assemblers, the total number of transcripts (18 180) in all components was less than the total number of expressed transcripts (22 402). A component containing a transcript does not guarantee that the transcript can be reconstructed. Thus, the number of reconstructed transcripts (17 243) is less than the total number of transcripts in all components (18 180). However, experiments showed that most transcripts decomposed correctly can be reconstructed successfully.<ref type="figure" target="#tab_4">Table 4</ref>shows the performance of IDBA-Tran and CEM on estimating expression levels of transcripts. Although CEM had the additional information of the rice genome, the number of expression transcripts reconstructed by IDBA-Tran and CEM were similar. Moreover, IDBA-Tran had similar performance to CEM in estimating the expression levels because it could reconstruct most of the expressed transcripts making the estimation process easier.<ref type="figure">Table 6</ref>for comparison (with the distribution of expressed transcripts estimated as mentioned in Section 3.1). Note that since the expressed transcripts and expression levels were estimated from alignments, there may be some error due to the existence of unknown transcripts and transcripts with over 80% similarity. The sensitivities and specificities shown are approximation of the real sensitivities and specificities only.<ref type="figure" target="#fig_11">Figure 5</ref>shows the number of reconstructed transcripts and aligned (correct) contigs reported by each assembler under different completeness. The results were consistent with those for the simulated data. IDBA-Tran still performed the best for all levels of completeness. All assemblers had poorer performance for real data than for simulated data. Oases still had its best performance when k was set to 25, and had very similar performance in terms of reconstructed transcripts compared with Trinity in all completeness settings.Detailed statistics of assembly results are shown in<ref type="figure" target="#tab_5">Table 5</ref>when completeness is set to 0.8. IDBA-Tran, Oases and Trinity had about the same number of contigs and total contig bases. IDBA-UD assembled relatively fewer contigs than others. IDBA-Tran had the highest sensitivity (42.08%) and specificity (22.94%) while other assemblers had much lower sensitivity and specificity.<ref type="figure">Table 6</ref>shows the expression level distribution of reconstructed transcripts for different assemblers when completeness is set to 0.8. When comparing Tables 2 and 6, it is clear that the real data was more difficult to assemble than simulated data, especially for low-expressed transcripts. Only 732 transcripts ($25%) with depth 55 were reconstructed by IDBA-Tran and worse for other assemblers. Similar to simulated data, IDBATran had better performance than other assemblers for all expression levels.<ref type="figure">Table 7</ref>shows the distribution of transcripts in components. Since the sampling depths of a single transcript may be uneven, many transcripts were broken into fragments. Moreover, there were some unknown transcripts in the data set. So, quite a number of components did not contain 80% of a transcript. However, for the other components, IDBA-Tran did a good job: 6353 components, each of which contained at most 5 transcripts, contained 9082 transcripts all together. Similar to simulated data, once a transcript was correctly assigned to a component, the transcript was reconstructed with high probability.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Real data</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>We have identified one key issue in transcriptome assembly, namely how to remove erroneous vertices/edges of high multiplicity (due to high-expressed isoforms) from the de Bruijn graph while keeping correct ones with relatively lower multiplicity (due to low-expressed isoforms). We developed a probabilistic progressive approach with local thresholds to solve the problem. We proposed IDBA-Tran, combined with other techniques, to assemble transcriptome sequencing data. Experiments on both simulated and real data confirm that IDBA-Tran can outperform existing de novo transcriptome assemblers in terms of both sensitivity and specificity. In particular, for low-expressed transcripts, the improvement of IDBA-Tran is substantial. Recall that there is another approach to recover both low-expressed and high-expressed transcripts, namely: run the assembler for different k values and merge all contigs as output. OasesM, which runs Oases several times with multiple k values, is a post-processing tool based on this approach. Oases-M can reconstruct many transcripts for both simulated and real data. However, since erroneous contigs cannot be merged, Oases-M produces many incorrect contigs and has a low specificity (see Supplementary<ref type="figure">Table SA8</ref>). Moreover, contigs representing some transcripts may appear multiple times (with small difference) in the output such that the number of correct contigs is double the number of reconstructed transcripts. The large number of erroneous contigs and redundant contigs may make analysis difficult, and it is very hard to distinguish the erroneous contigs from the correct ones. On the other hand, we found that Oases-M had slightly better performance than IDBA-Tran for high-expressed transcripts for real data (see Supplementary<ref type="figure">Table SA9</ref>). Thus, it may be a good idea to investigate how to integrate both approaches to reconstruct more transcripts.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>Similar to Oases-M, IDBA-Tran also adopts the idea of multiple k to handle transcripts with different expression levels. However, instead of generating a de Bruijn graph and finding transcripts for each k value, an accumulated de Bruijn graph is built to capture all information from both high-expressed and low-expressed transcripts. During each iteration, an accumulated de Bruijn graph H k for a fixed k is constructed from the input reads and the contigs constructed in previous iterations, i.e. those contigs constructed in H k-s are treated as input reads for the construction of H k. The depth information is used to separate de Bruijn graph into components. Ideally, transcripts from different genes are decomposed into different components. In each component, alternative splicing can be detected and transcripts can be reconstructed. To accumulate information, all reconstructed transcripts are used as input reads for the next iteration.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>Many de novo assemblers remove tips (short simple paths leading to dead ends) in the de Bruijn graph as erroneous contigs. It would not be advisable to remove such tips in transcriptome assembly, because transcripts are very short (could be several hundred bases) when compared to genomes. Removing one hundred bases from the end of a genome may not be a problem, but removing one hundred bases from the end of a transcript may lose much important information. When constructing the accumulated de Bruijn graph in IDBA-Tran, the tip removal process will take place at each iteration. Instead of removing all tips and producing shorter transcripts, IDBA-Tran keeps the longest tip (with highest probability of being a correct path) and removes all other short tips. For</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Example of de Bruijn graph for two isoforms from the same gene. (a) de Bruijn graph of two isoforms without error. (b) de Bruijn graph of two isoforms when there is 1% sequencing error in reads. (c) Multiplicity of correct and erroneous k-mers for simulated data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.3.</head><figDesc>Fig. 3. Workflow of IDBA-Tran</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>Transcripts Discovering (TD) Problem]: given a de Bruijn graph G(V, E) with a set of vertices V and edges E, a set of paired-end reads P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>. If a component contained a certain portion (80%) of a transcript, the component was deemed to have contained this transcript. There were 2865 components containing no transcripts and 10 611 components, each of which contained at most 5 transcripts, together containing most of the transcripts (16 663). Since very low-expressed transcripts cannot be</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.4.</head><figDesc>Fig. 4. Experiment result of each assembler on different completeness level for simulated data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><figDesc>We verified IDBA-Tran and other assemblers on the real RNASeq data of Oryza sativa transcriptome. There were 24 855 142 paired-end length-90 reads in the data set. The insert distance was about 200. Previous simulated data used the expression level profile of this data set, so they had the same set of expressed transcripts and expression levels. The distribution of expressed transcripts is also included in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Total</head><figDesc>Length of Reconstructed Transcripts IDBA-Tran IDBA-UD Oases Trinity Velvetsc</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig.5.</head><figDesc>Fig. 5. Experiment result of each assembler on different completeness level for real data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><figDesc>Funding: This research is partially supported by RGC HKU 7111/12E and HKU 719709E, the Shanghai Pujiang Plan (Y057C11501) and Bill &amp; Melinda Gates Foundation Project (''C4 Rice''). Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>i Prune short tips Merge similar path Paired-end reads Construct de Bruijn H k for k = k min until k max Contigs</figDesc><table>Progressive-

Component-Depth 

Error Correction 

Local Assembling 

Find-transcripts 

Build H k+s </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 2. Expression level distribution of reconstructed transcripts of each assembler for simulated data set (completeness ¼ 0.8)</figDesc><table>Depth 
0, 5 
5, 10 
10, 15 
15, 20 
=20 

Total number of transcripts 
5943</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 5. Statistics of assembly result of each assembler for real data set (completeness ¼ 0.8)</figDesc><table>Contigs 
number 

Average 
length (nt) 

Total length (nt) 
Reconstructed 
transcripts number 

Correct 
contigs number 

Sensitivity 
Specificity 

Trinity 
39 974 
966 
39M 
7052 
6121 
31.48% 
15.31% 
Oases 
36 684 
1041 
38M 
5666 
5162 
25.29% 
14.07% 
IDBA-UD 
28 753 
890 
25M 
6164 
4567 
27.51% 
15.88% 
Velvet-SC 
28 626 
518 
15M 
233 
208 
1.04% 
0.73% 
IDBA-Tran 
40 010 
1055 
42M 
9428 
9177 
42.08% 
22.94% 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 6.</figDesc><table>Expression level distribution of reconstructed transcripts of each assembler for real data set (completeness ¼ 0.8) 

Depth 
0, 5 
5, 10 
10, 15 
15, 20 
=20 

Total number of transcripts 
5943 
5011 
2943 
1857 
6646 
Trinity 
410 
910 
983 
743 
4004 
Oases 
431 
907 
1005 
776 
3946 
IDBA-UD 
287 
978 
985 
723 
3124 
V e l v e t -S C 
2 8 
5 5 
5 5 
2 8 
6 7 
IDBA-Tran (unbroken transcripts after decomposition) 
732 (921) 
1480 (1525) 
1417 (1472) 
1041 (1083) 
4758 (5325) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 4. Statistic on estimating expression levels of reconstructed transcripts of each assembler for simulated data set (completeness ¼ 0.8)</figDesc><table>Transcripts reconstructed by both algorithms 
Transcripts reconstructed by only one algorithm 

Number of transcripts 
Pearson's correlation 
(based on log value) 

Number of transcripts 
Pearson's correlation 
(based on log value) 

CEM 
5611 
0.95 (0.91) 
100 
0.89 (0.79) 
IDBA-Tran 
0.95 (0.94) 
37 
0.93 (0.85) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 7. Distribution of transcripts in IDBA-Tran components for real data set (completeness ¼ 0.8)</figDesc><table>Transcripts in component 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
4¼10 
total 

Numberofcomponents 
20288 
4482 
1265 
408 
145 
53 
21 
17 
6 
6 
15 
26706 
Number of unbroken transcripts (after decomposition) 
0 
4482 
2531 
1224 
580 
265 
126 
119 
48 
54 
593 
10 022 
Number of reconstructed transcripts 
0 
4371 
2450 
1152 
553 
265 
126 
119 
48 
28 
316 
9428 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">SPAdes: a new genome assembly algorithm and its applications to single-cell sequencing</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bankevich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="455" to="477" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of single-cell bacterial genomes from short-read data sets</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Chitsaz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="915" to="921" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Full-length transcriptome assembly from RNA-Seq data without a reference genome</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">G</forename>
				<surname>Grabherr</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="644" to="652" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Molecular biology: power sequencing</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">R</forename>
				<surname>Graveley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">453</biblScope>
			<biblScope unit="page" from="1197" to="1198" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Ab initio reconstruction of cell type-specific transcriptomes in mouse reveals the conserved multi-exonic structure of lincRNAs</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Guttman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="503" to="510" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Transcriptome assembly and isoform expression level estimation from biased RNA-Seq reads</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="2914" to="2921" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Statistical inferences for isoform expression in RNA-Seq</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">H</forename>
				<surname>Wong</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1026" to="1032" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">BLAT–the BLAST-like alignment tool</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">J</forename>
				<surname>Kent</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="656" to="664" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">The sequence and de novo assembly of the giant panda genome</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">463</biblScope>
			<biblScope unit="page" from="311" to="317" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">The transcriptional landscape of the yeast genome defined by RNA sequencing</title>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Nagalakshmi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">320</biblScope>
			<biblScope unit="page" from="1344" to="1349" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<monogr>
		<title level="m" type="main">T-IDBA: a de novo Iterative de Bruijn Graph Assembler for Transcriptome</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<pubPlace>Vancouver, BC, Canada</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">IDBA-UD: a de novo assembler for single-cell and metagenomic sequencing data with high uneven depth</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1420" to="1428" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title level="m" type="main">De novo assembly and analysis of RNA-seq data</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Robertson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="909" to="912" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Oases: robust de novo RNA-seq assembly across the dynamic range of expression levels</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">H</forename>
				<surname>Schulz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1086" to="1092" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<monogr>
		<title level="m" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Optimization of de novo transcriptome assembly from next-generation sequencing data</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Surget-Groba</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">I</forename>
				<surname>Montoya-Burgos</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1432" to="1440" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">A probabilistic approach to accurate abundance-based binning of metagenomic reads</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Tanaseichuk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms Bioinform</title>
		<imprint>
			<biblScope unit="volume">7534</biblScope>
			<biblScope unit="page" from="404" to="416" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">TopHat: discovering splice junctions with RNA-Seq</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Trapnell</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1105" to="1111" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Transcript assembly and quantification by RNA-Seq reveals unannotated transcripts and isoform switching during cell differentiation</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Trapnell</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="511" to="515" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">From de Bruijn Graphs to Rectangle Graphs for Genome Assembly</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Vyahhi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<biblScope unit="volume">7534</biblScope>
			<biblScope unit="page" from="249" to="261" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>