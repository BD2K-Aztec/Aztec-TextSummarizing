
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fiona: a parallel and automatic strategy for read error correction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Marcel</forename>
								<forename type="middle">H</forename>
								<surname>Schulz</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">&apos;Multimodal Computing and Interaction&apos;</orgName>
								<orgName type="department" key="dep2">Department for Computational Biology and Applied Computing</orgName>
								<orgName type="department" key="dep3">Max Planck Institute for Informatics</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<addrLine>Saarbr€ ucken</addrLine>
									<postCode>66123</postCode>
									<settlement>Saarland, Germany</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Ray and Stephanie Lane Center for Computational Biology</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<postCode>15206 PA</postCode>
									<settlement>Pittsburgh</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">David</forename>
								<surname>Weese</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Freie Universit € at Berlin</orgName>
								<address>
									<postCode>14195</postCode>
									<settlement>Berlin, Germany</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Manuel</forename>
								<surname>Holtgrewe</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Freie Universit € at Berlin</orgName>
								<address>
									<postCode>14195</postCode>
									<settlement>Berlin, Germany</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Viktoria</forename>
								<surname>Dimitrova</surname>
							</persName>
							<affiliation key="aff3">
								<orgName type="laboratory">UMR7238</orgName>
								<orgName type="institution" key="instit1">Universit e Pierre et Marie Curie</orgName>
								<orgName type="institution" key="instit2">CNRS-UPMC</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="laboratory" key="lab1">UMR7238</orgName>
								<orgName type="laboratory" key="lab2">Laboratory of Computational and Quantitative Biology</orgName>
								<orgName type="institution">CNRS</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Sijia</forename>
								<surname>Niu</surname>
							</persName>
							<affiliation key="aff3">
								<orgName type="laboratory">UMR7238</orgName>
								<orgName type="institution" key="instit1">Universit e Pierre et Marie Curie</orgName>
								<orgName type="institution" key="instit2">CNRS-UPMC</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="laboratory" key="lab1">UMR7238</orgName>
								<orgName type="laboratory" key="lab2">Laboratory of Computational and Quantitative Biology</orgName>
								<orgName type="institution">CNRS</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Knut</forename>
								<surname>Reinert</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Freie Universit € at Berlin</orgName>
								<address>
									<postCode>14195</postCode>
									<settlement>Berlin, Germany</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Hugues</forename>
								<surname>Richard</surname>
							</persName>
							<affiliation key="aff3">
								<orgName type="laboratory">UMR7238</orgName>
								<orgName type="institution" key="instit1">Universit e Pierre et Marie Curie</orgName>
								<orgName type="institution" key="instit2">CNRS-UPMC</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="laboratory" key="lab1">UMR7238</orgName>
								<orgName type="laboratory" key="lab2">Laboratory of Computational and Quantitative Biology</orgName>
								<orgName type="institution">CNRS</orgName>
								<address>
									<settlement>Paris</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fiona: a parallel and automatic strategy for read error correction</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="page" from="356" to="363"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu440</idno>
					<note>BIOINFORMATICS Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Automatic error correction of high-throughput sequencing data can have a dramatic impact on the amount of usable base pairs and their quality. It has been shown that the performance of tasks such as de novo genome assembly and SNP calling can be dramatically improved after read error correction. While a large number of methods specialized for correcting substitution errors as found in Illumina data exist, few methods for the correction of indel errors, common to technologies like 454 or Ion Torrent, have been proposed. Results: We present Fiona, a new stand-alone read error–correction method. Fiona provides a new statistical approach for sequencing error detection and optimal error correction and estimates its parameters automatically. Fiona is able to correct substitution, insertion and deletion errors and can be applied to any sequencing technology. It uses an efficient implementation of the partial suffix array to detect read overlaps with different seed lengths in parallel. We tested Fiona on several real datasets from a variety of organisms with different read lengths and compared its performance with state-of-the-art methods. Fiona shows a constantly higher correction accuracy over a broad range of datasets from 454 and Ion Torrent sequencers, without compromise in speed. Conclusion: Fiona is an accurate parameter-free read error–correc-tion method that can be run on inexpensive hardware and can make use of multicore parallelization whenever available. Fiona was implemented using the SeqAn library for sequence analysis and is publicly available for download at http://www.seqan.de/projects/</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Next-generation DNA sequencing (NGS) technologies have revolutionized genomics and produce billions of base pairs per day in the form of reads of length !100 bp. In this article, we focus on NGS reads produced by genome sequencing. Owing to the large range of applications of genome sequencing, the correction of errors introduced by the sequencer, substitution as well as insertion or deletion (indels), has recently attracted attention. Previous studies showed that error correction can improve de novo genome assembly performance (<ref type="bibr" target="#b11">Salmela and Schr€ oder, 2011;</ref><ref type="bibr" target="#b12">Salzberg et al., 2012</ref>) and SNP detection (<ref type="bibr" target="#b5">Kao et al., 2011;</ref><ref type="bibr" target="#b6">Kelley et al., 2010</ref>). Depending on the technology, the most prevalent error type differs. Illumina technology produces mostly substitution errors (<ref type="bibr" target="#b7">Minoche et al., 2011</ref>), whereas 454 sequencers are prone to produce runs of larger insertions of the same nucleotide. Ion Torrent sequencers were shown to have a large amount of indel errors and a high-sequencing error rate (<ref type="bibr" target="#b9">Quail et al., 2012</ref>). However, current error correction methods suffer a number of limitations as highlighted in a recent review (<ref type="bibr" target="#b16">Yang et al., 2013</ref>).</p><p>(i) Most methods cannot correct indel errors because they are tailored to correct only substitution errors and are therefore only applicable to Illumina reads. (ii) Most approaches need to be parameterized depending on the dataset, otherwise their performance is suboptimal. This either requires in-depth knowledge by the user or parameter optimization using downstream analysis, which often leads to longer running times in practice.</p><p>(iii) Because the throughput of NGS technologies is growing steadily, many approaches are not applicable to larger datasets because of running time or memory limitations. These caveats make it hard for users to choose the optimal tool for their dataset and NGS technology. Here we introduce a new approach to read error correction, called Fiona, which addresses all the above mentioned limitations. Fiona provides an accurate and highly parallelized method for correction, with the ability to correct indel errors, while it automatically adjusts its parameters. All read error–correction methods have to perform essential tasks: (i) computation of read overlaps, (ii) error detection in reads and (iii) error correction. In a recent review by<ref type="bibr" target="#b16">Yang et al. (2013)</ref>, the methods have been classified into k-spectrum based, suffix tree/array based and multiple sequence alignment (MSA) based. We will briefly explain the differences and weaknesses of these approaches but refer the reader to (<ref type="bibr" target="#b16">Yang et al., 2013</ref>): k-spectrum based. k-spectrum based read error correction was introduced in the Euler assembler (<ref type="bibr" target="#b8">Pevzner et al., 2001</ref>). There exist many variations on the k-spectrum based error corrections for NGS reads (<ref type="bibr" target="#b16">Yang et al., 2013</ref>), for example, approaches that were designed to select the necessary parameters using mixture models (<ref type="bibr" target="#b1">Chaisson and Pevzner, 2008;</ref><ref type="bibr" target="#b6">Kelley et al., 2010</ref>). Popular methods are Quake (<ref type="bibr" target="#b6">Kelley et al., 2010</ref>), Reptile (<ref type="bibr" target="#b15">Yang et al., 2010</ref>) and the error correction module from the Allpaths-LG assembler (<ref type="bibr" target="#b3">Gnerre et al., 2010</ref>), all of which use base quality values. To our knowledge, only Allpaths-LG in this category can correct short indel errors. *To whom correspondence should be addressed. y The authors wish it to be known that, in their opinion, the first three authors and the last author should be regarded as Joint First Authors. ß The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com</p><p>The general disadvantage for most of these methods is their inability to correct indel errors, a severe limitation for 454 or Ion Torrent sequencers. In addition, for most of these approaches, parameters need to be optimized by the user to obtain good performance, for example, Reptile. Suffix tree/array based. Shrec (<ref type="bibr" target="#b13">Schr€ oder et al., 2009</ref>) was the first approach that uses a variable seed length for read overlap and error-detection computation. It considers for each erroneous read a set of correcting reads such that all reads share a ðk À 1Þ-mer left of the error and the set of correcting reads share a k-mer that ends with the correct base, which outvotes the erroneous base. To efficiently find erroneous reads and correcting candidates, Shrec traverses a generalized suffix tree of all reads, in which erroneous and correcting reads occur as children of branching nodes with string depth k À 1. Building on a suffix tree representation, the HybridShrec algorithm extended the ideas to correct indel errors and sequences in color space (<ref type="bibr" target="#b10">Salmela, 2010</ref>). In both methods, potentially correcting reads are compared with erroneous reads using hamming distance, seeded by the shared ðk À 1Þ-mers between reads. Further, both methods are sensitive to the input parameters and therefore show variable performance when compared in other studies (<ref type="bibr" target="#b4">Ilie et al., 2011;</ref><ref type="bibr" target="#b5">Kao et al., 2011;</ref><ref type="bibr" target="#b6">Kelley et al., 2010</ref>), and the full suffix tree data structure needs large memory resources. The HiTEC algorithm introduced automatic parameter selection using coverage statistics (<ref type="bibr" target="#b4">Ilie et al., 2011</ref>). Seed lengths and coverage threshold are set automatically, given the genome length and the average error rate. HiTEC uses the suffix array instead of a suffix tree to save memory. However, HiTEC can only correct substitution errors and the automatic parameter selection works only for reads of same length as found for Illumina data. Note that these methods do not define explicitly which correction for an erroneous position is applied when the same error is encountered multiple times through different seed lengths in the tree, and in which order errors in a read are corrected. MSA based. Among the two existing multiple alignment-based methods ECHO (<ref type="bibr" target="#b5">Kao et al., 2011</ref>) and Coral (Salmela and Schr€ oder, 2011), only Coral can correct indel errors. Coral computes initial read overlaps with hash tables for a fixed k-mer length and then uses dynamic programming to form multiple read alignments. This alignment is costly for long reads but has a clear optimization function, as read errors are corrected by the best voting correction in the MSA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">MATERIALS AND METHODS</head><p>We introduce the Fiona algorithm, which combines the strength of suffix tree-based methods with a clear definition of error correction as in MSAbased methods. The algorithm uses a suffix tree to detect and correct substitution and indel errors following Shrec and HybridShrec, but with enhanced overlap detection of reads with indel errors using edit distance comparisons. In the implementation, the suffix tree traversal is emulated using solely a partial suffix array that is presorted up to a fixed depth to reduce the memory footprint. All steps feature a parallel implementation to scale with larger datasets. Instead of treating discovered errors independently, Fiona collects them and solves a new formulation for optimal error correction inspired by the MSA-based correction methods. Further, it uses new statistical methods to improve error detection at different k values and automatically estimates its parameters for reads of varying lengths as commonly found in 454 or IonTorrent data sets. The Fiona strategy is outlined in<ref type="figure">Figure 1</ref>. Notations. Let<ref type="bibr">[i, j]</ref>and (i, j) be closed and open ranges of integers. Further, let S be the DNA alphabet (S=fA; C; G; T; Ng, and N represents an unknown base) and s a string of jsj characters. The concatenation of two strings s and t is denoted by st. A substring of s from position i to j is the sequence s½i; j:=s i s i+1. .. s j. s R and s denote, respectively, the reverse and the reverse complement of a DNA string s. We correct errors on a set R ðjRj=mÞ of DNA strings of lengths ð' i Þ m i=1 , sampled from a genome G of length n, possibly with sequencing errors. R denotes the set of reverse-complemented reads. The edit distance ed(s, t) between two strings s and t is the minimal number of operations (substitutions, deletions and insertions) required to transform s into t. In the following section, we describe how we use a suffix tree and a statistic on read coverage to find erroneous reads and correct them using the sequences they overlap. We then introduce our approach for detecting the type of error and choosing the optimal correction. Instead of immediately correcting errors as they are found, corrections are prioritized according to the support of their overlapping reads.<ref type="figure">Fig. 1</ref>. The Fiona strategy illustrated on a toy example. A set of partial suffix trees are built from the set of reads and their reverse complement (in fact partial suffix arrays are constructed, see Implementation). The trees are traversed in parallel to detect and correct errors. Potential errors in the reads are identified as nodes in the tree according to their coverage (e.g. the substring GGAC, covered by only one read). The correction with the highest support is chosen to correct the read at that position. Owing to the parallel traversal of the tree, all possible corrections on a read are recorded in a linked list, which reports the positions of corrections as well as their current maximal support. After traversal, the reads are updated by applying all non-conflicting corrections in order of decreasing support. Once all reads have been corrected, the algorithm repeats the procedure until the number of corrections have been achieved i357</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Searching erroneous reads</head><p>One essential ingredient in every sequencing error correction method is the statistic that computes which k-mers are erroneous, i.e. span at least one sequencing error in the read. Because new k-mers are generated when an error is introduced, their abundance or coverage is lower compared with k-mers from the genome. To detect a k-mer with a sequencing error, we compute the expected coverage assuming a uniform sampling of genomic positions. We use a hierarchical statistical model to describe the expected coverage distribution of k-mers resulting from library preparation and sequencing as follows. Let X k be the random variable for the number of occurrences of a string of length k in the population of sequence fragments before sequencing. X k is never directly observed, instead the occurrences of k-mers in the reads R after sequencing, denoted Y k , are observed with a given number of sequencing errors z. For every k-mer covered by c reads, we classify it as possessing errors based on the sign of the log odds ratio (positive value for erroneous k-mers):</p><formula>log PðY k =c j z40Þ PðY k =c j z=0Þ +w: ð1Þ</formula><p>The constant w can be modified to adjust the sensitivity of the detection. To match the setup of a naive Bayes classifier, we use the log-odds ratio of the probability that the k-mer has errors compared with the probability that the k-mer has no error: w=logð1 À ð1 À "Þ k Þ=ð1 À "Þ k : As we will show in the following the user only needs to supply the genome length n and the average error rate " to the method. The method can then infer the coverage cutoff and the range of k-mers to explore.</p><p>Coverage distribution of k-mers. The counts X k are drawn according to binomial sampling along each position in G. If we assume the sampling to be uniform, k5minð' i Þ; maxð' i Þ ( n and that any word of length k is unique in G, the expected count of a k-mer k is</p><formula>k = X m i=1 ' i À k+1 n À ' i +1 : ð2Þ</formula><p>As n is usually large, X k can be approximated by a Poisson distribution of rate k. Note that the assumption that a word is unique in G is vital because repeats in G will have a higher k. We restrict ourselves to this hypothesis in the following, as errors derived from repeats are difficult to infer based exclusively on their coverage. Therefore, we have an additional filter to remove words that originate from repetitive regions (see Implementation). If we assume a uniform error rate of " at each base (thus a probability of "=3 for each substitution), we can derive the expected count for a given k-mer, given its number of sequencing errors, i.e. the distribution of Y k jz. The coverage of a k-mer possessing i sequencing errors is distributed according to a Poisson distribution with an expectation of</p><formula>i = k Á ð"=3Þ i ð1 À "Þ kÀi : ð3Þ</formula><p>Note that this formulation does not incorporate cases where errors would accumulate on other reads in the neighborhood of the k-mer. This effect can be neglected given the relatively low error rate of current sequencers (55%). The distribution of Y k can be obtained by summing over the possible number of errors, which results in a mixture of Poisson distributions with rates i. We denote the proportion of reads with exactly i errors as</p><formula>i = k i ! " i ð1 À "Þ kÀi ; ð4Þ</formula><p>which we call the mixture coefficients. It follows the formulation for Y k :</p><formula>PðY k =cÞ= X k i=0 i Á PðY k =c j z=iÞ= X k i=0 i Á e À i c i i ! : ð5Þ</formula><p>Note that without the i = 0 term, this formulation denotes the distribution for reads with at least one error.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Choosing</head><p>the k-mer range. In our error correction formulation we seed the alignments with different seed lengths in the interval ½k min ; k max . The minimal value k min should neither be too small, to reduce influence from repetitive sequences, nor too large, as many erroneous reads may be missed otherwise. In Fiona, we extend a technique proposed by the authors of HiTEC (<ref type="bibr" target="#b4">Ilie et al., 2011</ref>) to determine the best value for k min , balancing the sensitivity of a seed and its accuracy, and modify it to account for heterogeneous read lengths (Supplementary Section S1). Note that our use of the<ref type="bibr">[</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Detecting the type of error</head><p>With the statistic described in the previous section we now search the generalized suffix tree of R [ R for nodes at level k À 1 that branch into an erroneous and a correct k-mer, let the latter be x with x 2 S. For each read r in the erroneous subtree, we search for possible corrections in the correct subtrees. If i is the position of the error, obviously r½i 6 ¼ x and we can use the set of overlapping correct reads to determine the type of error at i: substitution, insertion or deletion. We use the spectrum of the correct k-mer x to select possible correcting reads. The spectrum SðtÞ of a string t is defined as the set of pairs (s, j) such that s 2 R [ R and s½j À jtj+1; j=t (the set of positions in reads ending with the string t). For each read s in the spectrum SðxÞ, we extend the seed to the right with minimal edit distance using an alignment algorithm until the end of either r or s is reached. We define the right extension of two strings a and b as a pairwise alignment of one string to a prefix of the other.</p><formula>e 0 2 1 1 ! ; 1 0 ! ; 0 1 ! ( ) Eðr½i+e 0 1 ; jrj; s½j+e 0 2 ; jsjÞg:</formula><p>Thus, V(e) is the set of correct reads (or more precisely of correct anchors) that vote for e, i.e. can be optimally extended incorporating error e. We choose the error type that maximizes jV(e)j. In case of ties, we prefer substitutions over indels and deletions over insertions. As an additional criterion to reduce false positives, we consider only correct reads within a given overlap error rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i358</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Selecting optimal read corrections</head><p>In contrast to other approaches that consider a fixed seed length, we examine potential errors over a whole range of seed lengths and therefore need a way to select the overall most probable error among them. For an error, summarized by the tuple "=ðr; i; eÞ, we define the support suppð"; xÞ as the number of matching base pairs in overlap alignments between r and correct reads voting for e at position i:supp is computed for all reads that vote for error type e, by subtracting from the total overlapping bases (left and right) the number of errors in the overlap [given by<ref type="bibr">EðÁ; ÁÞ]</ref>. During the traversal we maintain a data structure that stores the maximal suppð"; ÁÞ and its corresponding correction. After tree traversal, we sort for each read r the list of errors by decreasing support, apply the first correction and continue with the next non-conflicting correction (a conflicting correction is a correction which would destroy the seed of one previously applied correction). Note that this definition of error correction is different from the correction approaches in the other suffix tree based algorithms (<ref type="bibr" target="#b4">Ilie et al., 2011;</ref><ref type="bibr" target="#b10">Salmela, 2010;</ref><ref type="bibr" target="#b13">Schr€ oder et al., 2009</ref>) because these do not maximize over a range of seed lengths for one correction and do not maximize the support of corrections for an individual read. Rather, their algorithms can detect errors at different seed lengths, but correct an error in read r for an arbitrary k, solely determined by its first encounter in the suffix tree. This makes Fiona the only approach to use a definition of optimality for different seed lengths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation</head><p>We implemented Fiona in C++ using SeqAn (D € oring et al., 2008). We emulate the suffix tree traversal with a suffix array and exploit a one-to-one correspondence of suffix tree nodes at string depth ' and '-intervals in the suffix array (<ref type="bibr" target="#b0">Abouelhoda et al., 2004)</ref>where (i) the suffixes in the interval are the leaves of the node's subtree and (ii) the suffix tree path from the root to the node spells out the longest common prefix of the interval suffixes. We parallelized the construction and traversal of the suffix array using OpenMP, exploiting the fact that we do not need to explicitly construct the arrays for suffixes shorter than k min. Reticulating the tree this way allows to control memory usage and to process suffixes step-wise in chunks. In practice we refine a 10-mer index up to a sorted prefix of length k max. Seed extension and computation of the EðÁ; ÁÞ values is done with a banded variant of Myers' bitvector algorithm for fast edit distance computation. For parallel access of the found corrections and their support in each read, we implemented a concurrent linked list data structure. Finally, repeats are accounted for by filtering out suffixes with too high coverage or containing tandem repeats. More implementation details, as well as worst case and expected time and memory complexities, can be found in Supplementary Section S2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>We performed a comprehensive experimental evaluation of Fiona and other tools on various real-world read sets. For the evaluation of read correction quality, the metric gain has been established in (<ref type="bibr" target="#b15">Yang et al., 2010</ref><ref type="bibr" target="#b16">Yang et al., , 2013</ref>) as a good summary of both sensitivity and precision. The gain can be computed by ðb À aÞ=b where a and b are the sums over the number of errors after and before correction over all reads. When more errors are introduced than corrected over all the reads, the gain takes a negative value. For the evaluation, we developed a tool compute_gain, which is included in the Fiona distribution (Supplementary Section S3.2) To cover most of the use cases nowadays, we evaluated the accuracy on read sets from 454, IonTorrent and Illumina sequencers that show a varying degree of read lengths (mean values from 92 to 544 bp) and depth of coverage (up to 490Â). We selected datasets for a diverse set of organisms to explore the impact of genome complexity and repeat content on error correction performance, from short genomes (Escherichia coli, Pseudomonas syringae) to longer and more complex ones (Drosophila melanogaster, Homo sapiens). Further details about all datasets and the evaluation are given in Supplementary Section S3. The only variable parameter besides the input read set given to Fiona is the estimated genome length (Supplementary<ref type="figure" target="#tab_1">Table S1</ref>). Fiona was run with default parameters for all datasets, i.e. the sequencing error rate was 5% and the presorting q-gram length was set to 10.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Optimal error formulation improves correction accuracy</head><p>As mentioned in the introduction, the previous suffix tree based error correction approaches use the correction for a read that is first encountered during tree traversal and neither store all possible corrections nor choose the optimal one. Although we compare with HybridShrec later, which uses such a strategy, it is not straightforward to analyze the advantage of our new formulation of optimal error correction because HybridShrec further differs in the way errors are detected. Therefore, we implemented two special versions of Fiona to illustrate the improvement of our approaches. In the first, for each read position only the first correction encountered during</p><formula>(d) (a) (b)</formula><p>(c)<ref type="figure">Fig. 2</ref>. Example for detecting the type of error. Given an erroneous read r and a correct read s, that share a 3-mer anchor CCG that cannot be extended to the right. For each possible error type, deletion (a), substitution (b) and insertion (c), we skip 0 or 1 bases in r or s and compute DP overlap alignments of the remaining suffixes (shaded). The corresponding DP traces of the three alignments are shown below (d) with colors matching the overlap regions. The error type with the least number of errors in the overlap, here the deletion with 0 errors, is assumed to be the true error</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i359</head><p>Fiona: automatic read error connection traversal is stored, after each round the corrections are executed in the order they were found. We term this version Fiona-RE, for random encounter mode. The second, implements a version of Fiona that does all optimizations but compares two reads using hamming distance, instead of pairwise edit distance computation (Fiona-H). Note that Fiona-H does correct indel errors, as found at branching nodes in the tree, but no further indels are considered in the pairwise read alignment. We compare Fiona, Fiona-H and Fiona-RE on data sets with different regimes of coverage and genome complexity in<ref type="figure">Figure 3</ref>. The results show that Fiona-H, without edit distance pairwise comparison, usually shows a drop in gain value of 13–19%. This is due to a loss of sensitivity, where two reads that have several other indel errors downstream or upstream are not judged similar enough to be considered for correction. The optimal error formulation in Fiona, compared with random encounter mode in Fiona-RE, shows a pronounced improvement in error correction for more complex genomes and higher coverages as on the E.coli 163Â and Bordetella pertussis 85Â datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Robustness</head><p>Fiona uses different statistical formulas to infer the optimal correction parameters (see Section 2). We analyzed the robustness of error correction results on two datasets by varying the user-supplied sequencing error rate between 2 and 10%. Fiona produces corrections of similar quality with difference in gain value 515%, despite the large range of error rates tested, which indicates robust automatic parameter selection (see Supplementary<ref type="figure" target="#tab_3">Table S3</ref>). Note that the gain is generally better when the error rate is overestimated. This can be explained by the variability of read quality observed in the sequencing sample, i.e. an average error rate does not account for the other reads of low quality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Comparison with other methods</head><p>We compared the performance of Fiona with state-of-the-art genome error correction methods for the respective type of sequencing technology. For 454 and Ion Torrent datasets, we compared with Coral 1.4, Hybrid-Shrec 1.0 and the error correction module of Allpaths-LG release 44994, which can correct indel errors. For Illumina, we add the tools HiTEC 1.0.2 and Quake 0.3.4.2, which are designed for substitution errors. We did not include HybridShrec in those evaluations, as it consistently performed worse than HiTEC. In any case, all programs were run with eight threads if possible. The detailed parameterization of the programs is listed in Supplementary Section S5. Except ECHO and HiTEC, which do automatic parameter selection similar to Fiona, no other correction method adapts parameters depending on the data. But whereas Allpaths-LG has a fixed set of parameters, Coral and HybridShrec expect the user to optimize its parameters for indel-prone datasets, which we did to allow for a fair comparison. For Coral, we report the results of two versions, Coral and Coral*, the default version with error rate set to 7% and the optimized version with the bestperforming gain and error rate set as high as 25%, respectively (Supplementary Tables S8–S11). Coral* performed better than Coral on all datasets tested, clearly indicating the need for parameter adjustment for indel-prone datasets. HybridShrec has three parameters that have substantial influence on its performance, the strictness parameter for error detection and the minimum and maximum k-value for suffix tree traversal. As HybridShrec often terminates with default strictness value we have varied this parameter between values of 2–7 and took the best result. Consequently, we report the results as HybridShrec*. The same was done for HybridShrec F , which uses the same k value range as determined by Fiona for a dataset. Even with the optimized set of parameters we explored, HybridShrec sometimes yields negative gain values. The optimized parameters for HybridShrec*, HybridShrec F and Coral* are listed in Supplementary, Sections S9 and S8. We have evaluated all methods on different datasets and list their relative performance in terms of gain, sensitivity, specificity, base error rate after correction, running time and memory in Tables 1 and 2. and Supplementary Tables S4–S7, respectively. Further, we relate the error correction performance to running time of a method in<ref type="figure" target="#fig_4">Figure 4</ref>, where the best method appears in the upper left corner. Comparison on 454 data. We have collected four different 454 dataset with different coverage values for D.melanogaster 18Â, E.coli 13Â, Staphylococcus aureus 34Â and Saccharomyces cerevisae 16Â. These datasets vary in the per-base error rate between 0.6 and 1.76%. Errors are often found in sequence regions with homopolymer runs, which are hard to correct (<ref type="bibr" target="#b9">Quail et al., 2012</ref>). We observe that the optimized version of Coral* always outperforms the default parameters (Coral) on 454 data sets. Similarly, HybridShrec F mostly outperforms the optimized HybridShrec*, owing to adapted k-mer levels for each dataset. Similar to<ref type="bibr" target="#b16">Yang et al. (2013)</ref>, we observe that HybridShrec sometimes yields negative gain values, i.e. that more errors are introduced than corrected. As<ref type="figure" target="#fig_4">Figure 4</ref>(right) shows Fiona has the highest gain among all methods except for the S.aureus dataset, where Coral* performs best. However, Coral* runs $10 times longer than Fiona on this dataset. Allpaths-LG generally is the fastest or among the fastest methods, but with a loss in gain performance between 90 and 50% compared with Fiona. Fiona shows a fast running time for all datasets, and is also memory efficient compared with the Coral and HybridShrec versions.Fiona-RE Fiona-H Fiona<ref type="figure">Fig. 3</ref>. Comparison of gain values after error correction with new optimality criterion introduced in Fiona and corrections without optimization (Fiona-RE), or without edit distance overlap computation (Fiona-H) as performed by other suffix treebased methods. The results are for three different datasets with varying coverage values: B.pertussis (85Â), S.aureus (109Â), E.coli (160Â) (see Supplementary<ref type="figure" target="#tab_2">Table S2</ref>). Optimal corrections always lead to higher gain values i360 datasets. On seven of eight datasets, Fiona significantly outperforms the other methods in terms of gain. Fiona shows an increase in gain to the second best method ranging from 10 (E.coli 163Â) to 56% (Plasmodium falciparum). For the human dataset, only Allpaths-LG and Fiona could be run with the available memory, with a gain improvement of 35% for Fiona. Only for the E.coli (156Â) dataset Fiona and Coral* have comparable gain values, although Fiona runs approximately six times faster. Except for Fiona, all methods show a large variation in their ability to correct errors as shown in fluctuations of their gain values. For example, all datasets with an error rate 43.3% are poorly corrected when using Coral default parameters. In these evaluations, Allpaths-LG uses the lowest amount of memory. Fiona's memory usage scales linearly with the dataset size (Supplementary<ref type="figure" target="#tab_2">Table S2</ref>), which is in line with the expected memory consumption (Supplementary Section S2.6). Comparison on Illumina data. To show that Fiona is on par with methods that are optimized for Illumina data, we made comparisons on seven datasets. We compared Fiona-H, theNote: a The programs were run on machine with 16 physical and 32 virtual cores and 370 GB of RAM. b Out of memory—Time (in minutes and fractions thereof) and memory (in GB, rounded to the next GB) for the read correction runs from<ref type="figure" target="#tab_1">Table 1</ref>. For each dataset, the results with the lowest running time and memory are given in bold. The results are separated by sequencing technology; the 454 results are above the IonTorrent results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i361</head><p>Fiona: automatic read error connection version that corrects indels but only considers hamming pairwise read distance (Fiona-H) to Coral, Allpaths-LG, HiTEC and ECHO. On all datasets, Fiona-H and Allpaths-LG are the best two methods in terms of gain, with Fiona always being among the two first-ranked methods (<ref type="figure" target="#tab_5">Table S5</ref>, we list the runtime and memory consumption for these comparisons. Fiona-H scales well with dataset size and has lower memory consumption than HiTEC and Coral. Allpaths-LG and Quake were the fastest methods in our comparisons, with Fiona-H ranking third most of the time.</p><p>Of the remaining methods, Quake ranks second two times and third five times. This can be explained by the fact that Fiona examines an error at various seed lengths, whereas fixed-length seed methods examine it at most once.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>In this study, we introduced Fiona, a new algorithm for the correction of sequencing errors without the need for a reference sequence. Fiona builds over existing strategies to accurately correct errors, accounting for indels with automatic parameter selection. One of the main advantages of Fiona is the use of variable seed lengths, combined with a global optimization criterion to choose the best correction for a read. Our experiments show that Fiona outperforms other methods on datasets from different sequencing technologies.time<ref type="bibr">[min]</ref>gain<ref type="bibr">[%]</ref>454</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fiona: automatic read</head><figDesc>error connection</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>E(a, b) denotes the number of errors in an optimal right extension of a and b: Eða; bÞ=minf min l2½1;jaj edða½1; l; b½1; jbjÞ; min l2½1;jbj edða½1; jaj; b½1; lÞg : Considering the three possible types of error, we assume that skipping the actual error yields an optimal extension of the remaining suffixes. Hence,e 1 bases from position i in r and e 2 bases from position j in s and examine which value of e yields an optimal extension, i.e. a minimal value Eðr½i+e 1 ; jrj; s½j+e 2 ; jsjÞ. Figure 2 gives an example where e= 0 1 ! yields an optimal extension. We determine the actual error by a majority vote over all correct reads: VðeÞ=fðs; jÞ 2 SðxÞ e 2 arg min</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>Comparison on Ion Torrent data. We next compared the performance of the different methods on the eight Ion Torrent</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.4.</head><figDesc>Fig. 4. Scatterplots that show achieved gain and running time for Allpaths-LG (orange filled circles), Coral (dark yellow filled circles), Coral* (green filled squares), Fiona (turquoise filled dimonds), H-Shrec (blue filled triangles), and H-Shrec* (green filled triangles) on the various datasets for Ion Torrent (left) and 454 (right) technologies. The best-performing method appears in the upper left corner of a plot. Gain values below zero were arbitrarily reassigned a value of –1. In the case of E.coli, values for the four datasets for each tool are connected by a line</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>33.86 0.2777 32.30 0.1686 58.89 0.5045 –23.00 0.1963 52.15 Note: This table shows the same metrics as Table 1. a The program ran too long—The problems were Coral and HiTEC produced a segfault, requiring more than 72 GB of memory. b The program crashed. ECHO was killed after running more than 4 days in the case of C.elegans and D.melanogaster datasets and the subprogram NeighborJoin crashed on the full E.coli dataset; i362 M.H.Schulz et al.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>T G G C A C C G-A A A C C G G C A C C G T A A A C C G T A deletion T G G C A C C G A A A-C C G G C A C C G T A A A C C G T A</figDesc><table>substitution 

T G G C A C C G A A A --C C G 

G C A C C G -T A A A C C G T A 

insertion 
DP traces 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 1. Performance on 454 (top) and IonTorrent (bottom) datasets Note: a The programs were run on machine with 16 physical and 32 virtual cores and 370 GB of RAM. b Out of memory—The table shows the base error rate (e-rate, in percent) before and after correction with the methods as well as the gain statistic. For each dataset, the results with the best gain value are highlighted in bold. The results are separated by sequencing technology, the 454 results are above the IonTorrent results.</figDesc><table>Original 
Allpaths-LG 
Coral 
Coral* 
Fiona 
HybridShrec* 
HybridShrec F 

Dataset 
e-rate 
e-rate 
gain 
e-rate gain 
e-rate gain 
e-rate gain 
e-rate 
gain 
e-rate 
gain 

D.melanogaster 
18Â 1.17 
1.07 
8.87 
0.72 
38.81 0.55 
53.30 0.42 
64.62 
4.46 
–279.51 0.73 
38.17 
E.coli K-12 
13Â 1.06 
0.74 
30.68 
0.54 
49.42 0.38 
63.79 0.25 
76.88 
0.64 
40.05 0.70 
34.28 
S.aureus 
34Â 1.76 
1.34 
23.85 
1.76 
0.00 0.44 
74.90 0.53 
69.87 
1.59 
9.62 1.40 
20.50 
S.cerevisae 
16Â 0.95 
0.78 
18.45 
0.95 
0.56 0.92 
2.99 0.61 
36.04 
0.90 
5.48 0.73 
23.11 

B.pertussis 
85Â 3.71 
2.22 
40.13 
3.71 
0.02 2.57 
30.60 1.01 
72.83 12.44 
–235.48 4.07 
–9.68 
E.coli K-12 
8Â 0.62 
0.28 
54.46 
0.33 
46.86 0.30 
51.86 0.06 
90.52 
0.36 
41.81 0.37 
40.26 
E.coli K-12 
163Â 1.46 
1.23 
15.99 
0.59 
59.70 0.38 
73.72 0.27 
81.24 
1.73 
–18.90 1.46 
0.00 
E.coli K-12 
156Â 1.11 
0.75 
31.98 
0.43 
61.07 0.28 
74.70 0.29 
74.06 
1.38 
–24.15 1.11 
0.00 
E.coli O104:H4 
32Â 5.19 
3.09 
40.53 
5.19 
0.00 3.44 
33.82 1.59 
69.33 
4.39 
15.36 4.31 
16.76 
H.sapiens a 
11Â 1.62 
1.44 
11.52 
— b 
— b 
0.87 
46.68 
— b 
— b 
P.falciparum 3D7 
13Â 5.06 
3.97 
21.39 
5.05 
0.03 3.80 
24.94 2.33 
54.12 
7.67 
–51.29 4.63 
8.50 
S.aureus 
109Â 3.32 
2.83 
14.89 
3.32 
0.24 1.44 
56.91 1.17 
64.94 
3.77 
–13.44 3.31 
0.32 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Table 2.</figDesc><table>Running time and memory consumption for 454 (top) and IonTorrent (bottom) experiments 

Allpaths-LG 
Coral 
Coral* 
Fiona 
HybridShrec* 
HybridShrec F 

Dataset 
Gbp 
time 
mem 
time 
mem 
time 
mem 
time 
mem 
time 
Mem 
time 
mem 

D.melanogaster 
18Â 
2.2 
145.0 
11 
496.1 
59 
1414.1 
60 
240.7 
18 
333.2 
41 
499.5 
42 
E.coli K-12 
13Â 
0.06 
1.0 
0 
0 . 8 
3 
0 . 9 
3 
2 . 5 
1 
4 . 8 
5 
5 . 0 
1 2 
S.aureus 
34Â 
0.1 
3.0 
1 
5.5 
5 
112.2 
5 
12.3 
1 
12.0 
14 
13.6 
15 
S.cerevisae 
16Â 
0.19 
6.5 
1 
7.1 
5 
19.6 
5 
13.1 
2 
22.5 
15 
30.5 
15 

B.pertussis 
85Â 
0.3 
6.0 
2 
13.5 
9 
81.2 
9 
32.0 
3 
58.3 
17 
54.0 
21 
E.coli K-12 
8Â 
0.04 
2.6 
0 
3.4 
3 
4.4 
3 
3.1 
1 
7.1 
5 
9.2 
8 
E.coli K-12 
163Â 
0.8 
14.2 
4 
243.0 
13 
373.8 
13 
118.3 
9 
111.3 
19 
160.2 
6 
E.coli K-12 
156Â 
0.7 
15.0 
7 
249.1 
12 
290.1 
12 
49.2 
8 
111.4 
18 
111.0 
6 
E.coli O104:H4 
32Â 
0.2 
3.8 
1 
5.3 
8 
12.6 
8 
15.2 
2 
21.7 
15 
28.7 
16 
H.sapiens a 
11Â 
31.5 
572.8 
129 
— b 
— b 
1187.1 
244 
— b 
— b 
P.falciparum 
13Â 
0.3 
5.6 
1 
11.0 
11 
24.8 
11 
20.5 
3 
38.9 
16 
49.7 
20 
S.aureus 
109Â 
0.31 
4.4 
1 
12.0 
13 
175.8 
13 
43.7 
3 
51.1 
18 
53.8 
29 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>Table 3)</figDesc><table>. Fiona-H outperforms 
Allpaths-LG with a significant increase in gain of 17% on the 
D.melanogaster 5Â and P.syringae 41Â datasets. Conversely, 
Allpaths-LG ranks first, with a gain increase of 1–3.5% over 
Fiona-H on D.melanogaster 28Â, E.coli 30Â and the 
Caenorhabditis elegans dataset. Of the remaining methods, 
Quake ranks second two times and third five times. In 
Supplementary </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Table 3.</figDesc><table>Performance on Illumina datasets 

Original 
Allpaths-LG 
Coral 
ECHO 
Fiona-H 
HiTEC 
Quake 

Dataset 
e-rate 
e-rate 
gain 
e-rate 
gain 
e-rate 
gain 
e-rate 
gain 
e-rate 
gain 
e-rate 
gain 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">M.H.Schulz et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from For the evaluation of the different error correction methods we chose to use the gain statistic that is commonly used for this task. However, evaluating the accuracy of nucleotide corrections based on the available reference sequence can be misleading, as haplotype variants may be penalized and therefore the number of false-positive/negative corrections inflated. Despite this disadvantage, the comparison should not favor any method because all compared methods work exclusively on the read set without alignment to the reference sequence. We introduced a new statistic for error detection that uses a hierarchical model for the stepwise process of first selecting a subset of reads from a genome and then introducing errors during sequencing. This formulation provides an easily extendible framework and can be extended to accommodate more general scenarios, like the presence of heterozygous positions in diploid genomes, coverage overdispersion or the distribution of repeat elements, as well as base quality values. For our experiments, we fixed the error rate estimate to 5% for indel-prone datasets and show that reasonable variations to this value lead to minor performance differences. In principle, the error rate could be estimated from the base-calling procedure of the sequencer. Alternatively, it could be estimated from the raw sequencing data in a preprocessing step as was recently shown by Wang et al. (2012) for Illumina data. Further research on how to determine sequencing error rates in the context of de novo assemblies, where no reference sequence is available, is necessary. In conclusion, Fiona is a reliable method that automatically determines parameters, corrects indels and scales well to large datasets. We believe that users will improve their downstream analysis by using Fiona in their pipelines and made it publicly available at http://www.seqan.de/projects/fiona.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENT</head><p>The authors thank Enrico Siragusa for his partial suffix array implementation.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Replacing suffix trees with enhanced suffix arrays</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Abouelhoda</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Alg</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="53" to="86" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Short read fragment assembly of bacterial genomes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="324" to="330" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">SeqAn an efficient, generic C++ library for sequence analysis</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>€ Oring</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title level="m" type="main">High-quality draft assemblies of mammalian genomes from massively parallel sequence data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gnerre</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<publisher>PNAS</publisher>
			<biblScope unit="page" from="1513" to="1518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">HiTEC: accurate error correction in high-throughput sequencing data</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Ilie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="295" to="302" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">ECHO: a reference-free short-read error correction algorithm</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Kao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1181" to="1192" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Quake: quality-aware detection and correction of sequencing errors</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Kelley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">116</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Evaluation of genomic high-throughput sequencing data generated on Illumina HiSeq and Genome Analyzer systems</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Minoche</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">112</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<monogr>
		<title level="m" type="main">An eulerian path approach to dna fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>PNAS</publisher>
			<biblScope unit="page" from="9748" to="9753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">A tale of three next generation sequencing platforms: comparison of Ion Torrent, Pacific Biosciences and Illumina MiSeq sequencers</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Quail</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genomics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">341</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Correction of sequencing errors in a mixed set of reads</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Salmela</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1284" to="1290" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Correcting errors in short reads by multiple alignments</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Salmela</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Schr€ Oder</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1455" to="1461" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">GAGE: a critical evaluation of genome assemblies and assembly algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">SHREC: a short-read error correction method</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Schr€ Oder</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2157" to="2163" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Estimation of sequencing error rates in short reads</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<forename type="middle">V</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">185</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Reptile: representative tiling for short read error correction</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Yang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="2526" to="2533" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">A survey of error-correction methods for next-generation sequencing</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Yang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="56" to="66" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Fiona</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>