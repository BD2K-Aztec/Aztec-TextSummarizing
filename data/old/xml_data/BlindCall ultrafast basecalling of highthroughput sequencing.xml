
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:42+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">BlindCall: ultra-fast base-calling of high-throughput sequencing data by blind deconvolution</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Chengxi</forename>
								<surname>Ye</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Center for Bioinformatics and Computational Biology</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Chiaowen</forename>
								<surname>Hsiao</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Center for Bioinformatics and Computational Biology</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Applied Mathematics and Scientific Computing</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<settlement>College Park</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Hé</forename>
								<surname>Ctor Corrada Bravo</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Center for Bioinformatics and Computational Biology</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Applied Mathematics and Scientific Computing</orgName>
								<orgName type="institution">University of Maryland</orgName>
								<address>
									<settlement>College Park</settlement>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">BlindCall: ultra-fast base-calling of high-throughput sequencing data by blind deconvolution</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="issue">9</biblScope>
							<biblScope unit="page" from="1214" to="1219"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu010</idno>
					<note type="submission">Sequence analysis Advance Access publication January 9, 2014 Received on August 1, 2013; revised on December 12, 2013; accepted on January 6, 2014</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Associate Editor: Dr John Hancock</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Base-calling of sequencing data produced by high-throughput sequencing platforms is a fundamental process in current bioinformatics analysis. However, existing third-party probabilistic or machine-learning methods that significantly improve the accuracy of base-calls on these platforms are impractical for production use due to their computational inefficiency. Results: We directly formulate base-calling as a blind deconvolution problem and implemented BlindCall as an efficient solver to this inverse problem. BlindCall produced base-calls at accuracy comparable to state-of-the-art probabilistic methods while processing data at rates 10 times faster in most cases. The computational complexity of BlindCall scales linearly with read length making it better suited for new long-read sequencing technologies. Availability and Implementation: BlindCall is implemented as a set of Matlab scripts available for download at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Second-generation sequencing technology has revolutionized high-throughput genomics in life science and clinical research. The sheer scale of sequence generated by these instruments has allowed unprecedented views into a number of molecular phenomena, including population genetics, transcriptomics, epigenetics and translational profiling. Both the throughput and accuracy of second-generation sequencing instruments has increased at an accelerated pace in the last few years due to the use of high-resolution optics and biochemical methods that allow sequencing of billions of DNA fragments in parallel by generating fluorescence intensity signals that can be decoded into DNA sequences. However due to experimental and hardware limitations, these raw signals are inherently noisy (<ref type="bibr" target="#b0">Aird et al., 2011;</ref><ref type="bibr" target="#b4">Bravo and Irizarry, 2010;</ref><ref type="bibr" target="#b5">Dohm et al., 2008;</ref><ref type="bibr" target="#b6">Erlich et al., 2008</ref>). Base-calling is the essential step of converting these noisy fluorescent intensity signals into sequences used in downstream analysis. Providing accurate base-calls greatly reduces many difficulties in downstream bioinformatics analysis like genome assembly and variant calling (<ref type="bibr" target="#b1">Alkan et al., 2011;</ref><ref type="bibr" target="#b4">Bravo and Irizarry, 2010</ref>). Sequencing-by-synthesis (<ref type="bibr" target="#b3">Bentley et al., 2008</ref>) generates millions of reads of short DNA sequences by measuring in parallel the fluorescence intensity of billions of PCR-amplified and labeled clusters of DNA from a sample of interest. The DNA fragments attach to a glass surface where it is then PCRamplified in situ to create a cluster of DNA fragments with identical nucleotide composition. Sequence reads are generated from these DNA clusters in parallel and by cycles. A single nucleotide is sequenced from all DNA clusters in parallel by adding labeled nucleotides that incorporate to their complementary nucleotide. This synthesizes DNA fragments complementary to the fragments in each cluster as sequencing progresses. A set of four images is created measuring the fluorescence intensity along four channels to detect incorporation at each cycle. These images are then processed to produce fluorescence-intensity measurements from which sequences are then inferred by basecalling. In the default base-calling process for Illumina sequencers, called Bustard, the highest intensity in each quadruplet of intensity measurements determines the base at the corresponding position of the corresponding read. For current Illumina technologies, sequencers can produce up to 600 GB per run (<ref type="bibr">Illumina, 2013</ref>). The raw intensity signals generated by this process are known to be subject to several biases (<ref type="bibr" target="#b0">Aird et al., 2011;</ref><ref type="bibr" target="#b4">Bravo and Irizarry, 2010;</ref><ref type="bibr" target="#b5">Dohm et al., 2008;</ref><ref type="bibr" target="#b6">Erlich et al., 2008</ref>) (<ref type="figure" target="#fig_0">Fig. 1A</ref>and B). (i) Cross talk: there are significant correlations between different nucleotide channels; (ii) phasing/pre-phasing: the signal in one cycle can spread to the cycles ahead and the cycles after it; (iii) signal decay: where signal intensities become lower in later sequencing cycles; (iv) background noise: the signal to noise ratio becomes lower in later sequencing cycles. A significant challenge in base-calling is accounting for these biases. Existing base-calling methods can be classified into two major groups: (i) unsupervised model-based methods that capture the sequencing-by-synthesis process in a statistical model of fluorescence intensity from which base-call probabilities can be extracted directly (<ref type="bibr" target="#b4">Bravo and Irizarry, 2010;</ref><ref type="bibr" target="#b8">Kao and Song, 2011;</ref><ref type="bibr" target="#b9">Kao et al., 2009;</ref><ref type="bibr" target="#b14">Massingham and Goldman, 2012</ref>) and</p><p>(ii) supervised methods that train a statistical model on a set of base-calls whereby fluorescence intensity measurements are classified into base-calls (<ref type="bibr" target="#b6">Erlich et al., 2008;</ref><ref type="bibr" target="#b10">Kircher et al., 2009</ref>). The former methods have been shown to significantly improve the accuracy of Bustard base-calls. These model-based methods aim to capture the sequencing process described above in a statistical model from which base-call probabilities are usually obtained. While these probabilistic or machine-learning methods improve *To whom correspondence should be addressed. ß The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/3.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited. the accuracy of base-calls, they are impractical for use due to their computational inefficiency, which usually scales quadratically with read length since most of them resort to dynamic programming for model fitting (<ref type="bibr" target="#b8">Kao and Song, 2011;</ref><ref type="bibr" target="#b9">Kao et al., 2009;</ref><ref type="bibr" target="#b14">Massingham and Goldman, 2012</ref>). In this article, we show that the base-calling problem can be formulated as an optimization problem called blind deconvolution. Based on this observation, we developed BlindCall as a method that treats base-calling as a blind deconvolution problem (<ref type="bibr" target="#b12">Levin et al., 2011;</ref><ref type="bibr" target="#b20">Xu et al., 2013</ref>). We model intensity signals (B) output by the sequencer as the convolution of a latent sparse signal of interest X and a convolution kernel k modeling crosstalk and phasing biases, plus background noise N: B ¼ k Ã X þ N:</p><p>The blind deconvolution problem is to recover the latent signal X given only the observed B. This reduces the base-calling problem into solving an inverse problem that admits computationally efficient solutions. The blind deconvolution problem has been a research hotspot in recent years (<ref type="bibr" target="#b12">Levin et al., 2011;</ref><ref type="bibr" target="#b20">Xu et al., 2013</ref>) and we adapt methods for its solution to the base-calling problem (<ref type="bibr" target="#b18">Wang and Yin, 2010</ref>). BlindCall was able to provide base-calls at comparable accuracy to state-of-the-art probabilistic methods while processing data at rates ten times or faster in most cases. It scales linearly with read length and is thus better suited for new long-read sequencing technologies. Direct blind deconvolution modeling and the ultra-efficient processing based on optimization methods presented here are essential for bioinformatics analysis workflows to cope with increased throughput and read lengths in new sequencing technologies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>BlindCall follows the following architecture (<ref type="figure" target="#fig_1">Fig. 2A</ref>): a training module uses blind deconvolution (<ref type="figure" target="#fig_1">Fig. 2B</ref>) on a randomly sampled subset (e.g. 1000 reads) of the intensity data to iteratively estimate the convolution kernel k and produce a deconvolved signal from which base-calling is performed. The base-calling module then uses the convolution kernel estimated in the training module to produce a deconvolved output signal for the entire dataset and call bases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Blind deconvolution</head><p>We solve the blind deconvolution problem using an iterative procedure:</p><p>(i) fixing k and estimating latent signal X using a specific non-blind deconvolution method based on iterative support detection (ISD) (described below) and then (ii) fixing X to estimate convolution kernel k to correct for cross-talk and phasing effects. We divide the signal into nonoverlapping windows: in each 20-cycle window we assume an invariant convolution kernel. The discrete convolution can be written as matrix multiplication B ¼ KX, where K is a convolution matrix constructed from the kernel k. A normalization procedure is used in each iteration to account for intensity biases across channels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Channel intensity normalization</head><p>Intensity data for Illumina sequencing show certain biases, specifically (i) signal strength variation across channels, (ii) signal strength variation across clusters and (iii) signal decay over sequencing cycles. For accurate base-calling, these biases must be addressed through normalization. Traditionally, read normalization is applied to tackle the second and third problems first, in order to address the first problem. In our method, we circumvent the read normalization problem by analyzing the relative intensity ratio of successive calls across sequence reads. After an initial deconvolution in which cross-talk is corrected, we normalize each channel by scaling the intensities across reads by the same quantile (95%) in the respective channels and select the strongest channel after normalization as candidate base-calls. We then select successive candidate calls that are of different bases and construct a set of linear equations of the form x ik À r k x jk ¼ 0, where x ik and x jk are the relative intensity of channels in the k-th relation and r k is the observed intensity ratio for the k-th relation. The set of linear equations is then Rx ¼ 0, where R is a M Â 6 matrix, with M being the total number of base-calls pairs within consideration. To estimate x, we solve a least-squares problem under the constraint that x k k 2 ¼ 1: The solution is obtained by solving an eigenvalue problem since it can be formulated into the Rayleigh quotient min x k k 2 ¼1 Rx k k 2 , and its solution must satisfy the eigenvalue equation R t Rx ¼ lx: Since the number of base-calls across channels varies, the solution of this optimization problem favors channels that are called frequently. We normalize the problem using the number of base-calls and solve the generalized eigenvalue problem R t Rx ¼ lDx where D is a diagonal matrix that records the number of base-calls in each channel. This formulation can be interpreted as finding the stable state of a normalized non-linear diffusion, and is used in normalized cut (<ref type="bibr" target="#b17">Shi and Malik, 2000</ref>), Laplacian Eigenmaps (<ref type="bibr" target="#b2">Belkin and Niyogi, 2001</ref>), and PageRank (<ref type="bibr" target="#b15">Page et al., 1999</ref>). The estimated vector x is the relative intensity of each channel and we use it to normalize each channel in subsequent steps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Sparse signal reconstruction through ISD</head><p>To perform base-calling we need to reconstruct latent sparse signal X, corresponding only to nucleotide incorporation measurements given a convolution kernel k. A straightforward l 2 optimization problem to estimate latent signal X minimizes B À k Ã X k k 2 : We know the latent signal is sparser than the observed signal, so we add this property as a constraint to the least squares problem and use an iterative procedure to solve the problem under the sparsity constraint. This idea is termed ISD in the mathematical community (<ref type="bibr" target="#b18">Wang and Yin, 2010</ref>), and can also be applied to deconvolution problems stemming from image deblurring applications. In our case, the support (non-zero entries) detected for latent signal X corresponds exactly to base-calls. Assuming X Supp is the signal taking non-zeros only in the support set obtained using our support detection algorithm, we want to find an X that minimizes B À k Ã X k k 2 þl X À X Supp 2 : This optimization outputs a corrected signal subject to the support set constraint. The support detection procedure is critical to the output accuracy—if the support set is correct, we are close to our solution. At the beginning, we have no knowledge of the support set, since that directly tells us the answer. To tackle this, we use an increasing series l itr f g that puts increasing weight on the second constraint. This weight is low at first since the support set is not accurate. As we gradually refine the estimates we increase this weight. In our implementation, support detection is conducted by incorporating the channelnormalization method discussed in the previous section and picking the strongest normalized channel. We provide further mathematical justification as to why this iterative procedure recovers the clear intensity signals of incorporation events. For reference to the applications in image deblurring we refer to the convoluted signal B as the blurred signal, and to the latent signal X, the clear signal. Observation 1: Assume the clear signal is a non-negative signal with spikes, the convolution (blur) kernel is non-negative and k k k 1 ¼ 1, then the convoluted (blurred) signal is denser than the latent (clear) signal. This observation holds for all blurs since the blur spreads the spikes thus creates more non-zero intensities, so the support set becomes larger with the blurred signal. This observation hints us to design an optimization that favors sparse solutions:</p><formula>min X B À k Ã X k k 2 þl X k k p , 0 p 1:</formula><p>The second term is a sparse-inducing penalty. This sparse regularization problem is well known in wavelet analysis (<ref type="bibr" target="#b13">Mallat, 2009</ref>). We also have the following observation. Observation 2: By comparing the l p norm ð0 p 2Þ of the clear/ blurred signal, we discover that the sparse norm penalty favors the clear signal. As special cases: l 1 norm measures the total variation of the signal, thus the blurred signal and clear signal have the same l 1 norm.</p><p>The l 2 norm of the blur signal is smaller than that of the clear signal.</p><p>The support set for the blurred signal is larger than the clear signal, therefore it has larger l 0 cost.</p><p>The above observations suggest that we use a sparse norm to penalize the blur signal and make it resemble the clear signal. Thus, we analyze the deconvolution model with an l 0 penalty:</p><formula>min X B À k Ã X k k 2 þ X k k 0 :</formula><p>By introducing an auxiliary variable and using an exterior penalty technique, the above minimization problem is equivalent to solving the following optimization problem:</p><formula>min X B À k Ã X k k 2 þ w k k 0 þl w À X k k 2 , l ! þ1:</formula><p>One strategy to solve the above optimization is the alternating minimization technique (<ref type="bibr" target="#b19">Wang et al., 2008</ref>) and cast the problem into two sub-problems: (i) fixing X and analyzing the terms containing w, we have the w sub-problem:</p><formula>min w w À X k k 2 þ l w k k 0 :</formula><p>The solution can be found by entry-wise comparison (<ref type="bibr" target="#b13">Mallat, 2009;</ref><ref type="bibr" target="#b20">Xu et al., 2013</ref>) and the result is the so-called hard thresholding:</p><formula>w i ¼ X i , if jX i j4 ffiffi l p 0, otherwise :</formula><p>Then (ii) fix w, and analyze the terms containing X, we have</p><formula>min X B À k Ã X k k 2 þl w À X k k 2 :</formula><p>This optimization problem has the same form with our deconvolution model when w ¼ X Supp : In our ISD method, X Supp is obtained by adaptive hard thresholding, where is set adaptively to select strictly one non-zero element into the support set by selecting the channel with maximum intensity. Thus, our ISD method solves an optimization problem with an l 0 penalty favoring sparse signals corresponding to nucleotide incorporation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Convolution kernel estimation</head><p>Given latent signal X we use a least-squares method to estimate the convolution kernel k modeling cross-talk and phasing effects by solving:</p><formula>min k B À k Ã X k k 2 : C.Ye et al.</formula><p>We estimate convolution kernel k in two distinct steps: we use data from the first four cycles and only model cross-talk in the convolution kernel and use the blind-deconvolution iterative procedure to estimate cross-talk effects. We then fix the components of the convolution kernel corresponding to cross-talk effects for the remaining windows and estimate the components of the convolution kernel corresponding to phasing effects only. We assume the phasing effect is the same across channels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Deriving quality scores from deconvolved signal</head><p>We measure the quality of a base-call by the ratio of the intensity of the strongest channel and the sum of the two strongest channels after the deconvolution procedure. This number ranges between 0.5 and 1.0 and is used as the raw quality score. This scheme is similar to the one in Illumina's Bustard basecaller. Like most existing base-callers, we calibrate these raw quality scores by aligning reads to the reference genome and mapping raw quality scores to the alignment error rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Validation methods</head><p>The following datasets were used to test the accuracy and computational efficiency of BlindCall and state-of-the-art probabilistic methods: Illumina HiSeq 2000 phiX174: 1 926 928 single-end reads of 101 cycles from a single tile. Data was sequenced at the University of Maryland, College Park and is available for download at http://cbcb.umd.edu/ *hcorrada/secgen. Ibis Test: 200K single-end reads of phiX174 451 sequencing cycles. Bordetella pertussis: 100 tiles of 76-cycle single-end reads from the coccobacillus B.pertussis, using the complete genome of the Tohoma I strain as a reference. AYB phiX174: released with AYB and contains human sequence with a PhiX174 spike-in. The last three datasets were downloaded from the AYB authors' website (http://www.ebi.ac.uk/goldman-srv/AYB/#data).</p><p>To calculate accuracy we align the reads based on the phiX174 reference using Bowtie2 (<ref type="bibr" target="#b11">Langmead and Salzberg, 2012</ref>) with –end-to-end and –sensitive settings. Reported error rates are based on reads with no more than five substitution errors, following the methodology in Massingham and Goldman (2012). We used SparseAssembler (<ref type="bibr" target="#b21">Ye et al., 2012</ref>) to obtain assemblies from base-calls obtained by each method. To derive assembly statistics, we sub-sampled 100 datasets from the complete set of reads at 5Â, 10Â and 20Â coverage, and perform assemblies on each of these. We report N50 and maximum contig length for each resulting assembly. Version 1.9.4 of the Off-line basecaller was downloaded from Illumina to run Bustard. Version 2 of AYB was downloaded from http://www.ebi. ac.uk/goldman-srv/AYB. We ran AYB for 5 iterations as per its default setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>BlindCall is implemented as a set of Matlab scripts available at http://cbcb.umd.edu/*hcorrada/secgen. As an example of its computational efficiency, running BlindCall on a single-core Matlab instance on an Intel i7 3610QM laptop with 2.3–3.3 GHz processor and 8 GB of memory, we found that it was able to process 1 million bases/s, or 485 billion bases/CPU day. We note that a significant portion of its running time (50%) is spent on disk IO to read intensity data and write the fasta/fastq outputs. To the best of our knowledge, BlindCall is one of the fastest base-callers available at this time, even though it is implemented in a scripting language. A port of this algorithm into a lowerlevel language (C/Cþþ) will give further improvements on speed over the current Matlab version. We compared the running time of BlindCall to the state-of-the art probabilistic base-caller AYB (<ref type="bibr" target="#b14">Massingham and Goldman, 2012</ref>) and the state-of-the-art supervised learning method freeIbis (<ref type="bibr" target="#b16">Renaud et al., 2013</ref>) on a dataset of 1.9 million reads from a PhiX174 run on an Illumina HiSeq 2000 (<ref type="figure" target="#tab_1">Table 1</ref>). We found that BlindCall was able to process this dataset $20 times faster than AYB and 10 times faster than freeIbis while retaining similar accuracy. A plot of per cycle error rate of these basecallers (<ref type="figure">Fig. 3</ref>) shows that all methods produce significant improvements over Bustard, especially in later sequencing cycles. We observed a similar pattern when testing other datasets (<ref type="figure">Table 2</ref>). We also obtained better assemblies, especially at low coverage, using BlindCall, AYB and freeIbis relative to BustardAYB, accuracy and run times for Bustard. freeIbis and BlindCall for a dataset of 1.9 million reads from a HiSeq 2000 run of PhiX174. BlindCall Fast corresponds to noniterative version of the blind-deconvolution method. Running times for BlindCall are reported as (processing time/total time), where the total time includes reading intensity data from disk and writing base-calls to disk. For freeIbis, we report the time as (predicting time with single thread/ training time with 10 threads). BlindCall was able to produce base-calls of comparable accuracy to AYB and freeIbis at significantly faster computational time (8 min/12 min versus 217 min and 126 min, respectively). It is also faster than Bustard (8 min/12 min versus 17 min). AYB, freeIbis and BlindCall all improve on Bustard base calls. We also compared assemblies of the PhiX174 genome using reads generated by Bustard, BlindCall, freeIbis and AYB. The reported N50s and Max contig lengths are averages4100 random samples with the corresponding coverage (5Â, 10Â or 20Â). While BlindCall is able to process data at a significantly lower computational cost, the assemblies obtained using BlindCall are of comparable quality to those obtained using AYB or freeIbis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>BlindCall</head><p>base-calls (<ref type="figure" target="#tab_1">Table 1</ref>). We also found that the calibrated quality values obtained from BlindCall are very accurate (<ref type="figure" target="#fig_2">Fig. 4</ref>). We next compared each base-calling method's ability to scale to longer read lengths by calculating running time as a function of read length for the same dataset (<ref type="figure">Fig. 5</ref>). Like most probabilistic model-based base callers, AYB resorts to a dynamic programming strategy with quadratic running time complexity with respect to the read length. In contrast, BlindCall scales linearly with read length. freeIbis uses supervised learning approach, and while it also scales linearly with read length, its training time is much slower than BlindCall (even using 10 threads for freeIbis, compared to a single thread for BlindCall). Base-callers based on the blind deconvolution framework will be able to scale as sequencers produce longer reads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONCLUSION</head><p>BlindCall is a simple and ultra-fast non-probabilistic base-calling method for Illumina high-throughput sequencing data based on blind deconvolution. We have shown that it provides comparableAccuracy for Bustard, AYB and BlindCall on various datasets. BlindCall was able to produce comparable accuracy to state-of-the-art base callers at significantly faster computational time. All methods improve on Bustard base calls. Run times for BlindCall are reported as (training time/processing time/total time in minutes) where the total time includes reading intensity data from disk and writing base-calls to disk.<ref type="figure">Fig. 5</ref>. Base-calling by blind deconvolution is scalable to long read lengths. We compare the computational time of BlindCall with a stateof-the-art probabilistic base caller AYB, the state-of-the-art supervised learning method freeIbis and Illumina's Bustard on the PhiX174 dataset reported in<ref type="figure" target="#tab_1">Table 1</ref>as a function of the number of sequencing cycles. Since most model-based base callers resort to a dynamic programming solution, running time is quadratic with respect to the read length. In contrast, BlindCall scales linearly with read length. Base callers based on the blind deconvolution framework will be able to scale as sequencers produce longer reads. freeIbis also scales linearly but is much slower than BlindCall<ref type="figure">Fig. 3</ref>. Third-party base callers improve Bustard per-cycle error rate. We plot error rate of each base-caller per sequencing cycle on the PhiX174 test data. All three base callers significantly improve accuracy over Bustard, especially in later cycles. BlindCall is able to achieve comparable accuracy while processing data at a much faster rate</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Signal properties in the base-calling problem. (A) Fluorescence intensity measurements from one cluster for 50 sequencing cycles. Cross-talk and signal decay effects are clearly observed in this data. Background intensity increases as sequencing progresses. (B) The phasing effect demonstrated on a subset of data from (A). High intensity in the C channel in cycle 32 affects background intensity in the C channel in neighboring cycles</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. The BlindCall architecture. BlindCall consists of two modules: (A) the training module uses blind deconvolution and (B) to simultaneously estimate model parameters and produce a deconvolved signal from which base-calling is done. The calling module uses the parameters estimated in the training module to produce a deconvolved output signal</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.4.</head><figDesc>Fig. 4. BlindCall produces accurate calibrated quality scores. We plot observed error rates (on the PHRED scale) for Bustard, AYB and BlindCall as predicted by quality scores and observed high correlation for all base callers</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. Base callers accuracy and runtime comparison</figDesc><table>Bustard 
AYB 
BlindCall slow 
BlindCall fast 
freeIbis 

Perfect reads 
1 446 079 
1 532 000 
1 509 451 
1 508 779 
1 530 099 
Error rate (%) 
0.29 
0.21 
0.23 
0.23 
0.21 
Time (minimum) 
17 
217 
8/12 
4/8 
9/126 

Assembly results 
N50 
Maximum 
N50 
Maximum 
N50 
Maximum 
N50 
Maximum 
N50 
Maximum 
5Â 
610 
1122 
628 
1155 
629 
1164 
623 
1167 
649 
1184 
10Â 
3 375 
3469 
3198 
3322 
3382 
3487 
3389 
3485 
3306 
3418 
20Â 
4466 
4478 
4627 
4637 
4511 
4523 
4470 
4483 
4333 
4357 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 2. Accuracy comparison</figDesc><table>Ibis Test 
B.pertussis 
PhiX174 (AYB) 

Perfect reads 
Error rate (%) 
Perfect reads 
Error rate (%) 
Perfect reads 
Error rate (%) 

Bustard 
99 834 
1.45 
1 557 963 
2.01 
24 478 
0.49 
AYB 
133 537 
0.73 
2 304 005 
1.26 
26 878 
0.38 
BlindCall slow 
110 951 
1.12 
1 902 621 
1.61 
25 144 
0.45 
BlindCall fast 
105 312 
1.26 
1 856 286 
1.66 
24 740 
0.47 
Time 
Slow 
0.08/0.3/1 
0.11/6/10 
0.15/14/22 
Fast 
0.08/0.1/1 
0.11/3/8 
0.15/7/16 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="1215"> BlindCall at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from accuracy to probabilistic base-calling methods while producing base-calls at rates more than ten times faster. Almost all probabilistic methods solve the base-calling problem in a &apos;forward&apos; way, i.e. by setting a set of basis functions and searching for an optimal path, which often leads to dynamic programming solutions. Fitting these statistical methods is computationally expensive, and will not scale as the increase in sequencing throughput continues. Also, a stationarity assumption must be made in order to estimate parameters in these probabilistic methods through a Markov process. In contrast, BlindCall models base-calling as an &apos;inverse&apos; problem of blind deconvolution, which requires no probabilistic assumptions of the sequencing process. As steady progress has been made to improve the accuracy of probabilistic methods, we expect that similar progress will be made on non-probabilistic methods based on the blind deconvolution methods described in this article. Furthermore, these methods will be better suited to cope with increased throughput and read lengths of new sequencing technologies.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank Najib El-Sayed and the University of Maryland IBBR Sequencing core for their assistance with test data, James A. Yorke and his research group in University of Maryland for insightful discussions and Gabriel Renaud at Max Planck Institute for assistance with freeIbis.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Analyzing and minimizing PCR amplification bias in Illumina sequencing libraries</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Aird</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">18</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Limitations of next-generation genome sequence assembly</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Alkan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="61" to="65" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Laplacian eigenmaps and spectral techniques for embedding and clustering</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Belkin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Niyogi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Neural Inf. Process. Syst</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="585" to="591" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Accurate whole human genome sequencing using reversible terminator chemistry</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Bentley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">456</biblScope>
			<biblScope unit="page" from="53" to="59" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Model-based quality assessment and basecalling for second-generation sequencing data</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">C</forename>
				<surname>Bravo</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">A</forename>
				<surname>Irizarry</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biometrics</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="page" from="665" to="674" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Substantial biases in ultra-short read data sets from highthroughput DNA sequencing</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">C</forename>
				<surname>Dohm</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page">105</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Alta-Cyclic: a self-optimizing base caller for next-generation sequencing</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Erlich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="679" to="682" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">HiSeq Systems Comparison</title>
	</analytic>
	<monogr>
		<title level="j">Illumina</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">naiveBayesCall: an efficient model-based base-calling algorithm for high-throughput sequencing</title>
		<author>
			<persName>
				<forename type="first">W.-C</forename>
				<surname>Kao</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<forename type="middle">S</forename>
				<surname>Song</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol. A J. Comput. Mol. Cell Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="365" to="377" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">BayesCall: A model-based base-calling algorithm for highthroughput short-read sequencing</title>
		<author>
			<persName>
				<forename type="first">W.-C</forename>
				<surname>Kao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1884" to="1895" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Improved base calling for the Illumina Genome Analyzer using machine learning strategies</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kircher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">83</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with Bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Understanding blind deconvolution algorithms</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Levin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="2354" to="2367" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<monogr>
		<title level="m" type="main">A Wavelet Tour of Signal Processing : the Sparse Way</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">G</forename>
				<surname>Mallat</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Elsevier/ Academic Press</publisher>
			<pubPlace>Amsterdam/Boston</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">All Your Base: a fast and accurate probabilistic approach to base calling</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Massingham</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Goldman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<monogr>
		<title level="m" type="main">The PageRank citation ranking: bringing order to the web</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
	<note>Stanford. InfoLab</note>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">freeIbis: an efficient basecaller with calibrated quality scores for Illumina sequencers</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Renaud</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1208" to="1209" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Normalized cuts and image segmentation</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">B</forename>
				<surname>Shi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Malik</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Pattern Anal. Mach. Intell</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="888" to="905" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Sparse signal reconstruction via iterative support detection</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Wang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Yin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Imaging Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="462" to="491" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">A new alternating minimization algorithm for total variation image reconstruction</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<forename type="middle">L</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Imaging Sci</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="248" to="272" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Unnatural L 0 sparse representation for natural image deblurring</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Xu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference on Computer Vision and Pattern Recognition (CVPR &apos;13)</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1107" to="1114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Exploiting sparseness in de novo genome assembly</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Ye</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinform</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>Suppl. 6</note>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">BlindCall</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>