
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:39+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Pareto-optimal phylogenetic tree reconciliation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Ran</forename>
								<surname>Libeskind-Hadas</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Harvey Mudd College</orgName>
								<address>
									<postCode>91711</postCode>
									<settlement>Claremont</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yi-Chieh</forename>
								<surname>Wu</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">MIT</orgName>
								<address>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Mukul</forename>
								<forename type="middle">S</forename>
								<surname>Bansal</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of Connecticut</orgName>
								<address>
									<postCode>06269</postCode>
									<settlement>Storrs</settlement>
									<region>CT</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Manolis</forename>
								<surname>Kellis</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical Engineering and Computer Science</orgName>
								<orgName type="institution">MIT</orgName>
								<address>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Broad Institute</orgName>
								<address>
									<postCode>02142</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Pareto-optimal phylogenetic tree reconciliation</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="page" from="87" to="95"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu289</idno>
					<note>BIOINFORMATICS Availability and implementation: Our Python tools are freely available at www.cs.hmc.edu/$hadas/xscape. Contact: mukul@engr.uconn.edu Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Phylogenetic tree reconciliation is a widely used method for reconstructing the evolutionary histories of gene families and species , hosts and parasites and other dependent pairs of entities. Reconciliation is typically performed using maximum parsimony, in which each evolutionary event type is assigned a cost and the objective is to find a reconciliation of minimum total cost. It is generally understood that reconciliations are sensitive to event costs, but little is understood about the relationship between event costs and solutions. Moreover, choosing appropriate event costs is a notoriously difficult problem. Results: We address this problem by giving an efficient algorithm for computing Pareto-optimal sets of reconciliations, thus providing the first systematic method for understanding the relationship between event costs and reconciliations. This, in turn, results in new techniques for computing event support values and, for cophylogenetic analyses, performing robust statistical tests. We provide new software tools and demonstrate their use on a number of datasets from evolutionary gen-omic and cophylogenetic studies.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Phylogenetic tree reconciliation is a fundamental technique for studying the evolution of pairs of entities such as gene families and species, parasites and hosts and species and geographical regions. Recent algorithmic advances in tree reconciliation have led to seminal biological discoveries. Among these are the finding that 426% of extant gene families arose during the Archaean period between 3.33 and 2.85 billion years ago (<ref type="bibr" target="#b7">David and Alm, 2011</ref>), a study showing that interactions of species and their ecological niches are strongly conserved across the entire tree of life (G<ref type="bibr">omez et al., 2010</ref>), and new insights into the relationship between pathogenic RNA viruses and their hosts (<ref type="bibr" target="#b13">Jackson and Charleston, 2004</ref>). The reconciliation problem takes as input two trees and the associations between their leaves and seeks a mapping of one tree onto the other such that incongruence between the two trees is accounted for by a set of evolutionary events. In the context of gene family evolution, the two trees are the gene tree and the species tree, and in the well-studied Duplication-Transfer-Loss model (DTL), the events are speciation, duplication, transfer and loss. Unlike the simpler Duplication-Loss (DL) reconciliation model (<ref type="bibr" target="#b10">Goodman et al., 1979</ref><ref type="bibr" target="#b18">: Page, 1994</ref>), DTL accounts for transfer events and is thus broadly applicable across the tree of life. In the context of parasites and their hosts, the corresponding events are co-speciation, independent speciation, host switch and loss, respectively. In the context of species and area cladograms, these four events correspond to vicariance, sympatric speciation, dispersal and loss, respectively (<ref type="bibr" target="#b16">Morrone, 2009</ref>). Henceforth, we refer to this set of events as the DTL model and use the DTL event names. DTL-reconciliation is generally performed in a maximum parsimony framework in which each event type has an associated user-defined cost and the objective is to find a reconciliation of minimum total cost. Probabilistic approaches for DTL reconciliation, which do not require event cost assignments, also exist (<ref type="bibr" target="#b23">Szollosi et al., 2012;</ref><ref type="bibr" target="#b24">Tofigh, 2009</ref>), but these require estimates of other parameters, such as species divergence times, and are prohibitively slow for trees with more than a few leaves. If the species trees are fully dated, then maximum parsimony reconciliations can be found in polynomial time (<ref type="bibr" target="#b8">Doyon et al., 2010;</ref><ref type="bibr" target="#b15">Libeskind-Hadas and Charleston, 2009</ref>). However, accurately dating the internal nodes of a phylogenetic tree is generally difficult (<ref type="bibr" target="#b19">Rutschmann, 2006</ref>). In the absence of dates, reconciliations may be time-inconsistent in the sense that they can induce contradictory constraints on the relative order of the internal nodes. The problem of finding optimal time-consistent DTL-reconciliations in undated trees is known to be NP-hard (<ref type="bibr" target="#b12">Hallett et al., 2004;</ref><ref type="bibr" target="#b17">Ovadia et al., 2011</ref>). Therefore, a common approach, and the one followed in this article, is to relax the time-consistency requirement (<ref type="bibr" target="#b1">Bansal et al., 2012</ref><ref type="bibr" target="#b2">Bansal et al., , 2013</ref><ref type="bibr" target="#b5">Chen et al., 2012;</ref><ref type="bibr" target="#b7">David and Alm, 2011;</ref><ref type="bibr" target="#b25">Tofigh et al., 2011</ref>), which permits an optimal (although not necessarily time-consistent) solution to be found in O(mn) time (<ref type="bibr" target="#b1">Bansal et al., 2012</ref>), where m and n denote the number of nodes in the gene (parasite) and species (host) trees, respectively. Experimental evidence suggests that the solutions found using this approach are generally timeconsistent (<ref type="bibr" target="#b0">Addario-Berry et al., 2003</ref>); but see also<ref type="bibr" target="#b22">Stolzer et al. (2012)</ref>. Maximum parsimony reconciliations depend on the event costs. In the DTL model, speciations are considered 'null events' and are therefore typically assigned a cost of 0 while duplications, transfers and losses are assigned positive costs.<ref type="figure" target="#fig_1">Figure 1a</ref>shows a species (host) tree in black and a gene (parasite) tree in gray along with associations between their leaves. If duplication, transfer and loss each cost 1, then the reconciliation in<ref type="figure" target="#fig_1">Figure 1b</ref>is optimal, comprises one speciation and one transfer and has total cost 1. However, if duplication and loss cost 1 and transfer costs 5, then the maximum parsimony reconciliation in<ref type="figure" target="#fig_1">Figure 1c</ref>is optimal, comprises one speciation, one duplication and three losses and has total cost 4. Even small differences in event costs *To whom correspondence should be addressed. ß The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com. can induce different solutions when the trees are larger. For example, we have found that in many datasets, the default costs used in TreeMap (<ref type="bibr" target="#b4">Charleston, 1998</ref>) and Jane (<ref type="bibr" target="#b6">Conow et al., 2010</ref>) give rise to different reconciliations than those using the default costs in AnGST (<ref type="bibr" target="#b7">David and Alm, 2011</ref>) and RANGERDTL (<ref type="bibr" target="#b1">Bansal et al., 2012</ref>). Despite great advances in the efficiency and accuracy of DTLreconciliation, little is understood about the relationship between event costs and the resulting maximum parsimony reconciliations. A systematic way to handle the difficulty in determining appropriate event costs is to optimize for event counts rather than total numerical cost. We define an event count vector for a reconciliation to be a triple h; ; 'i, denoting the number of duplications, transfers and losses, respectively. These vectors do not explicitly count the number of speciation events because the number of speciations is implicit (it is m À À À 1). An event count vector v=h; ; 'i is strictly better than an event count vector v 0 =h 0 ; 0 ; ' 0 i if each entry of v is less than or equal to the corresponding entry in v 0 and at least one entry of v is less than its corresponding entry in v 0. A reconciliation is Pareto-optimal if there is no reconciliation with a strictly better event count vector. We use the term Pareto-optimal for both reconciliations and their corresponding event count vectors. Given the set of all Pareto-optimal event count vectors, we can partition the space of possible event cost assignments into equivalence classes, or 'regions', such that any two event cost assignments within the same region lead to the same optimal reconciliations. These regions provide insights into the relationships between event costs and maximum parsimony reconciliations and have numerous applications, including new definitions and algorithms for computing event consensus support.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Previous work</head><p>TreeMap (<ref type="bibr" target="#b4">Charleston, 1998</ref>) was the first to address the problem of uncertain event costs by enumerating Pareto-optimal solutions. However, TreeMap's underlying algorithm has worstcase exponential time and thus can only be used with small trees.<ref type="bibr" target="#b24">Tofigh (2009)</ref>later considered the problem of computing all Pareto-optimal solutions for the DTL-reconciliation problem but without accounting for losses; this simplifies the algorithmic problem but affects the accuracy of the reconciliation. Losses play a fundamental role in the ability to distinguish between duplications and transfers, and in mapping the nodes of the gene tree to the nodes of the species tree, and thus should be explicitly considered during reconciliation (<ref type="bibr" target="#b22">Stolzer et al., 2012</ref>). Thus, despite earlier work on Pareto-optimal reconciliations, there currently exist no algorithms or tools for computing or exploring the space of all Pareto-optimal DTL reconciliations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Our contributions</head><p>In this article, we give efficient algorithms that compute all Pareto-optimal DTL reconciliations and completely characterize the relationship between event costs and maximum parsimony reconciliations. Specifically, We give an algorithm for computing the Pareto-optimal event count vectors by extending the dynamic programming approaches that we and others have developed for the case of fixed event costs. Our algorithm has worst-case running time Oðm 5 nlog mÞ where m and n denote the number of leaves in the gene (parasite) tree and species (host) tree, respectively. The algorithm also counts the number of distinct reconciliations associated with each event count vector. In addition, we give a Oðm 4 log mÞ-time algorithm that uses the Pareto-optimal event count vectors to partition the event cost space into equivalence classes, or regions, such that event costs in a region give rise to the same set of maximum parsimony reconciliations. We present three applications of this algorithm and provide downloadable software tools for each one.</p><p>– The first tool, costscape, computes the Pareto-optimal event count vectors and provides a visualization of the corresponding regions.</p><p>– The second tool, eventscape, identifies the individual events that are common to the reconciliations in each region and uses this information to identify events that are strongly supported across the event cost space.</p><p>– The sigscape tool permits new, more robust statistical significance tests in cophylogenetic analyses.</p><p>We apply these tools to a number of datasets to demonstrate their utility. These results show that a small number of appropriately selected event costs can be used to capture a large fraction of maximum parsimony reconciliations; that a significant fraction of speciation events occur in every reconciliation across a wide range of event costs; and that duplications, transfers and losses are more sensitive to the choice of event costs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DEFINITIONS AND PRELIMINARIES</head><p>We follow the basic definitions and notation from<ref type="bibr" target="#b1">Bansal et al. (2012)</ref>. Given a tree T, we denote its node, edge and leaf sets by VðTÞ; EðTÞ and LeðTÞ, respectively. If T is rooted, the root node of T is denoted by rtðTÞ, the parent of a node v 2 VðTÞ by pa T ðvÞ, its set of children by Ch T ðvÞ and the (maximal) subtree of Trooted at v by T(v). The set of internal nodes of T, denoted I(T), is defined to be VðTÞnLeðTÞ. We define T to be the partial order on V(T) where x T y if y is a node on the path between rtðTÞ and x. The partial order ! T is defined analogously, i.e. x! T y if x is a node on the path between rtðTÞ and y. We say that y is an ancestor of x, or that x is a descendant of y, if x T y (note that, under this definition, every node is a descendant as well as ancestor of itself). We say that x and y are incomparable if neither x T y nor y T x. Given a non-empty subset L LeðTÞ, we denote by lca T ðLÞ the last common ancestor (LCA) of all the leaves in L in tree T, that is, lca T ðLÞ is the unique smallest upper bound of L under T. Given x; y 2 VðTÞ; x! T y denotes the unique path from x to y in T. We denote by d T ðx; yÞ the number of edges on the path x! T y; note that if x = y then d T ðx; yÞ=0. Throughout this work, the term tree refers to a rooted binary tree. We assume that the two input trees are denoted by T and S, and the goal is to map tree T to tree S. Thus, in gene-tree/speciestree reconciliation, T denotes the gene tree and S the species tree; in coevolutionary studies, T denotes the parasite tree and S the host tree; and in biogeographical studies, T denotes the species tree and S the area cladogram. Each leaf of tree T is labeled with the leaf-label from S with which it is associated. This labeling defines a leaf-mapping L T;S : LeðTÞ ! LeðSÞ that maps a leaf node t 2 LeðTÞ to the unique leaf node s 2 LeðSÞ, which has the same label as t. Note that T may have more than one leaf associated with the same leaf of S. Throughout this work we will implicitly assume that the species tree contains all the species represented in the gene tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Reconciliation and DTL scenarios</head><p>Next, we define what constitutes a valid DTL reconciliation; specifically, we define a Duplication-Transfer-Loss scenario (DTL-scenario) (<ref type="bibr" target="#b1">Bansal et al., 2012;</ref><ref type="bibr" target="#b25">Tofigh et al., 2011</ref>) for T and S that characterizes the mappings of T into S that constitute a biologically valid reconciliation. Essentially, DTL-scenarios (i) map each node of T to a unique node in S in a consistent way that respects the immediate temporal constraints implied by the topology of S, and (ii) designate each node of T as representing either a speciation, duplication or transfer event. DEFINITION 2.1 (DTL-scenario). A DTL-scenario for T and S is a seven-tuple hL; M; S; "; Â; Ä; i, where L : LeðTÞ ! LeðSÞ represents the leaf-mapping from T to S; M : VðTÞ ! VðSÞ maps each node of T to a node of S, the sets S; " and Â partition I(T) into speciation (or co-speciation), duplication and transfer nodes, respectively, Ä is a subset of edges of T that represent transfer edges and : Â ! VðSÞ specifies the recipient for each transfer event, subject to the following constraints:</p><p>(1) If t 2 LeðTÞ, then MðtÞ=LðtÞ.(4) If t 2 IðTÞ and t 0 and t 00 denote the children of t, then,(c) t 2 Â if and only if either ðt; t 0 Þ 2 Ä or ðt; t 00 Þ 2 Ä.</p><formula>(</formula><p>(d) If t 2 Â and ðt; t 0 Þ 2 Ä, then MðtÞ and ðtÞ must be incomparable, and Mðt 0 Þ must be a descendant of ðtÞ.</p><p>Constraint 1 above ensures that the mapping M is consistent with the leaf-mapping L. Constraint 2a imposes on M the temporal constraints implied by S. Constraint 2b implies that any internal node in G may represent at most one transfer event. Constraint 3 determines the edges of T that are transfer edges. Constraints 4a, 4b and 4c state the conditions under which an internal node of T may represent a speciation, duplication and transfer, respectively. Constraint 4d specifies which species may be designated as the recipient species for any given transfer event. DTL-scenarios correspond naturally to reconciliations, and it is straightforward to infer the reconciliation of T and S implied by any DTL-scenario. Given a DTL-scenario, one can directly count the minimum number of gene losses (<ref type="bibr" target="#b1">Bansal et al., 2012</ref>) in the corresponding reconciliation as follows.The total number of losses in the reconciliation corresponding to the DTL-scenario is defined to be Loss = X t2IðTÞ</p><p>Loss ðtÞ. We assume that speciations have zero cost, and let C " ; C Â and C L denote the assigned positive costs for duplication, transfer and loss events, respectively. Then the cost of reconciling T and S according to a DTL-scenario is defined as follows:</p><p>DEFINITION 2.3 (Reconciliation cost of a DTL-scenario). Given a DTL-scenario =hL; M; S; "; Â; Ä; i for T and S, the reconciliation cost associated with is given by</p><formula>C " Á j"j+C Â Á jÂj+C L Á Loss .</formula><p>The traditional goal of DTL-reconciliation is to find a most parsimonious reconciliation, i.e. a DTL-scenario for G and S with minimum reconciliation cost. However, in this work, we assume that the exact cost assignments, C " ; C Â and C L , are unknown; therefore, we focus on the inferred event counts rather than the reconciliation cost itself. DEFINITION 2.4 (Event count vector). Given a DTL-scenario = hL; M; S; "; Â; Ä; i for T and S, the event count vector associated with , denoted v , is defined to be hj"j; jÂj; Loss i. Given two DTL-scenarios =hL; M; S; "; Â; Ä; i and 0 = hL; M; S 0 ; " 0 ; Â 0 ; Ä 0 ; 0 i for T and S, the event count vector v is said to be strictly better than v 0 if each entry of v is less than or i89 Pareto-optimal phylogenetic tree reconciliation equal to the corresponding entry in v 0 and at least one entry of v is less than its corresponding entry in v 0. DEFINITION 2.5 (Pareto-optimal event count vector). Given a DTL-scenario =hL; M; S; "; Â; Ä; i for T and S, the event count vector v is said to be Pareto-optimal if there does not exist any other DTL-scenario 0 for T and S whose event count vector v 0 is strictly better than v .</p><p>Given trees T and S and leaf-mapping L T;S , our goal is to find all Pareto-optimal event count vectors for the two trees. Note that, if an event count vector h; ; 'i is Pareto-optimal, then there exists some assignment of values for C " ; C Â and C L for which a most parsimonious reconciliation invokes exactly duplications, transfers and ' losses. Thus, the set of all Paretooptimal event count vectors provides a relationship between event cost assignments and most parsimonious reconciliations. PROBLEM 1 (Pareto-optimal vectors). The Pareto-optimal vectors (PV) problem is to find the set of all Pareto-optimal event count vectors for trees T and S and their leaf-mapping L T;S .</p><p>The set of Pareto-optimal vectors obtained by solving the PV problem can then be used to partition the space of possible event cost assignments into 'equivalent' regions.</p><p>PROBLEM 2 (Equivalent Region Partition). Given T; S; L T;S and the set of all Pareto-optimal event count vectors for the two trees, the equivalent region partition (ERP) problem is to partition the space of possible event cost assignments into disjoint regions such that any two event cost assignments within the same region yield the same set of maximum parsimony reconciliations.</p><p>In the next section, we first show how to efficiently solve both the PV and ERP problems. In the subsequent sections, we use these algorithmic results as the basis of new software tools and then demonstrate the utility of these tools on several biological datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ALGORITHMS</head><p>Our algorithm for the PV problem is based on an extension of the dynamic programming framework for computing most parsimonious DTL reconciliations with known event costs, e.g. (<ref type="bibr" target="#b1">Bansal et al., 2012</ref>).<ref type="bibr" target="#b24">Tofigh (2009)</ref>was the first to adapt the dynamic programming algorithm to compute Pareto-optimal event count vectors. However, that result did not count losses, which significantly simplifies the dynamic programming algorithm and also bounds the number of Pareto-optimal event count vectors to just O(m), resulting in an Oðm 3 nÞ-time algorithm, where m=jLeðTÞj and n=jLeðSÞj. In developing an efficient algorithm for the PV problem, we not only show how to efficiently account for losses in the dynamic programming algorithm [using ideas from<ref type="bibr" target="#b1">Bansal et al. (2012)</ref>] but also show how to efficiently maintain the resulting larger set of Pareto-optimal event count vectors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Solving the PV problem</head><p>Given any t 2 IðTÞ and s 2 VðSÞ, let P S ðt; sÞ denote the set of Pareto-optimal event count vectors for reconciling T(t) with S such that t maps to s and t 2 S. The terms P " ðt; sÞ and P Â ðt; sÞ are defined similarly for t 2 " and t 2 Â, respectively. Given any t 2 VðTÞ and s 2 VðSÞ, we define Pðt; sÞ to be the set of Paretooptimal event count vectors for reconciling T(t) with S such that t maps to s. Our algorithm performs a nested post-order traversal of T and S to compute Pðt; sÞ for each t and s. Given two sets A and B of Pareto-optimal event count vectors, we define A È B to be the set obtained by taking the union of the event count vectors in A and B and then selecting the subset of event count vectors that are Pareto-optimal. Similarly, A B is defined to be the set obtained by first computing the Cartesian product of A and B, then converting each resulting ordered pair into a single event count vector by adding the two vectors of the ordered pair, and finally taking only the subset of Pareto-optimal event count vectors. These operations will be used when merging the Pareto-optimal event count vectors from smaller subproblems to compute the Pareto-optimal event count vectors for larger subproblems. The dynamic programming table for Pðt; sÞ is initialized and computed as shown below:We now analyze our algorithm and prove its correctness. Recall that m and n denote the number of leaves in T and S, respectively. LEMMA 3.1. The cardinality of any set of Pareto-optimal event count vectors can be no greater than Âðm 2 Þ. PROOF. Consider any event count vector h; ; 'i. Let A be any set of Pareto-optimal event count vectors. Suppose A contains more than one vector with identical values for and but different values for '. Clearly, only one of these vectors can be Pareto-optimal (the one with the lowest value for '). Thus, for any pair of fixed values for and , A may contain at most one vector with that assignment of values for and. Because the values of and are both bounded by m – 1, the number of internal nodes in T, the lemma follows.Complexity: Because both A and B contain at most Oðm 2 Þ vectors (Lemma 3.1), Steps 4 through 12 are each executed Oðm 4 Þ times. By using a self-balancing binary search tree to represent Z, each of these steps can be executed in Oðlog mÞ time, yielding a total time complexity of Oðm 4 log mÞ for Steps 1 through 12. Because the time complexity of Step 13 is OðjZj 2 Þ, it now suffices to show that the size of Z never exceeds m 2 at any time. Consider Steps 8 and 12. These steps ensure that for any fixed value of , and , there is at most one vector in Z of the form h; ; 'i. Thus, the size of Z can not exceed Oðm 2 Þ at any time. Based on the pseudo-code for Algorithm Pareto-Reconcile, and on the previous three lemmas, the next two theorems follow easily. For brevity, their proofs appear in Supplementary Section S1. THEOREM 3.1. Algorithm Pareto-Reconcile correctly solves the PV problem. THEOREM 3.2. The total time complexity of Algorithm ParetoReconcile is Oðm 5 nlog mÞ. In addition, the algorithm can be implemented so that its total space complexity is Oðm 3 nÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Equivalent region partition</head><p>In this section, we describe how the set of Pareto-optimal event count vectors can be used to efficiently partition the space of event costs into a finite number of equivalence classes, or 'regions', such that all event costs in a given region induce the same set of maximum parsimony reconciliations. These regions i91</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pareto-optimal phylogenetic tree reconciliation</head><p>provide insights into the relationship between the event costs and the resulting solutions and are used in several of the software tools described in the next section. Recall that we assume that speciation is a 'null' event with cost 0 and all other events have positive costs. Because the costs are unit-less, duplication cost is normalized to 1 and the costs of transfer and loss are non-negative values relative to the unit cost of duplication. For a given event count vector v=h; ; 'i and positive real transfer and loss costs C Â and C ' , respectively, the cost of that solution, denoted Cðv; C Â ; C ' Þ, is +C Â Á +C L Á '. Let A denote the Pareto-optimal set of event count vectors for a given pair of trees and leaf mapping. These vectors induce a partition of the event cost space into regions where the region R(v) associated with event count vector v 2 A is the set of pointsis the intersection of those half-spaces. The intersection of N half-spaces can be found in time OðNlog NÞ (<ref type="bibr" target="#b3">Berg et al., 2008</ref>) and thus each region can be found in time Oðm 2 log mÞ. Thus, all jAj regions can be found in time Oðm 4 log mÞ.</p><formula>ðC ; C ' Þ 2 R + Â R + such that Cðv; C Â ; C ' Þ Cðv 0 ; C Â ; C ' Þ; 8v 0 2 A À v.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Counting solutions and enumerating events</head><p>Our algorithm for the PV problem can be easily adapted to count the number of maximum parsimony reconciliations for each Pareto-optimal event count vector and to record the events in those reconciliations. To count the number of distinct reconciliations, we keep track of the number of solutions associated with each event count vector in each subproblem Pðt; sÞ. Those values are easily updated based on the number of solutions from the subproblems from which Pðt; sÞ is constructed (<ref type="bibr" target="#b2">Bansal et al., 2013</ref>). The additional bookkeeping does not increase the asymptotic running time of the algorithm. In addition, the dynamic program can be augmented to keep track of the set of events occurring in the reconciliations associated with a Pareto-optimal event count vector. While the number of reconciliations can grow exponentially with the m and n, the total number of distinct events is bounded by Oðmn 2 Þ because each of the O(m) nodes of T can be mapped to at most O(n) nodes in S and, for transfer events, there are O(n) possible destinations for the 'landing site'. For each subproblem Pðt; sÞ we can, therefore, maintain a set of associated events such as the union or intersection of all events that occur in that subproblem. This increases the asymptotic running time by a factor that depends only on the time complexity of the particular set theoretic operation. For example, we use set intersection in the eventscape tool described in the next section, which contributes a multiplicative factor of Oðmn 2 log mnÞ using self-balancing binary search trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">APPLICATIONS AND SOFTWARE</head><p>In this section, we demonstrate three programs that use the algorithmic results in the previous section to provide new insights into maximum parsimony reconciliation. Each of these tools solves the PV and ERP problems and uses those solutions in different ways. We note that while our algorithms can compute all Pareto-optimal regions, these tools take a user-specified a range of costs for transfer and loss events, relative to the normalized unit cost of duplication, and restrict the Pareto-optimal event count vectors and corresponding regions to that event cost space. (We note that the choice of fixing the duplication cost to 1 and normalizing the remaining costs with respect to duplication is arbitrary). The first tool, costscape, computes the Pareto-optimal event count vectors and their corresponding regions as well as a 'Count' of the number of distinct maximum parsimony reconciliations in each region. These results are displayed graphically to provide a systematic overview of the relationship between event costs and the structure of the maximum parsimony solution space. For example,<ref type="figure" target="#fig_2">Figure 2a</ref>and b show the results of using costscape on the canonical gopher-louse (<ref type="bibr" target="#b11">Hafner and Nadler, 1988</ref>) and indigobird-finch (<ref type="bibr" target="#b21">Sorenson et al., 2004</ref>) datasets for transfer and loss costs ranging from 0.1 to 5, relative to the unit cost of duplication. The second tool, eventscape, augments the dynamic programming algorithm to compute the set of events that are common to every reconciliation in a region. Eventscape then collects all of these events over all regions and partitions that set into the set of events that are found in exactly one region, exactly two regions and so forth up to the total number of regions. Each event includes a gene (parasite) node, its association with a species (host) node and the type of event. In the case of transfers, the landing site of the event is also specified. One important application of eventscape is in identifying events that are highly supported by merit of occurring in a large fraction of the regions or the cost space. The next section explores this application on a large collection of datasets. The third tool, sigscape is designed for cophylogenetic analyses where permutation tests are performed to test the null hypothesis that the host and parasite trees are similar owing to chance. Shades of each color indicate variations in P-values, with brighter shades indicating smaller P-values. For example, for the gopher-louse dataset using transfer and loss costs ranging from 0.1 to 5 and using 1000 permutations, sigscape found 97:6 % of the event cost space to have significance at the 0.01 level, 1:5% to have significance between 0.01 and 0.05, and 0:9% below the 0.05 level (<ref type="figure" target="#fig_2">Fig. 2c</ref>). More details about sigscape are provided in Supplementary Section S2. These tools, collectively called xscape, are written in Python and are freely available at www.cs.hmc.edu/$hadas/xscape. As noted earlier, the underlying algorithms do not guarantee timeconsistent solutions because finding such solutions is NP-hard i92 (<ref type="bibr" target="#b17">Ovadia et al., 2011</ref>). However, if the species trees are fully dated, then our algorithms can be modified (resulting in slower polynomial-time algorithms) to guarantee time-consistency (<ref type="bibr" target="#b6">Conow et al., 2010</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>In this section, we demonstrate the utility of our algorithms and tools on a diverse collection of datasets. Currently, reconciliation analyses infer evolutionary events by choosing a set of event costs (often the default costs in the software, although most tools recommend experimenting with different costs) and constructing reconciliations based on these costs. Because event costs are not easily estimated and the choice of costs affects the reconciliations, we seek here to understand the impact of event costs on the resulting reconciliations. We first analyzed a biological dataset consisting of predominantly prokaryotic species sampled broadly from across the tree of life (<ref type="bibr" target="#b7">David and Alm, 2011</ref>). This consisted of 4860 gene trees (with at least two extant genes) over 100 species, but, for efficiency, we restricted our analyses to a subset of 3433 gene families from 20 randomly sampled species and evaluated event counts and their corresponding event cost regions for transfer and loss costs ranging from 0.5 to 2 (with respect to the unit cost of duplication). The results presented here exclude 34 (51.0%) gene families for which eventscape used more than the allocated 5 GB of RAM in our experimental setup. Using the costscape tool, we observed that 85.8% (2917) of the gene families induce at least two regions, 37.5% (1274) have at least five regions and that the number of regions grows as a function of tree size (<ref type="figure" target="#fig_9">Fig. 3a</ref>). Thus, the common practice of selecting a single cost setting or a small fixed number of cost settings [e.g.,<ref type="bibr" target="#b22">Stolzer et al. (2012)</ref>considered three settings, and<ref type="bibr">Bansal et al. (2013) considered five]</ref>can result in missing potentially important parts of the solution space. Additionally, many regions have zero area (e.g. lines or points), meaning that the associated reconciliations are unlikely to be discovered by an ad hoc choice of event costs: for this dataset, 54.1% (1839) of the gene families have at least one region with zero area, and for 19.7% (669) of the gene families, more than half of the regions have zero area. We also found that a systematic choice of event costs (e.g. using costscape) can cover a substantial portion of the solution space. For example, for all gene families studied here, an appropriately selected subset of five or fewer regions covers the majority (450%) of the event cost space (<ref type="figure" target="#fig_9">Fig. 3b</ref>), and coverage of the event cost space appears to follow a power law distribution (Supplementary<ref type="figure" target="#fig_1">Fig. S1</ref>). Although these results seem to suggest that a small set of event costs (and their associated regions) is representative of the entire event cost space, we note that coverage of event cost space is a biased measure, as some large regions may include cost ratios that are biologically unrealistic while other regions containing biologically plausible ratios might cover a small fraction of the event cost space. Regions of zero area, for example, are generally abundant and may contain a biologically relevant solution. While these results provide some preliminary understanding of the relationship of event costs and the space of maximum parsimony reconciliations, further research is needed to understand the properties of this space and, ultimately, to determine appropriate event costs. Next, we focus on the identification of well-supported events across the event cost space. Given a user-specified event cost space, that is, a range of costs on transfer and loss (with respect to the unit cost of duplication), we used the eventscape tool to infer the Pareto-optimal regions and the sets of events that are common to 1;. .. ; k regions, where k is the total number of regions in the event cost space. We define an event to have consensus support s, 0 s 1 (with respect to the event cost space), if the event is found in every reconciliation in at least a fraction s (inclusive) of the regions. Note that this is one of many possible measures of event support, and our algorithms can be used to define and compute other measures.</p><formula>(a) ( b) ( c)</formula><p>Fig. 2. Pareto-regions for the (a) gopher-louse and (b) indigobird-finch datasets. Colors are arbitrary and are used to match regions with the event counts in the legend. The displayed event counts comprise the number of speciations in addition to the number of duplications, transfers and losses. In addition, the 'Count' field indicates the number of distinct reconciliations in each region. While most regions are polygons, regions may also be points or lines, such as in the first region in the legend in (a). (c) Results of a permutation test on the gopher-louse dataset using 1000 random trials. For (c) only, green indicates significance at the 0.01 level, yellow represents significance between 0.01 and 0.05 and red indicates lack of significance at the 0.05 level. Brightness of green, yellow and red indicates differences in P-values, with brighter shades indicating smaller P-values.Using this definition, we investigated the fraction of events supported at various support thresholds (<ref type="figure">Fig. 4a</ref>). Almost universally, speciations are the best supported type of event, with $33.2% of speciations supported under strict consensus (that is, found in all regions). Manual inspection revealed that speciations found near the root of the tree were often conserved across multiple regions. However, when analyzing gene family evolution, we are typically interested in the inferred duplications, transfers and losses (collectively, the DTL events), and we found that few of these have high support. For example, only 2.1% of duplications, 15.1% of transfers and 2.1% of losses have at least 80% support (though the percentage of events with at least 50% support is substantially higher, with 56.8% of duplications, 41.4% of transfers and 34.9% of losses supported at that level). Interestingly, we observed a 'jump' in the number of supported events around a support threshold of 50%. Also, in general, for most support thresholds, duplications are the most supported type of event (after speciation), followed by transfers, then losses; however, for low support thresholds, the three types of DTL events show roughly equal support. These results have important implications for existing analyses that rely on DTL reconciliation and suggest that many inferred events are highly specific to the user-defined event costs. In this study, we have investigated a specific range of event costs (transfer and loss ranging from 0.5 to 2 relative to the unit cost of duplication). The number of regions, and thus the level of consensus support, depends on this range. Moreover, our analyses permitted cost combinations in which duplications are more expensive or less expensive than transfers and losses. Adding constraints on these cost relationships could alter the levels of support. We also note that manual inspection revealed that loss events, and to a lesser extent transfers, are often 'fungible' in the sense that they can be moved from one location to another without changing the total cost of the solution, and thus any individual loss or transfer event is not likely to be strongly supported. By looking at the event cost space and supported events, our tools allow the elucidation of the complex interplay between event cost assignments and event support under various ranges and constraints of event costs. For completeness, we also determined event support as measured by fraction of the event cost space (rather than fraction of the number of regions) covered (<ref type="figure">Fig. 4b</ref>), yielding similar results. The main difference between these two measures is that event support increases gradually with increasing region coverage but tends to 'jump' with increasing event cost space coverage; this confirms our finding that the event cost space is dominated by a few large regions. Otherwise, duplications also show a clear demarcation from no support to high support at $66.7% coverage. To demonstrate the applicability of our tools on cophylogenetic datasets, we performed similar analyses on five host–parasite datasets and found results consistent with those above (Supplementary Section S3, Supplementary<ref type="figure" target="#fig_2">Fig. S2</ref>). Finally, the average runtimes for our tools is on the order of seconds (Supplementary<ref type="figure" target="#tab_1">Table S1</ref>). To demonstrate scalability, we also ran costscape on the full 100-taxa tree of life dataset (also using transfer and loss costs ranging from 0.5 to 2) and found that the median runtime remains 51 min.whereas a sampling approach would necessarily capture only a subset of the event cost space. Using the tools based on our algorithms, we have conducted experiments on a broad array of datasets. These results show that the space of maximum parsimony solutions is complex and sensitive to the event costs, and thus, choosing ad hoc event costs may result in misrepresenting evolutionary histories. At the same time, we cannot discount ad hoc procedures for finding event costs [for example, through comparison to event inferences on a biological dataset, as in<ref type="bibr" target="#b7">David and Alm (2011)]</ref>. In particular, such approaches may elucidate the boundaries for biologically reasonable event cost assignments, which could then be used as input into our tools for more systematic analysis. In addition, by defining notions of consensus support based on the number of regions that share an event, we found that while many speciation events have high consensus support, most other events do not. Thus, inferring events based on non-systematically selected event costs is likely to provide only a piece of a complex picture, and our tools motivate further investigation into the robustness of analyses based on DTL reconciliation. There are numerous interesting directions for future work. In particular, this work affords opportunities to explore many variants of event consensus support. For example, our work uses the most specific definition of an event in computing support: for a speciation, duplication or transfer to be supported across different reconciliations, a gene (parasite) tree node must map to the same species (host) tree node and to the same event, and transfers must also yield the same transfer edge. Similarly, for two losses to be supported across different reconciliations, they must be found along the same branch of both the gene tree and species tree. In some cases, analyses only require the species mapping (<ref type="bibr" target="#b7">David and Alm, 2011</ref>) or event mapping (<ref type="bibr" target="#b14">Koonin, 2005</ref>), and thus the support values must be considered for these relaxed definitions of events. Our algorithms can be modified accordingly. In addition to identifying highly supported events, it is desirable to find highly supported whole reconciliations. In the spirit of promising recent work on this problem for fixed event costs (<ref type="bibr" target="#b20">Scornavacca et al., 2013</ref>), one promising research direction is to identify and succinctly represent whole reconciliations that are robust across the space of event costs. In summary, this work provides techniques and tools that are immediately useful in the phylogenomic, cophylogenetic and biogeography analyses and offers avenues for further research that leverages the Pareto-optimal reconciliation methods developed here</p><formula>(a) ( b)</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.1.</head><figDesc>Fig. 1. (a) A species (host) tree in black and a gene (parasite) tree in gray with the leaf associations shown in dotted lines. (b and c) Two different reconciliations with events labeled by type</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>(2)</head><figDesc>If t 2 IðTÞ and t 0 and t 00 denote the children of t, then, (a) MðtÞ 65Mðt 0 Þ and MðtÞ 65Mðt 00 Þ, (b) At least one of Mðt 0 Þ and Mðt 00 Þ is a descendant of MðtÞ. (3) Given any edge ðt; t 0 Þ 2 EðTÞ; ðt; t 0 Þ 2 Ä if and only if MðtÞ and Mðt 0 Þ are incomparable.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>DEFINITION2.</head><figDesc>2 (Losses). Given a DTL-scenario =hL; M; S; "; Â; Ä; i for T and S, let t 2 VðTÞ and ft 0 ; t 00 g=ChðtÞ. The number of losses Loss ðtÞ at node t is defined to be jd S ðMðtÞ; Mðt 0 ÞÞ À 1j+jd S ðMðtÞ; Mðt 00 ÞÞ À 1j, if t 2 S. d S ðMðtÞ; Mðt 0 ÞÞ+d S ðMðtÞ; Mðt 00 ÞÞ, if t 2 ". d S ðMðtÞ; Mðt 00 ÞÞ+d S ððtÞ; Mðt 0 ÞÞ, if ðt; t 0 Þ 2 Ä.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>Given an event count vector, v=h; ; 'i, we use the notation v+ð"; iÞ, for i 2 Z + , to denote the event count vector where the count for duplications is incremented by i, i.e. h+i; ; 'i. The vectors v+ðÂ; iÞ and v+ðL; iÞ are defined analogously for transfers and losses, respectively. We extend this notation to a set of event count vectors, A, as follows: A+ð"; iÞ represents the set fv+ð"; iÞ : v 2 Ag. The sets A+ðÂ; iÞ and A+ðL; iÞ are defined analogously. We define inðt; sÞ= È x2VðSðsÞÞ ðPðt; xÞ+ðL; d S ðs; xÞÞÞ, outðt; sÞ= È x2VðSÞ incomparable to s Pðt; xÞ, and inAltðt; sÞ= È x2VðSðsÞÞ Pðt; xÞ. Our algorithm computes P S ðt; sÞ; P " ðt; sÞ and P Â ðt; sÞ for each t 2 VðTÞ and s 2 VðSÞ by performing a nested post-order traversal of T and S. The values inðÁ; ÁÞ; outðÁ; ÁÞ and inAltðÁ; ÁÞ help to reuse previously computed information to efficiently compute the values P S ðt; sÞ; P " ðt; sÞ and P Â ðt; sÞ at each step. The exact formulas for computing the values of P S ðt; sÞ; P " ðt; sÞ and P Â ðt; sÞ using previously computed values are given in steps 17, 18 and 19 of the algorithm below. The nested post-order traversal ensures that when computing P S ðt; sÞ; P " ðt; sÞ and P Â ðt; sÞ at nodes t 2 G and s 2 S, all the required inðÁ; ÁÞ; outðÁ; ÁÞ; inAltðÁ; ÁÞ and PðÁ; ÁÞ values have already been computed. Note that once all the PðÁ; ÁÞ sets have been computed, the set of Pareto-optimal event count vectors for the reconciliation of T and S is simply È s2VðSÞ PðrtðTÞ; sÞ. The algorithm is as follows: Algorithm Pareto À ReconcileðT; S; LÞ 1: for each t 2 VðTÞ and s 2 VðSÞ do 2: Initialize Pðt; sÞ; P S ðt; sÞ; P " ðt; sÞ; P Â ðt; sÞ; inðt; sÞ; inAltðt; sÞ, and outðt; sÞ to 1. 3: for each t 2 LeðTÞ do i90 R.Libeskind-Hadas et al.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>To complete our description of the above algorithm, we must also show how to efficiently perform the operations A È B and A B, for any two sets A and B of Pareto-optimal event count vectors. Operation A È B can be performed in Oðm 4 Þ time using a straightforward algorithm (Lemma 3.2 below). Computing A B efficiently is more involved. From Lemma 3.1 (below), each Pareto-optimal set has size Oðm 2 Þ. Thus, computing their Cartesian product takes time Oðm 4 Þ. Finding the subset of Pareto-optimal vectors by pairwise comparisons would thus take Oððm 2 Â m 2 Þ 2 Þ=Oðm 8 Þ time. We now show how A B can be computed in Oðm 4 log mÞ time. Procedure Perform À ðA; BÞ 1: Create an empty ordered list Z that will be used to store event count vectors in lexicographically sorted order. 2: for each a 2 A do 3: for each b 2 B do 4: Compute the vector a+b. Let this new vector be denoted as c=h; ; 'i. 5: Insert c into Z (maintaining lexicographic order). 6: Consider the element d immediately before c in the list Z. 7: if d exists and is of the form h; ; ' À xi, where x ! 0 then 8: Delete c from Z. 9: else 10: Consider the element e immediately after c in the list Z. 11: if e exists and is of the form h; ; '+xi, where x ! 0 then 12: Delete e from Z. 13: Delete from Z all vectors that are not Pareto-optimal. 14: Return Z.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>LEMMA 3.2.</head><figDesc>Given any two sets, A and B, of Pareto-optimal event count vectors, the set A È B can be computed in Oðm 4 Þ time. PROOF. Let C=A È B. Because both A and B have Oðm 2 Þ elements, so does C. Thus, trimming down set C to just the Paretooptimal vectors requires at most Oðm 4 Þ time. LEMMA 3.3. Given any two sets, A and B, of Pareto-optimal event count vectors, the set A B can be computed in Oðm 4 log mÞ time. PROOF. Consider Procedure Perform À ðA; BÞ. We first prove its correctness and then analyze its time complexity. Correctness: Consider the set Y=fv 1 +v 2 : v 1 2 A andv 2 2 Bg. The procedure constructs each element of C, one at a time, and adds it to the ordered set Z. The only elements ever deleted from set Z in Steps8 and12are those that arenotPareto-optimal.Finally,Step13 removes any remaining elements that are not Pateto-optimal from Z. The procedure thus computes the value of A B correctly.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>From this definition, it follows that for every combination of transfer and loss costs in a given region, every maximum parsimony solution using those costs will have the event count vector associated with that region. While there can be many distinct reconciliations in a given region, all event costs in that region will admit the same set of maximum parsimony reconciliations. THEOREM 3.3. Given a set of Pareto-optimal event count vectors, the corresponding regions can be found in time Oðm 4 log mÞ. PROOF. Let A denote the set of Pareto-optimal event count vectors. By Lemma 3.1, jAj 2 Oðm 2 Þ. The region R(v) corresponding to v 2 A comprises all points ðC ; C ' Þ 2 R + Â R + such that Cðv; C Â ; C ' Þ Cðv 0 ; C Â ; C ' Þ; 8v 0 2 A À v. Each inequality of the form Cðv; C Â ; C ' Þ Cðv 0 ; C Â ; C ' Þ induces a half-space and R(v)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><figDesc>Fig. 2. Pareto-regions for the (a) gopher-louse and (b) indigobird-finch datasets. Colors are arbitrary and are used to match regions with the event counts in the legend. The displayed event counts comprise the number of speciations in addition to the number of duplications, transfers and losses. In addition, the 'Count' field indicates the number of distinct reconciliations in each region. While most regions are polygons, regions may also be points or lines, such as in the first region in the legend in (a). (c) Results of a permutation test on the gopher-louse dataset using 1000 random trials. For (c) only, green indicates significance at the 0.01 level, yellow represents significance between 0.01 and 0.05 and red indicates lack of significance at the 0.05 level. Brightness of green, yellow and red indicates differences in P-values, with brighter shades indicating smaller P-values. All plots use transfer and loss costs ranging from 0.1 to 5. Plus sign marks the default event costs for Jane/TreeMap (C " =1; C Â =2; C L =1) and multiplication sign the default event costs for AnGST/RANGER-DTL (C " =1; C Â =3=2; C L =1=2). In (a), the two sets of default costs are in the same region, whereas in (b) and in almost all but the smallest datasets, the two sets of default costs are in different regions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig.3.</head><figDesc>Fig. 3. The costscape summary on the tree of life dataset. For each gene family, we computed (a) the number y of Pareto-optimal regions (all regions, black white circles; positive area regions, red plus sign; zero area regions, blue multiplication sign) and the number x of extant genes, and (b) the fraction y of the event cost space covered by the largest x regions</figDesc></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">R.Libeskind-Hadas et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="6"> CONCLUSIONS In this work, we have described new algorithms and tools for understanding the relationship between event costs and maximum parsimony reconciliations. In particular, we have given algorithms for computing the set of Pareto-optimal event count vectors and partitioning the event cost space into equivalence classes, or regions, induced by these vectors. We have demonstrated these algorithms in three software tools that (i) compute and visualize the regions that partition the event cost space, (ii) list the sets of events shared by reconciliations within and between regions and (iii) determine the statistical significance of reconciliation costs over the cost space. An alternative approach to computing Pareto-optimal event count vectors would be to uniformly sample event costs and, for each sample, use existing algorithms to compute the maximum parsimony reconciliation and corresponding event counts. However, it is not known how to determine the appropriate sampling density to capture all event count vectors. Additionally, sampling fails to find regions that comprise points and lines, which we have shown to comprise a large fraction of the total number of solutions. Finally, our approach allows us to determine all Pareto-optimal event count vectors, (a) ( b) Fig. 4. Event support for the tree of life dataset as measured by (a) fraction of regions or (b) fraction of event cost space covered. Coordinate (x, y) indicates that fraction y of events are found in at least fraction x of regions (or event cost space), with the plot being left-continuous (such that the highest y for each x should be read). Over all gene families, 16 795 speciations, 8375 duplications, 41 247 transfers and 13 761 losses are inferred</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors thank the anonymous referees for their invaluable comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Towards identifying lateral gene transfer events</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Addario-Berry</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pac. Symp. Biocomput</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="279" to="290" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Efficient algorithms for the reconciliation problem with gene duplication, horizontal transfer and loss</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Bansal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="283" to="291" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Reconciliation revisited: Handling multiple optima when reconciling with duplication, transfer, and loss</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Bansal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="738" to="754" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title level="m" type="main">Computational Geometry: Algorithms and Applications</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Berg</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<publisher>Springer-Verlag TELOS</publisher>
			<pubPlace>Santa Clara, CA</pubPlace>
		</imprint>
	</monogr>
	<note>3rd. edn</note>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Jungles: a new solution to the host-parasite phylogeny reconciliation problem</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Charleston</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Biosci</title>
		<imprint>
			<biblScope unit="volume">149</biblScope>
			<biblScope unit="page" from="191" to="223" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Simultaneous identification of duplications, losses, and lateral gene transfers</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<forename type="middle">Z</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="1515" to="1528" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Jane: a new tool for the cophylogeny reconstruction problem</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Conow</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithm Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">16</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Rapid evolutionary innovation during an archaean genetic expansion</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">A</forename>
				<surname>David</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">J</forename>
				<surname>Alm</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">469</biblScope>
			<biblScope unit="page" from="93" to="96" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">An efficient algorithm for gene/species trees parsimonious reconciliation with losses, duplications and transfers</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">P</forename>
				<surname>Doyon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>Tannier,E.</editor>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">6398</biblScope>
			<biblScope unit="page" from="93" to="108" />
			<date type="published" when="2010" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Ecological interactions are evolutionarily conserved across the entire tree of life</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Omez</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">M</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">465</biblScope>
			<biblScope unit="page" from="918" to="921" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Fitting the gene lineage into its species lineage. a parsimony strategy illustrated by cladograms constructed from globin sequences</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Goodman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Zool</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="132" to="163" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Phylogenetic trees support the coevolution of parasites and their hosts</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Hafner</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">A</forename>
				<surname>Nadler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">332</biblScope>
			<biblScope unit="page" from="258" to="259" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title level="m" type="main">Simultaneous identification of duplications and lateral transfers</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">T</forename>
				<surname>Hallett</surname>
			</persName>
		</author>
		<editor>Bourne,P.E. and Gusfield,D.</editor>
		<imprint>
			<date type="published" when="2004" />
			<publisher>ACM</publisher>
			<biblScope unit="page" from="347" to="356" />
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">A cophylogenetic perspective of RNA-virus evolution</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Jackson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Charleston</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="45" to="57" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Orthologs, paralogs, and evolutionary genomics</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">V</forename>
				<surname>Koonin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="309" to="338" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">On the computational complexity of the reticulate cophylogeny reconstruction problem</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Libeskind-Hadas</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Charleston</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="105" to="117" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<monogr>
		<title level="m" type="main">Evolutionary Biogeography: An Integrative Approach with Case Studies</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Morrone</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Columbia University Press</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">The cophylogeny reconstruction problem is NP-complete</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Ovadia</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="59" to="65" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Maps between trees and cladistic analysis of historical associations among genes, organisms, and areas</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">D M</forename>
				<surname>Page</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="58" to="77" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Molecular dating of phylogenetic trees: a brief review of current methods that estimate divergence times</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Rutschmann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Divers. Distrib</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="35" to="48" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Representing a set of reconciliations in a compact way</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Scornavacca</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Bioinform. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">1250025</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Clade-limited colonization in brood parasitic finches (vidua spp.)</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">D</forename>
				<surname>Sorenson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="140" to="153" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Inferring duplications, losses, transfers and incomplete lineage sorting with nonbinary species trees</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Stolzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="409" to="415" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Phylogenetic modeling of lateral gene transfer reconstructs the pattern and relative timing of speciations</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">J</forename>
				<surname>Szollosi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="17513" to="17518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<monogr>
		<title level="m" type="main">Using trees to capture reticulate evolution: lateral gene transfers and cancer progression</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Tofigh</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Simultaneous identification of duplications and lateral gene transfers</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Tofigh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="517" to="535" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<monogr>
		<title level="m" type="main">Pareto-optimal phylogenetic tree reconciliation</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>