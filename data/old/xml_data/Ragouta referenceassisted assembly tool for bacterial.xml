
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:58+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Ragout—a reference-assisted assembly tool for bacterial genomes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Mikhail</forename>
								<surname>Kolmogorov</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="institution">Bioinformatics Institute, St. Petersburg</orgName>
								<address>
									<country key="RU">Russia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Brian</forename>
								<surname>Raney</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="institution">UCSC</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<settlement>Santa Cruz</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Benedict</forename>
								<surname>Paten</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="institution">UCSC</orgName>
								<address>
									<addrLine>1156 High Street</addrLine>
									<settlement>Santa Cruz</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Son</forename>
								<surname>Pham</surname>
							</persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">UCSD</orgName>
								<address>
									<addrLine>9500 Gilman Drive, La Jolla</addrLine>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">St</forename>
							</persName>
						</author>
						<author>
							<affiliation key="aff0">
								<orgName type="institution">Petersburg University of the Russian Academy of Sciences</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Ragout—a reference-assisted assembly tool for bacterial genomes</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="page" from="302" to="309"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu280</idno>
					<note>BIOINFORMATICS Availability: The Ragout software is freely available at: https://github. com/fenderglass/Ragout. Contact: spham@salk.edu</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Bacterial genomes are simpler than mammalian ones, and yet assembling the former from the data currently generated by high-throughput short-read sequencing machines still results in hundreds of contigs. To improve assembly quality, recent studies have utilized longer Pacific Biosciences (PacBio) reads or jumping libraries to connect contigs into larger scaffolds or help assemblers resolve ambiguities in repetitive regions of the genome. However, their popularity in contemporary genomic research is still limited by high cost and error rates. In this work, we explore the possibility of improving assemblies by using complete genomes from closely related species/strains. We present Ragout, a genome rearrangement approach, to address this problem. In contrast with most reference-guided algorithms, where only one reference genome is used, Ragout uses multiple references along with the evolutionary relationship among these references in order to determine the correct order of the contigs. Additionally, Ragout uses the assembly graph and multi-scale synteny blocks to reduce assembly gaps caused by small contigs from the input assembly. In simulations as well as real datasets, we believe that for common bacterial species, where many complete genome sequences from related strains have been available, the current high-throughput short-read sequencing paradigm is sufficient to obtain a single high-quality scaffold for each chromosome.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The recent proliferation of next-generation sequencing with short reads has enabled many new experimental opportunities, but it has also raised formidable computational challenges in genome assembly. Even for relatively simple bacterial genomes, their assemblies from current generation of high-throughput short reads are still fragmented with hundreds of contigs. To improve the assembly's quality, recent studies have utilized longer Pacific Biosciences (PacBio) reads or jumping libraries to connect contigs into larger scaffolds or help assemblers resolve ambiguities in repetitive regions of the genome (<ref type="bibr" target="#b5">Deshpande, 2013;</ref><ref type="bibr" target="#b9">Koren, 2012</ref>). However, their popularity in current genomic research is still limited by high cost and error rates. When a related genome is available, an alternative approach is to use this genome to guide the assembly of the target genome, in a method called 'reference-assisted assembly'. The first reference-assisted assembly tools aligned contigs against the reference and ordered them according to their positions in the reference genome. While this approach is still commonly used, it introduces errors when structural variations between the reference and the assembled (target) genome are present. In an attempt to address this problem, Gaul and Blanchette (<ref type="bibr" target="#b7">Gaul and Blanchette, 2006</ref>) formulated the contig ordering problem, which attempts to order contigs so that the 2-break distance (DCJ distance) (<ref type="bibr" target="#b0">Alekseyev and Pevzner, 2009;</ref><ref type="bibr" target="#b4">Bergeron et al., 2006</ref>) between the resulting scaffold and the reference genome is minimized. This formulation has been further applied in some reference-guided assembly tools (<ref type="bibr" target="#b14">Richter et al., 2007;</ref><ref type="bibr" target="#b15">Rissman et al., 2009</ref>). Unfortunately, while the approach is theoretically sound, these tools still generate erroneous scaffolds when there are rearrangements between the target and reference genomes. This poses an important question: is a single reference genome sufficient to obtain a single scaffold (for each chromosome) without errors? Recently,<ref type="bibr" target="#b8">Kim et al. (2013)</ref>introduced RACA software, which made an important step toward reliable reconstruction of the target (assembled) genome. In contrast to other tools, which use only one reference, RACA utilizes a reference as well as multiple outgroups to guide the assembly. This approach proved to be valuable, since the adjacency information in the outgroups can also help infer the adjacencies in the target assembly. Although RACA marked an important advancement in the reference-guided assembly problem, it still suffers some limitations. First, RACA uses information from outgroup genomes, but it heavily relies on a single reference. As with any genome rearrangement tools, RACA decomposes these sequences into synteny blocks. However, rather than constructing synteny blocks by considering all input sequences, RACA constructs synteny blocks based on pairwise sequence alignment against only the reference genome. This approach, in some cases, cannot detect synteny blocks (<ref type="bibr" target="#b13">Pham and Pevzner, 2010</ref>) and also raises the question of what to do with assembly sequences (contigs) that do not align against the reference. Second, unlike synteny blocks constructed from complete genomes, synteny blocks constructed in the presence of contigs can be fragmented, since assemblies usually have contigs of various lengths. Constructing synteny blocks from fragmented assemblies raises a problem: on which scale should synteny blocks be constructed? If one constructs large-scale synteny blocks, then small and fragmented synteny blocks (within small contigs) are not considered, thus leading to gaps in the assembly. On the other hand, if one constructs small-scale synteny blocks, then the rearrangement *To whom correspondence should be addressed. ß The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com analysis becomes harder, since smaller synteny blocks are more likely to exhibit structural variations and are also more susceptible to be incorrectly identified (i.e. false synteny blocks). This dilemma must be addressed in order to obtain high-quality scaffolds. In this work, we present Ragout (Reference-Assisted Genome Ordering UTility), a genome rearrangement approach for reference-assisted assembly that can produce high-quality scaffolds with a small number of misordered contigs and high genome coverage. Rather than working with a single reference, Ragout uses multiple complete genomes from closely related species/ strains. In contrast with most existing tools, in which only a fixed scale of synteny blocks is used, our algorithm works iteratively with different scales of synteny blocks and also utilizes the assembly graph to improve scaffolds. We demonstrate that with multiple references, Ragout significantly improves the assembly of the target genome compared to existing tools. Through simulations as well as real datasets, we believe that for common bacterial species, for which many complete genome sequences from related strains have been made available, the current high-throughput short-read-sequencing paradigm is sufficient to assemble into a single high-quality scaffold. The Ragout software is freely available at: https://github. com/fenderglass/Ragout.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Algorithm overview</head><p>Ragout takes as input: an assembly (a set of contigs); a set of related genomes; and a phylogenetic tree of all the genomes (including the target assembly). It outputs high-quality scaffolds in the form of ordered lists of contigs. Ragout first decomposes the input sequences into synteny blocks using Sibelia software (<ref type="bibr" target="#b11">Minkin et al., 2013</ref>). After this stage, these sequences are represented in the alphabet of synteny blocks instead of as strings of nucleotides. While each reference sequence is transformed into a single sequence of synteny blocks (a list of signed numbers), the assembly corresponds to multiple sequences of synteny blocks because the target genome has been fragmented into multiple contigs. Due to this fragmentation, some adjacency information is missing. Ragout uses a genome-rearrangement approach to infer these missing adjacencies. Initially, we filter all repetitive blocks as well as blocks that are not present in the target assembly, since these kinds of synteny blocks are hurdles in most current genome-rearrangement algorithms. From the remaining blocks, we build an incomplete multi-color breakpoint graph, in which vertices correspond to the ends of synteny blocks and edges represent adjacencies between them. Ragout further solves the Half-breakpoint State Parsimony Problem to transform this graph to the 'normal' multi-color breakpoint graph (<ref type="bibr" target="#b0">Alekseyev and Pevzner, 2009</ref>) by recovering missing adjacencies in the target assembly. Next, contigs are assembled into scaffolds with respect to the inferred adjacencies. The above procedure is repeated multiple times with different synteny block scales, and the resulting scaffolds in these iterations are reconciled into a single set of scaffolds. Afterwards, a refinement step is performed. In this step, small and repetitive contigs are recovered and inserted back into the scaffolds by using the adjacency information from the assembly graph. The pseudocode of Ragout is described in Algorithm 1.Since the synteny block-reconstruction algorithm used in Ragout has been described in (<ref type="bibr" target="#b11">Minkin et al., 2013</ref>), we will not describe it in this article. Below, we delve into the details of Ragout algorithm, assuming that synteny blocks have already been constructed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">The phylogenetic tree Let</head><p>T be a rooted phylogenetic tree of the genomes A, P 1 ,. .. , P k. T consists of k + 1 leaves, (k – 1) internal nodes of degree three, and one node of degree two (called the root). Edges connecting two nodes are called branches. Branch length represents evolution time (evolution time is usually inferred from the number of nucleotide substitutions in sequence alignment). A parsimonious model for rearrangements. Given a tree T with all of its k + 1 leaves represented as complete genomes (in the alphabet of synteny blocks), the parsimony procedure (<ref type="bibr" target="#b6">Fitch, 1971;</ref><ref type="bibr" target="#b16">Sankoff, 1975</ref>) explains the descent of these various sequences from a common ancestor with the fewest number of changing operations, associated with a minimum cost value. When one of these genomes is divided into contigs, a possible formulation for recovering the target genome corresponds to finding a permutation of these contigs such that the parsimony procedure returns the lowest cost among all possible orderings of these contigs. Note that this is a double optimization. One step finds the most parsimonious explanation for a given configuration of the target genome, while the other step finds the configuration of the target genome having lowest cost. The usual (and more correct) choice for the allowed operation in the first optimization is the 2-break operation (also called a DCJ operation) since it can well approximate many real rearrangement operations (<ref type="bibr" target="#b0">Alekseyev and Pevzner, 2009</ref>). However, accounting for such an operation will lead to an NP-complete problem (<ref type="bibr" target="#b10">Ma et al., 2006</ref>). In this work, rather than using the 2-break operation, we study the parsimonious approach on individual breakpoints. While considering breakpoints individually may not adequately reflect the reality of rearrangements (since each rearrangement uses at least two breakpoints), this method is computationally feasible and has been proven to be valuable in the problem of ancestral genome reconstruction (<ref type="bibr" target="#b10">Ma et al., 2006</ref>). In the breakpoint graph BG(A, P i ,. .. , P k ), we call each vertex a halfbreakpoint (since a breakpoint involves two synteny block ends). For a given genome P i , the state of a half-breakpoint v i is defined as the halfbreakpoint adjacent to it, i.e. the vertex v j , such that the color of the edge (v i , v j ) is P i (color) in BG. Because of the first graph property described above, each half-breakpoint has at most one such state. If the synteny block corresponding to v i is missing in a genome, the state v i is void (see<ref type="figure">Fig. 1B</ref>). Rather than using the parsimony procedure with 2-break operations, we study the parsimony procedure with respect to the change of halfbreakpoint's states for each vertex in the breakpoint graph. The cost associated with a state change along a branch b of length in the phylogenetic tree is WðbÞ=e À : Intuitively, the longer a branch, the more likely a half-breakpoint state can change along it, and therefore the smaller the corresponding cost. Next, we formulate the Half-breakpoint State Parsimony Problem in order to infer the evolutionary scenario of a particular half-breakpoint.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">Half-breakpoint state parsimony Given a half-breakpoint u</head><p>and the phylogenetic tree T, each leaf of which is labeled by state(u) in each corresponding genome. Label the internal nodes of T in order to minimize the total cost needed to derive the leaves' states from their common ancestor. Below is a linear time algorithm for solving this problem. The solution for this problem mimics Sankoff's dynamic programming algorithm for the weighted small parsimony problem. The optimality proof is perfectly analogous to Sankoff's proof (<ref type="bibr" target="#b16">Sankoff, 1975</ref>). Input: stateðuÞ for each leaf node of tree.</p><p>Output: stateðuÞ for each internal node, along with the corresponding cost.</p><p>Objective function: s t (v) = minimum score of the subtree rooted at vertex v if v has state t. Initialization: for each leaf node l: s t (l) = 0 if the state of leaf node is t, otherwise s t (l) = 1. Recursion: The score at each vertex is based on the scores of its children:</p><formula>s t parent ð Þ =min i s i leftchild ð Þ + i;t W leftbranch ð Þ g È +min j s j rightchild ð Þ + j;t W rightbranch ð Þ g È</formula><p>where i;j =0 i fi=j and 1 otherwise: Termination: min a s a ðrootÞ:</p><p>Complexity: O(nÁd), where n is the number of leaves and d is the number of possible states.</p><p>When all the internal nodes of the tree have already been labeled, the cost of half-breakpoint state parsimony of the half-breakpoint u can be calculated by summing the cost in all the branches that the state changes. P u; T ð Þ= X branch i;j ð Þ i;j W branchlength ð Þ ð 1Þ</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4">Recovering missing adjacencies Since</head><p>the half-breakpoint state parsimony problem can be solved efficiently, the remaining question is to recover all missing adjacencies such that X u2G</p><p>Pðu; TÞ—the total cost of all half-breakpoints in G—is minimal. Since we filtered all duplicated synteny blocks as well as synteny blocks that do not appear in the target assembly, adjacencies in the target genome define a perfect matching in the graph. The cost of this matching is defined to be the sum of the half-breakpoint parsimony cost of all vertices (half-breakpoints). For each vertex that is not incident to a red edge in the breakpoint graph, the Ragout algorithm finds the cost for the half-breakpoint state parsimony problem on each of its possible states. These states are chosen from the vertex's adjacent vertices in the breakpoint graph. Since choosing a state for a particular half-breakpoint corresponds to choosing an edge incident to it, for each edge in the breakpoint graph, two such cost values are calculated. We assign the weight of each edge as the sum of these two values. As some adjacencies in the target genome are already known (vertices incident to a red edge), we can also remove those vertices from the graph before applying the Blossom algorithm to find the perfect matching with minimum cost (in O(jV j 4 ) time) and add corresponding edges into the final matching afterwards. This matching defines the optimal adjacencies in the target genome.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.5">Building scaffolds</head><p>Finally, we order contigs into scaffolds.</p><p>Starting from one contig, we try to extend it in both the forward and</p><formula>(a) ( b) Fig. 1.</formula><p>(a) A breakpoint graph of three reference genomes and one assembly. The three reference genomes (Ref1, Ref2 and Ref3) are presented as cyclic permutations of synteny blocks: Ref1(blue): + 1 +2 +3 +4 +5, Ref2(green): + 1 +3 +4 +5 and Ref3(orange): + 1 À 4 – 3 + 5, respectively. The target assembly (red) is presented as four separated permutations (corresponds to four contigs): Target Assembly: +1 j+2+ 3 j+4 j+5: (b) A phylogenetic tree representing the states of the halfbreakpoint 5 h. Each leaf is labeled by the state of the half-breakpoint 5 h in the corresponding reference/target genome. (According to this tree, the state of 5 h in the target genome is 4 t , although the correct state of 5 h in the target genome is unknown.) i304 backward directions, using the inferred adjacencies from the matching above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The choice of minimum synteny block size and iterative assembly</head><p>Since synteny block reconstruction is a parameter-dependent procedure, and the choice of parameters depends on the 'synteny block scale' required in each particular application, an important question to ask is: which scale of synteny blocks should one use for reference-assisted assembly? We argue that using a single scale of synteny blocks is not sufficient to obtain high-quality scaffolds. If one constructs large-scale synteny blocks, then small and fragmented synteny blocks (coming from small contigs and micro-rearrangements) are not considered, thus leading to gaps in the assembly. On the other hand, if one constructs small-scale synteny blocks, then rearrangement analysis becomes more difficult, since small-scale blocks are more likely to exhibit structural variations and are also more susceptible to be incorrectly identified (false synteny blocks). To resolve this dilemma, we use multiple synteny block scales in order to build multiple scaffolds and then reconcile these scaffolds. Consider two scaffolds A s and A w constructed from large-and smallscales of synteny blocks, respectively. A contig is called strong if it is in the scaffold A s and called weak if it is in A w and not in A s. Two scaffolds A s and A w are called consistent if every pair of adjacent contigs in A s is either adjacent or separated by only weak contigs in A w. Although the order of contigs in A s is more reliable than in A w , there are many small synteny blocks that do not reveal in A s and only appear in the 'finer' scaffold A w. We therefore rely on the 'skeleton of contigs' in A s and insert smaller contigs from A w if they are consistent (see<ref type="figure" target="#fig_0">Fig. 2</ref>). The merged scaffold is therefore consistent with A s. We successively apply the described procedure to scaffolds in different stages (sorted by the scale of synteny blocks) until we reach the stage with the smallest scale.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Refinement with the assembly graph</head><p>While the iterative procedure attempts to maximize the number of contigs used to build the scaffold, there are still some certain types of contigs that cannot be utilized in that stage. These contigs include: (i) contigs that are shorter than minimum synteny block size that existing synteny block tools can detect (several hundred nucleotides), (ii) contigs contained only in the target genome and (iii) repetitive contigs. Such fragments are not considered in the rearrangement analysis and will therefore not appear in the merged scaffolds. To add these fragments, we need to use the assembly graph, which has been output by short-read assemblers and can also be independently constructed from input contigs. The genome traverses the graph with a certain unknown path. However, since initial scaffolds are now available, we can use these scaffolds to restore small or repetitive fragments. This problem is analogous to the problem of repeat resolution in short-read assembly. Instead of paired-read information, we have pairs of adjacent contigs built during the rearrangement analysis stage. Given an assembly graph and a set of merged scaffolds from the previous step of the algorithm, for each pair of consecutive contigs from these scaffolds we find all possible paths connecting them in the assembly graph that do not contain contigs from the scaffold. If there exists only one such path, we insert all the intermediate contigs along this path between the two contigs (see<ref type="figure" target="#fig_1">Fig. 3</ref>). This procedure significantly improves the number of used contigs in most datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>We benchmarked Ragout against other reference-assisted assembly tools [Mauve Contig Mover (<ref type="bibr" target="#b15">Rissman et al., 2009</ref>), OSLay (<ref type="bibr" target="#b14">Richter et al., 2007</ref>), RACA (<ref type="bibr" target="#b8">Kim et al., 2013</ref>)] on one simulated and three real bacterial datasets. Since the complete sequences of target genomes are available, we can also assess the quality of the resulting scaffolds by the number of misordered contigs, scaffold gaps and coverage. As each output scaffold is an ordered list of contigs, we define the number of misordered contigs as the minimum number of contigs in the scaffolds whose mapping positions or directions are not consistent with the mapping positions and directions of the contigs before and after them. Also, we define the number of gaps in a scaffold as the number of contig pairs that are adjacent in a scaffold, but are separated by some other contigs when we map all contigs to the reference genome. The coverage is defined as the total number of aligned bases against the reference, divided by the genome size. Mauve Contig Mover and OSLay were run with parameters recommended for bacterial genomes. For Ragout, we ran three iterations with the corresponding minimum synteny block sizes: 5000, 500, 100, as they are the default scales used in Sibelia (<ref type="bibr" target="#b11">Minkin et al., 2013</ref>) for bacterial genomes. Since RACA works with only one synteny block size, we chose the maximal synteny block scale (most reliable).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Assembly using one closely related reference</head><p>First, we benchmark these tools on an easy case in which the target and reference genomes do not exhibit any structural variations. In this situation, one reference is sufficient to obtain the correct assembly. This also allows us to compare Ragout with MCM and OSLay, which can work only with one reference. The dataset consists of two different Escherichia coli strains: DH1 (NC_017625) as the reference and K-12 subs. MG1655 (NC_000913) as the target. The contigs were assembled with SPAdes assembler (<ref type="bibr" target="#b1">Bankevich et al., 2012</ref>). The results can be seen in<ref type="figure" target="#tab_1">Table 1</ref>. Ragout and MCM are able to recover one complete scaffold, while OSLay outputs eight scaffolds. The quality of Ragout's assembly without refinement is quite similar to MCM, but with refinement Ragout uses significantly more contigs and produces fewer gaps in the final scaffolds.</p><formula>(a) ( b)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Assembly of one chromosome using multiple references</head><p>Next, we want to address a more problematic case in which multiple references are available, but each of these references exhibits structural variations comparing to the target genome. The dataset contains five different Helicobacter Pylori strains: Puno120 (NC_017378), ELS37 (NC_017063), Gambia94/24 (NC_017371) and G27 (NC_011333) as references and SJM180 (NC_014560) as the target. The corresponding phylogenetic tree is shown on<ref type="figure" target="#fig_3">Figure 4A</ref>. The dot plots showing the rearrangements can be seen in<ref type="figure" target="#fig_2">Figure 5</ref>. Contigs were assembled using ABYSS (<ref type="bibr" target="#b17">Simpson et al., 2009</ref>). First, we run Ragout as well as OSLay and MCM on each of the available references separately to illustrate that the 'usual' assisted assembly with one reference is insufficient for the current case. Every tool produces a certain amount of misordered contigs, which can be explained by the structural divergence between the reference and the target (see<ref type="figure" target="#tab_2">Table 2</ref>). Since OSLay and MCM can only run with one reference, we use Ragout and RACA to benchmark different sets of multiple references (see<ref type="figure" target="#tab_3">Table 3</ref>). For RACA, G27 was chosen to be the reference and others were treated as outgroups. Both tools have misordered contigs when using three or fewer references. Ragout is able to infer the correct order of the contigs with the set of four references, while RACA still has some misordered contigs. Also, Ragout outputs the assembly with better coverage and fewer gaps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Multiple chromosome assembly using multiple references</head><p>The next dataset was taken from a recent study () in which long PacBio reads were used to obtain the complete de novo assembly of Vibrio Cholerae H1 str. (AKGH01000001). Here we want to show that with multiple related references (even though these references and the target genome have structural variations), complete scaffolds with high quality can also be obtained from only short-read data. We used SPAdes to assemble non-paired Illumina reads with read length 40 bp. Three references were chosen so that each of them would have rearrangements in at least one chromosome compared to the target genome: O1 Biovar (AE003852), O1 Inaba (CM001785) and O395 (CP001235). See<ref type="figure" target="#fig_4">Figure 6</ref>for the dotplots. The phylogenetic tree is shown on<ref type="figure" target="#fig_3">Figure 4</ref>(B). Using three references, Ragout was able to correctly reconstruct two scaffolds that correspond to two V.Cholerae chromosomes (see<ref type="figure" target="#tab_4">Table 4</ref>). Refinement with the assembly graph significantly increases the number of utilized contigs.All tools were run with their default parameters. For Ragout, results are given both with and without (in brackets) refinement. The total number of the contigs is 156. Initial assembly coverage is 98.18%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i306</head><p>For RACA, O1 Inaba was chosen to be the reference and others were treated as outgroups. RACA outputs three correct scaffolds with three references and six scaffolds with two references. Ragout outperforms RACA by the quality of the assembly, both with and without refinement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Assembly using structurally divergent references</head><p>Finally, we want to address the case when the references have a large number of structural variations. This case requires us to perform simulations because bacterial genomes usually have few rearrangements. The phylogenetic tree that was used for simulations is shown on<ref type="figure" target="#fig_3">Figure 4</ref>(D). For the sake of simplicity, the tree is chosen to be symmetrical and can be treated both as an unrooted tree or as a rooted one with the target branch of infinitesimal length. On each of the four outer branches (incident to references), five reversals and five translocations were simulated. Additionally, to make the dataset more complex, we have simulated 10 indels on each of the tree branches, including all inner ones. Genomes were then decomposed into synteny blocks, and then the target genome was split into contigs, where each contig represents exactly one synteny block. Our analysis includes three cases corresponding to when four, three or two of the simulated references are available. For each case, we have generated 100 different datasets. Since the phylogenetic tree is symmetric, the result does not depend on which particular reference is absent. We took E.coli K-12 str. MG1655 substr. (NC_000913) as a target and the number of synteny blocks in decomposition was 112 in average. Next, we run Ragout on every dataset. The results of simulations can be seen in<ref type="figure" target="#fig_5">Figure 7</ref>, which clearly shows that the number of misordered contigs increases when some of the references are missing from the analysis. The errors in the case whenAll tools were run with their default parameters. For Ragout, results are given both with and without (in brackets) refinement. The total number of contigs is 183. Initial assembly coverage is 98.57%.All tools were run with their default parameters. For Ragout, results are given both with and without (in brackets) refinement. The total number of contigs is 183. Initial assembly coverage is 98.57%.All tools were run with their default parameters. For Ragout, results are given both with and without (in brackets) refinement. The total number of contigs is 1407. Initial assembly coverage is 96.89%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i307</head><p>Reference-assisted assembly tool for bacterial genomes all references are available can be explained by breakpoint reuse, which makes it impossible for the algorithm to distinguish overlapping rearrangements. To compare Ragout and RACA, we chose two datasets with four references, since each run of RACA requires a large number of manual preparations. Results can be seen in<ref type="figure" target="#tab_5">Table 5</ref>. In both cases, Ragout produces better assemblies than RACA; one possible explanation for this phenomenon is that RACA heavily relies on one particular reference.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Parameter choice and iterative assembly</head><p>We would like to benchmark Ragout with different parameters of iterative/non-iterative assembly. The dataset consists of five strains of Staphylococcus Aureus as references: COL (NC_002951), JKD6008 (NC_017341), N315 (NC_002745), RF112 (NC_007622) and USA300 (NC_007793) as the target. The phylogenetic tree is shown in<ref type="figure" target="#fig_3">Figure 4</ref>(C). Contigs were assembled from single-cell sequencing data using SPAdes. The results of benchmarking can be seen in<ref type="figure" target="#tab_6">Table 6</ref>. As expected, the smaller size of a synteny block allows the algorithm to arrange more contigs, but analysis becomes more complicated. As a result, the algorithm produces some incorrect adjacencies which leads to misordered contigs and more fragmented assembly (in number of scaffolds). Next, iterative assembly was performed in three stages (5000, 500, 100). This assembly kept the complete scaffold from the first stage, while adding some smaller contigs from the second and third stages. Even though some misordered contigs could be carried to the merged scaffolds, these errors are local and do not violate the correct 'skeleton' of scaffolds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>In this article, we have presented Ragout, a package for improving assemblies using multiple complete references. We demonstrated that with multiple related genomes available, one can obtain a complete and high-quality scaffold for each chromosome using only high-throughput short-read sequencing. This marks an important improvement in genome assembly of short reads and even raises a question whether long PacBio reads or long jumping libraries are needed for genomic studies of common bacteria where multiple related references have been available. The current version of Ragout uses Sibelia for synteny block reconstruction and therefore limits itself to bacterial genomes. When synteny blocks have been available, Ragout is fast and memory-efficient. We plan to make Ragout compatible with other synteny block generation tools that can work with mammalian genomes [e.g. Cactus aligner<ref type="bibr" target="#b12">Paten et al. (2011)</ref>] and further extend Ragout to work with mammalian datasets. Another limitation of Ragout is that it only uses the assembly graph for recovering repetitive blocks or small contigs that could not be captured in synteny analysis. Therefore, it can make mistakes when rearrangements happened on the target branch. Since de Bruijn graphs can be transformed into breakpoint graphs and vice-versa, the de Bruijn graphs output from short-read assemblers can also be used for rearrangement analysis and we will focus on this issue in further studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We would like to thank Jaebum Kim for assisting us with the benchmark of RACA software. We are indebted to Phillip Compeau, Apua Paquola, Nitin Udpa, Shay Zakov, Nikolay Vyahhi and Han Do for revising the manuscript and for many helpful suggestions that significantly improve the paper.Ragout and RACA were run with synteny block size equal to 500 (the size is known from the simulations) without refinement. The total number of contigs is 114 in both cases. Initial assembly coverage is 100%.Ragout was run with four S.Aureus references with different minimum synteny block sizes. Iterative assembly was performed with all previous sizes combined (5000, 500, 100). The total number of contigs is 767. Initial assembly coverage is 98.4%. We did not perform refinement with the assembly graph in order to focus on the effect of synteny block size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i308</head><p>Funding: NIH (grant number 1U41HG007234-01) and VP Foundation (grant number BI-2013-02), in part. Conflict of Interest: none declared.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.2.</head><figDesc>Fig. 2. Merging two scaffolds A s and A w built from two different synteny scales into a scaffold M. Yellow rectangles represent weak contigs. (a) A s and A w are consistent. (b) A s and A w are not consistent</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.3.</head><figDesc>Fig. 3. Refinement with the assembly graph. The procedure fills scaffold gaps with small contigs. The big circles illustrate contigs with known order, while small ones correspond to contigs that were not considered in rearrangement analysis</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.5.</head><figDesc>Fig. 5. (aÀd) Dot plots of H.Pylori references versus target genomes. (e) Dot plot of Ragout's scaffold versus the target genome showing a perfect diagonal line for visual verification</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.4.</head><figDesc>Fig. 4. Phylogenetic trees. (a) Heclicobacter Pylori with SJM180 as target. (b) Vibrio Cholerae with H1 as target. (c) Staphylococcus Aureus with USA300 as target. (d) Simulated genomes. Solid branches contain all types of rearrangements, while dashed branches contain only indels</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.6.</head><figDesc>Fig. 6. Dot plots of different chromosomes of V.Cholerae references (a–c) versus the corresponding chromosomes of the target genome showing rearrangements</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.7.</head><figDesc>Fig. 7. Correspondence of the number of available references with the number of misordered contigs for Ragout</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. Comparison of different tools using one reference</figDesc><table>Ragout 
MCM 
OSLay 

Scaffolds 
1 (1) 
1 
8 
Coverage 
97.9 (97.6) 
97.6 
96.7 
Ordered contigs 
129 (79) 
77 
80 
Gaps 
52 (71) 
73 
61 
Misordered 
0 (0) 
0 
1 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 2. Comparison with MCM and OSLay using one H. Pylori reference showing misordered contigs</figDesc><table>Reference 
Scaffolds 
Ordered 
Misordered 
Coverage 

Mauve contig mover 
G27 
1 
53 
7 
97.9 
Gambia94/24 
1 
54 
8 
97.9 
ELS37 
1 
45 
9 
98.0 
Puno120 
1 
56 
11 
98.0 
OSLay 
G27 
5 
50 
1 
96.2 
Gambia94/24 
8 
49 
3 
96.4 
ELS37 
6 
53 
3 
98.0 
Puno120 
8 
51 
2 
87.0 
Ragout 
G27 
1 (1) 
91 (50) 
4 (4) 
97.7 (97.4) 
Gambia94/24 
2 (2) 
83 (45) 
7 (7) 
96.8 (96.6) 
ELS37 
1 (1) 
102 (56) 
4 (3) 
98.1 (97.5) 
Puno120 
2 (2) 
92 (49) 
6 (6) 
97.2 (96.9) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><figDesc>Table 3. Comparison of Ragout and RACA on H.pylori using multiple references</figDesc><table>References 
Scaffolds Coverage Ordered Gaps 
Misordered 

Ragout 
G27, ELS37 
2 (2) 
97.8 (97.6) 95 (53) 22 (39) 1 (1) 
G27, Puno120, ELS37 1 (1) 
97.8 (97.6) 95 (53) 21 (36) 1 (1) 
G27, Puno120, 
Gambia94/24, ELS37 

1 (1) 
97.6 (97.3) 93 (46) 22 (38) 0 (0) 

RACA 
G27, ELS37 
3 
83.6 
35 
29 
2 
G27, Puno120, ELS37 2 
83.6 
35 
30 
1 
G27, Puno120, 
Gambia94/24, ELS37 

2 
8 3 . 8 
3 5 
3 1 
1 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Table 4.</figDesc><table>Comparison of Ragout and RACA on V.cholerae using multiple 
references 

References 
Scaffolds Coverage Ordered Gaps 
Misordered 

Ragout 
O1 Inaba 
3 (3) 
95.3 (94.8) 317 (185) 41 (64) 5 (3) 
O1 Inaba, O1 biovar 2 (2) 
95.5 (94.7) 305 (179) 46 (68) 6 (4) 
O1 Inaba, O1 
biovar, O395 

2 (2) 
95.5 (94.7) 300 (174) 46 (66) 2 (0) 

RACA 
O1 Inaba, O1 biovar 6 
85.8 
124 
51 
0 
O1 Inaba, O1 
biovar, O395 

3 
90.0 
127 
56 
0 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 5. Comparison of Ragout and RACA on simulated datasets</figDesc><table>Dataset 1 
Dataset 2 

Ragout 
RACA 
Ragout 
RACA 

Scaffolds 
1 
6 
1 
8 
Coverage 
95.3 
83.5 
94.5 
75.4 
Ordered 
112 
101 
112 
90 
Gaps 
3 
6 
11 
5 
Misordered 
0 
3 
4 
2 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Table 6.</figDesc><table>Iterative assembly of S.Aureus 

SB size 
100 
500 
5000 
Iterative 

Scaffolds 
5 
2 
1 
1 
Coverage 
96.7 
96.3 
92.0 
96.7 
Ordered 
108 
91 
62 
89 
Gaps 
75 
75 
56 
73 
Misordered 
1 
0 
0 
1 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="2">.2 A genome-rearrangement approach for recovering missing adjacencies Given reference sequences and assembly in the alphabet of synteny blocks, our task is to recover the missing adjacencies of synteny blocks in the target assembly. While breakpoint graphs best capture adjacency information, they have thus far only been defined for complete genomes. Below, we introduce incomplete multi-color breakpoint graphs for presenting synteny block adjacencies in the assembly and reference sequences. 2.2.1 Incomplete multi-color breakpoint graphs Given an assembly A and k reference sequences P 1 ,. .. , P k in the alphabet of synteny blocks B, we define the incomplete multi-color breakpoint graph BG(A, P 1 ,. .. , P k ) = (V, E), where V=fb h i ; b t i jb i 2 Bg: For each synteny block, there are two vertices in the graph which correspond to the tail and head of the block. Edges are undirected and colored by k + 1 colors. An edge connects vertices that correspond to heads/tails of adjacent synteny blocks and is colored by the corresponding color of the genome/assembly. To simplify the notation, we use red, P 1 ,. .. , P k to refer to the colors of edges, where red edges represent the adjacencies of synteny blocks in the target assembly A, and P i represents the adjacencies of synteny blocks in genome P i (see Fig. 1A). Before constructing the graph, we filter synteny blocks from reference genomes that are not present in the target assembly, since these synteny blocks do not help to infer the adjacencies in the target genome. Also, we filter synteny blocks that have multiple copies within any sequences, since duplicated synteny blocks make further analysis in the breakpoint graph complicated. After this filtering, the constructed graph has two important properties: (i) each vertex has at most one edge of each color (since all repetitive synteny blocks are removed), and (ii) each vertex corresponds to a certain synteny block in the target genome. Therefore, if the target genome were available, the set of all red edges would define a perfect matching in the graph. However, since the genome is fragmented into contigs, the adjacency information of the target genome at the vertices that correspond to the end of contigs is missing. The main task is to infer these missing red edges in the graph using other adjacencies from the reference genomes as well as using their evolutionary relationship in the form of a phylogenetic tree. i303 Reference-assisted assembly tool for bacterial genomes at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">M.Kolmogorov et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Breakpoint graphs and ancestral genome reconstructions</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">A</forename>
				<surname>Alekseyev</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="943" to="957" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Spades: a new genome assembly algorithm and its applications to single-cell sequencing</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bankevich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="455" to="477" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">A hybrid approach for the automated finishing of bacterial genomes</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bashir</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="701" to="707" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">A hybrid approach for the automated finishing of bacterial genomes</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Bashir</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="701" to="709" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">A unifying view of genome rearrangements</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bergeron</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Algorithms in Bioinformatics</title>
		<meeting>Algorithms in Bioinformatics</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="163" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Cerulean: A hybrid assembly using high throughput short and long reads</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Deshpande</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Algorithms in Bioinformatics</title>
		<meeting>Algorithms in Bioinformatics</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="349" to="363" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Toward defining the course of evolution: minimum change for a specific tree topology</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">M</forename>
				<surname>Fitch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="406" to="416" />
			<date type="published" when="1971" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Ordering partially assembled genomes using gene arrangements</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Gaul</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Blanchette</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Comparative Genomics</title>
		<meeting>the Comparative Genomics</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="113" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Reference-assisted chromosome assembly</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Kim</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1785" to="1790" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Hybrid error correction and de novo assembly of singlemolecule sequencing reads</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Koren</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="693" to="700" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Reconstructing contiguous regions of an ancestral genome</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1557" to="1565" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Sibelia: A scalable and comprehensive synteny block generation tool for closely related microbial genomes</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Minkin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Algorithms in Bioinformatics</title>
		<meeting>Algorithms in Bioinformatics</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="215" to="229" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Cactus: Algorithms for genome multiple sequence alignment</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Paten</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1512" to="1528" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Drimm-synteny: decomposing genomes into evolutionary conserved segments</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">K</forename>
				<surname>Pham</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="2509" to="2516" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Oslay: optimal syntenic layout of unfinished assemblies</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">C</forename>
				<surname>Richter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="1573" to="1579" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Reordering contigs of draft genomes using the mauve aligner</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">I</forename>
				<surname>Rissman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2071" to="2073" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Minimal mutation trees of sequences</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Sankoff</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="35" to="42" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<monogr>
		<title level="m" type="main">Abyss: A parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<monogr>
		<title level="m" type="main">Reference-assisted assembly tool for bacterial genomes</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>