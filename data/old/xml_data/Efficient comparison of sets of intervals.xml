
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:51+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Data and text mining Efficient comparison of sets of intervals with NC-lists</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2013">7 2013</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Matthias</forename>
								<surname>Zytnicki</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Plant Biology and Breeding Division</orgName>
								<orgName type="institution" key="instit1">URGI</orgName>
								<orgName type="institution" key="instit2">INRA Versailles</orgName>
								<address>
									<postCode>78026</postCode>
									<settlement>Versailles Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yufei</forename>
								<surname>Luo</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Plant Biology and Breeding Division</orgName>
								<orgName type="institution" key="instit1">URGI</orgName>
								<orgName type="institution" key="instit2">INRA Versailles</orgName>
								<address>
									<postCode>78026</postCode>
									<settlement>Versailles Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Hadi</forename>
								<surname>Quesneville</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Plant Biology and Breeding Division</orgName>
								<orgName type="institution" key="instit1">URGI</orgName>
								<orgName type="institution" key="instit2">INRA Versailles</orgName>
								<address>
									<postCode>78026</postCode>
									<settlement>Versailles Cedex</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Data and text mining Efficient comparison of sets of intervals with NC-lists</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">29</biblScope>
							<biblScope unit="page" from="933" to="939"/>
							<date type="published" when="2013">7 2013</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btt070</idno>
					<note type="submission">Received on March 27, 2012; revised on December 20, 2012; accepted on February 7, 2013</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Associate Editor: Michael Brudno Contact: matthias.zytnicki@versailles.inra.fr Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: High-throughput sequencing produces in a small amount of time a large amount of data, which are usually difficult to analyze. Mapping the reads to the transcripts they originate from, to quantify the expression of the genes, is a simple, yet time demanding, example of analysis. Fast genomic comparison algorithms are thus crucial for the analysis of the ever-expanding number of reads sequenced. Results: We used NC-lists to implement an algorithm that compares a set of query intervals with a set of reference intervals in two steps. The first step, a pre-processing done once for all, requires time O½#R logð#RÞ þ #Q logð#QÞ, where Q and R are the sets of query and reference intervals. The search phase requires constant space, and time Oð#R þ #Q þ #MÞ, where M is the set of overlaps. We showed that our algorithm compares favorably with five other algorithms, especially when several comparisons are performed. Availability: The algorithm has been included to S–MART, a versatile tool box for RNA-Seq analysis, freely available at http://urgi.versailles. inra.fr/Tools/S-Mart. The algorithm can be used for many kinds of data (sequencing reads, annotations, etc.) in many formats (GFF3, BED, SAM, etc.), on any operating system. It is thus readily useable for the analysis of next-generation sequencing data.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>With the advent of high-throughput sequencing, bioinformatics must analyze a large amount of data every day. Modern sequencers can generate several hundred millions of sequences in a week for a price that is affordable to more and more labs. When a reference genome is available, the first task is to map the reads on the genome. Many mapping tools are now available and research is active on this topic<ref type="bibr">[see Langmead et al. (2009) for instance]</ref>. For RNA-Seq, the second step may be the assignment of the mapped read to the transcripts they originate from, to estimate the expression of the genes (<ref type="bibr" target="#b1">Anders, 2011</ref>). In general, the genomic comparison of the mapped reads with a reference annotation is the basis of many analyses: comparison of putative transcription factor binding sites with up-regulated genes (<ref type="bibr" target="#b1">Blankenberg et al., 2010;</ref><ref type="bibr" target="#b2">Giardine et al., 2005;</ref><ref type="bibr" target="#b3">Goecks et al., 2010</ref>); detection of the single-nucleotide polymorphisms that are located in coding regions (<ref type="bibr" target="#b8">Renaud et al., 2011</ref>); processing de novo transcript sequences to determine if they represent known or novel genes (<ref type="bibr" target="#b10">Roberts et al., 2011</ref>). These three examples involve a comparison of two annotations, and the problem has been addressed often. However, high-throughput sequencing, for the amount a data it produces, requires optimized algorithms for its analysis. Most tools model the reads or annotation as intervals, or lists of intervals when different elements are modeled (exons, UTRs, etc.). These intervals are considered along a reference, which usually is a chromosome or a scaffold. Thus, comparing RNASeq reads with known transcripts reduces to comparing a set of query intervals (the reads) with a set of reference intervals (the exons of the transcripts). Every efficient algorithm requires a dedicated data structure, such as an indexed database, an indexed flat file [such as a BAM file (<ref type="bibr" target="#b7">Li et al., 2009)]</ref>, an R-tree or NC-lists (nested containment lists) (<ref type="bibr" target="#b0">Alekseyenko and Lee, 2007</ref>). These structures are usually built once during the pre-processing step, and can be reused for other analyses. Although these structures may take considerable amount of time to build, the balance is usually favorable to pre-processed structures when several comparisons are performed, as the time spent for the comparison itself is considerably reduced. This observation leads to the conception of the BAM format, now widely used in the bioinformatics community. With the notable exception of the fjoin algorithm (<ref type="bibr" target="#b9">Richardson, 2006</ref>), almost all the algorithms previously described only get all the reference intervals that overlap with one given query interval: most algorithms have been designed to retrieve all the intervals a user can see when he selects a given window in a genome browser (<ref type="bibr" target="#b5">Kent et al., 2002</ref>). Whereas these algorithms can be used to compare two sets by comparing each query interval, one after the other, with the reference intervals, we will show here how comparing the whole query set with the reference set can be more efficient. Among the possible data structures presented to compare intervals, NC-lists (<ref type="bibr" target="#b0">Alekseyenko and Lee, 2007</ref>) are one of the most promising. NC-lists have been first described to retrieve all the reference intervals that overlap with a single interval. Their structure is compact (a simple set of two arrays, L and H), the algorithm is fast in practice and the search phase requires only constant space, which is compulsory when handling several hundreds of millions of reads. The key idea of NC-lists is to perform binary dichotomic search on the list of reference intervals. But dichotomic search cannot be performed when some intervals are contained (or nested) inside other intervals, so NC-lists arrange intervals into lists—the L array—where no two intervals are nested. If some intervals are nested inside an ancestor interval, *To whom correspondence should be addressed. ß The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com they are stored in a separate sublist using the H array (see<ref type="figure">Fig. 1</ref>). NC-lists can be built in linearithmic time [i.e. of the form Oðn log nÞ], using linear space (actually, only five integers are stored per interval). In their article, the authors presented a recursive dichotomic algorithm, equivalent to Alg. 1, which uses NC-lists. It is claimed that getting all the reference intervals that overlap with a query interval could be done in time O½logð#RÞ þ #M, where R is the reference set and M the pairs query/reference that overlap, but this is not accurate for some cases (see section 3.1). In this article, we will present an algorithm, which relies on NC-lists, and provides all the pairs query intervals/reference intervals that overlap. In a pre-processing step, the algorithm sorts the query and the reference intervals. It then builds a NC-list for the reference intervals. In the search phase, the algorithm compares every query interval with the reference intervals in time Oð#R þ #Q þ #MÞ. All together, the algorithm takes O½#R logð#RÞ þ #Q logð#QÞ þ #M. Although the complexity of the whole algorithm is not better than already known algorithms, the runtime complexity is significantly lower than other constant-space algorithms. As such, our algorithm is especially useful when performing multiple comparisons on large sets of data, such as in an RNA-Seq data analysis.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Original algorithm</head><p>Algorithms 2 Simplified algorithm</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>To compare two sets of intervals, we also used a NC-list for the reference set, and query intervals are simply sorted by their start position. Our aim is to find all the query intervals that overlap with at least one reference interval. The main idea of the algorithm is that knowledge from the comparison between a query interval and a reference interval will be used for the comparison of the next query interval. A sketch of the algorithm, which provides all the pairs of query/reference intervals that overlap, is presented in Alg. 2. The actual algorithm is slightly more complex, and is described in section 3.2. It uses a special variable, nfo (for next first overlap), which stores the first reference query that may overlap with the next query interval.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ALGORITHMS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Original algorithm</head><p>Definitions. We will describe and analyze here the problem of the comparison of genomic intervals. We will first formally define our data and the NC-list structure. DEFINITION 1. An interval i ¼ ða, bÞ is an element of N 2 such that a b. By convention, we set i:start ¼ a and i:end ¼ b. For two intervals i and j, we define: i5j , ði:end5j:startÞ ð i is before jÞ i54j , ðði:start j:endÞ ^ ðj:start i:endÞÞ ði and j overlapÞ i &amp; j , ððj:start i:startÞ ^ ði:end j:endÞÞ ði is contained in jÞr:start r 0 :start _ ðr:start ¼ r 0 :startÞ ^ ðr:end ! r 0 :endÞ 8 &lt; :</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The associated asymmetric relation is defined by</head><p>8ðr, r 0 Þ 2 R 2 , ðr 0 r 0 Þ , :ðr 0 " rÞ If two different intervals, r and r 0 , have the same coordinates [ðr:start ¼ r 0 :startÞ ^ ðr:end ¼ r 0 :endÞ], we define r 0 r 0 or r 0 0 r arbitrarily. To avoid ambiguity, the 0 relation is subscripted by the set it relates to (namely 0 Q for the query set and 0 R for the reference set). The successor of an element r 2 R with respect to the order 0 R will be noted succðrÞ, when it exists.</p><p>The construction phase of the NC-list groups the sorted intervals into lists, such that an interval that is contained in another interval is moved into the sublist of the container interval.8ðc, pÞ 2 R 2 , ðc:parent ¼ pÞ , ðp 2 r:childrenÞ Finally, r:ancestors is the list of ancestors of r 2 R, i.e. the list ðr 1 , r 2 , r 3 ,. .. , r n Þ such that r 1 has no parent, r k ¼ r kþ1 .parent and r n ¼ r:parent.</p><p>The previous definition provides a way to build the nested containment structure from a sorted list of intervals: given an interval r, all its successors that are nested into r should be found in a list under r. They are the subelements of r. The children of r are the subelements that are right under r (i.e. there is no other interval nested in r that contains a child of r). Note that an interval r may have no parent. In this case, we set r:parent ¼ ; and all the intervals that have no parent form the top list. DEFINITION 4. The NC-list of a set of intervals is a tree-like data structure such that each node contains sorted intervals, the root node is the list of intervals that has no parent, there is an edge between every interval and the list of its children.</p><p>Notice that a NC-list is not a tree because an edge connects a node (the parent interval) to a list of nodes (the children intervals). Revised complexity. The original algorithm, equivalent to Alg. 1, considers a query interval q and a set of reference intervals R. It gives the elements of R that overlap with q. We will show here that the algorithm presented by Alekseyenko and Lee (2007) does not have the complexity claimed in the article. In the example in<ref type="figure" target="#fig_2">Figure 2</ref>, the announced complexity does not hold. The example has a nested structure, where each reference interval has the same number of siblings. For each list of siblings, none but the last one has children. The query overlaps every last sibling of each list. The number of layers is equal to the number of siblings, n. Here, #M ¼ n and #R ¼ n 2. Executing the algorithm yields a time complexity of O½n logðnÞ, as n binary searches are performed (one for each layer). However, the expected complexity is O½logðn 2 Þ þ n ¼ OðnÞ5O½n logðnÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">New algorithm</head><p>DEFINITION 5. The problem of the comparison of sets of intervals considers two sets of intervals, Q and R (hereafter named the query set and the reference set) and finds all the pairs ðq, rÞ 2 Q Â R such that q and r overlap.</p><p>Notice that there is no assumption on the two sets: elements from the query or reference sets may be nested or not, have different sizes, etc. DEFINITION 6. Consider a query read q. Let B½q ¼ fr 2 R : r5qg be the set of reference intervals that are before q. M½q ¼ fr 2 R : r54qg be the set of reference intervals that overlap with q. A½q ¼ fr 2 R : r4qg be the set of reference intervals that are after q.</p><p>Because B<ref type="bibr">[q]</ref>, M<ref type="bibr">[q]</ref>and A<ref type="bibr">[q]</ref>are disjoint, and cover the entirety of R, fB½q, M½q, A½qg is a partition of R. Moreover, any optimized algorithm would of course try to compute M<ref type="bibr">[q]</ref>as fast as possible, while avoiding scanning B<ref type="bibr">[q]</ref>and A<ref type="bibr">[q]</ref>. The two following lemma (their proof are omitted for they are straightforward) will help us skipping reading these sets. LEMMA 1. If an interval is in B<ref type="bibr">[q]</ref>, then all its subelements also are. A consequence, if a reference element is in B<ref type="bibr">[q]</ref>, then its children intervals will not be compared with q.The previous lemma implies that if we scan the reference interval using the ordering 0 R , the search can stop when the leastelement of A<ref type="bibr">[q]</ref>is found. In other words, the greatest element of M<ref type="bibr">[q]</ref>, when this set is not empty, is the predecessor of the least element of A<ref type="bibr">[q]</ref>. There is no similar rule concerning the least element of M<ref type="bibr">[q]</ref>and B<ref type="bibr">[q]</ref>, and characterizing the 'left frontier' of M<ref type="bibr">[q]</ref>is slightly more complex.</p><p>To do so, we will define here nfo. Informally, this variable is the least (using the ordering 0 R ) lowest (meaning that none of its children does) interval that overlaps with q. Because nfo overlaps with q, all its ancestors also do. Because it is the least variable that overlaps with q, the successors of nfo either overlap with q or are after q. In the algorithm, this variable is set when we compare a query interval q with the set of reference intervals, and it is the first interval that will be compared with the successor of q. We will prove the previous claims here.LEMMA 3. Let m½q ¼ min 0R fM½q [ A½qg. If m<ref type="bibr">[q]</ref>is undefined, we set m½q ¼ None. If m<ref type="bibr">[q]</ref>is None, the nfo<ref type="bibr">[q]</ref>also is. Otherwise, m½q 2 fnfo½qg [ nfo½q:ancestors PROOF. Let us suppose that m<ref type="bibr">[q]</ref>is not None (the proof is clear otherwise). If m½q 2 A½q, then m½q ¼ nfo½q and the lemma is proved. Otherwise, let r be a reference element such that ðm½q 2 r:ancestorsÞ ^ ðr:children ¼ ;Þ. Such an element exists, otherwise the number of sublists would be infinite. Clearly, r 2 fðr 0 2 M½q : r 0 :children &amp; B½qÞg, so nfo½q" R r. We have thus m½q" R nfo½q" R r and r 2 m½q:sub, which implies, by definition of the subelements, that nfo½q 2 m½q:sub, or nfo½q ¼ m½q. This proves the lemma.</p><formula>COROLLARY 4.</formula><formula>8r 2 R, ðr 0 R nfo½qÞ ) ðr 2 B½q [ nfo½q:ancestorsÞ</formula><p>As a result, suppose that we have found nfo<ref type="bibr">[q]</ref>and that we are looking for nfo½q 0 , with q 0 ¼ succðqÞ. Because B½q &amp; B½q 0 , the previous corollary implies that nfo½q 0  is either a parent of nfo<ref type="bibr">[q]</ref>or one of its successors. LEMMA 5. 8m 2M½q, 8r 2 R, ððm 0 R rÞ ^ ðm 6 2 r:ancestorsÞÞ ) ðr 2 M½q [ A½qÞ PROOF. Let r be a reference interval such that m 0 R r ^ m 6 2 r:ancestors. The following assertions hold:</p><p>(1) m:start q:end ^ q:start"m:end (q and m overlap),</p><p>(2) m:start r:start</p><formula>(m 0 R r),</formula><p>(3) m:start4r:start ^ m:end5r:end (m 6 2 r:ancestors).</p><p>From 2 and 3, we deduce that m:end5r:end. Comparing with 1, we deduce that q:start5r:end, and so r 2 M½q [ A½q. This proves the lemma.This last proposition implies that in general, all the elements greater than nfo<ref type="bibr">[q]</ref>could overlap with the successor of q. The only exception is when nfo<ref type="bibr">[q]</ref>overlaps with q. In this case, children intervals must be skipped. This is why we use a variable skip, which stores this configuration. Algorithm. From the previous propositions, we can directly infer an algorithm, which is completely presented in supplementary materials. A loop iterating over the query elements is described in findOverlap. The algorithm that compares a query interval with the reference intervals is described in findOverlapIter. A last algorithm, getNext, shows how to get the successor of a reference interval (considering the ordering 0 R ). Informally, the main algorithm directly jumps to the nfo reference element that had been computed by the previous query interval. It then checks the ancestors. Then, it scans forward. If the current reference is in B<ref type="bibr">[q]</ref>, it jumps to the next interval. If the current reference is in M<ref type="bibr">[q]</ref>, it goes down to the sublists, except if the variable skip is true. In such case, it directly jumps to the next interval. If the current reference is in A<ref type="bibr">[q]</ref>, it stops. The variable nfo is updated when necessary.In every case, the query interval (q) is in black, and the other colors refer to the reference intervals. nfo<ref type="bibr">[q]</ref>is indicated by the arrow. To help the reader, reference intervals in B<ref type="bibr">[q]</ref>are white; the intervals in M<ref type="bibr">[q]</ref>are light gray; dark gray intervals are in A<ref type="bibr">[q]</ref>. Case (A) is the simple case, the other cases are less intuitive. In case (B), we can observe that the first overlapping interval is not nfo<ref type="bibr">[q]</ref>: it is the bottom-most overlapping element. In case (C), all the children of nfo<ref type="bibr">[q]</ref>are in B<ref type="bibr">[q]</ref>. In case (D), nfo<ref type="bibr">[q]</ref>is in A<ref type="bibr">[q]</ref>m½q ¼ min 0R fM½q [ A½qg is either a parent of nfo½q 0  or one of its successors. Besides, we have previously proved that m½q 2 fnfo½qg[ nfo½q:ancestors. Thus, starting from the previous nfo, checking its ancestors, then possibly going right until m<ref type="bibr">[q]</ref>is found, and then finally going down is enough to find nfo<ref type="bibr">[q]</ref>. This is what the algorithm does. PROPOSITION 8. The time complexity of the algorithm is Oð#Q þ #R þ #MÞ. PROOF. Let us consider the reference intervals that will be compared with q. Let q 0 be its predecessor. The reference intervals that are scanned are B½qnB½q 0 , M<ref type="bibr">[q]</ref>, and the least element of A<ref type="bibr">[q]</ref>. Because the sets fB½qnB½q 0  : ðq, q 0 Þ 2 Q 2 , succðq 0 Þ ¼ qg are all disjoint, the total number of comparisons is Oð#Q þ #R þ #MÞ.</p><p>Notice that the algorithm findOverlap sometimes needs to go from the child to the parent, and thus be able to visit the tree from bottom to top, whereas the original algorithm described in Alg. 1 is a typical top-down algorithm. To be able to go up, we added in the L table a new cell, which contains the address of the parent element in the L table.</p><p>Transcript modelization. Transcripts usually are not simple interval, but a succession of several intervals, which are the exons. Similarly, the reads can also be splitted in several parts if they overlap the exon/exon junction. In our implementation, we modeled the query and the reference element as a single interval (the smallest interval that contains all the exons), and store these intervals into the NC-list. To avoid reporting the reads that are the introns, we also store, for each interval, a pointer to the memory address where the transcript or read is completely described. To do so, we simply added a new column in the L table, which stores the address. When an overlap is found, the full structure is retrieved and the query and reference intervals are compared in detail to report only true matches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>Comparison to other implementations. We show here the results of our algorithm when compared with several other published methods. The first is a simple NC-list algorithm, as presented by<ref type="bibr" target="#b0">Alekseyenko and Lee (2007)</ref>, which does not use any information between two consecutive query intervals, hereafter called 'nc'. The second method implements binning (<ref type="bibr" target="#b5">Kent et al., 2002</ref>) using an indexed SQLite table, hereafter called 'bin'. We also implemented another flavor of this algorithm, called 'has', where the database has been replaced by a hash structure, such that the keys are the bins, and the values are lists of intervals. A forth algorithm is a binning table with segment tree, as described in Segtor (<ref type="bibr" target="#b8">Renaud et al., 2011</ref>), called 'seg'. We also added FJoin (<ref type="bibr" target="#b9">Richardson, 2006</ref>) ('fj'), which scans the previously sorted query intervals and reference intervals simultaneously to find overlaps. Our algorithm will simply be called 'new'. Among the presented algorithms, only 'bin', 'nc' and 'new' have constant space complexities. The other algorithms, 'has', 'seg' (where the trees are stored in memory) and 'fj' (which has a linear space complexity), are thus not likely to work on the large amount of data modern sequencers generate, with a standard computer. For instance, in our implementation, the 'has' algorithm fills our RAM (4 GB) when the reference dataset contains 30 M intervals. Still, as they rely on in-memory data, they usually run faster on the sets they can handle. For a fair comparison of all the algorithms, and to exclude any bias that would originate from the choice of the programming language used by the different methods, we re-implemented all the algorithms carefully as described by the articles. All the algorithms have exactly the same input, output and functionalities, which reflect a usual mapped reads/annotation comparison study. First, strand is ignored (as many RNA-Seq data have no strand information, and most algorithms, when described in their original articles, do not deal with this case). Second, each feature (hereafter a read or a transcript) is stored as a single interval. If an overlap is detected, the transcript is extracted from the input file (each method keeps track of the memory address of the features) and a second comparison is performed to check if the overlap is not located in the introns of the transcript, in which case the overlap is not reported. Last, the output file is a GFF3 file, which contains the query intervals that overlap with at least one reference element, and the list of the overlapping elements are added in the tags of the ninth field. These implementations, as well as the benchmark itself, are available in the S–MART toolbox. See supplementary materials for more information about these implementations. Example on a real dataset. We downloaded three different publicly available RNA-Seq datasets: on yeast, fly and cress (available as SRR014335, SRR030228 and SRR346552 datasets in GEO). We mapped the reads with Bowtie (<ref type="bibr" target="#b6">Langmead et al., 2009</ref>) on the reference genome and we compared the mapped reads with the annotation (the genome sequence and the annotations are both available from the Bowtie website). For each dataset, we reported the number of annotated transcripts (which are the reference intervals) as well as the number of reads (the query intervals). We used the six different algorithms previously mentioned. Run-time results are shown in<ref type="figure" target="#tab_1">Table 1</ref>. The first columns give the characteristics of the datasets: number of reads, number of transcripts and number of overlaps. The following columns give the run-time spent by the algorithms when the genes are the reference and the reads are the query. As expected, 'has' and the 'fj' algorithms usually perform well on this dataset because the intervals are stored in memory.Our algorithm is still among the fastest ones. However, the preprocessing of our algorithm is by far the slowest one (see Supplementary Data). This is a typical trade-off between run-time speed and pre-processing-time speed because the 'bin' algorithm, the slowest algorithm in the comparison step, is the fastest algorithm in the pre-processing step among constant space methods.</p><p>Example on simulated datasets. We also generated several datasets to compare the algorithms in detail. The intervals ranged from 36 to 100 nt, the genome contained a single chromosome, ranging from 10 k to 2 M bp. The number of reference and query intervals varies from 100 to 100 k and 100 to 10 M elements, respectively. Each configuration was generated five times. The results in<ref type="figure" target="#fig_7">Figure 4</ref>give the run-time results of each method. Our algorithm is still the fastest among the constant space complexity algorithms. The 'fj' required too much RAM (more than 4 GB) to work on the largest datasets. Regarding the pre-processing step, our algorithm is the slowest one (see Supplementary Information) but overall, the balance is always favorable to our algorithm after three comparisons when compared with the 'bin', the 'seg' or the 'nc' algorithm.</p><p>Insertion in S–MART. S–MART (<ref type="bibr" target="#b11">Zytnicki and Quesneville, 2011</ref>) is a versatile tool box for the analysis of RNA-Seq data. It contains many useful tools for the comparison of RNA-Seq data with respect to a given annotation: number of reads for each transcript, distance distribution between the reads and the closest transcripts, discovery of previously unknown transcribed loci, etc. We added a new tool, called FindOverlapsOptim, which implements the algorithm presented in this article. As a consequence, the algorithm can be used for many kinds of data (such as RNA-Seq reads, but also annotation of any feature) in many formats (GFF3, BED, SAM, etc.). We included a so-called 'nclist' format in S–MART, which contains several NC–lists (one per chromosome), so that preprocessing can be done once for all. This pre-processing step can be performed using a separate tool called ConvertToN CList. These files can be used as input file by most tools of the S–MART suite, much like BED or GFF3 files. We also implemented a second version of our algorithm in the S–MART tool called CompareOverlapping. This version is more flexible and accepts many different parameters: it may output the query elements only if they are collinear (or antisense) to the overlapping reference element, the query elements that are nested inside reference elements, the query elements that overlap the first 100 bp of the reference elements, etc. Because CompareOverlapping is much more flexible than FindOverlapsOptim, it is also substantially slower. Last, we added two versions of the much faster 'has' algorithm in S–MART, to be used when the query or the reference have moderate sizes. The encapsulation of the algorithms within S–MART ensures that the presented method is not only a theoretical work, but also used in a tool that is readily available to biologists. For the computer scientists, we also implemented an API and executables in Cþþ so that they can embed them in their algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>The method presented here uses NC-lists and provides a fast algorithm that compares two large sets of intervals efficiently.To our knowledge, it is the first time that an algorithm with both linear time complexity and constant space complexity during the search phase is presented. This low run-time complexity comes at the cost of a high pre-processing time complexity, where the intervals should be sorted. However, this step is done only once and is far from untractable (the samtools sort algorithm is used routinely to sort BAM files). As a result, the algorithm presented in this article is adapted to multiple comparisons. When we designed the algorithm, we had the idea in mind that it could help comparing features such as RNA-Seq data, which can amount to several hundreds millions reads. While this algorithm presents a theoretical interest by itself, we also encapsulated it in the S–MART tool box, which includes all the features to handle usual file formats. As a consequence, we hope this work will be useful for both computer scientists and biologists.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>DEFINITION3.</head><figDesc>We define the subelement of an interval by 8r 2 R, r:sub ¼ fs 2 R : r 0 R s ^ s 0 R min 0R fr 0 2 R : ðr 0 R r 0 Þ ^ ðr 0 6 &amp; rÞgg The children of an interval are as follows: 8r 2 R, r:children ¼ fc 2 r:sub : 8c 0 2 r:subnfcg, c 6 &amp; c 0 g r:children is also called the sublist of r. The parent of an interval is defined as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Pathological case concerning the algorithm between one query interval (in black) and several reference reads (white)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>be undefined if B[q] and A[q] are empty. In this case, we define nfo[q] ¼ None. To help the reader, different configurations of the nfo[q] are described in Figure 3. We will prove that the predecessors of nfo, except for its ancestors, are all in B[q].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>If nfo½q 2 A½q, then Lemma 2 proves that r will be in A[q]. Otherwise, nfo½q 2 M½q. In this case, by definition of nfo[q], all its children are in B[q], and by application of Lemma 1, all the intervals that are under nfo[q] are in B[q]. Finally, by application of Lemma 5, all the reference intervals that are after nfo[q], but not under it, are in M½q [ A½q. This proves the proposition.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>PROPOSITION7.</head><figDesc>nfo½q is the nfo computed in the algorithm. PROOF. Let us consider a query interval q 0 and its successor q. We have ðM½q \ A½qÞ &amp; ðM½q 0  \ A½q 0 Þ. By corollary 4,</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.3.</head><figDesc>Fig. 3. Different configurations of the interval comparison problem. In every case, the query interval (q) is in black, and the other colors refer to the reference intervals. nfo[q] is indicated by the arrow. To help the reader, reference intervals in B[q] are white; the intervals in M[q] are light gray; dark gray intervals are in A[q]. Case (A) is the simple case, the other cases are less intuitive. In case (B), we can observe that the first overlapping interval is not nfo[q]: it is the bottom-most overlapping element. In case (C), all the children of nfo[q] are in B[q]. In case (D), nfo[q] is in A[q]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.4.</head><figDesc>Fig. 4. Runtime of the algorithms. Each cell provides the runtime of each algorithm in seconds. The numbers of reference and query intervals are provided on top of each cell. Each configuration has been repeated five times with a genome size of 100Â the number of reference intervals, and 200Â the number of reference intervals. The 'fj' required too much RAM (44 GB) to work on the largest datasets and is therefore not provided in these configurations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><figDesc>Funding: Y.L. was supported by the Plant Breeding and Genetics research division of the INRA and by the Groupement d'inte´reˆtinte´reˆinte´reˆt scientifique IBISA. Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. Characteristics of three real datasets, and run-time results (in thousands of seconds) for the six algorithms</figDesc><table>Dataset No. of 
reads 

No. of 
transc. 

No. 
of ov. 

bin has seg fj 
nc 
new 

Yeast 
10 M 
9 k 
20 M 
5.1 3.2 
4.3 a 
4.8 3.4 
Fly 
3 M 
183 k 
10 M 
2.5 1.3 
1.9 1.1 
2.1 1.4 
Cress 
20 M 
245 k 
58 M 17 
9.2 13 

a 

14 
9.1 

a 

The program aborted for it needed too much memory (44 GB). 
No. of transc., number of annotated transcripts, used as reference; No. of ov., 
number of overlaps. </table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> 2 1 1 (top list) (sublist of 2) (sublist of 3) (sublist of 6) 14 30 24 16 23 15 28 H L 0 1 Fig. 1. Transforming a set of ordered intervals an NC-list. All the intervals have been previously sorted according to their increasing start position and, in case of tie, decreasing end position. Because intervals 3, 4 and 5 are nested inside interval 2, they are removed from the top list (which consists in intervals 1, 2 and 6) and inserted into another sublist. Intervals 3 and 5 are moved to the sublist of 2. Similarly, interval 4 is nested inside interval 3, and thus moved to another sublist. When an interval is nested into two intervals (as it is the case for the interval 7, which is nested in 2 and 6), the right-most interval that contains it is chosen. Here, it is interval 6. An NC-list is a set of two arrays, L and H. Each line of L stores the start and end positions of an interval, as well as an index to the H array. The L data are stored so that the intervals that are in the same list appear contiguously. For each sublist, a corresponding line of the H array stores the index of its least interval and the size of the list. As highlighted by the arrows, the sublist of interval 2 (line 1 of the L array, which is a zero-based structure) is the line 1 of the H array. The sublist starts at index 3 of the L array and contains 2 intervals (the intervals 3 and 5)</note>

			<note place="foot">M.Zytnicki et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Efficient comparison of sets of intervals at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Nested containment list (NCList): a new algorithm for accelerating interval query of genome alignment and interval databases</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">V</forename>
				<surname>Alekseyenko</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">J</forename>
				<surname>Lee</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="1386" to="1393" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">HTSeq: analysing high-throughput sequencing data with python Galaxy: A Web-Based Genome Analysis Tool for Experimentalists</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Anders</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Blankenberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Chapter</title>
		<imprint>
			<publisher>John Wiley &amp; Sons Inc</publisher>
			<biblScope unit="volume">1910</biblScope>
			<biblScope unit="page" from="1" to="21" />
			<date type="published" when="2010" />
			<publisher>John Wiley &amp; Sons Inc</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Galaxy: a platform for interactive large-scale genome analysis</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Giardine</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1451" to="1455" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title level="m" type="main">Galaxy: a comprehensive approach for supporting accessible, reproducible, and transparent computational research in the life sciences</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Goecks</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">86</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">The human genome browser at UCSC</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">J</forename>
				<surname>Kent</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="996" to="1006" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">The Sequence Alignment/Map format and SAMtools</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2078" to="2079" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Segtor: rapid annotation of genomic coordinates and single nucleotide variations using segment trees</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Renaud</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS ONE</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">26715</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">fjoin: simple and efficient computation of feature overlaps</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Richardson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1457" to="1464" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Improving Rna-Seq expression estimates by correcting for fragment bias</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Roberts</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">22</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">S-MART, a software toolbox to aid RNA-seq data analysis</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Zytnicki</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Quesneville</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS ONE</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">25988</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>