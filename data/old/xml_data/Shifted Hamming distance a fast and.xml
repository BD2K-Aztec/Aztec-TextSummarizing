
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:48+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Shifted Hamming distance: a fast and accurate SIMD-friendly filter to accelerate alignment verification in read mapping</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Hongyi</forename>
								<surname>Xin</surname>
							</persName>
							<email>hxin@cmu.edu,</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">John</forename>
								<surname>Greth</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">John</forename>
								<surname>Emmons</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Gennady</forename>
								<surname>Pekhimenko</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science Department</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Carl</forename>
								<surname>Kingsford</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Computational Biology Department</orgName>
								<orgName type="institution">Carnegie Mellon University</orgName>
								<address>
									<postCode>15213</postCode>
									<settlement>Pittsburgh</settlement>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Can</forename>
								<surname>Alkan</surname>
							</persName>
							<email>calkan@cs.bilkent.edu.tr or onur@cmu.edu</email>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Engineering</orgName>
								<orgName type="institution">Bilkent University</orgName>
								<address>
									<postCode>06800</postCode>
									<settlement>Bilkent</settlement>
									<region>Ankara</region>
									<country key="TR">Turkey</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Onur</forename>
								<surname>Mutlu</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Electrical and Computer Engineering</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Shifted Hamming distance: a fast and accurate SIMD-friendly filter to accelerate alignment verification in read mapping</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu856</idno>
					<note type="submission">Received on September 8, 2014; revised on December 1, 2014; accepted on December 23, 2014</note>
					<note>Sequence analysis *To whom correspondence should be addressed Associate Editor: Alfonso Valencia Contact: Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Calculating the edit-distance (i.e. minimum number of insertions, deletions and substitutions) between short DNA sequences is the primary task performed by seed-and-extend based mappers, which compare billions of sequences. In practice, only sequence pairs with a small edit-distance provide useful scientific data. However, the majority of sequence pairs analyzed by seed-and-extend based mappers differ by significantly more errors than what is typically allowed. Such error-abundant sequence pairs needlessly waste resources and severely hinder the performance of read mappers. Therefore, it is crucial to develop a fast and accurate filter that can rapidly and efficiently detect error-abundant string pairs and remove them from consideration before more computationally expensive methods are used. Results: We present a simple and efficient algorithm, Shifted Hamming Distance (SHD), which accelerates the alignment verification procedure in read mapping, by quickly filtering out error-abundant sequence pairs using bit-parallel and SIMD-parallel operations. SHD only filters string pairs that contain more errors than a user-defined threshold, making it fully comprehensive. It also maintains high accuracy with moderate error threshold (up to 5% of the string length) while achieving a 3-fold speedup over the best previous algorithm (Gene Myers&apos;s bit-vector algorithm). SHD is compatible with all mappers that perform sequence alignment for verification. Availability and implementation: We provide an implementation of SHD in C with Intel SSE instructions at: https://github.com/CMU-SAFARI/SHD.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The emergence of massively parallel sequencing technologies, commonly called high-throughput sequencing platforms, during the past decade triggered a revolution in the field of genomics. These platforms enable scientists to sequence mammalian-sized genomes in a matter of days, which has created new opportunities for biological research. For example, it is now possible to investigate human genome diversity between populations 1000 Genomes Project<ref type="bibr" target="#b0">Consortium (2010</ref><ref type="bibr">Consortium ( , 2012</ref>), find genomic variants likely to cause disease (<ref type="bibr" target="#b8">Flannick et al., 2014;</ref><ref type="bibr" target="#b19">Ng et al., 2010</ref><ref type="bibr" target="#b16">Marques-Bonet et al., 2009;</ref><ref type="bibr" target="#b20">Prado-Martinez et al., 2013;</ref><ref type="bibr" target="#b23">Scally et al., 2012;</ref><ref type="bibr" target="#b27">Ventura et al., 2011</ref>) and ancient hominids (<ref type="bibr" target="#b9">Green et al., 2010;</ref><ref type="bibr" target="#b17">Meyer et al., 2012;</ref><ref type="bibr" target="#b21">Reich et al., 2010</ref>) to better understand human evolution. However, these new sequencing platforms drastically increase the computational burden of genome data analysis. In the first step of data analysis, billions of short DNA segments (called reads) are aligned to a long reference genome. Each read is mapped to one or more sites in the reference based on similarity with a process called read mapping. Read mappers typically fall into one of two main categories: suffix-array and backtracking-based (<ref type="bibr" target="#b5">Delcher et al., 1999</ref>; Langmead and Salzberg 2012; Li and Durbin 2010) or seed-and-extend-based (<ref type="bibr" target="#b2">Ahmadi et al., 2011;</ref><ref type="bibr" target="#b3">Alkan et al., 2009;</ref><ref type="bibr" target="#b14">Li et al., 2009;</ref><ref type="bibr" target="#b22">Rumble et al., 2009;</ref><ref type="bibr" target="#b28">Weese et al., 2012</ref>). Suffix-array-based mappers use the Burrows-Wheeler transformation (<ref type="bibr" target="#b4">Burrows et al., 1994</ref>) and are efficient at finding the best mappings of a read. Mappers in this category use aggressive algorithms to build their candidate pools, which may miss potentially correct mappings. Although mappers in this category can also be configured to achieve higher sensitivity by systematically inspecting all possible error scenarios of a read, such configuration increases their execution times superlinearly (<ref type="bibr" target="#b5">Delcher et al., 1999</ref>; Langmead and Salzberg 2012; Li and Durbin 2010). Alternatively, seed-and-extend-based mappers build comprehensive but overly large candidate pools and rely on filters and local alignment techniques to remove incorrect mappings (i.e. potential mappings with more errors than allowed) from consideration in the verification step. Mappers in this category are comprehensive (find all correct mappings of a read) and accurate (do not provide incorrect mappings), but waste computational resources identifying and rejecting incorrect mappings. As a result, they are slower than suffix-array-based mappers. Fast and accurate filters, which detect and reject incorrect mappings using cheap heuristics can increase the speed of seedand-extend mappers (by speeding up the verification procedure,<ref type="bibr" target="#b29">Xin et al., 2013</ref>) while maintaining their high accuracy and comprehensiveness. An ideal filter should be able to quickly verify the correctness of a mapping, yet require much less computation than rigorous local alignment, which precisely calculates the number of errors between the read and reference using dynamic programming methods. More importantly, a filter should never falsely remove a correct mapping from consideration, as this would reduce the comprehensiveness of the mapper. Recent work has shown the potential of using single instruction multiple data (SIMD) vector execution units including general-purpose GPUs and Intel SSE Intel (2012) to accelerate local alignment techniques (<ref type="bibr" target="#b7">Farrar 2007;</ref><ref type="bibr" target="#b15">Manavski and Valle 2008;</ref><ref type="bibr" target="#b25">Szalkowski et al., 2008</ref>). However, these publications only apply SIMD units to existing scalar algorithms, which do not exploit the massive bitparallelism provided by SIMD platforms. In this article, we present shifted hamming distance (SHD), a fast and accurate SIMD-friendly bit-vector filter to accelerate the local alignment (verification) procedure in read mapping. The key idea of SHD is to avoid wasting computational resources on incorrect mappings by verifying them with a cheap, SIMD-friendly filter before invoking canonical complex local alignment methods. Our studies show that SHD quickly identifies the majority of the incorrect mappings, especially ones that contain far more errors than allowed, while permitting only a small fraction of incorrect mappings to pass SHD which are later filtered out by more sophisticated and accurate filters or by local alignment techniques. This article makes the following contributions: @BULLET We show that for seed-and-extend-based mappers, most potential mappings contain far more errors than what is typically allowed (Section 2). @BULLET We introduce a fast and accurate SIMD-friendly bit-vector filter, SHD, which approximately verifies a potential mapping with a small set of SIMD-friendly operations (Section 3). @BULLET We prove that SHD never removes correct mappings from consideration; hence, SHD never reduces the accuracy or the comprehensiveness of a mapper (Section 3). @BULLET We provide an implementation of SHD with Intel SSE (Section 3) and compare it against three previously proposed filtering and local alignment implementations (Section 4), including an SSE implementation of the Smith–Waterman algorithm, swps3 (<ref type="bibr" target="#b25">Szalkowski et al., 2008</ref>); an implementation of Gene Myers's bit-vector algorithm, SeqAn (Dö ring et al., 2008) and an implementation of our Adjacency Filtering algorithm, FastHASH (<ref type="bibr" target="#b29">Xin et al., 2013</ref>). Our results on a wide variety of real read sets show that SHD SSE is both fast and accurate. SHD SSE provides up to 3Â speedup against the best previous state-of-the-art edit-distance implementation (Dö ring et al., 2008) with a maximum false-positive rate of 7% (the rate of incorrect mappings passing SHD).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Motivation</head><p>Read mappers identify locations within a reference genome where the read and the reference match within a user-defined error (i.e. insertions, deletions or substitutions) threshold, e. In practice, e is usually 5% of the read length, but most aligners can be configured to return only the best mapping (the mapping with the fewest errors). As seen in<ref type="figure">Figure 8</ref>(in Supplementary Materials), most potential location mappings tested by seed-and-extend based mappers are incorrect (having more errors than allowed); in fact, when e ¼ 5% of the read length, more than 98% of mappings are incorrect. Since alignment is the primary computationally intensive task performed by seed-and-extend-based read mappers (<ref type="bibr" target="#b29">Xin et al., 2013</ref>), it is crucial that incorrect mappings be rejected efficiently. Many mechanisms have been proposed to efficiently calculate the edit-distance of strings and filter out incorrect mappings. These mechanisms can be divided into five main classes: (i) dynamic programming (DP) algorithms, (ii) SIMD implementations of DP algorithms, (iii) bit-vector implementations of DP algorithms, (iv) Hamming distance calculation and (v) locality-based filtering mechanisms. Notice that although mechanisms in both (ii) and (iii) are different implementations of (i), we separate them into two categories because they use different optimization strategies: while mechanisms in (ii) faithfully implement the DP algorithm in a SIMD fashion, mechanisms in (iii) use a modified bit-parallel algorithm to calculate a bit representation of the DP matrix (<ref type="bibr" target="#b18">Myers 1999</ref>). Full descriptions of each strategy are provided in Supplementary Materials, Section S1.3. In this article, we choose three representative implementations from (ii), (iii) and (v): swps3 (<ref type="bibr" target="#b25">Szalkowski et al., 2008</ref>), SeqAn (<ref type="bibr">Dö ring et al., 2008</ref>) and FastHASH (<ref type="bibr" target="#b29">Xin et al., 2013</ref>) (for detailed analysis, see Supplementary Materials S1.3). These mechanisms were not designed as SIMD bit-parallel filters and are either fast or accurate (can filter out most incorrect mappings) but not both. Conversely, we designed SHD to leverage bit-parallelism and SIMD instructions to achieve high performance while preserving high accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Shifted Hamming Mask-Set (SHM)</head><p>SHM aligns basepairs in the read and the reference by horizontally shifting the read against the reference. SHM is based on the key observation that if there are no more than e errors between the read and the reference, then each non-erroneous basepair (bp) in the reference can be matched to a basepair in the read within ½Àe; þe shifts from its position. Thus, if there are more than e basepairs in the read that failed to find a match in the reference, then there must be more than e errors between the read and the reference, hence the potential mapping should be rejected. Based on this observation, SHM verifies a potential mapping in two steps. First, SHM separately identifies all basepair matches by calculating a set of 2e þ 1 Hamming masks while incrementally shifting the read against the reference (one Hamming mask per shift). Each Hamming mask is a bit-vector of '0's and '1's representing the comparison of the read and the reference, where a '0' represents a bp match and a '1' represents a bp mismatch (implementation details of computing Hamming masks using bitparallel operations are provided in Supplementary Materials S1.1).<ref type="figure" target="#fig_0">Figure 1</ref>illustrates the production of these Hamming masks for a correct mapping. Once found, SHM merges all basepair matches together through multiple bit-wise AND operations. In SHM, to tolerate e errors, 2e þ 1 Hamming masks must be produced where: e Hamming masks are calculated after incrementally shifting the read to the left by 1 to e bps; e Hamming masks are calculated by incrementally shifting the read to the right by 1 to e bps; one additional Hamming mask is calculated without any shifting. By incrementally shifting the read in SHM, all basepairs between the read and the reference of a correct mapping (except the errors) are brought into alignment with at least one matching bp of the read and identified in one or more of the 2e þ 1 masks, as shown in<ref type="figure" target="#fig_0">Figure 1</ref>. The Hamming masks are merged together in 2e bit-wise AND operations. When ANDing Hamming masks, a '0' at any position will lead to a '0' in the resulting bit-vector at the same position.</p><p>When aligned with a match, a bp produces a '0' in the Hamming mask, which masks out all '1's in any other Hamming masks at the same position. Therefore, the final bit-vector produced after all bitwise AND operations are complete is guaranteed to contain '0's for all non-error basepairs; as a result, the number of '1's that remain in the final bit-vector provides a lower bound on the edit-distance between the read and the reference. Since correct potential mappings must have e or fewer errors, SHM can safely filter mappings whose final bit-vector contains more than e '1's, without any risk of removing correct read mappings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Speculative Removal of Short-Matches (SRS)</head><p>SHM ensures all correct read mappings are preserved; however, many incorrect mappings may also pass the filter as false positives. For example, the read in<ref type="figure" target="#fig_2">Figure 2</ref>is compared against a drastically different reference using SHM with an error threshold of two (e ¼ 2). Despite the presence of substantially more than two errors, the final bit-vector produced by SHM does not contain any '1's, as if there were no errors at all. In SHM, '0's in the final bit-vector are considered to be matches and '1's are considered to be errors. In this example, most basepairs in the reference find a match within two shifts of the read, so the read and the reference are considered similar enough to pass the filter. The false-positive rate of SHM increases superlinearly as e increases. Consider a random read and the reference pair, where each basepair in the read and reference are generated completely randomly (having 1/4 probability of being either A, C, G or T). The probability that a bp in the reference does not match anyneighboring bp in the read during any of the 2e þ 1 Hamming masks of SHM (hence rendering a '0' at its position in the final bit-vector) is ð3=4Þ 2eþ1 , which decreases exponentially as e increases. Therefore, when e is large, most basepairs in the reference find matches in the read during SHM, even if the read and the reference differ by more than e errors. Some of the incorrect mappings that pass SHM can still be identified by checking if the read and the reference share large sections of identical substrings. According to our second observation, two strings that differ by e errors will share no more than e þ 1 identical sections. These identical sections are simply the bp segments between errors. In fact, the goal of the entire local alignment (editdistance) computation is to identify these identical sections and the errors between them. When basepairs of an identical section are aligned in SHM, all basepairs of this identical section in the read simultaneously match all basepairs in the reference, which produces a contiguous streak of '0's in the Hamming mask (blue-highlighted region in<ref type="figure" target="#fig_0">Figure 1</ref>). Other '0's in the Hamming masks (unhighlighted '0's in the Hamming masks) that are not produced by an identical section represent only individual bp matches, which are not part of the correct alignment (the alignment produced by the local alignment computation) of the mapping. We call these '0's spurious, as they conceal mismatch errors and give the false impression that the read and the reference have a small edit distance, even when they differ significantly.</p><p>We propose a heuristic, SRS, which aims to remove spurious '0's. SRS uses one important observation: identical sections are typically long (!10 bps) while streaks of spurious '0's are typically short (&lt;3 bps). This insight is confirmed empirically through experiments, but is also supported by theory. Given that for most mappers e is in general less than 5% of the read length L, the average length of an identical section is greater than 16 bps for, say, L ¼ 80.</p><formula>(l sec ! L 0:05Lþ1 % 16</formula><p>). The probability that a streak of n '0's will be spurious (i.e. part of a random alignment between basepairs) is ð1=4Þ n. For streaks where n is greater than 3 bps, the probability of being spurious is below 1%. Using this insight, we replace all streaks of '0's in the Hamming masks that are shorter than three digits with '1's. We call the '1's that replace the '0's (i.e. amended from '0's) as amended '1's. Amended '1's do not affect the final bit-vector of the SHM as they are " transparent " during AND operations. The potential trade-offs and reasoning for choosing three as our threshold for SRS is discussed in Section 3.3. Note, the incorrect mapping which passed SHM in<ref type="figure" target="#fig_2">Figure 2</ref>is identified and correctly rejected using SRS in<ref type="figure" target="#fig_1">Figure 3</ref>. Since SRS amends all short streaks of '0's, even the ones produced by correct alignments of basepairs, it could cause correct read mappings to be mistakenly filtered, as shown in<ref type="figure" target="#fig_3">Figure 4</ref>. To avoid this possibility, SRS counts the number of errors in the final bitvector more conservatively than SHM. Each streak of '1's in the final bit-vector could be the outcome of multiple streaks of amended '1's. However, '0's are changed only if they are two-or-fewer-bit '0' streaks and are surrounded by '1's. In the worst case, multipleexample, during the bit-wise AND operations, short streaks of '0's at different locations in the Hamming masks overwrite (mask out) any '1's in other Hamming mask that are at the same locations. As a result, the final bit-vector of SHM is full of '0's. With SRS, streaks of '0's that are shorter than three are marked as spurious and are subjected to removal later on back-to-back short identical sections that are separated by single errors can be mistakenly overwritten into a long streak of '1's (e.g. 1001001 ! 11111111). As a result, the number of errors covered by a streak of '1's (e 1 ) of length l 1 after SRS is e 1 ¼ 1 þ ½ðl 1 þ 1Þ=3. The streak of four '1's in the final bit-vector of<ref type="figure" target="#fig_3">Figure 4</ref>is now counted as only two errors rather than four and the correct mapping passes the filter. Using this counting scheme, we ensure all correct mappings will pass through the filter, while still identifying and removing read and reference pairs with errors up to 5% of the read length (results are provided in Section 4). SRS can be implemented using SIMD-friendly operations. As we explain in Supplementary Materials, the ability to implement SRS with SIMD instructions is crucial for the high performance of SHD, as it enables computing SRS in constant time with few instructions: both overwriting of short streaks of '0's and counting the number of errors of streaks of '1's can be computed in constant time using SIMD packed shuffle operations. See Section 1.3 in Supplementary Materials for details. Combined with SHM, SRS and SHM form the two-step filtering algorithm SHD, which guarantees that correct read mappings are preserved, while quickly removing incorrect mappings with simple bit-parallel operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Analysis of SHD</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Pseudocode</head><p>The pseudocode of SHD is shown in Algorithm 1. Overall, SHD computes 2e þ 1 Hamming masks (ComputeHammingMask), with e of them computed with the read incrementally shifted to the left; e of them computed with the read incrementally shifted to the right, and one computed without any shifts. Each Hamming mask is then processed by SRS to amend short streaks of '0's into '1's (SRS_amend). Finally, all Hamming masks are merged together into a final bit-vector through bit-wise AND operations and a lower bound of errors is computed from the final bit-vector (SRS_count). Details of implementations of ComputeHammingMask, (SRS_amend) and SR S_count are discussed in Supplementary Materials.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">False Negatives</head><p>SHD never filters out correct mappings; hence, it has a zero falsenegative rate. As we discussed in Section 3.2, identical sections longer than 3 bps are recognized and preserved in the final bit-vector by SHD. Identical sections shorter than 3 bps are amended into '1's; however, SHD counts '1's in the final bit-vector conservatively, ensuring correct mappings are not filtered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">False Positives</head><p>SHD does allow a small portion of incorrect mappings to pass the filter as false positives. This is acceptable since SHD is only a filter. Incorrect mappings that pass SHD are discarded later by more rigorous edit-distance calculations. Below, we describe two major sources of false positives, both of which are related to the threshold of the SRS (the minimal length of a streak of '0's that will not be amended by SRS). First, long streaks of spurious '0's are not identified by SRS. Although less likely, long streaks of '0's can still be spurious(i.e. identical substrings between the read and the reference that do not belong to the correct alignment between the read and the reference). Long spurious streaks of '0's in an incorrect mapping can mask out real errors ('1's in other Hamming masks) and produce a mostly '0' final bit-vector even though the read and the reference differ by more errors. We can increase the SRS threshold beyond three bps, which amends longer streaks of '0's, to reduce such false positives. Second, SRS may underestimate the number of errors while examining the final bit-vector. SRS always assumes the worst case where any streak of '1's in the final bit-vector is the result of amending short streaks of spurious '0's, despite the possibility it could be a sequence full of real errors. When counting streaks of '1's, SHD only assigns the minimal number of errors required to produce the pattern (e.g. 1001111 ! 11111111 ! 1001001 three errors counted when five errors are present). By always assuming the worst case, SHD may underestimate the number of errors in the final bit-vector and let incorrect mappings pass the filter. Although using a smaller SRS threshold would help filter out such false positives, it would also let long streaks of spurious '0's pass the filter as we described in the previous paragraph. As a result, a carefully chosen SRS threshold should consider both factors: it should neither be too small to omit long spurious '0's nor should it be too large to underestimate the number of errors.<ref type="figure" target="#fig_4">Figure 5a</ref>shows this dilemma, as the false-positive rate first drops and then slowly increases as SRS threshold increases. In this article, we chose three as our SRS threshold because: 1, the false-positive rate of SHD drops below 2% (with the configuration of e ¼ 3) at three and remains steady afterwards and 2, with Intel</p><formula>(a)</formula><p>(b)SSE platform we are only able to provide an efficient implementation of SHD with an SRS threshold no-more-than three (further elaborated in Supplementary Materials). A sweep of the false-positive rate of SHD against variant allowed error rate (error threshold divide by read length) is shown in<ref type="figure" target="#fig_4">Figure 5b</ref>. While the false-positive rate of SHD increases with larger allowed error rate, at 5% error rate (which is the upper limit of most available mappers (<ref type="bibr" target="#b2">Ahmadi et al., 2011;</ref><ref type="bibr" target="#b3">Alkan et al., 2009;</ref><ref type="bibr" target="#b5">Delcher et al., 1999;</ref><ref type="bibr" target="#b12">Langmead and Salzberg 2012;</ref><ref type="bibr" target="#b13">Li and Durbin 2010;</ref><ref type="bibr" target="#b14">Li et al., 2009;</ref><ref type="bibr" target="#b22">Rumble et al., 2009;</ref><ref type="bibr" target="#b28">Weese et al., 2012</ref>), the false-positive rate of SHD is only 7%, indicating a high accuracy (&gt; 93%) of the filter.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. An example of applying SHM to a correct mapping, which contains two deletions. All matching basepairs are identified in the Hamming masks as 0s and are merged together using bit-wise AND operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.3.</head><figDesc>Fig. 3. The incorrect mapping from Figure 2 is filtered correctly by SRS, since most of its short streaks of '0's are turned into amended '1's. Amended '1's transparent during the AND operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. An example of an incorrect mapping that passes SHM. In this example, during the bit-wise AND operations, short streaks of '0's at different locations in the Hamming masks overwrite (mask out) any '1's in other Hamming mask that are at the same locations. As a result, the final bit-vector of SHM is full of '0's. With SRS, streaks of '0's that are shorter than three are marked as spurious and are subjected to removal later on</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.4.</head><figDesc>Fig. 4. Correct short streaks of '0's might also get overwritten by SRS. To avoid filtering out correct mappings, SRS counts the errors of a streak of '1's in the final bit-vector conservatively, always assuming it was overwritten by a short streak of correct '0's</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.5.</head><figDesc>Fig. 5. A sweep of the false positive rate of SHD, against variant allowed error rate [(a), under a fixed SRS threshold of three bps] and variant SRS thresholds [(b), under a fixed allowed error rate of 3%], respectively. The sweep is produced with the first one billion potential mappings analyzed by mrFAST when it maps the read set ERR240728 from the 1000 Genomes Project (1000 Genomes Project Consortium 2012) under an error threshold of 3 bps</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.6.</head><figDesc>Fig. 6. The execution time of SHD, SeqAn, swps3 and FastHASH (AF) with different error thresholds (e) across multiple read sets</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>, and study the genomes V C The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com 1553 Bioinformatics, 31(10), 2015, 1553–1560 doi: 10.1093/bioinformatics/btu856 Advance Access Publication Date: 10 January 2015 Original Paper of ape species (</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. Benchmark data, obtained from the 1000 Genomes Project Phase I (1000 Genomes Project Consortium 2012)</figDesc><table>ERR240726_1 
ERR240726_2 
ERR240727_1 
ERR240727_2 
ERR240728_1 

No. of Reads 
4031354 
4031354 
4082203 
4082203 
3894290 
Read Length 
101 
101 
101 
101 
101 

ERR240728_2 
ERR240729_1 
ERR240729_2 
ERR240730_1 
ERR240730_2 

No. of Reads 
43894290 
4013341 
4013341 
4082472 
4082472 
Read Length 
101 
101 
101 
101 
101 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">H.Xin et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Overview Our filtering algorithm, SHD, uses simple bit-parallel operations (e.g. AND, XOR, etc.) which can be performed quickly and efficiently using the SIMD architectures of modern CPUs. SHD relies on two key observations: 1. If two strings differ by e errors, then all non-erroneous characters of the strings can be aligned in at most e shifts. 2. If two strings differ by e errors, then they share at most e þ 1 identical sections (Pigeonhole Principle, Xin et al., 2013). Based on the above observations, SHD filters potential mappings in two steps: 1. Identify basepairs (bps) in the read and the reference that can be aligned by incrementally shifting the read against the reference. 2. Remove short stretches of matches identified in step 1 (likely noise). We call these two steps shifted Hamming mask-set (SHM) and speculative removal of short-matches (SRS), respectively. In the remainder of this section, we describe these two steps, then analyse SHD in terms of false negatives (defined as correct mappings that are falsely rejected by SHD) and false positives (defined as incorrect mappings that pass SHD).</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Results</head><p>We implemented SHD in C, using Intel SSE. We compared SHD against three edit-distance calculation/filtering implementations, they are: SeqAn (<ref type="bibr">Dö ring et al., 2008</ref>), an implementation of Gene Myers's bit-vector algorithm (<ref type="bibr" target="#b18">Myers 1999</ref>); swps3 (<ref type="bibr" target="#b25">Szalkowski et al., 2008</ref>), a Smith-Waterman algorithm (Smith and<ref type="bibr" target="#b24">Waterman 1981</ref>) implementation; and FastHASH (<ref type="bibr" target="#b29">Xin et al., 2013</ref>), an Adjacency Filtering (AF) implementation. Both SeqAn and swps3 are also implemented with SSE and all implementations were configured to be single threaded. We used a popular seed-and-extend mapper, mrFAST (<ref type="bibr" target="#b3">Alkan et al., 2009</ref>), to retrieve all potential mappings (read-reference pairs) from 10 real datasets from the 1000 Genome Project Phase I (1000 Genomes Project Consortium 2012).lists the read length and read size of each set. Each read set is processed using multiple error thresholds (i.e. e from 0 to 5 errors). We benchmarked all four implementations using the same potential mappings (i.e. seed hits) produced by mrFAST for a fair comparison of the four techniques.shows the execution time of the four techniques with different error thresholds across multiple read sets. Notice that when the indel threshold is zero, SHD reduces to bit-parallel Hamming distance. A detailed comparison against bit-parallel Hamming distance implementation is provided in Supplementary Materials, Section S1.3. Among the four implementations, SHD is on average 3Â faster than SeqAn and 24Â faster than swps3. Although SHD is slightly slower than FastHASH (AF) when e is greater than two (e.g. 2:5Â slower when e ¼ 5), SHD produces far fewer (on average, 0:25Â) false positives than FastHASH (seen in). Note, the speedup gained by SHD diminishes with greater e. This is expected since the number of bit-parallel/SIMD operations of SHD increases for larger e.illustrates the false-positive rates of SHD and FastHASH (AF). SeqAn and swps3 both have a 0% false-positive rate, compared with SHD which has a 3% false-positive rate on average. That being the case, SHD is only a heuristic to filter potential mappings while both SeqAn and swps3 must compute the exact edit distances of the potential mappings. As we discussed in Section 3.3, the false-positive rate of SHD increases with larger e. Nonetheless, the false-positive rate of SHD at e ¼ 5 is only 7%, much smaller than the false-positive rate (50%) of FastHASH (AF) asshows. With these results, a mapper can selectively combine multiple implementations together to construct an efficient multi-layer filter/ edit-distance calculator. For instance, a mapper can attach SHD with FastHASH, to obtain both the fast-speed of FastHASH and the high accuracy of SHD. A mapper can also combine SHD with SeqAn to obtain 100% accuracy without significantly sacrificing the speed of SHD. Of course, there are many possibilities to integrate SHD into a other mappers, but a comprehensive study of this topic is beyond the scope of this article and is part of our future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>Most potential mappings that must be verified by seed-and-extendbased mappers are incorrect, containing far more errors than what is typically allowed. Our proposed filtering algorithm, SHD, can quickly identify most incorrect mappings (through our experiment, SHD can filter 86 billion potential mappings within 40 min on a single thread while obtaining a false-positive rate of 7% at maximum), while preserving all correct ones. Comparison against three other state-of-the-art edit-distance calculation/filtering implementations revealed that our Intel SSE implementation of SHD is 3Â faster than SeqAn (<ref type="bibr">Dö ring et al., 2008</ref>), the previous best edit-distance calculation technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This study is supported by NIH Grants (HG006004 to O.</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">A map of human genome variation from population-scale sequencing</title>
		<author>
			<persName>
				<forename type="first">Consortium</forename>
				<surname>Genomes Project</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">467</biblScope>
			<biblScope unit="page" from="1061" to="1073" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">The false-positive rates of SHD and FastHASH (AF) with different error thresholds (e) across multiple read sets ation from 1,092 human genomes</title>
		<author>
			<persName>
				<surname>Fig</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">491</biblScope>
			<biblScope unit="page" from="56" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Hobbes: optimized gram-based methods for efficient read alignment</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Ahmadi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page">41</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Personalized copy number and segmental duplication maps using next-generation sequencing</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Alkan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="1061" to="1067" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">A block-sorting lossless data compression algorithm</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Burrows</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>Digital Equipment Corporation</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Alignment of whole genomes</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">L</forename>
				<surname>Delcher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2369" to="2376" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Seqan an efficient, generic cþþ library for sequence analysis</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Dö Ring</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinf</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Striped Smith-Waterman speeds database searches six times over other SIMD implementations</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Farrar</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="156" to="161" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Loss-of-function mutations in slc30a8 protect against type 2 diabetes</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Flannick</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="357" to="363" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">A draft sequence of the Neandertal genome</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">E</forename>
				<surname>Green</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">328</biblScope>
			<biblScope unit="page" from="710" to="722" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast bit-vector algorithms for approximate string matching under indel distance</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hyyro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SOFSEM, Liptovsky´JáLiptovsky´ Liptovsky´Já n, Slovakia</title>
		<editor>Vojts,P. et al.</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="380" to="384" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Intel architecture instruction set extensions programming reference</title>
	</analytic>
	<monogr>
		<title level="j">Intel</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Method</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast and accurate long-read alignment with Burrows-Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="589" to="595" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">SOAP2: an improved ultrafast tool for short read alignment</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1966" to="1967" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">CUDA compatible GPU cards as efficient hardware accelerators for Smith-Waterman sequence alignment</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">A</forename>
				<surname>Manavski</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Valle</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinf</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">10</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
	<note>Suppl</note>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">A burst of segmental duplications in the genome of the African great ape ancestor</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Marques-Bonet</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">457</biblScope>
			<biblScope unit="page" from="877" to="881" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">A high-coverage genome sequence from an archaic denisovan individual</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Meyer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">338</biblScope>
			<biblScope unit="page" from="222" to="226" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">A fast bit-vector algorithm for approximate string matching based on dynamic programming</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="395" to="415" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Exome sequencing identifies MLL2 mutations as a cause of kabuki syndrome</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">B</forename>
				<surname>Ng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="790" to="793" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Great ape genetic diversity and population history</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Prado-Martinez</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">499</biblScope>
			<biblScope unit="page" from="471" to="475" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Genetic history of an archaic hominin group from Denisova Cave in Siberia</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Reich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">468</biblScope>
			<biblScope unit="page" from="1053" to="1060" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Shrimp: accurate mapping of short color-space reads</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">M</forename>
				<surname>Rumble</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">1000386</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Insights into hominid evolution from the gorilla genome sequence</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Scally</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">483</biblScope>
			<biblScope unit="page" from="169" to="175" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Identification of common molecular subsequences</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">F</forename>
				<surname>Smith</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Waterman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">147</biblScope>
			<biblScope unit="page" from="195" to="195" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">SWPS3—fast multi-threaded vectorized SmithWaterman for IBM Cell/B.e. and x86/SSE2</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Szalkowski</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Res. Notes</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">107</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Finding approximate patterns in strings</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ukkonen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Gorilla genome structural variation reveals evolutionary parallelisms with chimpanzee</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Ventura</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1640" to="1649" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Razers 3: faster, fully sensitive read mapping</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Weese</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="2592" to="2599" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Accelerating read mapping with FastHASH</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Xin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genomics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">13</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>