
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:37+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ScaffoldScaffolder: solving contig orientation via bidirected to directed graph reduction</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Paul</forename>
								<forename type="middle">M</forename>
								<surname>Bodily</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="laboratory">Computational Sciences Laboratory</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602-6576</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">M</forename>
								<forename type="middle">Stanley</forename>
								<surname>Fujimoto</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="laboratory">Computational Sciences Laboratory</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602-6576</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Quinn</forename>
								<surname>Snell</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="laboratory">Computational Sciences Laboratory</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602-6576</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Dan</forename>
								<surname>Ventura</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="laboratory">Computational Sciences Laboratory</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602-6576</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Mark</forename>
								<forename type="middle">J</forename>
								<surname>Clement</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="laboratory">Computational Sciences Laboratory</orgName>
								<orgName type="institution">Brigham Young University</orgName>
								<address>
									<postCode>84602-6576</postCode>
									<settlement>Provo</settlement>
									<region>UT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">ScaffoldScaffolder: solving contig orientation via bidirected to directed graph reduction</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btv548</idno>
					<note type="submission">Received on August 21, 2014; revised on September 9, 2015; accepted on September 11, 2015</note>
					<note>Sequence analysis *To whom correspondence should be addressed. Associate Editor: John Hancock Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: The contig orientation problem, which we formally define as the MAX-DIR problem, has at times been addressed cursorily and at times using various heuristics. In setting forth a linear-time reduction from the MAX-CUT problem to the MAX-DIR problem, we prove the latter is NP-complete. We compare the relative performance of a novel greedy approach with several other heuristic solutions. Results: Our results suggest that our greedy heuristic algorithm not only works well but also out-performs the other algorithms due to the nature of scaffold graphs. Our results also demonstrate a novel method for identifying inverted repeats and inversion variants, both of which contradict the basic single-orientation assumption. Such inversions have previously been noted as being difficult to detect and are directly involved in the genetic mechanisms of several diseases. Availability and implementation: http://bioresearch.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Accurate and efficient genome assembly algorithms are essential to unlocking solutions to challenges posed by genetic disease. Insufficient molecular sampling and repetitive regions in the DNA prevent full chromosomal assembly from next-generation sequencing reads, causing assembly algorithms to produce a large set of partially reconstructed chromosomes termed contigs. Contigs must be oriented and positioned to reconstruct full chromosomes using paired-read data to infer positional and orientational relationships between contigs. We define a scaffolding of two contigs as the relative positioning and orientation of contigs weighted by the multiplicity of supporting paired reads. The problem of scaffolding is often modeled as a graph where vertices are contigs and weighted edges indicate scaffoldings of contigs. The goal in scaffolding is to find a Hamiltonian path that incorporates each non-repeat contig sequence once. As a subtask of scaffolding, the contig orientation problem describes the challenge of assigning each contig a single orientation (as per the singleorientation assumption) so as to minimize conflicting orientation evidence. More specifically, the goal is to remove the minimum number of edges from the scaffold graph, so that the remaining subgraph suggests a single consistent orientation of all vertices (<ref type="bibr" target="#b25">Pop et al., 2004</ref>). Solving the contig orientation problem is one step to reducing erroneous linking evidence in the scaffold data. The contig orientation problem has been equated to the weighted MAX-CUT problem (<ref type="bibr" target="#b8">Dayarian et al., 2010</ref>), the bipartite graph problem (<ref type="bibr" target="#b25">Pop et al., 2004</ref>) and the odd cycle transferal problem (<ref type="bibr" target="#b10">Donmez and Brudno, 2013</ref>). Solutions have included energy cost minimization (<ref type="bibr" target="#b8">Dayarian et al., 2010</ref>), a fixed-parameter algorithm (<ref type="bibr" target="#b10">Donmez and Brudno, 2013</ref>), mixed integer programming (<ref type="bibr" target="#b29">Salmela et al., 2011</ref>), depth-first search (<ref type="bibr" target="#b23">Nijkamp et al., 2010</ref>) and greedy bipartite graph coloring (<ref type="bibr" target="#b25">Pop et al., 2004</ref>). Several solutions to the more general problem of scaffolding do not explicitly solve the contig orientation problem but provide implicit contig orientationsolutions as a result of completing walks through the scaffold graph (<ref type="bibr" target="#b4">Batzoglou et al., 2002;</ref><ref type="bibr" target="#b7">Butler et al., 2008;</ref><ref type="bibr" target="#b16">Li et al., 2010;</ref><ref type="bibr" target="#b30">Zerbino and Birney, 2008</ref>). Formal bidirected graph notation [as first laid out by Edmonds and<ref type="bibr" target="#b11">Johnson (1970)</ref>] has a long history in both computer science and bioinformatics research (<ref type="bibr" target="#b11">Edmonds and Johnson, 1970;</ref><ref type="bibr" target="#b14">Jackson and Aluru, 2008;</ref><ref type="bibr" target="#b20">Medvedev et al., 2007;</ref><ref type="bibr" target="#b22">Myers, 2005</ref>) but has rarely been employed to represent scaffold graphs (<ref type="bibr" target="#b29">Salmela et al., 2011</ref>). Commonly used is a notation in which directed nodes are depicted using some sort of biterminal distinction: one node terminal represents the biological 5 0-end of the contig sequence and the other terminal represents the 3 0end (<ref type="bibr" target="#b23">Nijkamp et al., 2010;</ref><ref type="bibr" target="#b25">Pop et al., 2004;</ref><ref type="bibr" target="#b30">Zerbino and Birney, 2008</ref>). Edges are then connected between the terminals or ends of a node. In this notation, a valid reconstruction or walk through a node requires entering and exiting the node via opposite terminals. The bidirected graph paradigm when applied to scaffold graphs enables new approaches to scaffolding problems, as will be shown. Research on the MAX-CUT problem has yielded a number of effective approximation algorithms including a min-max cut algorithm (<ref type="bibr" target="#b9">Ding et al., 2001</ref>), a randomized linear-time 1/2approximation (<ref type="bibr" target="#b28">Sahni and Gonzalez, 1976</ref>) and branch-and-bound methods (<ref type="bibr" target="#b26">Rendl et al., 2010</ref>). Goemans and Williamson (1994) present what is commonly accepted as the best MAX-CUT approximation algorithm (a 0.878-approximation) by randomly rounding the solution to a nonlinear-programming relaxation.<ref type="bibr" target="#b15">Khot et al. (2007)</ref>demonstrate that if the unique games conjecture is true, the Goemans–Williamson algorithm is the best possible approximation algorithm for MAX-CUT. The NP-completeness of the contig orientation problem has not hitherto been formally proven. We provide such a proof, demonstrating the many-one polynomial-time equivalence of the contig orientation and weighted MAX-CUT problems. We present a novel greedy solution and demonstrate its effectiveness compared with several MAX-CUT solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Contig orientation problem defined</head><p>We provide a novel formulation of the contig orientation problem using bidirected graph constructs as a prerequisite to outlining the proof of equivalence with MAX-CUT. A bidirected graph is formally defined as an undirected multigraph G with a set of vertices V and a set of bidirected edges E (<ref type="bibr" target="#b11">Edmonds and Johnson, 1970</ref>). A bidirected edge e is a five-tuple ðv i ; o i ; v j ; o j ; wÞ consisting of two vertices, v i and v j , the weight of the edge, w, and two endpoint orientations, o i and o j , one with respect to each vertex. An endpoint orientation may be either positive or negative, defining e as either positive-incident or negative-incident to the corresponding endpoint. In the graphical representation of a bidirected edge e, we represent positive-incidence with an arrow pointing out of the vertex and negative-incidence with an arrow pointing in toward the vertex. We thus say that e is directed if it is positive-incident to one endpoint and negative-incident to the other; introverted if positive-incident to both endpoints and extraverted if negative-incident to both endpoints. A directed graph is a special case of a bidirected graph in which all edges are directed edges. A valid (v 1 ,v k )-walk is a sequence v 1 ,e 1,. .. ; v kÀ1 ; e kÀ1 ,v k where e i is an edge incident to v i and v i þ 1 and for all 2 i k – 1, e iÀ1 and e i have opposite endpoint orientations incident to v i (<ref type="figure" target="#fig_0">Fig. 1a</ref>and b). Each valid walk through a vertex v i represents a possible scaffold reconstruction for contig c i. The contig orientation solution allows for a contig to be included multiple times or in multiple reconstructions while maintaining a consistent orientation (e.g. repetitive sequence). We thus define a bidirected scaffold graph for a set of contigs C and a set of weighted scaffoldings F as a bidirected graph G ¼(V,E) in which vertex v i 2 V represents contig c i 2 C and a weighted bidirected edge e ¼ ðv i ; o i ; v j ; o j ; wÞ represents the scaffolding f 2 F of contigs c i and c j , weighted by the number of supporting paired reads. The endpoint orientations, o i and o j , are determined by the relative orientation of the forward strands of c i and c j in f—if the forward strands of c i and c j are oriented in the same direction, then e is a directed edge that is positive-incident to the vertex representing the upstream contig; if the forward strands are oriented away from one another (i.e. 5 0-ends are proximal), then e is an extraverted edge and if the forward strands are oriented toward one another (i.e. 3 0-ends are proximal), then e is an introverted edge. The 5 0 –3 0 directionality of a DNA molecule must ultimately be consistent along the entire length of the sequence. This means that introverted and extraverted edges, both of which represent internally inconsistent 5 0 –3 0 directionality of the forward strand, violate a biological constraint. As per this definition, only directed edges are considered valid in the final scaffold reconstruction. A graph which retains the most weight in directed edges will retain the most internally consistent supporting evidence. Directed edges can be formed from introverted and extraverted edges by reversing one of the edge's endpoint orientations. This is essentially what is accomplished when we consider inclusion of the opposite strand of a contig in place of the strand currently being considered for inclusion: all endpoint orientations adjacent to the contig are reversed (<ref type="figure" target="#fig_0">Fig. 1c</ref>). The notion of contig orientation is used to more simply refer to which contig strands (relative to the initial forward strands) are being considered in a scaffolding. Thus, in our graph, we will say that for any vertex v i 2 V, we can arbitrarily select between the forward-orientation assignment v þ i and the reverse-orientation assignment v À i. We will refer to this selection as the contig-orientation assignment of c i or vertex-orientation assignment for v i. Furthermore, we refer to a contig-orientation assignment for all contigs in C (or vertices in G) as a contig-orientation assignment of C (or vertex-orientation assignment of G). We will refer to a vertex v i with possible vertex-orientation assignments v þ i and v À i as an orientable vertex. As the forward strand c þ i of each assembled contig c i is arbitrarily given as input, each corresponding vertex v i is initially assumed to be assigned the vertex-orientation v þ i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1.1">MAX-DIR problem</head><p>We formally state the corresponding decision problem as follows: MAX-DIR ¼ {(G,k) j G is a bidirected graph with orientable vertices, and there exists a vertex-orientation assignment for G resulting in a subgraph containing at least k directed edges} Depending on whether the preferred bias is toward more evidence or more edges, the weighted and unweighted versions of this problem (respectively) become important. In the following equivalence proof of the MAX-DIR and MAX-CUT decision problems, we will consider the unweighted version and assume that the weighted</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Proof of equivalence with MAX-CUT</head><p>The proof that MAX-DIR is NP-complete is useful because it signals that a heuristic will likely be required to solve an instance of the contig orientation problem (i.e. the MAX-DIR problem) on any reasonably large input. Because MAX-CUT is NP-complete and MAXDIR 2 NP, it follows immediately that MAX-DIR P m MAX-CUT. The many-one equivalence in polynomial time is useful because it allows us to reduce any MAX-DIR problem to a MAX-CUT problem and then solve it using existing MAX-CUT heuristics (see Supplementary Materials for details of reduction). Thus, rather than 'reinventing the wheel' to solve instances of the MAX-DIR problem, one could reasonably apply existing MAX-CUT heuristics to obtain MAX-DIR solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2.1">MAX-DIR is NP-complete</head><p>Proof:To prove this statement, we must demonstrate that 1. MAX-DIR 2 NP and 2. 8L 2 NP, L P m MAX-DIR.</p><p>We prove that MAX-DIR is in NP by noting that given a vertexorientation assignment to a bidirected graph with orientable vertices and an integer k, we can check in polynomial time whether the assignment yields k directed edges. To prove that 8L 2 NP, L P m MAX-DIR, we must show that some other NP-complete problem is many-one reducible in polynomial time to MAX-DIR. We demonstrate that MAX-CUT has such a reduction to MAX-DIR. Recall that the decision problem corresponding to the MAXCUT problem is as follows:</p><p>MAX À CUT ¼ fðM; kÞ j M is a multigraph with a cut of size kg where a multigraph M ¼ (V,E) is a graph allowing multiple edges between two nodes and a cut in a graph is a partition of V into two distinct subsets S and T. The size of the cut is the number of edges e 2 E which have an endpoint in S and an endpoint in T. We will describe a polynomial-time-bounded construction that maps an instance (M,k) of MAX-CUT to some bidirected graph with orientable vertices G and positive integer k such that M has a cut of size at least k if and only if G has a vertex-orientation assignment yielding k directed edges. Let V and E be the vertex and edge sets of M and let V 0 and E 0 be the vertex and edge sets of G which<ref type="figure" target="#fig_1">Fig. 2</ref>. An instance of the MAX-CUT problem shown with the reduction to MAX-DIR<ref type="figure">Fig. 3.</ref>A possible cut of the graph in<ref type="figure" target="#fig_1">Figure 2a</ref>and the corresponding vertexorientation assignment for the bidirected graph in<ref type="figure" target="#fig_1">Figure 2b</ref>. Both the weight of the cut and the sum weight of the directed edges are the same. In the subgraph of nodes and directed edges resulting from the vertex-orientation assignment, each contig in any valid walk will be consistently oriented ScaffoldScaffolderwe will create. The construction of G from M consists of the following steps (<ref type="figure" target="#fig_1">Fig. 2):</ref>1. Let V 0 ¼ V. 2. For each edge e 2 E linking vertices v i ,v j 2 V, we create a bidirected edge e 0 linking v i 0 and v j 0 (in V 0 ) where e is negativeincident to both v i 0 and v j 0 .</p><p>Clearly the construction takes polynomial time. First we show that if M has a cut of size k, then G has a vertexorientation assignment yielding k directed edges (<ref type="figure">Fig. 3</ref>). If M has a cut of size k, then there is a partition of V into two distinct subsets S and T such that there are k edges which have an endpoint in S and an endpoint in T. By partitioning V 0 into the same subsets, S and T, and assigning forward-orientation to all vertices in S and reverseorientation to all vertices in T, k bidirected edges (those analogous to the cut edges of M) are rendered directed edges. All others remain either introverted or extraverted edges. It follows from the same line of reasoning that if G has a vertex-orientation assignment yielding k directed edges, then M has a cut of size k. This completes the proof that MAX-DIR is NP-complete.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Systems and methods</head><p>Results were collected for nine different algorithms on six different datasets using multiple assessment criteria. Though several published scaffolding algorithms address the contig orientation problem (<ref type="bibr" target="#b10">Donmez and Brudno, 2013;</ref><ref type="bibr" target="#b25">Pop et al., 2004</ref>), none provide sufficient metadata to easily recover their exact contig orientation solution. We thus measure the relative performance of two novel MAX-DIR heuristics (Greedy and RandEdge) and seven other MAX-CUT heuristics as applied to instances of the contig orientation problem: 1. Greedy: Our novel greedy heuristic (see Algorithm 1). 2. RandEdge: Considers edges in a random order and greedily assigns an orientation to adjacent contigs that is consistent with previous orientation assignments (similar to Algorithm 1 except edge e at line 5 is random). 3. BiqMac: A Branch-and-Bound heuristic algorithm for solving weighted MAX-CUT problems which uses SDP relaxation and a relative bound precision criterion (<ref type="bibr" target="#b26">Rendl et al., 2010</ref>). 4. LPSolve: lp_solve, a mixed integer linear programming heuristic used by MIP Scaffolder (<ref type="bibr" target="#b29">Salmela et al., 2011</ref>). 5. SCIP: A linear-optimization Branch-and-Bound MAX-CUT solver (<ref type="bibr" target="#b0">Achterberg, 2007</ref>). 6. GLPK: GNU Linear Programming Kit, a linear/mixed integer programming solver (<ref type="bibr" target="#b18">Makhorin, 2001</ref>). 7. SDP: A dual-scaling interior-point algorithm for solving sparse semidefinite MAX-CUT programs (<ref type="bibr" target="#b5">Benson et al., 2000</ref>). 8. Sahni: A 1/2-approximation algorithm for MAX-CUT, which adds vertices in random order to maximize the weight of the cut (<ref type="bibr" target="#b28">Sahni and Gonzalez, 1976</ref>). 9. Random: randomly orients contigs, retaining edges consistent with assigned orientations (averaged over ten iterations).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1. MAX-DIR GREEDY HEURISTIC</head><p>Input: Weighted bidirected graph, G, and min edge weight, w min 1: Create a forest, F 2: For each vertex v i 2 G, add tree t i to F containing v i 3: Create a set S of all edges in G with weight w e &gt; w min 4: while S is not empty do 5: Remove an edge e with maximum weight from S 6: if e connects two different trees, t 1 and t 2 , then 7: add e to F, combining t 1 and t 2 into one tree 8: if e is not a directed edge then 9: for all vertices v 2 in t 2 do 10: Flip orientation assignment of v 2 11: else if e is a directed edge then 12: add e to F 13: else 14: discard e 15: return F, a weighted directed subgraph</p><p>The algorithms were assessed on six scaffold graphs: two synthetic genome scaffold graphs and four real scaffold graphs (see Supplementary Material for details). ScaffoldScaffolder (<ref type="bibr" target="#b6">Bodily et al., 2012</ref>) was used to generate scaffold graphs.Solutions were assessed on five metrics: the total count of edges retained; the total weight of edges retained; the total count of edges excluded; the total weight of edges excluded and (for real datasets) the computation time required. A contig orientation solution does not produce linear scaffolds. Thus, our evaluative metrics do not include typical scaffold evaluation metrics such as scaffold N50.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Algorithm</head><p>We developed a greedy heuristic algorithm to solve the weighted MAX-DIR problem (see Algorithm 1). As a heavier-weighted edge generally reflects greater confidence for the scaffolding which it represents, such an edge is likely to be valid, and therefore included in the optimal solution. Thus a greedy algorithm, which maximally favors heavier-weighted edges, approximates an ideal solution for the contig orientation problem. This algorithm starts by making each vertex in the graph its own tree and then adds edges which combine distinct trees to form larger trees. In combining trees t i and t j via edge e, we flip vertex orientations for all vertices in t j when needed, so that e is always directed. Edges are considered in order of decreasing weight. Any edge e linking vertices v i and v j within the same tree t i is added if and only if, given the current vertex-orientation assignment of v i and v j in t i , e is a directed edge. Additionally, we define a minimum edge weight threshold, w min , to avoid the risk of determining contig orientation based on erroneous edges with very low support. We ensure that the final subgraph contains solely directed edges by only adding directed edges and ensuring that directed edges remain directed as a result of vertex orientation changes. In cases where two conflicting edges have significant but marginally different weights, there is the danger of discarding biologically significant information. Such cases represent violations of the single-orientation assumption. We consider two such scenarios and their implications below in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head><p>A summary of the total retained edge weight and edge count is shown in<ref type="figure" target="#fig_3">Figure 4a</ref>and b, respectively (complete results are available in Supplementary Material). In the synthetic genome graphs, the Greedy and RandEdge algorithms performed best of the compared solutions. The Greedy heuristic retained the greatest number of edges and the greatest total edge weight. We believe that the superior performance of the Greedy and RandEdge algorithms is because these algorithms are designed to greedily include each edge as it is considered, without any concern for solutions that are excluded by its inclusion. Heuristic algorithms generally employ a heuristic function to determine (with some degree of caution) whether or not to include any given edge. In a scaffold graph, the greedy addition of edges (whether considered randomly or ordered by weight) often performs well because most edges are valid and should be included. Therefore, the majority of the supportive evidence should be internally consistent with relatively few spurious edges requiring exclusion. In many real-world instances of NP-complete problems, the trivial solution is often the wrong solution, thus creating a need for more complex heuristics which bypass the trivial solution. A scaffold graph is quite sparse (i.e. average in-and out-edge degrees are between 1 and 2) and linear by nature, thus rendering the contig orientation problem far more simple than would require a complex heuristic solution. In such a graph, a local optimum will often be part of the global optimum. This serves as a reminder that simply because the complexity of a biological problem can be classified by theoretical computer science does not imply that existing solutions for that class of problem are well-suited to the particular biological application. Domain-specific knowledge is critical to developing algorithms that will work faster and better than existing heuristics. The Greedy algorithm also outperformed the other algorithms in the scaffold graphs from real datasets. In the raspberry genome graph, the Greedy algorithm retained 17% more total edge weight than the next best algorithm (BiqMac). Likewise in the strawberry, oyster and human graphs, the Greedy algorithm reported margins of 6% and 7%, respectively, above competitors. On the real datasets, the RandEdge algorithm retained between 13% and 16% less overall weight than the Greedy approach. Despite its average performance, RandEdge is notably faster than algorithms with similar results (see Supplementary Material). The discrepancy between the Greedy and RandEdge algorithms on real data is largely explained by Figures 4b and 5. The relative decrease in edge weight retention by RandEdge is mirrored in a relative decrease in the number of edges retained. We also find that RandEdge is generally including lighter edges and conversely excluding heavier ones than the Greedy algorithm is. Thus biasing toward the heavy edges not only results in more weight retained but also inthat the heavy edges are more likely to represent the set of internally consistent edges in the scaffold graph.<ref type="figure">Figure 5</ref>also confirms that the greedy algorithm is correctly removing the erroneous edges. Regardless of the overall average weight (i.e. sequencing depth) for a real dataset, the weights of spurious edges tend to maintain a consistent distribution clustered close to 0. The average weights of included and excluded edges, however, vary as a function of the overall average edge weight per dataset. Thus, the penalty for adding erroneous edges in place of valid edges grows larger with an increase in overall average edge weight. (Note in<ref type="figure" target="#fig_3">Fig. 4a</ref>that though the average retained edge weight increases as a function of the overall edge weight average per dataset, it is most largely affected by the choice of algorithm.) The superior performance of the greedy heuristic algorithm is thus likely due to this key observation about the nature of scaffold graphs—heavily weighted retained edges not only contribute more to total edge support than do lowly weighted edges; they are more likely to be part of the optimal solution. The greedy algorithm thus maximally favors edges which are likely to belong in the optimal solution, which helps to explain why it retains far more edge weight (and many more edges) than other solutions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>We noted a peculiarity in the subgraph produced using our Greedy heuristic on the synthetic genome without errors—the two excluded edges were both adjacent to contig 591. We also noted that contig 591 has an average sequence depth (a value indicative of the number of nucleotides contributing to the assembly at a given locus) of roughly twice the normal diploid depth, making it a likely candidate for being a two-copy repeat. We used BLAST (<ref type="bibr" target="#b2">Altschul et al., 1997</ref>) to find where contig 591 aligned to the known reference. We discovered that it aligned perfectly at two locations and that the two matching sequences were inversions (see Supplementary Material). This case illustrates that if repeats are not screened, they can present exceptions to the contig-orientation problem and more specifically to the single-orientation assumption. The single-orientation assumption will hold only if the contig represents a sequence which repeats in the same orientation in a scaffold (e.g. tandem repeats). Inverted repeats, like contig 591, represent identical sequences with opposite orientations from two distinct places in a scaffold (<ref type="figure">Fig. 6a</ref>). Among their several biological roles, inverted repeats are used to detect the boundaries of transposons (<ref type="bibr" target="#b27">Rio and Rubin, 1988</ref>) and are instrumental in transcriptional regulation (<ref type="bibr" target="#b21">Muskens et al., 2000</ref>). Assigning a single orientation to such a contig prevents a viable scaffold reconstruction from occurring, prematurely fragmenting the assembly. This scenario can be resolved prior to assigning contigorientations by special handling or screening of repeat contigs (<ref type="bibr" target="#b16">Li et al., 2010;</ref><ref type="bibr" target="#b25">Pop et al., 2004</ref>). This example shows that in addition to removing erroneous linkages from a scaffold graph, the contig orientation assignment will remove any viable biological scenario that is an exception to the single-orientation assumption. Thus, if the erroneous linkages can be filtered via other means (e.g. minimum support threshold and next-generation error correction), the contig orientation assignment can be used to identify (via exclusion) biologically viable exceptions to the single-orientation assumption. One other such exception is the case of inverted haplotypes. Many genomes exist as diploid or polyploid organisms, meaning there are two or more versions (termed haplotypes) of the genome in each cell. An inverted haplotype is a sequence, which is identical but oppositely oriented at corresponding locations on analogous chromosomes (<ref type="figure">Fig. 6b</ref>). Such inversions are often biologically significant and have been specifically shown to be associated at times with mental retardation, microdeletion syndrome, renal cysts and diabetes syndrome, epilepsy, schizophrenia and autism (<ref type="bibr" target="#b3">Antonacci et al., 2009;</ref><ref type="bibr" target="#b31">Zody et al., 2008</ref>). Most assembly algorithms have not been specifically designed for diploid genome assembly and assume that where multiple haplotypes do exist, they can be readily merged to form a single 'reference' sequence. In doing so, inverted haplotype differences are metaphorically 'swept under the rug', which is perhaps why biologists have lamented that 'unlike other types of structural variation, little is known about inversion variants within normal individuals because such events are typically balanced and are difficult to detect and analyze by standard molecular approaches' (<ref type="bibr" target="#b3">Antonacci et al., 2009</ref>). Just as a contig orientation solution is able to identify inverted repeats, it is also able to identify inverted haplotypes. We developed a module in ScaffoldScaffolder to automatically generate a detailed report of potential inverted repeats and inverted haplotypes. In the module, candidates are internally identified as any contig (i) having at least two connecting edges from at least one end and (ii) which is connected to two or more excluded edges. The candidates can be classified as inverted repeats or inverted haplotypes based on the location of each candidate contig in a probability density function of contig coverage. A special case is a monocontig inversion candidate, which requires that each of two adjacent contigs be linked via edges from both ends of the candidate. We tested our new predictive module on both synthetic and real data. We first synthesized a diploid genome (heterozygosity rate % 0.2%) containing an inverted haplotype from the zebra finch chromosome 25. We generated error-free reads for assembly with Newbler, and a graph was created using ScaffoldScaffolder. Using our greedy heuristic algorithm, we assigned orientations to the contigs which resulted in a subgraph which excluded 12 edges. The<ref type="figure">Fig. 5</ref>. Average weight of included/excluded edges. Although the average weights of included/excluded edges vary as a function of the overall average edge weight, the weight of edges excluded by the Greedy algorithm remains close to 0. This suggests that the Greedy algorithm is excluding primarily erroneous edges<ref type="figure">Fig. 6</ref>. Violations of the single-orientation assumption. (a) In an inverted repeat, a sequence (contig A) is included in the reconstruction twice in opposite orientations. (b) In a polyploid genome, an inverted haplotype is a sequence (contig B) included in opposite orientations on different haplotypes potential inversion report listed three inversions (two with sequencing depth to suggest inverted repeats). We verified that all three inversions were accurate using BLAST and verified that the (nonrepeat) inverted haplotype aligned at the expected location in the reference haplotype sequences (see Supplementary Material). To confirm our ability to predict inverted haplotypes in real data, we identified a 18.7 kb inverted haplotype (HsInv0393) from the Human Polymorphic Inversion DataBase (Martínez<ref type="bibr" target="#b19">Fundichely et al., 2014</ref>) that has been found to be heterozygous in human HapMap individual NA19240 (<ref type="bibr" target="#b1">Aguado et al., 2014</ref>). From this individual, we assembled paired Illumina reads mapping to a 64 kb segment of chromosome X in the region of HsInv0393. We created a small graph of the assembled region with ScaffoldScaffolder using the same paired reads. The greedy heuristic algorithm assigned contig orientations, excluding two well-supported edges. The algorithm identified a 9.4 kb inversion, contig 3, that when mapped to the hg19 reference aligned in the region defined for HsInv0393. In addition, the two 4.65 kb contigs scaffolded on either side of this inversion (contigs 2 and 4) were also identified as inverted repeats. This arrangement in the scaffold graph (summarized in<ref type="figure" target="#fig_4">Fig. 7</ref>) suggests not only that contig 3 is inverted but that possibly some or all of contigs 2 and 4 are also part of the inversion (hence why many inversion breakpoints are reported as ranges). We observe that distinguishing between an inverted haplotype and a non-inverted sequence flanked by inverted repeats is impossible by this approach without pairs that span beyond the inverted repeats (which in the case of NA19240 were unavailable). Ongoing development and testing will help to assess the efficacy of this inversion detection method on a larger scale. However, both the theory and our small tests confirm that edges which are excluded in solving the contig orientation problem are suggestive of inverted repeats and inverted haplotypes in de novo assemblies, particularly when such sequences are adjacent to multiple or heavily supported excluded edges. The contig orientation problem, which we have formally framed as the MAX-DIR problem, has at times been addressed (somewhat apologetically) only cursorily and at times using various heuristics. In setting forth a linear-time reduction from the MAX-CUT problem to the MAX-DIR problem, we have proven that the latter is NPcomplete. We have compared the relative performance of our novel greedy approach with several other heuristic solutions. Our results suggest that the greedy heuristic algorithm not only works well, but outperforms the other algorithms due to the nature of scaffold graphs. In such graphs, heavier-weighted edges are more likely to be valid and therefore included in the optimal solution. A greedy algorithm, which maximally favors such edges, approximates an ideal solution. One unanticipated outcome of this study has been the discovery of a novel method for identifying inverted repeats and inversion variants, both of which contradict the basic single-orientation assumption. Such inversions have previously been noted as being difficult to detect and are directly involved in the genetic mechanisms of several diseases.</p><p>Thus, this method, which we have implemented as a module of ScaffoldScaffolder, has the potential to assist in the automated discovery of biologically significant features in de novo genome assembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This research was supported in part by NIH grant R01 HG005692. Conflict of Interest: none declared.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Walks in bidirected graphs. (a) A valid walk enters and exits a node through opposite edge-orientations. (b) An invalid walk enters and exits a node through identical edge-orientations. (c) Reversing all edge-orientations adjacent to a node results in the same valid and invalid walks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. Fig. 2. An instance of the MAX-CUT problem shown with the reduction to MAX-DIR</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1.</head><figDesc>Synthetic Genome (w/o Errors): A 1.25 Mb diploid genome was synthesized from the zebra finch using HapMaker (Okuda et al., 2013). The following were generated using ART v1.3.1 (Huang et al., 2012): a set of 250 bp reads; a 4 kb paired-end library and a 20 kb paired-end library. Newbler 2.6 was used to assemble contigs. Only 4 kb libraries were used in scaffolding. 2. Synthetic Genome (w/ Errors): Using the 1.25 Mb genome reference, a 200-bp paired-read library was generated from ART. Contig assembly was performed using Newbler. 3. Raspberry Genome: Contigs for the Rubus idaeus cultivar heritage genome were assembled by Newbler using reads from a combination of Illumina HiSeq and 454 sequencing technologies. HiSeq reads were used for scaffolding. 4. Strawberry Genome: Contigs were assembled for Fragaria vesca using Newbler on eleven 454 runs. Two 3-kb paired-end libraries were used to scaffold. 5. Oyster Genome: Contigs for the Pacific oyster Crassostrea gigas were assembled using SOAPdenovo2 (Luo et al., 2012). Paired Illumina reads from 170 bp inserts were used to scaffold. 6. Human Genome: Contigs for HapMap individual NA19240 chromosome X were assembled using SOAPdenovo2. Paired Illumina reads from 550 bp inserts were used to scaffold.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.4.</head><figDesc>Fig. 4. Comparative performance of weighted MAX-DIR solutions. In all graphs, the greedy algorithm retained the most total edge support. In general the Greedy algorithm also retained the most edges. The second chart also demonstrates that the RandEdge algorithm's failure to retain as much total weight as the Greedy algorithm on the real datasets comes (at least in part) as a result of retaining fewer edges. Missing data reflects a failure of the particular algorithm to provide a valid solution for the given dataset</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.7.</head><figDesc>Fig. 7. Scaffold graph of heterozygous HsInv0393 inversion in NA19240. Black arrows are contigs, pointing 5 0 –3 0. Solid lines are putative scaffoldings weighted by paired evidence. Dotted lines are scaffoldings which were excluded by the greedy heuristic. Contig 3 is a potential inversion. Because contigs 2 and 4 are inverted repeats, the exact breakpoints of an inverted haplotype are undetectable</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>V C The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 17 Bioinformatics, 32(1), 2016, 17–24 doi: 10.1093/bioinformatics/btv548 Advance Access Publication Date: 17 September 2015 Original Paper</figDesc><table></table></figure>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">P.M.Bodily et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<monogr>
		<title level="m" type="main">Constraint Integer Programming. Citeseer</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Achterberg</surname>
			</persName>
		</author>
		<author>
			<persName>
				<surname>Tu Berlin</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2007-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Validation and genotyping of multiple human polymorphic inversions mediated by inverted repeats reveals a high degree of recurrence</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Aguado</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">1004208</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="3389" to="3402" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Characterization of six human disease-associated inversion polymorphisms</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Antonacci</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Hum. Mol. Genet</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="2555" to="2566" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">ARACHNE: a whole-genome shotgun assembler</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Batzoglou</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="177" to="189" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Solving large-scale sparse semidefinite programs for combinatorial optimization</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">J</forename>
				<surname>Benson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Optimization</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="443" to="461" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">ScaffoldScaffolder: an aggressive scaffold finishing algorithm</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">M</forename>
				<surname>Bodily</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 International Conference on Bioinformatics &amp; Computational Biology</title>
		<editor>Arabnia,H.R. and Tran,Q.-N.</editor>
		<meeting>the 2012 International Conference on Bioinformatics &amp; Computational Biology<address><addrLine>Las Vegas, Nevada, USA</addrLine></address></meeting>
		<imprint>
			<publisher>CSREA Press</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="385" to="390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">ALLPATHS: de novo assembly of whole-genome shotgun microreads</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Butler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="810" to="820" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">SOPRA: scaffolding algorithm for paired reads via statistical optimization</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Dayarian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">345</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">A min-max cut algorithm for graph partitioning and data clustering</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">H</forename>
				<surname>Ding</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE International Conference on Data Mining</title>
		<editor>Cercone,N. et al.</editor>
		<meeting>the IEEE International Conference on Data Mining<address><addrLine>Los Alamitos, CA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">SCARPA: scaffolding reads with practical algorithms</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Donmez</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Brudno</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="428" to="434" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<monogr>
		<title level="m" type="main">Matching: a well-solved class of integer linear programs</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Edmonds</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">L</forename>
				<surname>Johnson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1970" />
			<publisher>Combinatorial Structures and Their Applications. Citeseer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">879-approximation algorithms for MAX CUT and MAX 2SAT</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">X</forename>
				<surname>Goemans</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">P</forename>
				<surname>Williamson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Sixth Annual ACM Symposium on Theory of Computing</title>
		<meeting>the Twenty-Sixth Annual ACM Symposium on Theory of Computing<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1994" />
			<biblScope unit="page" from="422" to="431" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">ART: a next-generation sequencing read simulator</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Huang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="593" to="594" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Parallel construction of bidirected string graphs for genome assembly</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">G</forename>
				<surname>Jackson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Aluru</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Thirty-Seventh International Conference on Parallel Processing</title>
		<meeting>the Thirty-Seventh International Conference on Parallel Processing<address><addrLine>Portland, OR, USA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="346" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Optimal inapproximability results for MAX-CUT and other 2-variable CSPs?</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Khot</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="319" to="357" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<monogr>
		<title level="m" type="main">SOAPdenovo2: an empirically improved memory-efficient short-read de novo assembler</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Luo</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">GNU linear programming kit</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Makhorin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Moscow Aviation Institute</title>
		<imprint>
			<biblScope unit="page">38</biblScope>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Invfest, a database integrating information of polymorphic inversions in the human genome</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Martínez-Fundichely</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="1027" to="1032" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Computability of models for sequence assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In: Algorithms in Bioinformatics</title>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="289" to="301" />
			<date type="published" when="2007" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Role of inverted DNA repeats in transcriptional and post-transcriptional gene silencing</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">W M</forename>
				<surname>Muskens</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Plant Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="243" to="260" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">The fragment assembly string graph</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="79" to="85" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Suppl</note>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Integrating genome assemblies with MAIA</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Nijkamp</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="433" to="439" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">HapMaker: synthetic haplotype generator</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Okuda</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2013 International Conference on Bioinformatics &amp; Computational Biology</title>
		<editor>Arabnia,H.R. and Tran,Q.-N.</editor>
		<meeting>the 2013 International Conference on Bioinformatics &amp; Computational Biology<address><addrLine>Las Vegas, Nevada, USA</addrLine></address></meeting>
		<imprint>
			<publisher>CSREA Press</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="370" to="374" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Hierarchical scaffolding with Bambus</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="149" to="159" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Solving Max-Cut to optimality by intersecting semidefinite and polyhedral relaxations</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Rendl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Program</title>
		<imprint>
			<biblScope unit="volume">121</biblScope>
			<biblScope unit="page" from="307" to="335" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Identification and purification of a Drosophila protein that binds to the terminal 31-base-pair inverted repeats of the P transposable element</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">C</forename>
				<surname>Rio</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">M</forename>
				<surname>Rubin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="8929" to="8933" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">P-complete approximation problems</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Sahni</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Gonzalez</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="555" to="565" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Fast scaffolding with small independent mixed integer programs</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Salmela</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="3259" to="3265" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using De Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">Evolutionary toggling of the MAPT 17q21. 31 inversion region</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">C</forename>
				<surname>Zody</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="1076" to="1083" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>