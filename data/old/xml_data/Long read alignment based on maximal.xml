
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:30+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Long read alignment based on maximal exact match seeds</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Yongchao</forename>
								<surname>Liu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Institut für Informatik</orgName>
								<orgName type="institution">Johannes Gutenberg Universität Mainz</orgName>
								<address>
									<postCode>55099</postCode>
									<settlement>Mainz</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName>
								<forename type="first">Bertil</forename>
								<surname>Schmidt</surname>
							</persName>
							<email>bertil.schmidt@uni-mainz.de</email>
							<affiliation key="aff0">
								<orgName type="department">Institut für Informatik</orgName>
								<orgName type="institution">Johannes Gutenberg Universität Mainz</orgName>
								<address>
									<postCode>55099</postCode>
									<settlement>Mainz</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Long read alignment based on maximal exact match seeds</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="318" to="324"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts414</idno>
					<note>Copyedited by: MANUSCRIPT CATEGORY: [16:41 9/8/2012 Bioinformatics-bts414.tex] Page: i318 i318–i324 BIOINFORMATICS Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: The explosive growth of next-generation sequencing datasets poses a challenge to the mapping of reads to reference genomes in terms of alignment quality and execution speed. With the continuing progress of high-throughput sequencing technologies, read length is constantly increasing and many existing aligners are becoming inefficient as generated reads grow larger. Results: We present CUSHAW2, a parallelized, accurate, and memory-efficient long read aligner. Our aligner is based on the seed-and-extend approach and uses maximal exact matches as seeds to find gapped alignments. We have evaluated and compared CUSHAW2 to the three other long read aligners BWA-SW, Bowtie2 and GASSST, by aligning simulated and real datasets to the human genome. The performance evaluation shows that CUSHAW2 is consistently among the highest-ranked aligners in terms of alignment quality for both single-end and paired-end alignment, while demonstrating highly competitive speed. Furthermore, our aligner shows good parallel scalability with respect to the number of CPU threads. Availability: CUSHAW2, written in C++, and all simulated datasets are available at http://</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Many biological applications of next-generation sequencing (NGS) require the alignment of large quantities of produced reads to a given reference genome. Consequently, a wide variety of short read aligners have been developed in recent years. They can be classified into two categories according to their approaches to identify seeds: hash tables and prefix/suffix tries. MAQ (), SOAP (), SHRiMP (<ref type="bibr" target="#b37">Rumble et al., 2009</ref>) and BFAST (<ref type="bibr" target="#b19">Homer et al., 2009</ref>) are examples of the hash table approach. Bowtie (<ref type="bibr" target="#b22">Langmead et al., 2009</ref>), BWA (<ref type="bibr" target="#b24">Li and Durbin, 2009</ref>), SOAP2 (<ref type="bibr" target="#b24">Li et al., 2009</ref>) and CUSHAW (<ref type="bibr" target="#b30">Liu et al., 2012</ref>) implement the concept of prefix/suffix tries using the Burrows–Wheeler transform (BWT) (<ref type="bibr">Burrows and Wheeler, 1994</ref>) and the FM-index (<ref type="bibr" target="#b17">Ferragina and Manzini, 2005</ref>). With the progress of NGS technologies, the length of produced reads continues to increase. Unfortunately, many existing short read aligners are becoming inefficient as generated reads grow to a few hundred bp in length because of two reasons. First, they typically perform only ungapped alignments or gapped alignments allowing a very limited number of gaps (typically one gap). Second, their speed degrades rapidly as the number of gaps increases. However, for long read alignment, more gaps must be allowed as indels will * To whom correspondence should be addressed. occur more frequently. These new features of long read alignment thus motivate the design of new aligners with fast speed and high quality. In this article, we devise a new long read aligner based on the well-known seed-and-extend heuristic. This heuristic is based on the observation that significant alignments are likely to include homologous regions, containing exact or inexact short matches between the two sequences. It generally works in three steps. First, seeds, represented as short matches indicating highly similar regions, are generated between the query and the target sequences. Secondly, these seeds are extended and refined under certain constraints, such as minimal percentage identity and extension length, to filter out noisy seeds. Finally, more sophisticated algorithms, such as the Needleman–Wunsch algorithm (<ref type="bibr" target="#b32">Needleman and Wunsch, 1970</ref>) or the Smith–Waterman (SW) algorithm (<ref type="bibr" target="#b38">Smith and Waterman, 1991</ref>), are employed to obtain the final alignments. Several types of seeds have been proposed, including fixed-length seeds, maximal exact matches (MEMs), maximal unique matches (MUMs), and adaptive seeds (<ref type="bibr">Kielbasa et al., 2011</ref>). Fixed-length seeds (k-mers) are the most widely used seed type. The simplest fixed-length seed is the exact k-mer match. Some improvements have been suggested by allowing mismatches and gaps in the k-mers, including spaced seeds (<ref type="bibr" target="#b31">Ma et al., 2002</ref>), and q-gram (a substring of q bases) filters (<ref type="bibr" target="#b34">Rasmussen et al., 2006</ref>). MEMs are exact matches that cannot be extended in either direction without allowing a mismatch. MUMs are inherently MEMs but require uniqueness in addition. An adaptive seed has a variable seed length, and also has a limitation on the number of seed occurrences in the target. Recently, several long read aligners have been developed based on the seed-and-extend approach, including BWA-SW (<ref type="bibr" target="#b25">Li and Durbin, 2010</ref>), Bowtie2 (<ref type="bibr" target="#b23">Langmead and Salzberg, 2012</ref>), and GASSST (<ref type="bibr" target="#b35">Rizk and Lavenier, 2010</ref>). BWA-SW, inspired by BWT-SW (<ref type="bibr" target="#b21">Lam et al., 2008</ref>), identifies long gapped seeds by employing a prefix directed acyclic word graph (implicitly represented by an FM-index) to perform dynamic programming (DP). Subsequently, it heuristically extends and refines the long gapped seeds to produce the final alignments. Bowtie2 extracts all mismatch-allowable fixed-length seeds from a read using the BWT and then employs DP to identity alignments. GASSST employs hash tables to find fixed-length seeds and employs multiple filters to remove noisy seeds, prior to the final DP-based alignment. This approach is effective to significantly reduce the number of noisy seeds, but also has the risk of discarding correct ones. In this article, we present a new long read aligner using MEMs as seeds. MEMs have been used for whole genome alignment (<ref type="bibr" target="#b14">Bray et al., 2003;</ref><ref type="bibr" target="#b15">Choi et al., 2005;</ref><ref type="bibr" target="#b16">Delcher et al., 1999;</ref><ref type="bibr" target="#b18">Höhl et al., 2002</ref>). However, to the best of our knowledge, MEMs have not been used for NGS read alignment. Our aligner employs memoryefficient versions of the BWT and FM-index data structures to generate MEM seeds for each read. Each seed defines a potential mapping read region on the genome. We then compute the optimal<ref type="figure">Fig. 1</ref>. Pipeline of our aligner for the SE and the PE alignment: the dashed lines show the additional two stages for the PE alignment local alignment score between the read and each potential mapping region and select the highest-scoring mapping region to produce the final alignment. In addition, our aligner provides support for paired-end (PE) alignment. For the PE alignment, a new seed-pairing approach is introduced with the intention to quickly determine the potential mapping regions of a PE read pair without performing alignments. Furthermore, we employ vectorization and multithreading to achieve fast execution speed on standard multi-core CPUs. The performance of our aligner is assessed and compared with BWA-SW, Bowtie2 and GASSST, by aligning simulated and real datasets to the human genome. The experimental results show that our aligner achieves favorable alignment quality, highly competitive speed and good parallel scalability with respect to the number of threads. This new aligner has been integrated into our software package CUSHAW. The first version of CUSHAW was designed for short read alignment (128-bp reads) using GPU computing. It uses mismatch-allowable fixed-length seeds and does not provide support for gapped alignments. We name the aligner presented in this article, CUSHAW2, to indicate the extended functionality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Long read alignment based on maximal exact match seeds</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>CUSHAW2 employs MEMs as seeds to compute a gapped alignment for a long read to a given reference genome. For the single-end (SE) alignment, CUSHAW2 works in three stages: (i) generate MEM seeds, (ii) select the best mapping regions on the genome and (iii) produce and report the final alignments. For the PE alignment, we introduce two additional stages before producing the final alignments: one is the seed pairing stage and the other is the read rescuing stage.<ref type="figure">Figure 1</ref>illustrates the pipelines of our aligner for both the SE and the PE alignment.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Essentials for maximal exact match identification</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Definitions and notations</head><p>Given a sequence S, define |S| to denote the length of S, S<ref type="bibr">[i]</ref>to denote the character at position i and S<ref type="bibr">[i,j]</ref>to denote the substring of S starting at position i and ending at position j, for 0 i &lt; |S| and 0 j &lt; |S|. We represent an exact match between two sequences S 1 and S 2 as a triplet (p, q, k), where k is the length of the exact match and the substring S 1<ref type="bibr">[p, p+k− 1]</ref>is identical to the substring S 2<ref type="bibr">[q, q+k− 1]</ref>. An exact match is called right maximal if p+ 1 = |S 1 | or q+ 1 = |S 2 | or S 1<ref type="bibr">[p+k]</ref>= S 2<ref type="bibr">[q+k]</ref>, and left maximal if p= 0 or q= 0 or S 1<ref type="bibr">[p− 1]</ref>= S 2<ref type="bibr">[q− 1]</ref>. An exact match is called a MEM if it is both left maximal and right maximal. Given a sequence T , defined over the alphabet = {A, C, G, T}, the suffix array SA of T stores the starting positions of all suffixes of T in lexicographical order. In other words, SA<ref type="bibr">[i]</ref>= j means that the ith lexicographically smallest suffix (among all suffixes of T ) starts at position j in T. The SA of T has an overall memory footprint of |T | log 2 |T | bits (∼12 GB for the human genome). Given a substring S of T , we can find all its occurrences within an SA interval. An SA interval is an index range [I a , I b ], where I a and I b represent the indices in SA of the lexicographically smallest and largest suffixes of T with S as a prefix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">BWT and FM-index</head><p>The BWT of T starts from the construction of a conceptual matrix M T , whose rows are all cyclic rotations of a new sequence T $ sorted in lexicographical order. T $ is formed by appending the special character $ to the end of T that is lexicographically smaller than any character in. After getting M T , the last column of the matrix is taken to form the transformed text B T , i.e. the BWT of T. B T is a permutation of T and thus occupies the same memory size of |T | log 2 || bits as T. M T has a property called 'last-to-first column mapping', which means that the ith occurrence of a character in the last column corresponds to the ith occurrence of the same character in the first column. The FM-index consists of a vector C(@BULLET) and an occurrence array Occ(@BULLET), constructed from B T , to accomplish substring search. C(@BULLET) contains || elements with each element C(a) representing the number of characters in T that are lexicographically smaller than a ∈. Occ(@BULLET) is an array of size |T |×|| with each element Occ(a, i) representing the number of occurrences of a ∈ in B T<ref type="bibr">[0,i]</ref>. In terms of memory overhead, C(@BULLET) requires only|| log 2 || bits but Occ(@BULLET) requires|||T | log 2 |T | bits. Given a substring S of T , the SA interval of all its occurrences can be computed in O(|S|) time using a backward search procedure. Based on C(@BULLET) and Occ(@BULLET), the SA interval<ref type="bibr">[I a , I b ]</ref>can be recursively calculated, from the rightmost to the leftmost suffixes of S, as: I a (i) = C(S<ref type="bibr">[i]</ref>)+Occ(S<ref type="bibr">[i]</ref>,I a (i +1)−1)+1, 0 i &lt; |S| I b (i) = C(S<ref type="bibr">[i]</ref>)+Occ(S<ref type="bibr">[i]</ref>,I b (i +1)), 0 i &lt; |S|</p><formula>(1)</formula><p>where I a (i) and I b (i) represent the starting and end indices of the SA interval for the suffix of S starting at position i, and I a (|S|) and I b (|S|) are initialized as 0 and |T |, respectively. The calculation stops if it encounters I a (i+ 1)&gt; I b (i+ 1). The condition I a (i) I b (i) holds if and only if the suffix of S starting at position i is a substring of T. The total number of the occurrences is</p><formula>calculated as I a (0)-I b (0) + 1 if I a (0) I b (0)</formula><p>, and 0, otherwise. After getting the SA interval, the location of each occurrence can be determined by directly looking up SA with a constant time complexity. Hence, the time complexity for finding n occurrences of S isO(|S|+n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.3">Reducing memory overhead From Equation</head><p>(1), the substring search using the FM-index does not require B T , meaning that the overall memory footprint is the memory sum of the FM-index and SA. This memory overhead (∼60 GB for the human genome) can be reduced by an order of magnitude by taking advantage of some features of the BWT at the cost of a slightly higher substring search time complexity as follows. For the FM-index, Occ(@BULLET) dominates the overall memory overhead. An approach to trade-off speed and memory space is to use a reduced FMindex (detailed in the Supplementary Material) with a time complexity of O(u·|S|) for substring search, which is able to reduce the memory size to || log 2 || +|T |(|| log 2 |T | /u+ log 2 || ) bits (u = 128 by default and thus ∼1.1 GB for the human genome). For SA, by employing the 'lastto-first column mapping' property of BWT, we can reduce the memory size to |T | log 2 |T | /v bits (v = 8 by default and thus ∼1.5 GB for the human genome) through the use of a reduced suffix array (detailed in the i319</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Y.Liu and B.Schmidt</head><p>Supplementary Material) with an approximate time complexity of O(n·v)for locating n occurrences of S. Now, we have arrived at a significantly smaller memory footprint of(||+|T |) log 2 || +|T |(||/u+1/v) log 2 |T | bits (e.g. ∼2.6 GB for the human genome). Furthermore, the increased time complexityO(u·|S|+ v ·n) for finding n occurrences of S is still acceptable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Estimation of the minimal seed size</head><p>We are only interested in the MEM seeds whose lengths are not less than a minimal seed size Q. Decreasing Q generally increases the sensitivity by finding more hits in homologous regions, at the cost of producing more noisy hits. Increasing Q generally decreases the number of hits at the cost of decreased sensitivity. Many seed-based aligners, therefore, require users to carefully tune Q. However, this tuning work is tedious. To address this issue, we propose an automatic estimation of Q according to a given read length. Our estimation of Q is based on the q-gram lemma (<ref type="bibr" target="#b34">Rasmussen et al., 2006</ref>) and a simplified error model. The q-gram lemma states that two aligned sequences S 1 and S 2 with an edit distance of e (the number of errors) share at least t q-grams where t = max(|S 1 |,|S 2 |)−q+1−q·e. This means that for overlapping q-grams, one error may cause up to q·eq-grams not to be shared by the two reads, and for non-overlapping q-grams, one error can destroy only one q-gram (<ref type="bibr" target="#b13">Blom et al., 2011</ref>). Hence, given the edit distance e of S aligned to the genome, Q is estimated as:</p><formula>Q = min max |S| e+1 , Q L , Q H (2)</formula><p>where Q L and Q H are the global lower-bound and upper-bound, respectively. The estimation is based on the pigeonhole principle for non-overlapping qgrams, meaning that at least one q-gram of length Q is shared by S and its aligned substring mate on the genome. By default, our aligner sets Q L = 13 and Q H = 49. Since the error model for gapped alignments is quite complicated, we employ a simplified error model for ungapped alignments to estimate e. Supposing that the number of substitutions w in the full-length alignment of S is a random variable and each base in S has the same error probability p (default = 2%), the probability of having z substitutions is calculated as:</p><formula>P(w = z) = C z |S| p z (1−p) |S|−z (3)</formula><p>where w follows a binomial distribution. By specifying a missing probability m (default = 4%), e can be estimated as min{z|P(w &gt; z) &lt; m}. Our simplified error model results in the following values: Q = 16 for 100-bp reads, Q = 22 for 200-bp reads and Q = 35 for 500-bp reads. In addition, we also provide parameters to allow users to customize Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Generation of maximal exact matches</head><p>To identify MEMs between S and T , we advance the starting position p in S, from left to right, to find the longest exact matches (LEMs) using the BWT and the FM-index. According to the above definitions, we know that the identified LEMs are right maximal. We know that the LEMs starting at the beginning of S are both left maximal and right maximal. This means that when advancing the starting positions from the beginning to the end of S, the identified LEMs are also left maximal if it is not part of any previously identified MEM. In this way, only unidirectional substring search is required. Since we are only concerned about MEMs of sufficient lengths, we discard the MEMs whose lengths are less than Q. For large genomes, it is possible to find a lot of occurrences of a MEM starting at a certain position of S. In this case, we only keep its first h (h = 1024 by default) occurrences and discard the others. However, it is also observed that we sometimes fail to find any MEM seeds for some reads using Q. To improve sensitivity, we therefore attempt to rescue them by re-conducting the MEM identification procedure using a new and smaller minimal seed size Q N = (Q +Q L )/2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Determination and selection of mapping regions</head><p>For local alignment with affine gap penalty, the positive score for a match is usually smaller than the penalty charged for a substitution or for a gap. Using such type of scoring schemes, the length of the optimal local alignment of S to the genome cannot be &gt;2|S| as a local alignment requires a positive alignment score. This conclusion forms the foundation of our genome mapping region determination approach for each identified MEM seed. In our aligner, we employ a commonly used scoring scheme [e.g. also used in BLAST (<ref type="bibr" target="#b12">Altschul et al., 1990</ref>) and BWA-SW] with the score 1 for a match, a penalty of 3 for a substitution, a penalty of 5 for a gap opening and a penalty 2 for a gap extension. For a read, a MEM indicates a mapping region on the genome, which includes the seed and potentially contains the correct alignment of the full read. We can determine the range of the mapping region by extending the MEM in both directions by a certain number of bases. Since the optimal local alignment length of S cannot be &gt;2|S| in our aligner, it is safe to determine the mapping region range by extending the MEM by 2|S| bases in each direction. This extension does work, but will result in lower speed due to the introduced redundancy. Hence, we attempt to compute a smaller mapping region with as little loss of sensitivity as possible. We define P mem to denote the starting position of a MEM in S, T mem to denote the mapping position of the MEM on the genome and L mem to denote the MEM length. Assuming that the MEM is included in the final alignment, our aligner estimates the mapping region range<ref type="bibr">[</ref>Our aligner computes the optimal local alignment scores in all determined mapping regions of S using the SW algorithm, and then builds a sorted list of all mapping regions in the descending order of score. Mapping regions whose scores are less than a minimal score threshold (default = 30) are removed from the sorted list. Subsequently, the sorted list of qualified mapping regions is used in the SE and the PE alignment (e.g. determining the final alignments and approximating the mapping quality scores).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Paired-end mapping</head><p>The alignment of a paired read pair generally has two constraints: alignment strand and mapping distance. For the alignment strand constraint, our aligner requires the two reads to be aligned to the genome from different strands. For the mapping distance constraint, our aligner requires that the mapping distance of the two reads cannot exceed a maximal mapping distance threshold defined by the insert-size information of a library. Assuming that the mean insert-size is X and the standard deviation of the insert-size is σ , we calculate the maximal mapping distance threshold as X +4σ. For the PE mapping, our aligner employs two stages: (i) pairing qualified mapping regions in order to find the correct alignments for both ends and (ii) rescuing un-aligned reads through their aligned read mates. For any aligned read pair, we can first compare their mapping distance on the genome (calculated from the positions of the best alignments of the two reads) to the insert-size constraint. If this comparison is within the mapping distance threshold, the corresponding alignment is output. Otherwise, we could calculate the mapping distance for each mapping position pair from all qualified mapping regions in the sorted list. However, the associated computational overhead cannot be tolerated since we need to obtain the alignment paths for all qualified mapping regions of a read pair. Hence, we introduce a seed-pairing approach to heuristically accelerate the read pairing. The seed-pairing heuristic works by enumerating each seed pair of S 1 and S 2 in order to find all potential seed pairs. If the seed pair has different alignment strands and locates on the same genome fragment, it will be used to estimate the mapping distance of S 1 and S 2 , and otherwise will be discarded. In our aligner, the mapping position T s of S is estimated from one of its MEMs as:</p><formula>T s = T mem − P mem ,</formula><p>if the strand is forward |S|−P mem +1, if the strand is reverse (5) i320</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Long read alignment based on maximal exact match seeds</head><p>where we assume that S is aligned to the genome without gaps. To compensate for the difference between the estimated mapping distance and the correct one, we employ a larger maximal insert-size threshold X +4σ +2e for the seed-pairing heuristic. If the estimated mapping distance does not exceed the maximal insert-size threshold, this seed pair is considered qualified and will be saved for future use. After finding all qualified seed pairs, we enumerate each qualified seed pair to compute the real mapping distance of S 1 and S 2 , which is compared with the maximal insert-size threshold X +4σ. If the insert-size constraint is met, S 1 and S 2 are reported as paired. Otherwise, we will compute the best alignment for S 1 (or S 2 ) to rescue its mate by employing the insert-size information to determine the potential mapping region of its mate. This rescuing procedure is also applied when only one read of S 1 and S 2 is aligned.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Approximation of mapping quality scores</head><p>Since the introduction of mapping quality scores in MAQ () to indicate the probability of the correctness of alignments, the concept of mapping quality scores has been frequently used in many NGS read aligners. Generally, a higher mapping quality score indicates a higher confidence in the correctness of an alignment. As stated in BWA-SW, if an aligner guarantees to find all local alignments of a read, the mapping quality score M q is determined by these local alignments only. Although our aligner does not find all local alignments of the read, the sorted list of qualified mapping regions still provides sufficient information to approximate M q. In our aligner, we employ two equations to approximate M q for the SE and the PE alignment. For the SE alignment, M q is approximated as 250(b 1 −b 2 )/b 1 × r, similar to the mapping quality approximation in BWA-SW, where b 1 is the best local alignment score, b 2 is the second best local alignment score, and r is calculated by dividing the number of bases of the read in the final alignment by the read length. For the PE alignment, the calculation of M q depends on two conditions. If the two reads are correctly paired through the seed-pairing heuristic, the mapping quality score for each read is equal to its SE M q. Otherwise, if one read is rescued by its mate, the mapping quality score of the read is approximated as r ×M mq , where M mq is the SE M q of its mate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Parallel design</head><p>In CUSHAW2, the most time-consuming part of SE alignment is the selection of the best mapping region using the SW algorithm. To accelerate its execution, we have adopted the (SSE2) Streaming SIMD Extensions 2-based parallel implementation of the SW algorithm in SWIPE (<ref type="bibr" target="#b36">Rognes, 2011</ref>). In addition, as multi-core CPUs have become commonplace, our aligner employs a multi-threaded design using Pthreads to parallelize the alignment process. We use a dynamic scheduling policy to assign reads to threads, which allows one thread to immediately start a new alignment without waiting for the completion of the other threads. For SE alignment, a thread aligns a single read at a time and then reads a new read from the input file immediately after finishing the current alignment. For PE alignment, we follow the same scheduling policy with the difference that one read pair is assigned at a time. Locks are appropriately used to ensure mutually exclusive accesses to both the input and output files.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>The performance of CUSHAW2 is compared with three other long read aligners: BWA-SW (v0.6.1), Bowtie2 (v2.0.0-beta5) and GASSST (v1.28). BWA-SW employs the default settings and Bowtie2 also employs the default settings, except for the insert size related parameters for the PE alignment. GASSST uses a minimal percentage identity of 90% and default settings for other parameters. CUSHAW2 requires the final alignment to have a percentage identity of 90% (default setting) and to include 80% (default setting) bases of the read.All the tests are conducted on a workstation with two six-core Intel Xeon X5650 2.67GHz CPUs and 96 GB RAM, running the Linux operating system. The runtime of each aligner is measured in wall clock time for all tests, where the one-time construction time of the BWT and the FM-index is not counted in for CUSHAW2, BWA-SW and Bowtie2. We use the recall and precision measures to assess all aligners using simulated datasets, where recall (precision) is calculated by dividing the number of reads that are correctly aligned by the total number of reads (the number of aligned read). If not explicitly specified, a read is deemed to be correctly aligned if the mapping position has a distance of 5 to the true position. For real datasets, we use the sensitivity measure, which is calculated by dividing the number of aligned reads by the total number of reads. GASSST does not evaluate every seed to determine the best alignment for a single read. Instead, it continues reporting identified alignments until reaching the maximal limit of the number of alignments. Thus, we consider the best of all reported alignments as the final alignment of the read and discard the others. In addition, GASSST does not provide the support for PE alignment and thus is only evaluated for SE alignment. BWA-SW might report more than one alignment for a single read (in rare cases for not very long reads), where one alignment corresponds to one fragment of the read. Since these fragment alignments are difficult to be distinguished and ranked, we take all of them into consideration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Evaluation on simulated datasets</head><p>We have first evaluated all aligners using nine simulated 100-bp, 200-bp and 500-bp datasets with different uniform base error rates (i.e. 1%, 2% and 4%). These datasets are simulated from the human genome using the wgsim utility in SAMtools v0.1.17 (<ref type="bibr" target="#b24">Li et al., 2009</ref>) with 10% errors being indel errors. Each dataset is comprised ofCUSHAW2 is on an average superior to all other evaluated aligners in terms of both recall and precision for the SE (PE) alignment, where the average recall is ∼89.92% (90.75%) and the average precision is ∼97.46% (98.28%). For the SE alignment, on average, BWA-SW is the second best with an average recall (precision) of ∼88.54% (96.81%), whereas GASSST is the worst with an average recall (precision) of only ∼79.46% (95.51%). For the PE alignment, on average, BWA-SW has a higher recall than Bowtie2, whereas the latter gives a higher precision. For BWA-SW, the average recall (precision) is ∼90.14% (97.65%) and for Bowtie2, ∼89.71% (97.92%). Moreover, an increased recall and precision can be observed for CUSHAW2, BWA-SW and Bowtie2 after performing PE mapping on each dataset. In general, for each aligner, both recall and precision improve for increasing read length for a fixed error rate, and degrade for increasing error rates for a fixed read length. To evaluate alignments with high mapping quality scores, we have taken into account the alignments whose mapping quality scores are 30 (Q30). Moreover, an aligned read is deemed to be correctly aligned only if the mapping position is identical to the true position of the read.<ref type="figure" target="#tab_2">Table 2</ref>shows the alignment results using Q30 for the 200-bp datasets, whereas the alignment results using Q30 for the other datasets can be obtained from the Supplementary Material. For both the SE and the PE alignment, on average, CUSHAW2 yields the highest recall whereas Bowtie2 gives the highest precision. For all datasets, the average recall (precision) for SE alignment is ∼85.80% (99.94%) for CUSHAW2, 81.70% (99.94%) for BWA-SW, 76.47% (99.98%) for Bowtie2 and 75.44% (99.51%) for GASSST. On an average for all datasets, the recall (precision) for PE alignment is ∼86.01% (99.94%) for CUSHAW2, 84.15% (99.94%) for BWASW and 81.84% (99.98%) for Bowtie2. Compared with the SE alignment, the recall of each aligner gets better for each dataset. As for the precision, both CUSHAW2 and BWA-SW can hold their precision for each dataset, whereas Bowtie2 has a minimal decrease for some datasets. Finally, we have evaluated the impact of the amount of indel errors on each aligner. In this evaluation, we have re-simulated four 200-bp datasets from the human genome containing 2 million PE reads each. All the four datasets have the same uniform base error rate of 2%, but have different percentages of indel errors (i.e. 20%, 40%, 60% and 80%).<ref type="figure">Table 3</ref>shows the alignment results. For the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Long read alignment based on maximal exact match seeds</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Y.Liu and B.Schmidt</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fig. 4. Scalability comparison between all aligners for the SE and PE alignment</head><p>with the use of SSE2 assembler instructions. In addition, multithreading is supported in order to benefit from the coarse-grained parallelism on multiple CPU cores. We have assessed the performance of CUSHAW2 and the three other long read aligners: BWA-SW, Bowtie2 and GASSST using simulated as well as real datasets. For the simulated reads, we have computed the recall and precision measures since we know the true position of each read on the genome. For the real datasets, we have employed the sensitivity measure. Using the above measures, CUSHAW2 is shown to be among the highest-ranked aligners in terms of alignment quality for both the SE and the PE alignment for a variety of error rates and varying amount of indel errors. Our aligner achieves good parallel scalability with respect to the number of threads, while demonstrating highly competitive overall execution speed. Furthermore, through the use of memory efficient data structures, CUSHAW2 only requires a memory footprint of ∼4 GB (using 12 threads) for performing alignments to the human genome. This approach makes it possible to accurately align hundreds of millions of long reads to a mammalian-sized genome in only a few hours on a standard multi-core workstation with only a modest amount of RAM installed. Since throughput and read-length of NGS machines continues to grow, these results are of high importance to the bioinformatics community.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Alignment results using the 454 datasets</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. Alignment results using the Illumina datasets</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>Funding: We acknowledge funding by the Center for Computational Science, Mainz. Conflict of Interest: None declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>T a , T b ] as: T a = T mem −2(P mem +1) T b = T mem +L mem +2(|S|−P mem −L mem ) (4)</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. Alignment results on the simulated 200-bp datasets</figDesc><table>Aligner 
1% 
2% 
4% 

Recall 
Prec. 
Recall 
Prec. 
Recall 
Prec. 

SE 

CUSHAW2 
90.39 
97.84 
90.28 
97.77 
90.02 
97.57 
BWA-SW 
90.30 
97.74 
90.03 
97.50 
88.92 
96.43 
Bowtie2 
89.99 
97.45 
89.44 
96.97 
87.41 
96.03 
GASSST 
80.41 
96.04 
79.58 
96.01 
77.73 
95.98 

PE 

CUSHAW2 
90.94 
98.44 
90.85 
98.39 
90.76 
98.26 
BWA-SW 
90.51 
97.97 
90.42 
97.90 
90.19 
97.51 
Bowtie2 
90.82 
98.32 
90.48 
98.03 
89.16 
97.58 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 3. Alignment results using different percentages of indel errors</figDesc><table>Aligner 
Measure 
20% 
40% 
60% 
80% 

SE </table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="2"> million PE reads, and the insert-sizes are drawn from normal distributions N (500, 50), N (1000, 50) and N (2000, 50) for the 100-bp, 200-bp and 500-bp datasets, respectively. Table 1 shows the alignment results of all aligners for the 200bp datasets, whereas the alignment results for the other datasets can be obtained from the Supplementary Material. CUSHAW2 yields the highest recall and precision for both the SE and the PE alignment for all datasets (with an exception that for the 100-bp dataset with 1% error rate, Bowtie2 has a slightly better precision than CUSHAW2 by ∼0.04% for the PE alignment). Furthermore, i321 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">− be explained by the quadratic time complexity of the DP-based alignment computation and the increasing number of seeds for longer reads. However, the runtime of GASSST does not increase significantly for increasing read length due to its use of both the multi-filtration mechanism and the early stop of seed search that stalls when the number of seed occurrences reaches a specified limit (Rizk and Lavenier, 2010). The multi-filtration mechanism is likely to eliminate many noisy seeds efficiently. The early stop of seed search makes the overall number of seeds relatively stable for different read lengths. However, the negative side effect of the two approaches is that it causes the loss of relevant seeds, thus missing some correct alignments as we can observe from evaluation with simulated reads. Finally, we have assessed the parallel scalability of all aligners with respect to the number of threads. In this evaluation, we have used the three simulated 100-bp, 200-bp and 500-bp datasets with 1% error rate to run each aligner. Figure 4 illustrates the average speedups of each aligner using different number of threads for the SE and PE alignment. For both the SE and PE alignment, CUSHAW2 shows the best scalability and BWA-SW the second best. The scalability of GASSST is the worst for the SE alignment, where it only gets slight speed improvement after doubling the number of threads. Using 12 threads, for the SE (PE) alignment, the average speedup is about 11.4 (11.3) for CUSHAW2, 10.6 (10.6) for BWA-SW and 8.7(6.3) for Bowtie2, whereas GASSST only has an average speedup of about 2.2 for the SE alignment. 4 CONCLUSIONS In this article, we have presented CUSHAW2, a parallel and accurate algorithm and tool for aligning long reads to large genomes, such as the human genome. In this aligner, MEMs are used as seeds to find gapped alignments and final alignments are reported in SAM format (Li et al., 2009) to facilitate the downstream analysis. To accelerate the alignment selection, our aligner employs fine-grained parallelism from Single instruction, Multiple data (SIMD) vector execution units i323 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Evaluation on real datasets</head><p>We have assessed all aligners using four datasets produced by 454 and Illumina sequencers, respectively. All the datasets are publicly available from NCBI SRA and named after their accession numbers (see). We have used two runs (SRR000026 and SRR000027) of the SRX000001 experiment, two runs (SRR006428 and SRR006433) of SRX001829, two runs (ERR024139 and ERR024140) of ERX009608 and the single run (SRR189815) of SRX028059. For all 454 datasets, we have removed all reads shorter than 100-bp and only conducted the SE alignment. For all Illumina datasets, we have performed both the SE and the PE alignment. Figures 2 and 3 show the alignment results for the 454 and Illumina datasets, respectively. In this evaluation, the alignment of a read is taken into account only if it has a percentage identity of 90% and contains 80% bases of the read. This constraint is also in accordance with our intention for long read alignments, i.e. attempting to align a read in the full length to the genome. We have excluded GASSST from the larger Illumina datasets due to its very slow speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i322</head><p>For each 454 dataset, CUSHAW2 has the highest sensitivity. BWA-SW is second and GASSST is worst. For the Illumina datasets, Bowtie2 aligned the most reads and CUSHAW2 the second most. For the SE (PE) alignment, the average sensitivity is ∼94.93% (95.28%) for CUSHAW2, 93.99% (94.95%) for BWA-SW and 95.45% (95.81%) for Bowtie2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Speed and scalability evaluation</head><p>We have assessed the speed of each aligner using 12 threads on our workstation (see), where we organized all simulated datasets into three groups, namely D100, D200 and D500, as per the read lengths and averaged the runtimes of all datasets in each group. For the SE alignment, GASSST is the slowest for each data group and is almost two orders of magnitude slower than the other three aligners for D100, D200 and SRX000001. For the datasets with smaller mean read lengths of 200-bp, Bowtie2 is the fastest and CUSHAW2 outruns BWA-SW. However, for the datasets with greater mean read lengths of around 500-bp, Bowtie2 becomes slower than both CUSHAW2 and BWA-SW and BWA-SW outruns CUSHAW2. This suggests that Bowtie2 might have been optimized for reads of lengths around 200-bp, but does not scale well towards longer reads. The PE alignment comparison between CUSHAW2, BWA-SW and Bowtie2 shows a similar trend. From the runtimes of all simulated data groups, it is observed that the runtime for CUSHAW2, BWA-SW and Bowtie2 significantly increases as the read lengths grow from 100 to 500. This can</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">16418</biblScope>
			<biblScope unit="issue">9</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>bts414. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Liu and B.Schmidt Table 2. Alignment results using Q30 on the simulated 200-bp datasets Aligner 1% 2% 4% Recall Prec. Recall Prec. Recall Prec</title>
		<imprint>
			<biblScope unit="page" from="322" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Bwa-Sw</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bowtie2 Recall</title>
		<imprint>
			<biblScope unit="volume">89</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="m">Prec. 96.96 96.97 96.99 96</title>
		<imprint>
			<biblScope unit="page">97</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Prec</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="m">PE CUSHAW2 Recall 90</title>
		<imprint>
			<biblScope unit="page">9086</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="m">Prec. 98.38 98.38 98.38 98</title>
		<imprint>
			<biblScope unit="page">37</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Bwa-Sw</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bowtie2 Recall</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Prec</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">REFERENCES</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Basic local alignment search tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="403" to="410" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Exact and complete short read alignment to microbial genomes using Graphics Processing Unit programming</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Blom</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1351" to="1358" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">AVID: a global alignment program A block sorting lossless data compression algorithm</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Bray</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="97" to="102" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">GAME: a simple and efficient whole genome alignment method using maximal exact match filtering</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">H</forename>
				<surname>Choi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Biol. Chem</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="244" to="253" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Alignment of whole genomes</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">L</forename>
				<surname>Delcher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2369" to="2376" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Indexing compressed text</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient multiple genome alignment</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Höhl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="312" to="320" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
	<note>Suppl. . 1</note>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">BFAST: an alignment tool for large scale genome resequencing</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Homer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Adaptive seeds tame genomic sequence comparison</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">M</forename>
				<surname>Kiełbasa</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="487" to="493" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Compressed indexing and local alignment of DNA</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">W</forename>
				<surname>Lam</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="791" to="797" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with Bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with Burrows– Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1755" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Fast and accurate long read alignment with Burrows– Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="589" to="595" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Mapping short DNA sequencing reads and calling variants using mapping quality scores</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1851" to="1858" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">The sequence alignment/map format and SAMtools</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2078" to="2079" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">SOAP: short oligonucleotide alignment program</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="713" to="714" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">SOAP2: an improved ultrafast tool for short read alignment</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1966" to="1967" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">CUSHAW: a CUDA compatible short read aligner to large genomes based on the Burrows-Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Liu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1830" to="1837" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">PatternHunter: faster and more sensitive homology search</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="440" to="445" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">A general method applicable to the search for similarities in the amino acid sequence of two proteins</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">B</forename>
				<surname>Needleman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">D</forename>
				<surname>Wunsch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="443" to="453" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">SSAHA: a fast search method for large DNA databases</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Ning</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1725" to="1729" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">Efficient q-gram filters for finding all epsilon-matches over a given length</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">R</forename>
				<surname>Rasmussen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="296" to="308" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">GASSST: global alignment short sequence search tool</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Rizk</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Lavenier</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="2534" to="2540" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<analytic>
		<title level="a" type="main">Faster Smith–Waterman database searches with inter-sequence SIMD parallelisation</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Rognes</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">221</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title level="a" type="main">SHRiMP: accurate mapping of short color-space reads</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">M</forename>
				<surname>Rumble</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">1000386</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b38">
	<analytic>
		<title level="a" type="main">Identification of common molecular subsequences</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">F</forename>
				<surname>Smith</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Waterman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">147</biblScope>
			<biblScope unit="page" from="195" to="197" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>