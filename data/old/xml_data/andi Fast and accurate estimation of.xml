
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:51+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Genome analysis andi: Fast and accurate estimation of evolutionary distances between closely related genomes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Bernhard</forename>
								<surname>Haubold</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Evolutionary Genetics</orgName>
								<orgName type="department" key="dep2">Max-Planck-Institute for Evolutionary Biology</orgName>
								<address>
									<addrLine>24306 Plö n</addrLine>
									<settlement>Germany</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Fabian</forename>
								<surname>Klö Tzl</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Evolutionary Genetics</orgName>
								<orgName type="department" key="dep2">Max-Planck-Institute for Evolutionary Biology</orgName>
								<address>
									<addrLine>24306 Plö n</addrLine>
									<settlement>Germany</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Institue for Neuro-and Bioinformatics</orgName>
								<orgName type="institution">Lü beck University</orgName>
								<address>
									<addrLine>23562 Lü beck</addrLine>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Peter</forename>
								<surname>Pfaffelhuber</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">Mathematical Stochastics</orgName>
								<orgName type="department" key="dep2">Mathematical Institute</orgName>
								<orgName type="institution">Freiburg University</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alfonso</forename>
								<surname>Valencia</surname>
							</persName>
						</author>
						<title level="a" type="main">Genome analysis andi: Fast and accurate estimation of evolutionary distances between closely related genomes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu815</idno>
					<note type="submission">Received on July 1, 2014; revised on November 6, 2014; accepted on December 7, 2014</note>
					<note>*To whom correspondence should be addressed. Associate Editor: Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: A standard approach to classifying sets of genomes is to calculate their pairwise distances. This is difficult for large samples. We have therefore developed an algorithm for rapidly computing the evolutionary distances between closely related genomes. Results: Our distance measure is based on ungapped local alignments that we anchor through pairs of maximal unique matches of a minimum length. These exact matches can be looked up efficiently using enhanced suffix arrays and our implementation requires approximately only 1 s and 45 MB RAM/Mbase analysed. The pairing of matches distinguishes non-homologous from homologous regions leading to accurate distance estimation. We show this by analysing simulated data and genome samples ranging from 29 Escherichia coli/Shigella genomes to 3085 genomes of Streptococcus pneumoniae. Availability and implementation: We have implemented the computation of anchor distances in the multithreaded UNIX command-line program andi for ANchor DIstances. C sources and documentation are posted at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The spread of infectious diseases is nowadays often monitored by sequencing the genomes of the outbreak strains. Since a given pandemic is usually caused by the rapid expansion of a single clone, monitoring by sequencing leads to the accumulation of hundreds to thousands of similar genome sequences. For example,<ref type="bibr" target="#b17">Petty et al. (2014)</ref>studied the spread of the multi-drug resistant Escherichia coli strain ST131, which causes extra-intestinal infections in humans. The authors sequenced 99 outbreak strains and reconstructed their phylogeny. This revealed that the outbreak was caused by a single lineage of ST131. On an even larger scale,<ref type="bibr" target="#b3">Chewapreecha et al. (2014)</ref>studied pneumococcal carriage in a refugee camp by sequencing 3085 strains of Streptococcus pneumoniae, which causes pneumoniae in humans. Again, phylogeny reconstruction based on these genomes was an early step in the study. Classifying bacteria by clustering their genomes is set to become routine. For this purpose,<ref type="bibr" target="#b17">Petty et al. (2014)</ref>computed a multiple sequence alignment of their E.coli ST131 strains using the program mugsy (<ref type="bibr" target="#b1">Angiuoli and Salzberg, 2011</ref>). It is based on the MUMmer software (<ref type="bibr" target="#b14">Kurtz et al., 2004</ref>), which makes mugsy one of the fastest multiple genome aligners available: it took only 19 h to align 57 complete E.coli genomes. However, the run time of mugsy becomes unacceptable when applied to the recently collected samples of hundreds or even thousands of bacterial genomes.For their study of 3085 pneumococcal isolates,<ref type="bibr" target="#b3">Chewapreecha et al. (2014)</ref>mapped the sequencing reads onto a reference genome, thereby approximating a multiple sequence alignment. Such alignment by mapping is widely used, and<ref type="bibr" target="#b2">Bertels et al. (2014)</ref>have shown that its accuracy can be further improved by mapping against multiple reference genomes instead of the customary single reference. Their implementation of this idea, REALPHY, requires 2 min and 250 MB/Mbase analysed. The genome of S.pneumoniae is 2.2 Mbase long, so REALPHY would run 9.4 days on the 3085 S.pneumoniae isolates. However, a more prohibitive aspect of REALPHY might be the RAM requirement of 1.7 TB. Perhaps surprisingly, it is not necessary to compute an explicit alignment for phylogeny reconstruction. This insight has sparked interest in devising alignment-free methods for rapidly calculating pairwise distances between genomes (Haubold, 2014), which can then be clustered using various quick algorithms (<ref type="bibr" target="#b7">Felsenstein, 2004</ref>). Alignment-free distance computation is either based on counting words of a certain length or recording match lengths (<ref type="bibr" target="#b9">Haubold, 2014</ref>). When counting words, there is a choice between the traditional approach of counting exact words and a more recent method of looking for words that enclose one mismatch. The latter is implemented in the program co-phylog (<ref type="bibr" target="#b21">Yi and Jin, 2013</ref>), which gives better distances than exact word counting while requiring only moderate additional resources (<ref type="bibr" target="#b9">Haubold, 2014</ref>).<ref type="bibr" target="#b10">Haubold et al. (2009)</ref>devised an alignment-free estimator of genetic distance based on match lengths. The expected match length is the inverse of the proportion of mismatches. For example, if 1% of positions between two genomes are mismatched, the expected match length is 100. Domazet-Lošo and Haubold (2009) implemented this idea using a generalized suffix tree of all input sequences to look up the match lengths. Their program kr computes the distances between the complete genomes of 29 E.coli/Shigella strains in just 5.5 min on a single processor. However, this takes 5.3 GB RAM and kr has been criticized for excessive RAM utilization (<ref type="bibr" target="#b4">Cohen and Chor, 2012</ref>). Moreover, Yi and Jin (2013) noted that co-phylog gave a better phylogeny when applied to the benchmarking sample of 29 E.coli/Shigella genomes. This has prompted us to devise a replacement for kr. Our new strategy is to look for mismatches that are bracketed by long exact matches, which we call anchors. We show through simulation that the resulting program andi, for ANchor DIstances, is accurate, fast and memory efficient. Moreover, we apply andi to three sets of bacterial genomes: the 29 genomes of E.coli/Shigella Yi and Jin (2013) used for benchmarking co-phylog, the 109 genomes of E.coli ST131 studied by<ref type="bibr" target="#b17">Petty et al. (2014)</ref>—of which they sequenced 99 strains—and the 3085 genomes of S.pneumoniae sequenced by<ref type="bibr" target="#b3">Chewapreecha et al. (2014)</ref>. In each case, andi quickly recovers pairwise distances. For the E.coli samples, we compare the new distances to alignment-based distances and find they are so similar that they yield almost identical phylogenies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Defining anchor distances</head><p>We compute anchor distances using maximal matches by imposing three criteria on them: uniqueness, equidistance and a minimum length. In this section, we explain each of these criteria in turn, which sets the stage for the description of our algorithm in Section 2.2. Consider two DNA sequences, a query Q and a subject S. Taking our cue from genome alignment tools such as MUMmer (<ref type="bibr" target="#b14">Kurtz et al., 2004</ref>) and mauve (<ref type="bibr" target="#b5">Darling et al., 2004</ref>), we call a unique maximal match between Q and S an anchor, if it has some minimum length. We look for pairs of anchors that have the same distance in Q and S, as shown in<ref type="figure" target="#fig_0">Figure 1A</ref>. Such anchor pairs approximate ungapped alignments, and we count the mismatches in the intervening segment. In contrast, if the anchors are unequally spaced as shown in<ref type="figure" target="#fig_0">Figure 1B</ref>, the regions they bracket are either not homologous or contain indels. We ignore such anchor pairs in our analysis. The total number of mismatches bracketed by equidistant anchors divided by the number of nucleotides covered by the anchors and the bracketed regions is our estimate of the number of mismatches per site, d m ðQ; SÞ. This is converted to the number of substitutions per site using the correction by<ref type="bibr">Jukes</ref>K(Q, S) is not symmetrical, that is, KðQ; SÞ 6 ¼ KðS; QÞ. We therefore define the anchor distance between two sequences i and j as the average Jukes–Cantor distance computed from the two possible labellings of i and j: d a ði; jÞ ¼ KðQ; SÞ þ KðS; QÞ 2 :</p><p>A critical parameter in the computation of d a ði; jÞ is the minimum anchor length, l. We compute this as a function of GC content and subject length using equation (6) by Haubold et al.</p><formula>(2009): P X Ã i x È É ¼ X x k¼0 2 x x k ! p k ð 1 2 À pÞ xÀk ð1 À p k ð 1 2 À pÞ xÀk Þ jSj ;</formula><p>where X Ã i is the length of a match starting at position i in Q and any position in S, and 2p is the GC content of S. We define l to be the 97.5% quantile of the distribution of X Ã i .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Algorithm and implementation</head><p>For computing anchor distances, we first order alphabetically all suffixes contained in the forward and reverse strands of S. From this suffix array, we compute the array of common prefix lengths between consecutive suffixes using the U-algorithm listed as Algorithm 4.4 by<ref type="bibr" target="#b16">Ohlebusch (2013)</ref>. Together with the suffix array, this longest common prefix array forms the enhanced suffix array, E, which is the central input for computing K(Q, S). Algorithm 1 uses the function getMatchðE; stringÞ to look for the longest prefix ofstring that matches somewhere in S. In Line 8, string is the suffix of Q that has not yet been matched against S. Function getMatch (not shown) is a slight variation on Algorithm 5.2 by Ohlebusch (2013). The matching step is repeated one residue beyond the mismatched nucleotide that terminates the previous match until an equidistant pair of anchors (<ref type="figure" target="#fig_0">Fig. 1A</ref>) is found in Line 12. The mutations in the intervening segment are counted (Line 13) and the distance between the current and the previous match is added to the homologous nucleotide counter (Line 14). The search for equidistant anchor pairs continues until the complete forward strand of Q has been traversed. Then K(Q, S) is computed as the ratio of mutations to homologous nucleotides (Line 24). This streaming of Q against S using an enhanced suffix array is an idea we took from vmatch (http://www.vmatch.de). For our suffix array computation, we use the libdivsufsort library (http://homepage3.nifty.com/wpage/software/). The function getMatch is based on range minimum queries, for which we use an algorithm and corresponding implementation by Fischer and Heun (2007). The memory requirement of the resulting program andi is dominated by the computation of the enhanced suffix array. To minimize the memory footprint of andi, it initially streams all sequences against the enhanced suffix array of the first sequence, then against the enhanced suffix array of the second sequence, and so on. Thus at any one time, only the enhanced suffix array for a single sequence is kept in memory. This approach also allows for easy parallelization, which we implemented using the OpenMP framework. andi runs fastest when the number of taxa is equal to the number of processors. In that situation, all rows of the distance matrix are filled in simultaneously and the program takes time proportional to the length of the longest genome.</p><formula>A Q S B Q S</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Simulations</head><p>For simulating pairs of related DNA sequences, we used our program simK, which is linked from the andi web page. Here is the command for a typical simulation run simK-l 1000000-k 0.01 j andi where-l is the sequence length and-k is the number of substitutions per site. Time and memory consumption was measured using commands such as /usr/bin/time-f " \n %E elapsed,\n%M memory " \ andi sim.fa &gt; sim.dist 2&gt; andi.res on a 32 core 2.3 GHz AMD Opteron system with 256 GB of RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Datasets</head><p>Apart from simulated data, we analysed three sets of genomes ofLinks to these datasets are also posted on the andi web site.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Alignment</head><p>The two E.coli genome samples were aligned with mugsy, which generates output in 'mutation annotation format' (maf) (<ref type="bibr" target="#b1">Angiuoli and Salzberg, 2011</ref>). We converted this to PHYLIP format with our script maf2phy.awk, also posted on the andi web site. Jukes–Cantor distances were computed using the program dnadist, which is part of the PHYLIP package (<ref type="bibr" target="#b8">Felsenstein, 2005</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Phylogeny reconstruction</head><p>Distances were clustered using neighbor and the trees midpoint rooted using retree, both also part of PHYLIP. Trees were plotted uising njplot (Perrière and<ref type="bibr" target="#b16">Gouy, 1996</ref>) or drawgram (PHYLIP). Topological distances between trees were computed using the programs rspr (<ref type="bibr" target="#b20">Whidden et al., 2013</ref>) or treedist (PHYLIP).<ref type="figure">Figure 2A</ref>shows our new distance measure d a as a function of the number of substitutions per site, K, for simulated pairs of 100 kbase sequences, which implies a minimum anchor length of 8. Under these ideal conditions, d a is an excellent estimator for a wide range of divergence values. However, for K ! 0:5 the probability increases that no anchor pair is found and d a cannot be computed. The proportion of failed estimations therefore grows from 0.7% for K ¼ 0.5 to 94% for K ¼ 0.65 (<ref type="figure">Fig. 2B</ref>, open circles). This might suggest that a lower minimum anchor length yields better estimates. However, it leads to underestimation of distances (Supplementary<ref type="figure" target="#fig_0">Fig. S1</ref>). We thus recommend using andi only for sequences with K 0:5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Simulations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Estimate substitutions per site</head><p>Require: Q {query sequence} Require: S {subject sequence} Require: E {enhanced suffix array of S, forward &amp; reverse} Require: l {minimum anchor length} Ensure: K {K(Q, S), substitutions per site between Q and S} 1: q p q c 0 {previous and current position in Q} 2: s p 0 {previous position in S} 3: l p 0 {previous jump length} 4: s 0 {number of mutations (segregating sites)} 5: n 0 {number of homologous nucleotides} 6: a false {no anchor found yet} 7: while q c &lt; jQj do 8: m getMatchðE; Q½q c ::jQjÞ 9: l c m:length þ 1 {jump by at least one position} 10: if m:isUnique and m:length ! l then 11: s c E:positionðmÞ {find position of match in S} 12: if q c À q p ¼ s c À s p then 13: s s þ countDiffðQ½q p ::q c À 1; S½s p ::s c À 1Þ 14: n n þ q c À q p 15: a true 16: else 17: if a ¼ true then 18:</p><formula>n n þ l p À 1 19: a false 20: q p q c 21: s p s c 22: l p l c 23: q c q c þ l c 24: K s=n</formula><p>Fast and accurate estimation of evolutionary distances</p><p>Our main motivation for developing d a is efficiency.<ref type="figure">Figure 3</ref>shows the time and memory consumption of andi as a function of sequence length. The run time would ideally be linear in the size of the input sequence, that is, time / length, which is close to the observed run time Oðlength 1:05 Þ. Notice also that the more divergent sequences with K ¼ 0.1 take slightly longer to analyse than those with K ¼ 0.01. The reason for this is that the streaming of the query against the enhanced suffix array of the subject takes time proportional to the number of calls to the matching function. This in turn depends on the number of substitutions, with divergent sequences requiring more matching steps. Nevertheless, as a rule of thumb andi takes 1 s/Mbase. The memory consumption shown in<ref type="figure">Figure 3B</ref>is initially constant in the sequence length reflecting program overheads. For longer sequences, memory consumption is exactly linear in the size of the input data, as expected. In fact, we observe that 45 bytes memory are used per base pair. We conclude from our analysis of simulated data that andi is accurate and efficient. Next, we apply andi to three samples of genomes: 29 E.coli/Shigella genomes, 109 genomes of E.coli ST131 (<ref type="bibr" target="#b17">Petty et al., 2014</ref>) and 3085 genomes of S.pneumoniae (<ref type="bibr" target="#b3">Chewapreecha et al., 2014</ref>). Where appropriate, we compare the results obtained by andi with those of co-phylog and alignment-based distances.<ref type="figure">Figure 4</ref>shows the phylogeny of 29 E.coli/Shigella strains computed from their complete genomes. These genomes are often used for benchmarking (<ref type="bibr" target="#b2">Bertels et al., 2014;</ref><ref type="bibr" target="#b21">Yi and Jin, 2013</ref>) and are on average 4.9 Mbase long. Aligning them to compute the phylogeny in<ref type="figure">Figure 4A</ref>took mugsy 5 h, 33 min and 2.9 GB RAM. The corresponding co-phylog computation took only 9 min, 21 s and 156.8 MB RAM. The resulting tree in<ref type="figure">Figure 4B</ref>is shorter than the reference from which it is separated by a topological distance of 3. Two of these topological differences affect short branches in clade C. The other difference concerns the position of E.coli strain UMN026, which switches between the two most basal clades. With 29 threads andi took 19.8 s and 7.2 GB RAM to compute<ref type="figure">Figure 4C</ref>. Its branch lengths are almost indistinguishable from the reference tree and its topological distance from the reference is only one due to a difference in clade C, where strain 536 should branch off at a more basal position. However, the position of strain UMN026 is correct.<ref type="figure" target="#fig_3">Figure 5</ref>shows the andi tree constructed from 109 E.coli ST131 strains (<ref type="bibr" target="#b17">Petty et al., 2014</ref>) in 1 min 21 s using 30 CPUs and 7.7 GB RAM. The 99 strains sequenced by<ref type="bibr" target="#b17">Petty et al. (2014)</ref>fall into three clades, A, B, and C, shown online in red, orange and green, respectively. The clades identified by andi are identical to those reported in the original publication based on a mugsy alignment computed on our hardware in 5.6 days using 52.7 GB RAM. That is, andi analyses the 109 E.coli genomes approximately 6000 times faster than mugsy and uses seven times less RAM. As the third and final challenge, we applied co-phylog and andi to 3085 complete genomes of the human bacterial pathogen S.pneumoniae. Its genome is 2.2 Mbase long, amounting to a dataset comprising 6.7 Gbase. co-phylog took 36.5 days and 2.3 GB RAM to compute the pairwise distances shown in<ref type="figure">Figure 6A</ref>. With 32 threads andi took 7 h, 35 min and 23.8 GB RAM to carry out the same computation (<ref type="figure">Fig. 6B</ref>). Unfortunately, we cannot compare these two trees to a reference tree. Moreover, their A BRobinson–Foulds distance (<ref type="bibr" target="#b18">Robinson and Foulds, 1981</ref>) is 4570, which is disconcertingly large. However, we found that the average Robinson–Foulds distance between 10 random trees with 3085 leaves is 6166. Also, the longest branches indicated by arrows in Figures 6A and B harbour the same three strains sequenced in lanes 6680_6#10, 6775_1#8 and 6823_7#22. It would be interesting to further investigate what sets these strains apart.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Application to genomes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discussion</head><p>Our new distance measure, d a , approximates local alignments by anchoring them with long, unique matches (<ref type="figure" target="#fig_0">Fig. 1</ref>). The requirement that the matches are equidistant in the query and the subject (<ref type="figure" target="#fig_0">Fig. 1A</ref>) is equivalent to restricting the analysis to ungapped alignments. andi is therefore a cross between the early version of BLAST (<ref type="bibr" target="#b0">Altschul et al., 1990</ref>) and the genome aligner MUMmer (<ref type="bibr" target="#b14">Kurtz et al., 2004</ref>): From early BLAST it inherits the idea of ungapped local alignments, from MUMmer the idea of looking up unique matches by indexing the subject. Domazet-Lošo and Haubold (2009) had previously used the power of indexing algorithms to estimate the number of substitutions from the match length distribution. Their program kr works on the same principle as the average common substring distance (<ref type="bibr" target="#b4">Cohen and Chor, 2012;</ref><ref type="bibr" target="#b19">Ulitsky et al., 2006</ref>), except that kr implements theory by<ref type="bibr" target="#b10">Haubold et al. (2009)</ref>to transform common substring lengths to mutation rates. Fast as the average common substring methods are, they suffer from two disadvantages: First, local fluctuations in the mutation rate affect the average match length. As a result, the same number of mutations can lead to different distances depending on the degree to which the mutations are clustered.<ref type="bibr" target="#b11">Haubold et al. (2013)</ref>have used this property to devise a test for recombination. andi does not have this problem as it counts mutations directly rather than inferring them from match lengths. The second disadvantage of match-length based methods is that matches induced by non-homologousFast and accurate estimation of evolutionary distancesregions are hard to distinguish from matches induced by highly divergent regions. Even a moderate divergence of K ¼ 0.1 implies an average match length of 10. Compare this to the expected length of a random match in a 1 Mbase sequence, which according to the theory by<ref type="bibr" target="#b10">Haubold et al. (2009)</ref>is 10.4. To overcome this limitation of match length distances, Leimeister and Morgenstern (2014) proposed a k-mismatch generalization. They show that this outperforms the classical zero-mismatch version of their distance. However, it remains unclear how to choose the critical parameter k when applying this method. Instead of a generalized mismatch approach, we bracket mutations with paired anchors. This should give more accurate results than kr, and andi did compute a better tree for 29 E.coli genomes than co-phylog, which in turn gave a better tree than kr. Hence, andi is substantially more accurate than kr. The accuracy of andi is excellent when applied to simulated sequences with a wide range of substitution rates, K (<ref type="figure">Fig. 2</ref>). However, at K &gt; 0.5 the search for suitable anchors fails increasingly often (<ref type="figure">Fig. 2B</ref>), which cannot be overcome by lowering the minimum anchor length (Supplementary<ref type="figure" target="#fig_0">Fig. S1</ref>). Hence, our method is effectively limited to K 0:5. To get an intuition for the evolutionary times implied by K ¼ 0.5, consider the average synonymous substitution rate in mammals of 3:51 Â 10 À9 (<ref type="bibr">Li, 1997, p. 420</ref>). The last common ancestor that can occur in a tree restricted to K 0:5 lived 0:5=3:51=10 À9 =2 ¼ 71 Â 10 6 years ago. This would allow the analysis of great apes, which diverged 15:7 Â 10 6 years ago (<ref type="bibr" target="#b12">Hedges et al., 2006</ref>) and mice (Muridae, 26:9 Â 10 6 years), but not of these two groups together (92:3 Â 10 6 years). Apart from maximizing accuracy, we strove to minimize time and memory usage by implementing three ideas: (i) Streaming of query against subject as first implemented in vmatch speeds up suffix array construction compared with the suffix array of all input sequences underlying kr; it also uses much less memory. Our second idea was (ii) to construct only as many enhanced suffix arrays as there are genomes in the sample, rather than constructing an enhanced suffix array for each pairwise comparison. This means that for a sample of n genomes andi requires only n suffix array constructions, whereas a program like mugsy requires the computation of Oðn 2 Þ suffix trees. The third idea was (iii) multithreading, which allows access to the multi-processor architecture of modern computers. However, other programmers might have chosen a different combination of time/memory consumption. For example, vmatch uses half as much memory as andi for suffix array construction, but is slower than the libdivsufsort library we used. When clustering hundreds of genomes, efficiency becomes paramount. As shown in<ref type="figure">Figure 3</ref>, andi uses only 1 s/Mbase and 45 bytes/bp when applied to simulated sequences. There is an intimate connection between the efficiency of andi and its limitation to closely related sequences: andi approximates local alignments by concatenating exact matches. Looking up exact matches is fast, but this strategy breaks down for divergent sequences where homologous matches become shorter than random matches. This phenomenon is also the reason why fast genome alignment programs like mauve and mugsy work best when applied to closely related genomes (<ref type="bibr" target="#b1">Angiuoli and Salzberg, 2011;</ref><ref type="bibr" target="#b5">Darling et al., 2004</ref>). The accuracy and efficiency observed with simulated data carried over to the analysis of genomes. Here, we compared andi to co-phylog as Haubold (2014) had found this to be the best alignment-free distance estimator for long sequences. However, andi gave a more accurate tree when compared to the tree based on the mugsy alignment (<ref type="figure">Fig. 4</ref>). This improvement in accuracy came without a time penalty as co-phylog computed its tree 36 times faster than mugsy, while andi was a thousand times faster than the alignment. The superior speed of andi comes from the structure of its algorithm and the multithreading; without multithreading, andi would still be 1.6 times faster than co-phylog when applied to the 29 E.coli/Shigella genomes. The memory consumption of andi is strictly linear in the number of threads, while time is roughly inversely proportional to the number of threads. This gives the A B<ref type="figure">Fig. 6</ref>. Phylogeny of 3085 stains of S.pneumoniae (<ref type="bibr" target="#b3">Chewapreecha et al., 2014</ref>). A: Based on distances computed using co-phylog (<ref type="bibr" target="#b21">Yi and Jin, 2013</ref>user the opportunity to trade speed for memory and processors, depending on the hardware available. Aligning the 109 genomes of E.coli ST131 took mugsy 5.6 days and 52.7 GB RAM. Compare this to the 5 h 33 min it took mugsy to align 29 E.coli genomes. In other words, a 3.8 times larger sample took 24.6 times longer to align. In contrast, andi took with 1 min, 21 s only 4.1 times longer, yielding the correct classification of strains into clades A–C in<ref type="figure" target="#fig_3">Figure 5</ref>. Moreover, the memory requirement of mugsy grew 18-fold, while that of andi grew by only 7% to 7.7 GB. These comments are not meant to imply that the mugsy alignment computed in the original study was superfluous; it was used for a number of analyses apart from phylogeny reconstruction, including the detection of horizontal gene transfer (<ref type="bibr" target="#b17">Petty et al., 2014</ref>). However, quick clustering of genomes is useful, if only as a quality control step. For our final application, we chose the set of 3085 genomes of S.pneumoniae, because here an alignment program like mugsy would run far longer than anyone is willing to wait. The current method for comparing sets of bacterial genomes this size is mapping the reads to a reference genome. There is some debate as to the accuracy of the resulting trees (<ref type="bibr" target="#b2">Bertels et al., 2014</ref>). andi takes as input assembled contigs, which are generated from the raw reads early on in all genome sequencing projects. Given these contigs, andi analyses them in 7 h and 35 min using 23.8 GB RAM on a 32 processor computer. Such computing resources are available in most genomics labs. The three outlier strains identified by andi are identical to those found by co-phylog after a 36.5 days run. This is gratifying and underlines the usefulness of our program.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Exact matches of a given minimum length (anchors) between query (Q) and subject (S) sequences. A: Equally spaced anchors; here we count the mismatches in the intervening segment. B: Unequally spaced anchors; these are ignored in the distance computation. (Color version of this figure is available at Bioinformatics online.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>increasing size: 1. Twenty-nine E.coli/Shigella genomes used by Yi and Jin (2013) for benchmarking, average length 4.9 Mbase; 2. One hundred and nine E.coli ST131 genomes, average length 5.2 Mbase (Petty et al., 2014); 3. Three thousand and eighty-five S.pneumoniae genomes, average length 2.2 Mbase (Chewapreecha et al., 2014).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.3.Fig.2.</head><figDesc>Fig. 3. Time (A) and memory (B) consumption as a function of sequence length. Single pairs of sequences were simulated with 0.01 or 0.1 substitutions per site and analysed. (Color version of this figure is available at Bioinformatics online.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.5.</head><figDesc>Fig. 5. The phylogeny of 109 E.coli ST131 strains based on da computed from complete genome sequences. Clades A–C colored online as defined by Petty et al. (2014). (Color version of this figure is available at Bioinformatics online.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>Fig. 6. Phylogeny of 3085 stains of S.pneumoniae (Chewapreecha et al., 2014). A: Based on distances computed using co-phylog (Yi and Jin, 2013); B: based on da. Arrows highlight strains discussed in the text. (Color version of this figure is available at Bioinformatics online.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>V C The Author 2014. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 1169 Bioinformatics, 31(8), 2015, 1169–1175 doi: 10.1093/bioinformatics/btu815 Advance Access Publication Date: 10 December 2014 Original Paper</figDesc><table></table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">B.Haubold et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>We thank Angelika Bö rsch-Haubold and Frederic Bertels for comments on the manuscript.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Basic local alignment search tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="403" to="410" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Mugsy: fast multiple alignment of closely related whole genomes</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">V</forename>
				<surname>Angiuoli</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="334" to="342" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Automated reconstruction of whole-genome phylogenies from short-sequence reads</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Bertels</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1077" to="1088" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Dense genomic sampling identifies highways of pneumococcal recombination</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Chewapreecha</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="305" to="309" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Detecting phylogenetic signals in eukaryotic whole genome sequences</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Cohen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Chor</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="945" to="956" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Mauve: multiple alignment of conserved genomic sequence with rearrangement</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">C E</forename>
				<surname>Darling</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1394" to="1403" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient estimation of pairwise distances between genomes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Domazet-Lošo</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Haubold</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="3221" to="3227" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<monogr>
		<title level="m" type="main">Inferring Phylogenies</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Felsenstein</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<pubPlace>Sinauer, Sunderland, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">PHYLIP (phylogeny interference package) version 3.6 A new succinct representation of rmqinformation and improvements in the enhanced suffix array</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Felsenstein</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Fischer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Heun</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lect. Notes Comput. Sc</title>
		<imprint>
			<biblScope unit="volume">4614</biblScope>
			<biblScope unit="page" from="459" to="470" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Alignment-free phylogenetics and population genetics</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Haubold</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="407" to="418" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Estimating mutation distances from unaligned genomes</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Haubold</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1487" to="1500" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">An alignment-free test for recombination</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Haubold</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="3121" to="3127" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">TimeTree: a public knowledge-base of divergence times among organisms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">B</forename>
				<surname>Hedges</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="2971" to="2972" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<monogr>
		<title level="m" type="main">Evolution of protein molecules</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">H</forename>
				<surname>Jukes</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">R</forename>
				<surname>Cantor</surname>
			</persName>
		</author>
		<editor>H.N., Munro</editor>
		<imprint>
			<date type="published" when="1969" />
			<publisher>Mammalian Protein Metabolism Academic Press</publisher>
			<biblScope unit="page" from="21" to="132" />
			<pubPlace>NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Versatile and open software for comparing large genomes</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">kmacs: the k-mismatch average common substring approach to alignment-free sequence comparison</title>
		<author>
			<persName>
				<forename type="first">C.-A</forename>
				<surname>Leimeister</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Morgenstern</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Molecular Evolution WWW-Query: an on-line retrieval system for biological sequence banks</title>
		<author>
			<persName>
				<forename type="first">W.-H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<surname>Sinauer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Ma</forename>
				<surname>Sunderland</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">G</forename>
				<surname>Ohlebusch</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Gouy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics Algorithms. Enno Ohlebusch. Perrière, Biochimie</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="364" to="369" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Global dissemination of a multidrug resistant Escherichia coli clone</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">K</forename>
				<surname>Petty</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the National Academy of Sciences</title>
		<meeting>the National Academy of Sciences<address><addrLine>USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="5694" to="5699" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Comparison of phylogenetic trees</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">F</forename>
				<surname>Robinson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">R</forename>
				<surname>Foulds</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Biosci</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="514" to="525" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">The average common substring approach to phylogenomic reconstruction</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Ulitsky</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="336" to="350" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Fixed-parameter algorithms for maximum agreement forests</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Whidden</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="1421" to="1466" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Co-phylog: an assembly-free phylogenomic approach for closely related organisms</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Yi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Jin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page">75</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>