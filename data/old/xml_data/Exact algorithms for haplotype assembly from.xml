
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:42+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Genome analysis Exact algorithms for haplotype assembly from whole-genome sequence data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2013">2013</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName>
								<forename type="first">Zhi-Zhong</forename>
								<surname>Chen</surname>
							</persName>
							<email>zzchen@mail.dendai.ac.jp or cswangl@cityu.edu.hk</email>
							<affiliation key="aff0">
								<orgName type="department">Division of Information System Design</orgName>
								<orgName type="institution">Tokyo Denki University</orgName>
								<address>
									<postCode>350-0394</postCode>
									<settlement>Saitama</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Fei</forename>
								<surname>Deng</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">City University of Hong Kong</orgName>
								<address>
									<addrLine>83 Tat Chee Avenue</addrLine>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Lusheng</forename>
								<surname>Wang</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">City University of Hong Kong</orgName>
								<address>
									<addrLine>83 Tat Chee Avenue</addrLine>
									<settlement>Hong Kong</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Genome analysis Exact algorithms for haplotype assembly from whole-genome sequence data</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">29</biblScope>
							<biblScope unit="issue">16</biblScope>
							<biblScope unit="page" from="1938" to="1945"/>
							<date type="published" when="2013">2013</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btt349</idno>
					<note type="submission">Received on February 13, 2013; revised on June 12, 2013; accepted on June 13, 2013</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Associate Editor: Michael Brudno Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Haplotypes play a crucial role in genetic analysis and have many applications such as gene disease diagnoses, association studies, ancestry inference and so forth. The development of DNA sequencing technologies makes it possible to obtain haplotypes from a set of aligned reads originated from both copies of a chromosome of a single individual. This approach is often known as haplotype assembly. Exact algorithms that can give optimal solutions to the haplotype assembly problem are highly demanded. Unfortunately, previous algorithms for this problem either fail to output optimal solutions or take too long time even executed on a PC cluster. Results: We develop an approach to finding optimal solutions for the haplotype assembly problem under the minimum-error-correction (MEC) model. Most of the previous approaches assume that the columns in the input matrix correspond to (putative) heterozygous sites. This all-heterozygous assumption is correct for most columns, but it may be incorrect for a small number of columns. In this article, we consider the MEC model with or without the all-heterozygous assumption. In our approach, we first use new methods to decompose the input read matrix into small independent blocks and then model the problem for each block as an integer linear programming problem, which is then solved by an integer linear programming solver. We have tested our program on a single PC [a Linux (x64) desktop PC with i7-3960X CPU], using the filtered HuRef and the NA 12878 data-sets (after applying some variant calling methods). With the all-hetero-zygous assumption, our approach can optimally solve the whole HuRef data set within a total time of 31 h (26 h for the most difficult block of the 15th chromosome and only 5 h for the other blocks). To our knowledge, this is the first time that MEC optimal solutions are completely obtained for the filtered HuRef dataset. Moreover, in the general case (without the all-heterozygous assumption), for the HuRef dataset our approach can optimally solve all the chromosomes except the most difficult block in chromosome 15 within a total time of 12 days. For both of the HuRef and NA12878 datasets, the optimal costs in the general case are sometimes much smaller than those in the all-heterozygous case. This implies that some columns in the input matrix (after applying certain variant calling methods) still correspond to false-heterozygous sites. Availability: Our program, the optimal solutions found for the HuRef dataset available at http://rnc.r.dendai.ac.jp/hapAssembly.html. Contact:</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>A haplotype is the sequence of SNPs in each of the two copies of a given chromosome in a diploid organism. Haplotypes are crucial for genetic analysis and have many applications such as gene disease diagnoses, association studies, ancestry inference, drug design and so forth (<ref type="bibr" target="#b3">Beckmann, 2010;</ref><ref type="bibr" target="#b6">Clark et al., 1998;</ref><ref type="bibr" target="#b15">Hoehe et al., 2000;</ref><ref type="bibr" target="#b21">Schwartz et al., 2002</ref>). Traditional approaches to obtaining haplotypes are based on genotype data from a set of individuals. The genotype data tell the status of both alleles at a position without distinguishing which one is on a specific copy of the chromosome. This approach is generally known as haplotype phasing. One can use various algorithms to infer the haplotypes (<ref type="bibr" target="#b11">Eskin et al., 2003;</ref><ref type="bibr" target="#b13">Halperin et al., 2004;</ref><ref type="bibr" target="#b23">Stephens et al., 2001;</ref><ref type="bibr" target="#b25">Wang and Xu, 2003</ref>). A drawback of this approach lies in its weakness in identifying rare and novel SNPs (<ref type="bibr" target="#b14">He et al., 2010</ref>). Besides, it is hard to verify whether the inferred haplotype is completely correct. With the development of high-throughput sequencing technologies, an alternative way to obtain the haplotypes for an individual is to combine sequence fragments, which is known as haplotype assembly (<ref type="bibr" target="#b4">Chen et al., 2008;</ref><ref type="bibr" target="#b12">Geraci, 2010;</ref><ref type="bibr" target="#b18">Li et al., 2004;</ref><ref type="bibr" target="#b20">Panconesi and Sozio, 2004;</ref><ref type="bibr" target="#b22">Schwartz, 2010;</ref><ref type="bibr" target="#b24">Wang et al., 2010;</ref><ref type="bibr" target="#b27">Xie et al., 2012</ref>). Given a set of aligned reads sequenced from the two copies of a given chromosome of a single individual, the goal of haplotype assembly is to correctly determine two haplotypes, each of which corresponding to one of the two copies of the chromosome. The haplotype assembly problem was first introduced by<ref type="bibr" target="#b16">Lancia et al. (2001)</ref>. Basically, when reads contain errors, the reads cannot be partitioned perfectly into two disjoint sets each of which consists of non-conflicting reads. To deal with errors when looking for the best reconstruction of haplotypes, one has to fix an objective function for evaluating candidate haplotypes. For this purpose, various functions such as Minimum Fragment Removal, Minimum SNP Removal, Longest Haplotype Reconstruction, Minimum Error Correction (MEC), Minimum Implicit SNP Removal and Minimum Implicit Fragment Removal have been subsequently proposed (<ref type="bibr" target="#b16">Lancia et al., 2001;</ref><ref type="bibr" target="#b19">Lippert et al., 2002</ref>). Recently,<ref type="bibr" target="#b0">Aguiar and Istrail (2012)</ref>proposed the Minimum Weighted Edge Removal function, whereas<ref type="bibr" target="#b8">Duitama et al. (2010</ref><ref type="bibr" target="#b9">Duitama et al. ( , 2012</ref>proposed the Maximum Fragments Cut function. Of special interest among the proposed functions is *To whom correspondence should be addressed. MEC, which aims at minimizing the total number of conflicts (errors) between the reads and the constructed haplotypes ðh 1 , h 2 Þ. The problem of minimizing MEC is NP hard (<ref type="bibr" target="#b5">Cilibrasi et al., 2005;</ref><ref type="bibr" target="#b19">Lippert et al., 2002</ref>). For this problem,<ref type="bibr" target="#b26">Wang et al. (2005)</ref>presented an exact algorithm based on the branch-andbound method and a genetic algorithm. A weighted version of this problem is considered by<ref type="bibr" target="#b29">Zhao et al. (2005)</ref>. In the remainder of this article, we only consider the problem of minimizing MEC.<ref type="bibr" target="#b17">Levy et al. (2007)</ref>presented the first diploid genome sequence of an individual human, J. Craig Venter, using Sanger sequencing technology. They also designed a greedy heuristic method that concatenates the reads with minimum conflicts. Their method is fast but not accurate when errors appear in reads.<ref type="bibr" target="#b1">Bansal and Bafna (2008)</ref>developed a software package (named HapCUT), and their algorithm tries to minimize the MEC score of the reconstructed haplotypes by iteratively computing maxcuts in graphs derived from the sequenced fragments.<ref type="bibr" target="#b1">Bansal et al. (2008)</ref>designed a Markov chain Monte Carlo algorithm (named HASH). Both HASH and HapCut work well in practice, but there is no guarantee of finding optimal haplotypes. Recently,<ref type="bibr" target="#b14">He et al. (2010)</ref>proposed a dynamic programming algorithm for the problem that runs in time Oð2 k mnÞ, where k is the length of the longest read, m is the number of reads and n is the total number of SNPs in the haplotypes. Their experiments show that their algorithm works well when k 15. On the other hand, when k is large, they model the problem as a MaxSAT problem, which is then solved by a MaxSAT solver. To compare their MaxSAT approach with the previous methods, they use the filtered HuRef dataset from<ref type="bibr" target="#b17">Levy et al. (2007)</ref>over 22 chromosomes. Via experiments, they show that their program can construct better haplotypes than the previous programs by<ref type="bibr" target="#b2">Bansal and</ref><ref type="bibr" target="#b1">Bafna (2008) and</ref><ref type="bibr" target="#b17">Levy et al. (2007)</ref>. It is worth pointing out that to solve the problem for the 22 chromosomes, their program takes a total time of $15h on a PC cluster. Moreover, their program does not solve the problem exactly because it excludes certain reads (3725 reads in total) from consideration. Furthermore, their program fails to find optimal haplotypes for a total of eight blocks of the 22 chromosomes. In this article, we develop a new approach to optimally solving the problem. In our approach, we first use new methods to decompose the input read matrix into small independent blocks and then model the problem for each block as an integer linear programming (ILP) problem, which is then solved by an ILP solver [such as CPLEX (IBM ILOG CPLEX Optimizer) and GLPK(GNU Linear Programming Kit)]. We have tested our program on a single PC [namely, a Linux (x64) desktop PC with i7-3960X CPU], using the filtered HuRef dataset. Our experimental results show that our program can optimally solve all the chromosomes within a total time of 31 h (26 h for the most difficult block of the 15th chromosome and only 5 h for the other blocks). To our knowledge, this is the first time that optimal haplotypes under the MEC model are completely obtained for the filtered HuRef dataset. Moreover, to find almost optimal haplotypes within much shorter time for the difficult blocks, we propose several powerful heuristic methods.<ref type="bibr" target="#b28">Wu et al. (2009)</ref>have generalized the problem by removing the all-heterozygous assumption to handle the existence of a small number of homozygous sizes in the solution. The generalized problem is much harder because it allows many more candidate haplotypes. Nevertheless, we develop a program that can optimally solve the generalized problem for all the 22 chromosomes of the filtered HuRef dataset except the most difficult block of the 15th chromosome within a total time of 12 days. As far as we know, this is the first strike on computing optimal solutions for the HuRef dataset without the all-heterozygous assumption. Moreover, to find almost optimal haplotypes within much shorter time for the difficult blocks, we propose several powerful heuristic methods. Via experiments with the simulated dataset of Geraci (2010), we show that an optimal solution for the general case of the problem achieves a better reconstruction rate than an optimal solution for the all-heterozygous case of the problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The haplotype assembly problem</head><p>For convenience, we define a ternary string to be a string whose characters each belong to f0, 1, Àg. The extended Hamming distance between two ternary strings s and t, denoted by dðs, tÞ, is the total number of positions p at which both characters of s and t belong to f0, 1g, but they are different. Two binary strings h and h 0 of the same length are complementary if the bit of h at every position is different from the bit of h 0 at the same position. In the haplotype assembly problem, we are given a matrix of X whose entries each belong to f0, 1, Àg (i.e. each row of X is a ternary string). Supplementary Table S1 shows an example X. Such an X is constructed from a given reference genome sequence and the set of reads containing sequence from both chromosomes, by aligning all the reads to the reference genome and then applying some SNP/variant calling methods. See Section 2 of the Supplementary Material for details. Each row of X corresponds to a read, whereas each column corresponds to an SNP site. The first (last, respectively) entry of a read that is not a 'À' is called the start (end, respectively) position of the read. There can exist 'À's between the start and the end positions of a read. Such 'À's are called gaps of the read because they either correspond to missing data or serve as gaps to connect disjoint parts of the read. If a read has no gap, it is called a gapless read; otherwise, it is called a gapped read. Moreover, if the gaps of a gapped read appear consecutively, then it is called a paired-end read; otherwise, it is called a multi-gapped read. The length of a read is j e À j s þ 1, where j e and j s are the end and the start positions of the read, respectively. Given X, we want to compute the unknown haplotypes, which are an unordered pair H ¼ ðh, h 0 Þ of binary strings each of length n, where n is the number of columns in X. Such a pair is called a solution of X. As the haplotypes are unknown and there are many solutions for them, we need a criterion for evaluating solutions. The MEC score is such a criterion and is defined as follows: Given X, the MEC score of a solution H ¼ ðh, h 0 Þ of X is P m i¼1 min È dðr i , hÞ, dðr i , h 0 Þ É , where m is the number of rows in X and r i is the ith row of X. Given X, the haplotype assembly problem asks for a solution of X whose MEC score is minimized. Such a solution is called an optimal solution of X. For convenience, we say that a row of X is useless if every entry in the row is a 'À' and is useful otherwise. Clearly, the removal of useless rows from X does not change the problem. Moreover, we say that a column of X is monotone if 0 or 1 does not appear in the column. Obviously, if the jth column of X contains no 0's (1's, respectively), then X has an optimal solution ðh, h 0 Þ such that the jth bits of h and h 0 are 1's (0's, respectively). Recall that a diploid organism has two alleles at each position. An SNP site is homozygous if the two alleles at this site are identical; otherwise, it is heterozygous. When the reads contain no errors, a homozygous SNP site corresponds to a monotone column in X, whereas a heterozygous SNP site corresponds to a non-monotone column in X. However, when reads contain errors at a homozygous SNP site, the corresponding column can also be non-monotone. Therefore, we may hereafter make the following assumptions: A1. No row of X is useless. A2. No column of X is monotone. A3. No column of X contains more 1's than 0's.</p><p>We make Assumption A3 only for a technical reason. If the jth column of X contains more 1's than 0's, then we can modify the column by flipping 1's and 0's so that each solution ðh, h 0 Þ of the modified X can be transformed back to a solution of the original X with the same MEC score by flipping the jth bits of h and h 0. Therefore, it does not matter to instead assume that no column of X contains more 0's than 1's. Assumption A2 ensures that all the columns of X contain both 0's and 1's. However, some originally homozygous sites may also be included in X owing to errors in the reads. Given a solution ðh, h 0 Þ of X, we can obtain a bipartition ðH, H 0 Þ of the rows in X as follows. Each row r i of X with dðr i , hÞ dðr i , h 0 Þ belongs to H, whereas each row r i of X with dðr i , hÞ4dðr i , h 0 Þ belongs to H 0. Consider an arbitrary integer j 2 f1, 2,. .. , ng. Let h j, 0 (h j, 1 , respectively) be the number of rows r i in H such that the entry in the jth column of r i is a 0 (1, respectively). Similarly, let h 0 j, 0 (h 0 j, 1 , respectively) be the number of rows r i in H 0 such that the entry in the jth column of r i is a 0 (1, respectively). We define the contribution of the jth column of X to the MEC score of ðh, h 0 Þ as follows: Let h j and h 0 j be the jth bit of h and h 0 , respectively. If h j h 0 j is 00 (11, 01 or 10, respectively), then the contribution is h j, 1 þ h 0 j, 1 (h j, 0 þ h 0 j, 0 , h j, 1 þ h 0 j, 0 or h j, 0 þ h 0 j, 1 , respectively). The MEC score of ðh, h 0 Þ is the total contribution of the columns of X.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The all-heterozygous case</head><p>Recall that each column of X is not monotone based on Assumption A2. When there is no error, every non-monotone column in X should correspond to a heterozygous site in the solution. When errors occur, it is still true that most of the columns in X correspond to heterozygous sites in the solution. This motivates researchers to assume that all sites corresponding to the columns in X are heterozygous, i.e. we should search for solutions ðh, h 0 Þ of X such that h and h 0 are complementary (<ref type="bibr" target="#b14">He et al., 2010</ref>). In this subsection, we show how to solve this case by reductions and ILP. For each pair of integers ðj 1 , j 2 Þ with 1 j 1 j 2 n, we use X½j 1 , j 2  to denote the submatrix of X consisting of the j 1 th, ðj 1 þ 1Þst ,. .. , j 2 th columns of X. For brevity, we simply use X½j to denote X½j, j. Block reduction: Like most of the existing methods for the problem, we split the whole chromosome into a set of column-disjoint blocks such that no read starts and ends at different blocks. This reduction can be done in time linear in the total length of reads in X. Many rows of the blocks are useless and can be removed immediately. A singular block is a useful block consisting of a single column. Singular blocks can be ignored because the problem for them is trivially solved. Block decomposition: Suppose that B is a block of X with ' columns.</p><p>Consider an integer j with 15j5'. If there is no read r in B such that j is greater than the start position of r but less than the end position of r, then we say that B½j is a splittable column. Suppose that the splittable columns of B are B½j 1 , B½j 2  ,. .. , B½j k . Then, the submatrices B½1, j 1 , B½j 1 , j 2 , B½j 2 , j 3  ,. .. , B½j kÀ1 , j k , B½j k , ' are called unsplittable blocks of X. Many rows of these blocks are useless and can be removed immediately. An important observation is that we can solve the problems for these blocks independently (say, in parallel) and then concatenate their optimal solutions ðh 1 , h 0 1 Þ, ðh 2 , h 0 2 Þ ,. .. , ðh kþ1 , h 0 kþ1 Þ into an optimal solution ðh, h 0 Þ of B as follows. Consider an integer i with 1 i k. As h i and h 0 i are complementary, one of them ends with a 0 and the other ends with a 1. Similarly, one of h iþ1 and h 0 iþ1 starts with a 0 and the other starts with a 1. Therefore, the last character of h i is the same as the first character of h iþ1 or h 0 iþ1. We assume that the last character of h i is the same as the first character of h iþ1 ; the other case is similar. Then, we can concatenate ðh i , h 0 i Þ and ðh iþ1 , h 0 iþ1 Þ by (1) deleting the last character of h i and then appending h iþ1 to h i and (2) deleting the last character of h 0 i and then appending h 0 iþ1 to h 0 i. This shows that we can reduce the original problem for B to the smaller problems for B½1, j 1 , B½j 1 , j 2 , B½j 2 , j 3  ,. .. , B½j kÀ1 , j k , B½j k , '. We call this reduction block decomposition. It can be done in time linear in the total length of reads in B. Singleton removal: Suppose that C is an unsplittable block of X. A row in C is singular if the start and the end positions of the read corresponding to the row are the same. Obviously, the removal of a singular row from C does not change the MEC score of an optimal solution of C. Therefore, we can reduce the problem for C to a smaller problem by removing all singular rows from C. This type of reduction is called singleton removal and can be done in time linear in the total length of reads in C. Duplicate removal: Suppose that C is an unsplittable block of X. Duplicate removal is the reduction that repeats modifying C as follows, until no two rows or columns of C are identical:</p><p>(1) Merge identical rows into a single row and memorize the original multiplicity of the row. (Of course, if a row is originally identical to no other row, then its multiplicity is 1.</p><p>)</p><p>(2) Merge identical columns into a single column and memorize the original multiplicity of the column. (Of course, if a column is originally identical to no other column, then its multiplicity is 1.)</p><p>Duplicate removal can be done in OðL log kÞ time, where k is the number of reads in C and L is the total length of reads in C. Solving reduced-blocks via ILP: A reduced block of X is an unsplittable block of X without singular rows, identical rows or identical columns. Suppose that D is a reduced block of X. To solve the problem for D, we formulate the problem as an ILP problem and then solve it using CPLEX of IBM, which is a freely available ILP solver for academic research. Let p (q, respectively) be the number of rows (columns, respectively) of D. For each integer j with 1 j q, let c j be the multiplicity of D½j. Similarly, for each integer i with 1 i p, let w i be the multiplicity of the ith row of D, and J i, 0 (J i, 1 , respectively) be the set of integers j 2 f1, 2,. .. , qg such that the ith entry in D½j is a 0 (1, respectively). As we want to compute an optimal pair ðh, h 0 Þ of complementary haplotypes for D, we introduce a binary variable x j for D½j whose value is supposed to be 1 if and only if the jth bit of h is a 1 (and hence the jth bit of h 0 is a 0). Moreover, we introduce a binary variable y i for the ith row of D whose value is supposed to be 1 if and only if the read corresponding to r i is aligned to h, where r i is the ith row of D. Then, the problem of finding an optimal pair ðh, h 0 Þ of complementary haplotypes for D becomes the following integer programming problem:</p><formula>Minimize X p i¼1 w i X j2Ji,0 c j x j y i þ ð1 À x j Þð1 À y i Þ À Á þ X p i¼1 w i X j2Ji,1 c j ð1 À x j Þy i þ x j ð1 À y i Þ À Á</formula><p>Subject to 8 1 i p y i 2 f0, 1g 8 1 j q x j 2 f0, 1g</p><p>The aforementioned integer programming problem is not linear because it contains quadratic terms such as x j y i. Therefore, for each pair ði, jÞ with 1 i p and 1 j q, we introduce a binary variable t i, j (for replacing x j y i ) and add the following three constraints to ensure that t i, j ¼ y i x j :</p><formula>t i, j y i t i, j x j t i, j ! y i þ x j À 1</formula><p>The resulting ILP formulation is given in the Supplementary Material. It is easy to construct the ILP from D in O(Lp) time, where L is the total length of reads in D. A powerful heuristic for hard blocks: Let C be an unsplittable block of X. Our experiments will show that performing singleton and duplicate removal on C usually yields a reduced block D of X such that D is small enough that the aforementioned ILP problem for D can be solved by CPLEX within several seconds on a single PC. However, although rare, it is possible that the aforementioned ILP problem for D cannot be solved by CPLEX within several hours. In this case, we can solve the problem for C heuristically as follows.</p><p>(1) First, we choose an integer j with 1 j5q, where q is the number of columns in C. We refer to j as the cut position. The choice of the cut position is important, and we will detail how to choose it later.</p><p>(2) Then, we perform singleton and duplicate removal on C½1, j and C½ðj þ 1Þ, q and further use CPLEX to solve the smaller problems for the two resulting reduced blocks independently (say, in parallel) to obtain optimal solutions ðh j, 1 , h 0 j, 1 Þ and ðh j, 2 , h 0 j, 2 Þ for C½1, j and C½ðj þ 1Þ, q. Let s j, 1 and s j, 2 be the MEC scores of the two solutions. Obviously, s j, 1 þ s j, 2 is a lower bound on the MEC score of an optimal solution of C.</p><p>(3) We concatenate the solutions obtained in Step 2 to obtain two solutions ðh j, 1 h j, 2 , h 0 j, 1 h 0 j, 2 Þ and ðh j, 1 h 0 j, 2 , h 0 j, 1 h j, 2 Þ of C. Unfortunately, it is often the case that neither solution has a MEC score close to the lower bound s j, 1 þ s j, 2. Therefore, we refer to them as the raw solutions for C associated with j and will design a method for refining them. Finally, among the two refined solutions, we output the one with the smaller MEC score. For choosing the cut position, we propose the following two methods: C1. For each j 2 f1,. .. , q À 1g, we use an approximation algorithm to estimate the MEC score s 0 j, 1 (s 0 j, 2 , respectively) of an optimal solution of C½1, j (C½ðj þ 1Þ, q, respectively). We measure the quality of j by js 0 j, 1 À s 0 j, 2 j. By trying all j 2 f1,. .. , q À 1g, we can find the j with the best quality. The intuition behind this choice of the cut position is that if s 0 j, 1 and s 0 j, 2 are close, then it takes roughly the same amount of time to solve the problems for C½1, j and C½ðj þ 1Þ, q. Thus, we refer to this choice as the balanced choice of the cut position. Basically, this choice aims at shortening the running time.<ref type="bibr" target="#b7">Deng et al. (2013)</ref>have recently designed an approximation algorithm for estimating the MEC score. C2. Let p be the number of rows in C. For each j 2 f1,. .. , q À 1g, we find the set R j of integers i 2 f1,. .. , pg such that f i j5t i , where f i and t i are the start and the end positions of the read corresponding to the ith row of C, respectively. For each i 2 R j , we also calculate</p><formula>e i, j ¼ minfj À f i þ 1, t i À jg. We further calculate e j ¼ P i2Rj e i, j. For</formula><p>example, if C is the unsplittable block in the bottom of the matrix in<ref type="figure" target="#tab_2">Table 2</ref>in the Supplementary Material, then R 2 ¼ f3, 4g, e 3, 2 ¼ 2, e 4, 2 ¼ 1 and e 2 ¼ 3. It is not hard to see that the MEC score of each raw solution of C associated with j does not exceed e j þ s j, 1 þ s j, 2 , where s j, 1 and s j, 2 are the MEC scores of optimal solutions of C½1, j and C½ðj þ 1Þ, q, respectively. Thus, e j þ s j, 1 þ s j, 2 is an upper bound on the MEC score of an optimal solution of C. Also recall that s j, 1 þ s j, 2 is a lower bound on the MEC score of an optimal solution of C. Hence, the smaller e j is, the closer the two bounds are. Therefore, by trying all j 2 f1,. .. , q À 1g, we can find the integer j that minimizes e j. Unfortunately, such a j is usually either close to 1 or close to q and hence either the problem for C½1, j or the problem for C½ðj þ 1Þ, q remains hard to solve. Therefore, instead of trying all j 2 f1,. .. , q À 1g, we choose a real number " with 0550:5 (say, 0.1) and only try all j 2 fq,. .. , ð1 À Þqg to find the integer j with the smallest e j. We refer to this choice as the unbalanced choice of the cut position. For the purpose of refining a raw solution ðh, h 0 Þ of C associated with the cut position j, we design a subroutine (named Majority), which repeats the following steps until ðh, h 0 Þ does not change any more.</p><p>(a) For each read i 2 f1,. .. , pg, we compute dðr i , hÞ and dðr i , h 0 Þ, where r i is the ith row of C.</p><p>If dðr i , hÞ dðr i , h 0 Þ, we align r i to h; otherwise, we align r i to h 0. In this way, each row is aligned to one of h and h 0. Let S (S 0 , respectively) be the set of rows aligned to h (h 0 , respectively).</p><p>(b) For each j 2 f1,. .. , qg, we compute the total number j, 0 ( j, 1 , respectively) of rows r i 2 S such that the jth entry in r i is a 0 (1, respectively), and we also compute the total number 0 j, 0 ( 0 j, 1 , respectively) of rows r i 2 S 0 such that the jth entry in r i is a 0 (1, respectively). Let b j 2 f0, 1g be the jth bit of h. Note that 1 À b j is the jth bit of h 0. Also note that C½j contributes j, 1Àbj þ 0 j, bj to the MEC score of ðh, h 0 Þ. Similarly, if we flip the jth bits of h and h 0 , then C½j contributes j, bj þ 0 j, 1Àbj to the MEC score of ðh, h 0 Þ. Thus, we check whether j, 1Àbj þ 0 j, bj 4 j, bj þ 0 j, 1Àbj. If this inequality holds, then we flip the jth bits of h and h 0. Majority usually refines a raw solution ðh, h 0 Þ of C associated with the cut position j so that its MEC score becomes significantly smaller. To enhance Majority, we propose the following random-sampling approach. First, we choose a large enough number , say ¼ 100 Ã s, where s is the current MEC score of ðh, h 0 Þ. Then, we repeat the following three steps times:</p><p>(1) Calculate the current MEC score s of ðh, h 0 Þ and select (not necessarily distinct) integers j 1 , j 2 ,. .. , j each uniformly at random from f1, 2,. .. , qg, where ¼ 0:1s b c.</p><p>(2) Let j 0 1 , j 0 2 ,. .. , j 0 ' be the distinct integers among j 1 , j 2,. .. , j. Obtain a new solution ð ^ h, ^ h 0 Þ of C by flipping the j 0 i th bits of h and h 0 for all j 0 i with 1 i '.</p><p>(3) Call Majority to refine the solution ð ^ h, ^ h 0 Þ. If the MEC score of the refined ð ^ h, ^ h 0 Þ is smaller than s, then update ðh, h 0 Þ to ð ^ h, ^ h 0 Þ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The general case</head><p>Ideally, the input matrix X should only contain heterozygous sites for the specific individual. However, accurately identifying the set of heterozygous sites of an individual is extremely difficult. Most of the existing methods choose non-monotone columns to form X. This is based on the observation that when each read contains no errors, a non-monotone column corresponds to a heterozygous site and a monotone column corresponds to a homozygous site. However, in practice, reads may contain a (small) number of errors. Thus, some homozygous sites may also lead to non-monotone columns, and those non-monotone columns corresponding to homozygous sites are also included in the input matrix X. To deal with this problem, we have to consider the general case where each site in the solution ðh, h 0 Þ can be either homozygous or heterozygous. See the Supplementary Material for details. In this case, neither block decomposition nor singleton removal is applicable anymore because some sites corresponding to the columns of X may be homozygous, and hence an optimal solution ðh, h 0 Þ of X may not be complementary. For each j 2 f1, 2,. .. , ng, we say that the jth column of X is intrinsically heterozygous if for every optimal solution ðh, h 0 Þ of X, we can modify the jth bits of h and h 0 without losing the optimality so that the jth bit of h is different from that of h 0. An intrinsically heterozygous column is useful because as in the all-heterozygous case, it can be used to perform singleton removal and is also possibly a splittable column for block decomposition. We next consider how to find heterozygous columns. Finding intrinsically heterozygous columns: For each j 2 f1, 2,. .. , ng, we compute the total number j, 0 ( j, 1 , respectively) of rows r i in X such that the entry in the jth column of r i is a 0 (1, respectively), and further compute the number s j, 0 ( s j, 1 , respectively) of non-singular rows r i in X such that the jth entry in r i is a 0 (1, respectively). LEMMA 1. Suppose that j 2 f1, 2,. .. , ng satisfies minf j, 0 , j, 1 g ! sj,0þ sj,1 2 j k . Then, X½j is intrinsically heterozygous. PROOF. See Section 5 of the Supplementary Material. For example, LEMMA 1 ensures that the first six columns of the matrix in Supplementary Table S2 are intrinsically heterozygous. Block reduction: This is same as that in the all-heterozygous case. Block decomposition: This is almost the same as that in the all-heterozygous case. The only difference is in the definition of a splittable column of a block B. Specifically, the new definition of a splittable column B½j of B requires that the jth column of B be intrinsically heterozygous. Singleton removal: This is almost the same as that in the allheterozygous case. The only difference is that instead of removing all singular rows, we only remove those singular rows r i such that the read corresponding to r i starts and ends at an intrinsically heterozygous column. Duplicate removal: This is the same as that in the all-heterozygous case. Solving reduced-blocks via ILP: Similar to the all-heterozygous case, we can obtain an ILP formulation for the general case. The only difference is that for each column D½j of D that is not known to be intrinsically heterozygous, we need to introduce two binary variables x j and z j (instead of one for the all-heterozygous case) such that the value of x j (z j , respectively) is supposed to be 1 if and only if the jth bit of h (h 0 , respectively) is a 1. For lack of space, we detail the ILP formulation in the Supplementary Material. It is worth pointing out that Wu et al. (2009) has also given an ILP formulation for the problem. However, their ILP formulation contains non-binary variables. Moreover, finding intrinsically heterozygous columns and merging identical columns enable us to use fewer variables than theirs. Consequently, ours can be solved within shorter time. A powerful heuristic for hard blocks: This is almost the same as that in the all-heterozygous case. There are only two differences. The first is in Step (b) of the Majority subroutine, which should be modified as follows.</p><p>(b) For each j 2 f1,. .. , qg, we compute the total number j, 0 ( j, 1 , respectively) of rows r i 2 S such that the entry in the jth column of r i is a 0 (1, respectively), and we also compute the total number 0 j, 0 ( 0 j, 1 , respectively) of rows r i 2 S 0 such that the entry in the jth column of r i is a 0 (1, respectively). Let b j 2 f0, 1g (b 0 j , respectively) be the jth bit of h (h 0 , respectively). If j, 1Àbj 4 j, bj , then we flip the jth bit of h.</p><formula>Furthermore, if 0 j, 1Àb 0 j 4 0 j, b 0 j</formula><p>, then we flip the jth bit of h 0 .</p><p>The other difference is in the random-sampling approach, whose last two steps should be modified as follows.</p><formula>(1) Let j 0 1 , j 0 2 ,. .. , j 0 ' be the distinct integers among j 1 , j 2,. .. , j. Obtain a new solution ð ^ h, ^ h 0 Þ of D by performing the following step for all j 0 i with 1 i ':</formula><p>If the j 0 i th column of D is intrinsically heterozygous, then flip the j 0 i th bits of h and h 0 ; otherwise, choose one of h and h 0 uniformly at random and flip its j 0 i th bit.</p><p>(2) Call the modified Majority subroutine to refine ð ^ h, ^ h 0 Þ. If the MEC score of the refined ð ^ h, ^ h 0 Þ is smaller than s, then update ðh, h 0 Þ to</p><formula>ð ^ h, ^ h 0 Þ.</formula><p>Another powerful heuristic for hard blocks: The ILP formulation of the all-heterozygous case has fewer variables and constraints than that of the general case and hence can usually be solved within much shorter time. Therefore, a natural heuristic for hard reduced-blocks D in the general case is as follows. First, we solve the problem for D by assuming that all columns of D are heterozygous. This yields a raw solution ðh, h 0 Þ of D. We then use the modified Majority subroutine and the random-sampling approach to refine ðh, h 0 Þ. Our experiments will show that this heuristic often finds a solution of D whose MEC score is extremely close to optimal. A drawback of this heuristic is that it does not give any lower bound on the MEC score of an optimal solution of D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS AND DISCUSSION</head><p>To evaluate our methods empirically, we run our program on a Linux (x64) desktop PC with i7-3960X CPU and 31.4GiB RAM. In our experiments, we use three datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The filtered HuRef dataset</head><p>The filtered HuRef dataset over 22 chromosomes is generated by<ref type="bibr" target="#b17">Levy et al. (2007)</ref>. Some simple variant calling method has been applied to form the matrices in the dataset (<ref type="bibr" target="#b17">Levy et al., 2007</ref>). The dataset has been used to compare previous methods with each other (<ref type="bibr" target="#b1">Bansal and Bafna, 2008;</ref><ref type="bibr" target="#b1">Bansal et al., 2008;</ref><ref type="bibr" target="#b14">He et al., 2010;</ref><ref type="bibr" target="#b17">Levy et al., 2007</ref>). This dataset is known to be hard to solve. Indeed, He et al. (2010)'s program takes 15 h on a PC cluster to only roughly solve the all-heterozygous case of the problem for the dataset. In particular, their program excludes multi-gapped reads (3725 in total) and fails to solve a total of eight hard blocks. As each of the 22 chromosomes has a large number of SNP sites and a huge number of reads, it is effective to cut each of them into as many smaller independent blocks as possible. Block reduction has been used for this purpose in previous studies (<ref type="bibr" target="#b14">He et al., 2010</ref>). In contrast, to our knowledge, block decomposition has not been used for this purpose before. For the all-heterozygous (general, respectively) case, Supplementary<ref type="figure">Table S6</ref>(Supplementary<ref type="figure">Table S7</ref>, respectively) summarizes the numbers of non-singular blocks of the 22 chromosomes obtained by block reduction only and by both block reduction and block decomposition, respectively. As can be seen from the tables, block decomposition enables us to cut the nonsingular blocks (obtained by block reduction only) of a chromosome into many smaller blocks. When we use CPLEX to solve each reduced-block in the allheterozygous (general, respectively) case of the problem, we set a time limit of 10 (20, respectively) min. As the result, CPLEX fails to solve only three (seven, respectively) reduced-blocks optimally within the time limit. The three (seven, respectively) blocks are shown in the first (second, respectively) part of Supplementary<ref type="figure">Table S8</ref>. As they are hard, we use the (first) heuristic detailed in Section 2.2 (Section 2.3, respectively) to find heuristic solutions for them. The results are summarized in the same table from which we can see that our heuristics can find solutions extremely close to optimal for hard reduced-blocks. Excluding these hard blocks, our program can solve the all-heterozygous (general, respectively) case of the problem for the 22 chromosomes within a total of 3 h (5, respectively) on the PC. The running times and the optimal MEC scores for the 22 chromosomes for the all-heterozygous case and the general case are summarized in<ref type="figure" target="#tab_1">Table 1</ref>, where one can see that the scores for the general case are significantly smaller than those for the all-heterozygous case. This indicates that the number of homozygous sites included in the input matrix cannot be ignored. In Table 1, we also compare our program with HapCUT (<ref type="bibr" target="#b1">Bansal and Bafna, 2008</ref>). It is worth noting that HapCUT uses randomness and hence different runs of HapCUT on the same input may generate different outputs. Therefore, for each chromosome in the HuRef dataset, we ran HapCUT 10 times, where each run was given the default maximum number (namely, 100) of iterations. Consequently, for each chromosome in the dataset, the running time of HapCUT in<ref type="figure" target="#tab_1">Table 1</ref>is the total time of the 10 runs, whereas the score of HapCUT in the table is the best score among the 10 runs. Clearly, our program spends less time than HapCUT to give optimal solutions. We also use the second heuristic in Section 2.3 to solve the general case of the problem for the seven hard reduced-blocks. The results are summarized in<ref type="figure" target="#tab_2">Table 2</ref>from which we can see that the second heuristic can find solutions close to optimal for the hard reduced-blocks within shorter time than the first heuristic, but cannot find a lower bound on the optimal MEC score.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Simulated datasets</head><p>We use part of the simulated datasets of Geraci (2010). To generate a read matrix, three parameters ', c and e are used, where ' is the number of SNPs, c is the coverage and e is the error rate. Intuitively speaking, the larger c (e, respectively) is, the more reads we have in the matrix (the larger optimal MEC score we have for the matrix, respectively). The values for ', c and e are chosen from f100, 350, 700g, f3, 5, 8, 10g and f0%, 10%, 20%, 30%g, respectively. For each combination of the three parameters, 100 read matrices are generated. A merit of each generated read matrix X is that we know its true solution ðh 1 , h 2 Þ. To evaluate the quality of a solution ð ^ h 1 , ^ h 2 Þ of X (returned by a program), the reconstruction rate of the solution is defined to be</p><formula>1 À min È dðh1, ^ h1Þþdðh2, ^ h2Þ, dðh1, ^ h2Þþdðh2, ^ h1Þ É 2'</formula><p>, where d is the Hamming-distance function. Intuitively, the larger the reconstruction rate is, the better the solution is. To compare the all-heterozygous and the general cases, we use the datasets of Geraci (2010) for those combinations ð', c, eÞ with ' 2 f100, 350g, c 2 f3, 5, 8, 10g and e 2 f0%, 10%g. It turns out that when e ¼ 0%, our exact program for both cases can find the correct solution. On the other hand, when e ¼ 10%, the solutions for the two cases found by our exact program look different (cf.<ref type="figure">Table 3</ref>). In particular, the average reconstruction rate achieved by our exact program for the general case is better than the best reconstruction rate reported by<ref type="bibr" target="#b12">Geraci (2010)</ref>, but the average reconstruction rate achieved by our exact program for the all-heterozygous case is worse. Moreover, the larger c is, the worse the average reconstruction rate achieved by our exact program for the all-heterozygous case is. Consider a homozygous site p. For a fixed error rate e, with the increase of coverage at p, the chance that errors exist for reads at site p increases and so does the chance that p corresponds to a non-monotone column. Thus, the number of columns corresponding to homozygous sites in X increases. Therefore, the larger c is, the worse the average reconstruction rate achieved by the exact program for the all-heterozygous case is. This is the reason why we have to consider the general case. Contrary to the all-heterozygous case, the general case can handle such 'false-heterozygous' sites correctly, and thus the reconstruction rate increases with more coverage for the general case. The running time of our program is also related to the coverage. With the increase of coverage, the number of errors increases and so does the MEC score. As the result, the running time increases accordingly as shown in<ref type="figure">Table 3</ref>. To see how good our heuristics for the general case are, we use the datasets of Geraci (2010) for those combinationsð', c, eÞ with ' 2 f100, 350g, c 2 f3, 5, 8, 10g and e ¼ 10%. For simplicity, we always choose the middle position as the cut position when experimenting with the first heuristic. The experimental results are summarized in<ref type="figure">Table 4</ref>. From the table, we can see that for the tested dataset, the average reconstruction rate achieved by our first (second, respectively) heuristic for the general case is better than the best reconstruction rate reported by Geraci (2010) when c ! 8 (c 5, respectively). It also turns out that for the tested dataset, the first heuristic is faster than the second. Furthermore, for those instances with c ! 5 in the tested dataset, our second heuristic always finds optimal solutions, but its average reconstruction rate is different from that of our exact program for the general case. Consequently, the optimal solutions found by our second heuristic can be different from the optimal solutions found by our exact program for the general case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The NA12878 dataset</head><p>This real dataset contains the whole-genome fosmid sequence data for an individual NA12878 (<ref type="bibr" target="#b9">Duitama et al., 2012</ref>). It is obtained by using fosmid pool-based next generation sequencing, which allows genome-wide generation of haploid DNA segments significantly larger than other standard shotgun sequencing technologies. We use the NA12878 dataset<ref type="bibr">[</ref><ref type="bibr" target="#b1">Bansal and Bafna, 2008</ref>). Our experimental results are summarized in Supplementary Table S11 from which one can see that our exact program can finish within 3 min for each of the 22 chromosomes in the dataset and is much faster than He et al. (2010)'s program. Besides, we can see that the optimal costs in the general case are smaller than those in the all-heterozygous case for all the 22 chromosomes in Supplementary Table S11. This implies that there are still some false-heterozygous columns in the filtered matrices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Discussion</head><p>Multiple optimal solutions may exist for both the all-heterozygous and the general cases. If there is no error in the reads, the optimal solution is unique. If the error rate in reads is low, the chance that the optimal solution is unique is high. However, if the error rate is high, many optimal solutions may exist. In general, enumerating all optimal solutions are much harder and takes much longer time than computing a single optimal solution. From the experiments on simulated datasets, we can see that the single optimal solution found by our exact algorithm can achieve better reconstruction rate than the previously known heuristics in most cases. Still, it remains an open problem to handle multiple optimal solutions.<ref type="figure">Table 3</ref>. Evaluating our exact program using the simulated dataset of Geraci (2010) for those combinations ð', c, eÞ with ' 2 f100, 350g, c 2 f3, 5, 8, 10g and e ¼ 10%, where column 'prev RR' shows the best average reconstruction rate reported by Geraci (2010) and columns 'org score', 'score', 'time' and 'RR' show the average MEC score of the correct solution, the average MEC score of the solution found by our exact program, the average time (in minutes) taken by our exact program, and the average reconstruction rate of our program over the 100 instances in the dataset for a particular combination ð', c, 10%Þ, respectively<ref type="figure">Table 4</ref>. Evaluating our heuristics for the general case using the simulated dataset of Geraci (2010) for those combinations ð', c, eÞ with ' 2 f100, 350g, c 2 f3, 5, 8, 10g and e ¼ 10%, where the columns mean the same as in</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>to which some variant calling method has been applied by Duitama et al. (2011)] to compare our approach with the MaxSAT approach of He et al. (2010) and HapCUT (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Table 1. The running times of our program (HapCUT, respectively) and the optimal MEC scores (heuristic MEC scores, respectively) found for the HuRef dataset, where column 'chr' shows the index number of a chromosome, column 'score' shows the MEC score and column 'time' shows the running time Chr Our program HapCUT</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 3</figDesc><table>c 
Prev 
Org 
First heuristic 
Second heuristic 

RR 
Score 
Score 
Time 
RR 
Score 
Time 
RR 

' ¼ 100 
3 
93.0 
59.1 
61.9 
0.02 
87.7 
53.4 
0.04 
99.0 
5 
98.5 
97.3 
96.8 
0.04 
98.1 
95.4 
0.12 
99.0 
8 
99.3 
157.7 
158.3 
0.11 
99.6 
157.3 
0.20 
98.8 
10 
99.8 
196.0 
195.8 
0.14 
99.9 
195.8 
0.38 
98.8 
' ¼ 350 
3 
93.0 
207.0 
195.1 
0.09 
94.3 
186.3 
0.23 
99.6 
5 
97.8 
345.6 
340.2 
0.36 
98.5 
338.4 
0.62 
99.6 
8 
99.6 
548.3 
547.1 
1.40 
99.7 
547.1 
31.5 
99.6 
10 
99.8 
682.0 
682.1 
2.43 
99.9 </table></figure>

			<note place="foot">ß The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Z-Z.Chen et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Exact algorithms for haplotype assembly at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">HapCompass: a fast cycle basis algorithm for accurate haplotype assembly of sequence data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Aguiar</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Istrail</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="577" to="590" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">HapCUT: an efficient and accurate algorithm for the haplotype assembly problem</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bansal</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bafna</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="24" to="153" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">An MCMC algorithm for haplotype assembly from whole genome sequence data</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bansal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page">1336</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Haplotype Sharing Methods</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Beckmann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In: Encyclopedia of Life Sciences (ELS</title>
		<imprint>
			<publisher>John Wiley &amp; Sons</publisher>
			<date type="published" when="2010" />
			<publisher>John Wiley &amp; Sons</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Linear time probabilistic algorithms for the singular haplotype reconstruction problem from SNP fragments</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="535" to="546" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">On the complexity of several haplotyping problems</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Cilibrasi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms in Bioinformatics Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">3692</biblScope>
			<biblScope unit="page" from="128" to="139" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Haplotype structure and population genetic inferences from nucleotide-sequence variation in human lipoprotein lipase</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Clark</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="595" to="612" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">A highly accurate heuristic algorithm for the haplotype assembly problem</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Deng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genomics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note>Suppl. . 2</note>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">ReFHap: A reliable and fast algorithm for single individual haplotyping</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Duitama</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First ACM International Conference on Bioinformatics and Computational Biology</title>
		<meeting>the First ACM International Conference on Bioinformatics and Computational Biology<address><addrLine>Niagara Falls, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="160" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Fosmid-based whole genome haplotyping of a HapMap trio child: evaluation of Single Individual Haplotyping techniques</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Duitama</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="2041" to="2053" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Towards accurate detection and genotyping of expressed variants from whole transcriptome sequencing data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Duitama</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICCABS</title>
		<meeting>ICCABS<address><addrLine>Orlando, FL, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="87" to="92" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient reconstruction of haplotype structure via perfect phylogeny</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Eskin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Bioinform. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1" to="20" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">A comparison of several algorithms for the single individual SNP haplotyping reconstruction problem</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Geraci</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="2217" to="2225" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Haplotype reconstruction from genotype data using imperfect phylogeny</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Halperin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Eskin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1842" to="1849" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Optimal algorithms for haplotype assembly from whole-genome sequence data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>He</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="183" to="190" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Sequence variability and candidate gene analysis in complex disease: association of opioid receptor gene variation with substance dependence</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Hoehe</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Hum. Mol. Genet</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="2895" to="2908" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">SNPs problems, complexity, and algorithms</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Lancia</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Annual European Symposium on Algorithms</title>
		<meeting>the 9th Annual European Symposium on Algorithms<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="2161" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">The diploid genome sequence of an individual human</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Levy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">254</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Haplotype reconstruction from SNP alignment</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">M</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="505" to="516" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Algorithmic strategies for the single nucleotide polymorphism haplotype assembly problem</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Lippert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="23" to="31" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Fast Hare: a fast heuristic for single individual SNP haplotype reconstruction</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Panconesi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Sozio</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms in Bioinformatics Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="volume">3240</biblScope>
			<biblScope unit="page" from="266" to="277" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Methods for inferring block-wise ancestral history from haploid sequences</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Schwartz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms in Bioinformatics Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="page" from="2452" to="2496" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Theory and algorithms for the haplotype assembly problem</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Schwartz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. Inform. Syst</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="23" to="38" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">A new statistical method for haplotype reconstruction from population data</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Stephens</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="978" to="989" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">A practical exact algorithm for the individual haplotyping problem MEC/GI</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="page" from="283" to="296" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Haplotype inference by maximum parsimony</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Wang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Xu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1773" to="1780" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Haplotype reconstruction from SNP fragments by minimum error correction</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">S</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="2456" to="2462" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">A fast and accurate algorithm for single individual haplotyping</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Xie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">8</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>Suppl. . 2</note>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Self-organizing map approaches for the haplotype assembly problem</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">Y</forename>
				<surname>Wu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Comput. Simul</title>
		<imprint>
			<biblScope unit="volume">79</biblScope>
			<biblScope unit="page" from="3026" to="3037" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Haplotype assembly from aligned weighted SNP fragments</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<forename type="middle">Y</forename>
				<surname>Zhao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Biol. Chem</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="281" to="287" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>