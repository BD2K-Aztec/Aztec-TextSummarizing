
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:58+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sequence analysis kmacs: the k-mismatch average common substring approach to alignment-free sequence comparison</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Chris-Andre</forename>
								<surname>Leimeister</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Bioinformatics</orgName>
								<orgName type="department" key="dep2">Institute of Microbiology and Genetics</orgName>
								<orgName type="institution">University of G € ottingen</orgName>
								<address>
									<addrLine>Goldschmidtstr. 1, 37073 G € ottingen</addrLine>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Burkhard</forename>
								<surname>Morgenstern</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Bioinformatics</orgName>
								<orgName type="department" key="dep2">Institute of Microbiology and Genetics</orgName>
								<orgName type="institution">University of G € ottingen</orgName>
								<address>
									<addrLine>Goldschmidtstr. 1, 37073 G € ottingen</addrLine>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">John</forename>
								<surname>Hancock</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="laboratory" key="lab1">Laboratoire Statistique et G enome</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 8071</orgName>
								<orgName type="institution" key="instit1">Universit e d&apos; Evry Val d&apos;Essonne</orgName>
								<orgName type="institution" key="instit2">USC INRA</orgName>
								<address>
									<addrLine>23 Boulevard de France</addrLine>
									<postCode>91037</postCode>
									<settlement>Evry</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sequence analysis kmacs: the k-mismatch average common substring approach to alignment-free sequence comparison</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="issue">14</biblScope>
							<biblScope unit="page" from="2000" to="2008"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu331</idno>
					<note type="submission">Received on December 19, 2013; revised and accepted on April 25, 2014</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Associate Editor: Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Alignment-based methods for sequence analysis have various limitations if large datasets are to be analysed. Therefore, alignment-free approaches have become popular in recent years. One of the best known alignment-free methods is the average common substring approach that defines a distance measure on sequences based on the average length of longest common words between them. Herein, we generalize this approach by considering longest common substrings with k mismatches. We present a greedy heuristic to approximate the length of such k-mismatch substrings, and we describe kmacs, an efficient implementation of this idea based on generalized enhanced suffix arrays. Results: To evaluate the performance of our approach, we applied it to phylogeny reconstruction using a large number of DNA and protein sequence sets. In most cases, phylogenetic trees calculated with kmacs were more accurate than trees produced with established alignment-free methods that are based on exact word matches. Especially on protein sequences, our method seems to be superior. On simulated protein families, kmacs even outper-formed a classical approach to phylogeny reconstruction using multiple alignment and maximum likelihood. Availability and implementation: kmacs is implemented in C++, and the source code is freely available at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Comparative sequence analysis traditionally relies on pairwise or multiple sequence alignment. With the huge datasets that are produced by next-generation sequencing technologies, however, today's alignment algorithms reach their limits. Thus, with the growing number of completely or partially sequenced genomes, there is an urgent demand for faster sequence-comparison methods. Over the past two decades, a wide variety of alignment-free approaches were proposed (<ref type="bibr" target="#b32">Vinga and Almeida, 2003</ref>). Although aligning two sequences takes time proportional to the product of their lengths, most alignment-free methods run in linear time. They are, therefore, increasingly used for genome-based phylogeny reconstruction and for large-scale protein sequence comparison. It is known, however, that alignment-free methods are generally less accurate than alignment-based approaches. Most alignment-free methods calculate the relative frequencies of words of a fixed length k, also called k-mers, in the input sequences. Other methods are based on variable-length matches; they have the advantage that it is not necessary to specify a fixed word length (<ref type="bibr" target="#b3">Comin and Verzotto, 2012;</ref><ref type="bibr" target="#b4">Didier et al., 2012</ref>). These programs achieve usually better results than approaches relying on a fixed word length. However, algorithms using variable word lengths are typically more complex and require more sophisticated data structures than methods relying on fixed word lengths. A well-known approach that uses word matches of variable length is the average common substring (ACS) method (<ref type="bibr" target="#b31">Ulitsky et al., 2006</ref>), which calculates for each position i in one sequence the length of the longest substring starting at i and matching some substring of a second sequence. As a further development of this idea, the shortest unique substring (shustring) approach has been proposed by<ref type="bibr" target="#b12">Haubold et al. (2005)</ref>. These authors also derived an estimator for the number of substitutions per site between two unaligned sequences based on the average shustring length; they implemented this approach in the program K r (<ref type="bibr" target="#b13">Haubold et al., 2009</ref>). ACS and shustrings can be calculated efficiently using suffix trees (<ref type="bibr" target="#b33">Weiner, 1973</ref>). As the aforementioned methods, most approaches for alignment-free phylogeny reconstruction are based on exact word matches. Recently, we suggested to use spaced-k-mers defined by pre-defined patterns of match and don't care symbols, instead of contiguous k-mers (<ref type="bibr" target="#b2">Boden et al., 2013;</ref><ref type="bibr" target="#b16">Leimeister et al., 2014</ref>). The aim of this study is to apply the idea of inexact matches to word matches of varying lengths. We generalize the ACS approach by considering, for each position i in one sequence, the longest substring starting at i and matching some substring in the second sequence with k mismatches. We propose an efficient heuristic to approximate the lengths of these substrings, and we describe kmacs, an implementation of this approach based on generalized enhanced suffix arrays. A web server for our program is described in<ref type="bibr" target="#b15">Horwege et al. (2014).</ref>*To whom correspondence should be addressed. ß The Author 2014. Published by Oxford University Press. All rights reserved. This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/3.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">APPROACH</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The ACS approach and k-mismatch substrings</head><p>As usual, for a sequence S over an alphabet S, S<ref type="bibr">[i]</ref>is the i-th element of S, by jSj we denote the length of S and S½i::j is the (contiguous) substring of S from i to j. In particular, S½i::jSj is the i-th suffix of S. For two sequences S 1 and S 2 , the ACS approach determines for every position i in S 1 the length s 1 ðiÞ of the longest substring of S 1 starting at position i and exactly matching some substring in S 2. The lengths s 1 ðiÞ are averaged and normalized to define a similarity measure</p><formula>LðS 1 ; S 2 Þ= 1 jS 1 j Ã X jS1j i=1 s 1 ðiÞ ð 1Þ</formula><p>which is turned into a (non-symmetric) distance measure by defining</p><formula>dðS 1 ; S 2 Þ= logðjS 2 jÞ LðS 1 ; S 2 Þ À logðjS 1 jÞ LðS 1 ; S 1 Þ ð2Þ</formula><p>To obtain a symmetric distance, the distance between S 1 and S 2 is then defined by Ulitsky et al.</p><formula>(2006) as d ACS ðS 1 ; S 2 Þ= dðS 1 ; S 2 Þ+dðS 2 ; S 1 Þ 2 ð3Þ</formula><p>In this article, we generalize this distance measure by using substring matches with k mismatches instead of exact matches. That is, instead of using the maximum substring lengths s 1 ðiÞ, we define s k 1 ðiÞ as the length of the longest substring of S 1 starting at position i and matching some substring of S 2 with up to k mismatches, minus k. (We subtract k from the length of this string, counting only the matching positions). s k 2 ðiÞ is defined accordingly. We then define a distance measure as above, but with s q ðiÞ replaced by s k q ðiÞ. In the special case where k = 0, we have s 0 q ðiÞ=s q ðiÞ, so in this case our distance is exactly the distance d ACS .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Approximating the length of k-mismatch substrings</head><p>For a pair of sequences, the exact values s k q ðiÞ can be calculated in Oðk Ã n 2 Þ time using suffix trees or similar data structures where n is the maximal length of the sequences. As we want to compare sequences in linear time, however, we propose a heuristic to approximate these values. To do so, we first calculate for each position i in S 1 the length s 1 ðiÞ of the longest common substring starting at i matching a substring of S 2 , as is done in ACS. Let j be the start of this matching substring in S 2 ; the character S 1 ½i+sðiÞ must therefore differ from S 2 ½j+sðiÞ. We then extend this match without gaps in S 1 from position i+sðiÞ+1 and in S 2 from j+sðiÞ+1, until the next mismatch occurs. This is repeated until the k + 1-th mismatch or the end of one of the two sequences is reached. In the example below, for position i = 4 in S 1 and with k = 2 mismatches, our approach would return the following k-mismatch common substring, starting at position j = 2 in S 2 :</p><p>To obtain this k-mismatch common substring, our program would first determine the longest common substring for position i = 4 in S 1 that exactly matches a substring in S 2. We find such a match at position j = 2 in S 2 with the length s 1 ð4Þ=2. Then this match is extended without gaps until the third mismatch is reached. The length of this 2-mismatch substring is 7, so we have s 2implementation, we therefore used enhanced suffix arrays instead of suffix trees, making use of recent improvements of linear-time suffix array construction algorithms. A suffix array SA of a string S=S½1. .. S½n is a permutation of the indices 1:::n according to the lexicographical ordering of the corresponding suffices. That is, we have SA½i=j if the j-th suffix of S is at the i-th position in the lexicographical ordering of all suffices of S. In addition to the SA, we need the so-called longest common prefix (LCP) array for S. Here, the entry LCP<ref type="bibr">[i]</ref>stores the length of the LCP of the SA<ref type="bibr">[i]</ref>th suffix and its predecessor in SA, the SA½i À 1-th suffix. The SA of a sequence S together with the corresponding LCP array is called, in this context, the enhanced suffix array of S. To calculate enhanced suffix arrays in linear time, we used a program described by<ref type="bibr" target="#b8">Fischer (2011)</ref>, which is available at http://algo2.iti.kit.edu/english/1828. php. The underlying algorithm is based on sais-lite by Yuta Mori, a fast implementation of induced sorting (<ref type="bibr" target="#b21">Nong et al., 2009</ref>). Suffix arrays provide an efficient solution to our longest k-mismatch substring problem. For a single sequence S and a position SA<ref type="bibr">[i]</ref>in S, the enhanced suffix array of S can be used to find the length of the longest substring in S starting at a different position in S and matching a substring starting at SA<ref type="bibr">[i]</ref>. It is easy to see that this substring must be the LCP of the SA<ref type="bibr">[i]</ref>th suffix with one of its neighbours in SA, i.e. either with the SA½i+1-th or the SA½i À 1-th suffix, whichever is longer. With an enhanced suffix array, the length of this substring is given as the maximum of the values LCP<ref type="bibr">[i]</ref>and LCP½i+1 and can therefore be looked up in constant time. The position where this second substring starts is then either SA½i À 1 or SA½i+1—or both of these positions—depending on where the maximum is reached. If matches between two sequences are to be found, the situation is slightly more complicated. For a position in sequence S 1 , we want to find a position in S 2 such that the common substring starting at these two positions is maximal, and vice versa. To solve this problem, we build the generalized enhanced suffix array of our sequences, i.e. the enhanced suffix array of the concatenated sequence S :=S 1 $S 2 where $ is a special character not contained the alphabet S; see also Babenko and<ref type="bibr" target="#b1">Starikovskaya (2008)</ref>for a related approach. Thus, each suffix from S 1 or S 2 is represented in lexicographical order by an entry in SA.<ref type="figure" target="#fig_1">Figure 1</ref>shows the enhanced suffix array for two sequences. To find the length of the longest substring starting at SA<ref type="bibr">[i]</ref>in one sequence, matching a substring of the other sequence, and its occurrences there, we need to look up the largest integer p 1 ðiÞ with p 1 ðiÞ5i, such that SA½p 1 ðiÞ belongs to the other sequence. Correspondingly, we need the smallest integer p 2 ðiÞ with p 2 ðiÞ4i with SA½p 2 ðiÞ belonging to the other sequence. The length of this common substring is then given as the minimum of all LCP values between p 1 ðiÞ+1 and i or the minimum between the LCP values between i + 1 and p 2 ðiÞ—whichever minimum is larger. Formally, the length of the longest substring starting at a position SA<ref type="bibr">[i]</ref>and matching a substring of the respective other sequence is given as follows:The position of this longest substring in S is then SA½p 1 ðiÞ or SA½p 2 ðiÞ (or both), depending on where the maximum in Equation (4) is reached. All positions in this formula refer to the concatenated sequence S, but it is trivial to retrieve the positions in the original sequences S 1 and S 2 from these values by subtracting jS 1 j+1 where necessary. As an example, consider<ref type="figure" target="#fig_1">Figure 1</ref>. For i = 6, we want to find the longest common substring starting at SA½6=10 (marked by an arrow) that exactly matches a substring starting at some position in the other sequence. Position SA½6=10 in the concatenated sequence S corresponds to a position in sequence S 2 , so we have p 1 ð6Þ=4, as 4 is the largest integer smaller than 6 such that SA½4 belongs to the other sequence, i.e. to S 1. Similarly, we obtain p 2 ð6Þ=8. According to Equation (4), we get the following: sðSA½6Þ=max min f5; 3g; min f1; 0g f g =max f3; 0g=3:</p><p>Position 10 in S corresponds to position 3 in the original sequence S 2 , so, as a result, we obtain s 2 ð3Þ=3, i.e. the longest substring starting at position 3 in S 2 matching a substring from S 1 has length 3 (the substring itself is 'ana').</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Calculation of Equation (4)</head><p>Require: SA {generalized suffix array for S 1 and S 2 of length n} Require: LCP {corresponding longest common prefix array} Ensure: s {stores the results of Equation (4)} min 0 for i = 2 to n – 1 do if SA½i and SA½i+1 belong to the same sequence then if LCP½i+15min then min LCP½i+1 end if s½i+1 min else<ref type="figure" target="#tab_1">LCP½i+1  s½i+1  LCP½i+1</ref>end if end for min 0 for i = n to 2 do if SA½i and SA½i+1 belong to the same sequence then if LCP½i5min then min LCP½i end if s½i À 1 maxðmin; s½i À 1Þ else min LCP½i s½i À 1 maxðmin; s½i À 1Þ end if end for All values s(i) can be calculated for the entire concatenated string S in linear time using Algorithm 1. Here, the first loop computes min p15x i LCP½x for all indices i and stores them as s<ref type="bibr">[i]</ref>. Then the second loop calculates min i5y p2 LCP½y and updates s<ref type="bibr">[i]</ref>if the result is greater than the actual value of s<ref type="bibr">[i]</ref>. This way, algorithm 1 applies Equation (4) to all indices i and stores the corresponding values s<ref type="bibr">[i]</ref>. Finally, for our heuristic we need to find for an index i all positions belonging to the respective other sequence, where a match of length s(i) occurs. This can be achieved by a simple extension of Algorithm 1. Without loss of generality, we assume that the first minimum in Equation (4) is strictly larger than the second minimum, so p 1 ðiÞ is a position where a maximal match to the other sequence occurs (as was the case in our small example above). To find possible additional matching positions, we consider all indices p p 1 ðiÞ in descending order, as long as one has the following inequality:</p><formula>LCP½p+1 min p1ðiÞ5x i LCP½x</formula><p>For all such p that belong to the other sequence, the positions SA<ref type="bibr">[p]</ref>are occurrences of longest substrings matching a substring starting at i. In our example, we find one further position p = 3, so SA½3=4 is an additional occurrence. If the maximum in (4) is achieved by the second term, one proceeds accordingly. Next, the second step in our approach involves finding the length of the longest common substring starting at pre-defined positions in S 1 and S 2 , respectively. Using the enhanced suffix array of a sequence S, the length of the longest substring starting at positions SA<ref type="bibr">[i]</ref>and SA<ref type="bibr">[j]</ref>(with SA½i5 SA<ref type="bibr">[j]</ref>) is given as the minimum over the values LCP<ref type="bibr">[p]</ref>, i5p j. There is an approach similar to LCA queries to obtain this value known as range minimum queries (RMQ). A RMQ returns the index of an array A that stores the smallest element between two specified indices l and r, denoted as RMQ A ðl; rÞ. Several algorithms are available that can solve RMQ in constant time, after a linear preprocessing step, e.g. Fischer and Heun (2007). According to<ref type="bibr" target="#b9">Fischer and Heun (2006)</ref>, the longest common substring starting at i and j can be calculated as LCP½RMQ LCP ðSA À1 ½i+1; SA À1 ½jÞ where SA À1 is the inverse suffix array. As a result, the same complexity as for suffix trees can be achieved by using enhanced suffix arrays. In our implementation, however, we extend the substrings by matching single characters because in our test runs this 'naive' approach was faster than the RMQ implementation that we tested. Nevertheless, our downloadable program has an option for using the RMQ algorithm so the user can compare these two approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">BENCHMARKING</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Benchmark sequences</head><p>To evaluate kmacs and to compare it with other methods of sequence comparison, we applied these methods phylogeny reconstruction. We used a large number of DNA and protein sequence sets for which reliable phylogenetic trees are available, and we measured how similar the constructed trees are to the respective reference trees. The following sequence sets were used in our study: For eukaryotic DNA comparison, we used a set of 27 primate mitochondrial genomes that were previously used by<ref type="bibr" target="#b13">Haubold et al. (2009)</ref>as benchmark for alignment-free methods. These sequences have a total length of 446 kb. A benchmark tree that has been constructed based on a multiple alignment. As prokaryotic genomes, we used a set of 32 Roseobacter genomes, which were previously analysed by<ref type="bibr" target="#b20">Newton et al. (2010)</ref>. They constructed a phylogenetic tree for these sequences based on alignments of 70 universal single-copy genes that we used as reference tree in our study. The total size of this sequence set is 135.9 mb. As benchmark proteins, we used 218 sequence sets contained in the BAliBASE (v3.0) database (<ref type="bibr" target="#b29">Thompson et al., 2005</ref>). To obtain reference trees, we applied Maximum Likelihood (<ref type="bibr" target="#b6">Felsenstein, 1981</ref>), implemented in the program proml from PHYLIP to the reference multiple alignments in BAliBASE. As these reference alignments are considered to be reliable, the resulting trees should also be reliable. In addition to these real-world sequences, we used the program Rose (<ref type="bibr" target="#b27">Stoye et al., 1998</ref>) to generate simulated DNA and protein families. Rose generates sets of related sequences based on a probabilistic model of substitutions and insertions/deletions for which the parameters can be adjusted by the user. These sequences are created along a randomly generated tree, starting from one common ancestral sequence at the root of the tree. This way, the 'evolution' of the generated sequences is logged, so a reference tree is generated alongside the sequences. We used Rose with default parameters, except for the parameter relatedness, which defines the average evolutionary distance between the generated sequences, measured in PAM units. We generated 20 DNA sequence sets, each of which contains 50 sequences with an average length of 16 000 nt using a relatedness value of 70. Furthermore, we generated 20 protein sequence sets, each containing 125 sequences with an average length of 300 amino acids. Here, we set the relatedness to 480.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Compared methods</head><p>We compared our new method with seven state-of-the-art alignment-free methods, namely ACS (<ref type="bibr" target="#b31">Ulitsky et al., 2006</ref>), K r v2.0.2 (<ref type="bibr" target="#b13">Haubold et al., 2009</ref>), FFP (<ref type="bibr" target="#b26">Sims et al., 2009</ref>), spaced words (<ref type="bibr" target="#b16">Leimeister et al., 2014</ref>), CVTree (<ref type="bibr" target="#b22">Qi et al., 2004</ref>), the underlying approach (UA) (<ref type="bibr" target="#b3">Comin and Verzotto, 2012</ref>) as well as to a<ref type="bibr" target="#b28">Thompson et al., 1994</ref>) on those sequence sets where this was possible and meaningful. For ACS and the k-mer approach, we used our own implementations, namely kmacs with k = 0 and our spaced-words approach without don't care positions in the underlying patterns, respectively. FFP, K r and CVTree return pairwise distances between the input sequences. For ACS, we calculated distances as defined in (3), and for spaced words and the k-mer approach we used the Jensen–Shannon divergence (<ref type="bibr" target="#b17">Lin, 1991</ref>), applied to (spaced)word frequency vectors as explained in<ref type="bibr" target="#b16">Leimeister et al. (2014)</ref>. For each of the five groups of benchmark data, we used the word length k for which the k-mer approach produced the best results, i.e. trees with minimal average Robinson–Foulds (RF) distances to the reference trees. For spaced words, we used the same value for k, even though better results might be possible with different values. Accordingly, on every group of benchmark data, we tested FFP, CVTree and UA with different parameter values and used those which produced the best results on this group. We then constructed phylogenetic trees by applying Neighbor joining (<ref type="bibr" target="#b24">Saitou and Nei, 1987</ref>) to the distance matrices obtained with the different alignment-free methods. Finally, we calculated phylogenetic trees for all sequence sets by applying Maximum Likelihood (<ref type="bibr" target="#b6">Felsenstein, 1981</ref>) to the Clustal W multiple alignments. All resulting tree topologies were compared with the topologies of the respective reference trees using the RF metric (<ref type="bibr" target="#b23">Robinson and Foulds, 1981</ref>). For Neighbor joining and to calculate the RF distances, we used the programs neighbor and treedist contained in the PHYLIP package (<ref type="bibr" target="#b7">Felsenstein, 1989</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS AND DISCUSSION</head><p>Figures 2 and 4–7 summarize our test results on the five groups of benchmark sequence sets that we used. The plots show the average RF distances between the produced trees and the corresponding reference trees. For kmacs, results are shown for various values of k. For FFP, CVTree, UA and the k-mer method, we also used a range of parameter values, but for each of these methods, the figures show only the best results on the respective group of benchmark sequences. Thus, for a fair comparison, these methods should be compared with the best results of kmacs in the corresponding<ref type="figure">figure.</ref>On the other hand, K r , ACS and Clustal could be used with default parameters, which is clearly an advantage of these methods.<ref type="figure" target="#fig_4">Figure 2</ref>contains the test results on the primate mitochondrial genomes. The best method on this dataset was our previously developed spaced-words approach; the tree topology produced by this method precisely coincides with the topology of the reference tree, i.e. the RF distance is zero. The second best methods were FFP and kmacs with k = 3, 4 and 64 k 117. ACS, CVTree, UA, kmacs with other values for k and K r performed worse on these data. As an example,<ref type="figure">Figure 3</ref>(B) is based on kmacs with k = 70. Red branches represent differences to the reference tree topology. Except for these three species, the topologies of the two trees coincide, resulting in a RF distance of 2 between our tree and the reference treekmacs almost coincides with the topology of the reference tree; the RF distance between these trees is 2. On the Roseobacter genomes, the best methods were kmacs with k = 4 and 6, FFP and CVTree as shown in<ref type="figure" target="#fig_8">Figure 4</ref>. Spaced words and the generic k-mer approach performed slightly worse. None of the tested methods was able to exactly reconstruct the topology of the reference tree. UA is missing in this comparison, as this program is too slow to be run on full bacterial genomes in reasonable time. For our simulated DNA sequence sets, the results were similar as for the primate mitochondrial genomes; see<ref type="figure" target="#fig_6">Figure 5</ref>. Here too, spaced words was the best alignment-free method, followed by kmacs. This time kmacs outperformed the established alignment-free approaches for all values of k that we tested. On our simulated DNA sequences, we could also run a classical approach to phylogeny reconstruction using Clustal W and Maximum Likelihood. Not surprisingly, this slow and accurate method performed better than all alignmentfree approaches.<ref type="figure" target="#fig_5">Figure 6</ref>shows the results for the BAliBASE protein sequences. Spaced words and kmacs again produced better results than the existing alignment-free methods that we evaluated. This time, there was a large range of values for k where kmacs performed similar or even slightly better than spaced words, and both methods outperformed the other alignment-free methods that we tested. As with the previous dataset, the classical approach based on multiple sequence alignment performed best; this time the difference between alignment-based and alignment-free methods was larger. This may be because of the fact that multiple-alignment programs are often tuned to perform well on BAliBASE, the main database to evaluate multiple-alignment methods. Finally, the results on our simulated protein sequences are shown in<ref type="figure" target="#fig_7">Figure 7</ref>. As in most previous examples, spaced words and kmacs outperformed other alignment-free approaches and, as on BAliBASE, kmacs was slightly better than spaced words if k was sufficiently large. Surprisingly, on these benchmark sequences spaced words and kmacs even outperformed Clustal W and Maximum Likelihood, although not dramatically. So far, we evaluated alignment-free and alignment-based methods indirectly, by applying them to phylogeny reconstruction and comparing the resulting trees with trusted reference trees using the RF metric. This is a common procedure to evaluate alignment-free methods. RF distances to reference trees are only a rough measure of accuracy, though, as they are based on tree topologies alone and do not take branch lengths into account. Furthermore, the constructed trees depend not only on the underlying methods for sequence comparison but also on the methods used for tree reconstruction. A more direct and accurate way of comparing alignment-free methods is to directly compare the distance values that they calculate. This can be done, for example, by plotting the distances produced for simulated sequences against their real evolutionary distances (<ref type="bibr" target="#b13">Haubold et al., 2009</ref>). Ideally, this should be a linear relation.<ref type="figure" target="#fig_9">Figure 8</ref>shows such plots for the algorithms that we compared in our study. Tables 1 and 2 summarize the run times of the different methods that we tested. When used with moderate values of k, kmacs is faster than spaced words run with a set of 100 differentpatterns. K r was more than one order of magnitude faster than kmacs and spaced words, respectively, although UA was the slowest method. The fastest method was our implementation of the generic word-frequency approach, followed by K r and CVTree. In general, spaced words used with the single-pattern option is only slightly slower than the k-mer approach. As shown in our companion paper, however, spaced words produces considerably better results when used with multiple patterns (<ref type="bibr" target="#b16">Leimeister et al., 2014</ref>). We therefore applied only the multiple-pattern version in this study. The relatively long runtime of UA is partially because of the fact that this program is written in Java, while all other programs that we tested are written in C++. As expected, the multiplealignment approaches Clustal W and Clustal (<ref type="bibr" target="#b25">Sievers et al., 2011</ref>) were far slower than the alignment-free methods; the difference in speed between alignment-based and alignment-free methods was between three and four orders of magnitude. All test runs were done on a Intel Core i7 4820k, which we overclocked to 4.5Ghz. As explained in Section 2.2, kmacs searches for each position i in one sequence the maximum substring starting at i that matches a substring in the second sequence. There can be more than one such maximal match, and all these matches are extended to k-mismatch common substrings. Thus, the runtime of kmacs depends on z, the average number of such maximal substring matches for a given position i. In principle, z can be large and the worst-case time complexity of our algorithm is therefore high. In practice, however, z is small, independent of sequence length and substitution probability.<ref type="figure">Figure 9</ref>shows values of z for different sequence lengths and mutation frequencies. Finally, we wanted to know how accurately our greedy heuristic approximates the exact maximal k-mismatch substring length.<ref type="figure" target="#fig_1">Figure 10</ref>compares the average maximal k-mismatch substring length for varying substitution probabilities (a) as estimated with our heuristic and (b) calculated with a slow and exact algorithm. The figure shows that our heuristic is clearly suboptimal. But the goal of our project was not so much to precisely estimate the maximal k-mismatch substring lengths, but rather to define a distance measure on sequences that can be efficiently calculated and that can be used to obtain biologically meaningful results. Therefore, we think that the discrepancies between the optimal substring lengths and the values estimated by our heuristic are acceptable.<ref type="figure" target="#fig_1">Figure 10</ref>suggests, however, that better estimates of the kmismatch common substring lengths might improve the sensitivity of kmacs on divergent sequence sets because the curves for the exact solutions converge at higher substitution frequencies. In fact, on the mitochondrial genomes that we used as benchmark data, an exact algorithm led to better phylogenetic trees than our greedy heuristic (Supplementary Material). Therefore, it may be worthwhile to develop heuristics that approximate the maximal k-mismatch substring lengths more accurately.Note: Spaced words was run with 100 random patterns of varying length as described by<ref type="bibr" target="#b16">Leimeister et al. (2014)</ref>. For Clustal W and Clustal , the time for calculating a multiple alignment is shown; for the six alignment-free methods the time for calculating pairwise distances is shown.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>Most alignment-free approaches to sequence analysis are based on exact word matches. In this article, we presented a novel alignment-free algorithm that takes mismatches into account. This is similar in spirit to the spaced-words approach that we previously proposed (<ref type="bibr" target="#b16">Leimeister et al., 2014</ref>). But while spaced words uses word pairs of a fixed length with possible mismatches at pre-defined positions, kmacs considers maximal substring matches with k mismatches at arbitrary positions. In the spaced-words approach, the number of match positions in the underlying patterns is a critical parameter for the performance of the method. In contrast, in kmacs, there seems to be a fairly large range of values for k that lead to high-quality results, as shown by our test results. kmacs seems therefore less sensitive to user-defined parameters. The implementation of our approach using generalized enhanced suffix arrays enables us to analyse large sequence sets efficiently. Still, the program K r is roughly one order of magnitude faster than kmacs. One reason for this is that K r uses one single generalized suffix tree representing all input sequences, which can be calculated in time proportional to the number of sequences (Domazet-Lo so and<ref type="bibr" target="#b13">Haubold, 2009</ref>). In contrast, kmacs calculates one generalized enhanced suffix array for each pair of sequences, so its run time is quadratic in the number of sequences. On the other hand, calculating suffix arrays for two sequences at a time is less memory consuming, as one does not need to keep the suffix array for all input sequences simultaneously in main memory. Thus, our approach can be applied to larger datasets than K r. The two approaches that we developed, kmacs and spaced words, are slower than the corresponding approaches based on exact matches, ACS and the generic k-mer approach. Our new approaches, however, produce significantly better results than those established methods. Our test results suggest that spaced words performs slightly better than kmacs on genomic sequences, whereas on protein sequences, kmacs is superior. In our program evaluation, we used DNA sequence sets with large evolutionary distances. On these sequences, our new alignment-free methods performed better than established methods that rely on exact word matches. Algorithms using exact matches, on the other hand, seem to work better on smaller evolutionary distances. K r , for example, performs best on evolutionary distances of up to 0.6 substitutions per site (<ref type="bibr" target="#b13">Haubold et al., 2009</ref>). Similarly, we observed that on closely related DNA sequences, kmacs produces sometimes best results with k = 0, i.e. without mismatches (unpublished results). It seems therefore best to apply kmacs to distantly related sequence sets, while methods such as K r and ACS may be preferred on evolutionarily more closely related sequences. In biological sequences, substitutions are more frequent than insertions and deletions. Consequently, exact matches between local homologies can usually be extended until the first substitution is reached. The average length of longest common substrings and of shortest unique substrings, respectively, can therefore be used to estimate substitution probabilities (<ref type="bibr" target="#b13">Haubold et al., 2009</ref>). This is similar for kmacs as long as k is small enough. In this case, all k mismatches are likely to be used up in a k-mismatch common substring extension before the first indel occurs. Thus, the average length of the longest k-mismatch common substrings depends on the frequency of mismatches and could be used to estimate substitution probabilities, just as in K r. In contrast, if k is sufficiently large, substring matches between local homologies are essentially extended until the first indel occurs. From this point on, the mismatch frequency is high and the remaining mismatches will be used up quickly. So in this situation, the average k-mismatch substring length depends on the frequency of indels rather than on the frequency of substitutions. This may explain why ACS and K r work well on closely related sequences, while kmacs is superior on distantly related sequences where the frequency of indels may be a better measure for evolutionary distances than the frequency of mismatches. In our study, we used alignment-free methods to reconstruct phylogenetic trees and evaluated the quality of these trees. But phylogeny reconstruction is only one important application of sequence comparison. Clustering, classification and remotehomology detection are other fundamental challenges in DNA and protein sequence analysis. With the rapidly growing size of sequence databases, alignment-free methods have become indispensable for these tasks (<ref type="bibr" target="#b3">Comin and Verzotto, 2012;</ref><ref type="bibr" target="#b14">Hauser et al., 2013;</ref><ref type="bibr" target="#b18">Lingner and Meinicke, 2006</ref>). Given the speed of<ref type="figure" target="#fig_1">Fig. 10</ref>. Average common k-mismatch substring lengths depending on the substitution frequency in simulated DNA sequences, estimated with our greedy heuristic (lower curve) and calculated with an exact algorithm (upper curve) for various values of k<ref type="figure">Fig. 9</ref>. Average number z of maximal exact matches starting at a position i in one sequence to a substring in a second sequence. We used simulated DNA sequences with different lengths and substitution frequencies</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2007</head><p>kmacs: the k-mismatch average common substring approach kmacs and the quality of the phylogenetic trees that we could produce with it, our approach should be useful not only for fast phylogeny reconstruction, but also for other tasks in comparative sequence analysis.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.1.</head><figDesc>Fig. 1. Generalized SA and LCP array for the strings S 1 =banana and S 2 =ananas, concatenated by the symbol $. Suffices of S 1 $S 2 starting in S 1 are shown in orange, suffices starting in S 2 are in blue</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>2003kmacs: the k-mismatch</head><figDesc>average common substring approach generic k-mer-frequency approach. As an eighth method, we ran Clustal W (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>Fig. 3. Midpoint-rooted trees of 27 primate mitochondrial genomes. (A) is the alignment-based reference tree obtained from Haubold et al. (2009) and (B) is based on kmacs with k = 70. Red branches represent differences to the reference tree topology. Except for these three species, the topologies of the two trees coincide, resulting in a RF distance of 2 between our tree and the reference tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.2.</head><figDesc>Fig. 2. Performance of alignment-free methods on a set of 27 primate mitochondrial genomes. RF distances between constructed trees and a reference tree are shown. The tree calculated by kmacs with k = 70 is shown in Figure 3, together with the reference tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.6.</head><figDesc>Fig. 6. Performance of different methods on 218 protein sequence sets from BAliBASE. Average RF distances to reference trees, calculated based on BAliBASE reference alignments, are shown</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.5.</head><figDesc>Fig. 5. Performance of alignment-based and alignment-free methods on 20 sets of 50 simulated DNA sequences of length 16 000 each. Average RF distances to the respective reference trees are shown</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.7.</head><figDesc>Fig. 7. Performance of different methods on 20 sets of 125 simulated protein sequences each</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.4.</head><figDesc>Fig. 4. Performance of alignment-free methods on a set of 32 Roseobacter genome sequences. RF distances to the reference tree are shown</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig.8.</head><figDesc>Fig. 8. Distances calculated by different alignment-free methods as a function of substitutions per site for pairs of simulated DNA sequences. Distances were normalized such that they are equal for 0.75 substitutions per site</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. Program runtime for different methods on a set of 50 simulated DNA sequences of length 16 000 nt each</figDesc><table>Method 
Runtime (s) 

Clustal W 
1817 
Clustal 
1039 
8-mer 
0.3 
FFP, l = 23 
123.3 
spaced words, 100 patterns, k = 8 
27.6 
ACS 
2.8 
K r 
0.9 
CVTree 
0.5 
UA 
572 
kmacs, k = 1 
4.2 
kmacs, k = 10 
7.6 
kmacs, k = 20 
4.2 
kmacs, k = 50 
21.4 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 2. Program run time for different methods on a set of 32 genome sequences of total length 135 mb from various Roseobacter species</figDesc><table>Method 
Runtime (s) 

17-mer 
34.9 
FFP, l = 24 
9022 
Spaced words, 100 patterns, k = 17 
3617 
ACS 
531 
K r 
206 
CVTree 
84 
kmacs, k = 1 
784 
kmacs, k = 10 
1302 
kmacs, k = 50 
3158 
kmacs, k = 100 
5433 

Note: Parameters for spaced words as in Table 1. </table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="1"> ð4Þ=5 (in the definition of s k q ðiÞ, we count only the matching positions). It should be mentioned that, for a position i in S 1 , the corresponding position j in S 2 of the longest exact match to a substring starting at i may not be unique. Consider, e.g. position i = 2 in the first sequence of the above example: Here, the substring AT starting at position 2 in S 1 is the longest substring starting at this position and matching a substring of S 2 —but this substring occurs at positions 1, 5 and 10 in S 2. In such a case, we calculate all k-mismatch extensions of these occurrences as described above, and we define s k 1 ðiÞ as length of the maximal possible extension minus k. The above heuristic reduces the complexity of finding the k mismatch maximal substring lengths from Oðk Ã n 2 Þ to Oðk Ã n Ã zÞ, where z is the average number of maximal matches to a substring in S 2 starting at a position i in S 1. In principle, this complexity could be achieved by using suffix trees (Weiner, 1973) as the underlying data structure. Here, one would build a generalized suffix tree for the sequences in OðjS 1 j+jS 2 jÞ time, e.g. using Ukkonen&apos;s algorithm (Ukkonen, 1995). To determine the longest substring starting at i in S 1 and also occurring in S 2 , one needs to find the lowest node v in the suffix tree that is above leaf i and also above some leaf that belongs to S 2. The length s 1 ðiÞ of the longest common substring starting at i is then the string depth of the node v, that is, the length of the edge labels on the path from the root to v. Moreover, the leaves below v appertaining to S 2 exactly correspond to the positions of this longest exact match in S 2. Next, we want to extend the longest exact matches that we have found by this procedure until the k + 1-th mismatch is found. Thus, we need be able to find the longest exact match between two sequences starting at two given positions i and j (the positions after a mismatch, in our case). In a suffix-tree approach, this could be accomplished by lowest common ancestor (LCA) queries. Similar to the aforementioned approach, we would have to look up the lowest node v that is above both leafs i and j; the string depth of v is then the length of the longest exact match starting at i and j, respectively. LCA queries can be carried out for any i and j in constant time after a linear-time preprocessing step (Harel and Tarjan, 1984), resulting in k constant-time LCA queries for the full k-mismatch extension of an exact longest match. 3 IMPLEMENTATION Abouelhoda et al. (2004) have shown that every algorithm that uses suffix-trees can be replaced by an algorithm using enhanced suffix arrays that has the same complexity. Here, an enhanced suffix array is defined as a data structure &apos;consisting of the suffix array and additional tables&apos;. Both, suffix trees and enhanced suffix arrays, can be calculated in linear time and space, but suffix arrays require substantially less memory per input character than suffix trees do (Manber and Myers, 1990). In our 2001 kmacs: the k-mismatch average common substring approach at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">C.-A.Leimeister and B.Morgenstern at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors want to thank Bernhard Haubold, Sebastian Horwege and Manuel Landesfeind for useful comments and discussions as well as Sebastian Lindner, Martin Sch € oneich and Marcus Boden for providing datasets used in this study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflicts</head><p>of Interest: none declared.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Replacing suffix trees with enhanced suffix arrays</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">I</forename>
				<surname>Abouelhoda</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="53" to="86" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Computing longest common substrings via suffix arrays</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">A</forename>
				<surname>Babenko</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">A</forename>
				<surname>Starikovskaya</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In: Computer Science-Theory and Applications Lecture Notes in Computer Science</title>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">5010</biblScope>
			<biblScope unit="page" from="64" to="75" />
			<date type="published" when="2008" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Alignment-free sequence comparison with spaced k-mers</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Boden</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings German Conference on Bioinformatics (GCB&apos;13). OpenAccess Series in Informatics</title>
		<meeting>German Conference on Bioinformatics (GCB&apos;13). OpenAccess Series in Informatics</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="21" to="31" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Alignment-free phylogeny of whole genomes using underlying subwords</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Comin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Verzotto</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">34</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Variable length local decoding and alignment-free sequence comparison</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Didier</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">462</biblScope>
			<biblScope unit="page" from="1" to="11" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Efficient estimation of pairwise distances between genomes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Domazet-Lo So</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Haubold</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="3221" to="3227" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Evolutionary trees from DNA sequences:a maximum likelihood approach</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Felsenstein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Evol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="368" to="376" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">PHYLIP-Phylogeny Inference Package (Version 3.2)</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Felsenstein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cladistics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="164" to="166" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Inducing the LCP-array</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Fischer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 12th Algorithms and Data Structures Symposium</title>
		<meeting>12th Algorithms and Data Structures Symposium</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="374" to="385" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Theoretical and practical improvements on the RMQ-problem, with applications to LCA and LCE</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Fischer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Heun</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th Annual Symposium on Combinatorial Pattern Matching, Lecture Notes in Computer Science 4009</title>
		<meeting>the 17th Annual Symposium on Combinatorial Pattern Matching, Lecture Notes in Computer Science 4009</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="36" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">A new succinct representation of RMQ-information and improvements in the enhanced suffix array</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Fischer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Heun</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Combinatorics, Algorithms, Probabilistic and Experimental Methodologies</title>
		<meeting>the International Symposium on Combinatorics, Algorithms, Probabilistic and Experimental Methodologies</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="459" to="470" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Fast algorithms for finding nearest common ancestor</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Harel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">E</forename>
				<surname>Tarjan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="338" to="355" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Genome comparison without alignment using shortest unique substrings</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Haubold</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">123</biblScope>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Estimating mutation distances from unaligned genomes</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Haubold</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1487" to="1500" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">kclust: fast and sensitive clustering of large protein sequence databases</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Hauser</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">248</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Spaced words and kmacs: fast alignment-free sequence comparison based on inexact word matches</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Horwege</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res., [Epub ahead of print</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast alignment-free sequence comparison using spaced-word frequencies</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">A</forename>
				<surname>Leimeister</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1991" to="1999" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Divergence measures based on the shannon entropy</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Lin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="145" to="151" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Remote homology detection based on oligomer distances</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Lingner</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Meinicke</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="2224" to="2231" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Suffix arrays: a new method for on-line string searches</title>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Manber</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the first annual ACM-SIAM symposium on Discrete algorithms, SODA&apos;90</title>
		<meeting>the first annual ACM-SIAM symposium on Discrete algorithms, SODA&apos;90</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="319" to="327" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Genome characteristics of a generalist marine bacterial lineage</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Newton</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ISME J</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="784" to="798" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Linear suffix array construction by almost pure inducedsorting</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Nong</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 19th IEEE Data Compression Conference</title>
		<meeting>19th IEEE Data Compression Conference</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="193" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">CVTree: a phylogenetic tree reconstruction tool based on whole genomes</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Qi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="45" to="47" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
	<note>Suppl. . 2</note>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Comparison of phylogenetic trees</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Robinson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Foulds</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Biosci</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="131" to="147" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">The neighbor-joining method: a new method for reconstructing phylogenetic trees</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Saitou</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Nei</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="406" to="425" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Fast, scalable generation of high-quality protein multiple sequence alignments using Clustal Omega</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Sievers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">539</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Alignment-free genome comparison with feature frequency profiles (FFP) and optimal resolutions</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">E</forename>
				<surname>Sims</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci</title>
		<meeting>. Natl Acad. Sci</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="2677" to="2682" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Rose: generating sequence families</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Stoye</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="157" to="163" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">CLUSTAL W: improving the sensitivity of progressive multiple sequence alignment through sequence weighting, position-specific gap penalties and weight matrix choice</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Thompson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="4673" to="4680" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">BAliBASE 3.0: latest developments of the multiple sequence alignment benchmark</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Thompson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins</title>
		<imprint>
			<biblScope unit="page" from="61" to="127" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">On-line construction of suffix trees</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ukkonen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="249" to="260" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">The average common substring approach to phylogenomic reconstruction</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Ulitsky</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="336" to="350" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">Alignment-free sequence comparison—a review</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Vinga</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Almeida</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="513" to="523" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">Linear pattern matching algorithms</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Weiner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 14th IEEE Symposium on Switching and Automata Theory</title>
		<meeting>the 14th IEEE Symposium on Switching and Automata Theory</meeting>
		<imprint>
			<date type="published" when="1973" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>