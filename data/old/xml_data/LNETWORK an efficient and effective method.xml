
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:31+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">LNETWORK: an efficient and effective method for constructing phylogenetic networks</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2013">18 2013</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Juan</forename>
								<surname>Wang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Maozu</forename>
								<surname>Guo</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Xiaoyan</forename>
								<surname>Liu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yang</forename>
								<surname>Liu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Chunyu</forename>
								<surname>Wang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Linlin</forename>
								<surname>Xing</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Kai</forename>
								<surname>Che</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">LNETWORK: an efficient and effective method for constructing phylogenetic networks</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">29</biblScope>
							<biblScope unit="page" from="2269" to="2276"/>
							<date type="published" when="2013">18 2013</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btt378</idno>
					<note type="submission">Received on February 4, 2013; revised on June 24, 2013; accepted on June 26, 2013</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Associate Editor: David Posada Availability: LNETWORK has been built as a Java software package and is freely available at http://nclab.hit.edu.cn/$wangjuan/LNETWORK/. Contact: maozuguo@hit.edu.cn Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: The evolutionary history of species is traditionally represented with a rooted phylogenetic tree. Each tree comprises a set of clusters, i.e. subsets of the species that are descended from a common ancestor. When rooted phylogenetic trees are built from several different datasets (e.g. from different genes), the clusters are often conflicting. These conflicting clusters cannot be expressed as a simple phylogenetic tree; however, they can be expressed in a phylogenetic network. Phylogenetic networks are a generalization of phylogenetic trees that can account for processes such as hybridization, horizontal gene transfer and recombination, which are difficult to represent in standard tree-like models of evolutionary histories. There is currently a large body of research aimed at developing appropriate methods for constructing phylogenetic networks from cluster sets. The CASS algorithm can construct a much simpler network than other available methods, but is extremely slow for large datasets or for datasets that need lots of reticulate nodes. The networks constructed by CASS are also greatly dependent on the order of input data, i.e. it generally derives different phylogenetic networks for the same dataset when different input orders are used. Results: In this study, we introduce an improved CASS algorithm, LNETWORK, which can construct a phylogenetic network for a given set of clusters. We show that LNETWORK is significantly faster than CASS and effectively weakens the influence of input data order. Moreover, we show that LNETWORK can construct a much simpler network than most of the other available methods.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Phylogenetic networks are a generalization of phylogenetic trees; they can represent non–tree-like evolutionary histories caused by processes such as hybridization, horizontal gene transfer and recombination (<ref type="bibr" target="#b3">Doolittle, 1999;</ref><ref type="bibr" target="#b19">Rieseberg, 1997</ref>). Developing appropriate methods for inferring phylogenetic networks has been identified as an important research area (<ref type="bibr" target="#b5">Huson, 2005;</ref><ref type="bibr" target="#b14">Linder et al., 2004</ref>), and there have been many recent studies on this topic (<ref type="bibr" target="#b8">Huson and Scornavacca, 2010;</ref><ref type="bibr" target="#b12">Huson et al., 2011</ref>). Phylogenetic networks can be typologically classified into unrooted and rooted networks, and functionally classified into implicit and explicit networks (<ref type="bibr" target="#b8">Huson and Scornavacca, 2010</ref>). Implicit networks can be used to represent conflicting patterns that may be the result of a variety of causes, such as model misspecification (<ref type="bibr" target="#b6">Huson and Bryant, 2006</ref>). Explicit networks can capture biological processes such as hybridization (<ref type="bibr" target="#b14">Linder and Rieseberg, 2004;</ref><ref type="bibr" target="#b17">Maddison, 1997</ref>), recombination (<ref type="bibr" target="#b4">Gusfield and Bansal, 2005;</ref><ref type="bibr" target="#b22">Song and Hein, 2005</ref>) and horizontal gene transfer (<ref type="bibr" target="#b18">Nakhleh, 2010</ref>). Explicit networks are usually rooted, as evolution is inherently directed. However, rooted phylogenetic networks may also be implicit networks, depending on how they are constructed and interpreted (<ref type="bibr" target="#b8">Huson and Scornavacca, 2010</ref>). The program Dendroscope (<ref type="bibr" target="#b9">Huson and Scornavacca, 2012</ref>) is used to compute rooted phylogenetic networks. It combines a number of methods used to compute implicit networks, such as the cluster network method (<ref type="bibr" target="#b7">Huson and Rupp, 2008</ref>), with methods used for computing explicit networks, such as the hybridization network method (<ref type="bibr" target="#b9">Huson and Scornavacca, 2012</ref>). The program SplitsTree4 (<ref type="bibr" target="#b6">Huson and Bryant, 2006</ref>) is designed to compute implicit networks. It uses a variety of methods, including the Z-closure super network method (<ref type="bibr" target="#b10">Huson et al., 2004</ref>).<ref type="bibr" target="#b26">Woolley et al. (2008)</ref>used computer simulations to compare the performance of most of the unrooted implicit network approaches, i.e. they compared the simulated trees with all of the trees embedded in the constructed network. Phylogenetic networks are an important part of biological research.<ref type="bibr" target="#b24">Wang et al. (2012)</ref>used the Dendroscope program to confirm the hypothesis that indehiscent sporangia promote the establishment of a persistent population in different regions of the Qinghai-Tibetan Plateau.<ref type="bibr" target="#b21">Schwarzer et al. (2011)</ref>analyzed Amplified Fragment Length Polymorphism (AFLP) loci using the Neighbor-net method and revealed three main clusters and several smaller subclusters.<ref type="bibr" target="#b13">Kelly et al. (2010)</ref>inferred super networks (<ref type="bibr" target="#b25">Whitfield et al., 2008</ref>) from several incongruent gene trees, and uncovered new evidence for a complex history of reticulate evolution in Nicotiana. Our study develops a method for constructing rooted implicit networks. In the following, unless otherwise specified, we refer to rooted phylogenetic networks as simply networks. Let X be a set of taxa. A rooted phylogenetic tree T on X represents a cluster C (a proper subset of X ), if there is an edge e in T such that the set of taxa below e equals C. Each rooted phylogenetic tree T is uniquely defined by the set of clusters that it represents (<ref type="bibr" target="#b12">Huson et al., 2011</ref>). Given a network N and a cluster C, when switching an incoming edge on and all of the *To whom correspondence should be addressed. others off for each reticulate node in N, if there is a tree edge e ¼ ðu, vÞ (indegree of v at most 1) in N such that the set of leaves reachable from e equals C, we say that N represents C in the soft-wired sense. Alternatively, if there is a tree edge e in N such that the set of taxa below e equals C, we say that N represents C in the hard-wired sense. Given a network N and a phylogenetic tree T, when switching an incoming edge on and all of the others off for each reticulate node in N, if N equals T, then we say that N represents T (see<ref type="figure">Fig. 1</ref>). Phylogenetic trees are commonly constructed from different datasets, e.g. from different genes. Each constructed phylogenetic tree carries important evolutionary information, and to reconstruct complete evolutionary histories of all of the relevant taxa, we would preferably like to use all of the clusters represented in the various constructed phylogenetic trees. However, such a set of clusters cannot usually be expressed as a single phylogenetic tree. Therefore, it is necessary to construct a phylogenetic network to express the set of clusters. Several recent publications have studied this problem (<ref type="bibr" target="#b7">Huson and Rupp, 2008;</ref><ref type="bibr" target="#b11">Huson et al., 2009;</ref><ref type="bibr" target="#b23">van Iersel et al., 2010</ref>). Note that individual gene trees will probably contain a mixture of correct and incorrect clusters; however, in our article, we assume that all clusters contained by these trees are correct. The rooted phylogenetic network can, in theory, be used to explicitly describe evolution in the presence of reticulate events such as hybridization, horizontal gene transfer and recombination. However, in biology, those reticulate events are rare (<ref type="bibr" target="#b14">Linder et al., 2004;</ref><ref type="bibr" target="#b18">Nakhleh, 2010</ref>). Consequently, it is reasonable that the desired network should minimize the number of reticulate nodes contained in the network. The CASS algorithm (van<ref type="bibr" target="#b23">Iersel et al., 2010</ref>) can construct a network with fewer reticulate nodes than any other available method, but it is not suitable when the input consists of large datasets or datasets that need many reticulate nodes. Moreover, the networks constructed by CASS are dependent on the order of input data, i.e. it generally constructs different phylogenetic networks when the order of the input data is different. In the following, we use the redundant clusters in a network to refer to the clusters that remain after removing the input clusters from all of the clusters represented by the network. In the context of phylogenetic analysis, the clusters represent putative monophyletic groups of related species. Biologically, the ideal situation would be that all of the clusters represented in the input trees would be represented in the constructed network, and no others. Therefore, we invoke the parsimony principle to argue that the best constructed network for representing a set of clusters in the soft-wired sense is one that minimizes the number of redundant clusters; this is based on the premise that there will be as few reticulate nodes as possible. This new criterion brings the model closer to the above ideal situation. To achieve this aim, we introduce an improved CASS algorithm called LNETWORK, which constructs a network that represents the given set of clusters in the soft-wired sense. LNETWORK is significantly faster than CASS and effectively weakens the influence of the input data order. Moreover, LNETWORK can construct a network that represents fewer redundant clusters and has fewer reticulate nodes than most other programs. Furthermore, the trees represented by the networks constructed by LNETWORK are closer to the input trees than those represented by the networks produced by the other programs we consider.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>A rooted phylogenetic network N on X is a directed acyclic graph with a single node of indegree 0, called the root, and the leaves bijectively labeled as X. The indegree of a node v is denoted by À ðvÞ. Any node v where À ðvÞ41 is called a reticulate node or a reticulation, and all of the other nodes are called tree nodes. Any edge leading to a reticulate node is called a reticulate edge, and all of the other edges are called tree edges. The reticulation number of a network N ¼ ðV, EÞ is defined as P v2V: À ðvÞ40 ð À ðvÞ À 1Þ ¼ jEj À jVj þ 1. The number of reticulate nodes in a network N ¼ ðV, EÞ, denoted by r N , is r N ¼ jfv : v 2 V, À ðvÞ41gj. The reticulation number of a network is no less than the number of reticulate nodes in the network. The number of reticulate nodes is used as a variable in the following Theorem 2, whereas the reticulation number is used to describe the complexity of a network. A graph is called connected if every pair of nodes is connected by some (undirected) path. A cut node or cut edge is a node or edge (except for leaves or edges leading to leaves), respectively, whose removal will disconnect the graph. A graph is biconnected if it contains no cut nodes. A biconnected component of a graph is a maximal biconnected subgraph. A network is said to be a level k network if each biconnected component has a reticulation number of at most k. A level k network is called a simple level k network if it has no cut nodes. A network is binary if each reticulate node has indegree 2 and outdegree 1, and each tree node that is not a leaf has outdegree 2. A network has tree-child property if every internal node has at least one child that is a tree node. A network N ¼ ðV, EÞ is time consistent if it has a time assignment, i.e. a mapping : V ! IN, such that ðuÞ5 ðvÞ for a tree edge ðu, vÞ and ðuÞ ¼ ðvÞ for a reticulate edge ðu, vÞ. Let X be a set of taxa. A cluster C on X is any subset of X , excluding both the empty set ; and the full set X. Two different clusters, C 1 and C 2 , on X are called compatible if C 1 \ C 2 ¼ ; or</p><formula>C 1 &amp; C 2 or C 2 &amp; C 1 ;</formula><p>otherwise they are called incompatible. A cluster set C on X is called compatible if and only if C is pairwise compatible; otherwise it is called incompatible. The incompatibility graph IGðCÞ ¼ ðV, EÞ for C is an undirected graph with node<ref type="figure">Fig. 1</ref>. The network N is on {x, y, z, w, t}. Consider the cluster C ¼ {x,y}. When switching the edge b on and a off, the set of leaves reachable from e is equal to C, so N represents the cluster C in the soft-wired sense. However, the network does not represent the cluster C in the hard-wired sense, as there is no tree edge for which the set of taxa below the edge equals C. The tree edge e represents the cluster {x,y,z} in the hard-wired sense. The rooted phylogenetic trees T 1 and T 2 are both trees represented by N set V ¼ C and edge set E, such that any two clusters C 1 , C 2 2 C are connected by an edge if and only if they are incompatible. For each pair of incompatible clusters, C 1 , C 2 2 C, an incompatibility statement is defined by the three terms C 1 nC 2 , C 1 \ C 2 and C 2 nC 1. Let C be a set of clusters on X. Given a subset S of X , the restriction of C to S, denoted by Cj S , is the result of removing all of the elements in XnS from each cluster in C. S with jSj41 is called an ST-set (strict tree set) with respect to C if S and any one cluster C 2 C are compatible, and Cj S is also compatible. An STset S is maximal if there are no other ST-sets containing S except itself. There is a subtree with respect to a maximal ST-set S, which is constructed for the cluster set fCjC 2 C, C &amp; Sg [ S. An ancestor u of a node v in a network N ¼ ðV, EÞ is called a stable ancestor if each path from the root to v passes through u; otherwise it is called an unstable ancestor. Conversely, v is called a stable descendant of u if u is a stable ancestor of v, and v is called an unstable descendant of u if u is an unstable ancestor of v. The tripartition associated with a tree edge e ¼ ðu, vÞ in N (N is on X ) is ðeÞ ¼ ðAðeÞ, BðeÞ, CðeÞÞ, where AðeÞ ¼ fx 2 Xjx is a stable descendant of vg, BðeÞ ¼ fx 2 Xjx is an unstable descendant of vg and CðeÞ ¼ fx 2 Xjx is not a descendant of vg. Here we use ÂðNÞ to denote all tripartitions in N. The tripartition distance between two networks N 1 and N 2 is jÂðN 1 ÞÁÂðN 2 Þj=2, where Á denotes the symmetric difference. The tripartition distance is a metric on the set of all of the rooted phylogenetic networks that have the tree-child property and are time consistent (<ref type="bibr" target="#b1">Cardona, 2009</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">CASS algorithm</head><p>Consider a set of taxa X and a set of clusters C on X. The CASS algorithm includes several steps to construct a network for C as follows. First, it finds all of the non-trivial biconnected components C 1 , Á Á Á , C p of the incompatibility graph IGðCÞ. For each C i , i 2 f1, Á Á Á , pg, let C 0 i be the result of collapsing all of the maximal ST-sets for C i. As it does not know the level number of the network for C 0 i , it first sets k ¼ 0. Then CASS(k) seeks to construct a simple level k network, i.e. N i , for C 0 i. If there exists such a network, it outputs the resulting network and halts; otherwise it lets k ¼ k þ 1 and continues. This is pivotal for constructing networks. Second, CASS constructs a unique phylogenetic tree T for the cluster set C 00 , which contains the clusters that remain after removing all of the clusters in C 1 , Á Á Á , C p from C, and all of the clusters that consist of all of the taxa of each C i , i 2 f1, Á Á Á , pg, and all of the maximal STsets of C 1 , Á Á Á , C p. Third, it integrates T with all of the simple level k networks, N 1 , Á Á Á , N p , to obtain the resulting level k network, using ancestor nodes displacement.As we have seen, when constructing the simple level k network for the non-trivial biconnected components C 0 i , CASS first sets k ¼ 0, then runs CASS(k). If CASS(k) returns a network that is not an empty network, it halts; otherwise it lets k ¼ k þ 1 and continues. Assuming that there is a set of clusters represented by a level l network, we can imagine that CASS must run CASS(0), CASS(1), Á Á Á, CASS(l) until it has constructed the level l network. This results in an excessive consumption time for a high level l. When running CASS(k), the label of the node below the reticulate node is uncertain, so each taxon, x 2 X, must be tried repeatedly until the network N represents the complete set of clusters. Such uncertainty also results in constructed networks that are greatly dependent on the order of input data. However, the following Theorem 2 shows that there is a network for a given set of clusters, and the network has certain labels below its reticulate nodes. We use Theorem 2 to develop the LNETWORK algorithm. Our experiments show LNETWORK is faster than CASS and weakens the influence of input data order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Seed-growing algorithm</head><p>The seed-growing algorithm (<ref type="bibr" target="#b11">Huson et al., 2009</ref>) has been used to solve the Restricted Maximum Compatible Subset (RMCS) problem for an incompatible cluster set C, i.e. it finds a minimum set of taxa R &amp; X, such that Cj XnR is compatible. Suppose that L is the list of all of the incompatibility statements for C. The algorithm maintains a set of candidate solutions S, called seeds. A seed s Ã resolves an incompatibility statement X, Y, Z, if X s Ã or Y s Ã or Z s Ã. Each seed s 2 S is labeled by the number rank(s) of incompatibility statements that it has been shown to resolve in succession, starting from the beginning of the list L. Initially, the three parts of the first incompatibility statement are chosen as three seeds, and we set rank(s)¼ 1 for each seed s. The algorithm chooses a seed s Ã that has a minimum size among all of the seeds. If rank(s Ã Þ ¼ jLj, then s Ã is an optimal solution and the algorithm halts. Otherwise, if s Ã resolves the (rank(s Ã )þ1)-th incompatibility statement X, Y, Z, we increment rank(s Ã ) by 1; otherwise, we define three new seeds</p><formula>s 1 ¼ s Ã [ X, s 2 ¼ s Ã [ Y and s 3 ¼ s Ã [ Z, with rand(s 1 ) ¼ rand(s 2 ) ¼ rand(s 3 ) ¼ rand(s Ã ) þ 1</formula><p>, and then we add these to S and remove s Ã from S. The above steps repeat until the algorithm halts. Let A be a solution found by the seed-growing algorithm. We then add A to A, where A is a solution set of the RMCS problem for C. Further, for each seed s 2 S with jsj ¼ jAj, if s is also a solution of the RMCS problem for C, we add s to A. A will be applied in the context of LNETWORK.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DEFINITIONS, LEMMAS AND THE MAIN THEOREM</head><p>The incompatibility degree of a cluster set C, denoted by dðCÞ, is equal to the number of edges in the incompatibility graph IGðCÞ. The incompatibility degree of a taxon x 2 X with respect to C, denoted by d(x), is dðxÞ ¼ dðCÞ À dðCj Xnfxg Þ. The frequency of a taxon x 2 X with respect to C, denoted by f (x), is f ðxÞ ¼ jfC 2 Cjx 2 Cgj. A cluster C 2 C is called a minimal cluster if there is no cluster C 0 2 C such that C 0 (C. For two clusters, C 1 and C 2 , we say C 1 5C 2 if C 1 (C 2. Let C 0 be a cluster on X. We say C5C 0 if C5C 0 for any cluster C 2 C. Given a set of seeds S, for any two seeds, s 1 , s 2 2 S, with js 1 j ¼ js 2 j, we define the order of s 1 and s 2 as follows. Let s 1 ¼ fa 1 , a 2 , Á Á Á , a n g and s 2 ¼ fb 1 , b 2 , Á Á Á , b n g. We say s 1 4s 2 if dða i Þ4dðb i Þ, where a i and b i are the first pair of taxa with different incompatibility degrees, or if for all of i 2 f1, 2, Á Á Á , ng, dða i Þ ¼ dðb i Þ and fða j Þ4fðb j Þ, where a j and b j are the first pair of taxa with different frequencies; otherwise s 1 ¼ s 2. Suppose that the seed-growing algorithm finds that A ¼ fa 1 , a 2 , Á Á Á , a n g is a solution of the RMCS problem for C. Then, for each element a i , i 2 f1, 2, Á Á Á , ng, let C i ¼ fC 2 Cj a i 2 Cg. Let C ¼ C 1 \ C 2 \ Á Á Á \ C t and M ¼ ðC 1 nCÞ [ ðC 2 nCÞ [ Á Á Á [ ðC t nCÞ, where t n. We can say that fa 1 , a 2 , Á Á Á , a t g can be merged, if M5A, where A can be seen as a cluster.PROOF. See the Supplementary Material. From Lemma 1, it follows that B ¼ fa 1 , a 2 , Á Á Á , a t g can be merged if and only if any subsets of B can be merged. We merge elements that can be merged for A such that A ¼ fA 1 , A 2 , Á Á Á , A k g, where A i ¼ fa i1 , a i2 , Á Á Á , a imi g, A i \ A j ¼ ;ði 6 ¼ jÞ, i, j 2 f1, 2, Á Á Á , kg and P k l¼1 m l ¼ n. Each A i is called a removed taxon with respect to C. A removed taxon A i is called trivial if it contains only one element; otherwise it is called nontrivial. Let C i ¼ fC 2 CjC A, C \ A i 6 ¼ ;g and i 2 f1, 2, Á Á Á , kg. A i and A j ði 6 ¼ jÞ are called conflicting if there exists a cluster C 2 C i [ C j , such that C, A i are incompatible, and C, A j are incompatible. A i is called conflicting if the cluster set Cj Ai is incompatible. Then, C 0 ij ¼ fC 2 C i [ C j j C, A i are incompatible, and C, A j are incompatibleg is called the conflicting cluster set of A i and A j , whereas C 0 i ¼ fC 1 , C 2 2 Cj Ai jC 1 and C 2 are incompatibleg is called the conflicting cluster set of A i. Obviously, if A i and A j are conflicting then A i or A j is non-trivial, and if A i is conflicting then A i is non-trivial. A is called decomposable if there is a conflicting removed taxon A i 2 A, or if there are two removed taxa A i , A j 2 A, such that A i and A j are conflicting; otherwise it is called indecomposable. Let A c ¼ fi 2 f1, 2, Á Á Á , kgjA i is conflicting, or there exists a removed taxon A j 2 A, such that A i and A j are conflictingg. Let</p><formula>C 0 ¼ [ i, j2Ac C 0 ij [ i2Ac C 0 i [ i2Ac fA i g: ð3:1Þ</formula><p>C 0 is obviously incompatible when A is decomposable; hence, the seed-growing algorithm can find a solution A 0 ¼ fA 0 1 , A 0 2 , Á Á Á , A 0 m g for C 0 after merging the elements that can be merged. We subsequently decompose A by means of A 0 as follows.g; for the sake of brevity, we denote this as A ¼ fA 1 , A 2 , Á Á Á , A k g. Then, if A is still decomposable, we compute C 0 using Formula (3.1). Further, we obtain a solution A 00 for the RMCS problem for C 0 using the seed-growing algorithm, and merge the elements for A 00 that can be merged. Subsequently, we decompose A by means of A 00 using the decomposing process. We repeat the above steps until A is indecomposable, at which point we say that A has undergone decomposing. Suppose that A ¼ fA 00 1 , A 00 2 , Á Á Á , A 00 k g is indecomposable. For each A 00 i , i 2 f2, Á Á Á , k À 1g, we say that the removed order of</p><formula>A 00 i is after A 00 1 , A 00 2 , Á Á Á , A 00 iÀ1 and before A 00 iþ1 , Á Á Á , A 00 k .</formula><p>Specifically, the removed orders of A 00 1 and A 00 k are the first and the last, respectively. For each A 00 i with jA 00 i j41, we need to decide its removal order using the following sorting process. Sorting:</p><formula>Let C i ¼ fC 2 CjC A and C \ A 00 i 6 ¼ ;g, i 2 f1, 2, Á Á Á</formula><p>, kg. If there exists a cluster C 2 C i , such that C and A 00 i are incompatible, then C 1 ¼ CnA 00 i. A 00 j should be before A 00 i if A 00 j C 1 ði 6 ¼ jÞ. Then we sort A. After applying the sorting process to A 00 i with jA 00 i j41, i 2 f1, Á Á Á , kg, we get A ¼ fA 1 , A 2 , Á Á Á , A k g, which is a permutation of A ¼ fA 00 1 , A 00 2 , Á Á Á , A 00 k g. Then we say that A has undergone sorting. THEOREM 2. Let C be a cluster set on X with IGðCÞ connected and assume that there are no ST-sets with respect to C. A ¼ fA 1 , A 2 , Á Á Á , A k g is a solution of the RMCS problem for C, which has undergone decomposing and sorting. Then there will be a network N, with r N ¼ k representing C, and the leaves below the reticulate nodes of N will be A 1 , A 2 , Á Á Á , A k , respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF. See the Supplementary Material.</head><p>Theorem 2 tells us that there is a network representing the given cluster set and the leaves below the reticulate nodes are the removed taxa. However, because of the method of inserting the new nodes that have a child that is a reticulate node, the network N constructed by the proof of Theorem 2 represents too many redundant clusters. Therefore, when inserting those nodes, the LNETWORK(k) algorithm follows the CASS(k) algorithm, i.e. it tries to add the nodes below each pair of edges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">LNETWORK</head><p>LNETWORK first decomposes the incompatibility graph IGðCÞ into biconnected components, as does CASS, and then constructs a simple level k network by applying LNETWORK(k) to each non-trivial biconnected component separately. Then it integrates those simple level k networks into a final network. The process with which LNETWORK(k) constructs a simple level k network is as follows. Let A be the solution set of the RMCS problem for C found by the seed-growing algorithm. Then, LNETWORK(k) chooses a solution A from A such that A ! B for any element B 2 A. This step aims at weakening the influence of input data order by fixing the solution of the RMCS problem for C when the input order of C is changed. The decomposing process is then applied repeatedly until A is indecomposable. Subsequently, the sorting process is applied. Then A ¼ fA 1 , A 2 , Á Á Á , A k g. LNETWORK(k) first removes A 1 from each cluster of C. It subsequently collapses all of the maximal ST-sets of Cj XnA1. These steps repeat k times until the resulting cluster set is compatible and the second phase of the algorithm starts. LNETWORK(k) creates a network consisting of a unique phylogenetic tree for the resulting cluster set. Then the algorithm 'expands'. Subsequently, LNETWORK(k) adds a new leaf below the new reticulate node and labels it as the removed taxon of this step. Then LNETWORK(k) tries to add the reticulate node below each pair of edges. The algorithm continues with a new 'expand' step and then hangs the next leaf below a reticulate node. LNETWORK(k) will save this network if it represents the cluster set of this step. LNETWORK(k) finds all of the networks representing the cluster set of this step and sorts them in descending order of the number of clusters represented; this reduces the number of redundant clusters in the resulting network and weakens the influence of input data order. These steps are repeated until all of the removed taxa are appended to the networks. LNETWORK outputs the resulting network, which now has the minimal number of redundant clusters. The resulting network is a simple level k network, where k is no less than the number of removed taxa. In particular, when the resulting network is binary, k equals the number of removed taxa. For ease of description, sometimes the construction technique mentioned in this paragraph is called as the remove-collapse-expand-attach technique of LNETWORK. LNETWORK(k) adds a new dummy taxon to the network when it constructs the reticulate nodes with indegree 42. The dummy taxon is removed before it outputs the resulting network. We give the pseudo-code of the LNETWORK(k) algorithm in the Supplementary Material. LEMMA 3. LNETWORK(k) runs in time Oðm 2 d3 m þ ðk 2 þ jXj 2 Þ2 k Þ, where d is the incompatibility degree of the cluster set C and m is the size of the solution of the RMCS problem for C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF. See the Supplementary Material.</head><p>In the Supplementary Material, there is an example illustrating all of the steps of LNETWORK(k) as it constructs a simple level k network.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>All of the experiments were performed on a computer with an Intel Xeon E5504 2.0 GHz CPU, 8GB RAM and 147GB HDD. The operating system was Debian 4.1 32 bit with Java 1.6 installed. LNETWORK was written in Java. We tested LNETWORK with both the practical (i.e. real biological data) and artificial data (https://sites.google. com/site/cassalgorithm/data-sets) used by CASS and compared the results of LNETWORK with those of other programs. The results are summarized in Tables 1, 2 and 3. The experiments test two main aspects of the LNETWORK algorithm. First, they test the influence of input data order; the results are shown in<ref type="figure" target="#tab_1">Table 1</ref>. Second, they test the complexities of the network, i.e. the level, the reticulation number and the redundant cluster number; the results are shown in Tables 2 and 3.</p><p>To test the influence of the input data order, for each dataset the program constructs the networks for every permutation of input data order. The running time for this process is factorial; thus, in the experiment the scale of data considered is small. To compare the differences between the constructed networks, we use the tripartition distances of networks.<ref type="figure" target="#tab_1">Table 1</ref>shows, for each dataset, the number (n) of the different networks constructed by each program and the mean, the minimum (min) and theNote: t, k, r and c represent, respectively, the running time, the level, the reticulation number and the redundant cluster number.Note: n represents the number of constructed networks, and mean, min, max represent, respectively, the mean, the minimum, the maximum of tripartition distances of those networks. Each dataset has jCj clusters and jX j taxa. maximum (max) of tripartition distances of those networks; the last row gives their average values. Our conclusions about the superiority of LNETWORK are based on the following observations. First, the number of different networks constructed by LNETWORK is less than the number of different networks constructed by CASS for the same data with different input orders. Second, the tripartition distance between the networks constructed by LNETWORK is less than that between the networks constructed by CASS; this demonstrates that, if LNETWORK outputs more than one network when the input order of the data is changed, the networks constructed by LNETWORK are more similar to each other than the networks constructed by CASS. Thus, LNETWORK effectively weakens the influence of input data order compared with CASS.<ref type="figure" target="#tab_2">Table 2</ref>compares the results of LNETWORK with the results of CASS for several artificial datasets.<ref type="figure" target="#tab_2">Table 2</ref>shows the level k, the reticulation number r, the redundant cluster number c and the running time t in hours (h), minutes (m) and seconds (s) for the two algorithms; the last row gives their average values. The comparison shows that LNETWORK takes less time than CASS, and that the level and the reticulation numbers of the networks constructed by LNETWORK are the same as the level and the reticulation numbers of the networks constructed by CASS in almost every case. Furthermore, the networks constructed by LNETWORK have fewer redundant clusters than the networks constructed by CASS in almost every case. The study by van Iersel et al. compared HYBRID INTERLEVE (<ref type="bibr" target="#b2">Collins et al., 2011</ref>) and Parsimonious Inference of Reticulate Network (PIRN) (<ref type="bibr" target="#b27">Wu, 2010)</ref>with CASS. In this study, we compare LNETWORK with CASS, the galled network (<ref type="bibr" target="#b11">Huson et al., 2009</ref>) and the cluster network (<ref type="bibr" target="#b7">Huson and Rupp, 2008</ref>) using practical data.<ref type="figure" target="#tab_3">Table 3</ref>shows that the average reticulation number of LNETWORK is slightly more than that of CASS and less than that of the other two programs. The networks constructed by LNETWORK represent fewer redundant clusters than those constructed by the other programs. In terms of running time, LNETWORK is faster than CASS in general, but is slower than the cluster network and the galled network algorithms. Even so, the running time of LNETWORK is acceptable. Thus LNETWORK is superior to the other algorithms when we consider running time, number of reticulations and number of redundant clusters. Tables 2 and 3 show that when the constructed networks are binary, the level and the reticulation number of the network constructed by LNETWORK are the same as the level and the reticulation number of the network constructed by CASS when the same input data are used. We ran LNETWORK and CASS on the simulation data randomly generated by the PHYL-O-GEN tool (http://tree.bio.ed.ac. uk/software/phylogen/).<ref type="figure" target="#tab_4">Table 4</ref>shows the results of only LNETWORK as CASS did not finish within 10 days. These results suggest that LNETWORK can construct networks for datasets thatneed high levels and many reticulations. This conclusion is illustrated in<ref type="figure" target="#fig_1">Figure 2</ref>, which shows the output of LNETWORK when it is given real data consisting of all of the clusters in at least one of the four gene trees from a Pinaceae dataset. Finally, we compare the performance of LNETWORK, CASS, the galled network and the cluster network using simulation data generated by the Recodon tool (<ref type="bibr" target="#b0">Arenas and Posada, 2007</ref>) (http://darwin.uvigo.es/). We use the tool to randomly generate 700 datasets, and then run these datasets using each program. This tests how well the LNETWORK algorithm constructs networks for input tree sets by comparing the topology structure of the input trees with the trees represented by the resulting constructed network. We first list the trees represented by the constructed network. Let T be the input tree set and N be the set of trees represented by the constructed network for the input tree set. We then compute the Robinson–Foulds (RF) distance (<ref type="bibr" target="#b20">Robinson and Foulds, 1981</ref>) between any one tree in N and any one tree in T. For any two trees T 1 and T 2 , the RF distance between them is denoted as RF(T 1 , T 2 ). Two trees are identical if the RF distance between them is zero. The false positive (FP) is the fraction of trees in N that do not exist in T. The false negative (FN) is the fraction of trees in T that do not exist in N. For any one tree T in N , the degree of false positive (DFP) of T, denoted by DFP(T), is defined as DFP(T) ¼ min{RF(T, T 0 ÞjT 0 2 T }. For any one tree T in T , the degree of false negative (DFN) of T, denoted by DFN(T), is defined as DFN(T) ¼ min{RF(T, T 0 ÞjT 0 2 N }. For each of the 700 datasets, we compute the size of N (SIZE), FP, FN, mean DFP (MDFP) and mean DFN (MDFN).<ref type="figure" target="#tab_5">Table 5</ref>shows the average of those values. The mean size of the input tree sets is 2.3652. The table shows that the mean size of trees represented by the networks constructed by LNETWORK is closer to the mean size of input tree sets than the mean size of trees represented by the networks constructed by the other programs, and the mean FP, the mean FN, the mean MDFP and the mean MDFN of the networks constructed by LNETWORK are less than those of the networks constructed by the other programs. Thus, the networks constructed by LNETWORK are closer to the input tree sets than the networks constructed by the other programs.Note: The best value in every column is displayed in bold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>LNETWORK</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>CASS(k) constructs the simple level k network for the nontrivial biconnected components C 0 i as follows. It loops over all taxa x. For each choice of x, CASS(k) tries x as the label of the leaf below the reticulate node, and thus CASS(k) removes it from each cluster. It subsequently collapses all of the maximal ST-sets of the resulting cluster set. CASS(k) repeats this step k times. If, after this process, the resulting clusters C 0 are compatible, then CASS(k) creates a network consisting of a phylogenetic tree for C 0 ; otherwise CASS(k) returns an empty network. Further, CASS(k) 'expands', i.e. it replaces each leaf labeled with a maximal ST-set S with the subtree of S. Then, CASS(k) adds a new leaf below the new reticulate node and labels it as the latest removed taxon. As it does not know where to add the new reticulate node, CASS(k) tries to add the reticulate node below each pair of edges. These steps are repeated k times. For the constructed simple level k network, CASS(k) checks whether it represents all of the input clusters. If it does, then the algorithm returns the resulting network; otherwise it returns an empty network.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. A level-15 network with 23 taxa, 15 reticulations and 1236 redundant clusters constructed by LNETWORK for the four gene trees of the Pinaceae datasets, within 15 days. All of the clusters that were present in at least one of the four gene trees were used. CASS did not finish the process within 30 days. For the same input, the galled network produced a level-16 network with 16 reticulations and 3197 redundant clusters, and the cluster network produced a level-31 network with 31 reticulations and 45239 redundant clusters</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>LEMMA 1. Given three cluster sets C 1 , C 2 and C 3 on X and a cluster C 0 on X , let M 1 ¼ ðC 1 nðC 1 \ C 2 ÞÞ [ ðC 2 nðC 1 \ C 2 ÞÞ, M 2 ¼ ðC 1 nðC 1 \ C 3 ÞÞ [ ðC 3 nðC 1 \ C 3 ÞÞ, M 3 ¼ ðC 2 nðC 2 \ C 3 ÞÞ[ ðC 3 nðC 2 \ C 3 ÞÞ, C ¼ C 1 \ C 2 \ C 3 and M ¼ ðC 1 nCÞ [ ðC 2 nCÞ[ ðC 3 nCÞ. Then M5C 0 if and only if M 1 5C 0 , M 2 5C 0 and M 3 5C 0 .</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 2. Results of LNETWORK and CASS for artificial datasets with jCj clusters and jXj taxa</figDesc><table>Data 
LNETWORK 
CASS 

jCj 
jXj 
t (s) k 
r 
c 
t 
k 
r 
c 

14 
4 
0 
3 
3 
0 
1s 
3 
3 
0 
30 
5 
2 
4 
4 
0 
2s 
4 
4 
0 
62 
6 
18 
5 
5 
0 
11 s 
5 
5 
0 
42 
10 
1 
4 
4 
14 
10s 
4 
4 
34 
39 
11 
38 
6 
6 
18 
21s 
5 
5 
7 
61 
11 
15 
6 
6 
43 
1m26s 
5 
5 
48 
75 
30 
1 
2 
2 
19 
4s 
2 
2 
19 
180 
51 
4 
2 
2 
0 
40s 
2 
2 
0 
70 
56 
1 
1 
4 
0 
1 s 
1 
4 
0 
270 
76 
12 
2 
2 
0 
6 m 22 s 
2 
2 
0 
404 
122 
44 
2 
2 
0 
1h14m 2 
2 
0 
113.4 
34.7 13 
3.4 3.6 
8.5 7 m 34 s 
3.2 3.5 10 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><figDesc>Table 1. The influence of input data order on the LNETWORK and CASS algorithms</figDesc><table>Data 
LNETWORK 
CASS 

jCj 
jXj 
n 
mean min max n 
mean min max 

35 
22 
1 
0 
0 
0 
2 
6.5 
6.5 
6.5 
25 
15 
1 
0 
0 
0 
2 
3 
3 
3 
22 
13 
2 
1 
1 
1 
2 
0.5 
0.5 
0.5 
27 
15 
2 
1 
1 
1 
3 
3 
3 
3 
25 
13 
3 
1.2 
0.5 
1.5 
4 
6.3 
2 
7.5 
22 
11 
1 
0 
0 
0 
3 
3 
2.5 
3.5 
17 
10 
3 
1.3 
1 
1.5 
3 
2 
1.5 
2.5 
13 
8 
2 
1 
1 
1 
4 
3.6 
1.5 
4 
23 
11 
2 
1 
1 
1 
4 
5.6 
3 
7.5 
18 
10 
3 
2.5 
1.5 
3.5 
4 
1.5 
0.5 
3 
22 
11 
1 
0 
0 
0 
3 
3.2 
1.5 
5 
12 
10 
1 
0 
0 
0 
2 
3 
3 
3 
21 
10 
2 
1.5 
1.5 
1.5 
4 
3.9 
1.5 
5.5 
13 
7 
2 
1 
1 
1 
4 
3.8 
1.5 
4 
22 
10 
1 
0 
0 
0 
2 
1.5 
1.5 
1.5 
21.3 11.7 1.8 1.2 
1.1 
1.4 
3.1 3.4 
2.2 
4 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 4. Results of LNETWORK for the simulation data generated by the PHYL-O-GEN tool</figDesc><table>LNETWORK 

jCj jXj k r 
c 
t 
jCj jXj k r 
c 
t 

288 148 7 39 71 5 s 
524 240 8 78 197 11 m 26 s 
286 120 10 39 84 14 m 6 s 488 220 14 74 221 48 h 
206 100 7 30 87 11.6 s 
292 150 8 43 119 27 s 
185 100 8 29 87 35.8 s 
341 150 14 51 163 25 h 38 m 
189 100 11 33 90 5 m 9 s 343 150 10 47 113 5 m 14 s 
218 100 10 32 91 3 m 35 s 372 150 9 47 75 2 m 36 s </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 5. Results of LNETWORK, CASS, the cluster network and the galled network for the simulation data generated by the Recodon tool</figDesc><table>Method 
SIZE 
FP 
FN 
MDFP 
MDFN 

LNETWORK 
2.7869 
0.1235 
0.0650 
0.1605 
0.0481 
CASS 
2.8006 
0.1368 
0.0863 
0.1753 
0.0576 
Galled network 
2.9410 
0.1432 
0.0899 
0.1832 
0.0579 
Cluster network 
11.1292 
0.5489 
0.1849 
0.7724 
0.1797 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">J.Wang et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="6"> CONCLUSIONS We have presented LNETWORK, which can construct a phylogenetic network for a given set of clusters. We have shown that LNETWORK effectively weakens the influence of input data order compared with CASS, and that the execution time of LNETWORK is shorter than that of CASS. Moreover, we show that the levels and the reticulation numbers of networks constructed by LNETWORK are the same as those of networks constructed by CASS for most datasets, and that the networks constructed by LNETWORK represent fewer redundant clusters than other available methods, for most datasets. We also show that the trees represented by the networks constructed by LNETWORK are closer to the input trees than those represented by the networks constructed by all other tested programs.</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Recodon: coalescent simulation of coding DNA sequences with recombination, migration and demography</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Arenas</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Posada</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">458</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Metrics for phylogenetic networks I: generalizations of the Robinson-Foulds metric</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Cardona</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="46" to="61" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Quantifying hybridization in realistic time</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Collins</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1305" to="1318" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Phylogenetic classification and the universal tree</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">F</forename>
				<surname>Doolittle</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">284</biblScope>
			<biblScope unit="page" from="2124" to="2128" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">A fundamental decomposition theory for phylogenetic networks and incompatible characters</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bansal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth International Conference on Research in Computational Molecular Biology (RECOMB 2005)</title>
		<meeting>the Ninth International Conference on Research in Computational Molecular Biology (RECOMB 2005)<address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="217" to="232" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Introduction to phylogenetic networks</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th Annual Intelligent Systems for Molecular Biology Conference</title>
		<meeting><address><addrLine>Detroit, MI, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Application of phylogenetic networks in evolutionary studies</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Bryant</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="254" to="267" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Summarizing multiple gene trees using cluster networks</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Rupp</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In: Algorithms in Bioinformatics (WABI). Lecture Notes in Bioinformatics</title>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">5251</biblScope>
			<biblScope unit="page" from="296" to="305" />
			<date type="published" when="2008" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">A survey of combinatorial methods for phylogenetic networks</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Scornavacca</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="23" to="35" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Dendroscope 3-An interactive viewer for rooted phylogenetic trees and networks</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Scornavacca</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">61</biblScope>
			<biblScope unit="page" from="1061" to="1067" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Phylogenetic super-networks from partial trees</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="151" to="158" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Computing galled networks from real data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="85" to="93" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Clusters and rooted phylogenetic networks</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Phylogenetic Networks: Concepts, Algorithms and Applications</title>
		<meeting><address><addrLine>Cambridge, UK</addrLine></address></meeting>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Intragenic recombination events and evidence for hybrid speciation in Nicotiana (Solanaceae)</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">J</forename>
				<surname>Kelly</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="781" to="799" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Reconstructing patterns of reticulate evolution in plants</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">R</forename>
				<surname>Linder</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">H</forename>
				<surname>Rieseberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Bot</title>
		<imprint>
			<biblScope unit="volume">91</biblScope>
			<biblScope unit="page" from="1700" to="1708" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Network (reticulate) evolution: biology, models, and algorithms</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">R</forename>
				<surname>Linder</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Ninth Pacific Symposium on Biocomputing</title>
		<meeting><address><addrLine>Hawaii, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Hybridisation in nonbinary trees</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Linz</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Semple</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="30" to="45" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Gene trees in species trees</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">P</forename>
				<surname>Maddison</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="523" to="536" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<monogr>
		<title level="m" type="main">Evolutionary phylogenetic networks: models and issues (eds) The Problem Solving Handbook for Computational Biology and Bioinformatics</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Nakhleh</surname>
			</persName>
		</author>
		<editor>Heath,L.L.S. and Ramakrishnan,N.</editor>
		<imprint>
			<date type="published" when="2010" />
			<publisher>Springer US</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Hybrid origins of plant species</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">H</forename>
				<surname>Rieseberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Ecol. Evol. Syst</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="359" to="389" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Comparison of phylogenetic trees</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">F</forename>
				<surname>Robinson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">R</forename>
				<surname>Foulds</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Biosci</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="131" to="147" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Speciation within genomic networks: a case study based on Steatocranus cichlids of the lower Congo rapids</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Schwarzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Evol. Biol</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="138" to="148" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Constructing minimal ancestral recombination graphs</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<forename type="middle">S</forename>
				<surname>Song</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Hein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comp. Biol</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="147" to="169" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Phylogenetic networks do not need to be complex: using fewer reticulations to represent conflicting clusters</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Van Iersel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="124" to="131" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Indehiscent sporangia enable the accumulation of local fern diversity at the Qinghai-Tibetan Plateau</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Evol. Biol</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="158" to="169" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Filtered Z-closure supernetworks for extracting and visualizing recurrent signal from incongruent gene trees</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">B</forename>
				<surname>Whitfield</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="939" to="947" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">A comparison of phylogenetic network methods using computer simulation</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">M</forename>
				<surname>Woolley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Plos One</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">1913</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Close lower and upper bounds for the minimum reticulate network of multiple phylogenetic trees</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Wu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="140" to="148" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>