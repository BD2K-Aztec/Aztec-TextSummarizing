
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:28+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Algorithms for sorting unsigned linear genomes by the DCJ operations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011">2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Haitao</forename>
								<surname>Jiang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Montana State University</orgName>
								<address>
									<postCode>59717</postCode>
									<settlement>Bozeman</settlement>
									<region>MT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science and Technology</orgName>
								<orgName type="institution">Shandong University</orgName>
								<address>
									<settlement>Jinan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Binhai</forename>
								<surname>Zhu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Montana State University</orgName>
								<address>
									<postCode>59717</postCode>
									<settlement>Bozeman</settlement>
									<region>MT</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Daming</forename>
								<surname>Zhu</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computer Science and Technology</orgName>
								<orgName type="institution">Shandong University</orgName>
								<address>
									<settlement>Jinan</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Algorithms for sorting unsigned linear genomes by the DCJ operations</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">27</biblScope>
							<biblScope unit="issue">3</biblScope>
							<biblScope unit="page" from="311" to="316"/>
							<date type="published" when="2011">2011</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq674</idno>
					<note type="submission">Genome analysis Advance Access publication December 6, 2010 Received on September 27, 2010; revised on December 1, 2010; accepted on December 2, 2010</note>
					<note>[13:27 5/1/2011 Bioinformatics-btq674.tex] Page: 311 311–316 Associate Editor: Martin Bishop</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: The double cut and join operation (abbreviated as DCJ) has been extensively used for genomic rearrangement. Although the DCJ distance between signed genomes with both linear and circular (uni-and multi-) chromosomes is well studied, the only known result for the NP-complete unsigned DCJ distance problem is an approximation algorithm for unsigned linear unichromosomal genomes. In this article, we study the problem of computing the DCJ distance on two unsigned linear multichromosomal genomes (abbreviated as UDCJ). Results: We devise a 1.5-approximation algorithm for UDCJ by exploiting the distance formula for signed genomes. In addition, we show that UDCJ admits a weak kernel of size 2k and hence an FPT algorithm running in O(2 2k n) time. Contact:</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Computing genomic distance on gene order is a fundamental problem in computational biology. In the last two decades, a variety of biological operations, such as reversals, translocations, fusions, fissions, transpositions and block-interchanges, have been proposed to handle gene order. The double cut and join operation, introduced by<ref type="bibr" target="#b16">Yancopoulos et al., 2005</ref>, unifies all the classical operations. In the past, the rearrangement distance for signed genomes is well studied for single operations, like reversals (<ref type="bibr" target="#b13">Hannenhalli and Pevzner, 1999</ref>), combinations of operations (reversals, translocations, fusions and fissions) (<ref type="bibr" target="#b12">Hannenhalli and Pevzner, 1995</ref>) and universal operations (double cut and join) (<ref type="bibr" target="#b3">Bergeron et al., 2006;</ref><ref type="bibr" target="#b16">Yancopoulos et al., 2005</ref>). Unfortunately, as for unsigned genomes, most of these problems seem to be NP-hard. Then it is natural to devise relevant approximation algorithms. A 1.5-approximation algorithm was devised for sorting by unsigned reversals (<ref type="bibr" target="#b7">Christie, 1998</ref>), and the approximation factor was improved to 1.375 by<ref type="bibr" target="#b4">Berman et al., 2002.</ref>The problem of sorting by unsigned translocations was investigated by<ref type="bibr" target="#b8">Cui et al., 2008</ref>, and an algorithm with an approximation factor of 1.5+ε was proposed. Transposition, though occurring much less than reversal and translocation, is an indispensable operation in the evolutionary events. The problem of sorting by transpositions was first studied by<ref type="bibr" target="#b2">Bafna and Pevzner, 1998</ref>, who devised a * To whom correspondence should be addressed. 1.5-approximation algorithm running in quadratic time. Later, the approximation factor was improved to 1.375 by<ref type="bibr" target="#b10">Elias and Hartman, 2006</ref>. The problem of sorting by short block-moves, a special but more practical case of transpositions, was studied by Jiang and Zhu, 2011, and they obtained an 14/11-approximation algorithm. The design of FPT algorithms for genome rearrangement problems was started very recently, with the help of weak kernels. (Intuitively, an FPT algorithm is an exact algorithm which runs in polynomial time when the problem solution size, like the number of unsigned reversals to sort a sequence, is bounded by a constant. The relevant formal definitions will be given in the next section.) Both sorting by unsigned reversals and sorting by unsigned translocations admit small weak kernels, hence are in FTP (<ref type="bibr" target="#b14">Jiang et al., 2010</ref>). As far as we know, the only known positive result for sorting unsigned genomes by minimum DCJ operations (or interchangeably, the unsigned DCJ distance problem) is a factor-1.416 approximation for the case of linear unichromosomal genomes (<ref type="bibr" target="#b6">Chen, 2010</ref>). Of course, even in this case the problem involves computing a maximum alternating-cycle decomposition (MAX-ACD) of the breakpoint graph, which is NP-complete (<ref type="bibr" target="#b5">Caprara, 1999</ref>); therefore, it is not surprising that the unsigned DCJ distance problem is NP-complete, even for linear unichromosomal genomes (<ref type="bibr" target="#b6">Chen, 2010</ref>). Prior to our current work, there has been no FPT algorithm known for the unsigned DCJ distance problem.</p><p>Our contributions: In this article, we introduce DCJ operations on unsigned linear multichromosomal genomes to compute the corresponding genomic distance. We devise a 1.5-approximation algorithm for linear multichromosomal genomes in Section 3. In Section 4, we obtain a weak kernel of size 2k for UDCJ; moreover, we present an FPT algorithm running in O(2 2k n) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>Gene, chromosome and genome: An unsigned gene is a sequence of DNA, usually denoted by a positive integer. A chromosome can be viewed as a sequence of genes and denoted by a permutation, while a genome is a set of chromosomes. A gene that lies at the end of some linear chromosome is called an end-gene. Gene i and j form an adjacency if they are consecutive in some chromosome. An adjacency (g i ,g i+1 ) is perfect if it satisfies |g i+1 −g i |=1. A chromosome is perfect if every adjacency is perfect. A genome is perfect if all its chromosomes are perfect. As a convention, we always list the genes in a perfect genome in increasing order. For instance, a perfect genome with 3 chromosomes and 10 genes can be listed as (1, 2, 3, 4), (5, 6, 7) and (8, 9, 10). We study unsigned linearBreakpoint graph: Above all, we recall the well-known tool for computing the genomic rearrangement distance, the Breakpoint Graph (<ref type="bibr" target="#b2">Bafna and Pevzner, 1998</ref>). Given two unsigned genomes A and B on the same set of n genes, the Breakpoint Graph BG(A,B) = (V ,E b ∪E g ), where |V |=n and each vertex in V corresponds to a gene, every adjacency in A forms a black edge belonging to E b and every adjacency in B forms a gray edge belonging to E g. It is known that in this case computing a maximum alternating-cycle decomposition in BG(A,B) is NP-complete (<ref type="bibr" target="#b5">Caprara, 1999</ref>). As for signed genomes F and H, the breakpoint graph BG s (F,H) is a bit different. Due to the sign, each gene has one head and one tail corresponding to two vertices in the breakpoint graph. Consequently, the head has only one adjacency in F and H respectively, so does the tail. Then each vertex in the breakpoint graph has degree at most two, which means that the breakpoint graph is composed of cycles and paths, and the black edges and gray edges appear alternatively in the cycles or paths. So the maximum alternating-cycle decomposition is easy in this case. A cycle that contains l black edges is called an l-cycle.</p><p>The double cut and join operations: The Double Cut and Join operation (abbreviated as DCJ) unifies all the traditional genome rearrangement operations such as reversal, translocation, fusion, fission, transposition and block interchange, as well as excision, integration, circularization and linearization. The formal definition of a DCJ operation on the breakpoint graph is as follows.</p><p>Definition 1. The double cut and join operation acts on the breakpoint graph in the following four ways (<ref type="figure" target="#fig_1">Fig. 1</ref>):</p><p>(1) For two black edges(3) For two end-genes g i and g j , join them with a black edgeNote that the black edges and end-genes involved in one DCJ operation can be in the same chromosome, then a circular chromosome may form after some DCJ operations. Problem statement: We now formally formulate the problem to be investigated in this article. Sorting unsigned genomes by the DCJ operations (UDCJ): Input: Two unsigned linear genomes A and B and an integer k. Question: Can A be converted into B by a series of k DCJ operations ρ 1 ,ρ 2 ,...,ρ k ? The minimum k is the unsigned DCJ distance between A and B. Following the results in (<ref type="bibr" target="#b5">Caprara, 1999;</ref><ref type="bibr" target="#b6">Chen, 2010</ref>), UDCJ is also NP-complete. W.L.O.G, assume that B is perfect. Let l A and l B be the number of linear chromosomes in A and B, respectively, we can also assumethat l A ≥ l B , since all the DCJ operations are reversible, which means that if there exists consecutive DCJ operations ρ 1 ρ 2 ...ρ m that convert A into B, then we can also convert B into A by</p><formula>b 1 = (g i ,g i+1 ) and b 2 = (g j ,g j+1 ),</formula><formula>(g i ,g j ).</formula><formula>(4) For a black edge b = (g i ,g i+1 ),</formula><formula>ρ −1 m ρ −1 m−1 ...ρ −1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Structure properties of UDCJ</head><p>For an unsigned genome A, a signed-version of A is obtained by assigning '+ or '− to each gene in A, with '+ signs usually omitted. Obviously, every genome of n genes has exponential, i.e. 2 n , signed versions. Given two signed genomes F,H, we use DCJ s (F,H) to denote their signed DCJ distance.Proof. Notice that, loosely speaking, we can take B = B +. (⇒) Assume that there exists a series of consecutive DCJ operations ρ 1 ρ 2 ...ρ m that convert A into B. We say that a DCJ operation ρ changes the sign of a gene g if ρ involves reversing a segment of genes including g. For each gene g in A, let T g denote the number of times that the sign of g is changed if we trace all the m DCJ operations. g is assigned '− , if T g is odd; and '+ , if T g is even. Then we obtain a signed version of A, A * , which can be converted into B + by the m equivalent signed DCJ operations.</p><formula>Thus, DCJ(A,B) ≥ DCJ s (A * ,B + ). (⇐)</formula><p>If there exists a signed version A * of A that can be converted into B + by m signed DCJ operations ρ 1 ρ 2 ...ρ m , then we can also use these m (signed) DCJ operations to convert A into B, ignoring the gene signs. Thus DCJ(A,B)</p><formula>≤ DCJ s (A * ,B + ).</formula><p>We now proceed to obtain the necessary properties of the optimal solution. First of all, in order to avoid distinct end points of chromosomes in A and B, we add unlabeled caps to both ends of each linear chromosome in genomes A and B, respectively, then connect the A-cap and its adjacent end-gene with a black edge and the B-cap and its adjacent end-gene with a gray edge in BG(A,B). The above preprocess is called capping. Note that each gene in BG(A,B) has degree 4 after capping, i.e. with two black edges and two gray edges. After capping, genomes A and B become ¯ A and ¯ B, respectively. We denote the resulting graph by BG( ¯ A, ¯ B). As it seems to be hard to extract the properties of the optimal solution from BG( ¯ A, ¯ B) directly, we take a detour. We notice that, for signed genomes F and H, after capping each vertex in the breakpoint graph BG s (F,H) has degree two and each cap has degree one, which means that all the paths end with caps. A path with an A-cap end and a B-cap end (respectively, two A-cap ends, two B-cap ends) is an AB-path (respectively, AA-path, BB-path). There are three ways to construct cycles from BG s (F,H)in the breakpoint graph BG s (F,H) of signed genomes F and H, after capping .</p><p>(1) single-identifying: identify the two caps of each AB-path, close the path into a cycle containing just one A-cap (with the B-cap eliminated).</p><p>(2) double-identifying: identify each B-cap of a BB-path and each A-cap of an AA-path, join an AA-path and a BB-path into a cycle containing two A-caps (with the two B-caps eliminated).</p><p>(3) joining: connect the two A-caps of an AA-path with a gray edge. Let BG s ( ¯ F, ¯ H) denote the resulting breakpoint graph after constructing cycles from BG s (F,H) following the above three ways. Then the signed DCJ distance between the signed genomes ¯ F and ¯ H, DCJ s ( ¯ F, ¯ H) = b−c, where b is the number of black edges and c is the number of cycles in BG s ( ¯ F, ¯ H) (<ref type="bibr" target="#b16">Yancopoulos et al., 2005</ref>). In<ref type="figure" target="#fig_2">Figure 2</ref>, we show an example of ¯ F, ¯ H and BG s ( ¯ F, ¯ H), before the identifying and joining operations are performed. In the figure, an empty round (respectively, square) node is an A-cap (respectively, B-cap); moreover, in BG s ( ¯ F, ¯ H), a signed gene +i (respectively, −i) is already converted to (2i−1,2i) [respectively, (2i,2i−1)]. After two single-identifying operations are performed, we have two new</p><formula>BG s ( ¯ F, ¯ H)</formula><p>, before the identifying and joining operations are performed. cycles (6) and (9, 8, 4, 5, 14). After a double-identifying operation is performed, we have a new cycle (2, 3, 7, 1). After a joining operation is performed, we have a new cycle (12, 13). It is worth mentioning that this distance formula is equivalent to that of<ref type="bibr" target="#b3">Bergeron et al., 2006</ref>, i.e. DCJ s (F,H) = n−C −−I/2, where n is the number of genes, C is the number of cycles and I is the number of odd paths in their corresponding adjacency graph. To see this, note that I also equals to the number of AB-paths in the breakpoint graph; in addition, we have b</p><formula>= n+l A , c = C +I + (2l A −I)/2. So DCJ s ( ¯ F, ¯ H) = DCJ s (F,H).</formula><formula>Corollary 1.</formula><formula>= DCJ s ( ¯ A * , ¯ B + ), where ¯ A * (respectively, ¯ B + ) is a capping of A * (respectively, B + ). Proof. It follows from Theorem 1 that DCJ(A,B) = DCJ s (A * ,B + ). The statements in the last paragraph show that DCJ s (A * ,B + ) = DCJ s ( ¯ A * , ¯ B + ). Then the corollary follows.</formula><p>Notice that computing an alternating-cycle decomposition of BG( ¯ A, ¯ B) is equivalent to finding a signed version of ¯ A. To extract the properties of the optimal solution, we first try to make use of the breakpoint graph BG( ¯ A, ¯ B) instead of BG(A,B). Following Corollary 1, we can now make use of the breakpoint graph</p><formula>BG s ( ¯ A * , ¯ B + ). From the way BG s ( ¯ A * , ¯ B + )</formula><p>is constructed, we only need to find an optimal ¯ A * such that the number of disjoint alternating-cycles in</p><formula>BG s ( ¯ A * , ¯ B + )</formula><p>is maximized. The reason is that the number of black edges in BG( ¯ A, ¯ B) is fixed. Then we have</p><formula>d opt = DCJ(A,B) = DCJ s ( ¯ A * , ¯ B + ) = b−c 1 −c 2 − c 3 ,</formula><p>where b is the number of black edges in</p><formula>BG s ( ¯ A * , ¯ B + ), c 1 and c 2 are the number of 1-cycles and 2-cycles in BG s ( ¯ A * , ¯ B + )</formula><p>, respectively, and c 3 is the number of cycles with three or more black edges in</p><formula>BG s ( ¯ A * , ¯ B + ). Obviously, c 3 ≤ (b−c 1 −2c 2 )/3</formula><p>, thus we have the following formula:</p><formula>d opt = b−c 1 −c 2 −c 3 ≥ b−c 1 −c 2 −(b−c 1 −2c 2 )/3</formula><p>Page: 314 311–316</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H.Jiang et al.</head><formula>(a) ( b) ( c) ( d)</formula><formula>= 2(b−c 1 )/3−c 2 /3 = 2 3 ·(b−c 1 −c 2 /2).</formula><p>The above formula implies that, if we can convert A into B by at most b−c 1 −c 2 /2 DCJ operations, then we obtain a 1.5-approximation algorithm for UDCJ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The algorithm</head><p>The idea of our approximation algorithm is as follows. We compute BG( ¯ A, ¯ B) and try to first keep all the 1-cycles in it. Then we compute many 2-cycles from BG( ¯ A, ¯ B) (in fact, at least c 2 /2 such 2-cycles). We comment that a similar idea was used by Christie (1998) on sorting by unsigned reversals. On the other hand, the LP-relaxation algorithm by Chen, 2010 cannot handle paths (and caps) so it cannot be immediately generalized to solve our problem. The following lemma, which involves handling paths and caps,</p><p>shows that keeping all the 1-cycles in BG( ¯ A, ¯ B) is a good strategy to obtain some optimal alternating-cycle decomposition of it.Proof. We modify the optimal alternating-cycle decomposition in BG( ¯ A, ¯ B) in such a way: if two genes, say g i and g i+1 , are connected by a black edge and a gray edge, then we reassign the signs of these two genes to obtain a 1-cycle; if a gene, say g i , is connected to an A-cap by a black edge and to a B-cap by a gray edge, then we reassign the sign of the gene and identify the two caps to obtain a 1-cycle. If the newly obtained 1-cycle contains two genes, then there are two cases. Case (I): Only one of the signs of g i and g i+1 is changed. W.L.O.G, assume that the sign of g i is changed, see<ref type="figure" target="#fig_3">Figure 3a</ref>. The number of cycles is increased by one. Case (II): Both of the signs of g i and g i+1 are changed, see<ref type="figure" target="#fig_3">Figure 3b</ref>–d. The number of cycles is increased by two or one or unchanged, respectively. If the newly obtained 1-cycle contains one gene and a cap (which is identified by an A-cap a and a B-cap b), then there are four cases. Note that b must be identified with some A-cap a. Case (1): The A-cap a joins with another A-cap a. The number of cycles is unchanged. See<ref type="figure" target="#fig_5">Figure 4a</ref>It is sufficient to prove that G 2 does not contain cycles. Assume to the contrary that 2-cycles C 1 C 2 ...C r form a cycle in G 2 , where C i shares gray edge g i with C i+1 , 1≤ i ≤ r −1, and C r shares g r with C 1. Then C 1 contains two gray edges g 1 and g r , but the end points of g 1 and g r cannot form two black edges (otherwise these two black edges will force into some black cycle—which implies that the input genome contains some circular chromosome). See<ref type="figure" target="#fig_6">Figure 5</ref>. It is obvious that every 2-cycle containing caps has degree at most one in G 2 , because the gray edge containing caps cannot be shared by two 2-cycles computed from M. The property we just proved in Lemma 3 is important for us to compute a maximum independent set in G 2 (without this property, the computation of a maximum independent set might be intractable). Lemma 3 immediately implies the next lemma. Lemma 4. Let S be a maximum independent set in G 2 , then |S|≥ |M| 2. Note that if a gene is contained in some 1-cycle, then its sign can be fixed easily, i.e. if the black edge reads from (left to right) like (i,i+1) then both genes i and i+1 will be given positive signs, otherwise they will be given negative signs. If a gene is contained in some 2-cycle, its sign is fixed similarly. For instance, if in a 2-cycle the two black edges read like (i,j),(i+1,j +1) (from left to right), then the signing should be +i,−j,−(i+1),+(j +1). The other cases, e.g., when the directions of these black edges are possibly changed, are very much symmetric hence omitted. To complete the cycle decomposition, we arbitrarily assign signs to the remaining genes, then properly identify and join the remaining caps in the corresponding breakpoint graph. The complete Whole-Cycle Decomposition algorithm is presented as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Sorting by DCJ operations</head><formula>(a) ( b)</formula><formula>(c) (d)</formula><p>In other words, if the DCJ distance is equal to or smaller than k, there are at most 2 2k signed versions of A among which there must be an optimal one (e.g. A * in Theorem 1). For each signed version of A, we can exploit the algorithm in<ref type="bibr" target="#b3">Bergeron et al. (2006)</ref>;<ref type="bibr" target="#b16">Yancopoulos et al. (2005)</ref>to check whether it can be converted into B + by k or few DCJ operations. If so, we can compute the corresponding k unsigned DCJ operations to convert A into B. If no valid solution is found, we report NO. This algorithm clearly runs in O(2 2k n) = O * (2 2k ) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>In this article, we devise the first approximation algorithm with a factor of 1.5 and an FPT algorithm running in O(2 2k n) time for the NP-complete problem of sorting linear multichromosomal genomes under unsigned DCJ distance. It is interesting to improve the approximation factor as well as the running time of the FPT algorithm. For genomes containing circular chromosomes, our approximation algorithm cannot achieve the same performance as linear genomes, so it is also meaningful to handle the problem of sorting mixed genomes (i.e. with both linear and circular chromosomes) under unsigned DCJ distance.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>Jiang et al. multichromosomal (multilinear or simply linear, for short) genomes in this article.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.1.</head><figDesc>Fig. 1. The DCJ operation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. The breakpoint graph BG s ( ¯ F, ¯ H), before the identifying and joining operations are performed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. 1-cycle containing two genes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>. Case (2): The A-cap a is identified with a B-cap b and a,b belongs to distinct cycles. The number of cycles is unchanged. See Figure 4b. Case (3): The A-cap a is identified with a B-cap b and a,b belongs to the same cycle. The number of cycles is increased by one. See Figure 4c. Case (4): The A-cap a is identified with the B-cap b but the cycle containing a,b also contains two identified caps a and b. The number of cycles is increased by one. See Figure 4d.Page: 315 311–316</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.4.</head><figDesc>Fig. 4. 1-cycle containing one gene and one cap.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.5.</head><figDesc>Fig. 5. An example of 2-cycles sharing gray edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>cut them, and either form two new black edges b 1 = (g i ,g j+1 ) and b 2 = (g j ,g i+1 ) or form two new black edges b 1 = (g i ,g j ) and b 2 = (g i+1 ,g j+1 ). (2) For a black edge b = (g i ,g i+1 ) and an end-gene g j , cut the black edge, and either form a new black edge b = (g i ,g j ) and a new end-gene g i+1 or form a new black edge b = (g j ,g i+1 ) and a new end-gene g i .</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>= DCJ s (A * ,B + ), where A * is some signed version of A, and B +</figDesc><table>Theorem 1. Given two unsigned linear multichromosomal genomes 
A and B, let the minimum DCJ distance between A,B be DCJ(A,B). Page: 313 311–316 

Sorting by DCJ operations 

Then DCJ(A,B) is a special signed version of B with all signs being 
positive. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Given two unsigned linear multichromosomal genomes A and B, let A * and B + be defined as in Theorem 1. Then DCJ(A,B)</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Lemma 1. There is some maximum alternating-cycle decomposition of BG( ¯ A, ¯ B) in which all c 1 1-cycles in BG( ¯ A, ¯ B) are kept.</figDesc><table></table></figure>

			<note place="foot">© The Author 2010. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="1"> , where ρ −1 i is the reversed operation of ρ i. FPT and weak kernel: Basically, a fixed parameter tractable (FPT) algorithm for a decision problem with solution value k is an algorithm, which solves the problem in O(f (k)n c ) = O * (f (k)) time, where f is any function only on k, n is the input size and c is some fixed constant not related to k. FPT also stands for the set of problems that admit such an algorithm (Downey and Fellows, 1999; Flum and Grohe, 2006). Weak kernel is a relatively new concept; intuitively, it refers to the direct or indirect &apos;search space&apos; to solve a search problem. For a search problem in NP, if it admits a weak kernel of size g(k), then it is in FPT (Jiang et al., 2010). We comment that weak kernel is different from the traditional kernel in which the problem instance size is reduced (to a function of k), while a weak kernel only implies that the direct or indirect solution search space is reduced (to a function of k). More details can be found in (Jiang et al., 2010). 3 A 1.5-APPROXIMATION ALGORITHM In this section, we present a 1.5-approximation algorithm for double cut and join distance on unsigned multilinear genomes. We first comment that the method by Chen (2010) cannot be converted to solve our problem, as with multilinear genomes the underlying breakpoint graph is more complex (i.e. possibly with many paths). Given an original genome A with l A chromosomes and a target perfect genome B with l B chromosomes, our goal is to convert A into B by a series of DCJ operations so that the number of DCJ operations is as few as possible. To design an approximation algorithm, we first need the structure properties of UDCJ, which in fact can be obtained from the corresponding signed genomes.</note>

			<note place="foot">Following Lemma 1, we know that keeping all the 1-cycles in in BG( ¯ A, ¯ B) will not affect the value of some optimal alternating-cycle decomposition of it. Therefore, from now on we only focus on the optimal alternating-cycle decomposition of BG( ¯ A, ¯ B), which always keeps all the 1-cycles. Consequently, in order to approximate the optimal DCJ distance, we just need to find out as many as at least half of the 2-cycles in an optimal alternating-cycle decomposition of BG( ¯ A, ¯ B) (which keeps all 1-cycles). Now we present the algorithm 2-Cycle Decomposition to compute such 2-cycles. In this algorithm, we first construct a graph G 1 whose vertices are the black edges (not in any 1-cycle) in BG( ¯ A, ¯ B) and M is a maximum matching in G 1. Note that the maximum matching M can be computed in polynomial time (Galil et al., 1986); moreover, each edge in M results in a candidate 2-cycle. In order to bound the cardinality of S, we need the following lemmas. Lemma 2. Let M be a maximum matching in G 1 , then |M|≥c 2. Proof. Following the discussion in Section 3.1, c 2 corresponds to the number of 2-cycles in an optimal alternating-cycle decomposition of BG( ¯ A, ¯ B). These 2-cycles clearly form a matching in G 1. By the maximality of M, we have |M|≥c 2. Algorithm 2-Cycle Decomposition Input: BG( ¯ A, ¯ B)</note>

			<note place="foot">Proof. All 2-cycles computed at Step 2 cannot share black edges. Since each gray edge is connected to at most four black edges, at most two 2-cycles which do not share black edges can share this gray edge. Equivalently, each gray edge can belong to at most two cycles computed from M. Each 2-cycle has two gray edges, so each vertex in G 2 has degree at most two.</note>

			<note place="foot" n="1"> ) ≤ 2k. Following Lemma 1, we can assign signs to all genes involved in 1-cycles. So each of the remaining gene is connected to two black edges, and each black edge has at most two unsigned genes as its end points, which means that the number of unsigned genes N is bounded by the number of black edges not involved in any 1-cycle, e.g. N ≤ b−c 1 ≤ 2k. Hence, the problem admits a weak kernel of size 2k.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENT</head><p>We thank anonymous reviewers for their valuable comments.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A WEAK KERNEL AND AN FPT ALGORITHM</head><p>Similar to the problem of sorting by unsigned reversals and sorting by unsigned translocations (<ref type="bibr" target="#b14">Jiang et al., 2010</ref>), the UDCJ problem also possesses a (small and indirect) weak kernel. Let k be the minimum number of DCJ operations converting A into B. A weak kernel for UDCJ is a set of genes in A whose signs cannot be fixed after the genes involved in all 1-cycles have been properly signed (following Lemma 1). Before computing the size of the weak kernel, we state the following lemma, which is simple but critical.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Each DCJ operation can generate at most two 1-cycles.</head><p>Proof. Each DCJ operation cuts two black edges and forms at most two new black edges. Each new black edge can form at most one 1-cycle.Proof. The 2k weak kernel is straightforward from Lemma 1 and Lemma 5. For any optimal alternating-cycle decomposition of BG( ¯ A, ¯ B) which contains all possible number of c 1 1-cycles, we have k = b−c 1 −c 2 and c 2 ≤ (b−c 1 )/2, where c 2 is the number of cycles of length at least 2 in the optimal alternating-cycle decomposition of BG( ¯ A, ¯ B). Thus, k ≥ (b−c 1 )/2, equivalently, (b−c</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">13271</biblScope>
			<biblScope unit="issue">5</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>btq674. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="316" to="311" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Sorting by Transpositions</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Discrete Math</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="224" to="240" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">A unifying view of genome rearrangements</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bergeron</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 6th International Workshop on Algorithms in Bioinformatics (WABI&apos;06)</title>
		<meeting>the 6th International Workshop on Algorithms in Bioinformatics (WABI&apos;06)<address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="163" to="173" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">375-Approximation algorithm for sorting by reversals</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Berman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Annual European Symposium on Algorithms (ESA&apos;02)</title>
		<meeting>the 10th Annual European Symposium on Algorithms (ESA&apos;02)<address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2002" />
			<biblScope unit="page" from="200" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Sorting permutations by reversals and Eulerian cycle decompositions</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Caprara</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Discrete Math</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="91" to="110" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">On sorting permutations by double-cut-and-joins</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th International Conf. on Computing and Combinatorics (COCOON&apos;10)</title>
		<meeting>the 16th International Conf. on Computing and Combinatorics (COCOON&apos;10)<address><addrLine>Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="439" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">A 3/2-Approximation algorithm for sorting by reversals</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Christie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 9th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA&apos;98)</title>
		<meeting>the 9th Annual ACM-SIAM Symposium on Discrete Algorithms (SODA&apos;98)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="244" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">A (1.5 + )-Approximation algorithm for unsigned translocation distance</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Cui</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="56" to="66" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Downey</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Fellows</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1999" />
			<publisher>Parameterized Complexity Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">A 1.375-Approximation algorithm for sorting by transpositions</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Elias</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Hartman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="369" to="379" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Parameterized Complexity Theory An O(EVlog V) algorithm for finding a maximal weighted matching in general graphs</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Flum</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Grohe</surname>
			</persName>
		</author>
		<author>
			<persName>
				<surname>Germany</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Galil</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="120" to="130" />
			<date type="published" when="1986" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Transforming men into mice (polynomial algorithm for genomic distance problem)</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hannenhalli</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 36th Annual IEEE Symposium on Foundations of Computer Science (FOCS&apos;95)</title>
		<meeting>the 36th Annual IEEE Symposium on Foundations of Computer Science (FOCS&apos;95)</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1995" />
			<biblScope unit="page" from="581" to="589" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Transforming cabbage into turnip: polynomial algorithm for sorting signed permutations by reversals</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hannenhalli</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Weak kernels</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ECCC Report</title>
		<imprint>
			<biblScope unit="page" from="10" to="15" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<monogr>
		<title level="m" type="main">11-Approximation algorithm for sorting by short block-moves</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Zhu</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>To. appear in Science in China Series F</note>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Efficient sorting of genomic permutations by translocation, inversion and block interchange</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Yancopoulos</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="3340" to="3346" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>