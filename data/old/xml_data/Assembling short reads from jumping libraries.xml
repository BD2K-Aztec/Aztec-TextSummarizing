
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:31+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Assembling short reads from jumping libraries with large insert sizes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Irina</forename>
								<surname>Vasilinetc</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<postCode>194021</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Andrey</forename>
								<forename type="middle">D</forename>
								<surname>Prjibelski</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<postCode>194021</postCode>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Center for Algorithmic Biotechnology</orgName>
								<orgName type="department" key="dep2">Institute of Translational Biomedicine</orgName>
								<orgName type="institution">St.Petersburg State University</orgName>
								<address>
									<postCode>199004</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alexey</forename>
								<surname>Gurevich</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<postCode>194021</postCode>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Center for Algorithmic Biotechnology</orgName>
								<orgName type="department" key="dep2">Institute of Translational Biomedicine</orgName>
								<orgName type="institution">St.Petersburg State University</orgName>
								<address>
									<postCode>199004</postCode>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Anton</forename>
								<surname>Korobeynikov</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<postCode>194021</postCode>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Center for Algorithmic Biotechnology</orgName>
								<orgName type="department" key="dep2">Institute of Translational Biomedicine</orgName>
								<orgName type="institution">St.Petersburg State University</orgName>
								<address>
									<postCode>199004</postCode>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Mathematics and Mechanics</orgName>
								<orgName type="institution">St. Petersburg State University</orgName>
								<address>
									<postCode>198504</postCode>
									<settlement>St. Petersburg</settlement>
									<country key="RU">Russia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Pavel</forename>
								<forename type="middle">A</forename>
								<surname>Pevzner</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department" key="dep1">Center for Algorithmic Biotechnology</orgName>
								<orgName type="department" key="dep2">Institute of Translational Biomedicine</orgName>
								<orgName type="institution">St.Petersburg State University</orgName>
								<address>
									<postCode>199004</postCode>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92093-0404</postCode>
									<settlement>San Diego</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Assembling short reads from jumping libraries with large insert sizes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btv337</idno>
					<note type="submission">Received on February 12, 2015; revised on May 3, 2015; accepted on May 26, 2015</note>
					<note>Sequence analysis *To whom correspondence should be addressed. Associate Editor: Inanc Birol Contact: ap@bioinf.spbau.ru Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Advances in Next-Generation Sequencing technologies and sample preparation recently enabled generation of high-quality jumping libraries that have a potential to significantly improve short read assemblies. However, assembly algorithms have to catch up with experimental innovations to benefit from them and to produce high-quality assemblies. Results: We present a new algorithm that extends recently described EXSPANDER universal repeat resolution approach to enable its applications to several challenging data types, including jumping libraries generated by the recently developed Illumina Nextera Mate Pair protocol. We demonstrate that, with these improvements, bacterial genomes often can be assembled in a few contigs using only a single Nextera Mate Pair library of short reads. Availability and implementation: Described algorithms are implemented in Cþþ as a part of SPAdes genome assembler, which is freely available at bioinf.spbau.ru/en/spades.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In an article titled 'De novo fragment assembly with short matepaired reads: Does the read length matter?',<ref type="bibr" target="#b5">Chaisson et al. (2009)</ref>argued that availability of paired reads with long and accurate insert sizes (rather than the increase in the read length) is the most important factor for improving the quality of short read assemblies. However, while paired reads with long insert sizes have been extensively used in many assembly projects, robust generation of readpairs with accurate insert sizes proved to be difficult and have only been achieved recently. The recently emerged sample preparation technologies open new opportunities for genome assembly from short reads. For example, Illumina Nextera Mate Pair protocol generates long inserts (3 kb and longer) that feature rather tight insert size distribution and small rate of non-circularized fragments that result in read-pairs with abnormal distances. As discussed in<ref type="bibr" target="#b5">Chaisson et al. (2009)</ref>, such read-pair libraries may enable assemblies approaching the quality of assemblies from long reads of length equal to the insert size. Moreover, they can potentially substitute the existing assembly approaches based on a combination of short paired-end libraries (with insert size less than 1 kb) and long jumping libraries (with insert sizes typically longer than 1 kb) by a pipeline based on a single Nextera Mate Pair library. However, even though the popular assembly algorithms perform well with the previously proposed approaches to sample preparation, they have not kept up with recent experimental innovations. To catch up, bioinfomaticians either need to design novel tools for every technology improvement or to develop a universal assembler that can be easily modified to support new data types. For example, Ray (<ref type="bibr" target="#b3">Boisvert et al., 2010</ref>) and SPAdes (<ref type="bibr" target="#b0">Bankevich et al., 2012</ref><ref type="bibr" target="#b17">Prjibelski et al., 2014</ref>) is based on the path extension framework that was proposed by the authors of the Ray assembler (<ref type="bibr" target="#b3">Boisvert et al., 2010</ref>) and later implemented in the Telescoper (<ref type="bibr" target="#b4">Bresler et al., 2012</ref>) and PERGA (<ref type="bibr" target="#b22">Zhu et al., 2014</ref>) assemblers. Given a path P in the assembly graph (<ref type="bibr" target="#b0">Bankevich et al., 2012;</ref><ref type="bibr" target="#b17">Prjibelski et al., 2014</ref>), EXSPANDER iteratively attempts to grow it by choosing one of its extension edges (all edges starting at the terminal vertex of the path P). The assembly graph is defined as simplified de Bruijn graph (<ref type="bibr" target="#b15">Pevzner et al., 2001</ref>) of k-mers in reads after removal of bulges, tips and chimeric edges. To extend a path P, EXSPANDER computes the scoring function Score P ðeÞ for each extension edge e using read-pairs with one read mapping to P and another read mapping to e (further referred to as (P, e)-connecting read-pairs). Afterward, EXSPANDER decides whether to select the top-scoring extension edge or to stop growing P. It iteratively repeats the path extension procedure starting with single-edge paths until every edge in the assembly graph is covered by at least one path and no path can be extended further. To generate equivalent contigs on both strands, EXSPANDER is implemented as a bidirectional approach that can extend a path in both directions. While the scoring function Score P ðeÞ described in Prjibelski et al.</p><p>(2014) works well with short libraries, it appears to be rather inefficient when using jumping libraries. The key limitation of the previously defined scoring function is that it analyses only (P, e)connecting read-pairs (where e is an extension edge of path P) and ignores read-pairs that connect path P with other edges. When an edge e is short and the variations in the insert sizes are large, there is a danger that no (P, e)-connecting read-pairs exist and thus ScoreðP; eÞ ¼ 0 even if e is the correct extension edge (<ref type="figure" target="#fig_0">Fig. 1</ref>). Thus, the decision rule may stop extending path P or even select an incorrect extension edge. Additionally, the approach described in<ref type="bibr" target="#b17">Prjibelski et al. (2014)</ref>is inapplicable for scaffolding procedure, since it is unable to jump over coverage gaps. In this article, we extend the EXSPANDER approach to scaffolding. This extension is important since scaffolding with jumping libraries may dramatically improve the assembly quality. We describe several algorithms that address these bottlenecks based on the following idea. Consider a set of extension paths E [rather than extension edges as in<ref type="bibr" target="#b17">Prjibelski et al. (2014)</ref>] that contain all sufficiently long paths (longer than the insert size) starting from the extension edges of the path P. Once the set E is constructed, we choose the best-scoring path E in E and extend path P by the first edge of E. Our analysis has shown that such conservative extension (by the first edge of the best-scoring extension path rather than by the entire path) provides more accurate assemblies. To perform scaffolding procedure, we allow extension paths to 'jump' over coverage gaps in the assembly graph. This intuitive approach, while appealing, is often impractical since the assembly graph is usually tangled, resulting in a prohibitively large number of extension paths. To reduce the running time, we have implemented the new algorithm based on the observation that, instead of the exhaustive search through the set of all extension paths, one can significantly prune this set using single reads and paired-end libraries (if available). We demonstrate that the new algorithm enables assemblies of nearly complete genomes from a single Nextera Mate Pair library. We also show that SPAdes, coupled with the improved EXSPANDER algorithm, outperforms other popular assemblers, such as ABySS (<ref type="bibr" target="#b18">Simpson et al., 2009</ref>), IDBA-UD (<ref type="bibr" target="#b14">Peng et al., 2012</ref>), Ray (<ref type="bibr" target="#b3">Boisvert et al., 2010</ref>), SOAPdenovo (<ref type="bibr" target="#b13">Li et al., 2010</ref>) and Velvet (<ref type="bibr" target="#b21">Zerbino and Birney, 2008</ref>) on various types of datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The exSPAnder framework</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Rectangles</head><p>EXSPANDER utilizes the concept of the rectangle graph introduced by<ref type="bibr" target="#b0">Bankevich et al. (2012)</ref>and further developed in (<ref type="bibr" target="#b20">Vyahhi et al., 2012</ref>). Let e and e 0 be edges in the assembly graph (see (<ref type="bibr" target="#b0">Bankevich et al., 2012</ref>) for the construction of the assembly graph) separated by a known distance D and ðr; r 0 Þ be a read-pair, such that read r maps to e at position x 0 and read r 0 maps to e 0 at position y 0 (<ref type="figure" target="#fig_1">Fig. 2a</ref>). We note that while D is not known a priori, EXSPANDER only considers edges that are connected by a previously constructed path, which unambiguously defines distance D.<ref type="figure" target="#fig_1">Figure 2b</ref>shows the read-pair ðr; r 0 Þ represented as a point (x 0 , y 0 ) within the rectangle formed by the edges e and e 0. We further refer to this rectangle simply as ðe; e 0 Þ. Because of variations in the insert sizes, real read-pairs connecting edges e and e 0 typically correspond to the points that are scattered in the confidence strip—a strip between the 45 lines y ¼ x À d min and y ¼ x À d max within the rectangle ðe; e 0 Þ (<ref type="figure" target="#fig_1">Fig. 2c</ref>), where</p><formula>d min ¼ D À I min þ ReadLength; d max ¼ D À I max þ ReadLength:</formula><p>Here, ½I min ; I max  is the confidence interval of the insert size distribution defined as the smallest insert size interval that contains at least 80% of read-pairs. Since reads may have variable lengths (e.g. after quality trimming or error correction), we set ReadLength as the maximal read length across all reads in the current library.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">The decision rule</head><p>The decision rule relies on the scoring function that will be described in the next section. To extend a path P, we score all extension edges e 1 ;. .. ; e n and select e i as a correct extension if the following conditions are met: 1. Score P ðe i Þ &gt; C Á Score P ðe j Þ for all j 6 ¼ i 2. Score P ðe i Þ &gt; H Here, C and H are the EXSPANDER parameters described in (<ref type="bibr" target="#b17">Prjibelski et al., 2014</ref>). If no extension edge meets these conditions, the algorithm stops growing path P.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Assembling jumping libraries</head><p>In the case of multiple read-pair libraries, we process them in the order of increasing insert sizes until a certain library provides an extension edge satisfying the decision rule. We stop growing path P if no library provides an extension edge satisfying this rule. Processing libraries in a step-by-step fashion (rather than incorporating all libraries at once) has proven to result in more accurate and continuous assemblies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Scoring function</head><p>Given a path P ¼ ðp 1 ; p 2 ;. .. ; p n Þ and its extension path E ¼ ðe 1 ; e 2 ; .. . ; e m Þ, the composite rectangle for paths P and E is formed by n Á m simple rectangles (p i , e j ) (<ref type="figure" target="#fig_1">Fig. 2d</ref>). The distance D ij between a pair of edges p i and e j according to the paths P and E is equal to</p><formula>D ij ¼ X n k¼i Lengthðp k Þ þ X jÀ1 l¼1 Lengthðe l Þ:</formula><p>We define the following variables<ref type="bibr">[</ref>Thus, EXSPANDER ignores rectangles with a density lower than a pre-defined threshold W. While this approach worked well for short libraries, our benchmarking revealed that it deteriorates for long jumping libraries that typically have a higher rate of read-pairs with abnormal insert sizes (referred to as chimeric read-pairs). We thus define a new support function that evaluates whether a simple rectangle (p i , e j ) within the composite rectangle (P, E) can be considered as trusted and used for calculating the scoring function: Support Dij ðp i ; e j Þ ¼ 1; Observed Dij ðp i ; e j Þ &gt; g 0; otherwise (</p><p>where g is a user-controlled parameter with very conservative default value g ¼ 30. While it is not clear how to select optimal g, our analysis of the distribution of the number of chimeric points within all rectangles across a wide range of bacterial genomes revealed that hardly any rectangles contain more than 30 chimeric points. We note that by setting the parameter g, one essentially ignores the contribution from small rectangles containing less than g points. While it may appear that we unfairly ignore small rectangles, our benchmarking revealed that this approach actually improves the assembly quality. Moreover, the users can change the parameter g in the case of assembly projects with unusually low or high coverage. When the extension path contains a single edge e, EXSPANDER uses the following path-edge scoring function:</p><formula>Score P ðeÞ ¼ X n i¼1 Support Di ðp i ; eÞ Á Expected Di ðp i ; eÞ X n i¼1 Expected Di ðp i ; eÞ :</formula><p>In this article, we generalize this path-edge scoring function to a path–path scoring function as follows:</p><formula>Score P ðEÞ ¼ X n i¼1 X m j¼1 Support Dij ðp i ; e j Þ Á Expected Dij ðp i ; e j Þ X n i¼1 X m j¼1 Expected Dij ðp i ; e j Þ :</formula><p>Given a confidence interval ½I min ;I max  of the insert size distribution, we call a path long if its length exceeds I max and short otherwise. The algorithm that we describe below limits attention to the long extension paths ðe 1 ; e 2 ;. .. ; e m Þ whose prefix ðe 1 ; e 2 ;. .. ; e mÀ1 Þ is short. Given a path P, for each extension edge e i of P, we construct a set of extension paths E. A top-scored path E in E is called a representative path for edge e (<ref type="figure" target="#fig_3">Fig. 3a</ref>). The score of the extension edge e is now defined as the score of its representative path, i.e. Score P ðeÞ ¼ Score P ðEÞ. The new approach to define Score P ðeÞ can be applied to the libraries with both short and long insert sizes. While the resulting improvements are significant for long insert sizes, they appear to be minor for the libraries with small insert sizes. Thus, in the default EXSPANDER mode, the new scoring function is used only for the jumping libraries.</p><formula>(a) (b) ( c)</formula><p>(d)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Constructing extension paths</head><p>In the case of long libraries, the Depth-First Search (DFS) algorithm for exploring all paths and selecting representative paths becomes rather slow, e.g. the number of extension paths can reach millions even for a bacterial genome. To decrease the number of extension paths, we developed the ExtensionSearch algorithm that uses a set of pre-constructed paths S that are generated by the previous EXSPANDER algorithm (<ref type="bibr" target="#b17">Prjibelski et al., 2014</ref>) using single reads and short paired-end libraries if they are available. We use the notation Suffix(E, l)<ref type="bibr">[</ref>As the result, we obtain a set of extension paths that 'comply' with the set of pre-constructed paths S with length at least I max (<ref type="figure" target="#fig_3">Fig. 3b</ref>–d). ExtensionSearch greatly reduces the number of the extension paths when compared with the DFS algorithm. However, in the tangled regions of the assembly graph with many bulges (corresponding to variations in repeats) and loops (corresponding to tandem duplications), the number of paths is still high (<ref type="figure" target="#fig_4">Fig. 4</ref>). For example, each bulge potentially doubles the number of extension paths explored by the EXSPANDER algorithm (e.g. ExtensionSearch can select either of edges e 1 and e 2 in<ref type="figure" target="#fig_4">Fig. 4a</ref>). Each loop potentially multiples the number of extension paths by the (unknown) multiplicity of the loop (i.e. the number of times the loop traverses the edge e 2 in<ref type="figure" target="#fig_4">Fig. 4b</ref>). In the ExtensionSearch, we focus only on simple bulges (<ref type="figure" target="#fig_4">Fig. 4a</ref>) and simple loops (<ref type="figure" target="#fig_4">Fig. 4b</ref>) since they represent the majority of all cases that may trigger the increase in the running time of the algorithm. To limit the explosion of the extension paths, we add the following constrains to the ExtensionSearch algorithm: @BULLET For each bulge formed by two edges, only the top-scoring edge is used as an extension edge. @BULLET Each simple loop is traversed as a fixed number of times equal to the estimated multiplicity of the loop. The loop multiplicity is estimated as the closest integer to C loop =C local , where C loop is the average read coverage of the loop edges, and C local is the read coverage in the vicinity of the loop, i.e. the average read coverage of the last ReadLength nucleotides of edge e and first ReadLength nucleotides of edge e 0 (<ref type="figure" target="#fig_4">Fig. 4b</ref>).</p><p>Our benchmarking has demonstrated that the described modifications reduce the running time by an order of magnitude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Scaffolding</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1">Jumping over the coverage gaps</head><p>Existing genome assemblers are often complemented by scaffolding tools such as Bambus (<ref type="bibr" target="#b16">Pop et al., 2004</ref>), Opera (<ref type="bibr" target="#b10">Gao et al., 2011</ref>), SCARPA (<ref type="bibr" target="#b9">Donmez and Brudno, 2013</ref>), SOPRA (<ref type="bibr" target="#b8">Dayarian et al., 2010</ref>) and SSPACE (<ref type="bibr" target="#b2">Boetzer et al., 2011</ref>) to improve the contiguity of the resulting assemblies. However, most of these scaffolding tools work with contigs rather than the assembly graphs and none of them uses the rectangle framework that EXSPANDER utilizes. We thus added a rectangle-based scaffolder to EXSPANDER and evaluated its performance. Jumping from an out-tip to an in-tip. A coverage gap typically creates a pair of tips in the assembly graph<ref type="bibr">[see Bankevich et al. (2012) for details]</ref>formed by an out-tip (an edge that ends in a vertex with out-degree 0) and an in-tip (an edge that starts in a vertex with in-degree 0). We further refer to these tips as paired tips. Since coverage gaps are usually short, read-pairs from the jumping libraries often span them. Below we describe how ExtensionSearch finds pairs of tips and uses them for scaffolding. Let E be an extension path for a path P, such that E ends with an out-tip e and LengthðEÞ &lt; I max (<ref type="figure">Fig. 5a</ref>). To further extend path E, we search for an in-tip paired with e by considering a set of P-supported edges, i.e. all edges e 0 that have ðP; e 0 Þ-connecting. At each step, the ExtensionSearch algorithm grows an extension path E (that is shorter than I max ) using only E-consistent extension edges (with respect to S)Assembling jumping librariesread-pairs. Since the set of P-supported edges typically contains many false short edges (due to high rate of chimeric read-pairs in the jumping libraries), we filter out all P-supported edges shorter than a certain threshold (default value is 500 bp).<ref type="figure">Figure 5b</ref>presents a simple example when there is only one Psupported edge e 0 and this edge is an in-tip. We then consider e and e 0 as paired tips and extend the path E by edge e 0 with a gap (<ref type="figure">Fig. 5c</ref>). Since the size of a gap is difficult to estimate using a jumping library with large insert size variation, we assign a fixed length to each gap (100 bp by default). Once we extended the path E with an edge, we continue growing E using ExtensionSearch until its length exceeds I max. Jumping from an out-tip to an internal edge. A more difficult (and more common) case is illustrated in<ref type="figure">Figure 5d</ref>, where there exists only one P-supported edge e 0 and this edge is not an in-tip. Such situations arise when the in-tip paired with e is either not P-supported or is shorter than 500 bp (and thus ignored). To grow the path E in such cases, we consider all in-tips in the assembly graph and extend them further using ExtensionSearch limiting the path length to I max À LengthðEÞ. Afterward, we select only paths that contain edge e 0 and use them as potential extensions for E (<ref type="figure">Fig. 5e</ref>). When assembling real datasets, we often encounter several P-supported edges longer than 500 bp. In this case, we apply the strategy described above, i.e. extend the paths starting from every in-tip and choose paths containing at least one P-supported edge. If some of the extension paths remain shorter than I max , we continue growing them with the ExtensionSearch algorithm. However, growing paths from every in-tip can be extremely time-consuming, especially for single-cell datasets that often contain thousands of coverage gaps. To address this issue, we implement the described approach the other way around: instead of starting a path from every in-tip, we start growing paths from P-supported edges in the reverse direction and select only those that reach an in-tip. Since the number of long P-supported edges is typically much smaller than the number of all in-tips in the assembly graph in the case of singlecell assemblies, this implementation greatly reduces the running time of EXSPANDER.</p><formula>(a) (b) (c) (d)</formula><formula>(a) ( b)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2">Jumping over complex subgraphs</head><p>Even after applying the described heuristics for run-time reduction, there are cases when the number of extension paths remains huge. Such cases are often associated with complex subgraphs of the assembly graph (typically formed by short repeats with high multiplicities). To keep the running time under control, EXSPANDER stops growing a path if the number of its extension paths exceeds a threshold. The threshold is automatically calculated based on the number of edges in the assembly graph (e.g. the threshold value is set to 50 for graphs with &gt; 10 000 edges). A better approach is to use jumping libraries and to 'jump over' complex subgraphs in the assembly graph (instead of generating all extension paths traversing these complex subgraphs). If the 'size' of a complex subgraph is smaller than the insert size, a path P may start on 'one side' of this subgraph and be connected with edges on the 'other side' of this subgraph, thus allowing us to jump over the entire subgraph and to continue growing P. The question is how to identify such complex subgraphs and jump over them. To jump over complex subgraphs, we first identify a path P with unusually large number of extension paths. Afterward, we find all P-supported edges and order them using the rule: an edge e 0 follows an edge e if e 0 can be reached by ExtensionSearch within a certain distance starting from e. If all P-supported edges can be ordered into a single list, we extend path P by the first edge in this list (with a gap).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head><p>To evaluate how availability of Nextera Mate Pair libraries affects the quality of assembly, we assembled several bacterial genomes using multicell datasets provided by Illumina (Nextera Mate Pair libraries only). In this article, we describe benchmarking (using seven different assemblers and three scaffolders) on Meiothermus ruber str. 21T (<ref type="bibr" target="#b19">Tindall et al., 2010</ref>) Nextera Mate Pair library and additionally, on Escherichia coli st. K12 subst. MG1655 (<ref type="bibr" target="#b1">Blattner et al., 1997</ref>) single-cell dataset that contains both a short paired-end library and a long jumping library. Results for other Nextera Mate Pair libraries are presented in the Supplementary Material. Since the assemblers we used for comparison were not designed for assembling Nextera Mate Pair libraries, we have conducted<ref type="figure">Fig. 5</ref>. Jumping over coverage gaps in the assembly graph from an out-tip to an in-tip: (a) an extension path E (marked red) ending with an out-tip e; (b) the only P-supported edge e 0 is an in-tip (marked green); (c) the path E is extended by an edge e 0 with a gap (red line). Jumping over coverage gaps in the assembly graph from an out-tip to an internal edge: (d) the only P-supported edge e 0 is not an in-tip (marked green) and (e) paths E 1 and E 2 that start with in-tips and contain P-supported edge e 0 , both paths are considered as possible extensions for E (shown by red lines) additional optimization and selected the optimal k-mer sizes (with respect to N50) to ensure fair benchmarking with these assemblers. We ran ABySS 1.3.6 (<ref type="bibr" target="#b18">Simpson et al., 2009</ref>), Ray 2.0.0 (<ref type="bibr" target="#b3">Boisvert et al., 2010</ref>), SOAPdenovo 2.0.4 (<ref type="bibr" target="#b13">Li et al., 2010</ref>), Velvet 1.2.10 (<ref type="bibr" target="#b21">Zerbino and Birney, 2008</ref>) and Velvet-SC (<ref type="bibr" target="#b7">Chitsaz et al., 2011</ref>) (based on Velvet 0.7.62, released on March 11, 2011) with the kmer sizes 59, 57, 71, 99 and 105, respectively. Iterative de Bruijn graph assemblers IDBA-UD 1.1.1 (<ref type="bibr" target="#b14">Peng et al., 2012</ref>), SPAdes 3.0.0 (with the previous version of EXSPANDER (<ref type="bibr" target="#b17">Prjibelski et al., 2014)]</ref>and SPAdes 3.5.0 (that implements the new algorithm described in this article) were run with the default parameters. In addition to scaffolds, we also provide information about contigs generated by SPAdes 3.5 (referred to as SPAdes 3.5 ctg). We have also included results for such popular scaffolders as Opera 2.0 (<ref type="bibr" target="#b10">Gao et al., 2011</ref>), SCARPA 0.241 (<ref type="bibr" target="#b9">Donmez and Brudno, 2013</ref>) and SSPACE 3.0 (<ref type="bibr" target="#b2">Boetzer et al., 2011</ref>). To perform a fair comparison, we ran all scaffolders on the contigs that were assembled by SPAdes 3.5.0 using all data as single-end reads (discarding read-pair information). The resulting assemblies were evaluated with QUAST 2.3 (<ref type="bibr" target="#b12">Gurevich et al., 2013</ref>) using standard metrics: NGA50 (NG50 corrected for assembly errors), the total number of scaffolds in the assembly, the size of the largest scaffold, the number of misassemblies, the fraction of genome covered and the number of uncalled bases (N) in the assembly.<ref type="figure" target="#tab_1">Table 1</ref>benchmarks various assemblers on M.ruber Nextera Mate Pair library (mean insert size 3.6 kb). Some of the assemblers used in the comparison produce rather inaccurate assemblies (e.g. 95 misassemblies for Ray and 244 misassemblies for SOAPdenovo). Also, some assemblers generate very large number of unspecified symbols N (ABySS, Ray, SOAPdenovo and Velvet). Interestingly, most assemblers showed rather unstable behavior with Nextera Mate Pair libraries with exception of IDBA-UD and SPAdes (originally developed as single-cell assemblers). SPAdes þ EXSPANDER assembles an almost complete M.ruber genome with less than 0.03% of unspecified nucleotides and the largest scaffold capturing more than 93% of the genome. SPAdes generates similar high-quality assemblies on all Nextera Mate Pair libraries (see Supplementary Material) and often results in assemblies of very few contigs with the quality that approaches the quality of the assemblies from long Pacific Biosciences reads (<ref type="bibr" target="#b6">Chin et al., 2013</ref>). Thus, Nextera Mate Pair libraries provide a valuable low-cost trade-off when compared with the assemblies that use Pacific Biosciences reads. In Table 2, we also present a comparison between selected tools on E.coli single-cell dataset with paired-end and jumping libraries. In addition, we ran ALLPATHS-LG (<ref type="bibr" target="#b11">Gnerre et al., 2011</ref>) (build 47561, released on September 15, 2013) with the default parameters using both libraries together. As<ref type="figure">Table 2</ref></p><formula>(a) (b) (c) (d) (e)</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. An example of the assembly graph with path P ¼ ðp1; p2Þ (blue) and its correct short extension edge e (red). In this case, there may be no (P, e)-connecting read-pairs, but there may be ðP ; f 1 Þ-connecting read-pairs since the correct genomic path includes the path (p 1 , p 2 , e, f 1 ), which is shown in green above the graph</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. (a) A read-pair ðr; r 0 Þ mapping to edges e and e 0 in the assembly graph at positions x 0 and y 0 , respectively. (b) Read-pair ðr; r 0 Þ is represented as a point (x 0 , y 0 ) in the rectangle ðe; e 0 Þ. (c) Since the insert size varies, most readpairs correspond to the points scattered within the confidence strip in the rectangle ðe; e 0 Þ. (d) An example of a composite rectangle formed by paths P ¼ ðp1; p2; p3Þ and E ¼ ðe1; e2; e3Þ, which consists of nine simple rectangles. Note that the confidence strip crosses only five out of nine simple rectangles. The points outside the confidence strip appear in eight out of nine simple rectangles and represent read-pairs with abnormal insert sizes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>and Prefix(E, l)] to refer to a path formed by the last (first) l edges of a path E. For a path E and a set of pre-constructed paths S, we say that an extension edge e of path E is E-consistent (with respect to S) if S contains a path E 0 , such that SuffixðE þ e; lÞ ¼ PrefixðE 0 ; lÞ for some l &gt; 0. Instead of extending a path E by all its extension edges (like in the DFS algorithm), ExtensionSearch uses the following heuristics to construct extension paths: @BULLET Extend a path E only by E-consistent extension edges; @BULLET Extend only paths that are shorter than I max .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. (a) An example of path P in the assembly graph (shown in blue) and its extension edges e 1 and e 2. The representative path for e 1 is shown in red above the graph, whereas another extension path for e 1 (with lower score) is shown in orange. (b–d) A step-by-step example of the work of ExtensionSearch algorithm for constructing extension paths (marked orange) for edge e 1 using the pre-constructed paths from the set S (shown as five green paths in the top figure). At each step, the ExtensionSearch algorithm grows an extension path E (that is shorter than I max ) using only E-consistent extension edges (with respect to S)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.4.</head><figDesc>Fig. 4. An example of a simple bulge (a) and simple loop (b) consisting of edges e 1 and e 2. A simple bulge (loop) is formed by two parallel (anti-parallel) edges between two vertices. Regions used for calculating the local coverage in the vicinity of the loop are marked with bold segments</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Table1.</head><figDesc>indicates SPAdes (both versions 3.0 and 3.5) and IDBA-UD outperform other tools on this dataset. However, when using both libraries together, SPAdes generates more accurate and continuous assemblies comparing to IDBA-UD and at the same time captures the largest genome fraction.Comparison of the assemblies for the M.ruber str. 21T (Tindall et al., 2010) (genome size 3.1 Mb) Nextera Mate Pair library</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>) V C The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 3262 Bioinformatics, 31(20), 2015, 3262–3268 doi: 10.1093/bioinformatics/btv337 Advance Access Publication Date: 3 June 2015 Original Paper [with the recently implemented EXSPANDER (Prjibelski et al.</figDesc><table>, 2014) 
algorithm] use similar approach to repeat resolution that can be 
adapted for new types of sequencing data. However, the recently 
proposed Nextera Mate Pair libraries present new computational 
challenges that go beyond the algorithmic framework of both Ray 
and SPAdes. In this work, we describe several algorithmic advances 
to EXSPANDER that allows one to efficiently utilize jumping libraries 
and to perform assembly using only high-quality Nextera Mate Pair 
libraries. 
The EXSPANDER algorithm (</table></figure>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>We would like to thank Ilya Chorny from Illumina for providing various datasets for Nextera Mate Pair libraries, which are now available at Illumina BaseSpace public repository (https://basespace.illumina.com).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This study was supported by the Russian Science Foundation. Conflict of Interest: none declared.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Assembling jumping libraries</head></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">SPAdes: a new genome assembly algorithm and its applications to single-cell sequencing</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bankevich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="455" to="477" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">The complete genome sequence of Escherichia coli K-12</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<forename type="middle">R</forename>
				<surname>Blattner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">277</biblScope>
			<biblScope unit="page" from="1453" to="1462" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Scaffolding pre-assembled contigs using SSPACE</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Boetzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="578" to="579" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Ray: simultaneous assembly of reads from a mix of high-throughput sequencing technologies</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Boisvert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1519" to="1533" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Telescoper: de novo assembly of highly repetitive regions</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Bresler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="311" to="317" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">De novo fragment assembly with short mate-paired reads: does the read length matter?</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page">336</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Nonhybrid, finished microbial genome assemblies from long-read SMRT sequencing data</title>
		<author>
			<persName>
				<forename type="first">C.-S</forename>
				<surname>Chin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="563" to="569" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of single-cell bacterial genomes from short-read data sets</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Chitsaz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="915" to="921" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">SOPRA: Scaffolding algorithm for paired reads via statistical optimization</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Dayarian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">345</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">SCARPA: scaffolding reads with practical algorithms</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Donmez</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Brudno</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="428" to="434" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Opera: reconstructing optimal genomic scaffolds with high-throughput paired-end sequences</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1681" to="1691" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">High-quality draft assemblies of mammalian genomes from massively parallel sequence data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gnerre</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci. USA</title>
		<meeting>. Natl. Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page">1513</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">QUAST: quality assessment tool for genome assemblies</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Gurevich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1072" to="1075" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">IDBA-UD: A de novo assembler for single-cell and metagenomic sequencing data with highly uneven depth</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1" to="8" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">An Eulerian path approach to DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci. USA</title>
		<meeting>. Natl. Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9748" to="9753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Hierarchical scaffolding with Bambus</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="149" to="159" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">ExSPAnder: a universal repeat resolver for DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">D</forename>
				<surname>Prjibelski</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="293" to="301" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Complete genome sequence of Meiothermus ruber type strain (21T)</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">J</forename>
				<surname>Tindall</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Stand. Genomic Sci</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="26" to="36" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">From de Bruijn graphs to rectangle graphs for genome assembly</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Vyahhi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics Lecture Notes in Computer Science</title>
		<editor>Raphael,B. and Tang,J.</editor>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">2012</biblScope>
			<biblScope unit="issue">7534</biblScope>
			<biblScope unit="page" from="200" to="212" />
			<date type="published" when="2012" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Velvet: Algorithms for de novo short read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">PERGA: a paired-end read guided de novo assembler for extending contigs using SVM and look ahead approach</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Zhu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">114253</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>