
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:51+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient algorithms for the reconciliation problem with gene duplication, horizontal transfer and loss</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Mukul</forename>
								<forename type="middle">S</forename>
								<surname>Bansal</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Computer Science and Artificial Intelligence Laboratory</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Eric</forename>
								<forename type="middle">J</forename>
								<surname>Alm</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Biological Engineering</orgName>
								<orgName type="institution">Massachusetts Institute of Technology</orgName>
								<address>
									<postCode>02139</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Manolis</forename>
								<surname>Kellis</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Computer Science and Artificial Intelligence Laboratory</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="institution">Broad Institute of MIT and Harvard</orgName>
								<address>
									<postCode>02142</postCode>
									<settlement>Cambridge</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient algorithms for the reconciliation problem with gene duplication, horizontal transfer and loss</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="283" to="291"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts225</idno>
					<note>Copyedited by: TRJ MANUSCRIPT CATEGORY: [11:45 31/5/2012 Bioinformatics-bts225.tex] Page: i283 i283–i291 BIOINFORMATICS Contact: Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Gene family evolution is driven by evolutionary events such as speciation, gene duplication, horizontal gene transfer and gene loss, and inferring these events in the evolutionary history of a given gene family is a fundamental problem in comparative and evolutionary genomics with numerous important applications. Solving this problem requires the use of a reconciliation framework, where the input consists of a gene family phylogeny and the corresponding species phylogeny, and the goal is to reconcile the two by postulating speciation, gene duplication, horizontal gene transfer and gene loss events. This reconciliation problem is referred to as duplication-transfer-loss (DTL) reconciliation and has been extensively studied in the literature. Yet, even the fastest existing algorithms for DTL reconciliation are too slow for reconciling large gene families and for use in more sophisticated applications such as gene tree or species tree reconstruction. Results: We present two new algorithms for the DTL reconciliation problem that are dramatically faster than existing algorithms, both asymptotically and in practice. We also extend the standard DTL reconciliation model by considering distance-dependent transfer costs, which allow for more accurate reconciliation and give an efficient algorithm for DTL reconciliation under this extended model. We implemented our new algorithms and demonstrated up to 100 000-fold speed-up over existing methods, using both simulated and biological datasets. This dramatic improvement makes it possible to use DTL reconciliation for performing rigorous evolutionary analyses of large gene families and enables its use in advanced reconciliation-based gene and species tree reconstruction methods. Availability: Our programs can be freely downloaded from</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Gene families evolve through complex evolutionary processes such as speciation, gene duplication, horizontal gene transfer and gene loss. Accurate inference of these events is crucial not only to understanding gene and genome evolution but also for reliably inferring orthologs, paralogs, and xenologs (<ref type="bibr" target="#b26">Koonin, 2005;</ref><ref type="bibr" target="#b31">Mi et al., 2010;</ref><ref type="bibr" target="#b41">Sennblad and Lagergren, 2009;</ref><ref type="bibr" target="#b42">Storm and Sonnhammer, 2002;</ref><ref type="bibr" target="#b45">van der Heijden et al., 2007;</ref><ref type="bibr" target="#b46">Vilella et al., 2009;</ref><ref type="bibr" target="#b48">Wapinski *</ref>To whom correspondence should be addressed<ref type="bibr">. et al., 2007</ref>); reconstructing ancestral gene content and dating gene birth (<ref type="bibr" target="#b11">Chen et al., 2000;</ref><ref type="bibr" target="#b15">David and Alm, 2011;</ref><ref type="bibr" target="#b28">Ma et al., 2008</ref>); accurate gene tree reconstruction (<ref type="bibr" target="#b37">Rasmussen and Kellis, 2011;</ref><ref type="bibr" target="#b46">Vilella et al., 2009</ref>); and for whole genome species tree reconstruction (<ref type="bibr" target="#b2">Bansal et al., 2007;</ref><ref type="bibr" target="#b7">Burleigh et al., 2011</ref>). Indeed, the problem of inferring gene family evolution has been extensively studied. In the typical formulation of this problem, the goal is to reconcile an input gene tree (gene family phylogeny) to the corresponding rooted species tree by postulating speciation, duplication, transfer and loss events. Much of the previous work in gene tree–species tree reconciliation has focused on either duplication loss (DL) (<ref type="bibr" target="#b5">Bonizzoni et al., 2005;</ref><ref type="bibr" target="#b10">Chauve et al., 2008;</ref><ref type="bibr" target="#b17">Durand et al., 2006;</ref><ref type="bibr" target="#b18">Eulenstein and Vingron, 1998;</ref><ref type="bibr" target="#b19">Goodman et al., 1979;</ref><ref type="bibr" target="#b21">Górecki and Tiuryn, 2006;</ref><ref type="bibr" target="#b32">Mirkin et al., 1995;</ref><ref type="bibr" target="#b36">Page, 1994</ref>) or transfer loss (TL) (<ref type="bibr" target="#b4">Boc et al., 2010;</ref><ref type="bibr" target="#b22">Hallett and Lagergren, 2001;</ref><ref type="bibr" target="#b23">Hill et al., 2010;</ref><ref type="bibr" target="#b24">Huelsenbeck et al., 2000;</ref><ref type="bibr" target="#b25">Jin et al., 2009;</ref><ref type="bibr" target="#b33">Nakhleh et al., 2004</ref><ref type="bibr" target="#b34">Nakhleh et al., , 2005</ref><ref type="bibr" target="#b38">Ronquist, 1995</ref>), but not on duplication, transfer and loss together. However, duplication and transfer events frequently occur together, particularly in prokaryotes, and the analysis of such families requires reconciliation methods that can simultaneously consider duplication, transfer and loss events. This problem of gene tree–species tree reconciliation by duplication, transfer and loss simultaneously is referred to as the duplication TL (DTL) reconciliation problem. Previous work. The DTL reconciliation problem has a long history and is well studied in the literature. This is partly due to its close association with the host–parasite cophylogeny problem (<ref type="bibr" target="#b9">Charleston and Perkins, 2006</ref>) which seeks to understand the evolution of parasites (analogous to genes) within hosts (analogous to species). Almost all known formulations of the DTL reconciliation problem are based on a parsimony framework (<ref type="bibr" target="#b8">Charleston, 1998;</ref><ref type="bibr" target="#b12">Conow et al., 2010;</ref><ref type="bibr" target="#b15">David and Alm, 2011;</ref><ref type="bibr" target="#b16">Doyon et al., 2010;</ref><ref type="bibr" target="#b20">Gorbunov and Liubetskii, 2009;</ref><ref type="bibr" target="#b27">Libeskind-Hadas and Charleston, 2009;</ref><ref type="bibr" target="#b29">Merkle and Middendorf, 2005;</ref><ref type="bibr" target="#b30">Merkle et al., 2010;</ref><ref type="bibr" target="#b35">Ovadia et al., 2011;</ref><ref type="bibr" target="#b39">Ronquist, 2003;</ref><ref type="bibr" target="#b44">Tofigh et al., 2011</ref>) (but see also<ref type="bibr" target="#b43">Tofigh (2009)</ref>for an example of a probabilistic formulation, as well as<ref type="bibr" target="#b14">Csürös and Miklós (2006)</ref>for a probabilistic framework based on gene content). Under this framework, each duplication, transfer and loss event is assigned a cost and the goal is to find a reconciliation that has the lowest total reconciliation cost. Optimal DTL reconciliations can sometimes violate temporal constraints; that is, the transfers are such that they induce contradictory constraints on the dates for the internal nodes of the species tree. We refer to such paradoxical reconciliations as time-inconsistent (after<ref type="bibr" target="#b16">Doyon et al., 2010</ref>). In general, it is desirable to consider only those DTL reconciliations that are time-consistent (i.e. paradox-free). Henceforth, we refer to the problem of specifically computing optimal time-consistent</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M.S.Bansal et al.</head><p>DTL reconciliations as the tcDTL Reconciliation problem. Although the DTL reconciliation problem can be solved in polynomial time, solving the tcDTL reconciliation problem is NP-hard (<ref type="bibr" target="#b35">Ovadia et al., 2011;</ref><ref type="bibr" target="#b44">Tofigh et al., 2011</ref>). If divergence time information is available for the nodes of the species tree (or if there is a known relative temporal ordering for each pair of internal nodes), then any proposed DTL reconciliation must also respect the temporal constraints imposed by the available timing information, i.e., transfers must be restricted to occur only between coexisting species. When such divergence timing information is available, even the tcDTL reconciliation problem becomes polynomially solvable (LibeskindHadas and Charleston, 2009). (Note, however, that time-consistency cannot be guaranteed just by ensuring that transfers occur between coexisting species). In general, the input species tree can be undated, partially dated, or fully dated depending on whether the divergence timing information associated with the nodes of the species tree is absent, partial, or complete, respectively. Thus, in practice, when the species tree is undated or partially dated, one solves the DTL reconciliation problem, and if the species tree is fully dated, one can solve either the DTL reconciliation or the tcDTL reconciliation problem. Let m denote the number of leaves in the input gene tree and n the number of leaves in the species tree. Both the DTL reconciliation problem and the tcDTL reconciliation problem, along with some of their variants, have been extensively studied in the literature (<ref type="bibr" target="#b8">Charleston, 1998;</ref><ref type="bibr" target="#b12">Conow et al., 2010;</ref><ref type="bibr" target="#b15">David and Alm, 2011;</ref><ref type="bibr" target="#b16">Doyon et al., 2010;</ref><ref type="bibr" target="#b20">Gorbunov and Liubetskii, 2009;</ref><ref type="bibr" target="#b27">Libeskind-Hadas and Charleston, 2009;</ref><ref type="bibr" target="#b29">Merkle and Middendorf, 2005;</ref><ref type="bibr" target="#b30">Merkle et al., 2010;</ref><ref type="bibr" target="#b39">Ronquist, 2003;</ref><ref type="bibr" target="#b43">Tofigh, 2009;</ref><ref type="bibr" target="#b44">Tofigh et al., 2011</ref>). The most recent algorithmic work on these problems includes<ref type="bibr" target="#b16">Doyon et al. (2010)</ref>;<ref type="bibr" target="#b43">Tofigh (2009)</ref>;<ref type="bibr" target="#b44">Tofigh et al. (2011)</ref>; and David and Alm, 2011. The paper by<ref type="bibr" target="#b44">Tofigh et al. (2011)</ref>studies a restricted version of the reconciliation model that ignores losses (equivalent to assigning a cost of zero for loss events under the DTL reconciliation problem) and shows that, under this restricted model, the DTL reconciliation problem on undated trees can be solved in O(mn 2 ) time. They also gave a fixed parameter tractable algorithm for enumerating all most parsimonious reconciliations. The time complexity of the O(mn 2 )time algorithm was further improved to O(mn) in<ref type="bibr" target="#b43">Tofigh (2009)</ref>(under the same restricted reconciliation model). However, with the increasing availability of whole-genome datasets, such a restriction on the reconciliation model can be problematic as losses are a rich source of information that can be critical for accurate reconciliation. Indeed, losses play a fundamental role in the ability to distinguish between duplications and transfers as well as in mapping the nodes of the gene tree into the nodes of the species tree, and thus should be explicitly considered during reconciliation. The paper by<ref type="bibr" target="#b16">Doyon et al. (2010)</ref>showed that, for fully dated species trees, the tcDTL reconciliation problem could be solved in O(mn 2 ) time. Recently, an O(mn 2 )-time algorithm for the tcDTL reconciliation problem on fully dated trees has also been independently developed for Version 2 of the program Jane (<ref type="bibr" target="#b12">Conow et al., 2010</ref>). Finally, the recent paper by<ref type="bibr" target="#b15">David and Alm (2011)</ref>gave an O(mn 2 )-time algorithm for the DTL reconciliation problem on undated trees. In summary, in spite of tremendous methodological and algorithmic advances, even the fastest existing algorithms for DTL reconciliation (<ref type="bibr" target="#b15">David and Alm, 2011;</ref><ref type="bibr" target="#b30">Merkle et al., 2010</ref>) as well as for tcDTL reconciliation on fully dated trees (<ref type="bibr" target="#b16">Doyon et al., 2010</ref>) still have a time complexity of (mn 2 ). This makes them too slow to reconcile trees with more than a few hundred taxa, and completely unsuitable for all but the smallest trees when used in sophisticated applications such as reconciliation-based gene tree or species tree reconstruction that require the reconciliation of a multitude of trees while searching through tree space (<ref type="bibr" target="#b2">Bansal et al., 2007;</ref><ref type="bibr" target="#b7">Burleigh et al., 2011;</ref><ref type="bibr" target="#b37">Rasmussen and Kellis, 2011;</ref><ref type="bibr" target="#b46">Vilella et al., 2009</ref>). Our contributions. Recall that the DTL reconciliation problem, even on fully dated species trees, does not guarantee that the optimal reconciliation is time-consistent, whereas the tcDTL reconciliation problem does. However, the tcDTL reconciliation problem suffers from two major drawbacks that limit its applicability in practice. First, the tcDTL reconciliation problem can only be solved efficiently when the species tree is fully dated. This limits its application to only those species tree that contain a relatively small number of taxa (say &lt;100). This is because, it can be extremely difficult to accurately date large species trees (<ref type="bibr" target="#b40">Rutschmann, 2006</ref>) and the accuracy of tcDTL reconciliation relies implicitly on having a correctly dated species tree. Second, the time complexity of the fastest known algorithm for the tcDTL reconciliation problem is O(mn 2 ), which makes it too slow to be used with large datasets (as we also demonstrate later). This also makes it too slow for reconciliation-based gene tree reconstruction of even relatively small gene trees, as it involves repeatedly reconciling a multitude of candidate gene trees against the species tree. Furthermore, the tcDTL reconciliation problem cannot be used for reconciliationbased whole-genome species tree construction (also called gene tree parsimony), as the topology of the species tree is repeatedly modified and so at each step, the species tree is undated. Thus, in this work, we focus on the DTL reconciliation problem. In particular, we improve upon the current state of the art for the DTL reconciliation problem in the following ways:</p><p>(1) We provide an O(mn)-time algorithm for the DTL reconciliation problem on undated species trees. This improves on the fastest known algorithm for this problem by a factor of n. The DTL reconciliation problem on undated trees is the most common version of the DTL reconciliation problem and arises whenever the species tree cannot be accurately dated, as is usually the case with large gene families, and in applications such as reconciliation-based species tree reconstruction.</p><p>(2) For the DTL reconciliation problem on fully dated species trees, we provide an O(mn logn)-time algorithm, which improves on the fastest known algorithm for this problem by a factor of n/logn. Even though the fully dated version of DTL reconciliation does not guarantee time-consistency, as we show later using thorough experimental studies, optimal DTL reconciliations closely approximate optimal tcDTL reconciliations. This algorithm is thus meant as a faster alternative to the O(mn 2 )-time algorithm for tcDTL reconciliation.</p><p>(3) We give a simple O(mn 2 )-time algorithm for DTL reconciliation that can handle distance-dependent transfer costs and can work with undated, partially dated, or fully dated species trees. This is a factor of n faster than the fastest known algorithm that can handle distance-dependent transfer costs (<ref type="bibr" target="#b12">Conow et al., 2010</ref>)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reconciliation using Duplication, Transfer, and Loss</head><p>a fixed transfer cost (<ref type="bibr" target="#b0">Andam and Gogarten, 2011</ref>), and its use may lead to more accurate DTL reconciliations.</p><p>In addition, we also discuss how to efficiently incorporate other enhancements such as detecting transfers from unsampled or extinct lineages that further improve the accuracy of DTL reconciliation. Our O(mn)-time algorithm for undated species trees builds on the O(mn)-time algorithm from Tofigh (2009) that computes optimal reconciliation scenarios under a simpler reconciliation cost that ignores losses. Specifically, we show how to augment that algorithm to efficiently keep track of losses as well. Fully dated species trees presented a greater algorithmic challenge and to obtain our fast O(mnlogn)-time algorithm, we developed a novel algorithmic framework that exploits the structure of fully dated species trees and makes use of recent algorithmic advances on the dynamic range minimum query problem (<ref type="bibr" target="#b6">Brodal et al., 2011</ref>). Our new algorithms and other enhancements represent a great improvement in the runtime and applicability of DTL reconciliation compared with extant approaches. They not only make it possible to analyze large gene families but also to quickly analyze thousands of gene families from across the entire genomes of the species under consideration. Furthermore, and perhaps most importantly, they make DTL reconciliation much more amenable for use in sophisticated applications such as reconciliation-based gene tree or species tree reconstruction. The ability to efficiently handle distancedependent transfer costs, as well as the other enhancements, in turn, makes it possible to reconstruct the evolutionary history of gene families even more accurately. We benchmark our algorithms to both simulated and biological datasets and demonstrate the dramatic improvements in runtime at a range of dataset sizes. We also assess the accuracy of DTL reconciliation, on both dated and undated species trees, compared with optimal tcDTL reconciliations on fully dated trees and demonstrate the utility of using distance-dependent transfer costs in the reconciliation model. In the interest of brevity, all proofs appear in the Supplementary Material (Section S.1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">DEFINITIONS AND PRELIMINARIES</head><p>Given a tree T , we denote its node, edge and leaf sets by V (T ), E(T ) and Le(T ), respectively. If T is rooted, the root node of T is denoted by rt(T ), the parent of a node v ∈ V (T ) by pa T (v), its set of children by Ch T (v), and the (maximal) subtree of T rooted at v by T (v). If two nodes in T have the same parent, they are called siblings. The set of internal nodes of T , denoted I (T ), is defined to be V (T )\Le(T ). We define ≤ T to be the partial order on V (T ), where x ≤ T y if y is a node on the path between rt(T ) and x. The partial order ≥ T is defined analogously, i.e., x ≥ T y if x is a node on the path between rt(T ) and x. We say that v is an ancestor of u, or that u is a descendant of v, if u ≤ T v (note that, under this definition, every node is a descendant as well as ancestor of itself). We say that x and y are incomparable if neither u ≤ T v nor v ≤ T u. Given a non-empty subset L ⊆ Le(T ), we denote by lca T (L), the least common ancestor (LCA) of all the leaves in L in tree T ; that is, lca T (L) is the unique smallest upper bound of L under ≤ T. Given x,y ∈ V (T ), x → T y denotes the unique path from x to y in T. We denote by d T (x,y) the number of edges on the path x → T y. Throughout this work, unless otherwise stated, the term tree refers to a rooted binary tree. A species tree is a tree that depicts the evolutionary relationships of a set of species. Given a gene family from a set of species, a gene tree is a tree that depicts the evolutionary relationships among the sequences encoding only that gene family in the given set of species. Thus, the nodes in a gene tree represent genes. We assume that each leaf of the gene trees is labeled with the species from which that gene was sampled. This labeling defines a leaf-mapping L G,S : Le(G) → Le(S) that maps a leaf node g ∈ Le(G) to that unique leaf node s ∈ Le(S) which has the same label as g. Note that gene trees may have more than one gene sampled from the same species. Throughout this work, we denote the gene tree and species tree under consideration by G and S, respectively, and will implicitly assume that L G,S (g) is well defined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Reconciliation and DTL scenarios</head><p>Copyedited by: TRJ MANUSCRIPT CATEGORY:<ref type="bibr">[</ref></p><formula>(a) M(g) ≤ S M(g ) and M(g) ≤ S M(g ).</formula><p>(b) At least one of M(g ) and M(g ) is a descendant of</p><formula>M(g).</formula><p>(3) Given any edge (g,g ) ∈ E(G), (g,g ) ∈ if and only if M(g) and M(g ) are incomparable.</p><p>(4) If g ∈ I (G) and g and g denote the children of g, then,</p><p>(a) g ∈ only if M(g) = lca(M(g ),M(g )) and M(g ) and M(g ) are incomparable,</p><formula>(b) g ∈ only if M(g) ≥ S lca(M(g ),M(g )),</formula><p>(c) g ∈ if and only if either (g,g ) ∈ or (g,g ) ∈ ,</p><p>(d) If g ∈ and (g,g ) ∈ , then M(g) and τ (g) must be incomparable, the species represented by them must be potentially coexisting with respect to the available divergence time estimates, and M(g ) must be a descendant of τ</p><formula>(g), i.e. M(g ) ≤ S τ (g).</formula><p>Constraint 1 above ensures that the mapping M is consistent with the leaf mapping L. Constraint 2(a) imposes on M the temporal constraints implied by S. Constraint 2(b) implies that any internal node in G may represent at most one transfer event. Constraint 3 determines the edges of G that are transfer edges. Constraints 4(a–c) state the conditions under which an internal node of G may represent a speciation, duplication and transfer, respectively. Constraint 4(d) specifies which species may be designated as the recipient species for any given transfer event. DTL scenarios correspond naturally to reconciliations and it is straightforward to infer the reconciliation of G and S implied by any DTL scenario.<ref type="figure" target="#fig_0">Figure 1</ref>shows two simple DTL scenarios. Given a DTL scenario, one can directly count the minimum number of gene losses in the corresponding reconciliation as follows:</p><p>Definition 2.2 (Losses). Given a DTL scenario</p><formula>α = L,M,,,,,,,,</formula><p>,τ for G and S, let g ∈ V (G) and {g ,g }=Ch(g). The number of losses Loss α (g) at node g is defined to beWe define the total number of losses in the reconciliation corresponding to the DTL scenario α to be Loss α = g∈I (G) Loss α (g). Let P , P and P loss denote the costs associated with duplication, transfer and loss events respectively. The cost of reconciling G and S according to a DTL scenario α is defined as follows. Definition 2.3 (Reconciliation cost of a DTL scenario).</p><formula>@BULLET |d S (M(g),M(g ))−1|+|d S (M(g),M(g ))−1|, if g ∈ @BULLET d S (M(g),M(g )), if g ∈ and M(g) = M(g ). @BULLET d S (M(g),M(g ))+d S (M(g),M(g )), if g ∈ , M(g) = M(g ), and M(g) = M(g ), and @BULLET d S (M(g),M(g ))+d S (τ (g),M(g )) if (g,g ) ∈ .</formula><formula>(a) ( b)</formula><formula>Given a DTL scenario α ==L,M,,,,,,,,</formula><p>,τ for G and S, the reconciliation cost associated with α is given by</p><formula>R α = P ·||+ P ·||+P loss ·Loss α .</formula><p>Given G and S, our goal is to find a most parsimonious reconciliation of G and S. More formally.Based on whether the species tree is undated or fully dated, we distinguish two versions of the MPR problem: (i) The undated MPR (U-MPR) problem where the species tree is undated and (ii) the fully dated MPR (D-MPR) problem where every node of the species tree has an associated divergence time estimate (or there is a known total order on the internal nodes of the species tree). We will exploit the local structure unique to each version to develop faster algorithms for them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">COMPUTING THE MOST PARSIMONIOUS RECONCILIATION</head><p>In this section, we first develop our fast algorithms for the UMPR and D-MPR problems and then give a simple O(mn 2 )-time algorithm for the (general) MPR problem that can efficiently handle distance-dependent transfer costs. Before we proceed, we need a few definitions and additional notation. Definitions: Given any g ∈ I (G) and s ∈ V (S), let c (g,s) denote the cost of an optimal reconciliation of G(g) with S such that g maps to s and g ∈. The terms c (g,s) and c (g,s) are defined similarly for g ∈ and g ∈ , respectively. Given any g ∈ V (G) and s ∈ V (S), we define c(g,s) to be the cost of an optimal reconciliation of G(g) with S such that g maps to s. Thus,</p><formula>c(g,s) = ⎧ ⎨ ⎩ 0 i f g ∈ Le(G) and s = M(g), ∞ if g ∈ Le(G) and s = M(g), min{c (g,s),c (g,s),c (g,s)} otherwise. Furthermore, let in(g,s) = min x∈V (S(s)) {P loss ·d S (s,x)+c(g,x)}, out(g,s) = min x∈V (S)</formula><p>incomparable to s c(g,x), and inAlt(g,s) = min x∈V (S(s)) c(g,x). In other words, inAlt(g,s) is the cost of an optimal reconciliation of G(g) with S such that g may map to any node in V (S(s)); out(g,s) is the cost of an optimal reconciliation of G(g) with S such that g may map to any node from V (S) that is incomparable to s; and in(g,s) is the cost of an optimal reconciliation of G(g) with S such that g may map to any node, say x, in V (S(s)) but with an additional reconciliation cost of one loss event for each edge on the path from s to x. Note that the optimal reconciliation cost of G and S is simply: min s∈V (S) c(rt(G),s). The equation for c(g,s) above, used in a dynamic programming framework and coupled with methods for computing the values of c (g,s), c (g,s) and c (g,s), forms the basis of all our algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i286</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reconciliation using Duplication, Transfer, and Loss</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">An O(mn)-time algorithm for U-MPR</head><p>The following algorithm solves the U-MPR problem in O(mn) time. Our algorithm builds on the O(mn)-time dynamic programming algorithm from Tofigh (2009) that computes optimal reconciliation scenarios under a simpler reconciliation cost that ignores losses. We compute the values c (g,s), c (g,s) and c (g,s) for each g ∈ V (G) and s ∈ V (S) by performing a nested post-order traversal of G and S. For efficiency, we save and reuse as much of the computation from previous steps as possible, and the values in(·,·), inAlt(·,·) and out(·,·) help us in efficiently computing the values c (g,s), c (g,s), and c (g,s) at each dynamic programming step. For instance, for any g ∈ I (G), the value of c (g,s) is simply: ∞ if s ∈ Le(S), and min{in(g ,s )+in(g ,s ), in(g ,s )+in(g ,s )}, where {g ,g }=Ch G (g) and {s ,s }=Ch S (s), if s ∈ I (S). The values of c (g,s) and c (g,s) can be similarly computed; see Steps 10 and 18 of Algorithm U-Reconcile for c (g,s) and Steps 11 and 19 for c (g,s). The nested post-order traversal ensures that when computing the values c (g,s), c (g,s) and c (g,s) at nodes g ∈ G and s ∈ S, all the required in(·,·), inAlt(·,·), out(·,·) and c(·,·) values have already been computed. Algorithm U-Reconcile(G,S,L) 1. for each g ∈ V (G) and s ∈ V (S) do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Initialize c(g,s), c (g,s), c (g,s), c (g,s), in(g,s), inAlt(g,s), and out(g,s) to ∞. 3. for each g ∈ Le(G) do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>Initialize c(g,L(g)) to 0, and, for each s ≥ S L(g), initialize in(g,s) to P loss ·d S (s,L(g)) and inAlt(g,s) to 0. 5. for each g ∈ I (G) in post-order do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.</head><p>for each s ∈ V (S) in post-order do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7.</head><p>Let {g ,g }=Ch G (g).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>8.</head><p>if s ∈ Le(S) then 9. c (g,s) =∞.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>10.</head><p>c (g,s) = P +c(g ,s)+c(g ,s).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11.</head><p>If s = rt(S), then c (g,s) = P +min{in(g ,s)+ out(g ,s), in(g ,s)+out(g ,s)}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>12.</head><p>c(g,s) = min{c (g,s),c (g,s),c (g,s)}.</p><formula>13. in(g,s) = c(g,s). 14. inAlt(g,s) = c(g,s). 15. else 16. Let {s ,s }=Ch S (s). 17. c (g,s) = min{in(g ,s )+in(g ,s ),in(g ,s )+ in(g ,s )}. 18. c (g,s) = P +min ⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩ c(g ,s)+in(g ,s )+P loss , c(g ,s)+in(g ,s )+P loss , c(g ,s)+in(g ,s )+P loss , c(g ,s)+in(g ,s )+P loss , c(g ,s)+c(g ,s), in(g ,s )+in(g ,s )+2P loss , in(g ,s )+in(g ,s )+2P loss , in(g ,s )+in(g ,s )+2P loss , in(g ,s )+in(g ,s )+2P loss. 19. If s = rt(S), then c (g,s) = P +min{in(g ,s)+ out(g ,s), in(g ,s)+out(g ,s)}. 20. c(g,s) = min{c (g,s),c (g,s),c (g,s)}. 21. in(g,s) = min{c(g,s),in(g,s )+P loss ,in(g,s )+P loss }. 22. inAlt(g,s) = min{c(g,s),inAlt(g,s ),inAlt(g,s )}. 23. for each s ∈ I (S) in pre-order do 24. Let {s ,s }=Ch S (s). 25. out(g,s ) = min{out(g,s),inAlt(g,s )}, and out(g,s ) = min{out(g,s),inAlt(g,s )}. 26. Return min s∈V (S) c(rt(G),s). Remarks: (i)</formula><p>Note that, while the above algorithm only outputs the optimal reconciliation cost, it can be easily adapted, without affecting its time complexity, to output the DTL scenario itself. (ii) The algorithm above implicitly assumes that if g ∈ I (G) is a transfer node such that (g,g ) ∈ , then τ (g) = M(g ). The reason for this is easy to see: any reconciliation in which τ (g) is not M(g) (and losses have a strictly positive cost), cannot be most parsimonious. This, however, only holds true for the U-MPR problem, and we will be unable to make this assumption when working with partially or fully dated species trees. We have the following theorem. (all proofs are available in the Supplementary Material). Theorem 3.1. The U-MPR problem on G and S can be solved in O(mn) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">An O(mnlogn)-time algorithm for D-MPR</head><p>In the D-MPR problem, there exists a total ordering of the internal nodes of the species tree based on their divergence times. Thus, in this setting, for any given pair of species tree edges, it is known whether the two species represented by those edges overlapped in their time of existence, and transfers are only allowed between two species if they are coexisting. We assign consecutive positive integers, starting with one, to the internal nodes of the species tree according to the total order. These numbers are referred to as time stamps and they represent the temporal order in which the species represented by these nodes diverged. Given a node s ∈ V (S), we denote its time stamp by t(s). If the largest time stamp assigned to the internal nodes is k, then we assign time stamp k +1 to each leaf of S. Any two consecutive time stamps x,x +1 define the time zone labeled x on S. Given a node s ∈ V (S)\rt(S), the species represented by that node exists along the edge (pa(s),s) and is consequently associated with the time stamp interval</p><formula>[t(pa(s)),t(s)]</formula><p>and the time zones</p><formula>t(pa(s)),...,t(s)−1.</formula><p>Observe that any edge from E(S) is associated with at least one time zone. Given any pair of nodes s,s ∈ V (S)\ rt(S), a transfer is allowed between the species represented by those nodes if and only if the two edges (pa(s),s) and (pa(s ),s ) overlap in at least one time zone. Our algorithm for the D-MPR problem, called Algorithm Dreconcile, makes use of the same overall dynamic programming structure as Algorithm U-Reconcile, and the procedure for computing the values c (·,·) and c (·,·) remains identical. The difference is in the way c (·,·) is computed, as we can no longer rely on the out(·,·) values. Instead, we need a more elaborate procedure that can efficiently yield the 'best receiver' for a transfer originating at the species tree node currently under consideration, from among the relevant time zones. More concretely, suppose we want to compute the value c (g,s) assuming that (g,g ) ∈ , where g ∈ Ch(g), for each s ∈ V (S). Our algorithm first efficiently computes the locally best and locally second-best receivers of gene g in each time zone based on the values c(g ,·). Then, for each candidate node s under consideration, we efficiently compute the best receiver, for a transfer originating at s, by choosing the globally i287</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M.S.Bansal et al.</head><p>optimal value from among the previously computed locally best and locally second-best receivers for the relevant time zones. For efficiency, our algorithm makes use of (i) a binomial heap data structure and (ii) a dynamic range minimum query data structure. The binomial heap data structure maintains a set of P-values while supporting find-min, insert and delete operations in O(1), O(logp) and O(logp) time, respectively (<ref type="bibr" target="#b13">Cormen et al., 2009;</ref><ref type="bibr" target="#b47">Vuillemin, 1978</ref>). The dynamic range minimum query data structure maintains an ordered list of numbers and can answer queries that seek the smallest element in a given query range in O(logp) time and also supports update operations that change the value of an element in the list in O(logp) time (<ref type="bibr" target="#b6">Brodal et al., 2011</ref>). Definitions. Let k denote the number of time zones on the species tree. Given a time zone i</p><formula>(1 ≤ i ≤ k), let Z(i)</formula><p>denote the set of edges from E(S) that are associated with time zone i. Let Best(g,i) and secondBest(g,i) denote, respectively, the two edges from Z(i) with the smallest value of in(g,·). Preprocessing. Before running Algorithm D-Reconcile, we assume that we have precomputed, for each time zone i</p><formula>(1 ≤ i ≤ k), the following: (i) the set of edges (pa(s),s) ∈ E(S) for which t(s)−1 = i (i.e. (pa(s),s) is associated with Z(i), but not with Z(i +1)</formula><p>), referred to as end(i) and (ii) the set of edges (pa(s),s) ∈ E(S) for which t(pa(s)) = i (i.e. (pa(s),s) is associated with Z(i), but not with Z(i −1)), referred to as begin(i). The algorithm below makes use of the procedure bestReceiver which takes as input a node g ∈ I (G), a child x of g, and an edge s from S and returns, from among all those edges that share at least one time zone with s, an edge (pa(y),y) for which the value in(g,y) is smallest. Essentially, the returned edge (pa(y),y) implies that, in a scenario where g maps to s and g is a transfer node with (g,x) ∈ , the best possible mapping for x (i.e. one for which c (g,s) is minimized) is y.</p><formula>Algorithm D−Reconcile(G,S,L) 1. Let k</formula><p>denote the number of time zones on S.</p><formula>2. for each g ∈ V (G) and s ∈ V (S) do 3. Initialize c(g,s), c (g,s), c (g,s), c (g,s) and in(g,s) to ∞. 4. for each g ∈ Le(G) do 5. Initialize c(g,L(g)) to 0, and, for each s ≥ S L(g), initialize in(g,s) to P loss ·d S (s,L(g)). 6. for each g ∈ I (G) in post-order do 7. Let {g ,g }=Ch G (g). 8. for each x ∈{g ,g } do 9.</formula><p>Create an empty binomial heap data structure H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>10.</head><p>Consider each edge (pa(y),y) from Z(k) and add it to H based on the value in(x,y).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>11.</head><p>Query the heap H to assign Best(x,k) and secondBest(x,k).Update the heap H by deleting from it all the edges in begin(i +1) and inserting all the edges in end(i) (according to their in(x,·) scores).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>14.</head><p>Query the heap H to assign Best(x,i) and secondBest(x,i).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>15.</head><p>Add all the edges Best(x,·) and secondBest(x,·), labeled by their c(x,·) scores, to a dynamic range minimum query data structure, indexed by their time zones (Note that, as stated, each index gets assigned two values, which makes for an ill-defined range minimum query data structure. However, this is easy to get around by assigning Best(x,i) to index 2i −1, and secondBest(x,i) to index 2i, and querying the data structure accordingly). We denote this data structure by x .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>16.</head><p>Delete the heap H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>17.</head><p>for each s ∈ V (S) in post-order do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>18.</head><p>If s = rt(S), then let (pa(u),u) = bestReceiver(g,g ,s), and (pa(v),v) = bestReceiver(g,g ,s).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>19.</head><p>This part of the algorithm is identical to Steps 8 through 22 of Algorithm U-Reconcile, except, (a) Steps 11 and 19 are replaced by the following:Theorem 3.2. The D-MPR problem on G and S can be solved in O(mnlogn) time.</p><formula>If s = rt(S), then c (g,s) = P +min{in(g ,s)+ c(g ,v), in(g ,s)+c(g ,u)}, and,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Considering distance-dependent transfer costs</head><p>Under the current reconciliation model, all transfers have the same cost irrespective of the span of the transfer. However, it has been observed that transfers are more likely to occur between closely related species than between distantly related ones (<ref type="bibr" target="#b0">Andam and Gogarten, 2011</ref>). This suggests that, ideally, the cost of a transfer should depend on the phylogenetic distance between the donating and receiving species. Such a cost scheme could be implemented in several different ways: one straightforward way to implement this is to define the transfer cost between species a and b to be</p><formula>P (a,b) = θ 1 +d S (a,b)·θ 2 , where θ 1 ,θ 2 ≥ 0</formula><p>. If branch lengths are available on the species tree, d S (a,b) could also be replaced by a term that counts the total branch length between a and b. A simpler alternative is to have different constant transfer costs for different ranges of transfer spans. Next, we give a simple O(mn 2 )-time algorithm for the (general) MPR problem that can work with undated, partially dated, or fully dated species trees and can handle distance-dependent transfer costs. This makes it a factor of n faster than the fastest known algorithm that can handle distance-dependent transfer costs. Our algorithm, which we will refer to as algorithm reconcile, is essentially the same as algorithm U-Reconcile, except that we remove our dependence on the out array and assign a cost of ∞ to those transfers that violate any given time constraints. Specifically, we (i) remove Lines 14, 22, and 23 through 25 and (ii) replace Steps 11 and 19 with the following five: Let X ={x ∈ V (S) : x is incomparable to and potentially coexisting with s}.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reconciliation using Duplication, Transfer, and Loss</head><p>for each x ∈ X Temp(x) = P (s,x)+min{in(g ,x)+in(g ,x),</p><formula>in(g ,x)+in(g ,x)}. c (g,s) = min x∈X Temp(x)</formula><p>Given any a and b, the value of P (a,b) under distance-dependent transfer costs can be computed in constant time as long as the value d S (a,b) (or its equivalent in terms of branch lengths) can be computed in constant time. This can be achieved after an O(n) preprocessing of the species tree, which (i) allows constant time LCA querying (<ref type="bibr" target="#b3">Bender et al., 2005</ref>) and (ii) labels each species tree node with its distance (or total branch length) from the root. This yields the following theorem. Theorem 3.3. The MPR problem on G and S with distancedependent transfer costs can be solved in O(mn 2 ) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Algorithmic extensions</head><p>Unrooted gene trees. If the input gene trees are unrooted, each possible rooted version of the unrooted gene tree is reconciled against the species tree and the goal is to find a reconciliation that has minimum cost among all rootings. Each of our three algorithms described earlier can be easily extended to work with unrooted gene trees without any increase in their respective time complexities. This is done by relying on the oft-used observation (<ref type="bibr" target="#b11">Chen et al., 2000</ref>) that, w.r.t. any internal node g, all rootings of the tree can be partitioned into three sets, depending on which of the tree edges incident on the node is closest to the root node. We have implemented this feature into our software RANGER-DTL. Multiple optimal solutions. It should be noted that, for any given values of the event costs P , P and P loss , there may be more than one optimal solution for the MPR problem. The O(mn 2 ) algorithm above can be easily adapted to output all possible optimal reconciliations for any given problem instance. Further enhancements. It is also possible to extend each of our three algorithms, without any increase in their time complexities, to consider more complex biological scenarios, such as transfers from potentially extinct or unsampled lineages, or transfer from a species that then loses its copy of that gene. A more detailed discussion of these enhancements appears in the Supplementary Material (Section S.2).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENTAL EVALUATION</head><p>We implemented our fast algorithms into a software package called RANGER-DTL (Rapid ANalysis of Gene family Evolution using Reconciliation-DTL). Since the accuracy and utility of DTL and tcDTL reconciliation for inferring gene family evolution have already been demonstrated elsewhere (<ref type="bibr" target="#b15">David and Alm, 2011;</ref><ref type="bibr" target="#b16">Doyon et al., 2010;</ref><ref type="bibr" target="#b20">Gorbunov and Liubetskii, 2009;</ref><ref type="bibr" target="#b43">Tofigh, 2009</ref>), we do not attempt to do so here. Instead, our goal is to (i) demonstrate the immense speedup in running time achieved by our algorithms over existing state-of-the-art programs; (ii) compare the solutions obtained by DTL reconciliation on undated and fully dated species trees against tcDTL reconciliation on fully dated trees (which can be thought of as a 'gold standard'); and (iii) demonstrate the utility of enhancements such as distance-dependent transfer costs. To that end, we applied RANGER-DTL to a variety of simulated and biological datasets. Specifically, we created 500 simulated datasets (gene tree– species tree pairs), 100 each with 50, 100, 200, 500 and 1000 taxa generated using the probabilistic gene evolution model described in<ref type="bibr" target="#b1">Arvestad et al. (2009)</ref>; Tofigh (2009);<ref type="bibr" target="#b44">Tofigh et al. (2011)</ref>. We ensured that each simulated gene tree had at least one gene from each species in the corresponding species tree, and they contained on average 98.2, 195, 334.3, 618.8 and 1423.5 leaves, respectively, for the 50, 100, 200, 500 and 1000 taxa datasets. We also created a 10 000-taxon gene tree–species tree pair with random topologies to demonstrate the feasibility of analyzing even extremely large trees with RANGER-DTL. We point out that the running time depend only on the sizes of the input gene and species trees and are thus independent of the actual rate parameters used to generate the simulated trees and of the event costs used to compute the reconciliation. Our biological dataset was derived from David and Alm (2011) and consists of over 4700 unrooted gene trees with a species tree of 100 (predominantly prokaryotic) species sampled broadly across the tree of life. This biological dataset was analyzed using the same cost parameters (P = 2, P = 3, P loss = 1) used in David and Alm (2011). Running time. To compare the running time of our algorithms, we used an implementation of our algorithm for DTL reconciliation on undated species trees, referred to as the RANGER-DTL-U program, and compared it against AnGST (<ref type="bibr" target="#b15">David and Alm, 2011</ref>) and Mowgli (<ref type="bibr" target="#b16">Doyon et al., 2010</ref>) which are two of the most advanced programs implementing the fastest known algorithms for DTL reconciliation on undated species trees and tcDTL reconciliation on fully dated species trees, respectively. When running RANGER-DTL-U and AnGST on these datasets, all divergence-time information (branch lengths) on the nodes of the species trees was ignored. Moreover while both RANGER-DTL and AnGST can efficiently handle unrooted gene trees, Mowgli cannot; thus, we first randomly rooted each of the 4733 gene trees of the biological dataset.<ref type="figure" target="#tab_1">Table 1</ref>depicts the results. We find a dramatic improvement in runtime and scalability over both AnGST and Mowgli. For instance, on the 100 simulated 100-taxon datasets, RANGER-DTL-U is an impressive 300 and 4500 times faster than AnGST and Mowgli, respectively. Similar speedups are observed on the biological dataset as well, with RANGER-DTL-U requiring just over a minute to analyze the entire dataset of 4733 gene trees. (Even when run directly on the original unrooted gene trees, it requires only about 2 min to analyze the entire dataset). Moreover, the speedups are, as anticipated, even greater for larger datasets. AnGST required between 8 and 10 h on each of the 10 randomly chosen 500-taxon datasets that we tried, suggesting a running time of at least 800 h on all 100 datasets, and it crashed immediately on the 1000-taxon datasets. Similarly, Mowgli crashed after ∼4 h of running time on each of the 10 randomly chosen 500-taxon datasets that we tried, and did not terminate in 60 h (after which we stopped the program) on any one of the 10 1000-taxon datasets we ran it on. This suggests a total running time of at least 400 and 6000 h on all 100 of the 500-and 1000-taxon datasets, respectively, for Mowgli. In contrast, RANGER-DTL-U required &lt;2 s on each 1000-taxon dataset, which is, remarkably, over 100 000 times faster than Mowgli. While neither AnGST nor Mowgli can be run on the 10 000-taxon dataset, RANGER-DTL-U required only ∼4 h to analyze it. Solution quality. Note that it is ineffective to compare the actual reconciliations themselves as the presence of multiple</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>M.S.Bansal et al.</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Simple DTL scenarios. (a) and (b) depict two possible reconciliations of G and S: the dotted arcs show the mapping M (with the leaf mapping being specified by the leaf labels on the gene tree), and the label at each internal node of G specifies the type of event represented by that node. The reconciliation in (a) requires two transfers and one loss and the one in (b) requires one duplication and two losses</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: [11:45 31/5/2012 Bioinformatics-bts225.tex] Page: i288 i283–i291</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>12. for each time zone i in decreasing order from k −1 to 1 do 13.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>(b) Steps 14 and 22 are removed. 20. Delete the data structures g and g. 21. Return min s∈V (S) c(rt(G),s). Procedure</figDesc><table>bestReceiver is implemented as follows: 
Procedure bestReceiver(g,x,s) 
1. Query the data structure x with the query range 
[t(pa(s)),t(s)−1]. Let e denote the returned edge. 

2. If e happens to be the edge (pa(s),s), then remove e from x , 
and repeat the above step. 
3. Reinsert any removed edges back into x . 
4. Return e. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Table 1. Runtime comparison</figDesc><table></table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Reconciling a gene tree with a species tree involves mapping the gene tree into the species tree. Such a mapping allows us to infer the evolutionary events that gave rise to that particular gene tree. In this case, the evolutionary events of interest are speciation, gene duplication, horizontal gene transfer and gene loss. Next, we define what constitutes a valid reconciliation; specifically, we define a DTL scenario (Tofigh et al., 2011) for G and S that characterizes the mappings of G into S that constitute a biologically valid reconciliation. Essentially, DTL scenarios map each gene tree node to a unique species tree node in a consistent way that respects the immediate temporal constraints implied by the species tree and designate each gene tree node as representing a speciation, duplication or transfer event. For any gene tree node, say g, that represents a transfer event, DTL scenarios also specify which of the two edges (g,g ) or (g,g ), where g and g denote the children of g, represents the transfer edge on S, and identify the recipient species of the corresponding transfer. Incorporating available divergence time information. When accurate divergence time information is available, for some or all of the nodes of the species tree, DTL scenarios must respect the temporal constraints imposed by the available timing information. Specifically, those transfer events that are inconsistent with the available timing information are disallowed (as transfer events could only have happened between two coexisting species). If there is no divergence time information available, then transfers are allowed to occur between any pair of incomparable species on the species tree. The definition of a DTL scenario below is a generalization of the definition from Tofigh et al. (2011). The generalization is necessary to correctly handle optimal reconciliations in cases when the species tree is dated. Specifically, we enforce that, if the species tree is dated, then transfers can only occur between coexisting species and introduce an additional variable to explicitly specify the recipient species for any transfer event. Definition 2.1 (DTL scenario). A DTL scenario for G and S is a seven-tuple L,M,,,,,,,,,τ , where L : Le(G) → Le(S) represents the leaf mapping from G to S, M : V (G) → V (S) maps each node of G to a node of S, the sets , and partition I (G) into speciation, duplication and transfer nodes, respectively, is a subset of gene tree edges that represent transfer edges, and τ : → V (S) specifies the recipient species for each transfer event, subject to the following constraints: (1) If g ∈ Le(G), then M(g) = L(g). (2) If g ∈ I (G), and g and g denote the children of g, then, i285 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="4"> h by AnGST and over 41 h by Mowgli. Even on the 1000-taxon datasets, it required &lt;15 min per dataset. Although we have not yet implemented our fast O(mnlogn)-time algorithm for the D-MPR problem (since the general O(mn 2 ) algorithm solves the D-MPR problem as well), its runtime can be expected to be only slightly higher than that of RANGER-DTL-U. RANGER-DTL can be freely downloaded from http://compbio.mit.edu/ranger-dtl/. 5 DISCUSSION AND CONCLUSION In this article, we addressed the DTL reconciliation problem for reconstructing gene family evolution. We proposed new algorithms that are dramatically faster than any existing algorithms for this problem and proposed several enhancements necessary for improving the utility and accuracy of the computed solutions. Our work represents a substantial improvement in the ability to accurately analyze large gene families. It also enables, for the first time, the use of powerful, reconciliation-based gene tree and species tree reconstruction methods for prokaryotes. For instance, to reconstruct a 100-taxon species tree by gene tree parsimony, using a standard local search heuristic, one would need to reconcile on the order of many millions of gene tree/species tree pairs; using even the fastest existing DTL reconciliation algorithms, such as AnGST, one would require several years of computing time to perform such an analysis, compared with just a few days using RANGER-DTL. There are a number of ways to further improve the accuracy of DTL reconciliation and we would like to explore these in the future. For instance, it would help to explicitly distinguish between two types of transfers: ones that contribute an additional gene to the recipient genome and those that recombine with an existing gene copy and replace it. Under the current DTL reconciliation models, recombining transfers are counted as a transfer followed by a loss. Moreover, our current implementation assumes that the input gene tree topology is correct and it would be very useful to have an effective way to deal with any uncertainty in gene tree topologies.</note>

			<note place="foot">i291 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors thank Ali Tofigh for help with the tree simulation software, Lawrence David for providing the biological dataset, and Matt Rasmussen for helpful discussions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Reconciliation using Duplication, Transfer, and Loss</head></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Biased gene transfer in microbial evolution</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">P</forename>
				<surname>Andam</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">P</forename>
				<surname>Gogarten</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Microbiol</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="543" to="555" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">The gene evolution model and computing its associated probabilities</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Arvestad</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="1" to="7" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Heuristics for the gene-duplication problem: a (n) speed-up for the local search</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Bansal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RECOMB</title>
		<editor>Speed, T.P. and Huang, H.</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="238" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Lowest common ancestors in trees and directed acyclic graphs</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">A</forename>
				<surname>Bender</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algor</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="75" to="94" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Inferring and validating horizontal gene transfer events using bipartition dissimilarity</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Boc</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="page" from="195" to="211" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Reconciling a gene tree to a species tree under the duplication cost model</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Bonizzoni</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">347</biblScope>
			<biblScope unit="page" from="36" to="53" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Path minima queries in dynamic weighted trees</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">S</forename>
				<surname>Brodal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">WADS. Lecture Notes in Computer Science</title>
		<editor>F. Dehne, et al.</editor>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">6844</biblScope>
			<biblScope unit="page" from="290" to="301" />
			<date type="published" when="2011" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Genome-scale phylogenetics: inferring the plant tree of life from 18,896 gene trees</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">G</forename>
				<surname>Burleigh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="117" to="125" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Jungles: a new solution to the host–parasite phylogeny reconciliation problem</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Charleston</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Math. Biosci</title>
		<imprint>
			<biblScope unit="volume">149</biblScope>
			<biblScope unit="page" from="191" to="223" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Traversing the tangle: algorithms and applications for cophylogenetic studies</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">A</forename>
				<surname>Charleston</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Perkins</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Biomed. Inform</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="62" to="71" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Gene family evolution by duplication, speciation, and loss</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Chauve</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1043" to="1062" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Notung: a program for dating gene duplications and optimizing gene family trees</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="429" to="447" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Jane: a new tool for the cophylogeny reconstruction problem</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Conow</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithm. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">16</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">H</forename>
				<surname>Cormen</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>MIT press</publisher>
		</imprint>
	</monogr>
	<note>3rd. edn</note>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">A probabilistic model for gene content evolution with duplication, loss, and horizontal transfer</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Csürös</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Miklós</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RECOMB</title>
		<editor>Apostolico, A. et al.</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="206" to="220" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Rapid evolutionary innovation during an archaean genetic expansion</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">A</forename>
				<surname>David</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">J</forename>
				<surname>Alm</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">469</biblScope>
			<biblScope unit="page" from="93" to="96" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">An efficient algorithm for gene/species trees parsimonious reconciliation with losses, duplications and transfers</title>
		<author>
			<persName>
				<forename type="first">J.-P</forename>
				<surname>Doyon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RECOMBCG</title>
		<editor>Tannier, E.</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="93" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">A hybrid micro-macroevolutionary approach to gene tree reconstruction</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Durand</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="320" to="335" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">On the equivalence of two tree mapping measures</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Eulenstein</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Vingron</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Appl. Math</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="page" from="101" to="126" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Fitting the gene lineage into its species lineage. A parsimony strategy illustrated by cladograms constructed from globin sequences</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Goodman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Zool</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="132" to="163" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Reconstructing genes evolution along a species tree</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">Y</forename>
				<surname>Gorbunov</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<forename type="middle">A</forename>
				<surname>Liubetskii</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="946" to="958" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Dls-trees: a model of evolutionary scenarios</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Górecki</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Tiuryn</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">359</biblScope>
			<biblScope unit="page" from="378" to="399" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient algorithms for lateral gene transfer problems</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">T</forename>
				<surname>Hallett</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Lagergren</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the fifth Annual International Conference on Research in Computational Molecular Biology (RECOMB)</title>
		<editor>Lengauer, T.</editor>
		<meeting>the fifth Annual International Conference on Research in Computational Molecular Biology (RECOMB)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="149" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Sprit: identifying horizontal gene transfer in rooted phylogenetic trees</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Hill</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Evol. Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">42</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">A Bayesian framework for the analysis of cospeciation</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">P</forename>
				<surname>Huelsenbeck</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolution</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="352" to="364" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Parsimony score of phylogenetic networks: hardness results and a linear-time heuristic</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Jin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinforma</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="495" to="505" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Orthologs, paralogs, and evolutionary genomics</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">V</forename>
				<surname>Koonin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="309" to="338" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">On the computational complexity of the reticulate cophylogeny reconstruction problem</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Libeskind-Hadas</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Charleston</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="105" to="117" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Dupcar: reconstructing contiguous ancestral regions with duplications</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1007" to="1027" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Reconstruction of the cophylogenetic history of related phylogenetic trees with divergence timing information</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Merkle</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Middendorf</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Biosci</title>
		<imprint>
			<biblScope unit="volume">123</biblScope>
			<biblScope unit="page" from="277" to="299" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">A parameter-adaptive dynamic programming approach for inferring cophylogenies</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Merkle</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinform</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">60</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>Suppl. . 1</note>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">Panther version 7: improved phylogenetic trees, orthologs and collaboration with the gene ontology consortium</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Mi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="204" to="210" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>Suppl. . 1</note>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">A biologically consistent model for comparing molecular phylogenies</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Mirkin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="493" to="507" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">Reconstructing reticulate evolution in species: theory and practice</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Nakhleh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eighth Annual International Conference on Research in Computational Molecular Biology (RECOMB)</title>
		<editor>Bourne and Gusfield</editor>
		<meeting>the Eighth Annual International Conference on Research in Computational Molecular Biology (RECOMB)<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="337" to="346" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">RIATA-HGT: a fast and accurate heuristic for reconstructing horizontal gene transfer</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Nakhleh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">COCOON</title>
		<editor>Wang, L.</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="84" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">The cophylogeny reconstruction problem is np-complete</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Ovadia</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="59" to="65" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<analytic>
		<title level="a" type="main">Maps between trees and cladistic analysis of historical associations among genes, organisms, and areas</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">D M</forename>
				<surname>Page</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="58" to="77" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title level="a" type="main">A Bayesian approach for fast and accurate gene tree reconstruction</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">D</forename>
				<surname>Rasmussen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kellis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="273" to="290" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b38">
	<analytic>
		<title level="a" type="main">Reconstructing the history of host–parasite associations using generalised parsimony</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Ronquist</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cladistics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="73" to="89" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b39">
	<monogr>
		<title level="m" type="main">Parsimony analysis of coevolving species associations Tangled Trees: Phylogeny, Cospeciation and Coevolution</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Ronquist</surname>
			</persName>
		</author>
		<editor>Page, R.D.M.</editor>
		<imprint>
			<date type="published" when="2003" />
			<publisher>The University of Chicago Press</publisher>
			<biblScope unit="page" from="22" to="64" />
			<pubPlace>Chicago</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b40">
	<analytic>
		<title level="a" type="main">Molecular dating of phylogenetic trees: a brief review of current methods that estimate divergence times</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Rutschmann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Divers. Distrib</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="35" to="48" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b41">
	<analytic>
		<title level="a" type="main">Probabilistic orthology analysis</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Sennblad</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Lagergren</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="411" to="424" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b42">
	<analytic>
		<title level="a" type="main">Automated ortholog inference from phylogenetic trees and calculation of orthology reliability</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">E V</forename>
				<surname>Storm</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">L L</forename>
				<surname>Sonnhammer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="92" to="99" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b43">
	<monogr>
		<title level="m" type="main">Using trees to capture reticulate evolution: lateral gene transfers and cancer progression</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Tofigh</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b44">
	<analytic>
		<title level="a" type="main">Simultaneous identification of duplications and lateral gene transfers</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Tofigh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="517" to="535" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b45">
	<analytic>
		<title level="a" type="main">Orthology prediction at scalable resolution by phylogenetic tree analysis</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Van Der Heijden</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinform</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">83</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b46">
	<analytic>
		<title level="a" type="main">Ensemblcompara genetrees: complete, duplication-aware phylogenetic trees in vertebrates</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">J</forename>
				<surname>Vilella</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="327" to="335" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b47">
	<analytic>
		<title level="a" type="main">A data structure for manipulating priority queues</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Vuillemin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="309" to="315" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b48">
	<analytic>
		<title level="a" type="main">Natural history and evolutionary principles of gene duplication in fungi</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Wapinski</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">449</biblScope>
			<biblScope unit="page" from="54" to="61" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>