
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:46+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">HAPCOL: accurate and memory-efficient haplotype assembly from long reads</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Yuri</forename>
								<surname>Pirola</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Informatica Sistemistica e Comunicazione (DISCo)</orgName>
								<orgName type="institution">Univ. degli Studi di Milano-Bicocca</orgName>
								<address>
									<settlement>Milan</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Simone</forename>
								<surname>Zaccaria</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Informatica Sistemistica e Comunicazione (DISCo)</orgName>
								<orgName type="institution">Univ. degli Studi di Milano-Bicocca</orgName>
								<address>
									<settlement>Milan</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Riccardo</forename>
								<surname>Dondi</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Dipartimento di Scienze Umane e Sociali</orgName>
								<orgName type="institution">Univ. degli Studi di Bergamo</orgName>
								<address>
									<settlement>Bergamo</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Gunnar</forename>
								<forename type="middle">W</forename>
								<surname>Klau</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Life Sciences group</orgName>
								<orgName type="institution">Centrum Wiskunde &amp; Informatica (CWI)</orgName>
								<address>
									<addrLine>The Netherlands</addrLine>
									<settlement>Amsterdam</settlement>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">ERABLE Team</orgName>
								<orgName type="institution" key="instit2">INRIA</orgName>
								<address>
									<region>Lyon</region>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Nadia</forename>
								<surname>Pisanti</surname>
							</persName>
							<affiliation key="aff3">
								<orgName type="institution" key="instit1">ERABLE Team</orgName>
								<orgName type="institution" key="instit2">INRIA</orgName>
								<address>
									<region>Lyon</region>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="department">Dipartimento di Informatica</orgName>
								<orgName type="institution">Univ. degli Studi di Pisa</orgName>
								<address>
									<settlement>Pisa</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName>
								<forename type="first">Paola</forename>
								<surname>Bonizzoni</surname>
							</persName>
							<email>bonizzoni@disco.unimib.it</email>
							<affiliation key="aff0">
								<orgName type="department">Dipartimento di Informatica Sistemistica e Comunicazione (DISCo)</orgName>
								<orgName type="institution">Univ. degli Studi di Milano-Bicocca</orgName>
								<address>
									<settlement>Milan</settlement>
									<country key="IT">Italy</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">HAPCOL: accurate and memory-efficient haplotype assembly from long reads</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btv495</idno>
					<note type="submission">Received on April 7, 2015; revised on July 24, 2015; accepted on August 10, 2015</note>
					<note>Genome analysis *To whom correspondence should be addressed. † The authors wish it to be known that, in their opinion, the first two authors should be regarded as joint First Authors. Associate Editor: Gunnar Ratsch Availability and implementation: Our source code is available under the terms of the GNU General Public License at http://hapcol.algolab.eu/. Contact: Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Haplotype assembly is the computational problem of reconstructing haplotypes in dip-loid organisms and is of fundamental importance for characterizing the effects of single-nucleotide polymorphisms on the expression of phenotypic traits. Haplotype assembly highly benefits from the advent of &apos;future-generation&apos; sequencing technologies and their capability to produce long reads at increasing coverage. Existing methods are not able to deal with such data in a fully satisfactory way, either because accuracy or performances degrade as read length and sequencing coverage increase or because they are based on restrictive assumptions. Results: By exploiting a feature of future-generation technologies—the uniform distribution of sequencing errors—we designed an exact algorithm, called HAPCOL, that is exponential in the maximum number of corrections for each single-nucleotide polymorphism position and that minimizes the overall error-correction score. We performed an experimental analysis, comparing HAPCOL with the current state-of-the-art combinatorial methods both on real and simulated data. On a standard benchmark of real data, we show that HAPCOL is competitive with state-of-the-art methods, improving the accuracy and the number of phased positions. Furthermore, experiments on realistically simulated data-sets revealed that HAPCOL requires significantly less computing resources, especially memory. Thanks to its computational efficiency, HAPCOL can overcome the limits of previous approaches, allowing to phase datasets with higher coverage and without the traditional all-heterozygous assumption.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Diploid organisms such as humans contain two sets of chromosomes, one from each parent. Reconstructing the two distinct copies of each chromosome, called haplotypes, is crucial for characterizing the genome of an individual. The process is known as phasing or haplotyping and the provided information may be of fundamental importance for many applications, such as analyzing the relationships between genetic variation and gene function, or between genetic variation and disease susceptibility (<ref type="bibr" target="#b3">Browning and Browning, 2011;</ref><ref type="bibr" target="#b9">Duitama et al., 2012</ref>). In diploid species, haplotyping requires V C The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com assigning the variants to the two parental copies of each chromosome, which exhibit differences in terms of single-nucleotide polymorphisms (SNPs). Since a large scale direct experimental reconstruction of the haplotypes from the collected samples is not yet cost-effective (), a computational approach—called haplotype assembly—that considers a set of reads, each one sequenced from a chromosome copy, has been proposed. Reads (also called fragments) have to be assigned to the unknown haplotypes, using a reference genome in a preliminary mapping phase, if available. This involves dealing in some way with sequencing and mapping errors and leads to a computational task that is generally modelled as an optimization problem (<ref type="bibr" target="#b17">Lancia et al., 2001;</ref><ref type="bibr" target="#b18">Lippert et al., 2002</ref>). Minimum error correction (MEC) (<ref type="bibr" target="#b18">Lippert et al., 2002</ref>) is one of the prominent combinatorial approaches for haplotype assembly. It aims at correcting the input data with the minimum number of corrections to the SNP values, such that the resulting reads can be unambiguously partitioned into two sets, each one identifying a haplotype. wMEC (<ref type="bibr" target="#b10">Greenberg et al., 2004</ref>) is the weighted variant of the problem, where each possible correction is associated with a weight that represents the confidence degree assigned to that SNP value at the corresponding position. This confidence degree is a combination of the probability that an error occurred during sequencing (phred-based error probability) for that base call and of the confidence of the read mapping to that genome position. The usage of such weights has been experimentally validated as a powerful way to improve accuracy (<ref type="bibr" target="#b25">Zhao et al., 2005</ref>). Haplotype assembly benefits from technological developments in genome sequencing. In fact, the advent of next-generation sequencing (NGS) technologies provided a cost-effective way of assembling the genome of diploid organisms. However, to assemble accurate haplotypes, it is necessary to have reads that are long enough to span several different heterozygous positions (<ref type="bibr" target="#b9">Duitama et al., 2012</ref>). This kind of data is becoming increasingly available with the advent of 'future-generation' sequencing technologies such as single molecule real-time technologies like PacBio RS II (http:// www.pacificbiosciences.com/products/) and Oxford Nanopore flow cell technologies like MinION (https://www.nanoporetech.com/). These technologies, thanks to their ability of producing single end reads longer than 10 000 bases, eliminate the need of paired-end data and have already been used for tasks like genome finishing and haplotype assembly (<ref type="bibr" target="#b24">Smith et al., 2012</ref>). Besides read length, the future-generation sequencing technologies produce fragments with novel features, such as the uniform distribution of sequencing errors, that are not properly addressed (or exploited) in most of the existing methods that, instead, are tailored to the characteristics of traditional NGS technologies. Recently, MEC and wMEC approaches have been used in the context of long reads, confirming that long fragments allow to assemble haplotypes more accurately than traditional short reads (<ref type="bibr" target="#b0">Aguiar and Istrail, 2012;</ref><ref type="bibr" target="#b9">Duitama et al., 2012;</ref><ref type="bibr" target="#b20">Patterson et al., 2014</ref><ref type="bibr" target="#b21">Patterson et al., , 2015</ref>). Since MEC is NP-hard (<ref type="bibr" target="#b6">Cilibrasi et al., 2007</ref>), exact solutions have exponential complexity. Different approaches tackling the computational hardness of the problem have been proposed in literature. Integer linear programming techniques have been recently used (<ref type="bibr" target="#b5">Chen et al., 2013</ref>), but the approach failed to optimally solve some 'difficult blocks'. There were also proposed fixedparameter tractable (FPT) algorithms that take time exponential in the number of variants per read (<ref type="bibr" target="#b2">Bonizzoni et al., 2015;</ref><ref type="bibr" target="#b11">He et al., 2010</ref><ref type="bibr" target="#b12">He et al., , 2013</ref>) and, hence, are well-suited for short reads but become unfeasible for long reads. For this kind of data, heuristic approaches have been proposed to respond to the lack of exact solutions (<ref type="bibr" target="#b1">Bansal and Bafna, 2008;</ref><ref type="bibr" target="#b9">Duitama et al., 2012</ref>). Most of the proposed heuristics, such as REFHAP (<ref type="bibr" target="#b8">Duitama et al., 2010</ref>), make use of the traditional all-heterozygous assumption, that forces the heterozygosity of all the phased positions. These heuristics have good performances but do not offer guarantees on the optimality of the returned solution (<ref type="bibr" target="#b9">Duitama et al., 2012</ref>). Two recent articles (<ref type="bibr" target="#b20">Patterson et al., 2014</ref>) aim at processing future-generation long reads by introducing algorithms exponential in the sequencing coverage, a parameter which is not expected to grow as fast as read length with the advent of future-generation technologies. The first algorithm, called PROBHAP (), is a probabilistic dynamic programming algorithm that optimizes a likelihood function generalizing the objective function of MEC. Albeit PROBHAP is significantly slower than the previous heuristics, it obtained a noticeable improvement in accuracy. The second approach, called WHATSHAP (<ref type="bibr" target="#b20">Patterson et al., 2014</ref>), is the first exact algorithm for wMEC that is able to process long reads. It was shown to be able to obtain a good accuracy on simulated data of long reads at coverages up to 20Â and to outperforms all the previous exact approaches. However, it cannot handle coverages higher than 20Â, and its performance evidently decreases when approaching that limit. In this article, we exploit a characteristic of future-generation technologies, namely the uniform distribution of sequencing errors, for introducing (Section 2) an exact FPT algorithm for a new variant, called k-cMEC, of the wMEC problem where the parameters are (i) the maximum number k of corrections that are allowed on each SNP position and (ii) the coverage. The new algorithm, called HAPCOL, is based on a characterization of feasible solutions given in<ref type="bibr" target="#b2">Bonizzoni et al. (2015)</ref>and its time complexity is Oðcov kþ1 LmÞ (albeit it is possible to prove a stricter bound), where cov is the maximum coverage, L is the read length and m is the number of SNP positions. HAPCOL is able to work without the all-heterozygous assumption. In Section 3, we experimentally compare accuracy and performance of HAPCOL on real and realistically simulated datasets with three state-of-the-art approaches for haplotype assembly—REFHAP, PROBHAP and WHATSHAP. On a real standard benchmark of long reads (<ref type="bibr" target="#b9">Duitama et al., 2012</ref>), we executed each tool under the all-heterozygous assumption, since this dataset has low coverage ($3Â on average) and since the covered positions are heterozygous with high confidence. HAPCOL turns out to be competitive with the considered methods, improving the accuracy and the number of phased positions. We also assessed accuracy and performance of HAPCOL on a large collection of realistically simulated datasets reflecting the characteristics of 'future-generation' sequencing technologies that are currently (or soon) available (coverage up to 25Â, read length from 10000 to 50 000 bases, substitution error rate up to 5% and indel rate equal to 10%) (<ref type="bibr" target="#b4">Carneiro et al., 2012;</ref><ref type="bibr" target="#b13">Jain et al., 2015;</ref><ref type="bibr" target="#b23">Roberts et al., 2013</ref>). When considering higher coverages, interesting applications such as SNP calling or heterozygous SNPs validation become feasible and reliable (<ref type="bibr" target="#b19">Nielsen et al., 2011</ref>). Since these applications require that haplotypes are reconstructed without the all-heterozygous assumption, on the simulated datasets we only considered the tools that do not rely on this assumption—WHATSHAP and HAPCOL. Results on the simulated datasets with coverage 15–20Â show that HAPCOL, while being as accurate as WHATSHAP (they achieve an average error of $2%), is faster and significantly more memory efficient ($2 times faster and $28 times less memory). The efficiency of HAPCOL allows to further improve accuracy. Indeed, the experimental results show that HAPCOL is able to process datasets with coverage 25Â on standard workstations/ small servers (whereas WHATSHAP exhausted all the available memory, 256 GB) and that, since the number of ambiguous/uncalled positions decreases, the haplotypes reconstructed by HAPCOL at coverage 25Â are $9% more accurate than those reconstructed at coverage 20Â.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preliminary definitions</head><p>Let s be a vector. Then, we denote the value of s at position t by s½t. A haplotype is a vector h of length m belonging to f0; 1g m. Let h 1 , h 2 be the two haplotypes of an individual. A position j is called heterozygous if h 1 ½ j 6 ¼ h 2 ½ j, otherwise (i.e. if h 1 ½ j ¼ h 2 ½ j) j is called homozygous. A fragment is a vector f of length m belonging to f0; 1; Àg m. In a fragment f, a position f ½j ¼ À is called a hole. A gap in a fragment f is a maximal sub-vector of f of holes, preceded and followed by a non-hole element. Moreover, the length of a fragment f is defined as the number of elements contained in f between the leftmost and rightmost non-hole elements (included). A fragment matrix is a matrix M consisting of n rows (fragments) and m columns (SNPs). We indicate as L the maximum length for all the fragments i in M. We denote by M j the jth column of M. Notice that each column of M is a vector in f0; 1; Àg n , while each row is a vector in f0; 1; Àg m. Given two row vectors s 1 and s 2 belonging to f0; 1; Àg m , s 1 and s 2 are in conflict when there exists a position j, with 1 j m, such that s 1 ½j 6 ¼ s 2 ½j and s 1 ½j; s 2 ½j 6 ¼ À, otherwise s 1 and s 2 are in agreement. A fragment matrix M is conflict free if and only if there exist two haplotypes h 1 , h 2 such that each row of M is in agreement with one of h 1 and h 2. In an equivalent way, a fragment matrix M is conflict free if and only if there exists a bipartition (P 1 , P 2 ) of the fragments in M such that each pair of fragments in P 1 is in agreement and each pair of fragments in P 2 is in agreement. A correction of the entry M j ½i, where M j ½i 6 ¼ À, is a flip of the value of M j ½i. Now we are able to introduce the MEC problem.</p><p>Problem 1. MEC (<ref type="bibr" target="#b18">Lippert et al., 2002</ref>) Input: a matrix M of fragments. Output: a conflict free matrix M 0 obtained from M with the minimum number of corrections. A column of a matrix is called homozygous if it contains values in f0; Àg or in f1; Àg, otherwise it is called heterozygous. We say that a fragment i is active on a column M j , if M j ½i ¼ 0 or M j ½i ¼ 1. The active fragments of a column M j are the set activeðM j Þ ¼ fi : M j ½i 6 ¼ Àg. The coverage of the column M j is defined as the number cov j of fragments that are active on M j , that is cov j ¼ jactiveðM j Þj. In the following, we indicate as cov the maximum coverage over all the columns in M. Given two columns M j1 and M j2 , we denote by activeðM j1 ; M j2 Þ the intersection activeðM j1 Þ \ activeðM j2 Þ. Notice that on the one hand, any heterozygous column M j encodes a bipartition of the fragments in activeðM j Þ indicating which one belongs to h 1 and which one belongs to h 2. On the other hand, any homozygous column M j does not encode a specific bipartition and, since it gives no information on how its active fragments have to be partitioned, it is 'in accordance' with any other bipartition or heterozygous column.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 1:</head><p>Two columns M j1 ; M j2 of a fragment matrix M are in accordance if (1) at least one of M j1 ; M j2 is homozygous or (2) M j1 ; M j2 are both heterozygous and on activeðM j1 ; M j2 Þ they are identical or complementary.</p><p>The correction distance between two columns M j1 ; M j2 evaluates the minimum number of corrections needed to transform M j1 and M j2 into heterozygous columns in accordance and it is defined as dðM j1 ; M j2 Þ ¼ minfjEj; jEjg, where E ¼ fi : M j1 ½i 6 ¼ M j2 ½i^ M j1 ½i 6 ¼ À ^ M j2 ½i 6 ¼ Àg and E ¼ fi : M j1 ½i ¼ M j2 ½i ^ M j1 ½i 6 ¼ À ^ M j2 ½i 6 ¼ Àg. Given a column M j of a fragment matrix M, we define the homozygous distance HðM j Þ as the number of times the minor allele (i.e. the least frequent value of the column) appears in M j if it is not greater than an integer k, or infinity otherwise. More formally, HðM j Þ is equal to dðM j ; 0Þ if dðM j ; 0Þ k (notice that dðM j ; 1Þ ¼ dðM j ; 0Þ, where 0 and 1 are the columns composed only of zeros and ones, respectively) or to 1 otherwise. Homozygous columns cannot induce a conflict due to the fact that the corresponding positions in the two reconstructed haplotypes can be homozygous with no influence on the other positions. For this reason, we can remove every homozygous column from any input fragment matrix M without changing the optimal solution and we can assume that M is only composed of heterozygous columns. However, notice that a heterozygous column M j in the input can be transformed into a homozygous column M 0 j in the output. As a consequence, the optimal solution M 0 can potentially contain homozygous columns. Furthermore, given a conflict free matrix M 0 , notice that the two resulting haplotypes h 1 , h 2 can be easily computed from the bipartition of the fragments induced by the columns of M 0. In the weighted variant wMEC of MEC, there is a weight wðM j ½iÞ associated with each non-hole entry M j ½i of the input matrix M that represents the cost of correcting that entry. In this case, the goal is to minimize the total weight instead of the number of corrections. Each gap in any fragment of the input matrix M can be modeled as zero-weight entries equal to 0 or 1. For this reason, even though we propose an approach that considers fragment matrices without gaps, called gapless fragment matrices, the approach can be easily extended to deal with any general fragment matrix M. Lemma 1 (<ref type="bibr" target="#b2">Bonizzoni et al., 2015</ref>) proves a property of these matrices that will be fundamental for our FPT algorithm.</p><formula>LEMMA 1:</formula><p>Consider a gapless fragment matrix M. Then, M is conflict free if and only if each pair of columns is in accordance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">The k-constrained MEC problem</head><p>In this work, we introduce a variant of the MEC problem, called k-cMEC, motivated by the uniform distribution of sequencing errors of future-generation technologies, where the number of errors (hence, corrections) per column are bounded by an integer k. Given an input fragment matrix M, a conflict free fragment matrix M 0 obtained from M with h corrections is defined as a k-corrected matrix for M if for each column M j we have dðM j ; M 0 j Þ k. According to this definition we introduce the following variant of MEC:</p><p>Problem 2. k-constrained MEC (k-cMEC) Input: a fragment matrix M and an integer k. Output: a k-corrected matrix M 0 for M obtained with the minimum number of corrections.</p><p>Given a k-corrected matrix M 0 for a fragment matrix M, we can see each heterozygous column M 0 j in M 0 as the correction of the corresponding column M j in M. Hence, considering a column M j , we define a k-correction B j for M j as a vector in f0; 1; Àg n with activeðB j Þ ¼ activeðM j Þ such that dðM j ; B j Þ k and B j is heterozygous. According to this definition, a k-correction B j describes a feasible way to transform M j into the heterozygous column M 0 j when dðM 0 j ; B j Þ ¼ 0. Therefore, we define the space of these corrections as b j , such that b j is the set containing all the possible k-corrections B j for the column M j. Notice that 0 and 1 can be imagined as the corrections for any homozygous column in M 0. The weighted variant of this problem can be easily defined in the same way as wMEC for MEC. The goal of the weighted version is to compute a k-corrected matrix M 0 obtained from M with minimum total weight. Consider a fragment matrix M. There always exists a feasible solution for the MEC problem on input M, while a feasible solution for the k-cMEC problem, for a fixed k, on input M may not exist. This implies that a feasible solution for the MEC problem on input M may not be a feasible solution for the k-cMEC problem. Hence, an optimal solution for the k-cMEC problem is not necessarily an optimal solution for the MEC problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Algorithm</head><p>In this section, we present an FPT algorithm for solving the k-cMEC problem, when parameterized by the maximum number k of corrections that are allowed in each column and by the coverage cov. The algorithm is based on an exact dynamic programming approach. After presenting the basic dynamic programming equation for the gapless case, we show that the approach can be easily adapted to manage gaps and, possibly, the all-heterozygous assumption. Informally, the algorithm iteratively computes, for all j from 1 to m, a k-corrected matrix M 0 on the first j columns M 1 ;. .. ; M j of the input matrix M by considering all the possible corrections M 0 j for the last column M j such that dðM j ; M 0 j Þ k and choosing the best option. The corrected column M 0 j can be either homozygous or heterozygous. If it is homozygous, we pay a cost equal to the homozygous distance HðM j Þ of M j but then M 0 j is in accordance with any other column and no other check must be performed. If M 0 j is heterozygous, then we consider all the possible k-corrections B j for M j in b j and for each one two different cases may arise: (i) there exists a column M q with q &lt; j that 'shares' some fragments with M j and that in the optimal solution M 0 q is heterozygous (clearly, q ! j À L) or (ii) all the previous columns that share some fragments with M j are homozygous in the optimal solution M 0. In the first case, M 0 q and M 0 j must be either identical or complementary on the shared fragments (Lemma 1). It follows that we have to choose the best option among all the k-corrections B q such that dðB q ; B j Þ ¼ 0 and we pay a cost equal to that of the correction B j (i.e. dðM j ; B j Þ) plus the cost of transforming the columns between M q and M j into homozygous columns (i.e. their homozygous distance). In the second case, all the columns to the left of M j that share some fragment with M j are homozygous in the optimal solution M 0 (and we pay a total cost equal to their homozygous distance). As a consequence, any k-correction B j of M j is in accordance with them and we pay a cost equal to dðM j ; B j Þ. More formally, let M be a fragment matrix and B j be a k-correction for M j , we define D½j; B j  as the minimum number of corrections needed to obtain a k-corrected matrix M 0 for M on columns M 1 ;. .. ; M j such that M 0 j is heterozygous and dðM 0 j ; B j Þ ¼ 0. Moreover, we define OPT½j as the minimum number of corrections needed to obtain a k-corrected M 0 for M on columns M 1 ;. .. ; M j. Finally, we define M Lj (M Rj , respectively) as the rightmost (leftmost, respectively) column to the left (right, respectively) of M j such that activeðM Lj ; M j Þ ¼ / (activeðM Rj ; M j Þ ¼ /, respectively); if it does not exist, M Lj (M Rj , respectively) corresponds to an empty column in position 0 (m þ 1, respectively). Note that j À L j L and R j À j L.</p><p>Without loss of generality, we implicitly assume that there exists a dummy empty column M 0 in position 0 of the input M. Thus, we can define OPT½0 ¼ 0 and D½0; Á ¼ 0. For 0 &lt; j m; D½ j; B j  and OPT½ j can be computed as follows:</p><p>D½ j; B j  ¼ min min q : Lj þ 1 q j À 1; Bq : dðBj; BqÞ ¼ 0 D½q; B q  þ dðM j ; B j Þ þ</p><formula>X jÀ1 y ¼ qþ1 HðM y Þ OPT½L j  þ dðM j ; B j Þ þ X jÀ1 y ¼ Ljþ1 HðM y Þ 8 &gt; &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; &gt; :</formula><formula>(1)</formula><p>OPT½ j ¼ min OPT½j À 1 þ HðM j Þ ==M j is homozygous min 8Bj D½j; B j  ==M j is heterozygous (</p><formula>(2)</formula><p>The optimum cost is given by OPT½m and a corresponding optimal solution M 0 can be reconstructed by backtracking. The formal proof of correctness along with some technical details about the backtracking procedure are in the Supplementary Material. The algorithm can be easily adapted to the weighted version of k-cMEC. In this case, each non-hole element M j ½i of the input matrix M has a weight wðM j ½iÞ. Given a column M j and any k-correction B j in b j , the key idea is to consider the weight wðM j ; B j Þ as the minimum sum of the weights to transform M j in M 0 j such that dðM 0 j ; B j Þ ¼ 0 and to consider the weight w H ðM j Þ as the minimum sum of weights to transform M j into a homozygous column. Hence, we want to minimize the sum of such weights by replacing dðM j ; B j Þ with wðM j ; B j Þ and HðM j Þ with w H ðM j Þ in the recursive equations. Assume to consider a general fragment matrix M that may contain gaps. As explained before, any gap can be modeled as zeroweight elements. Since each of these elements can be equal to 0 or 1 with a cost of 0, we can adapt the algorithm such that for each column all the combinations of values for its gaps will be considered. It follows that any k-correction B j for a column M j is extended with any combination of values for its gaps and added to b j. Furthermore, the algorithm can be slightly modified to find a solution under the all-heterozygous assumption that forces to reconstruct two complementary haplotypes. In this case, the homozygous columns, both in the input and in the output, have to be considered as 'special' heterozygous columns that place all the covered fragments in the same part of the fragments bipartition. Hence, we remove from the recursive equation the possibility to transform each column M j into a homozygous column and we add to b j the k-correction B j that transforms. Let M be a gapless fragment matrix. Given two columns M j1 and M j2 , and a k-correction B j1 for M j1 , we define p j2 ðB j1 Þ as the vector of size jactiveðM j1 ; M j2 Þj that is obtained from B j1 by keeping only elements that correspond to fragments that are in activeðM j1 ; M j2 Þ. We define the intermediate projection table for each column M j , for each q in fL j þ 1;. .. ; j À 1g and for each vector C representing a possible correction of the positions in activeðM j ; M q Þ, as follows:</p><p>~ D½q; j; C ¼ min 8Bq2b q :dðC;pjðBqÞÞ¼0 D½q; B q :</p><formula>(3)</formula><p>Entry ~ D½q; j; p j ðB q Þ (and ~ D½q; j; p j ðB q Þ, where p j ðB q Þ is the complement of p j ðB q Þ) can be filled in OðcovÞ time [needed to compute p j ðB q Þ] while computing D½q; B q  and, consequently, the asymptotic overall time complexity does not change. Intuitively, ~ D½q; j; C corresponds to the minimum number of corrections to obtain a k-corrected matrix M 0 for M on the first q columns such that M 0 q is heterozygous and dðC; p j ðM 0 q ÞÞ ¼ 0. As a consequence, Equation</p><p>(1) can be equivalently rewritten as:</p><formula>D½j; B j  ¼ min ~ D½q; j; p q ðB j Þ þ dðM j ; B j Þ þ X jÀ1 y¼qþ1 HðM y Þ OPT½L j  þ dðM j ; B j Þ þ X jÀ1 y¼Ljþ1 HðM y Þ 8 &gt; &gt; &gt; &gt; &gt; &gt; &lt; &gt; &gt; &gt; &gt; &gt; &gt; : (4)</formula><p>In other words, with this recurrence, each entry D½j; B j  is computed using the entries ~ D½Á; j; Á and, at the same time, it is used to update the entries</p><formula>Á m Á P k s¼0 cov s Þ</formula><p>space, since for any column M j we only consider all the values q in fL j þ 1;. .. ; j À 1g and j À L j L. Therefore, since the algorithm iteratively proceeds column wise, when it is at the step corresponding to the column M j , we just need to consider the entries ~ D½y; Á; Á for all the columns M y with j y R j. For this reason, we just need</p><formula>OðL Á L Á P k s¼0 cov s Þ</formula><p>space to store that window of the projection table. Furthermore, if we consider a general fragment matrix M modelling the gaps as zero-weight elements (using the approach described before), the number of k-corrections B j in b j for a column</p><formula>M j increases to 2 g Á P k s¼0 cov s</formula><p>, where g is the maximum number of gaps in a column (hence 2 g is the number of all the combinations of values for gap elements). As a consequence, the overall time complexity becomesÞ space, respectively.</p><formula>Oð2 g Á P k s¼0 cov s Á cov Á L Á mÞ and it takes Oð2 g Á L Á L Á P k s¼0 cov s Þ space.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Implementation</head><p>A prototypical implementation of HAPCOL is available under the terms of the GPL at http://hapcol.algolab.eu/. Since coverage varies across columns, HAPCOL adaptively adopts a different maximum number k j of corrections for each column M j computed as the smallest integer such that the probability that M j contains more than k j errors is at most a, with a given as input. Such a probability is computed assuming that sequencing errors are uniformly distributed with a substitution error rate (given as input), an assumption which reflects the characteristics of future-generation sequencing technologies. Therefore, the two parameters given in input to HAPCOL are and a and can be chosen by the user depending on the estimated sequencing (substitution) error rate and on the user's preference towards better performances (larger a) or increased probability of finding a feasible solution (smaller a). The strategy currently implemented for choosing the maximum number of corrections per column assumes that errors are uniformly distributed. However, it can be easily modified to process datasets produced by technologies with different error profiles (even those with systematic errors, especially if the average error rate is low, such as current Illumina technologies) and/or to automatically increase the values k j until a feasible solution exists.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The NA12878 dataset</head><p>The real dataset (called 'NA12878 dataset') is the one produced using a fosmid-based technology from the HapMap sample NA12878 by<ref type="bibr" target="#b9">Duitama et al. (2012)</ref>. This dataset is considered a standard benchmark for comparing haplotyping algorithms on long reads, since the haplotypes of individual NA12878 were independently and confidently reconstructed using the sequenced genomes of the individual and of her parents. The dataset is composed of 271 184 reads with average length of $40 kb and with average coverage of $3Â. The reference haplotypes are the trio-phased variant calls from the GATK resource bundle (<ref type="bibr" target="#b7">DePristo et al., 2011</ref>), filtered on the 1 252 769 positions that are also covered by the fragments of the NA12878 dataset. HAPCOL, REFHAP, PROBHAP and WHATSHAP have been executed independently on each chromosome. HAPCOL and WHATSHAP can be executed with or without the all-heterozygous assumption without affecting the exponential part of their time/space complexities. In this case, these two tools have been executed using the allheterozygous assumption, since the positions covered by the dataset are heterozygous with high confidence and since the comparison between solutions obtained with different assumptions may lead to misleadingresults.Moreover, HAPCOL has been executed with e ¼ 5% and a ¼ 10 À3 and, for this choice of the parameters, a feasible solution existed for each chromosome.<ref type="figure" target="#tab_1">Table 1</ref>reports, for each tool, the overall error rate and the percentage of phased positions over all the phasable positions, the total running time and the peak of memory for the whole dataset (i.e. for all the chromosomes). On this dataset, HAPCOL reconstructed the most accurate haplotypes and phased the largest number of positions compared with the other tools. In particular, HAPCOL improves the accuracy obtained by WHATSHAP, PROBHAP and REFHAP by around 6%, 43% and 48%, respectively. Furthermore, HAPCOL is also the tool which phases the largest number of positions. In fact, HAPCOL phases 0.15% more positions than WHATSHAP, 2.03% more than PROBHAP and 2.18% more than REFHAP. To the contrary, REFHAP was the fastest and most memoryefficient tool among the four considered. This was expected, as REFHAP is a heuristic-based method, while the other ones are exact (albeit they minimize different objective functions). Overall, all the tools can be run with modest/medium computing resources. Indeed, each one analyzed the dataset in less than 25 min and using less than 24 GB of memory. However, while HAPCOL and WHATSHAP concluded in a few minutes, PROBHAP was significantly slower than the others ($20 min) and, possibly, it could not be able to scale to datasets with higher coverage. HAPCOL and WHATSHAP required significantly more memory than PROBHAP and REFHAP (4 times and 44 times, respectively). However, such a peak of memory usage is due to a small number of consecutive positions on chromosomes 2, 3 and 10 where coverage is high (up to 30Â), but most of values are gaps (all but 2-4 non-gap alleles on average). In these regions, the performances of HAPCOL and WHATSHAP degrade since both approaches model the gaps as zero-weight elements and must essentially 'guess' the alleles at those positions. Clearly, in this case, phase prediction is not reliable and a simple pre-filtering step can easily find (and possibly remove) such positions from further analyses. If we exclude chromosomes 2, 3 and 10, then WHATSHAP becomes the fastest tool (30 s), followed by REFHAP (35 s), by HAPCOL (60 s) and by PROBHAP that remains the slowest tool (956 s). In terms of memory usage, HAPCOL turns out to be the most memory-efficient method (0.06 GB), followed by WHATSHAP (0.16 GB), by PROBHAP (0.48 GB) and by REFHAP (0.54 GB).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Simulated datasets</head><p>We used simulated datasets to assess how accuracy and performances change while the characteristics of the dataset (coverage, especially) vary. As motivated before, in this part we focused on the tools that can work also without the all-heterozygous assumption, namely HAPCOL and WHATSHAP. The simulation of the datasets has been performed as in<ref type="bibr" target="#b21">Patterson et al. (2015)</ref>. The dataset consists of a ground truth, which was assembled by inserting all known variants of chromosomes 1 and 15 of J. Craig Venter's genome into theAccuracy is given in terms of phasing error ('error') and total phased positions ('phased') of the reconstructed haplotypes, while performances are given in terms of total running time ('time') expressed in seconds and the peak memory usage ('mem.') expressed in GB. Best results for each column are highlighted in boldface.The simulated instances have coverage ('cov') 15Â and 20Â, substitution error rate ('e') 1% and 5% and indel error rate fixed to 10%. The metrics considered are the number of instances with feasible solutions ('feas.'), the average phasing error ('error') of the reconstructed haplotypes, the average running time ('time') and the average maximum used memory ('mem.'). HAPCOL has been executed with two different combinations of and a: 5% / 10 À2 and 5% / 10 À3. human reference genome (hg18), mapped simulated long reads of lengths 1000, 5000, 10 000 and 50 000 bases with varying uniform substitution rates 1% and 5% and with a uniform indel distribution of 10% at 30Â coverage. These rates reflect the characteristics of the long read data generated by the future-generation sequencing technologies (<ref type="bibr" target="#b4">Carneiro et al., 2012;</ref><ref type="bibr" target="#b13">Jain et al., 2015;</ref><ref type="bibr" target="#b23">Roberts et al., 2013</ref>). From each set of simulated reads, five datasets were obtained by randomly extracting a maximal subset with (maximum) coverage of 15Â, 20Â and 25Â. HAPCOL has been executed with two combinations of its input parameters—namely e ¼ 5% with a ¼ 10 À2 , and e ¼ 5% with a ¼ 10 À3 —to assess the behavior of HAPCOL depending on the choice of the parameters. We remark that some fragment matrices could not admit a feasible solution for the k-cMEC problem with some choices of parameter k (depending on and a in the implementation), while the same instances have always a feasible solution for the (unconstrained) MEC problem. Both tools have been executed on all the instances, but HAPCOL terminated on some of them because no feasible solution existed for that choice of the input parameters. WHATSHAP, which should be able to find a feasible solution for all the instances, computed a solution only for the instances with coverage 15Â and 20Â, while, as expected (<ref type="bibr" target="#b21">Patterson et al., 2015</ref>), it was not able to successfully conclude the execution on the instances with coverage 25Â since it exhausted the available memory (256 GB).<ref type="figure" target="#tab_2">Table 2</ref>reports, for any combination of input parameters and a, the number of instances with a feasible solution (column 'feas.'), the average error of the reconstructed haplotypes, the average running time and the average memory usage over all the instances of a given chromosome (Venter chromosome 1 and chromosome 15), coverage (15Â and 20Â) and substitution error rate e (1% and 5%) (the indel error rate is fixed to 10%, thus is not reported). The results presented in the table refer only to the subset of instances which have a feasible solution for the k-cMEC problem and are averaged over the read lengths. Since WHATSHAP was not able to successfully terminate on any instance with coverage 25Â, the results on that subset of instances are separately reported (only for HAPCOL) on<ref type="figure">Table 3</ref>. First, as expected, the number of instances with a feasible solution increases as the combination of parameters and a allows more corrections per column. Indeed, for e ¼ 5% and a ¼ 10 À2 , the maximum numbers of corrections per column (not shown) are quite low and, as a consequence, a feasible solution does not exists for many instances, especially for those with high substitution error rates e. For the other combination of parameters (namely, e ¼ 5% and a ¼ 10 À3 ), the number of instances with a feasible solution rapidly increases. This trend, albeit less evident for chromosome 15, is clear for chromosome 1. Noticeably, when e ¼ 5% and a ¼ 10 À3 , a feasible solution exists for all but three instances with coverage at most 20Â. In terms of accuracy of the reconstructed haplotypes, on all the instances, HAPCOL obtained the same phasing error rate of WHATSHAP, which, in turn, was shown to be competitive with other state-of-the-art approaches (<ref type="bibr" target="#b21">Patterson et al., 2015</ref>). This observation supports the validity of the newly introduced k-cMEC problem as a computational model for haplotype assembly on long reads. Albeit HAPCOL and WHATSHAP achieve the same accuracy, in terms of performances HAPCOL is both faster and significantly more memory-efficient than WHATSHAP. In particular, on average, HAPCOL is at least twice faster than WHATSHAP when the coverage is 20Â even for the largest values of maximum number k j of corrections per column (i.e. when e ¼ 5% and a ¼ 10 À3 ). Moreover, with the same parameters and with read length of 10 000 bases (a typical average read length in the foreseeable future), HAPCOL is almost three times faster than WHATSHAP, allowing to process a single dataset in less than 11 min (on average). Concerning memory usage, we observe the same general trend, except that differences are even more evident. In fact, the average memory usage of WHATSHAP on chromosome 1 (the largest one) at coverage 20Â is $138 GB, while HAPCOL requires only $5 GB. Moreover, on instances with read length at most 50 000 bases, WHATSHAP requires up to 164 GB, while HAPCOL never requires more than 10 GB. As a consequence, with HAPCOL, the analysis of a genome-wide dataset at coverage 20Â is feasible even on a standard workstation/small server. As noticed before, three instances do not admit a feasible solution with e ¼ 5% and a ¼ 10 À3. However, by setting e ¼ 5% and a ¼ 10 À4 , a feasible solution exists also for these instances and the error rate of the solution obtained by HAPCOL is equal to that obtained by WHATSHAP. In terms of performance, HAPCOL is slower than WHATSHAP on the single instance with coverage 15Â and it has a similar running time of WHATSHAP on the two instances with coverage 20Â ($21 min, on average). Noticeably, the amount of memory required by HAPCOL on these two instances ($9 GB, on average) is $15 times lower than that required by WHATSHAP ($143 GB, on average), a further confirmation of the memoryefficiency of HAPCOL even when more corrections per columns are allowed. Furthermore, these results confirm that a simple strategy that progressively increases the number of corrections allowed in each column until a solution is found would be practicable, since it always leads to a solution while keeping the memory usage as low as possible. A comparison between HAPCOL and WHATSHAP is not possible on instances with coverage 25Â, since WHATSHAP was not able to solve these instances within the available amount of memory. Hence, we evaluated how accuracy and performances of HAPCOL vary between instances with coverage 20Â and 25Â (<ref type="figure">Table 3</ref>). For space constraints, we report the results only for e ¼ 5% and a ¼ 10 À3 , that is for the parameters for which the maximum number of instances has a feasible solution. Moreover, to not discard the effect of read lengths, we focused only on instances with read length50 000 bases. Such a read length has been chosen since almost all these instances have a feasible solution for both coverage 20Â and 25Â. We observe that increasing coverage from 20Â to 25Â allows to improve accuracy ($9%) of the reconstructed haplotypes (as we already observed for coverage 15Â and 20Â). Moreover, the increased accuracy is mainly due to a significant reduction (approximately À10% on average, data not shown for space constraints) of the number of ambiguous positions, leading to an increased number of phased SNP positions. Concerning performances, instances with coverage 25Â can be still analyzed with modest computing equipments; indeed HAPCOL completed the tests on chromosome 1 in &lt;73 min and using less than 40 GB of main memory.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>ÞÁ</head><figDesc>(Knuth, 2005, see Alg. T, chapter 7.2.1.3) and, using the same ideas, it is possible to compute the ith element (for any arbitrary i) of this order in time O(k). In a direct implementation of the recurrence equations,; j À 1g) in time OðcovÞ each (for computing dðB j ; B q Þ, since cov j ; cov q cov). Therefore, since OPT½j can be updated in constant time during the computation of the entries Accurate and memory-efficient haplotype assemblyD½j; B j , we have that the overall time complexity of the simple imcov Á LÁ mÞ by computing an intermediate projection table and applying an approach inspired by the one presented in Patterson et al. (2014)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>Notice that Oðcov kþ1 Á L Á mÞ is a more intuitive, but less tight, bound. Concerning space complexity and according to Equation (4), the intermediate projection table ~ D½Á; Á; Á can be stored instead of table D½Á; Á. This takes OðL</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>As shown in the Supplementary Material, for the backtracking phase we need two tables requiring O(m) and Oðm Á P k s¼0 cov s</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. Comparison of four haplotyping tools on the NA12878 real dataset</figDesc><table>Tool 
Error (%) 
Phased (%) 
Time (s) 
Mem. (GB) 

HAPCOL 
1.91 
99.88 
332 
2.1 
WHATSHAP 
2.02 
99.73 
172 
23.9 
PROBHAP 
3.36 
98.02 
1205 
0.6 
REFHAP 
3.68 
97.75 
43 
0.5 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 2. Comparison of HAPCOL (hc) and WHATSHAP (wh) on realistically simulated instances.</figDesc><table>Chromosome 15 
Chromosome 1 

Feas. 
Error (%) 
Time (s) 
Mem. (GB) 
Feas. 
Error (%) 
Time (s) 
Mem. (GB) 
/a 
cov 
e 
Á/20 
wh 
hc 
wh 
hc 
wh 
hc 
Á/20 
wh 
hc 
wh 
hc 
wh 
hc 

5% = 10 À2 
15Â 
1 
17 
2.26 
2.24 
18 
6 
1.7 
0.1 
15 
2.40 
2.40 
47 
17 
4.5 
0.3 
5 
20 
1.98 
1.98 
19 
6 
1.8 
0.1 
8 
2.42 
2.44 
46 
17 
4.4 
0.3 
20Â 
1 
18 
1.77 
1.76 
487 
53 
52.9 
0.6 
7 
1.84 
1.84 
1241 
155 
129.2 
2.0 
5 
18 
1.76 
1.76 
490 
48 
52.7 
0.6 
4 
2.07 
2.08 
1249 
132 
129.0 
1.6 

5% = 10 À3 
15Â 
1 
20 
2.12 
2.11 
19 
25 
1.8 
0.3 
20 
2.35 
2.36 
48 
64 
4.6 
0.8 
5 
20 
1.98 
1.98 
19 
22 
1.8 
0.3 
19 
2.35 
2.35 
49 
56 
4.7 
0.7 
20Â 
1 
20 
1.82 
1.81 
485 
218 
52.8 
2.2 
19 
1.95 
1.94 
1306 
586 
138.0 
5.6 
5 
20 
1.67 
1.67 
497 
200 
53.6 
2.0 
19 
2.07 
2.08 
1347 
526 
138.5 
5.1 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 3. Comparison between instances with coverage 20x and 25Â for HAPCOL.</figDesc><table>Chromosome 15 
Chromosome 1 

Feas. 
Error 
Time 
Mem. 
Feas. 
Error 
Time 
Mem. 
e 
cov 
Á/5 
(%) 
(s) 
(GB) 
Á/5 
(%) 
(s) 
(GB) 

1 
2 0 Â 
5 
1.40 
311 
3.8 
5 
1.66 
832 
9.5 
25 Â 
5 
1.25 
1457 
16.1 
4 
1.52 
4272 
40.7 

5 
2 0 Â 
5 
1.24 
277 
3.3 
5 
1.71 
737 
8.5 
25 Â 
5 
1.14 
1466 
15.2 
4 
1.55 
4357 
39.2 </table></figure>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> Results and discussion We experimentally compared accuracy and performance of HAPCOL with those of state-of-the-art haplotype assembly approaches on both real (Section 3.1) and simulated datasets (Section 3.2). The experimental comparison on the real long read dataset is focused on evaluating the accuracy of the tools under the all-heterozygous assumption since such a standard benchmark dataset has low average coverage ($3Â) and contains only heterozygous SNP positions. We also assessed accuracy and performances of the tools while varying coverage, read length and sequencing/indel error rate on simulated long read datasets with characteristics similar to those of the &apos;futuregeneration&apos; sequencing technologies that are currently (or soon) available (coverage up to 25Â, read length up to 50 000 bases, substitution error rate up to 5% and indel rate equal to 10%) (Carneiro et al., 2012; Jain et al., 2015; Roberts et al., 2013). We compared HAPCOL with three state-of-the-art haplotyping tools specifically designed for handling long reads, namely, REFHAP, which was shown to be one of the most accurate heuristic methods (Duitama et al., 2012), PROBHAP, a recent probabilistic method which has been shown to be sensibly more accurate than REFHAP (Kuleshov, 2014) and WHATSHAP, the first exact approach for the weighted MEC problem specifically designed for long reads (Patterson et al., 2014, 2015). At higher coverages, applications such as SNP calling or validating which SNPs are really heterozygous in the given sample (e.g. there could be a significant portion of positions that, due to sequencing errors, appears to be heterozygous, but that should be predicted as homozygous) become feasible and reliable (Nielsen et al., 2011). However, since these applications require that haplotypes are reconstructed without the all-heterozygous assumption, on the simulated datasets we only considered WHATSHAP and HAPCOL as they do not rely on this assumption. The analyses focused on the accuracy of the reconstructed haplotypes and on the performances of the tools. Accuracy of the reconstructed haplotypes has been evaluated in terms of (switch) error rate (Browning and Browning, 2011) (i.e. the number of inconsistencies over contiguous phased variants) and in terms of phased positions (i.e. the number of positions for which the tool gave a phase prediction over the total number of positions that can be phased using the fragments given as input). Performances of the tools have been evaluated in terms of running time and peak memory usage, as reported by the Unix utility time. All the tests have been performed on a server equipped with four Intel Xeon E5-4610v2 CPUs and 256 GB of RAM.</note>

			<note place="foot">Y.Pirola et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="4"> Conclusion We have proposed an exact algorithm, called HAPCOL, for the weighted k-cMEC, a new variant of the wMEC problem that takes into account the main characteristics of future-generation sequencing technologies, namely the uniform distribution of sequencing errors and the increasing length of sequenced reads. We showed that the haplotypes computed by HAPCOL on a real benchmark dataset are at least as accurate as those computed by current state-of-the-art approaches. This result supports the validity of the additional constraints imposed by the k-cMEC problem. Furthermore, HAPCOL is able to overcome the traditional all-heterozygous assumption and to process datasets with coverage 25Â on standard workstations/small servers, while the current state-of-theart methods either rely on this assumption or become unfeasible on coverages over 20Â. Thanks to these results, HAPCOL is potentially able to directly perform SNP calling or heterozygous SNPs validation that become feasible and reliable on coverage up to 25Â. HAPCOL has been specifically designed to exploit the uniform distribution of errors that characterizes &apos;future-generation&apos; sequencing technologies, but it can be successfully applied on sequencing data with a different error distribution by choosing the maximum number k of errors per position according to the error model. Furthermore, HAPCOL can be easily extended to adaptively increase the value of k (on certain columns) until a feasible solution exists. This strategy allows to process datasets affected by systematic sequencing errors without a great impact on the performance if the average error rate is low (such as in the current Illumina sequencing technologies). An interesting future direction would be the extension of the k-cMEC problem to deal with individuals related by structures such as trios or pedigrees (Browning and Browning, 2011). Indeed, the Mendelian laws of inheritance induce further constraints that may improve the accuracy of the reconstructed haplotypes, as shown for example by Pirola et al. (2012).</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">HapCompass: a fast cycle basis algorithm for accurate haplotype assembly of sequence data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Aguiar</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Istrail</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="577" to="590" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">HapCUT: an efficient and accurate algorithm for the haplotype assembly problem</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bansal</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bafna</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="153" to="159" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">On the fixed parameter tractability and approximability of the minimum error correction problem</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Bonizzoni</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>Ferdinando,C. et al.</editor>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<biblScope unit="volume">9133</biblScope>
			<biblScope unit="page" from="100" to="113" />
			<date type="published" when="2015" />
			<publisher>Springer International Publishing</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Haplotype phasing: existing methods and new developments</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Browning</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Browning</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="703" to="714" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Pacific biosciences sequencing technology for genotyping and variation discovery in human data</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Carneiro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genomics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">375</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Exact algorithms for haplotype assembly from wholegenome sequence data</title>
		<author>
			<persName>
				<forename type="first">Z.-Z</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1938" to="1945" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">The complexity of the single individual SNP haplotyping problem</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Cilibrasi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="13" to="36" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">A framework for variation discovery and genotyping using next-generation DNA sequencing data</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Depristo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="491" to="498" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<monogr>
		<title level="m" type="main">ReFHap: a reliable and fast algorithm for single individual haplotyping</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Duitama</surname>
			</persName>
		</author>
		<editor>Li,L. et al.</editor>
		<imprint>
			<date type="published" when="2010" />
			<publisher>ACM</publisher>
			<biblScope unit="page" from="160" to="169" />
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Fosmid-based whole genome haplotyping of a HapMap trio child: evaluation of single individual haplotyping techniques</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Duitama</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="2041" to="2053" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Opportunities for combinatorial optimization in computational biology</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Greenberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">INFORMS J. Comput</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="211" to="231" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Optimal algorithms for haplotype assembly from wholegenome sequence data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>He</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="183" to="190" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Hap-seq: an optimal algorithm for haplotype phasing with imputation using sequencing data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>He</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="80" to="92" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Improved data analysis for the minion nanopore sequencer</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Jain</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="351" to="356" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<monogr>
		<title level="m" type="main">The Art of Computer Programming</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">E</forename>
				<surname>Knuth</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>New York City, New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Probabilistic single-individual haplotyping</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Kuleshov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="379" to="385" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Whole-genome haplotyping using long reads and statistical methods</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Kuleshov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="261" to="266" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">SNPs problems, complexity, and algorithms</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Lancia</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>auf der Heide,F.M.</editor>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">2161</biblScope>
			<biblScope unit="page" from="182" to="193" />
			<date type="published" when="2001" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Algorithmic strategies for the single nucleotide polymorphism haplotype assembly problem</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Lippert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="23" to="31" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Genotype and SNP calling from next-generation sequencing data</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Nielsen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="443" to="451" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">WhatsHap: haplotype assembly for future-generation sequencing reads</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Patterson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<editor>Roded,S.</editor>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<biblScope unit="volume">8394</biblScope>
			<biblScope unit="page" from="237" to="249" />
			<date type="published" when="2014" />
			<publisher>Springer International Publishing</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">WhatsHap: weighted haplotype assembly for future-generation sequencing reads</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Patterson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="498" to="509" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">An efficient algorithm for haplotype inference on pedigrees with recombinations and mutations</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Pirola</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="12" to="25" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">The advantages of SMRT sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">J</forename>
				<surname>Roberts</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">405</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Validation of ITD mutations in FLT3 as a therapeutic target in human acute myeloid leukaemia</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">C</forename>
				<surname>Smith</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">485</biblScope>
			<biblScope unit="page" from="260" to="263" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Haplotype assembly from aligned weighted SNP fragments</title>
		<author>
			<persName>
				<forename type="first">Y.-Y</forename>
				<surname>Zhao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Biol. Chem</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="281" to="287" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>