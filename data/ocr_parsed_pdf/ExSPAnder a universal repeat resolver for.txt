BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

A.D.Prjibelski et al.

 

(a) 100000 (b) 10000
g g 1000
(U {B
e 2
§ 10000 E’ 100
d) a)
.c: g
s E
2 z3 10
1000 17 7
200 300 400 0 4000 8000 12000

Observed insert size. bp Observed insert size, bp

z-\
0
~_z

1e+06 (d) 100000

100000 10000
1 000
10000
1 00

Number 01 reads
Number 01 reads

1000 10

100100 200 300 1 o 2000 4000
Observed insert size, bp Observed insert size, bp
Fig. 1. Plots of the insert size distributions for Bfaeeium isolate
(a) paired-end and (b) jumping library, and S.aureus single-cell dataset
with (c) paired-end and (d) jumping library. The distributions were com-
puted by mapping reads to the Bfaeeium str. DSM4810 (Lapidus et al.,
2009) and S. aureus str. USA300 substr. FPR3757 (Diep et al., 2006)
reference genomes, respectively. All plots are in the logarithmic scale

[implemented as a part of SPAdes (Bankevich et al., 2012)] im—
proves on existing assemblers on standard bacterial datasets and
outperforms such popular assemblers as ABySS (Simpson et al.,
2009), Ray (Boisvert et al., 2010), SOAPdenovo (Li et al., 2010)
and Velvet (Zerbino and Birney, 2008). ALLPATHS—LG
(Gnerre et al., 2011) is an excellent assembler whose applications,
however, are limited to specially constructed read—pair libraries.
On such libraries EXSPANDER and ALLPATHS—LG generate
comparable results (EXSPANDER generates longer contigs but
ALLPATHS—LG generates longer scaffolds).

2 ANALYSIS OF READ-PAIR LIBRARIES

As we mentioned in the introduction, jumping libraries present
additional challenges for genome assembly owing to their high
variations in the insert size. Additionally, jumping libraries have
high rate of chimeric read—pairsiread—pairs that either have ab—
normal insert size or incorrect orientation. Chimeric read—pairs
further complicate utilization of such libraries while resolving
repeats.

Below we present analysis of the insert size distributions for
the following data: Brachybacteriumfaecium isolate dataset (read
length 150 bp) and Staphylococcus aureus single—cell dataset (read
length 101 bp). Both datasets contain one paired—end and one
jumping library. To analyze read—pair libraries we aligned reads
to the Bfaecium and S.aureus reference genomes using Bowtie 2
(Langmead and Salzberg, 2012) and computed the chimeric read—
pair rates and insert size distributions.

As Figure 1 and Table 1 demonstrate, both isolate and single—
cell paired—end libraries have small variations of the insert size. In
contrast, the jumping library from the Bfaecium dataset has a
much higher variation in the insert size and higher rate of chi—
meric read—pairs (Table 1). At the same time, in addition to the
large insert size variations, Saureus jumping library contains
only 22% of all read—pairs aligned with the proper reversei
forward orientation. Thirty—six percent of all read—pairs have

Table 1. Information on the Bfaeeium isolate dataset and the Saureus
single-cell dataset

 

 

Dataset Bfaeeium S .aureus

Library Paired-end Jumping Paired-end Jumping
Number of reads 13 M 41 M 38 M 41 M
Average coverage 400>< 1100>< 1050>< 1050><
Coverage span 21(P570 >< (P3000x (P3500X (F3500X
Insert size 270 bp 7.5 kb 210bp 1.8 kb
Insert span 150—400 bp 6*10 kb 18(P230 bp 0H kb
Chimeric read-pairs (%) l 9 3 50
Unaligned read-pairs (%) 16 10 6 28

 

Note: Insert span is the shortest insert size interval that contains at least 95% of
properly aligned read—pairs. Unaligned reads refer to the percentage of read—pairs
that have at least one read unaligned. Chimeric read—pairs refer to the percentage of
chimeric read—pairs among all read—pairs. All smtistics was obtained using Bowtie2
(Langmead and Salzberg, 2012). Coverage span is the smallest coverage interval that
includes a least 95% of all genomic positions

incorrect forwardireverse orientation (correspond to the left
peak in Fig. 1d) and 14% are classiﬁed as chimeric read—pairs
of other types. Forwardireverse read—pairs in jumping libraries
represent an artifact of the sample preparation and are common
for datasets of different types.

Despite the fact that various artifacts of jumping libraries
make it difficult to incorporate them into existing assembly
tools, EXSPANDER uses jumping libraries to generate high—quality
assemblies.

3 EXSPAN DER ALGORITHM

EXSPANDER uses an assembly graph constructed by SPAdes
(Bankevich et al., 2012) and a set of read—pair libraries. For
each library, we map read—pairs to the long edges of the assembly
graph and estimate the average insert size along with its confi—
dence intervalia shortest insert size interval that contains at least
80% of properly aligned read—pairs. These estimates are used as
parameters of the scoring function and the decision rule.

3.1 The decision rule

3.1.] Single library Given a path P, we define a winner as an
edge e with the maximal score Scorep(e) among all extension
edges for P. Similarly, a contender is defined as an extension edge
with the second best score. The winner edge is called the strong
winner if  Scorep(winner) >9 and (ii) Scorep(winner)>C -
Scorep(contender), where (9 and C are parameters of the algo—
rithm, which are discussed below. If the path P has a single
extension edge (which is obviously the winner), only the first
condition is used. The decision rule is defined as follows:

e, if edge e is the strong winner for path P
Extend(P) = . . .
Ill, 1f there 1s no strong Winner for path P

3.1.2 Multiple libraries The decision rule described above can
be generalized for several read—pair libraries. Consider M read—
pair libraries, which are sorted in the order of increasing insert

 

i294

ﬁm'spzumol‘pmjxo'sopeuuopuorq/ﬁdnq

ExSPAnder

 

 

 

 

 

 

 

(a) r T"
— ,—
1120 I yo I
C ) )0
e 6/
(b)
/ _ _ _ _ _ _ _ _ _ _ _ _ _ _ - . _ _ .
e I I
I I
I I
I I
I I
yo - - - - -? I I
I I I
)I \I
$0 6 '6
(d) (e)
e’ ; [I
I
I
I
I
I
I
)'
e

 

Fig. 2. (21) Reads r and 1" form a read-pair mapping to consecutive edges e
and e’ in the assembly graph at positions Xo and yo, respectively.
(b) Representation of a read-pair (r,r’) as a point in a rectangle (e,e’).
(c) ‘Ideal read-pairs’ with the exact insert size I connecting edges e and e’
form a 45D line within a rectangle. (d) Read-pairs from the real sequencing
data with variations in the insert size represented as points within a rect-
angle. Most points are located within the conﬁdence strip providing the
evidence that edges e and e’ are supported by the read-pairs and are
genome-consecutive. (e) A rectangle formed by a pair of edges that has
few points falling into the conﬁdence strip revealing that e and e’ are not
genome-consecutive edges

sizes and the associated decision rules Extend-(P) for l 5 i 5 M.
We process the libraries in this order because our analysis re—
vealed that the smaller is the insert size of a library (and its
variation), the more reliable is the decision rule for this individual
library. We thus select the library with the smallest index i that
has the strong winner and deﬁne the decision rule for multiple
libraries Extend(P) as simply Extend-(P). If neither library has a
strong winner, we deﬁne Extend(P) = ill.

3.2 The scoring function

3.2.] The support function We first consider an idealized case
when the genome deﬁnes a genomic path in the assembly graph.
We say that an edge e’ follows edge e at a distance D if the
distance between starts of these edges in the genomic path is
D. We define a boolean function SupportD(e,e/) that reﬂects
our conﬁdence that edge e/ follows edge e in the genome at dis—
tance D. Below we describe how to calculate SupportD(e,e/).
Let I and [1m i,,,l,,m] be the mean and the conﬁdence interval of
the insert size for a read—pair library formed by reads of length
ReadLength. Consider consecutive edges e and e/ in the assembly
graph and a read—pair (r,r/) such that read r maps to e at position
x0 and read r/ maps to e/ in position yo (Fig. 2a). We say that the
read—pair (r,r/) connects edges e and e’. Figure 2b shows a rect—
angle formed by the edges e and e/ [further simply referred to as
rectangle (e,e/)] with the read—pair (r,r/) represented as a point
(x0,y0) within the rectangle. If edges e and e/ represent consecu—
tive regions in the genome, then the genomic distance from the
start of read r to the start of read r/ equals to Length(e) — x0 + yo,

where Length(e) stands for the length of edge e. Therefore, in the
case of an ‘ideal read—pair’ (r,r’) (e.g. a read—pair with the exact
insert size I), yo = x0 — d, where d = Length(e) — I + ReadLength.
Thus all ‘ideal read—pairs’ mapping to edges e and e’ form a set
of integer points on the 450 line y = xi d within the rectangle
(Fig. 20). Because the read—pairs from the real sequencing data
have variations in the insert size, their corresponding points are
typically scattered in the strip between the 450 lines y = x i dun-n
and y = x i dum, where

dmm = Length(e) — [mm + ReadLength.
dmm. = Length(e) — [max + ReadLength.

This strip in the rectangle is further referred to as the confidence
strip (Fig. 2d).

Let F(x) be the empirical distribution of the insert size and S
be a set of all integer points within the confidence strip in the
rectangle (e,e/). We deﬁne the expected number of read—pairs
within the confidence strip (under the assumption of the uniform
coverage) as

Expected(e. e/) = 2 F (I (X, )0),
(x,y)ES

where [(x. y) = Length(e) — x + y + ReadLength represents the
insert size of a read—pair that corresponds to the point (x, y).
We also deﬁne Points(e,e/) as the total number of read—pairs
(from the real dataset) that correspond to the points within the
conﬁdence strip. The notion of density is deﬁned as

) . y ) ), = Points(e. e/)

Dcnsity(c. c ) —Expected e, 6/).

We set Density(e,e/) = 0, if Expected e,e/) = 0. The points outside
the conﬁdence strip may represent read—pairs with somewhat
larger deviations from the mean insert sizes or chimeric read—
pairs. Our analysis revealed that being conservative (e. g. limiting
analysis to the confidence strip) allows one to avoid most of the
assembly errors caused by chimeric read—pairs, particularly in
single—cell projects.

We distinguish between notions of genome—consecutive and
graph—consecutive edges and emphasize that graph—consecutive
edges are not necessarily genome—consecutive. The decision
about which graph—consecutive edges are genome—consecutive is
an important part of any assembler. Figure 2d and e illus—
trate how rectangles help us to make such decisions: both rect—
angles correspond to graph—consecutive edges, but only rectangle
in Figure 2d is formed by the pair of genome—consecutive edges.

The described notions of Expected(e,e/), Points(e,e/) and
Density(e,e/) (deﬁned for the case when edges e and e/ are
genome—consecutive) can be generalized for the case when e
and e/ are not consecutive genomic edges under the assumption
that genomic distance between them is D. In this case the conﬁ—
dence strip [further referred to as S trip D(e,e/)] is bounded by the
lines y = x i dun-n and y = x i dum, where

(1min = D _ [min + RCﬂdLeI/Igth,
dmux = D _ [max + ReadLength.

PointsD(e,e/) similarly represents the number of points within
strip StripD(e,e/). ExpectedD(e,e’) and DensityD(e,e/) are deﬁned

 

i295

ﬁm'spzumofpmjxo'sopeuHOJHIorq/ﬁdnq

A.D.Prjibelski et al.

 

(a)

61

 

 

 

Fig. 3. (a) An example of an assembly graph with the genomic paths (p1,
p2, p3, el) and (p1.p’2.p3. e2). (b, e) The composite rectangles for correct
genomic extension of each path: in these cases the points are evenly
distributed within the conﬁdence strip and the resulting score is equal
to l. (c, d) The composite rectangles that correspond to incorrect exten-
sions edges of these two paths. In each of these cases, at least one simple
rectangle contains few points within the conﬁdence strip

using the same formulas and the corresponding conﬁdence strip.
Clearly, for two genome—consecutive edges Expected(e,e/) =
Expected/lee) and Density(e,e/) = DensityL(e,e’), where
L = Length(e).

The support function reﬂects whether the number of read—
pairs connecting edges e and e/ supports the conjecture that e/
follows e in the genome at distance D:

/ l, DensityD(e, e/) > ‘11
SupportD(e. e ) = .
0. otherw1se

where W is a parameter of the algorithm, which is automatically
computed for each read—pair library based on the chimeric read—
pair rate (see below). For the standard isolate datasets this par—
ameter corresponds to the coverage cutoff for read—pairs. For
single—cell datasets this parameter is usually set to be very low
to retain the regions with low coverage, which are typical for sin—
gle—cell projects. If SupportD(e,e/) = l, we say that the rectangle
(e,e/) is supported by the read—pairs.

3.2.2 The naive scoring function To explain the intuition behind
ExSPANDER, we first introduce the naive scoring function. We
further modify the naive scoring function to arrive to the
advanced scoring function used in the real ExSPANDER
implementation.

A path P = (p1, . . . ,pm) and its extension edge e can be repre—
sented as a composite rectangle formed by m simple rectangles
(pl-,e) containing points that correspond to read—pairs connecting
edges of P and e. Figure 3b shows an example of a composite
rectangle, which is formed by a path (p1, p2, p3) and its extension
edge el and consists of three simple rectangles. The notion of the

confidence strip remains (it now consists of up to m substrips
within simple rectangles), except that it is bounded by the lines
y = x 7 dmin and y = x 7 dmaxa Where

dmm = Length(P) — [mm + ReadLength.
dmm. = Length(P) — [max + ReadLength.

For an edge p,- from the path P we deﬁne the expected number
of points in the confidence substrip within the simple rectangle
(pl-,e) as ExpectedD/(pf. e), where D,- is the distance between
start of p,- and start of e according to the path P
(i.e. D,- = ,- Length(p,-)). We consider rectangles (p). e).j= star
t. . . . . end such that ExpectedD,(p,-. e) >0 and introduce the func—
tion Scorep(e) as the fraction of the total number of expected
read—pairs in these rectangles with SupportD,(p,-. e) = 1:

end
2 SupportD/(pf. e) - ExpectedD,(p,-. e)

f = start

 

Scorep(e) = end

2 ExpectedD, (p). e)

f = start

We set Scorep(e) = 0 if all simple rectangle have zero expected
read—pairs.

Figure 3a shows paths P = (p1, p2, p3) and P, =(p1.p’2.p3)
and its extension edges e1,e2. Let (p1, p2, p3, el) and (p1.p/2.p3.
eg) be the true (but unknown) genomic paths. Figure 3b shows
the composite rectangle for path P and its correct extension e1, in
which points within the conﬁdence strip are rather evenly dis—
tributed resulting in Scorep(e1) = 1. Figure 3c shows the com—
posite rectangle for path P = (p1, p2, p3) and its incorrect
extension edge e2. Because (p1.p/2.p3. e2) is a genomic path, dens—
ity of the points in the sectors of the conﬁdence strip correspond—
ing to edges p1 and p3 is high. However, edge p2 of the path P
does not support extension edge e2 because there are few points
in the rectangle (p2, e2). Additionally, Figure 3d and e shows
composite rectangles for all possible extension edges for path
P/=(P1,l7'2tl?3)-

Because the deﬁned scoring function does not linearly depend
on read coverage, it is well suitable for both single—cell and stand—
ard sequencing projects. At the same time, considering only read—
pairs with insert size in [I,,,,—,,,I,,m] (which correspond to points
within the conﬁdence strip) allows one to filter out most of the
chimeric read—pairs (common for single—cell datasets) and to min—
imize their influence on the scoring function.

3.2.3 The advanced scoring function The naive scoring function
Scorep(e) described above works well in many cases but may be
too conservative when the path P contains repetitive edges (edges
that are visited more than once by the genomic traversal).
Figure 4 illustrates the case when the path P has a repetitive
edge and motivates the need for further improvements in the
scoring function.

Figure 4a shows an assembly graph with four unique edges
(p, p/, e and e/) and a single repetitive edge p, with multiplicity 2.
We assume that paths (p,p,,e) and (p/,p,,e/) are genomic and
paths (p,p,,e/) and (p’,p,,e) are non—genomic. Our goal is to
design an algorithm that correctly extends genomic paths (p,p,)

 

i296

ﬁm'spzumofpmjxo'sopeuHOJHIorq/ﬁdnq

ExSPAnder

 

 

Fig. 4. Scoring a path that contains repetitive edges. (21) An example of
the assembly graph with a repetitive edge p,.. (b) A composite rectangle for
the correct extension e of path (p,p,.). (c) A composite rectangle for the
incorrect extension e’ of the path (p,p,.)

and (p/,p,) into longer genomic paths (p,p,,e) and (p’,p,,e/),
respectively.

Consider a path P = (p,p,) and composite rectangles (P,e) and
(P,e/) (Fig. 4b and c). As Figure 4 illustrates, Scorep(e) is similar
to Scorep(e/), implying that there is no strong winner for path P
and preventing us from extending the path P by edge e.
However, because the repetitive edge p, supports both extension
edges e and e’, it does not provide any valuable information
about the correct extension of the path P. Therefore, to make
a decision about extending the path P by an extension edge e, we
should have excluded p, from the consideration as a repetitive
edge. Because we do not know in advance which edges of the
assembly graph correspond to repeats in the genome, we classify
p, as repetitive because it supports both extension edges e and e’.

Below we present the ExSPANDER algorithm that allows us
to exclude repetitive edges from contributing to scoring. An
extension edge e of path P is called an active edge if
C - Score p(e) 3 Scorep(winner). At the first step of the algorithm
we score all extension edges and form a set of active edges A. An
edge p,- in path P is classiﬁed as repetitive if it supports all active
edges, i.e. SupportD,(p,-. e,-) =1 for all e,- E A. At the second step
we mark all repetitive edges p,- e P and recalculate scores of all
edges in A ignoring these repetitive edges. We then update A by
removing all non—active edges and iterate the process. The pro—
cess continues until yet another iteration does not change the set
of active edges A. If A= {e} and Scorep(e) >® (which means that
e satisﬁes both conditions in the decision rule) the extension edge
e is considered to be a strong winner and added to the path P.
Otherwise, we stop extending path P.

We further demonstrate the work of the ExSPANDER algo—
rithm using a simple assembly graph shown in Figure 5. The
paths (171.p2.p3.e1). (171.122.123.62) and (173.123. 63) are genomic
paths, which means that edges p2 and p3 are repetitive and have
multiplicities 2 and 3, respectively.

Let P = (p1, p2, p3) be a path we aim to extend. We first cal—
culate scores of all extension edges using the composite rectangles
(Fig. 6a4:) and form a set of active edges A= {e1. e2. e3}
based on their scores (marked red in Fig. 6d). Because SupportD3

 

1 51
p2
P1 :03 62
, ) >0
P2
3

Fig. 5. An example of the assembly graph with repetitive edges p2 and p3

(p3. e,-) = l for i = l, 2, 3, edge p3 is classiﬁed as repetitive and is
removed from further consideration (Fig. 6e). We now recalcu—
late scores for the extension edges in A ignoring repetitive edge p3
(Fig. 6fih) and remove non—active edge e3 from A (Fig. 6i).
Using the updated set A= {e1. e2} we again proceed to the
repeat detection step and mark edge p2 as repetitive because Su
pportD,(p2.e,-)=l for i= 1, 2 (Fig. 6j). Finally, we once again
recalculate scores of the extension edges in A (Fig. 6kim) and
remove e2 as non—active (Fig. 6n). The extension edge e1 remains
the only active edge in and is used to extend path P.

Extensive tests of the advanced scoring function revealed that
it works well across diverse datasets including single—cell jumping
libraries with high variations in the insert size, extremely non—
uniform coverage and large number of chimeric reads and chi—
meric read—pairs (see Section 4).

3.3 Scaffolding

After all paths are constructed, we consider all pairs of paths
that form composite rectangles with non—zero number of points
(Fig. 7). For each such pair of paths P and P’ we can check
whether points in the corresponding composite rectangle are
scattered around a certain 450 line using SPAdes distance esti—
mation procedure (Nurk et al., 2013). When SPAdes provides the
estimated distance D between P and P/, we use ExSPANDER to
verify the conjecture that P’ follows P at distance D. If this con—
jecture is supported and does not contradict to any other con—
jectures about these paths, we extend the path P by P’ (the
scaffolding step). We estimate the gap length between the paths
as D — Length(P) and insert the appropriate number of ‘N’ sym—
bols (unspeciﬁed nucleotide) between end of P and start of PC If
paths P and P’ overlap, we construct their overlap alignment to
correct distance D.

3.4 Choice of the parameters

3.4.] The scoring function We select the parameter W as a
threshold for the density of the read—pairs within the conﬁdence
strip. We therefore assume that rectangles with the density below
\IJ contain mostly chimeric read—pairs and should be ignored
while calculating the score of an extension edge. To select W
for a particular read—pair library, we estimate the distribution
of the densities for rectangles that contain only chimeric read—
pairs (false rectangles) and for rectangles that contain only non—
chimeric read—pairs (true rectangles).

To partition all read—pairs into chimeric and non—chimeric, one
needs the complete genome that is unavailable. To get around
this, we identify a subset of chimeric reads using the long edges in
the assembly graph (e.g. edges longer than N50) that can be

 

i297

ﬁm'spzumofpmjxo'sopeuHOJHIorq/ﬁdnq

 

 

 

61

61

2

P3

6
------>—>

p2

52

P3

[)2

 

 

:39\Ewowsmoaﬁmowoxmoagoﬁsambwﬁ

1 2 3
e e.—. ew.
\
s
s
s
s
\r
.
.
3.
p.
_
_
I,
~
2
x
p~
x
1
AI
1 2 3
e act—t aw.—
\
s
s
x
3 s
p \r
.
.
3.
p.
_
_
.n
2
i p
.e
1

 

61

an?kgogmomammowoxmoagocgawbmﬁ

 

A.D.Prjibelski et al.

 

Table 2. Comparison of contigs for the Bfaeeium isolate dataset

Table 3. Comparison of scaffolds for the Bfaeeium isolate dataset

 

Assembler NG50 Number Largest Number GF
of contigs of mis

Assembler NG50 Number of Largest Number GF
scaffolds of mis

 

Only paired-end library

ABySS 203 40 672 0 99.9
Ray 114 51 436 1 98.9
SOAPdenovo 20 333 61 0 98.8
Velvet 144 47 550 0 99.4
Velvet-SC 163 46 550 0 99.4
IDBA-UD 202 39 483 0 99.4
SPAdes 2.4 361 24 635 1 99.7
ExSPANDER 380 22 672 1 99.5
Both paired-end and jumping libraries
ABySS 203 40 672 0 99.9
ALLPATHS-LG 313 21 686 0 99.5
Ray 87 88 416 2 96.8
SOAPdenovo 20 333 61 0 98.8
Velvet 103 75 242 11 99.0
Velvet-SC 253 40 545 15 99. 8
IDBA-UD 207 41 483 0 99.4
ExSPANDER 3268 2 3268 1 99.9

Only paired-end library

ABySS 383 24 676 0 99.9
Ray 204 31 553 1 98.9
SOAPdenovo 477 26 724 0 99.3
Velvet 477 28 724 0 99.4
Velvet-SC 477 28 724 0 99.4
IDBA-UD 250 30 671 0 99.4
SPAdes 2.4 361 22 671 1 99.7
ExSPANDER 380 22 672 1 99.5
Both paired-end and jumping libraries
ABySS 250 30 739 1 99.9
ALLPATHS-LG 3610 7 3610 1 99.5
Ray 106 75 416 2 96.8
SOAPdenovo 480 28 810 2 99.4
Velvet 2651 14 2651 78 99.1
Velvet-SC 945 102 1381 500 98.9
IDBA-UD 1002 9 1692 0 99.4
ExSPANDER 3268 2 3268 1 99.9

 

Note: NG50 is given in kb; number of contigs is the total number of contigs
>500bp; largest stands for the length (in kb) of the longest contig assembled;
number of mis is the number of misassemblies; GF stands for the fraction of
genome mapped given in percent. In each column, the best value is indicated
in bold.

Tables 2 and 3 show the benchmarking results for the
Bfaecium isolate dataset. Interestingly, the single—cell assemblers
(IDBA—UD and ExSPANDER coupled with SPAdes) as well as
ABySS performed well on the B.faecium isolate dataset and pro—
duced contigs with the largest NG50 in the case of a single
library. While AbySS generated the assembly with the maximal
genome fraction, manual inspection revealed that it reﬂects the
speciﬁcs of ABySS and QUAST reporting (mapping each repeat
to a single position in the genome) rather than real superiority of
ABySS by this metric.

In the case of two libraries, ExSPANDER produced the best
contigs while ALLPATHS—LG produced the best scaffolds.
The complexity of using jumping libraries is reﬂected in a dete—
riorated performance of ABySS and Ray (reduction in NG50) as
well as Velvet and Velvet—SC (dramatic increase in the number of
misassemblies).

Tables 4 and 5 compare various assemblers on the S.aureus
single—cell dataset. This comparison highlights the complexity of
both (i) assembling single—cell datasets and (ii) using jumping
libraries. For example, SOAPdenovo produced assemblies of
poor quality for single—cell data (we decided not to include it in
Tables 4 and 5). Similarly, ABySS produced assemblies with high
number of misassemblies for the single—cell data. Velvet and
Velvet—SC are not included in the benchmark experiment for
jumping libraries testing because they also produce low—quality
assemblies when both paired—end and jumping libraries are used
simultaneously. IDBA—UD performed well on a single paired—
end library, but produced an assembly of lower quality when
both libraries were provided (decreased NG50). ExSPANDER

Note: NG50 is given in kb; number of scaffolds is the total number of scaffolds
>500 bp; largest stands for the length (in kb) of the longest scaffold assembled;
number of mis is the number of misassemblies; GF stands for the fraction of
genome mapped given in percent. In each column, the best value is indicated in
bold.

Table 4. Comparison of contigs for the S.aureus single-cell dataset

 

Assembler NG50 Number of Largest Number GF
contigs of mis

 

Only paired-end library

ABySS 27 914 91 262 98.0
Ray 21 306 108 14 88.7
Velvet 10 538 56 2 93.2
Velvet-SC 9 616 56 4 94.2
IDBA-UD 75 390 161 7 98.6
SPAdes 2.4 98 400 230 8 99.1
ExSPANDER 148 366 275 3 98.6
Both paired-end and jumping libraries
ABySS 27 914 91 262 98.0
ALLPATHS-LG 15 283 75 26 79.9
Ray 100 178 486 21 93.5
IDBA-UD 47 415 161 7 98.6
ExSPANDER 314 322 603 9 99.3

 

Note: NG50 is given in kb; number of contigs is the total number of contigs >500 bp;
largest stands for the length (in kb) of the longest contig assembled; number of mis is
the number of misassemblies; GF stands for the fraction of genome mapped given in
percent. In each column, the best value is indicated in bold.

produced assemblies with the highest NG50 and largest
assembled contig/scaffold.

Using only paired—end library IDBA—UD, SPAdes 2.4 and
ExSPANDER recovered the largest fraction of the genome
(>98.5%). However, the highest genome fraction of the assembly

 

i300

ﬁm'spzumofpmjxo'sopauHOJHIorq/ﬁdnq

ExSPAnder

 

Table 5. Comparison of scaffolds for the S.aureus single-cell dataset

 

Assembler NG50 Number of Largest Number GF
scaffolds of mis

 

Only paired-end library

ABySS 28 910 91 270 98.2
Ray 21 306 108 14 88.7
Velvet 10 538 56 2 93.2
Velvet-SC 10 620 56 5 94.2
IDBA-UD 88 382 161 8 98.2
SPAdes 2.4 99 391 230 8 99.2
ExSPANDER 148 357 426 4 98.6
Both paired-end and jumping libraries
ABySS 30 852 91 275 98.0
ALLPATHS-LG 40 165 132 69 79.9
Ray 100 169 486 25 93.5
IDBA-UD 55 397 161 9 98.6
ExSPANDER 314 302 603 9 99.3

 

Note: NG50 is given in kb; number of scaffolds is the total number of scaffolds
>500 bp; largest stands for the length (in kb) of the longest scaffold assembled;
number of mis is the number of misassemblies; GF stands for the fraction of
genome mapped given in percent. In each column, the best value is indicated in
bold.

generated by SPAdes 2.4 reﬂects the specifics of SPAdes 2.4 and
QUAST reporting (some artifacts with reporting of repetitive
regions) rather than real advantage of SPAdes 2.4 with respect
to this parameter.

When using both libraries simultaneously, ExSPANDER pro—
duced assemblies with the highest genome fraction exceeding
99%, the largest genome fraction we saw across dozens of
single—cell datasets assembled with SPAdes in the past 2 years.
Moreover, Tables 4 and 5 show that ExSPANDER successfully
deals with the high rate of the chimeric read—pairs and relatively
high variations in the insert size.

5 CONCLUSION

We have presented ExSPANDER algorithm for resolving
repeats using either a single or multiple read—pair libraries with
different insert sizes, which is applicable for both single—cell and
isolate bacterial datasets. Benchmarks across eight popular
assemblers demonstrate that ExSPANDER produces high—quality
assemblies for datasets of different types. Additionally, as
illustrated by recent integration of Illumina and PacBio reads
in SPAdes 3.0, ExSPANDER is a ﬂexible approach that can be
easily modiﬁed to work with diverse types of sequencing data.

ACKNOWLEDGEMENTS

The Bfaecium sequencing data were produced by the Joint
Genome Institute in collaboration with the user community.
The S.aureus dataset was provided by the Human Microbiome
Project (bioproject ID PRJNA236734).

Funding: This work was supported by the Government of the
Russian Federation [grant numbers 11.G34.31.0018,
11.G34.31.0068]; the National Institutes of Health
[3P41RR024851—02S1]; and the Russian Fund for Basic
Research [12—01—00747—a to AK].

Conﬂict of Interest: none declared.

REFERENCES

Bankevich,A. et a]. (2012) SPAdes: a new genome assembly algorithm and its ap—
plications to single—cell sequencing. J. Comput. Biol., 19, 4554177.

Boisvert,S. et a]. (2010) Ray: simultaneous assembly of reads from a mix of high—
throughput sequencing technologies. J. Comput. Biol., 17, 151971533.

Bresler,M. et a]. (2012) Telescoper: de novo assembly of highly repetitive regions.
Bioiry’ormatics, 28, 3117317.

Butler,J. et a]. (2008) ALLPATHS: de novo assembly of whole—genome shotgun
microreads. Genome Res, 18, 81(k820.

Chitsaz,H. et a]. (2011) Efﬁcient de novo assembly of single—cell bacterial genomes
from short—read data sets. Nat. Biotechnol, 29, 9157921.

Compeau,F. et a]. (2011) How to apply de Bruijn graphs to genome assembly. Nat.
Biotechnol, 29, 9877991.

Diep,B. et a]. (2006) Complete genome sequence of USA300, an epidemic clone of
community—acquired meticillin—resistant Staphylococcus aureus. Lancet, 367,
7317739.

Gnerre,S. et a]. (2011) High—quality draft assemblies of mammalian genomes from
massively parallel sequence data. Proc. Natl Acad. Sci. USA, 108, 151}1518.

Gurevich,A. et a]. (2013) QUAST: quality assessment tool for genome assemblies.
Bioiry’ormatics, 29, 107271075.

Langmead,B. and Salzberg,S. (2012) Fast gapped—read alignment with bowtie 2.
Nat. Methods, 9, 3577359.

Lapidus,A. et a]. (2009) Complete genome sequence of Brachybacterium faecium
type strain (Schefferle 6—10). Standards Genomic Sci., 1, 3711.

Li,R. et a]. (2010) De novo assembly of human genomes with massively parallel
short read sequencing. Genome Res., 20, 2657272.

Nurk,S. et a]. (2013) Assembling single—cell genomes and mini—metagenomes from
chimeric MDA products. J. Comput. Biol., 20, 1724.

Medvedev,P. et a]. (2011) Paired de bruijn graphs: a novel approach for incorporating
mate pair information into genome assemblers. J. Comput. Biol., 18, 162571634.

Peng,Y. et a]. (2012) IDBA—UD: a de novo assembler for single—cell and metage—
nomic sequencing data with highly uneven depth. Bioinformatics, 28, 178.

Pevzner,P.A. et a]. (2001) An Eulerian path approach to DNA fragment assembly.
Proc. Natl Acad. Sci. USA, 98, 974879753.

Pham,S. et a]. (2013) Pathset graphs: a novel approach for comprehensive utilization
of paired reads in genome assembly. J. Comput. Biol., 20, 2597371.

Simpson,J. et a]. (2009) ABySS: a parallel assembler for short read sequence data.
Genome Res., 19, 111771123.

Vyahhi,N. et a]. (2012) From de Bruijn graphs to rectangle graphs for genome
assembly,” in Worksle on Algorithms in Bioinformatics 2012. Lecture Notes
Comput Sci, 7534, 2007212.

Zerbino,D.R. and Birney,E. (2008) Velvet: algorithms for de novo short read assem—
bly using de Bruijn graphs. Genome Res., 18, 8217829.

 

i301

ﬁm'spzumofpmjxo'sopauHOJHIorq/ﬁdnq

