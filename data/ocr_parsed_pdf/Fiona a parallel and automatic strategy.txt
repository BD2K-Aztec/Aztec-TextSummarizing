BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

Fiona: automatic read error connection

 

The general disadvantage for most of these methods is their
inability to correct indel errors, a severe limitation for 454 or Ion
Torrent sequencers. In addition, for most of these approaches,
parameters need to be optimized by the user to obtain good
performance, for example, Reptile.

Sufﬁx tree/array based. Shrec (Schroder el 61]., 2009) was the first
approach that uses a variable seed length for read overlap and
error-detection computation. It considers for each erroneous read
a set of correcting reads such that all reads share a (k i 1)-mer
left of the error and the set of correcting reads share a k-mer that
ends with the correct base, which outvotes the erroneous base. To
efficiently find erroneous reads and correcting candidates, Shrec
traverses a generalized suffix tree of all reads, in which erroneous
and correcting reads occur as children of branching nodes with
string depth k i 1. Building on a suffix tree representation, the
HybridShrec algorithm extended the ideas to correct indel errors
and sequences in color space (Salmela, 2010). In both methods,
potentially correcting reads are compared with erroneous reads
using hamming distance, seeded by the shared (k i 1)-mers be-
tween reads. Further, both methods are sensitive to the input
parameters and therefore show variable performance when com-
pared in other studies (Ilie el 61]., 2011; Kao el 61]., 2011; Kelley
el 61]., 2010), and the full suffix tree data structure needs large
memory resources.

The HiTEC algorithm introduced automatic parameter selec-
tion using coverage statistics (Ilie el 61]., 2011). Seed lengths and
coverage threshold are set automatically, given the genome
length and the average error rate. HiTEC uses the suffix array
instead of a suffix tree to save memory. However, HiTEC can
only correct substitution errors and the automatic parameter
selection works only for reads of same length as found for
Illumina data.

Note that these methods do not define explicitly which correc-
tion for an erroneous position is applied when the same error is
encountered multiple times through different seed lengths in the
tree, and in which order errors in a read are corrected.

MSA based. Among the two existing multiple alignment-based
methods ECHO (Kao el 61]., 2011) and Coral (Salmela and
Schroder, 2011), only Coral can correct indel errors. Coral
computes initial read overlaps with hash tables for a fixed
k-mer length and then uses dynamic programming to form mul-
tiple read alignments. This alignment is costly for long reads but
has a clear optimization function, as read errors are corrected by
the best voting correction in the MSA.

2 MATERIALS AND METHODS

We introduce the l-‘iona algorithm, which combines the strength of suffix
tree—based methods with a clear definition oferror correction as in MSA—
based methods. The algorithm uses a suffix tree to detect and correct
substitution and indel errors following Shrec and HybridShrec, but
with enhanced overlap detection of reads with indel errors using edit
distance comparisons. 1n the implementation, the suffix tree traversal is
emulated using solely a partial suffix array that is presorted up to a fixed
depth to reduce the memory footprint. All steps feature a parallel imple—
mentation to scale with larger datasets. Instead of treating discovered
errors independently, l-‘iona collects them and solves a new formulation
for optimal error correction inspired by the MSA—based correction meth—
ods. Further, it uses new statistical methods to improve error detection at

CGTCGGATTGCA
GTCGGATTGCAA —l
GGATTGCAAGCT
TCGGACTGCAAG
GTCGGA‘I‘TGCAA

TCGGATTGCAAG
CCGTCGGATTGC

\ c

 

   

 

 

 

 

 

TCGGACTGCAAG

TCGGATTGCAAG

 

 

C
L__

 

Fig. 1. The l-‘iona strategy illustrated on a toy example. A set of partial
suffix trees are built from the set of reads and their reverse complement
(in fact partial suffix arrays are constructed, see 1i71pl€l716l1fafi0l1). The
trees are traversed in parallel to detect and correct errors. Potential
errors in the reads are identified as nodes in the tree according to their
coverage (e.g. the substring GGAC, covered by only one read). The cor—
rection with the highest support is chosen to correct the read at that
position. Owing to the parallel traversal of the tree, all possible correc—
tions on a read are recorded in a linked list, which reports the positions of
corrections as well as their current maximal support. After traversal,
the reads are updated by applying all non—conflicting corrections in
order of decreasing support. Once all reads have been corrected, the al—
gorithm repeats the procedure until the number of corrections have been
achieved

different k values and automatically estimates its parameters for reads of
varying lengths as commonly found in 454 or lonTorrent data sets. The
l-‘iona strategy is outlined in Figure 1.

Notations. Let [i, ‘1] and (i, j) be closed and open ranges of
integers. l-‘urther, let 2 be the DNA alphabet (2: {A, C, G, T,N}, and N
represents an unknown base) and s a string of is) characters. The concat—
enation of two strings s and I is denoted by st. A substring of s from
position i to j is the sequence s[i,j]: :s,s,+1 ms). SR and E denote, re—
spectively, the reverse and the reverse complement of a DNA string s. We
correct errors on a set R (1R1 :m) of DNA strings of lengths (will,
sampled from a genome g oflength 11, possibly with sequencing errors. E
denotes the set of reverse—complemented reads. The edit distance er/(s, I)
between two strings s and I is the minimal number of oper—
ations (substitutions, deletions and insertions) required to transform s
into I.

In the following section, we describe how we use a suffix tree and a
statistic on read coverage to find erroneous reads and correct them using
the sequences they overlap. We then introduce our approach for detecting
the type of error and choosing the optimal correction. Instead of imme—
diately correcting errors as they are found, corrections are prioritized
according to the support of their overlapping reads.

 

i357

/810's12umo_fp10}xo'sopEuIJoguioiq/ﬁduq

M.H.Schulz et al.

 

Searching erroneous reads

One essential ingredient in every sequencing error correction method is
the statistic that computes which k-mers are erroneous, i.e. span at least
one sequencing error in the read. Because new k-mers are generated when
an error is introduced, their abundance or coverage is lower compared
with k-mers from the genome. To detect a k-mer with a sequencing error,
we compute the expected coverage assuming a uniform sampling of
genomic positions. We use a hierarchical statistical model to describe
the expected coverage distribution of k-mers resulting from library
preparation and sequencing as follows. Let Xk be the random variable
for the number of occurrences of a string of length k in the population
of sequence fragments before sequencing. Xk is never directly
observed, instead the occurrences of k-mers in the reads R after
sequencing, denoted Yk, are observed with a given number of sequencing
errors 2.

For every k-mer covered by 6 reads, we classify it as possessing errors
based on the sign of the log odds ratio (positive value for erroneous
k-mers):

P(Yk=c|z>0) + ‘

10gP(Yk=c|z=0)

(1)

The constant w can be modiﬁed to adjust the sensitivity of the detection.
To match the setup of a naive Bayes classiﬁer, we use the log-odds ratio
of the probability that the k-mer has errors compared with the probability
that the k-mer has no error: w=log(l — (l — a)")/(l — is)". As we will
show in the following the user only needs to supply the genome length n
and the average error rate a to the method. The method can then infer the
coverage cutoff and the range of k-mers to explore.

Coverage distribution of k—mers. The counts Xk are drawn
according to binomial sampling along each position in g. If we as-
sume the sampling to be uniform, k<min(l§,»), max(lZ,») << n and
that any word of length k is unique in g, the expected count of a k-mer
Ak is

m Ei—k-i-l
Avg—H,“- <2>

As n is usually large, X k can be approximated by a Poisson distribution of
rate Ak. Note that the assumption that a word is unique in g is vital
because repeats in Q will have a higher M. We restrict ourselves to this
hypothesis in the following, as errors derived from repeats are difﬁcult to
infer based exclusively on their coverage. Therefore, we have an add-
itional ﬁlter to remove words that originate from repetitive regions (see
Implementation).

If we assume a uniform error rate of a at each base (thus a probability
of 8/ 3 for each substitution), we can derive the expected count for a given
k-mer, given its number of sequencing errors, i.e. the distribution of YA. |z.
The coverage of a k-mer possessing i sequencing errors is distributed
according to a Poisson distribution with an expectation of

Hi = M» - (8/3)i(1 - a)” (3)

Note that this formulation does not incorporate cases where errors would
accumulate on other reads in the neighborhood of the k-mer. This effect
can be neglected given the relatively low error rate of current sequencers
(<5%).

The distribution of Yk can be obtained by summing over the pos-
sible number of errors, which results in a mixture of Poisson distribu-
tions with rates [14. We denote the proportion of reads with exactly i

errors as
k , k .
In: . 81(1—8)’l~ (4)
I

which we call the mixture coefﬁcients. It follows the formulation

for Yk:

gimp]?
Mi!

 

k k
P(Yk=c)=E JTi-P(Yk=C|Z=i)=E m- (5)
i=0 i=0

Note that without the i = 0 term, this formulation denotes the distribu-
tion for reads with at least one error.

Choosing the k—mer range. In our error correction formulation we
seed the alignments with different seed lengths in the interval [kmim kmx].
The minimal value kmm should neither be too small, to reduce inﬂuence
from repetitive sequences, nor too large, as many erroneous reads may be
missed otherwise. In Fiona, we extend a technique proposed by the au-
thors of HiTEC (Ilie et al., 2011) to determine the best value for kmin,
balancing the sensitivity of a seed and its accuracy, and modify it to
account for heterogeneous read lengths (Supplementary Section S1).
Note that our use of the [/(mm, kmx] values differs compared with
HiTEC because in Fiona we always choose the best corrections in the
interval [/(min, kmx] in each round.

Detecting the type of error

With the statistic described in the previous section we now search
the generalized sufﬁx tree of RUR for nodes or at level k —1 that
branch into an erroneous and a correct k-mer, let the latter be ax with
X E E.

For each read r in the erroneous subtree, we search for possible cor-
rections in the correct subtrees. If i is the position of the error, obviously
r[i] 75 X and we can use the set of overlapping correct reads to determine
the type of error at i: substitution, insertion or deletion. We
use the spectrum of the correct k-mer ax to select possible correcting
reads.

The spectrum 8(t) of a string t is deﬁned as the set of pairs (s, j) such
that s e R U R and s[j — |t| + 1,1] =t (the set of positions in reads ending
with the string t). For each read s in the spectrum 8(ax), we extend the
seed a to the right with minimal edit distance using an alignment algo-
rithm until the end of either r or s is reached.

We deﬁne the right extension of two strings a and b as a pairwise
alignment of one string to a preﬁx of the other. E(a, b) denotes the
number of errors in an optimal right extension of a and b:

E(a, b) = min{lr€i‘nﬂ ed(a[l, 1], b[1, |b|]), lr[r11i‘rl1”ed(a[1, lal], b[1, 11)}.

Considering the three possible types of error, we assume that skipping the

actual error yields an optimal extension of the remaining sufﬁxes. Hence,
for  e  we skip e1 bases from position i in r and e2 bases
from position j in s and examine which value of e yields an optimal
extension, i.e. a minimal value E(r[i+e1, |r|],s[j+e2, |s|]). Figure 2

gives an example where e =  yields an optimal extension.

We determine the actual error by a majority vote over all correct
reads:

V(e)= {(s,j) e 8(ax) l e e arg min E(r[i+e’1, |r|], s[j+e’2, |s|])}.

“’El(i)($)(i‘)]

Thus, V(e) is the set of correct reads (or more precisely of correct anchors)
that vote for e, i.e. can be optimally extended incorporating error e. We
choose the error type that maximizes |V(e)|. In case of ties, we prefer
substitutions over indels and deletions over insertions. As an additional
criterion to reduce false positives, we consider only correct reads within a
given overlap error rate.

 

i358

ﬁm'spzumoipmﬂo'sopeuuopnorq/ﬁdnq

:39\Ewowsmoaﬁmowoxmoagoﬁsambwﬁ

 

:39\Ewowsmoaﬁmowoxmoagoﬁsambwﬁ

Fiona: automatic read error connection

 

Table 1. Performance on 454 (top) and lonTorrent (bottom) datasets

 

 

 

 

Original Allpaths-LG Coral Coral* Fiona HybridShrec* HybridShrecF
Dataset e-rate e-rate gain e-rate gain e-rate gain e-rate gain e-rate gain e-rate gain
D.melanogaster 18>< 1.17 1.07 8.87 0.72 38.81 0.55 53.30 0.42 64.62 4.46 7279.51 0.73 38.17
Ecoli K-12 13 X 1.06 0.74 30.68 0.54 49.42 0.38 63.79 0.25 76.88 0.64 40.05 0.70 34.28
Saureus 34>< 1.76 1.34 23.85 1.76 0.00 0.44 74.90 0.53 69.87 1.59 9.62 1.40 20.50
S.cerevisae 16>< 0.95 0.78 18.45 0.95 0.56 0.92 2.99 0.61 36.04 0.90 5.48 0.73 23.11
Bpertussis 85>< 3.71 2.22 40.13 3.71 0.02 2.57 30.60 1.01 72.83 12.44 7235.48 4.07 79.68
Ecoli K-12 8>< 0.62 0.28 54.46 0.33 46.86 0.30 51.86 0.06 90.52 0.36 41.81 0.37 40.26
Ecoli K-12 163 X 1.46 1.23 15.99 0.59 59.70 0.38 73.72 0.27 81.24 1.73 718.90 1.46 0.00
Ecoli K-12 156>< 1.11 0.75 31.98 0.43 61.07 0.28 74.70 0.29 74.06 1.38 724.15 1.11 0.00
Ecoli 0104:H4 32>< 5.19 3.09 40.53 5.19 0.00 3.44 33.82 1.59 69.33 4.39 15.36 4.31 16.76
H.sapiens“ 1 1 X 1.62 1 .44 1 1.52 J J 0.87 46.68 J J
Pfalciparum 3D7 13 X 5.06 3.97 21.39 5.05 0.03 3.80 24.94 2.33 54.12 7.67 751.29 4.63 8.50
Saureus 109>< 3.32 2.83 14.89 3.32 0.24 1.44 56.91 1.17 64.94 3.77 713.44 3.31 0.32

 

Note: "The programs were run on machine with 16 physical and 32 virtual cores and 370 GB of RAM. bOut of memoryiThe table shows the base error rate (e—rate, in
percent) before and after correction with the methods as well as the gain statistic. For each dataset, the results with the best gain value are highlighted in bold. The results are

separated by sequencing technology, the 454 results are above the lonTorrent results.

Table 2. Running time and memory consumption for 454 (top) and lonTorrent (bottom) experiments

 

 

 

 

Allpaths-LG Coral Coral* Fiona HybridShrec* HybridShrecF
Dataset Gbp time mem time mem time mem time mem time Mem time mem
D.melanogaster 18>< 2.2 145.0 11 496.1 59 1414.1 60 240.7 18 333.2 41 499.5 42
E.coli K-12 13>< 0.06 1.0 0 0.8 3 0.9 3 2.5 1 4.8 5 5.0 12
Saureus 34>< 0.1 3.0 1 5.5 5 112.2 5 12.3 1 12.0 14 13.6 15
S.cerevisae 16>< 0.19 6.5 1 7.1 5 19.6 5 13.1 2 22.5 15 30.5 15
Bpertussis 85>< 0.3 6.0 2 13.5 9 81.2 9 32.0 3 58.3 17 54.0 21
E.coli K-12 8>< 0.04 2.6 0 3.4 3 4.4 3 3.1 1 7.1 5 9.2 8
E.coli K-12 163>< 0.8 14.2 4 243.0 13 373.8 13 118.3 9 111.3 19 160.2 6
E.coli K-12 156>< 0.7 15.0 7 249.1 290.1 12 49.2 8 111.4 18 111.0 6
E.coli 0104:H4 32>< 0.2 3.8 1 5.3 8 12.6 8 15.2 2 21.7 15 28.7 16
H.sapiens“ 1 1 X 31.5 572.8 129 J J 1 187.1 244 J J
Pfalciparum 13>< 0.3 5.6 1 11.0 11 24.8 11 20.5 3 38.9 16 49.7 20
Saureus 109>< 0.31 4.4 1 12.0 13 175.8 13 43.7 3 51.1 18 53.8 29

 

Note: "The programs were run on machine with 16 physical and 32 virtual cores and 370 GB of RAM. bOut of memoryiTime (in minutes and fractions thereof) and memory
(in GB, rounded to the next GB) for the read correction runs from Table 1. For each dataset, the results with the lowest running time and memory are given in bold. The
results are separated by sequencing technology; the 454 results are above the lonTorrent results.

datasets. On seven of eight datasets, Fiona signiﬁcantly outper—
forms the other methods in terms of gain. Fiona shows an in—
crease in gain to the second best method ranging from 10 (Ecoli
163><) to 56% (Plasmoa’iumfala'parum). For the human dataset,
only Allpaths—LG and Fiona could be run with the available
memory, with a gain improvement of 35% for Fiona. Only for
the Ecoli (156><) dataset Fiona and Coral* have comparable
gain values, although Fiona runs approximately six times
faster. Except for Fiona, all methods show a large variation in
their ability to correct errors as shown in ﬂuctuations of their

gain values. For example, all datasets with an error rate >3.3%
are poorly corrected when using Coral default parameters.

In these evaluations, Allpaths—LG uses the lowest amount of
memory. Fiona’s memory usage scales linearly with the dataset
size (Supplementary Table S2), which is in line with the expected
memory consumption (Supplementary Section 82.6).

Comparison on Illumina data. To show that Fiona is on par
with methods that are optimized for Illumina data, we made
comparisons on seven datasets. We compared Fiona—H, the

 

i361

ﬁm'spzumoipmﬂo'sopeuuopnorq/ﬁdnq

Ion Torrent

B. pertussis

I I I I
4 100 200 300

P. faICIparum S. aureus

time [min]

 

/3.IO'S[BIIJI’10[pJOJXO'SOIJBLUJOJIIIOIq/ﬂduq

Fiona: automatic read error connection

 

For the evaluation of the different error correction methods
we chose to use the gain statistic that is commonly used for this
task. However, evaluating the accuracy of nucleotide corrections
based on the available reference sequence can be misleading, as
haplotype variants may be penalized and therefore the number of
false—positive/negative corrections inﬂated. Despite this disad—
vantage, the comparison should not favor any method because
all compared methods work exclusively on the read set without
alignment to the reference sequence.

We introduced a new statistic for error detection that uses a
hierarchical model for the stepwise process of ﬁrst selecting a
subset of reads from a genome and then introducing errors
during sequencing. This formulation provides an easily extend—
ible framework and can be extended to accommodate more gen—
eral scenarios, like the presence of heterozygous positions in
diploid genomes, coverage overdispersion or the distribution of
repeat elements, as well as base quality values.

For our experiments, we ﬁxed the error rate estimate to 5%
for indel—prone datasets and show that reasonable variations to
this value lead to minor performance differences. In principle, the
error rate could be estimated from the base—calling procedure
of the sequencer. Alternatively, it could be estimated from the
raw sequencing data in a preprocessing step as was recently
shown by Wang et a1. (2012) for Illumina data. Further research
on how to determine sequencing error rates in the context of de
novo assemblies, where no reference sequence is available, is
necessary.

In conclusion, Fiona is a reliable method that automatically
determines parameters, corrects indels and scales well to large
datasets. We believe that users will improve their downstream
analysis by using Fiona in their pipelines and made it publicly
available at http://www.seqan.de/projects/ﬁona.

ACKNOWLEDGEMENT

The authors thank Enrico Siragusa for his partial sufﬁx array
implementation.

Funding: The initial part of the project for M.H.S. was funded by
the IMPRS—CBSC Berlin. M.H. and D.W. were supported by the
BMBF [16V0080]. HR. was partly funded by a JSPS [PE11014]
fellowship.

Conﬂict of interest: none declared.

REFERENCES

Abouelhoda,M. et a]. (2004) Replacing sufﬁx trees with enhanced sufﬁx arrays.
J. Discrete Alg., 2, 53786.

Chaisson,M.J. and Pevzner,P.A. (2008) Short read fragment assembly of bacterial
genomes. Genome Res, 18, 3244330.

D6ring,A. et a]. (2008) Squn an efﬁcient, generic C+ + library for sequence
analysis. BMC Bioiiy’ormaties, 9, ll.

Gnerre,S. et a]. (2010) High—quality draft assemblies of mammalian genomes from
massively parallel sequence data. PNAS, 108, 151371518.

Ilie,L. et a]. (2011) HiTEC: accurate error correction in high—throughput sequencing
data. Bioiiy’ormaties, 27, 2957302.

Kao,W. et a]. (2011) ECHO: a reference—free short—read error correction algorithm.
Genome Res., 21, 118171192.

Kelley,D.R. et a]. (2010) Quake: quality—aware detection and correction of sequen—
cing errors. Genome Biol., 11, R116.

Minoche,A. et a]. (2011) Evaluation of genomic high—throughput sequencing data
generated on Illumina HiSeq and Genome Analyzer systems. Genome Biol., 12,
R112.

Pevzner,P.A. et a]. (2001) An eulerian path approach to dna fragment assembly.
PNAS, 98, 974&9753.

Quail,M. et a]. (2012) A tale of three next generation sequencing platforms: com—
parison of Ion Torrent, Paciﬁc Biosciences and Illumina MiSeq sequencers.
BMC Genomics, 13, 341.

Salmela,L. (2010) Correction of sequencing errors in a mixed set of reads.
Bioinformaties, 26, l284~l290.

Salmela,L. and Schr6der,J. (2011) Correcting errors in short reads by multiple
alignments. Bioinformaties, 27, 145571461.

Salzberg,S.L. et a]. (2012) GAGE: a critical evaluation of genome assemblies and
assembly algorithms. Genome Res., 22, 5577567.

Schr6der,J. et a]. (2009) SHREC: a short—read error correction method.
Bioinformaties, 25, 215772163.

Wang,X.V. et a]. (2012) Estimation of sequencing error rates in short reads. BMC
Bioinformaties, 13, 185.

Yang,X. et a]. (2010) Reptile: representative tiling for short read error correction.
Bioinformaties, 26, 252G2533.

Yang,X. et a]. (2013) A survey of error—correction methods for next—generation
sequencing. Brief. Bioinform., l4, 5&66.

 

i363

ﬁlO'SIBHmOprOJXO'SOplZIIJJOJLIIOIQ/ﬂdnq

