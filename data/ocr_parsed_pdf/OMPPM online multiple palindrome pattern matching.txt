Advance Access Publication Date: 16 December 2015

Bioinformatics, 32(8), 2016, 1151—1157
doi: 10.1093/bioinformatics/btv738

Original Paper

 

Sequence analysis

OMPPM: online multiple palindrome pattern

matching

Hwee Kim and Yo-Sub Han*

Department of Computer Science, Yonsei University, Seoul 120-749, Republic of Korea

*To whom correspondence should be addressed.
Associate Editor: John Hancock

Received on 23 August 2015; revised on 11 December 2015; accepted on 12 December2015

Abstract

Motivation: A palindrome is a string that reads the same forward and backward. Finding palin—
dromic substructures is important in DNA, RNA or protein sequence analysis. We say that two
strings of the same length are pal—equivalent if, for each possible centre, they have the same length
ofthe maximal palindrome. Given a text Tof length n and a pattern Pof length m, we study the pal—
indrome pattern matching problem that finds all indices isuch that P and T[i — m+ 1 : i] are pal—

equivalent.

Results: We first solve the online palindrome pattern matching problem in O(mz) preprocessing
time and O(mn) query time using O(mz) space. We then extend the problem for multiple patterns
and solve the online multiple palindrome pattern matching problem in O(mkM) preprocessing
time and O(mkn+ 0) query time using O(mkM) space, where M is the sum of all pattern lengths,
mk is the longest pattern length and c is the number of pattern occurrences.

Availability and implementation: The source code for all algorithms is freely available at http://toc.

yonsei.ac.kr/OMPPM
Contact: kimhwee@cs.yonsei.ac.kr

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

Finding motifs and patterns in bio strings has been one of the most
popular topics in both computer science and biology (Adebiyi et (11.,
2001; Buhler, 2001; Parisi et (11., 2003; Priifer et (11., 2008;
Rigoutsos and Floratos, 1998). A palindrome is a string that reads
the same forward and backward. Namely, a string to is a palindrome
if to : wR, where if denotes the reversal of to. If a substring of a
string is a palindrome, we say that the string has a palindromic sub—
string or palindromic structure. It is important to find palindromes
and identify similar palindromic structures in DNA, RNA or protein
sequence analysis (Gusfield, 1997). Since palindromic structures in
bio data reflect the capability of molecules to fold and form double—
stranded stems (Kolpakov and Kucherov, 2009), bio data with simi—
lar palindromic structures may have similar secondary structures.
Moreover, palindromic sequences are closely associated with DNA
breakage during gene conversion (Krawinkel et (11., 1986), and pal—
indromic substructures are presented in CRISPR/Cas9 (Kunin et (11.,

2007), which has been used for gene editing and gene regulation in
species (Mali et (11., 2013). Therefore, it is useful to identify palin—
dromic substructures and palindromic equivalence efficiently.

We focus on the palindrome pattern matching problem intro—
duced by I et al. (2013). Given a text T of length n and a pattern P
of length m, the palindrome pattern matching problem is to find all
indices 1' such that P and T[i — m + 1 : i] have the same set of all cen—
tre—distinct maximal palindromes. See Figure 1 for an example.

I et al. (2013) presented two algorithms that solve the palin—
drome pattern matching for an arbitrary size alphabet. We notice
that both algorithms by I et al. (2013) require a preprocessing step
of T. This may slow down the whole process when T is an extremely
large text and I/O for T is considerably slow due to the large but
slow storages. Moreover, these algorithms might not be applicable if
T is a stream data. Many researchers designed online string algo—
rithms to avoid these problems, where each character in T is given
online, and we want to report intermediate results without reading

©The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 1151

 

91oz ‘Og JSanV 110 salaﬁuv 50’] ‘BtHJOJtIBQ 30 AJtSJQAtuf] 112 /3.IO'S[BHJI’101PJOJXO'SOlJBLUJOJIItth/ﬂduq 11101} popcolumoq

1152

H.Kim and Y.—S.Han

 

P =AGACUA AGACUA
---CGCUACGGAUACGAGUCC- --

%%

Fig. 1. An example of the palindrome pattern matching. Stripped boxes below
a string represent the set of all centre-distinct maximal palindromes with the
length at least 1. Note that the pattern on the left is matched, while the pattern
on the right is not matched due to the red-stripped box

whole T (Ahmad et al., 2003; Paten et al., 2009). For the palin—
drome pattern matching problem, we want to report all matching in—
dices i while reading T online. Based on the Knuth—Morris—Pratt
algorithm (Knuth et al., 1977), we first build an automaton A from
P and process T using A. For a text T of length n and a pattern P of
length m, our algorithm requires O(mz) preprocessing time and runs
in O(mn) query time using O(mz) space. We, furthermore, tackle
the online multiple palindrome pattern matching based on a modifi—
cation of the Aho—Corasick automaton (Aho and Corasick, 1975).
For multiple patterns P1,  ,Pk of length m1,  ,mk, our algo—
rithm requires O(mkM) preprocessing time and runs in O(mkn + c)
query time using O(mkM) space, where M is the sum of all pattern
lengths, mk is the longest pattern length and c is the number of pat—
tern occurrences. Note that the second algorithm considers multiple
patterns and has the same query time as the first algorithm except
the number of pattern occurrences.

2 Methods

2.1 Strings, palindromes and finite automata

A finite—state automaton (FA) A is specified by A : (Q,2,5,s, F),
where Q is a set of states, 2 is an alphabet, 5 : Q X 2 —> Q is a tran—
sition function, 5 E Q is the start state and F E Q is a set of final
states. A string u! is accepted by A if there is a labeled path from s to
a state in F such that the path spells out iii. For complete background
knowledge in automata theory, the reader may refer to textbooks
(Hopcroft and Ullman, 1979; Wood, 1986).

For a string to, let uIR denote the reversed string of w. A string u!
is called a palindrome if u! : uIR. The radius of a palindrome u! is
‘21). The centre of a palindromic substring ulli : j] of a string u! is 
A palindromic substring ulli : j] is called the maximal palindrome at
the centre  if no other palindromes at the centre  have a larger
radius than ulli : j]; in other words, if ulli — 1] 9E ullj + 1], i : 1 or
i :  Let Pals(uI) be the set of all centre—distinct maximal palin—
dromes where each element is encoded by a pair of its centre and ra—
dius (I et al., 2010). Namely, given a string to,

ullc — r + 0.5 : c + r — 0.5] isamaximal
Pals(w) : (c, a) .

palindromeatcentrec : 1,1.5,2,  ,n

For example, if u! : ahhacahhha, we have
Pals(uI) : {(1,0.5),(1.5,0),(2,0.5),(2.5,2),(3,0.5),
(3.5,0) 4,0.5),(4.5,0),(5,3.5),(5.5,0),
(6,0.5) 6.5,0),(7,0.5),(7.5,1),(8,2.5),
(8.5,1),(9,0.5),(9.5,0),(10,0.5)}.

7(
7(

For two strings u! and z of the same length, we say that u! and z
are pal-equivalent if Pals(uI) : Pals(z). Manacher (1975) proved

that for a string u! of length m, we can compute Pals(uI) in O(m)
time. From now on, we assume that the elements of Pals(uI) are
sorted in increasing order of centrers c—the algorithm of Manacher
(1975) computes the elements of Pals(uI) in this order.

We first tackle the palindrome pattern matching problem in
Definition 2.1. Note that while I et al. (2013) find start positions of
matching occurrences, we search for end positions of matching
occurrences.

Definition 2.1 (Palindrome Pattern Matching, Pal—Matching in
Short): Given a text T of length n and a pattern P of length m,
compute all positions isuch that Pals(P) : Pals(Tli — m + 1 : 

We then define the multiple palindrome pattern matching prob—
lems as follows:

Definition 2.2 (Multiple Palindrome Pattern Matching, MPal—Matching
in Short): Given a text Tof length n and patterns P1, .. . ,Pk of
length m1, . .. ,mk, compute all pairs of a position i and a corres-
ponding pattern P,- such that Pals(P,-) : Pals(Tli — m,- + 1 : 

For a pattern matching problem, we can consider an environment
where we want to report all matching occurrences at position i after
reading each character T[i]. This often requires a preprocessing step
of the pattern P—we call such a problem an online pattern matching
problem. We call the time to preprocess P preprocessing time, and the
time to read T and find all matching occurrences query time.

2.2 The algorithm for Pal—matching

We start from designing an algorithm for Pal—Matching in
Definition 2.1. The main idea of our algorithm is to design a special
automaton simulating the Knuth—Morris—Pratt algorithm (Knuth
et al., 1977). Before we design an algorithm, we have the following
observation (See Figure. 2 for an illustration): For two strings to, z
and an index i, if there exists (c, r) E Pals(uI) such that c Si and
c + r — 0.5 2 i, then zli] : z[2c — i]. If there is no (c, r) satisfying the
condition, then zli] a {z[2r — i]l(c, r) E Pals(uI) andc + r — 0.5 :
i — 1}. Note that zli] is computed based on zljl’s for j < i, instead of
characters in w. This leads us to define z to be a new sequence of
variables, where we can assign characters to variables based on
equality and inequality conditions, and the result string is pal—
equivalent to w. Based on the observation, we define a variable pat-
tern of P as follows:

Definition 2.3: For a pattern P of length m over 2 of size t, a vari—
able pattern P’ is defined by an array Alm] of variables and an array
Elm] of inequality conditions satisfying the following conditions:

1. P’li] : M1,] for 1 3131,: m.

2. If there exists (c,r) E Pals(P) where c S i and c + r — 0.5 2 i,
then I,- : l25_,-, and thus, P’ : P’[2c — i].

3. Otherwise, for all ['6 {2r — i)(c,r) E Pals(P)andc + r — 0.5 :
i— 1}, P’li] 5A P’lj]. For P’li] : Alli] and P’lj] : Alli], we use
Elli] : l,- and : i to denote P’li] 9E P’lj].

Namely, if we assign characters to A based on inequality condi—
tions, then Pals(P’) : Pals(P). Initially, we have no variables for
constructing P’. The inequality condition of Definition 2.3 implies
that for every index i where every maximal palindrome with a centre
c S i ends before i, we need to introduce a new variable satisfying in—
equality conditions with respect to the previously—used variables.
We construct an array Alm] of variables. We also construct an array
Elm] that represents the inequality conditions between all pairs of

9103 ‘Og isnﬁnv uo salaﬁuv soc} ‘BtHJOJtIBQ JO AJtSJQAtuf] 112 /3.IO'S[BIIJI’101PJOJXO'SOIJ’BLUJOJIIIOICI”Zduq 11101} papeolumoq

OMPPM

1153

 

(a) (c, r) E Pals(w) (h)
z z
|
2r 
\rl—l

(c, r) E Pals(w) f

i

 

 

2c—i c i

 

 

 

 

 

Fig. 2. Two cases in searching pal-equivalent strings. (a) There exists (0, r)
e Pals(w) such that c g i and 0+ r7 0.5 2 i. (b) There is no (0, r) satisfying
the condition. Stripped boxes represent maximal palindromes

 

 

 

 

 

 

pz|A|G|c|a|T|A| B
1 2,3,4
PI=|A.|A.|A.|A.|A.|A.| 21,3,4,5
3 1,2,4
A4¢A1,A2,A3,A5:> 4 1,2,3,5
5 2,4

 

 

 

 

Fig. 3. A variable pattern P’ and an array 113 of inequality conditions for P:
AGCGTA. Variables Ali] are written as A,- in the figure for better readability

variables. Thus, if j 6 Eli], then the condition A[i] 9E  holds. Now
we construct P’ as described in Algorithm 1. Figure 3 shows P’ and
B for P :AGCGTA.

Based on Definition 2.3, we establish the following result: after
running Algorithm 1, if there is a surjection of A to 2 where A[i]
5A  holds for all i, i such that j 6 Eli], then Pals(P’) : Pals(P).
Moreover, given a string it! such that Pals(uI) : Pals(P), there exists
a surjection of A to 2 such that P’ : to.

We analyze the time and space complexity of Algorithm 1.
Computing Pals(P) takes O(m) time. Since the for loop from line 6
to line 10 takes O(m) time and line 12 also takes O(m) time, the
time complexity of the algorithm is O(mz). For the space complex—
ity, A[m] and P’ requires O(m) space and Elm] requires O(mz) space.
Therefore, the space complexity is O(mz).

Once we have P’, we can construct a special automaton A : (Q,
AU {ﬁ},5,s,F,2,]B,5f,’l-l) that finds all occurrences of P’ in T as
follows:

' Q is the set of states,

' A is the array of variables (which is used as an alphabet in A)
and )1 is a wildcard variable,

' 5 : Q X A —> Q is the transition function,

' s is the start state,

' F is the set of ﬁnal states,

' 2 is the alphabet of the original pattern P,

' B is the array for inequality conditions of variables,

' 5f : Q —> Q is the failure transition function, and

' 'H : Q —> 2AX(AUW}) is the set of injective functions for variables.

Note that four parameters

 

2,133, 5f, ’H—are added to the defin—
ition of a traditional FA. The automaton A simulates the Knuth—
Morris—Pratt algorithm, using P’ instead of P as a pattern. In the
Knuth—Morris—Pratt algorithm, when there occurs a mismatch, the al—
gorithm uses the longest suffix of the prefix of T read so far, which is a
prefix of P’ . The automaton A simulates the process when a mismatch
occurs by 5f, and additionally, changes surjection of A to 2 according
to ’H. Algorithm 2 constructs an automaton A from P and Figure 4
shows an example automaton constructed from P : AGCGTA.

We establish the time and space complexity of Algorithm 2 as
follows: We can compute Pals(P) in O(m) time and, based on
Pals(P), line 11 takes O(m) time. Since other lines in the algorithm

 

Algorithm 1: ConstructVariablePattem
Input: Pattern P of length m over 23 of size t
Output: Variable Pattern P’, array A[m] of variables,
array Mm] of inequality conditions
1 construct A[m], lB[m] and compute Pals(P) // we insert
(0.5, O) to Pals(P) for convenience

 

2 c<—0.5,l<—0,s<—0

3 for-11(— 1tomdo

4 if I 2 ithen P, [i] <— P, [2c—i] else

5 s<—s+1,P'[i]<—A[s]

6 for each (0’, r') E Pals(P) where c S ido

7 ifc’+r’—0.5=2'—lthen

8 A[l] (— P’[i — 1]

9 A[l’] (— P’[c’ + r’ — 0.5]

10 add l/ to EU], add l to BU’]

11 ifl g ithen

12 ﬁnd c’ such that (c’,r’) E Pals(P), c’ — r’ + 0.5 S 2',

i+ 1 S c' + r' — 0.5 and c’ + r’ — 0.5 is the smallest.

13 ifc’ Si+0.5thenl<—c’+r’—0.5,c<—c’elseif

_l=2'—1thenl<—l-l—1

 

 

H

4 return P’, A, 15%

 

 

Algorithm 2: ConstructSingleAutomaton
Input: Pattern P of length 771 over 2 of size t
Output: Automaton A = (Q, A U {#}, 6, s, F, 2,13, 6f, 71)
1 ConstructVariablePattern(P)
2 add qo to Q
3 for“— 1tom+1do

 

 

4 if i aé m + 1 then

5 add q, to Q

6 _ 6(Qi717AlJ-l) <— qi for P'lil = A[J'l

7 if i = 2 then

8 (Hal) <— qo

9 _ add (A[l] <— #) to ’H(q1)

10 else if i > 2 then

11 ﬁnd the smallest 2" such that
Pals(P'[1 : i—i’D = Pals(P'[i’ : i—1])

12 6f(q,-,1) (— qi_i/

13 forl<—1toi—i’do

14 add (A[h] <— A[h’]) to ’H(q,-_1) for P’[l] = A[h]

) and P'[l+i'—l] = A[h']

15 for each A[h] in P' [1 : i—l] without injective function
in ’H(q,-_1) d0

16 L add (A[h] <— #) t0 “H(q¢—1) for A[h]

 

t—n

7 réum (em {#16, qo.{qm},2,IB, 6m)

 

A1<~A3 A1<~A2
AikAx A34—A4 Azt—AA
4.34% A4<—# Aa<—As
/ 7 — ‘ \ r ' — — 7 \ A41—
’ >: 

 

I 2"

1’

’ \ 7 4
, a \ \ \\
\ \ \
AIAQMWMA‘M
[that] ALI—£2- Alf—£2—
Aze# A2<—Aa
Asf—#

Fig. 4. An automaton A constructed from P : AGCGTA. Variables Ali] are
written as A,- in the figure for better readability. A dashed transition from a
state p is the failure transition 6,(p) and the label on the failure transition with
square brackets represents the set of injective functions H(p)

9103 ‘01; isnﬁnv uo salaﬁuv soq ‘BtHJOJtIBQ JO AnsmAtun 112 /3.IO'S[BIIJI’101PJOJXO'SOlJ’BLUJOJIIlOlq”K1111] 111011 papeolumoq

1154

H.Kim and Y.—S.Han

 

 

Algorithm 3: FindPalindromeMatching

Input: Text T of length n and pattern P of length m over 2 of

size it

Output: Indices i such that Pals(P) = Pals(T[i—m+1 : i])
1 ConstructSingleAutomaton(P)
2 fort <— 1 tom do  <— # q; <— qo // current state
3 fort <— ltondo
4 while one of the following conditions holds for
5(qlaAlJ'l) = ql+1
1-ql = (1m
2Ali] 7é T[i], #
3.A[j] = # and there exists 3" 6 EU] such that A[j'] = 
do
L for each (A[h] <— A[h']) E H(ql) do A[h] (— A[h’]

ql 4— (Wm)

ifAlJl = # then All] <— Tlil (11 <— (n+1
if q; = qm then return i

 

am

nod

 

except for loops require constant time, the total time complexity is
O(mz). For the space complexity, there are O(m) states in A. For
each state, there are one out—transition, one outgoing failure transi—
tion and O(m) injective functions. Therefore, the space complexity
is O(mz).

Now we present an algorithm that solves Pal—Matching using A.
Based on the Knuth—Morris—Pratt algorithm, Algorithm 3 processes
T in A and reports all end—indices of matching occurrences.

We analyze the time and space complexity of Algorithm 3.
Checking the condition in line 5 takes O(m) time, and the for loop
in line 6 takes O(m) time. Note that lines 5—6 runs once for one exe—
cution of line 6, where l decreases. For each i, l increases by 1 in line
7. Since I Z 0, the total runtime of the While loop from line 5 to line
6 is O(mn). Combined with Algorithm 2 in line 1, the algorithm re—
quires O(m2 + mn) time and O(mz) space. Thus, given a text T of
length n and a pattern P of length m, we can solve the online palin—
drome pattern matching problem with O(mz) preprocessing time
and O(mn) query time using O(mz) space.

2.3 The algorithm for MPal—matching

Now we extend the previous algorithm to solve MPal—Matching.
The basic idea of the algorithm is to process multiple patterns at
once with a single automaton, based on the idea of the Aho—
Corasick automaton (Aho and Corasick 1975). Assume that given
patterns P1,  ,Pk of length m1,  ,mk are sorted by ascending
order with respect to the length of the pattern and M is the sum of
all pattern lengths. For P1,  ,Pk, we first compute variable pat—
terns P’l,  ,sz, while merging all B[m,-]s to one BM It is
straightforward to show that the process, which we call
ConstructMultiVariablePattern, runs in O(mkM) time using O(m;a
M) space.

We define an automaton B : (Q,A U {(1}, 5,5,F,2,]B, 5f,’H,5p).
The definition of B is similar to the definition of A, except for an
additional parameter: The pattern suffix transition function 51, : Q
—> Q contains transitions to find multiple matching occurrences on
a single state. The automaton B simulates the Aho—Corasick algo—
rithm, using P’l, . . . ,Pga instead of P1, . . . ,Pk as patterns. Algorithm
4 constructs B from P1,  ,Pk. We use a supplementary function
StateForVP to return the state denoting the end of a given variable
pattern. Figure 5 shows an example automaton constructed from
P1 : AGA, P2 : ACTG,P3 : ATAT, P4 : TCTGC.

We analyze the time and space complexity of Algorithm 4. We
can compute Pals(P,-) in O(mi) time and, based on Pals(P,-), lines 14

  

.‘l

    

  

 

 ,[AleAz]
. / A2<—A1
.' /
.I.‘ I
30—“ ©—’A2 —Al  A” O A“ Q
+____ ____ ————
A <— A {—A A <—A g
[1 #] T424] ‘ AieAi] A14—A2 ,’ .v,’
AZFAI I 
A1<~A2 3 ’  A1<~A2
A # ’l ’3' AWAI
(— -"
3 -  A, w 42:45:
..____(: 
A1<~A2
Azt—Aa
A3<—A4
Await

Fig. 5. An automaton B constructed from P1 : AGA, P2 : ACTG,
P3 : ATAT, P4 : TCTGC. Variables A[I] are written as A,- in the figure for bet-
ter readability. Dashed transitions represent failure transitions and dotted
transitions represent pattern suffix transitions

 

Algorithm 4: ConstructMultiAutomaton

Input: Patterns P1, . . . , Pk of length m1, . . . ,mk over 2 of

size t

Output: Automaton B = (Q, AU {#}, 6, s, F, 2, 13, 6f, ’H, 61,)
1 ConsturctMultiVariablePattern(P1, . . . , Pk)
2 add q), to Q
3 p1,...,pk (—q)\
4 fori4—1tomk+1do
5
6
7

 

 

 

 

for each P; where i g m, + 1 do

let Pﬂi] 2 AU] and 12,- = q5

ﬁnd the smallest i' and corresponding j ' such that

Pals(PJC [1 : i—i']) = Pals(Pﬂil : i—1])

s ifi¢mj+1then
9 5(qsyAlll) <— qs-z
10 _ add gs.) to Q
11 if i = 2 then
12 6f (‘18) <— (IA
13 _ add (A[l] <— #) to ’H(qs)
14 else if i > 2 then
15 6f ((1,) <—StateForVP(P;,[l : i—i'])
16 forg<—1toi—i’do
17 add (A[h] (— A[h’]) to ’H(qs) for
P} [9] = A[/1] and Pil9+i'—1l = AW]
18 for each A[h] in  [1 : i—l] without injective
function in ’H(q8) do

19 L add (A[h] (— #) to 7-i(qs)
20 ifi=mj+1then
21 add qs to F
22 _ ifi — 2" = my then 6,,(pj) <—StateForVP(PJ(,)
23 _ pj (— (Is-l
24 return (Q,A U {#}, 6, q)‘, F, 2,lll§,6f,’H,6p)

 

 

Function StateForVP
Input: Variable Pattern P'
Output: State qS
l qs (— q),
2 fori <— 1 to |P’| do (1, <— qs.; for PM 2 AU] return q5

 

 

9103 ‘01; isnﬁnv uo salaﬁuv soq ‘BtHJOJtIBQ JO AJISJQAIIIH 112 /310'slcumofp1q1xo"sotJBuiJOJutotq/ﬁduq 111011 papeolumoq

OMPPM

1155

 

 

Algorithm 5: FindMultiPalindromeMatching
Input: Patterns P1, . . . , Pk of length m1, . . . ,mk over 2 of
size 15
Output: Pairs of an index i and a pattern P,- such that
Pals(Pj) = Pals(T[i—mj+1 : 
1 ConstructMultiAutomaton(P1, . . . ,Pk)
2 fort <— ltom;c doA[i] <— #111 <— q),
state
3 fori <— 1tondo
4 while one of the following conditions holds for all A[j]
such that 6(ql,A[j]) gé (ll
1.q; has no out transition
2411'] ¢ T[i], #
3.A[j] = # and there exists 3" E  such that A[j’] = 
and 5(ql,A[j]) =StateForVP(Pg’[1 : |l|+1])
5 d0
6 L for each (A[h] <— A[h’]) E 71(ql) do A[h] <— A[h’]
‘11 <— 6} (Ill)
7 ifAlJ'l = # then A[J'l <— Tlil 41 <— 5(qza Aiii)
8 if q; E F then

 

// current

9 return (i, sz) where StateForVP(PJ{/) = q;

10 PL <— q;

11 while 6,,(pl) 7E [71 do

12 P: <— 512(le

13 return (i, P,-«) where StateForVP(PJ{/) = p;

 

 

and 21 takes O(mk) time. Since other lines in the algorithm except
for loops require constant time, the main loop from lines 4 to 23
takes O(mkM) time. Therefore, the total time complexity is
O(mkM). For the space complexity, there are O(M) states in B.
For each state, there are one out—transition, one outgoing
failure transition, at most one outgoing pattern suffix transition and
O(mk) injective functions. Therefore, the space complexity is

We design Algorithm 5 similar to Algorithm 3 on B to solve
MPal—Matching with an additional process: whenever the current
state at reaches a final state qf, return all patterns that are con—
nected by 5,, from qf. This additional process requires O(c) total
runtime, where c is the number of pattern occurrences. Since the
size of ’H for each state in 113 is bounded to mk, the algorithm
requires O(mkM+mkn +c) time and O(mkM) space. Therefore,
given a text T of length n and a pattern P of length m, we can
solve the online multiple palindrome pattern matching problem
with O(mkM) preprocessing time and O(mkn + c) query time using
O(mkM) space.

3 Experiments

We design three experiments to estimate the average performance of
the algorithms. For Algorithm 3, we first establish two parameters—
the length m of the pattern and the length n of the text—and esti—
mated three values—the preprocessing time tp, the query time tq, the
number s of variables—for random DNA patterns and texts.
Second, we calculate the average number of variables for small m by
considering all possible patterns of length m. Third, for Algorithm
5, we use real RNA data as a pattern set and measure the pre—
processing time tp and the query time t, by two parameters—the
sum M of all pattern lengths and the longest pattern length mi.
The details of the experiment are as follows:

1. For the ﬁrst experiment,

' The length m of the pattern changes from 10 to 100 by 10,
and then from 100 to 1000 by 100. The length n of the text
changes from 10 000 to 100 000 by 10 000.

' For each pair of m and n, we randomly generate a pattern
and a text from an alphabet {A, G, C, T} 100 times, and cal—
culate the average value of the preprocessing time tp, the
query time t, and the number of variables 5.

2. For the second experiment, we iterate all possible strings for
1 S m S 10 and calculate the average ofs for each m.
3. For the third experiment,

' We use 24 RNA secondary structures belonging to distinct
RNA families from the Rfam database (Burge et al., 2013) as
a superset of a pattern set. The set of RNA secondary struc—
tures used is in the supplementary material.

' We use a RNA—sequence of length 100 000 from the
ArrayExpress database (Brazma et al., 2003) as a text. We
checked that each pattern in the superset does not appear in
the text, which erases the factor c from the runtime.

' We run 100 iterations. For each iteration, we ﬁrst choose a
pattern pk, and then select each pattern in the superset with
the length less than ]pk] with the probability % to form a set of
patterns for the iteration. We compute the preprocessing
time tp and the query time tq.

We obtain the following results from our experiments (note that
we have rounded our results to the nearest hundredth.):

' Preprocessing time of Algorithm 3: Figure 6 shows the prepro—
cessing time t,, of Algorithm 3 according to the length m of the
pattern (the table for the graph is in the supplementary material).

' Query time of Algorithm 3: Figure 7 shows the query time t, of
Algorithm 3 according to the length m of the pattern and the
length n of the text (tables for graphs are in the supplementary
material).

' Number of variables: In Algorithm 3, the query time is bounded to
O(ns), where s is the number of variables. Figure 8 shows the num—
ber of variables 5 according to the length of the pattern m (The table
for the graph is in the supplementary material). The data for m :
1—10 is the average of s for all possible cases, and the data from m
: 10 to m : 1000 is the average for 100 random cases.

' Pre-processing time of Algorithm 5: Figure 9 shows the prepro—
cessing time t,, of Algorithm 5, according to the sum of all pat—
tern lengths M and the longest pattern length mk.

' Query time of Algorithm 5: Figure 10 shows the query time tq of
Algorithm 5 according to the longest pattern length mi and the
sum of all pattern lengths M. We observe that t, is independent

 

 

201]
:8"; 9/“
wall.  7' )
(.15/
I-E-JF'I'AT')’
0 --‘3""'8
0 200 400 600 800 I .000

if”.

Fig. 6. Preprocessing time graph for Algorithm 3, where 10 g m g 1000. m
denotes the length of pattern and IP denotes the preprocessing time. We can
observe that tpfollows the quadratic function of m since tp : O(mz).

9103 ‘01; isnﬁnv uo salaﬁuv soq ‘BtHJOJtIBQ JO AnsraAtuf] 112 /310'sleumofp1q1xo"sotJBuiJOJutotq/ﬁduq 111011 papeolumoq

1156

H.Kim and Y.—S.Han

 

 

100

him-‘3')

 

   

— Linear Regression

 

 

 

 

 

 

 

 

 

 

 

 

 

00 0.2 0.4 0.6 0.8 1
m x n -107
1,000
E
:6 500
— Linear Regression
0U 0.2 0.4 0.6 0.8 l
m x 71 108

Fig. 7. Query time graph for Algorithm 3. m denotes the length of pattern and
IQ denotes the query time. We observe that L, is proportional to n and m since
tq : O(nm). Note that IQ for n : 10000 and m : 100 is 13.02, whereas IQ for
n : 100 000 and m : 10 is 31.56. This implies that the increase of m affects tq
less than the increase of n

 

 

0
/
400 23/“
/./e/
a: ﬂ,”
200
58/)?
ﬂ/
0
0 200 400 600 800 1,000
T11

Fig. 8. Number of variable graph, where m denotes the length of the pat-
tern and 5 denotes the number of variables used. For m : 1—10, we observe
linear increase of s as m increases. The difference of s between m and m 7 1
tends to decrease as m increases, but the difference rapidly converges
to 0.47, and we can easily approximate s : 0.47m (Note that s : 468.78 when
m : 1000.)

 

   
     

 

 

 

60
F510
Ef.‘
E
1‘51

20

(1'13); x M, £11)
_ — Linear Regression
0 0.5 1 1.5 2 2.5
mg, x M -105

Fig. 9. Preprocessing time graph for Algorithm 5. We observe that IP is pro-
portional to Mand mksince tp : O(mkM)

 

 

 

 

 

 

200
150
5100 no r" c
4.." o no  r: o o
o oo oo o o
50 g 3% $§m gas 00 c e 0
0 20 40 60 80 100 120 140
Til-k
100 O O O O
80
"5‘60
4.? 40
20 a,

 

 

is)
0
0 200 400 600 8001,0001,2001,4001,600

 

Fig. 10. Query time graph for Algorithm 5, considering rm and M. mk denotes
the length of the longest pattern, Mdenotes the sum of the lengths of all pat-
terns and t,, denotes the query time. We observe that t,, is independent
from M

 

    
    

( goback, tq)
— Linear Regression

 

 

 

 

 

 

 

 

00 0.5 1 1.5 2 2.5
105
1,500
’"‘ e
£1,000
500
o (chechall , tq)
0
0 0.5 l. 1.5 2 2.5 3 3.5
checkoll ‘ 106

Fig. 11. Query time graph for Algorithm 5, considering goback and checks/I.
gobackdenotes the number of changes on the array of variables, checks/Ide-
notes the number of pattern suffix transitions taken, and t,, denotes the query
time. This graph shows that L, is proportional to goback, which is O(mkn) but
the average value is far less than mkn and not proportional to mkn

to M but it is not clear whether or not tq is proportional to mk.
We design another experiment to determine the factor that af—
fects mk most.

' T is a randomly generated text of length 100 000. We run 1000
iterations for different sets of patterns.
For each iteration, we choose mk between 100 and 200, and gen—
erate a set of random patterns, where M is 1000.

910g ‘09 isanV no sepﬁuv s01 ‘BIIIJOJIIBO JO [fume/1111 f] 112 /810'slcumofp103xo"sotJBuIJOJutotq/ﬁduq mot} papeoIH/noq

OMPPM

1157

 

' We record the number of changes on the array of variables
(which we call gohack) and the number of pattern sufﬁx transi—
tions taken (which we call checkall).

Figure 11 shows the query time t, of Algorithm 5 according to
gohack and checkall. Theoretically, tq : O(mkn + c), the upper
bound of gohack is m1m and the upper bound of checkall is c.
This experiment shows that t, is proportional to gohack, which is
O(mkn) but the average value is far less than m1“, and not propor—
tional to min. This feature makes the algorithm much more efficient
than running pattern matching algorithms for individual pattern [2
times.

4 Conclusions

Palindromic structures are widely studied in string processing
and combinatorics and have applications in the analysis of DNA,
RNA and protein sequences. For a text T of length n and a pattern
P of length m, we have solved the online palindrome pattern
matching in O(mz) preprocessing time and O(mn) query time
using O(mz) space. Then we have extended the problem for mul—
tiple patterns P1,  ,Pk and solved the online multiple palin—
drome pattern matching in O(mkM) preprocessing time and
O(mkn) query time using O(mkM) space, where M is the sum of
all pattern lengths and mk is the longest pattern length. Note that
the algorithm for the multiple palindrome pattern matching does
not increase the query time. We performed experiments to analyze
the runtime of the algorithms, and found out that the runtime for
the multiple pattern matching is much faster than expected. We
believe that the algorithm can be efficiently used to find a struc—
tural similarity between multiple bio strings. Since the online mul—
tiple palindrome pattern matching is first proposed in the paper,
our future work includes reducing time and space requirement of
the algorithm. Moreover, we believe that the approach to solve
the multiple pattern matching based on the Aho—Corasick au—
tomaton can be applied to pattern matching problems considering
other structural equivalences.

Acknowledgements

We wish to thank the referees for the careful reading of the paper and many
valuable suggestions including relevant references.

Funding

This work was supported by the Basic Science Research Program through
National Research Foundation funded by MEST [2015R1D1A1A01060097],
Yonsei University Future-leading Research Initiative of 2015 and the

National Research Foundation Grant funded by the Korean Government
[NRF—2013—Global Ph.D. Fellowship Program to H.K.].

Conﬂict of Interest: none declared.

References

Adebiyi,E.F. et al. (2001) An efﬁcient algorithm for ﬁnding short approximate
non-tandem repeats. Bioinformatics, 17, 55—512.

Ahmad,S. et al. (2003) RVP-net: online prediction of real valued accessible sur-
face area of proteins from single sequences. Bioinformatics, 19, 1849—1851.
Aho,A.V. and Corasick,M.J. (1975) Efﬁcient string matching: an aid to biblio-

graphic search. Commun. ACM, 18, 333—340.

Brazma,A. et al. (2003) ArrayExpress—a public repository for microarray gene
expression data at the EBI. Nucleic Acids Res., 31, 68—71.

Buhler,J. (2001) Efﬁcient large-scale sequence comparison by locality-sensitive
hashing. Bioinformatics, 17, 419—428.

Burge,S.W. et al. (2013) Rfam 11.0: 10 years of RNA families. Nucleic Acids
Res., 41, 226—232.

Gusﬁeld,D. (1997). Algorithms on Strings, Trees, and Sequences: Computer
Science and Computational Biology. Cambridge University Press,
Cambridge, UK.

Hopcroft,J.E. and Ullman,J.D. (1979). Introduction to Automata Theory,
Languages, and Computation. Addison—Wesley, Boston, USA.

I,T. et al. (2010). Counting and verifying maximal palindromes. In:
Proceedings of the 17th International Conference on String Processing and
Information Retrieval, pp. 135—146.

I,T. et al. (2013). Palindrome pattern matching. Theor. Comput. Sci., 483,
162—170.

Knuth,D.E. et al. (1977). Fast pattern matching in strings. SIAM ]. Comput.,
6, 323—350.

Kolpakov,R. and Kucherov,G. (2009) Searching for gapped palindromes.
Theor. Comput. Sci., 410, 5365—5373.

Krawinkel,U. et al. (1986) Palindromic sequences are associated with sites
of DNA breakage during gene conversion. Nucleic Acids Res., 14,
3871—3882.

Kunin,V. et al. (2007) Evolutionary conservation of sequence and secondary
structures in CRISPR repeats. Genome Biol., 8, R61.

Mali,P. et al. (2013) Cas9 as a versatile tool for engineering biology. Nat.
Methods, 10, 957—963.

Manacher,G. (1975) A new linear-time “on—line” algorithm for ﬁnding the
smallest initial palindrome of a string. ]. ACM, 22, 346—351.

Parisi,V. et al. (2003) STRING: ﬁnding tandem repeats in DNA sequences.
Bioinformatics, 19, 1733—1738.

Paten,B. et al. (2009) Sequence progressive alignment, a framework for prac-
tical large—scale probabilistic consistency alignment. Bioinformatics, 25,
295—301.

Prufer,K. et al. (2008) PatMaN: rapid alignment of short sequences to large
databases. Bioinformatics, 24, 1530—1531.

Rigoutsos,I. and Floratos,A. (1998) Combinatorial pattern discovery in biolo-
gical sequences: the TEIRESIAS algorithm. Bioinformatics, 14, 55—67.

Wood,D. (1986). Theory of Computation. Harper 8c Row, New York City,
USA.

9103 ‘Org isanV uo salaﬁuv soq ‘BtHJOJtIBQ JO AJISJQAIIIH 112 /310'sleu1nofp1q1xo"sorreuiJOJutotq/ﬁduq 111011 papeolumoq

