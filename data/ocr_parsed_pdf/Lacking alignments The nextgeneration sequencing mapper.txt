BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

C.Otto et al.

 

 
     
 

bisulﬁte
data?

 

 

 

 

 

 

 

 

 

 
 
  

 
 
  
  

 

 

 

 

     
   

 

 

 

 

 

    

CIT -oollapsed G/A—collapsed sufﬁx array
alphabet alphabet seed search engine
I l l
bisulﬁte exten- bisulﬁte exten- bitvector-based
sion for on sion for G/A semI—global allgnment
"-7- ---I s lit
i b'su'ﬁ‘e i opt'ilon?
merging I __.__I
"""" " Yes : best :
________ __ | seed }
yes valid?
no -------- “
unmapped alignments alignments unmapped
reads SAM format) (SAM format)
.‘rv'aﬁw'aBBﬁﬁ'l
.___..___ I by lack I
: bisulflte I """"" '-
'_°_a_'"_"§__l
methylation rates alignments unmapped
(VCF format) (SAM format) reads

 

Fig. 1. Workﬂow of segemehl and lack. segemehl is able to align
paired and unpaired DNA-seq, RNA-seq and bisulﬁte-treated DNA-seq
data. Previously unmappped reads can be rescued with lack

First, we measured the sensitivity and the number of false posi—
tive (FP) alignments for each program in ﬁnding ‘at least one’
optimal hit (any—best) with respect to the unit edit distance. The
second benchmark measured the performance in ﬁnding ‘all’
optimal hits (all—best). The tests were carried out on different
datasets comprising simulated and real DNA— and RNA—seq
datasets from Illumina and 454 sequencing technologies.
Simulated data was generated using Mason (Holtgrewe, 2010).
For the case of Illumina, we evaluated short (~22730 nt) as well
as long (~100 nt) sequencing reads. The median length of 454
reads was 407 nt for simulated and 524 nt for read 454 data. To
obtain the complete set of optimal alignments, we used Razers
3 (Weese et al., 2012). Using a classical pigeonhole principle, the
algorithm of Razers 3 reportedly guarantees to find all optimal
alignments (up to a given maximum number) with an edit dis—
tance (mismatches + insertions + deletions) of less than or equal
to k. Because of the relatively long computation times for the full
sensitivity alignment, it was necessary to sample a smaller set of
reads, ~105, for each dataset and estimate sensitivity and number
of false positive alignments from this sample (see Section 4 and
Supplementary Material).

All aligners were benchmarked both with their default param—
eters and with parameter settings optimized for sensitivity and
number of false positive alignments, respectively.

The evaluation with default parameters shows that their per—
formance varied quite strongly with length and type of the input.
Nevertheless, segemehl performed better with respect to sensi—
tivity and number of false positive alignments than most of the
other tools (Fig. 2A). In the case of Illumina reads, segemehl
achieved the highest sensitivity for simulated reads as well as real

DNA— and mRNA—seq reads. At the same time, it reported the
lowest number of sub—optimal alignments with mRNA—seq data
(Fig. 2A). This is also the case for paired—end mRNA—seq data.
In all—best benchmarks, it outperformed all other tools tested in
terms of sensitivity while maintaining low false positive rates
(Supplementary Fig. S1 and Table S3). In any—best benchmarks,
a better sensitivity was only achieved by BWA—MEM on Illumina
paired—end DNA—seq data and BWA on Illumina shortRNA—seq
data (Supplementary Fig. S2 and Table S3) with 0.1 and 5%
increase, respectively. In the latter case, BWA reported 80%
more false positive alignments as compared to segemehl.
While segemehl performed similarly well in the all—best and
any—best scenarios, relatively large differences can be observed
for Bowtie 2, BWA and BWA—MEM since their default parameters
are presumably tailored to find one instead of all optimal align—
ments with signiﬁcant effects on the run time.

A larger difference among the read aligners can be observed in
Illumina short—read and 454 data (Supplementary Figs S1 and
S2). In the ﬁrst case, segemehl’s closest competitor was BWA,
which, however, achieved low sensitivities in most of the Illumina
single—end benchmarks. In all 454 scenarios, segemehl and
BWA—MEM turned out to be the best aligners among the tested
tools.

To explore the trade—off between sensitivity and the number of
false positive alignments, benchmarks with different parameter
settings were carried out. For each tool, we selected those par—
ameter sets with highest sensitivity and lowest number of false
positive alignments. Regardless of evaluation type (all—best or
any—best) and parameter setting (default, best—sensitivity, best—
FP), the sensitivities of segemehl exceeded 99% in all datasets
except for shortRNA—seq (Supplementary Figs SliS2 and Tables
S37S5) where segemehl still achieved the best or second—best
results (>9l%). In the comparison of best—FP parameter settings,
segemehl performed best or second—best in terms of number of
false positives in seven out of 10 datasets. The closest competitor
of segemehl with best—sensitivity settings was GEM despite some
performance issues with paired—end data. Apart from
segemehl, several aligners (BWA—MEM, BWA, GEM) showed
good performances with best—FP parameter settings, depending
on the dataset used. In terms of number of mapped reads,
segemehl performed comparable or better than the other
tools tested (Supplementary Tables S37S5).

The performance of segemehl in terms of sensitivity and
false positive rate came at the cost of higher running times and
memory consumption. With default parameters, segemehl was
on average slower than the competitors. STAR was the fastest
tool in this benchmark (Fig. 2B). Using best—sensitivity settings,
however, the running times of several aligners including Bowtie
2, BWA, GEM, became signiﬁcantly longer (Supplementary Fig. S3
and Table S4). The peak virtual memory footprint of segemehl
(70 GB) was higher than that of STAR (28 GB) and the other
aligners (376 GB). Unexpectedly, the memory consumption of
GEM depended on its parameter values, strongly varying in the
benchmarks with best—sensitivity settings (#70 GB). Note that
we compared the virtual memory consumption. The required
physical memory is considerably smaller. For large mammalian
genomes, segemehl may not be feasibly applied on computers
with <50 GB of memory. The memory consumption of
segemehl is considerably smaller for smaller genomes:

 

1838

ﬁm'spzumol‘pmﬂo'sopeuuopnorq/ﬁdnq

Bowtie 2 (b0)

v BWA/BWA—SW (bw)

BWA—MEM (bm)

GEM (ge)

segemehl (se)

STAR (st)

 

/3.IO'S[BIIJI’10[pJOJXO"SOIJBLUJOJIIIOIq/ﬂdnq

split unsplit

remapped

unmapped

 

55,2kgogmoddmmowoio~&o:~=£¢o~m\

 

 

 

 

 

 

.a

 

 

 

The next-generation sequencing mapper segemehl revisited

 

junctions are allowed. This particularly took effect in case of long
454 reads.

In terms of running time, lack is on average between 4— and
32—fold times faster than segemehl, TopHat 2 or Blat but
14—fold slower than STAR (Supplementary Fig. S5A). The mem—
ory consumption of lack is ~6.3 GB for each dataset
(Supplementary Fig. S5B). It is lower than the consumption of
segemehl and STAR and in the ballpark of the memory foot—
print of other tools.

3 DISCUSSION

In this article we show that segemehl is a versatile and accurate
read aligner that performs equally well for reads from DNA— and
RNA—seq experiments and is largely independent of read length
and technology. Since the initial publication, segemehl has
been continuously updated and extended. Here, we have focused
updating segemehl’s performance in aligning DNA—seq or
unspliced RNA—seq reads. While the core algorithms remained
unchanged, we have adjusted several parameterizations to opti—
mize the tool. Our results indicate that segemehl is not only
more sensitive in ﬁnding the optimal alignment with respect to
the unit edit distance, but also very speciﬁc compared to the most
commonly used alternative read mappers. These advantages are
observable for both real and simulated reads.

In addition, we have presented lack to rescue previously un—
mapped RNA—seq reads that have emerged from splicing events.
It shows excellent performance for every dataset with all split—
read aligner tested and hence represents a valuable extension to
RNA—seq analysis pipelines.

4 METHODS

4.1 Comparison of read aligners

In total, 10 datasets were used for benchmarking: three datasets with long
single-end Illumina reads (artiﬁcial, DNA-seq, mRNA-seq), three with
long paired-end Illumina reads (artiﬁcial, DNA-seq, mRNA-seq), two
with short single-end Illumina reads (artiﬁcial, shortRNA-seq) and two
with 454 reads (artiﬁcial, DNA-seq). An overview of the benchmarking
datasets, their sequencing platforms, library types and average read
lengths is given in Supplementary Table Sl. Details about simulations
and read data preprocessing are given in the Supplementary Material.

For benchmarking, we compared segemehl v.0.l.7 to ﬁve read
aligners: Bowtie 2 v.2.l.0, BWA/ BWA—SW v.0.7.4 (Li and Durbin,
2009, 2010), BWA—MEM v.0.7.4 (Li, 2013), GEM pre-release 3 (Marco-
Sola et al., 2012) and STAR v.2.3.0e (Dobin et al., 2013). The aligners
were run on all datasets while keeping track of the user time and peak
virtual memory consumption. Note that user time measurements did not
include the preprocessing time for building the index structures of the
reference, required by each aligner. In case of BWA where separate com-
mands for alignment (aln) and post-processing the intermediate align-
ments (samse/ sampe) were executed, time and memory were measured
to include both commands. For 454 datasets, as recommended by the
authors, BWA was exchanged by BWA—SW and Bowtie 2 was run in
local mode. If necessary, the output of the aligners was converted
into SAM format (Li et al., 2009).

Since our benchmark only considered optimal alignments with respect
to the unit edit distance, a best-only ﬁlter was applied to the output of all
tools. In case of paired-end alignments, the optimal alignment was
deﬁned as a properly paired alignment with the minimum sum of the
edit distances in the ﬁrst and second mate. In some cases, aligners report

local instead of semi-global read alignments, marked by soft-clipped
bases. To apply the best-only ﬁlter in these cases, local alignments were
treated as semi-global ones by considering soft-clipped bases as errors. In
addition to the default parameters, we evaluated a number of different
parameter settings for each aligner (analogously to Langmead and
Salzberg, 2012) to explore the tradeoff between sensitivity and number
of false positive alignments (Supplementary Table S2). In such a way,
best-sensitivity and best-false positive parameter settings were selected for
each read aligner and dataset.

To obtain the set of optimal read alignments, Razers 3 v.3.l was
applied to each dataset in its full-sensitivity mode. More speciﬁcally,
Razers 3 was run with the parameters —r 100, —i 90, —dr 0, —m
10, —pa, —ds and —of sam. Given a maximum edit distance and max-
imum number of optimal alignments per input, it guarantees to ﬁnd all
optimal alignments satisfying these constraints. For the paired-end data,
Razers 3 was not executed in paired-end but in single-end mode on both
ends separately. Reads with >10 alignments or alignments with an error
rate> 10% were discarded and not considered in all subsequent statistics.
Subsequently, concordant optimal single-end alignments with insert sizes
between 250 and 500 nt were paired and added to the test set. This strat-
egy ensured that both alignments of a pair were optimal itself and the
insert size constraint was always fulﬁlled. In this way, no aligner is put at
a disadvantage because it favors paired-end alignments with lower edit
distance but out-of-range insert sizes.

An alignment was considered optimal if a similar alignment was re-
ported by Razers 3 with the minimum edit distance on the same
chromosome, strand and almost identical position. We permitted a devi-
ation of twice the alignment edit distance from the position of the align-
ment reported by Razers 3. Otherwise, the alignment was marked
sub-optimal.

For the all-best benchmarks, the sensitivity was calculated as the nor-
malized number of optimal read alignments. The normalization corrected
for reads with multiple equivalent alignments, i.e. each optimal read
alignment counted as l/n with n being the total number of optimal
read alignments of this read. The number of false positives was given
by the number of sub-optimal read alignments. To compare read aligners
that report multiple alignments per read to those that report only a single
alignment in the any-best scenario, we randomly selected one single-/
paired-end alignment per read. For the any-best benchmarks, the sensi-
tivity and the number of false positives was given by the number of
optimal and sub-optimal read alignments, respectively. In case of
paired-end data, the alignments of both mates were evaluated separately.
In addition to sensitivity and number of false positive alignments, we
assessed the number of mapped reads of each aligner. To assure com-
patibility of local and semi-global alignments, only reads with at least one
alignment with 510% mismatches, indels and clipped bases were
considered.

4.2 Algorithm of lack

lack tries to rescue unmapped RNA-seq reads. In brief, it starts from a
seed alignment and iteratively extends it across potential splice junctions.
Subsequently, the read is aligned to the loci given by the extension path
using a transition alignment (Hoffmann et al., 2014). In the following, the
algorithm of lack is described in detail.

Initially, the splice junction data base is built up from split-read align-
ments provided by the user. Regardless of splice site consensus motifs and
strandedness of the alignments, the genomic locations of read splits are
clustered and categorized into types L and R (Fig. 4A). For reads that are
mapped to the plus strand, type L sites denote ‘donor’ sites while type R
sites denote ‘acceptor’ sites. For reads that are mapped to the minus
strand, it is the other way round. Subsequently, clusters are linked ac-
cording to the split read information, i.e. two clusters A and B are linked
if a split-read alignment from locus A to locus B (or B to A) exists. Thus,
for each cluster we obtain one or more cluster junctions. Note that for

 

1841

ﬁm'spzumol‘pmjxo'sopeuuopnorq/ﬁdnq

55,2kgogmoddmmowoio~&o:~=£¢o~m\

 

The next-generation sequencing mapper segemehl revisited

 

Langmead,B. et a]. (2009) Ultrafast and memory—efﬁcient alignment of short DNA
sequences to the human genome. Genome Biol, 10, R25.

Li,H. (2013) Aligning sequence reads, clone sequences and assembly contigs with
BWA—MEM. urXiv preprint arXiv:1303.3997.

Li,H. and Durbin,R. (2009) Fast and accurate short read alignment with Burrows—
Wheeler transform. Bioinformutiex, 25, 17544760.

Li,H. and Durbin,R. (2010) Fast and accurate long—read alignment with Burrows—
Wheeler transform. Bioinformutiex, 26, 5897595.

Li,H. et a]. (2009) The sequence Alignment/Map format and SAMtools.
Bioiriﬂrnmticx, 25, 207872079.

Marco—Sola,S. et a]. (2012) The GEM mapper: fast, accurate and versatile alignment
by filtration. Nut. Methods, 9, 118571188.

Otto,C. et a]. (2012) Fast and sensitive mapping of bisulfite—treated sequencing data.
Bioiry’ormuticx, 28, 169871704.

Smith,A. et a]. (2009) Updates to the RMAP short—read mapping software.
Bioiry’ormuticx, 25, 284172842.

Weese,D. et a]. (2012) RazerS 3: faster, fully sensitive read mapping. Bioinformutiex,
28, 259272599.

 

1843

/810'sleumofp103xo"soiJBuIJOJuioiqﬂ:duq

