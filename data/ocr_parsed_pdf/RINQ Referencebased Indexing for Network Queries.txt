Vol. 27 ISMB 2011, pages i149—i158
doi:10. 1 093/bioinformatics/btr203

 

RINQ: Reference-based Indexing for Network Queries

G nhan G |soy* and Tamer Kahveci*

Computer and Information Sciences and Engineering Department, University of Florida, Gainesville, FL 32611, USA

 

ABSTRACT

We consider the problem of similarity queries in biological network
databases. Given a database of networks, similarity query returns
all the database networks whose similarity (i.e. alignment score) to
a given query network is at least a specified similarity cutoff value.
Alignment of two networks is a very costly operation, which makes
exhaustive comparison of all the database networks with a query
impractical. To tackle this problem, we develop a novel indexing
method, named RINQ (Reference-based Indexing for Biological
Network Queries). Our method uses a set of reference networks
to eliminate a large portion of the database quickly for each query.
A reference network is a small biological network. We precompute
and store the alignments of all the references with all the database
networks. When our database is queried, we align the query network
with all the reference networks. Using these alignments, we calculate
a lower bound and an approximate upper bound to the alignment
score of each database network with the query network. With the
help of upper and lower bounds, we eliminate the majority of the
database networks without aligning them to the query network.
We also quickly identify a small portion of these as guaranteed
to be similar to the query. We perform pairwise alignment only for
the remaining networks. We also propose a supervised method to
pick references that have a large chance of filtering the unpromising
database networks. Extensive experimental evaluation suggests that
(i) our method reduced the running time of a single query on a
database of around 300 networks from over 2 days to only 8 h; (ii) our
method outperformed the state of the art method Closure Tree and
SAGA by a factor of three or more; and (iii) our method successfully
identified statistically and biologically significant relationships across
networks and organisms.

Contact: ggulsoy@cise.ufl.edu; tamer@cise.ufl.edu
Supplementary information: Supplementary data are available at
Bioinformatics online.

1 INTRODUCTION

With the advances in biotechnology and high-throughput computing,
the amount of data describing the interactions among molecules
has increased greatly in recent years. Depending on the types of
interactions, these data are expressed through various models such
as metabolic (Francke et al., 2005), gene regulatory (Levine and
Davidson, 2005) or protein interaction (Giot and Bader et al.,
2003) networks. The term pathway is also used in the literature
to describe a part of them. In this article, we will use the term
biological network to describe a collection of these interactions.
Understanding biological networks has been one of the main goals
of biological sciences as they contain key information regarding

 

*To whom correspondence should be addressed.

how organisms work. To achieve this goal, biological networks
are analyzed in a number of ways. One of them, comparison-
based analysis, identiﬁes similar parts of two biological networks
by aligning them. Such analysis has been successfully used for
ﬁnding functional annotations (Clemente et al., 2006), identifying
drug targets (Sridhar et al., 2007), reconstructing metabolic networks
from newly sequenced genome (Francke et al., 2005) and building
phylogenetic trees (Clemente et al., 2005).

Aligning two biological networks is a computationally
challenging problem. Existing methods often map this problem to
subgraph isomorphism problem. For this problem, there are no
known polynomial time algorithms which guarantee to produce
the optimal alignment. A number of methods aim to ﬁnd
approximate (Dost et al., 2008; Pinter et al., 2005; Shlomi et al.,
2006) or heuristic (Ay and Kahveci, 2010; Ay et al., 2009; Liao
et al., 2009) results in practical time. However, they still require a
signiﬁcant amount of time.

Computational difﬁculty of biological network alignment
becomes apparent when we need to align a query network with
a database of biological networks. To test this, we downloaded
297 networks from KEGG (Ogata et al., 1999). These networks
had 16—120 genes (i.e. nodes) and 17—165 edges. We aligned the
networks in the dataset with a set of 50 query networks using the
QNet algorithm (Dost et al., 2008). Each of these query networks
had seven nodes. Average processing time for a single query network
was over 2 days on a single processor. The same experiment for eight
node queries took more than a week for a single query network. In
this article, we aim to align a query network with a database of
networks efﬁciently. Formal deﬁnition of our problem is as follows:
PROBLEM DEFJNITION: Assume that we have a database of n biological
networks denoted by D ={d1,d2, ...,d,, }, where dl- is the i-th network
in our database. Also, we are given a query network denoted by (1.
Let us denote the alignment score between (1 and dl- (dl- ED) with
sim(q,dl-). Given a similarity cutoﬁ’ e, similarity search returns all
the database networks dl- that satisfy sim(q. di) 2 6. We aim to reduce
the processing time of similarity searches in biological network
databases to a practical level. El

A number of variants of the problem of aligning two networks
have been considered in the literature (Ay and Kahveci, 2010; Dost
et al., 2008; Kelley et al., 2004; Liao et al., 2009; Shlomi et al.,
2006). However, there has been a limited number of studies on
similarity searches in network databases (Giugno and Shasha, 2002;
He and Singh, 2006; Mongiovi et al., 2010; Yan et al., 2004).
Although these methods work well for speciﬁc types of network
databases, they are not well suited for biological network databases
which is the problem considered in this article. This is mainly
because they often use an overly simpliﬁed similarity measure
for network alignment. When used with costly biological network
alignment tools, the time complexity of these indexing methods
become impractical. We elaborate on previous works in Section 2.

 

© The Author(s) 2011. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non—Commercial License (http://creativecommons.org/licenses/
by—nc/2.5), which permits unrestricted non—commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.

112 /3.Io's[Bumo[pJOJXO'sorwurJOJurorqﬂ:duq mot} pQPBOIHMOG

9103 ‘Og anﬁnv uo ::

G.G lsoy and T.Kahveci

 

Contributions: In this article, we develop a reference-based indexing
method to answer similarity queries in biological network databases
efﬁciently. We call this method Reference-based Indexing for
Biological Network Queries (RINQ). The main advantage of this
method is its independence of the pairwise network alignment
algorithm the database employs. Brieﬂy, RINQ works as follows.
First, we choose a small set of networks to use as reference networks.
We align all the reference networks with the networks in our
database, and store all the alignment mappings and scores. These
steps are performed ofﬂine. After these two steps, our database is
ready to accept queries. Given a query (1 and a similarity cutoff 6,
instead of aligning q with all the database entries, we align it with
the reference networks. Using these alignments and the precomputed
alignments between reference and database networks, we compute a
lower bound and an approximate upper bound for sim(q, d,) for each
database network di. We will refer to these upper and lower bounds
as UB(q,dl-) and LB(q, di), respectively. Computing upper and lower
bounds take much less time than aligning the query network with
the database networks. Depending on the values of the upper and
lower bounds, we may encounter one of the following three cases.

0 Case 1: (Filter Set) UB(q,dl-) <6
0 Case 2: (Result Set) 6 §LB(q,dl-)
0 Case 3: (Twilight Zone) LB(q,dl-) < e f UB(q,dl-)

We can interpret these cases as follows. The ﬁrst case means that
sim(q,dl-) <6. We ﬁlter such database entries. Second case implies
sim(q, d,) > e, which is what we are looking for. We can directly add
such dl- to our result set. For the database networks dl- that fall into
the third case, the value of sim(q, d,) is unclear. We align q with such
(1) to ﬁnd their actual similarity value. In other words, we perform
the costly network alignment algorithm only for the networks that
fall into the third case. Our experiments suggest that

(l) RINQ ﬁlters up to 80% of the database entries depending on
the given similarity cutoff and the query.

(2) RINQ is signiﬁcantly faster and more accurate than the
existing methods including SAGA (Tian et al., 2007) and
CTree (He and Singh, 2006).

(3) The alignments returned by RINQ are statistically signiﬁcant
and biologically relevant.

Rest of the article is organized as follows. Section 2 discusses
the previous works related to our problem. Section 3 elaborates on
RINQ. Section 4 presents our experimental results. Section 5 brieﬂy
concludes the article.

2 RELATED WORK

Most of the existing work on comparing biological networks
focus on alignment of a pair of networks. This problem is the
ﬁmdamental building block of the similarity search problem
considered in this paper. However, aligning even a single pair
of networks is a computationally difﬁcult task. To alleviate
this difﬁculty, a number of methods in the literature restricted
alignments to speciﬁc topologies or network sizes. For example,
PathBLAST (Kelley et al., 2004) and QPath (Shlomi et al.,
2006) align linear pathways with protein interaction networks.
Pinter et al. devised an algorithm which can align queries of tree
networks with a multisource tree network (Pinter et al., 2005).

QNet uses a color-coding algorithm to align trees or bounded
treewidth networks with any network with provable conﬁdence
values (Dost et al., 2008). To evaluate the performance of QNet,
we aligned a set of seven node query networks with a database of
gene regulatory networks using our implementation of the QNet
algorithm. We downloaded all the gene regulatory networks from
KEGG (Ogata et al., 1999) that had more than 15 nodes in our
local database. There were 297 such networks (See Tables 3,
4 in Appendix II in Supplementary Material). When we set the
conﬁdence value to 99%, the average running time to align a
single query network with all database networks exhaustively took
over 2 days. Even after we reduced the conﬁdence to 90%, the
running time for exhaustive search was still 1 day. A number of
other approaches exist to speed up for pairwise network alignment
problem. NetMatch (Ferro et al., 2007) and NetGrep (Banks
et al., 2008) allow user to deﬁne queries with speciﬁc node
features. Then they use fast approximate algorithms to match
the user-deﬁned queries. Heuristic methods aim to solve the
alignment problem faster without providing a conﬁdence value
(Ay and Kahveci, 2010; Bruckner et al., 2009; Liao et al., 2009).
However, despite all these efforts, the running time still remains to
be a bottleneck.

Several indexing methods for similarity searches in graph
databases exist. Majority of these methods can be classiﬁed as
feature-based indexing methods. These methods start by picking
speciﬁc features of the networks for ﬁltering purposes. Grathrep
chooses paths as index feature (Giugno and Shasha, 2002). gIndeX
uses frequent subgraphs for the same purpose (Yan et al., 2004).
SAGA uses fragments of database networks and tries to combine
them together to ﬁnd larger matches (Tian et al., 2007). These
methods focus on ﬁnding exact matches of a given query in
the database. SIGMA is another feature-based indexing method
that concentrates on the problem of inexact matching in graph
databases (Mongiovi et al., 2010). Another method for graph
database indexing is Closure-Tree (CTree) (He and Singh, 2006).
Closure-Tree organizes the networks in the database using a binary
tree structure. It places each database network at a different leaf node
in this tree. Each internal node in this tree is a hypothetical network
that is obtained by aligning the two networks corresponding to its
children nodes. An interesting property of the CTree is the following.
The score of the alignment of any query network with an internal
node is at least as much as that with a leaf node rooted at that
internal node. Following from this, given a query network, closure
tree algorithm starts aligning query to the root node. It then proceeds
to the children nodes. It prunes an entire subtree rooted at an internal
node, if the alignment to that internal node has a score less than the
given cutoff.

Existing graph database indexing methods work well when each
database network is small or the underlying similarity measure is not
expensive. However, these two properties do not hold for biological
network databases such as metabolic and gene regulatory networks.
As a result, when they are applied to these networks, either the index
construction time becomes impractical or the amount of performance
gained becomes too small. For instance, when a costly dynamic
programming method, such as QNet (Dost et al., 2008), is used
to summarize sets of networks accurately in the CTree method,
computing the summary for even a single internal node can take
more than 1 month for networks with more than 12 nodes. On the
other hand, the method we develop in this article allows querying

 

i150

112 /3.Io's[BumoIpJOJXO'sorwurJOJurorq”:duq mot} papBOIII/lAOG

9103 ‘Og anﬁnv uo ::

RINQ

 

databases with networks of arbitrarily large number of nodes.
We provide an experimental comparison of our method with SAGA
and CTree in Section 4.3.

3 ALGORITHM

In this section, we explain the indexing method we developed for
querying biological network databases. We ﬁrst describe the notation
we use in the rest of this article. We denote the database of n
biological networks with D={d1,d2, ...,d,,}. Here, dl- represents the
i-th network in the database. As we will explain later, our algorithm
uses a set of reference networks. We denote the set of m candidate
references with C ={c1,c2,...,cm}. In this representation, each C,-
corresponds to a candidate reference network. We denote the actual
set of references with R={r1,r2, ..., rk}, where Rg C. To simplify
our notation, we will drop the subscript and use d, r or c to represent
di, rl- or ci, respectively, whenever possible. We will represent a
query network with q. We use q[j], c[j], r[j] and d[j] to refer to the
j—th node in respective networks.

An alignment is a mapping between the nodes of two networks.
Let us represent the mapping between q and d with f3. Then, f3(q[i]) =
d[j] means that q[i] is aligned to d[j]. Note that all these mappings
are one to one and symmetric. In other words, if f3(q[i]) =d[j], then
f3(d[j]) =q[i]. When a node q[i] is not aligned to any node in d (i.e.
insertions or deletions), we will use the notation f3(q[i])=l(l. The
similarity score between two nodes q[i] and d[j] is represented as
sim(q[i],d[j]). Let Ed and Eq be the set of edges (i.e. interactions)
of d and q, respectively. Let us denote the function that returns the
weight of an edge in Ed with EWd. Given a mapping f3 between q
and d, the individual node similarities between q and d, we calculate
the similarity score sim(q,d) as:

sinned) = Z simrqtimmrim
ﬁ(q[i])#®
+ Z InDel Penalty
ﬁ(q[i])=l?l

+ Z

(13(qul),/3(Ll[il))€Ed
AND (qulngil)€Eq

Ell/11039110150011»-

The organization of the rest of this section is as follows.
In Section 3.1, we provide an overview of reference-based indexing.
We elaborate on our reference selection method in Section 3.2.
Finally, in Section 3.3, we explain the calculation of the lower and
upper bounds we use for RINQ.

3.1 An overview of our reference-based indexing

RINQ has two major steps, namely index creation and query
processing. We create index once as a preprocessing step in two
phases. In the ﬁrst phase, we create a large set of candidate references
from the database networks. In the second phase, we pick a subset
of these candidates as the actual reference set by considering their
performance over a set of training queries. In our index, we store the
alignments between all the reference and database network pairs.
Once the index is created, we are ready to answer similarity
queries on our database. Given a query network q, we align q with the
reference networks in R rather than the database networks. Usually,
the cost of these alignments is negligible since R contains much
fewer and smaller networks than D. For each dj ED, we compute

a lower bound and an approximate upper bound to the similarity
score between q and dj. We do this by using the alignments of the
references to q and  We denote these lower and upper bounds by
LB(q,dj) and UB(q,dj), respectively.

Using the lower and upper bound values, we classify each  in
one of the following three sets: ﬁlter set, result set or twilight zone. If
UB(q, (1]) < e, the alignment score between q and dj cannot be larger
than 6. We put such  in ﬁlter set. We eliminate the networks in the
ﬁlter set without ﬁirther calculation. If e f LB(q,dj), it means  has
an alignment score which is deﬁnitely larger than 6. So dj should
be in the set we return as the result of our query. We place such dj
in the result set. Finally, if LB(q,dj) < e f UB(q,dj), the bounds do
not imply anything about the network being in the result set or the
ﬁlter set. We place such dj in the twilight zone. For the entries in
the twilight zone, we need to calculate the actual alignment scores
to decide if we can place them in the result set. Since aligning
two networks is a costly operation, we would like to have as few
networks in the twilight zone as possible.

We discuss how we create the reference set in Section 3.2. We
defer the discussion on the lower and upper bound computations
using references to Section 3.3.

3.2 Reference selection

The success of our method depends greatly on the reference set.
Ideally, a reference set should contain reference networks from
which we can construct a network that is similar to the given
query network. This section describes how we choose our reference
networks for our database with the help of a training query set.
Brieﬂy, we select references in two phases. In the ﬁrst phase, we
quickly generate a set of promising references. In the second phase,
we carefully examine these candidates and choose a subset of them
that has maximal performance on the training queries.

3.2.] Phase 1: creating the candidate reference set. Ideally the
reference set in our database should satisfy the following properties:

Property 1. (SMALL) Each reference network should have a small
number of nodes.

Property 2. (COMPREHENSIVE) At least one reference should align
well with any database network.

Property 3. (NON-REDUNDANT) Each reference network should
differ from the rest signiﬁcantly.

The ﬁrst property above ensures that the query aligns with each
reference quickly. The second property ensures that it is possible
to ﬁnd tight lower and upper bounds for any query that aligns well
with a reference network. If two references are highly similar, then
the lower and upper bounds computed through them will be similar
regardless of the query network. Thus, one of them is sufﬁcient to
compute the bounds. The third property avoids such redundancy.

In order to satisfy the ﬁrst rule, we set the size (i.e. the number
of nodes) of each reference network to that of the largest query
allowed. Let us denote this number with T. We use T=6, 7 or 8 in
our experiments. Using small T ensures Property 1 described above.
Following from the rules above, we create a potentially large set of
candidate references from the database networks iteratively. Each
iteration consists of two steps.

 

i151

112 /3.Io's[BumoIpJOJXO'sorwurJOJurorq”:duq mot} pepBo1umoq

9103 ‘0g15n8nv uo ::

G.G lsoy and T.Kahveci

 

Table 1. The distribution of the number of database networks to different
sets for a given query

 

 

Result Twilight Filter

set zone set
True N1 N2 N3
False 0 N4 N5

 

The networks in the partition True are the ones that need to be returned for the query.
The networks in the partition False are the ones that are not similar to the query. The
networks are also divided into three sets, result set, twilight zone and ﬁlter set. All the
N,» inside the partitions represent the number of networks in the corresponding partition.

Step I: we pick a database network randomly. We choose a random
node from that network as the seed. We then grow that seed by
including one of the neighboring nodes to the seed randomly, until
the seed contains T nodes.

Step 2: we align the current seed with rest of the candidate reference
networks we created so far. If any of the alignment scores is greater
than a predeﬁned cutoff, it means that the current seed is redundant.
Therefore, we discard the current seed. Otherwise, we include the
current seed in the candidate reference set.

Steps 1 and 2 eliminates redundancy from the candidate reference
network set, therefore enforcing Property 3. The iterations continue
until we are unsuccessful at creating a new candidate reference
network, hence fulﬁlling Property 2.

3.2.2 Phase II: creating the ﬁnal reference set Recall from
Section 3. 1 that we align a given query network with all the reference
networks in R ﬁrst. In order to perform this comparison quickly, it is
desirable to have a small number of references in R. The amount of
time we would like to spend for ﬁltering the database determines the
size of R. We will use at most 100 references in our experiments.
We choose our actual reference set as a subset of the candidate
references. A naive solution would be to pick the reference networks
randomly from the candidate reference set. This simple strategy
may produce a good reference set since the candidate set already
satisﬁes the three properties listed at the beginning of this section.
Here, we develop an intelligent strategy that optimizes the reference
selection ﬁirther. This strategy learns the accuracy of the references
by training over a set of queries.

At this point, we take small detour to explain how we compute
the accuracy of our references for a query. As we explained in
Section 3.1, our references place each database network into one of
the three sets, namely result set, ﬁlter set and twilight zone. Among
these, the last two may contain true or false results (i.e. a database
network is a true result if its alignment to the query has a score
greater than the given cutoff). Table 1 shows the decomposition and
the number of networks in each set. Result set contains only true
results as our lower bound is guaranteed to be at most the actual
score. The ﬁlter set on the other hand may contain true results, as
well as false results. Our method fails to ﬁnd the true results in this
set if there are any. We compute the accuracy of our method as the
ratio of true results that our method can return. Formally, this number
is  This metric is also known as recall in the literature.

Algorithm 1 iteratively tries to ﬁnd the reference set which yields
the highest accuracy. We do this with the help of a set of training
query networks. We avoid a purely combinatorial approach because

 

Algorithm 1: Create reference set R

Align all the networks in Q and C with the networks in D
Remove k networks from C randomly and add them to R
repeat
Set Current Accuracy to the accuracy of R
Remove r, from R where accuracy of R— {ri} is maximum
for all e]- in C do
Calculate accuracy using RU {01-}
end for
if The resulting accuracy is better than the current one then
Add c]- to R for which the accuracy of RU {cj} is largest
Remove c]- from C
else
Insert r, back in R and Break the loop.
end if
until Accuracy cannot be improved anymore or C is empty

 

the number of possible reference sets is very high. Instead, we
develop a hill climbing approach. Algorithm 1 describes this method
in detail. We start by randomly choosing a reference set. Then, at
each iteration, we replace one reference network in R with another in
C —R to improve the accuracy of our index for the training queries.
To do this, we ﬁrst eliminate the reference from the current reference
set whose removal drops the accuracy the least. Next, among all the
remaining candidate references, we ﬁnd the one whose inclusion to
the current reference set increases the accuracy the most. If these
two changes improve the overall accuracy, we accept them. We
repeat these iterations until there is no candidate reference which
can improve the overall accuracy.

3.3 Computing the bounds

For a query network q, we calculate UB(q,d) and LB(q,d) for each
d e D with the help of references. When we create the reference set
as described in Section 3.2, we also record the alignment of each
(ri, (1) pair (rl- ER). For each (q, (1) pair, we compute UB(q,d) and
LB(q,d) using the precomputed alignments of each rl- with d, and
the alignments of each rl- with q. In Section 3.3.1, we present an
exact lower bound calculation technique. Then in Section 3.3.2, we
discuss an approximate upper bound calculation method.

In order to simplify the explanation of bound calculations, we
denote an alignment of q and rl- with a relation Illi. We will use the
relation 6,- to represent the alignment between rl- and d.

3.3.] Lower bound calculation In order to provide a tight lower
bound for a given query and database network pair, we use each
reference independently. Using each reference network ri, we
calculate a different lower bound value LBl-(q,d). After calculating
k different lower bounds, we choose the largest one [i.e. LB(q,d) =
maxi{LBl-(q,d)}] as the lower bound.

Given q, rl- and d, we compute LBl-(q,d) in two phases. In the
ﬁrst phase, we map a subset of the nodes of q to those of d from
their existing alignments with ri. In the second phase, we map the
remaining nodes if possible and calculate ﬁnal alignment score.
Phase I : using the representations for alignments between (q, r,) and
(ri,d) pairs, our indirect alignment <1),- between q and (1 through rl- is
simply the composition of relations 6,- and Illi. In other words, it is
the relation ¢i(q[j])=6i(1//i(q[j])). For example, in Figure 1a, q[1]
and ri[1] are aligned (i.e. 1//i(q[1])=ri[1]). Also r[l] and d[1] are
aligned (i.e. 6i(ri[1]) =d[1]). From these two, in Figure lb we align

 

i152

112 /3.Io's[BumoIpJOJXO'sorwurJOJurorq”:duq urorJ pepeo1umoq

9103 ‘0g anBnV uo ::

RINQ

 

(a)  query target
quew reference target
d[1] d[5]

r[1]

 

Mappings 11) and <5 Indirect alignment <1)

Fig. 1. Overview of the lower bound calculation. (a) shows the alignments
of (q.r) and (r.(1 ) pairs. (b) shows the resulting indirect alignment. Solid lines
represent the edges within a network. Dashed lines represent the mapping
between the nodes of two networks.

q[l] with d[l] (i.e. <1)l-(q[1])=d[l]). Notice that <1),- maps each node
of q (or d) to at most one node in d (or q). This is because both 6,-
and 11/,- map one node of q and d to at most one node in ri. Also
notice that there may be nodes in q or d that are not aligned to any
node by <1)).

Phase 11: if all the nodes of q are aligned at the end of Phase I, we
simply use this alignment to compute LBl-(q, (1). Otherwise, there will
be unaligned nodes from at least one network. One way to deal with
the unaligned nodes is to consider them as insertions or deletions
(indel) in the alignment of q and d. This, however, is not desirable
as each indel will lower the value of LBl-(q,d). We observe that it is
possible to align such nodes if there is a matching node in d that is
not aligned in Phase I. For example, in Figure 1a, both q[2] and d [2]
are unaligned with a reference node. Thus, they both are unaligned.
In Phase II, we align such nodes with each other. We do this by
performing a breadth ﬁrst traversal on q and (1 simultaneously. We
start the traversal from the root node of q and the node aligned to
it in d. Then, we visit every child of this node in q, also visiting
the aligned node in d. When visiting a node, we check the shortest
path between this node and its parent. If both in q and (1 there are
unaligned nodes, we align such nodes to each other in the order they
are traversed. We mark the nodes we cannot align as insertion and
deletions. We start the traversal from a pair of nodes that are aligned
to each other in Phase I and that are both neighbors to unaligned
nodes. Figure lb shows the alignment found after Phase II using the
reference alignment in Figure 1a. Finally, we compute LBl-(q,d) as
the similarity score sim(q,d) resulting from the alignment <1)).

3.3.2 Upper bound calculation As we discussed in Section 3.3.1,
each reference provides an indirect alignment between q and (1.
Consider the extreme scenario when one of the references is identical
to q. In that case, the indirect alignment of q and (1 through that
reference will be the optimal alignment since (1 is optimally aligned
with each reference in our index. As the similarity between q and a
reference increases, we expect that the indirect alignment obtained
from that reference will approach to the optimal one. Our upper
bound computation strategy follows from this observation. Even
when none of the references is identical to q, each one may be
similar to a subnetwork of q. Thus, by considering all the references
at once, we may be able to reconstruct a subnetwork that is very
similar to q. Note that this method is not guaranteed to produce
an upper bound. Its success depends on how well the reference set
represents q. As we described in Section 3.2, Algorithm 1 chooses
the reference set that maximizes the accuracy of our upper bound

 
  
    

query reference 1 target

d[1]

 

Fig. 2. Overview of the upper bound calculation method. (a) and (b) Show
the alignments of q and (1 with references 1 and 2. respectively. In (a) and (b).
solid lines represent the edges between the nodes of a single network. and
dashed lines represent the mappings of two nodes in two different networks.
(c) shows the bipartite graph resulting from the indirect alignments using
two references. In (c). all the lines. solid and dashed. represent an element of
the relation 11. Solid lines originating from (1 [6] Show that these elements are
added to 1b. since no information about the node (1 [6] was gathered through
references. All the edge weights are omitted in all ﬁgures.

function. We discuss the observed accuracy of our method later in
Section 4.

We calculate UB(q,d) in two phases. In the ﬁrst phase, we ﬁnd
the set of node pairs from q and d that can be aligned using all
the references. In the second phase, we ﬁnd the highest scoring
alignment under this limitation by relaxing the topologies of q and (1.
Phase I : for each reference rl- ER, we ﬁnd an indirect mapping <1),-
between q and d as we explained in Phase I of Section 3.3.1. We
then create a joint mapping <1) from all indirect mappings as <1)(d [1]) =
U15i5k{<1)i(d[j])}. That is <1) maps each d[j] to the set of all nodes of
q that d[j] is indirectly aligned by at least one reference. Notice that
it is possible to have some nodes in d or q that are not mapped to
any node by <1). This happens when no reference in our reference set
aligns with them. This, however, does not mean that those nodes of
q and d are dissimilar. In order to deal with such nodes, we expand
<1) by mapping such such d[i] (q[j]) to all the nodes in q ((1).

Figure 2 depicts this on an example that has two references.
In this case, we have two reference networks. Figure 2a and b
show the alignments of these references to both q and (1. Figure 2c
shows the relation <1) based on these two references. Notice that
in Figure 2c, d[4] is mapped to two nodes from q, q[4] and q[2].
This is because (1 [4] is indirectly mapped to q[4] and q[2] through
reference 1 and reference 2, respectively. Also, d[6] is mapped to
all the nodes in q as it is not aligned to any node in any of the
references.

Phase II: In this phase, we align q and (1 using the mapping <1)
obtained in Phase I. Since <1) is computed from many references
jointly, it can map some of the nodes in q to topologically distant
nodes of d and vice versa. We ignore the topologies of q and d
at this phase. Instead, we consider the mapping <1) as a weighted
bipartite graph. The nodes of q and d are the nodes of this graph.
The mappings in <1) are the edges. The similarity between the nodes
that map are the weights of the edges. We compute the upper bound

 

i153

112 13.10'S[1211,1110prOJXO'SOIJBLUJOJIIIOIq”K1111] mot} pepeo1umoq

9103 ‘0g anBnV uo ::

G.G lsoy and T.Kahveci

 

UB(q,d) as the total weight of the maximum weighted bipartite
matching between q and d.

4 RESULTS AND DISCUSSION

This section evaluates the performance of RINQ experimentally.
Database: we used networks from the KEGG database (Ogata et al.,
1999) in our experiments. We downloaded all the gene regulatory
networks that have more than 15 genes (i.e. nodes). In total, there are
297 such networks as of September 2010. In this database, we had
21 different types of networks (such as MAPK signaling pathway)
from 46 different organisms. Further details about the size as well
as the distribution of the networks to different types and organisms
are in Appendix II in Supplementary Material (see Figures 8, 9 and
Tables 3, 4 in Appendix II in Supplementary Material).

Queries: we created three sets of query networks from this dataset
by performing random walks on the database networks. These sets
contain six, seven and eight node queries, respectively. Each query
set consisted of 100 query networks. We then randomly split each
query set into two disjoint sets, each containing 50 networks. We
used one of these sets for training our index, and the other one for
testing. All the query networks can be downloaded from our server
at http://bioinformatics.cise.uﬂ.edu/palRINQ.html.

Implementation details: we implemented RINQ in C++. We
align two networks using our own implementation of the QNet
method (Dost et al., 2008). In order to calculate node similarity
scores, we use BLAST (Altschul et al., 1990). We use the minus
logarithm of the E-values as the node similarity scores. We carried
out experiments with both high and low indel penalties. For high and
low indel penalties, we used 1.5 and 0.5 times the largest possible
node similarity score, respectively.

Methods compared against: we compared RINQ against two of the
existing ﬁltering methods, SAGA (Tian et al., 2007) and CTree
(He and Singh, 2006). These methods did not have their source
codes publicly available. Thus, for experiments with SAGA, we used
the online SAGA server. The CTree method describes two variations
for ﬁltering the internal nodes of the tree, namely maximum
weighted bipartite matching and neighbor biased matching. We
implemented and tested both of them. We report the results for CTree
for only the neighbor biased matching as it performs better than the
other alternative.

Evaluation criteria: we measured the running time and accuracy
as the performance criteria. We measured the performance of our
method by changing the values of two variables. These variables are
the number of references and query selectivity. In our experiments,
the number of references varies from 4 to 100. Query selectivity
indicates the percentage of true results for each query. For instance,
4% selectivity means that 4% of the networks in the database
are similar to the query according to the given similarity cutoff.
We performed experiments with up to 10% selectivity. For each
parameter combination, we performed experiments using 50 testing
queries. We present the average of 50 queries for each experiment.
We used all three sets of queries in our tests. However, due to space
restrictions, we only include the tests for seven node queries here.
Our other experiments on the other query and reference sets yield
similar results.

Test environment: we performed our tests on Linux servers equipped
with dual AMD Opteron dual core processors running at 2.2GHz
and 3 GB’s of main memory.

 

540 . . . . . . . . '
Random references from dataset —I— .
Random references from candidate set 
Intelligent Reference Selection 

520 -

Running time[minutes]

 

 

 

420

 

90 9'1 9'2 9'3 9'4 915 9's 9'7 ea 99
Accuracy (%)

Fig. 3. Running time versus accuracy of our method for different reference
selection strategies. Experiments are repeated for different number of
references. Average query processing time is presented as running time.
Accuracy is calculated over all test queries. Lower running time and higher
accuracy indicates better performance. The running time of exhaustive search
is over 2 days (not shown in ﬁgure).

In Section 4.1, we evaluate the contribution of our reference
selection strategy to the performance of RINQ. In Section 4.2, we
discuss how our index structure performs for varying index and
query parameters. In Section 4.3, we compare the performance of
RINQ to SAGA and CTree. Finally, in Section 4.4 we present the
statistical and biological signiﬁcance of our results.

4.1 Effects of reference selection strategy

Recall that we proposed to carefully select a reference set from the
candidate set we generated (Section 3.2.1). The ﬁrst question we
need to answer is how each of these steps affect the performance
of reference based indexing. In order to do this, we compared our
method to two alternatives variants. The ﬁrst one picks references
randomly from the database using random walk. The second one
chooses references randomly from the candidate reference set. We
conducted two sets of experiments using 4 and 8% query selectivity.
In each experiment, we varied the number of references from four
to 100 and measured the average accuracy and the running time.
Figure 3 shows the results for three reference selection strategies.
We also measured the running time of exhaustively searching the
database without using our index. The running time of exhaustive
search was over 2 days. The experiments demonstrate that reference
based indexing is signiﬁcantly faster than exhaustive search. It
improves the running time by a factor of ﬁve over exhaustive
search. Creating candidate references by following the three rules
(see Section 3.2.1) alone improves the running time by up to 5%.
Finally, carefully selecting references using Algorithm 1 results in up
to 10% additional improvement. In summary, the results suggest that
the reference selection strategy of RINQ indeed helps in improving
the performance of our method. It also demonstrates that RINQ
makes similarity searches in biological network databases practical.

4.2 Effects of index and query parameters

Earlier in Section 4, we pointed out that two parameters can affect the
performance of RINQ, namely the number of references and query
selectivity. In our next set of experiments, we evaluate the effects of
these parameters on the performance of RINQ. In order to do this,
we designed two sets of experiments. In our ﬁrst set of experiments,

 

i154

112 13.10'S[1211,1110prOJXO'SOIJBLUJOJIIIOIq”K1111] mot} pepeo1umoq

9103 ‘0g anBnV uo ::

RINQ

 

 

700

 

 

 

 

 

 

 

650 -
600 -
E 550 -
E
'g 500 -
E 450 -
E 400
1:
g 350 -
300 -
250 -
200 . . . . . . . . .
0 10 20 30 40 50 60 70 80 90 100
Number of References
100
98 -
96 -
g 94 -
>‘ u
 92- 
< 90 - 
88 - 
X
86 ' ,:" RINQ:H —l—
x RINQ:L 

 

 

0 10 20 30 40 50 60 70 80 90 100
Number of references

Fig. 4. Impact of the number of references. Top: the average running time
RINQ and Oracle. Bottom: the accuracy of RINQ. The query selectivity is
8%. The graphs includes two different tests with RINQ. RINQ:H refers to
RINQ experiments that use alignments with high indel penalties. RINQ:L
refers to experiments using alignments with low indel penalties. The running
time of exhaustive search is over 2 days (not shown in ﬁgure).

we ﬁxed query selectivity to 4 and 8%, and performed database
queries with varying number of references for each selectivity value.
We carried out the same experiment with RINQ using alignments
with both high and low indel penalties. For the second set of
experiments, we ﬁxed the number of references and we changed
the query selectivity from 3% to 10%. We present the running time
and accuracy with respect to varying parameters.

In addition to RINQ, we also report the running time of a
hypothetical method named Oracle. We assume that Oracle already
knows the networks in the result set for any query and aligns query
with only those networks. Thus, the running time of Oracle is a
lower bound to any database search method. The purpose we had
for including such a hypothetical method is to observe how much
room for improvement RINQ leaves in practice.

Ejfects of the number of references: Figure 4 shows the results
for varying number of references. The results suggest that RINQ
achieves up to 80% improvement in running time over exhaustive
search. With higher indel penalties, the importance of matching
topologies increase. Our experiments with RINQ show that as the
alignment favors topology, the accuracy of our method increases.
This suggests that the references can preserve the alternative
topologies in the database accurately. Another observation from this
experiment is, as the number of references increase, the running time
of our method increases slowly while its accuracy increases rapidly
to almost 100%. This is a desirable property as it suggests that RINQ
needs to maintain only a small number of references. Thus, it uses

 

800

RINQ _1_
Oracle ......... _. ‘-

Average Running Time[minutes]

 

 

 

 

3 4 5 6 7 8 9 10
Query Selectivity(°/o)

100

 

Accuracy(%)

 

 

 

32 references —I—

4 5 6 7 8 9 1 0
Query Selectivity(°/o)

 

80
3

Fig. 5. Running time and accuracy of RINQ for different query selectivity
values. These results are calculated using 32 references.

a small amount of storage and performs a small number of query-
reference network alignments. From our results, we suggest using
around 30 references for our database.
Eﬁ’ects of query selectivity: following from our previous
experiments, we ﬁx the number of references to 32 and vary
the query selectivity. Figure 5 plots the results. As the selectivity
increases, the size of the result set, and thus the number of networks
we need to align with the query increases. As a result, the running
time of RINQ grows. We observe that running time of our method
does not increase linearly. This is expected as the size of the actual
result set grows, it gets harder to place database networks into the
ﬁlter set. The small gap between Oracle and RINQ indicates that
our method is very successful in ﬁltering unpromising database
networks. It also shows that our method leaves little room for
improvement particularly for small selectivity values. For instance,
when the selectivity is 3%, our method’s running time is almost that
of the smallest number of alignments needed for that selectivity.
For all the selectivity values, RINQ has very high accuracy. We
observe that as we increase the query selectivity, RINQ’s accuracy
increases as well. This is mainly because for small selectivity values,
even a few false dismissals can reduce the accuracy. The results
demonstrate that our method reaches to very high accuracy values
quickly.

4.3 Comparison of RINQ with existing methods

An obvious question that needs to be answered is how well RINQ
performs as compared with existing state of the art methods. In order
to evaluate this, we compared RINQ with two existing methods,
namely SAGA (Tian et al., 2007) and CTree (He and Singh, 2006).
In order to have a fair comparison, similar to RINQ, we used SAGA

 

i155

112 13.10'S[1211,1110prOJXO'SOIJBLUJOJIIIOIq”K1111] mot} pepeo1umoq

9103 ‘0g anBnV uo ::

G.G lsoy and T.Kahveci

 

800

 

SAGA'—l—
700

600
500

400

Running time[minutes]

 

300

200 ,,,,, 

 

 

100

 

65 70 75 80 85 90 95 100
Accuracy (%)

Fig. 6. Running time versus accuracy of SAGA. CTree and RINQ.
Experiments are repeated for same queries with different selectivities.
Average query processing time is presented as running time. Accuracy is
calculated over all test queries. Lower running time and higher accuracy
indicates better performance.

and CTree to create a candidate set of results. We used our QNet
implementation to ﬁnd the actual results from the candidate set for
each method.

SAGA requires the user to provide the list of genes that can
be aligned with each gene in the query network. The user can
also specify the minimum percentage of query nodes that needs
to be aligned. We varied these two parameters to get the smallest
candidate set for SAGA for different accuracies. CTree uses a
neighbor biased matching algorithm to ﬁlter database networks. We
varied the constant that deﬁnes the amount of neighbor bias to get
the best running time of CTree for different accuracy values.

We ran RINQ, SAGA and CTree using the same query and
database networks. We queried each method with the same set of
query selectivity values. We recorded running time and accuracy of
each method. For all the three methods, the amount of time it takes
for ﬁltering the database was much smaller than the post-processing
time, where we compare query network with the candidate networks.
In our experiments, RINQ requires only 8 s for ﬁltering phase using
32 references, whereas the other methods require from a few seconds
up to minutes. We ignore the amount of time the index structure takes
to ﬁlter database networks for this is a negligible fraction (0.03—
0.1%) of the time it takes to process the candidate set. We report the
average running time and accuracy values for SAGA, CTree and
RINQ over all queries.

Figure 6 plots our results. In our experiments, RINQ performed
much better in terms of both accuracy and speed than both CTree
and SAGA. RINQ is up to three times faster than CTree for the
same accuracy values. We could not achieve comparable accuracy
with SAGA. We believe that this is probably because SAGA is
well suited for exact matches and its accuracy drops quickly as the
difference between the genes in the query and the database network
grows. In order to improve the accuracy of SAGA further, we grew
the set of genes that each gene can align (i.e. this corresponds to
reducing the similarity cutoff for gene pairs in the SAGA queries).
However, SAGA fails to return any results in that case. Given that
(i) its running time (when its accuracy is 75%) is already much
larger than both RINQ and CTree (when their accuracies are 85 and
89%, respectively), and (ii) its running time will only increase with
increased accuracy, we concluded that SAGA could not compete
with the two for high accuracy values. In conclusion, we observed
that RINQ is a signiﬁcant improvement over existing methods.

Table 2. The P-values and the result set sizes of top ﬁve queries when
similarity cutoff is set to 90. 80 and 70% of the maximum similarity score
that can be achieved with an exact match

 

Rank Similarity (%)

 

 

90 80 70
1 1.4E-6 (21) 1.0E-13 (34) <1E-15 (48)
2 5.7E-4 (17) 1.3E-7 (27) <1E-15 (44)
3 3.4E-2 (13) 5.4E-4 (21) 1.9E-7 (32)
4 3.4E-2 (13) 4.4E-2 (16) 3.0E-6 (30)
5 7.3E-2 (12) 4.4E-2 (16) 3.2E-4 (26)

 

The values in the parantheses are the result set size (i.e. the number of matches) reported
by RINQ for that speciﬁc query.

4.4 Signiﬁcance of results

In order to validate our method, we discuss the signiﬁcance of our
results in this section. We ﬁrst evaluate the statistical signiﬁcance
of our results. We then discuss some of the biologically interesting
observations from the statistically signiﬁcant results.

We start by discussing the statistical signiﬁcance of our results.
We compute the statistical signiﬁcance of each query as its P-value.
We do this as follows for a given query network and a similarity
cutoff. We ﬁrst run RINQ to ﬁnd the set of database networks that
have an alignment with score greater than the cutoff with the query.
We then compute the probability that a given random query network
has at least as many matching database networks in the same dataset
with alignment score at least the same similarity cutoff. We report
this probability as the P-value.

Table 2 presents the P-values and the result set sizes of the top
ﬁve queries when similarity cutoff is set to 90, 80 and 70% of the
maximum possible similarity score. The maximum score is the score
that is achieved when the query network is aligned with itself. We
observe that for all the three similarity cutoff values the top queries
are statistically signiﬁcant. This implies that the database contains
motifs that have at least as many genes as the query networks. The
top queries are a part of these motifs. The results are also encouraging
as they demonstrate that RINQ is capable of ﬁnding such frequent
patterns quickly.

When the similarity cutoff decreases, the number of matching
database networks grow. This proves that motifs are not exact
duplicates of the same networks, but they are approximate
alignments. This is an important result as it shows the necessity
of approximate alignment algorithms. Decreasing P-values also
indicate that our results are more signiﬁcant. This supports our
results in Figure 5b that for lower similarity cutoffs (i.e. higher query
selectivity), RINQ has higher accuracy. Higher accuracy and lower
P-values indicate that RINQ performs better with lower similarity
cutoffs.

One can argue that the large number of matches found by RINQ
can be attributed to the fact that there are multiple pathways that
belong to the same pathway class from different organisms (see
Table 4 in Appendix II in Supplementary Material). Next we focused
on the individual queries that have the best P-value and explored
the characteristics of the matching database subnetworks as well as
the biological signiﬁcance of these matches.

Figure 7 depicts two of our top queries. The query in Figure 7a is
a subnetwork of the ErbB signaling network of Rattus norvegicus.

 

i156

112 13.10'S[1211,1110prOJXO'SOIJBLUJOJIIIOIq”K1111] mot} pepeo1umoq

9103 ‘0g anBnV uo ::

RINQ

 

 

Fig. 7. Sample queries from our experiments. (a) A subnetwork of ErbB
signaling pathway of Rattus Norvegicus (rat). (b) A subnetwork of VEGF
signaling pathway of Mus Musculus (mouse).

This query is ranked as the ﬁrst for 90 and 80% similarity and
the second for the 70% similarity. ErbB signaling network is
closely related to cancer (Hynes and Lane, 2005). Mutations and
dysregulations of ErbB network proteins are frequently observed
in cancer cells. ErbB signaling network consists of ErbB family
of receptor proteins and a number of intracellular signaling
pathways (Yarden and Sliwkowski, 2001). ErbB family of receptors
are cell membrane proteins. Extracellular growth factors bind to
these proteins. In response to this binding, ErbB proteins can trigger
many different cell signaling networks. One of the most important
intracellular targets of ErbB receptors is MAPK signaling network.
Our ﬁrst query is a part of ErbB signaling pathway that is responsible
for triggering the MAPK signaling pathway.

RINQ successﬁilly identiﬁes the relationship between our query
and the similar patterns in the ErbB and MAPK signaling networks
of other organisms. When we query our database for 90% similarity,
RINQ successﬁilly returns all the 21 true results, with only three
false positives. Among these 21 results, nine are from the ErbB
signaling network of various organism and the rest from the MAPK
signaling network. For queries with 80% and 70% similarity, RINQ
also identiﬁes the database networks with 100% accuracy. For 80%
similarity, RINQ ﬁnds matching patterns in the Insulin signaling
networks of nine organisms. Indeed, the insulin signaling network
contains the Ras-Raf-MEK-ERK-Elkl pathway that is responsible
for growth and differentiation and the Ras-Raf-MEK-ERK-MNK
pathway that contributes to protein synthesis. As we reduce the
similarity to 70%, RINQ returns additional alignments from the
chemokine signaling pathway. There are totally ﬁve organisms,
namely Mus musculus, Homo sapiens, Canisfamiliaris, Bos taurus
and Pan troglodytes, whose chemokine signaling pathways align
with this query. These are all phylogenetically close to the
query organism. Further exploration of these pathways show that
they indeed contain the Sos-Ras-Raf—MEKl-ERKl/2 pathway that
regulates a set of critical ﬁmctions such as cytokine production,
cellular growth and differentiation, cell survival, apoptosis and
migration. Some organisms, such as Omithorhynchus anatinus,
Sus scrofa, Gallus gallus and Xenopus 1aevis have one or more
protein deletions in their ErbB signaling networks. Among these
the ﬁrst two belong to the same class as the query organism
(i.e. mammalian) while the last two belong to different classes.
Nevertheless, RINQ successﬁilly identiﬁes such networks and
provides tight estimates for their actual network similarity.

The query in Figure 7b is taken from the VEGF signaling pathway.
Although there are VEGF signaling networks of only 14 organisms
in our database, this query returns totally 48 alignments at 70%
similarity. These alignments are found in eight types of networks of
14 different organisms. This demonstrates that the VEGF signaling
network interacts with many other networks. It also suggests that
this query is a part of an important motif as it appears in numerous
organisms. RINQ could identify this motif as well among others.

5 CONCLUSION AND FUTURE WORK

In this article, we considered similarity queries in biological network
databases. Since pairwise comparison of biological networks is
a time consuming operation, exhaustive database searches are
impractical for such databases. We introduced reference-based
indexing to speed up such queries. We developed methods for
calculating upper and lower bounds to the alignment score quickly.
Using these bounds, we classiﬁed database networks as similar or not
without aligning them with the query network. We also developed
an intelligent method to choose references which maximizes the
chance of references to prune database networks. Our experiments
showed that (i) our method reduced the running time of a single
query on a database of around 300 networks from over 2 days
to only 8h; (ii) our method outperformed the state of the art
method Closure Tree and SAGA by a factor of three or more;
(iii) our method successﬁilly identiﬁed statistically and biologically
signiﬁcant relationships across networks and organisms. To the best
of our knowledge, this is the ﬁrst attempt at developing reference-
based indexing of biological networks. Therefore, application of
this method to other types of biological networks is an important
future research direction forus. This approach enables indexing large
biological networks. Therefore, we believe that it is an important
step toward large-scale analysis of biological network databases and
has great potential to assist biological sciences which need such
large-scale comparison.

Funding: NSF under (grants CCF-0829867 and IIS-0845439).

Conﬂict of Interest: none declared.

REFERENCES

Altschul,S.F. et al. (1990) Basic local alignment search tool. J. Mol. Biol., 215, 403410.

Ay,F. and Kahveci,T. (2010) SubMAP: aligning metabolic pathways with
subnetwork mappings. In International Conference on Research in Computational
Molecular Biology, Lecture Notes in Computer Science, Vol. 6044, Springer,
Berlin/Heidelberg, pp. 15730.

Ay,F. et al. (2009) A fast and accurate algorithm for comparative analysis of metabolic
pathways. J. Bioinformatics Comput. Biol., 7, 389428.

Banks,E. et al. (2008) Netgrep: fast network schema searches in interactomes. Genome
Biol., 9, R138.

Bruckner,S. et al. (2009) Torque: topology-free querying of protein interaction
networks. Nucleic Acids Res., 37 (Suppl. 2), W1067W108.

Clemente,J.C. etal. (2005) Reconstruction of phylogenetic relationships from metabolic
pathways based on the enzyme hierarchy and the gene ontology. Genome Inform.,
16, 45755.

Clemente,J.C. et al. (2006) Finding conserved and non-conserved reactions using a
metabolic pathway alignment algorithm. Genome Inform., 17, 4356.

Dost,B. et al. (2008) QNet: a tool for querying protein interaction networks. J. Comput.
Biol., 15, 9137925.

Ferro,A. et al. (2007) NetMatch: a Cytoscape plugin for searching biological networks.
Bioinformatics, 23, 9107912.

Francke,C. et al. (2005) Reconstructing the metabolic network of a bacterium from its
genome. Trends Microbiol, 13, 5507558.

Giot,L. and Bader,J.S. (2003) A protein interaction map of drosophila melanogaster.
Science, 302, 172771736.

Giugno,R. and Shasha,D. (2002) Grathrep: a fast and universal method for querying
graphs. In Proceedings of I 6th International Pattern Recognition Conference, Vol. 2,
pp. 1127115.

He,H. and Singh,A.K. (2006) Closure-Tree: an index structure for graph queries. Int.
Conf Data Eng., 0, 38.

Hynes,N.E. and Lane,H.A. (2005) Erbb receptors and cancer: the complexity of targeted
inhibitors. Nat. Rev. Cancer, 5, 3417354.

Kelley,B.P. et al. (2004) PathBLAST: a tool for alignment of protein interaction
networks. Nucleic Acids Res. , 32, W837W88.

 

i157

112 13.10'S[1211,1110prOJXO'SOIJBLUJOJIIIOIq”K1111] mot} pepeo1umoq

9103 ‘0g anBnV uo ::

G.G lsoy and T.Kahveci

 

Levine,M. and Davidson,E.H. (2005) Gene regulatory networks for development. Proc.
Natl Acad. Sci. USA, 102, 4936—4942.

Liao,C. et al. (2009) IsoRankN: spectral methods for global alignment of multiple
protein networks. Bioinformatics, 25, 2537238.

Mongiovi,M. et al. (2010) SIGMA: a set-cover—based inexact graph matching algorithm.
J. Bioinformatics Comput. Biol., 8, 1997218.

Ogata,I-I. et al. (1999) KEGG: Kyoto Encyclopedia of Genes and Genomes. Nucleic
Acids Res. , 27, 29734.

Pinter,R.Y. et al. (2005) Alignment of metabolic pathways. Bioinformatics, 21,
340173408.

Shlomi,T. et al. (2006) QPath: a method for querying pathways in a protein-protein
interaction network. BMC Bioinformatics, 7, 199.

Singh,R. et al. (2007) Pairwise global alignment of protein interaction networks
by matching neighborhood topology. In Research in Computational
Molecular Biology, Lecture Notes in Computer Science, Vol. 4453, Springer,
Berlin/Heidelberg, pp. 16731.

Sridhar,P. et al. (2007) An iterative algorithm for metabolic network-based drug target
identiﬁcation. Pac. Symp. Biocomput., 12, 88799.

Tian,Y. et al. (2007) SAGA: a subgraph matching tool for biological graphs.
Bioinformatics, 23, 2327239.

Yan,X. et al. (2004) Graph indexing: a frequent structure-based approach. In SIGMOD,
ACM, New York, NY, USA, pp. 3357346.

Yarden,Y. and Sliwkowski,M.X. (2001) Untangling the erbb signalling network. Nat.
Rev. Mol. Cell Biol., 2, 1277137.

 

i158

112 13.10'S[1211,1110prOJXO'SOIJBLUJOJIIIOIq”K1111] mot} pepeo1umoq

9103 ‘0g anBnV uo ::

