BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

LibSBMLSim

 

Supporting other programming languages will be achieved by
providing language bindings.

3 METHODS

3.1 Numerical integrator

LibSBMLSim provides both explicit (Rung&Kutta) and implicit
(backward Euler) methods (Hairer et al., 1993) for numerical integration.
Providing only explicit methods such as RungeiKutta is not sufﬁcient for
biochemical simulation. Owing to the fact that there exist several reac-
tions that proceed on different time scales, the system becomes stiff and
requires implicit methods to solve the problem.

x0 + At) = x0) + F(t, Xm). At (1)

X(t + At) = X(t) + F(t + At, X(t + Al))- Al (2)

Equations (1) and (2) are examples of explicit (Euler) and implicit (back-
ward Euler) methods, respectively. Here, X(t) is a variable which is a
function of time t, and F(t,x) is deﬁned by a differential equation. It is
obvious from equation (2) that the integrator must solve this equation to
ﬁnd X(t + At) before the integration because both the left- and right-hand
side of the equation contains the term X(t + At). For this reason, we have
developed a non-linear simultaneous equation solver. Furthermore, to
improve the accuracy of integration, variable-step integrator (Rungei
Kutta Fehlberg and CashiKarp) and multistep methods are provided
for both explicit (AdamsiBashforth) and implicit (AdamsiMoulton
and Gear) methods (Hairer et al., 1993).

3.2 Non-linear simultaneous equation solver

To implement the above implicit methods, a non-linear simultaneous
equation solver is implemented in our library. The non-linear simultan-
eous equation solver is also required to support the SBML AlgebraicRule
element and the ‘fast’ attribute in the Reaction element. We used the
k-dimensional Newton’s method to solve systems of non-linear simultan-
eous equations. Numerical differentiation is used to obtain the Jacobian
matrix, and (for linear approximation) LU decomposition, Newton’s
method, forward elimination and backward substitution are also imple-
mented for this purpose.

3.3 AST manipulator

In SBML, ODEs are stored in the kineticLaw math element and can be
obtained as an AST object (Supplemental Figure S1) by using libSBML
(Bornstein et al., 2008). Our library directly uses AST to handle all the
functionality of SBML. When an SBML model is loaded, our library
parses all ASTs and its related elements, and transforms the AST to
suit with actual evaluation. Evaluation of AST is performed by convert-
ing AST to Reverse Polish notation (RPN). To improve the performance,
we applied a stack architecture to avoid recursive calls and evaluation of
each AST node. Using AST as a fundamental data structure of equations
made our implementation straightforward. For example, if a model con-
tains a FunctionDeﬁnition element, the library will expand the AST node
that calls the function to the actual content of the deﬁned function
(Supplemental Figure S2). This transformation of AST can be applied
to support other SBML elements, such as piecewise functions. To support
piecewise functions on AST, our library adds multiplication between
each conditional expression and deﬁnition, and then combines them
using addition and logical operators (NOT and AND) (See
Supplemental Figure S3). The combination of the SBML Delay and
EventAssignment element that is used to describe an Event to take
place after a certain delay is also supported by this implementation.

3.4 Events and Delays

A SBML Event element is used to describe an instantaneous discon-
tinuous change in a set of variables of any type (species quantity, com-
partment size or parameter value) when a triggering condition is
satisﬁed (Hucka et al., 2008). When a condition speciﬁed in Trigger
changes from ‘false’ to ‘true’, an assignment described in
EventAssignment is executed. If an Event contains a Delay element,
then the assignment is executed after the delay described in the Delay
element. From SBML Level 3 Version 1, Priority element and ‘persist-
ent’ attribute on Trigger are introduced. Priority speciﬁes the priority of
Event, and ‘persistent’ attribute speciﬁes whether the trigger expression
should not have to be re-checked after it triggers. To support all func-
tions of SBML Events, we implemented an event handler as follows: (i)
Insert all Events that are related to a given Trigger to a queue. (ii)
Calculate the priority of all Events in the queue. (iii) Move the Event
that has the maximum priority value to the head of the queue and
execute its EventAssignment. (iv) Reconﬁrm the Trigger of Events
whose persistent ﬂag is ‘false’, and remove from the queue if the
Trigger is set to ‘false’ by the previous EventAssignment. (v) Insert
any Event whose Trigger was changed from ‘false’ to ‘true’ by the
above EventAssignment to the queue. (vi) Go back to procedure (ii)
if there still exists an Event in the queue.

The Delay function is used to describe a delay differential equation
(DDE) in a model. For example, when a model contains the differential
equation % 2 k1 — k2A(t — r), the simulator must use the value of Ar
seconds before for the integration. A straightforward way to implement a
DDE solver is to use a continuation method; however, in SBML, the
delay variable I is not necessarily ﬁxed, and thus the actual implementa-
tion in our library stores the values of all the variables during the
simulation.

4 DISCUSSION

The aim of the current work is the development of a portable
simulation library that fully supports SBML features. For this
purpose, we at ﬁrst focused on accuracy by a straightforward
implementation, staying carefully within the speciﬁcations of
SBML. Although there already exist elaborated and efﬁcient
solvers, numerical integrators including variable—step integrator
and both explicit and implicit method are implemented from
scratch because we wanted to reduce the number of dependent
libraries as much as possible. We are planning to port this library
on tablet computers and smartphones. SBML can also describe
partial differential equations (PDEs), stochastic differential
equations (SDEs) and discrete stochastic simulation models,
which are not yet included in the SBML test suite. As yet
libSBMLSim does not provide integrators for these types of
models; a known limitation which we intended to address in
our future development of the library.

5 CONCLUSION

LibSBMLSim is a portable simulation library that supports all
the features of SBML Level 2 Version 4 and Level 3 Version 1.
We conﬁrmed that our library passed all 980 tests of the SBML
test suite (version 2.0.2, See Supplemental Figure S4). The library
does not depend on any third—party library except libSBML.
Language bindings such as Java, C#, Python and Ruby are
also included in the distribution.

 

1 475

ﬁm'sIeumoI‘pJOJXO'sopnuuopnorq/ﬁdnq

H. Takizawa et al.

 

Funding: This work was supported by a Grant—in—Aid for
Scientific Research on Innovative Areas (23136513).

Conﬂict of Interest: none declared.

REFERENCES

Bornstein,B.J. et a]. (2008) LibSBML: an API library for SBML. Bioinformatim‘, 24,
88(k881.

Hucka,M. et a]. (2004) Evolving a lingua franca and associated software infrastruc—
ture for compumtional systems biology: the Systems Biology Markup Language
(SBML) project. Suit. Biol, 1, 41753.

Hucka,M. et a]. (2008) Systems Biology Markup Language (SBML) Level 2: struc—
tures and facilities for model deﬁnitions. Nat. Precedings, [Epub ahead of print,
doi: 10.1038/npre.2008.2715.l, November 5, 2007].

Hucka,M. et a]. (2011) A Proﬁle of Today’s SBML—Compatible Software. In:
e—Science Workshops, 2011 IEEE Seventh International Conference on
e—Science. IEEE, Stockholm, Sweden, pp. 1437150.

Hairer,E. et al. (1993) Solving Ordinary Differential Equations. 1: Nonstiﬂ’ProblemS.
2nd edn. Springer—Verlag, Berlin.

 

1476

/310'S[Bum0fplOJXO'SOIIBLUJOJIIIOICV/Idllq

