Bioinformatics, 31122), 2015, 3569—3576

doi: 10.1093/bioinformatics/btv435

Advance Access Publication Date: 27 July 2015
Original Paper

 

Genome analysis

Canonical, stable, general mapping using
context schemes

Adam M. Novak”, Yohei Rosenz, David Haussler1 and Benedict Paten1

1UC Santa Cruz Genomics Institute, 1156 High Street, Santa Cruz, CA 95064 and 2NYU School of Medicine, 550 First
Avenue, New York, NY 10016, USA

*To whom correspondence should be addressed.
Associate Editor: Alfonso Valencia

Received on March 9, 2015; revised on June 8,2015; accepted on July 21, 2015

Abstract

Motivation: Sequence mapping is the cornerstone of modern genomics. However, most existing
sequence mapping algorithms are insufficiently general.

Results: We introduce context schemes: a method that allows the unambiguous recognition of a
reference base in a query sequence by testing the query for substrings from an algorithmically
defined set. Context schemes only map when there is a unique best mapping, and define this criter—
ion uniformly for all reference bases. Mappings under context schemes can also be made stable,
so that extension ofthe query string (e.g. by increasing read length) will not alter the mapping of
previously mapped positions. Context schemes are general in several senses. They natively sup—
port the detection of arbitrary complex, novel rearrangements relative to the reference. They can
scale over orders of magnitude in query sequence length. Finally, they are trivially extensible to
more complex reference structures, such as graphs, that incorporate additional variation. We dem—
onstrate empirically the existence of high—performance context schemes, and present efficient con—
text scheme mapping algorithms.

Availability and implementation: The software test framework created for this study is available

 

from https://registry. h ub.docke r.com/u/adam nova k/seq uence—g raphs/.

Contact: a nova k@soe. ucsc.ed u

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

Many tools and algorithms exist for mapping reads to a reference gen-
ome (Harris, 2007; Langmead et (11., 2009; Li and Durbin, 2010).
These tools are based on the idea of scoring local alignments between
a query string and a reference according to some set of match, mis-
match and gap scoring parameters, and then finding local alignments
with maximal or near-maximal scores. Seed-and-extend approaches
coupled with memory efficient substring indexes or hashing schemes
have been highly successful in heuristically accelerating this search pro-
cess (Dobin et (11., 2013; Langmead et (11., 2009; Li and Durbin, 2010).

The core problem with read mapping is ambiguity. There is often
no single best place that a read maps; especially in the case of recent
duplication within the reference genome. The precise base-level
alignment of the read to a given location in the reference is also often

ambiguous. To mitigate this; each mapped read is given a mapping
quality; a per read score that indicates how likely the mapping was
generated erroneously (Li et (11., 2008). Quantifying this uncertainty is
a reasonable approach for many applications; but even then the uncer-
tainty can be difficult to accommodate downstream.

The difficulty of mapping a read to a reference motivates a con-
sideration of its necessity. Recently; alignment-free methods of vari-
ant calling through substring detection have garnered significant
interest (Dilthey et (11., 2014). The basic idea is not new; the dbSNP
database has long provided; for each point variant in the database; a
flanking nucleotide string that indicates the DNA context in which
the variation was isolated (Sherry et (11., 2001). In principle such a
system of variant identification sidesteps the limitations of score-
based alignment; and can be used to canonically detect variations.

(6) The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 3569

/310‘srcumo[p10}xo‘sopcuHOJIItotq/ﬁdnq

3570

A.M.Novak et al.

 

However, in practice, insufficient rigor in defining the substrings to
detect, and a failure to account for other variation near identified
point mutations have limited the approach’s usefulness. Here, we
formalize and extend this core idea; we propose using multiple, al—
gorithmically defined context strings to canonically identify the
presence of each base within a reference genome (potentially paving
the way for high—specificity, alignment—free variant calling) and
evaluate the performance of such a method in practice.

2 Methods

Throughout we make use of DNA strings, which are finite strings
over the alphabet of DNA bases {A. C. G.T}. A DNA string x has a
reverse complement x", which is the reverse of x with each DNA
base replaced with its complement; A and T are complements of
each other, as are G and C.

2.1 Mapping
A reference (genome) G is a set of DNA strings and an index set of
the elements of these strings, each member of which is called a pos-
ition. Each position 17 uniquely identifies an element b(p) of a string
in G. This allows us to unambiguously discuss the “positions” in
that set of DNA strings, rather than “bases” or “characters”, which
could be interpreted as the four DNA bases themselves.

We define the problem of mapping a query DNA string
x : (xi):1 to a reference G. A mapping scheme is a function that
takes x and G and, for each query element 1' of x, either returns a pos—
ition in G, declaring the query element 1' to be mapped to that position
in G, or declares the query element to be unmapped in G. For the
scheme to map a query element to a position 17 in G, b(p) must either
be x, (in which case that query element is forward mapped), or xi" (in
which case that query element is reverse mapped).

2.2 Contexts

A context is a tuple (L, B, R), where L is a DNA string called the left
part, B the base and R is a DNA string called the right part. The
string LBR is the context string of the context (L, B, R). The context
distinguishes B from the rest of the context string, so that when the
context is found to occur in a query string, it is clear which character
in the query string (i.e. the one corresponding to B) has been recog—
nized. For an element 1' in a DNA string x a context (L, B, R) is
called a natural context if B :x,, L is a (possibly empty) suffix of
(99);: and R is a (possibly empty) prefix of (ac/$2.“.
natural contexts are visible in Supplementary Figure 51.

Some example

2.2.1 Context generality

A context c1 : (L1.B1.R1) is forward more general than a context
6; : (L2,B2, R2) if L1 is a suffix of L2, B1 2B2, and R1 is a prefix of
R2. That is, if you turned the two contexts into strings with their
bases marked as special characters, the more general context would
be a substring of the less general context. Note that a context is for—
ward more general than itself. A context c1 is reverse more general
than a context 62 if 61 is forward more general than the reverse com—
plement of Q, which is c; : (R§.B§. L3). We define a context c1 to
be generically more general than context 62 if it is either forward
more general or reverse more general than 62.

2.3 Context—driven mapping

It is possible to define a mapping scheme for a query string x to a
reference G in terms of contexts for positions in the reference. Such
a mapping scheme makes use of a context assignment.

2.3.1 Context assignment

A context assignment assigns each position in a reference a non—
empty context set, such that all contexts in the set have the same
base as the position, and no context in one position’s set is more
general than any context in any other position’s set (Fig. 1). This se—
cond property of context assignments is called non-redundancy.

2.3.2 Matching

An element 1' in a query string x is said to match a context
c : (L,B,R) if the query, when partitioned into the context
((xj);;i.xi. (xi);- +1), is less general than 6. Note that this encom—
passes both forward less general (in which case element 1' forward
matches the context) and reverse less general (in which case element 1'
reverse matches the context). When the context is in the context set of

a reference position, the element matches the position on the context.

2.3.3 Context-driven mapping schemes

A context-driven mapping scheme is a mapping scheme which, for
query x and reference G with context assignment C, maps each
element 1' in x to the unique position in G which it matches under C,
or leaves 1' unmapped when no such position exists. An element re—
mains unmapped when it does not match any context of a reference
position, or when it matches contexts of two or more positions; in
the latter case we say it discordantly matches, an example of which
is visible in Supplementary Figure 52.

Under a (non—redundant) context assignment, each position 17 in
the reference can be mapped to, because for each context (L, B, R)
of p the context string LBR matches 17 on that context. The non—
redundancy requirement ensures that this matching is not discord—
ant: no context more general than (L, B, R) can be in the context set
of any other position in the reference.

2.3.4 Stability

An extension of a DNA string x is a DNA string that contains x as a
substring. An element k in an extension x’ of x is a partner of an
element 1' in x if the context ((xj);;i.xi.(x,')7:i+1) is more general
than <<x;>f;11.xr.<x;>,:t.1>.

A mapping scheme is weakly stable if for each element 1' in each
possible query string x, ifi is mapped to a position 17 in the reference,
its partners in all extensions of x will map to p or be unmapped.
Weak stability is desirable because it guarantees that an element in a
query cannot change its mapping to a different position under exten—
sion—the mapping scheme never has to admit that it mistook one
reference position for another when presented with more informa—
tion. Unlike score—based mapping procedures, which are generally
not weakly stable, all context—driven mapping schemes are weakly
stable, because for any mapped element 1', the partners of i in an ex—
tension of the query string can only either map to the same position
17, or be discordantly matched and therefore unmapped. This is be—
cause these partners have all the natural contexts of i, and therefore
must match on a context in the context set of p, but may

Contexts for position P1 Contexts for position P2
(L, b, R) (L7 b, R)
TGTCGC C CAAGCA ACGAC C CCAG
TGGCGC C CAAGCA CGAC C CT
TGTCGC C CACA ACGAC C CCATG

 

Fig. 1. Example of two non-redundant context sets. Substitutions relative to
the first context in each set are in bold. If the context (L, B, R) : C, C, C were
added to either set, it would make the context assignment redundant, as it is
more general than contexts that already occur in both sets

ﬁm'sreumol‘prqxo'sopeuuoptrotq/ﬁdnq

Canonical, stable, general mapping using context schemes

3571

 

additionally match on the context of a different position in the refer—
ence and therefore discordantly match.

A mapping scheme is stable if for each element 1' in each possible
query string x, ifi is mapped to a position 17 in the reference, its part—
ners in all extensions of x will map to 17. Stability is naturally a more
desirable property than weak stability, as it restricts mapping to in—
dividual positions aligned with high certainty. By the argument
above, some context—driven mapping schemes are only weakly sta—
ble. A stable context-driven mapping scheme is equivalent to a con—
text—driven mapping scheme that additionally makes an element of a
query string unmapped if a partner element in any extension of the
query would discordantly match.

2.4 The natural context—driven mapping scheme

In our earlier paper (Paten et al., 2014) we discussed a number of
different context assignments, including fixed k—mer approaches.
Here, we focus on a new scheme that is easy to reason about and
which performed the best in our preliminary empirical tests
(Supplementary Fig. S3).

The natural context assignment assigns to each position in the
reference the subset of its natural contexts that are not natural
contexts of any other position in the reference. It is trivially non—
redundant. The natural (context-driven mapping) scheme, which
uses the natural context assignment, has an intuitive interpretation:
an element 1' of a query string is mapped to a position 17 of the refer—
ence when all natural contexts ofi with context strings unique in the
reference are assigned to 17.

2.4.1 Overview of algorithms

The natural context scheme is also simple to implement. For a refer—
ence and query, a maximum unique match (MUM) is a maximum
length substring of the query present once in the reference. Our def—
inition of a MUM differs from that used by tools like MUMmer
(Delcher et al., 1999) in that it is non—symmetric; we allow a MUM
to have multiple MUM instances in the query, each of which is a
MUM and an interval of the query corresponding to a location of
the substring. For a query x of length 11 there are at most 11 MUM in-
stances, since two cannot start at the same place. Each MUM in—
stance that contains a given element 1' can be described as a natural
context string of i: (x;)i_1xi(x,')i+1. Under the natural context assign—
ment, the context of each such MUM—derived context string matches
exactly one reference position.

Using a suffix tree with suffix links of the strings in a reference
(which can be constructed in time linear in the sum of the length of
the reference strings), or a related substring index data structure, it
is possible to find the set of MUM instances for a query string
ordered by ascending start element in O(n) time. These data struc—
tures all provide two 0(1) operations, extend and retract, which,
given a search result set for some search string, can produce the re—
sult set for a search string one character longer or shorter, respect—
ively. Employing these operations to find all MUMs in order by
ascending query start position is straightforward. Starting with the
empty string, extend the search string on its right end with succes—
sive characters from the query string until such an extension would
produce a search result set with no results (or until the query string
is depleted). If at that point there is one result in the result set, and
at least one extension has happened since the last retraction, then a
MUM has been found. Next, retract a single character from the left
end of the search string, and go back to extending with the remain—
ing unused query string characters. Repeat the whole process until
the query string is depleted.

Since each successful extend operation consumes a character
from the query string, no more than O(n) extend operations can
ever be performed. Since each retract operation moves the left end
of the search string to the right in the query, no more than O(n) re—
tract operations can be performed. And since each unsuccessful ex—
tend operation (which would produce an empty result set) is
followed by a retract operation, no more than O(n) of those can
happen either. Thus, the entire algorithm is O(n).

Once the MUM instances have been found, it is necessary to
identify the query elements that occur in exactly one MUM and
therefore can be mapped under the natural scheme. (If an element is
contained in two or more MUM instances then it must be discord—
antly mapped, because each must define a context that matches the
element to a distinct position.) Given the MUM instances ordered
by ascending query start element, it can be determined for all elem—
ents if each is in one, zero or multiple MUM instances, by a single
traversal of the ordered MUM instances taking O(n) time. We can
therefore determine in O(n) which elements in a query string are
mapped. The combined time to map all the elements in a new query
string given an existing reference substring index data structure of
the type discussed is therefore O(n).

2.5 The oc-ﬁ—natural context—driven mapping scheme
Under the natural context assignment, for each (by definition min—
imally unique) reference context string, there must exist another ref—
erence substring that is an edit distance of one from it. Therefore,
while the natural context assignment ensures each context identifies
a single position in the reference, a single substitution, insertion or
deletion in a query substring could result in a change in mapping.
To avoid this, we now define a more robust scheme.

Throughout, we use the Levenshtein edit distance, in which a
single character replacement, insertion or deletion is worth one.
This choice of edit distance metric makes reasoning about the behav—
ior of our algorithms simpler, but they could potentially be extended
to other metrics tailored to different sequence data sources.

For a pair of overlapping substrings (xi). (xk) of a string x, we
call elements in either substring not contained within the intersec—
tion of their intervals on x separate. For two substrings within the
reference (not necessarily overlapping or even in the same reference
string) we can similarly talk about their number of separate elem—
ents. For a given reference substring, the oc-separation is the min—
imum edit distance or between it and any other substring in the
reference with a number of separate elements greater than its edit
distance from the original substring. For a given natural context of a
reference position, its oc—separation is the oc—separation of its context
string.

Having a minimum or—separation for contexts in a natural con—
text scheme makes mappings more stable in the face of edits to the
query. Specifically, it ensures that the number of edits required to
transform the context of one position into the context of another is
at least at, for positions whose context strings have more than or sep—
arate elements. When two reference substrings with or edit distance
have exactly or separate elements (it is easy to verify that they cannot
have fewer than or) then there exists a minimum edit—distance align—
ment of the two substrings that only aligns together bases from each
substring with the same reference positions, and the or edit distance
is therefore trivially realizable as the removal of a prefix from one
substring and a suffix from the other. However, it is also possible
that two substrings with or edit distance and or separate elements
could have other minimum edit distance alignments that would re—
sult in different mappings. Therefore, enforcing oc—separation on a

ﬁm'sreumol‘prqxo'sopeuuoptrotq/ﬁdnq

Section Sl

Section Sl

Supplementary

Li, 2013 Li and Homer, 2010

Figure 2

Supplementary

.‘e uer or In St ‘ 'u
S 111g ( )1 )1t1 m, 1999

The MHC

/810'sreumofp103xo'sopeuuoylrorq”:dnq

Flat Length Threshold

1
L1:1

 

The A41 1C Sequencing Consortium, 1999 Fig. 3

Fig. .) Fig. .)

Church (7/ al., 2011

Schneider

and Church, 2013 Fig. 3

Su ppleinentar} Figures S4 a

S4b

Supplementar) Fig. S4b

Figure 3 Earl (7/ al., 2014

Figure 4

Figures 3

1\4ed\ ede\
(7/ al., 2007 Paten (7/ al., 2011

1\4ed\ede\ (7/ al., 2007 Paten (7/ al., 2011

/310'SIBanoprOJxo"sorJBuiJOJurorqﬂ:dnq

2012

 

Supplementar) Figure S.

Quail (7/ al., 2012

Quail (7/ al.,

Harris. 2007 Li and Durbin, 2010

igure 5a and b

Figure 5c and d 1\4e'\e1~ (7/ al., 2013

Fig. 5c and d

Fig. 5c and d

Figure 6

Fig. 5

/310'SIBanoprOJxo"sorJBuiJOJurorqﬂ:dnq

Figure 3

Sherr) el al., 2001

 

Li (7/ al., 2008

Fig. 55

cl al., 2014

Supplementar)

Supplementar) Fig. S6

Paten

/310'SIBanoprOJxo"sorJBuiJOJurorqﬂ:dnq

3576

A.M.Novak et al.

 

Paten,B. et al. (2011). Cactus graphs for genome comparisons.  Compnt.
Biol., 18, 469—481.

Paten,B. et al. (2014). Mapping to a reference genome structure. arXiU [77e-
p7inta7Xiv:1404.5010.

Quai1,M.A. et al. (2012). A tale of three next generation sequencing platforms:
comparison of ion torrent, paciﬁc biosciences and illumina MiSeq sequen-
cers. BMC Genomics, 13, 341.

SChneider,V., and Church,D. (2013). Genome reference consortium. In: The
NCBI Handbook [Internet], 2nd edn. National Center for Biotechnology
Information (US), Bethesda, MD.

Sherry,S.T. et al. (2001). DBSNP: the NCBI database of genetic variation.
Nucleic Acids Res., 29, 308—311.

The MHC Sequencing Consortium (1999). Complete sequence and gene map
of a human major histocompatibility complex. Nature, 401, 921—923.

/810'sreumofp103xo"soueuuogurorqﬂ:dnq

