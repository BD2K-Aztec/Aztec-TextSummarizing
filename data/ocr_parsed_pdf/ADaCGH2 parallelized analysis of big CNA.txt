BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

R. Diaz-Uriarte

 

the code has been rewritten to use forking, data handling and
reading of input data has been completely modiﬁed so that data
much larger than available memory can be read and analyzed
and missing value handling has been changed to use all available
data per array. The vignette benchmarks .pdf provides exten—
sive comparisons between the new (32.3.5) and latest previous
running versions (version 1.10), but the main differences between
these two versions are as follows:

0 Reading and analysis of large datasets. The new version can
read datasets much larger than the old one and datasets
much larger than available memory (see details in Section
3). As a consequence of being able to read much larger
datasets, the new version can analyze datasets much larger
than the old one.

0 Missing value handling. The old version used row—wise dele—
tion of missing values when reading data (i.e. a probe would
be deleted from the data if it had one missing value in any
array/column). The new version deals with missing values
array by array, so for each array (or column) all available
data (or probes) are used in the segmentation.

o Forking and clusters. The new version of ADaCGH2 allows
for the usage of forking or an explicit cluster (e.g. MPI,
sockets) to parallelize reading and analysis. In POSIX oper—
ating systems (including Unix, GNU/Linux and Mac OS),
forking can be faster, less memory consuming and much
easier to use than a cluster.

0 Flexibility of reading data and compatibility with former
version. The new version of ADaCGH2 has not removed
the mechanisms of reading data available in the old version
(when data are small or memory is plentiful, reading data
from a single RData is an available option) and accepts data
read by the former version. However, the old version cannot
accept data read by the new version because it assumes that
data that have been read contain no missing values.

These differences in implementation, however, do not affect
the underlying core code for the algorithms, which is the same as
in the previous version. There have been, however, changes in
some defaults to adapt the package to really large data (e. g. using
MAD as merging default or using ‘haarseg’ as the ‘smoothfunc’
for daglad, following recommendations in the package vignette
for GLAD).

3 BENCHMARKS

Figure 1 shows benchmarks of reading and analyzing data with
6067 433 probes per array/column. Those flgures compare
memory usage and wall time of the old and new versions and
of the non—parallelized (NP) versions in two different machines
(data for the ﬁgures, as well as benchmarks for a third machine,
and with MP1 over two machines, are available from the vignette
‘benchmarks.pdf). To give an idea of sizes, the RData file for the
1000 arrays data is of ~41 GB, and the directory with the data
for 2000 columns/arrays occupies ~198 GB.

Compared with the NP version, in the analysis of data,
ADaCGH2 leads to speed increases by factors of 2&40 times

(a) AMD Opteron 6276, 64 cores, 256 GB RAM

 

   
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Reading
,'
50‘ 100-
._ 50-
EN. P 9 .... 
m >.
s 5
%1o- EZO‘
g  E + Old version
,.- no» Newversion
5_ _, 1o
,1,
.o‘ '1]
3-....... 6";
l l l I ' ' ' I V I I
o o o o o o o ° ° ° ° o o o
no o o o o o a no o o o 0 ° ‘3
F N m e a 2 ' N "’ 9 3 9’
Arrays Arrays
Analysis
2: 256- + H NP
 _ aar,
’1’: 200 -o— Haar.0ld
.’ -o- Haar,New A—
+ cas NP
, HMM.OId
mm + CES,OId .o- HMM,New
9 -v- cas, New + BioHMM,OId
‘. > -A- BiuHMM, New
_
1,. g 50-
d.)
E 30—
20-
12-

 

 

 

 

o
o

o
o

50
100 -
200 -

1000
2000
4000 -

50
1 00
200 -

1000
2000 -
4000

 

 

 

 

 

Arrays Arré'S/s
(b) Intel Xeon E5645, 12 cores, 64 GB RAM
Reading
,I" so—
200. + Old version ,x
-~0~ Newversion " 25‘
€100- , A
0  a
E 20-  E15—
; 10—  E
5_  10

L
;

 

 

 

 

 

 

 

 

 

 

 

 

 

.
 
O O O O O O D O O 0 O O O C
m o o o o o o m o o o o o o
‘— N m o o o .— N m o o o
Arrays ‘— “‘ ’ Arrays ‘— N ’
Analysis
4o—
/ 35- v
1000— ' V ,.-" 30- + Haar. NP
,u’ + HaarOId
_ ,. 25- v
E 500  A ~<>~v Haarv New
E  $20- + CBS. NP
v _ ,- " v + CBS. Old
a, 100   5.15—‘\; -v.» ch,New
E 50- _,..--’ o
1.:  512-
E o ,  £1“
E 10-  + HMM. Old A ..—-'
5- -<§-- HMM. New  y.
+ BioHMM, Old   '
A» BioHMM, New 5_ f;;:;;:__,_.., ---------- “"
1 l l l l . . . l l l . .
O O O O O D O O O O O D
in o o o o o m o o o o o
‘— N o o c ‘— N o o o
Arrays ‘— “‘ " Arrays " “‘ V

Fig. 1. Wall time and memory use (summed over all spawned processes)
of reading and analysis as a function of number of arrays. Reading:
comparison between new and old versions. Analysis: new and old ver-
sions with four segmentation methods and NP for two methods. No
benchmark allowed to run for >36 h. Without parallelization, in the
AMD machine no runs of CBS with 1000 arrays or HaarSeg with 2000
can be done (R runs out of memory); in the Intel machine no runs for
1000 arrays with any method can be done (R runs out of memory)

in the 64 cores machines and 7710 times in the 12 cores machines,
and allows us to analyze data that would not ﬁt in memory.
Compared with the former version, the new version uses less
memory for analysis. More importantly, the new version allows
us to read and analyze much larger datasets. In the 256 and

 

1760

ﬁm'spzumofpmﬂo'sopeuuopnorq/ﬁdnq

ADaCGH2

 

Single (multicore) computer

data frame

 

 

   

 

 

 

E . RD E

: (RAMobJeco “3 “We :

I MAList :

E Flimma) directory :

. Sengst :

; (snapCGH) E

: :

: : Cluster of
i i l ’

: data frame ff objects :  TEE]:
: (RAM object) ’ ' p

a a
E data frame )7“ objects E

5 (RAM object) I

E outputToCGHregionsl lpChromPlotl E
E data frame (CGHregions) png ﬁles l 1mg ﬁles

 

 

 

Fig. 2. Work ﬂow from input data to ﬁgures. R functions are shown with
courier font inside boxes. In italics are the names of other packages,
which can provide input/accept output. Data frames are stored in
memory, in contrast to ﬂ objects. Data input and conversion to ﬂ objects
are done with inputToADaCGH (maybe after using cutFile for par-
allelized reading of single-column ﬁles). Segmentation is performed with
pSegment, and results can then be plotted (pChromPlot) or used by
other packages (outputToCGHregions). When using ﬂ objects, after
data input (in a single machine) the remaining analyses can be conducted
in a cluster

384 GB machines the old version cannot read datasets with
32000 arrays (R runs out of memory), and in the machine
with 64 GB of RAM it cannot read data with 3500 arrays (R
runs out of memory); as can be seen from the figure, the old
version shows a steep linear increase in memory consumption
with number of arrays. In sharp contrast, with the new version
we can read and analyze 4000 arrays in a machine with only 64
GB of RAM (Fig. 1b), and the scaling of memory usage with
number of arrays suggests that much larger datasets could be
read and analyzed. In addition, we can obtain speedups by fac—
tors of 2710 times (depending on machine and number of arrays)
in the reading step as it is parallelized.

4 WORK FLOW

Figure 2 shows the usual sequence of calls with ADaCGH2.
inputToADaCGH accepts input in different formats, including
objects used by limma (Smyth, 2005) and snapCGH (Smith
et al., 2009), and produces R data frames or ff objects, after
performing several checks and data sanitation. If data are read
from a directory with one—column ﬁles, reading is parallelized
(cutFile allows splitting a text ﬁle into one—column files).
pSegment can take as input R data frames and ff objects pro—
duced by inputToADaCGH. pSegment can use multiple cores
or multiple computers, and it can accept as input data frames or
ﬂ objects; when running on a cluster, only ff objects are used
(to avoid passing around large objects and to allow analyzing
large datasets). The output from pSegment can be converted so
it is accepted by the CGHregions package (Vosse and van de
Wiel, 2009), and creation of figures is also parallelized.

5 CONCLUSIONS

ADaCGH2 should be of immediate use for researchers involved
in the analysis of CNA data. Parallelization allows it to speed up
data processing, and it can handle data that will not ﬁt in
memory with excellent scaling of memory usage with number
of arrays. These behaviors are needed for the analyses of plat—
forms with increasing number of probes and multicenter studies
with thousands of subjects.

ACKNOWLEDGEMENTS

The author thanks 0. M. Rueda and D. Rico for collaboration
in previous versions of ADaCGH and for help debugging under
Mac OS, 0. M. Rueda for the initial benchmarking data,
C. Lazaro—Perea, O. M. Rueda, I. Lopez and three anonymous
reviewers for comments on the manuscript.

Funding: Spanish MINECO (Project BIO2009—12458).

Conﬂict of Interest: none declared.

REFERENCES

Adler,D. et al. (2013) M eniortt—Eﬂizfieitt Storage of Large Data on Disk and Fast
Access Functions. R package version 2, pp. 2711.

Ben—Yaacov,E. and Eldar,Y.C. (2008) A fast and ﬂexible method for the segmen—
tation of aCGH data. Bioinformatics, 24, i1397i145.

Carro,A. et al. (2010) waviCGH: a web application for the analysis and visualiza—
tion of genomic copy number alterations. Nucleic Acids Res., 38, W1827W187.

Diaz—Uriarte,R. and Rueda,O.M. (2007) ADaCGH: a parallelized web—based
application and R package for the analysis of aCGH data. PLoS One, 2, e737.

Duan,J. et al. (2013) Comparative studies of copy number variation detection
methods for next—generation sequencing technologies. PLoS One, 8, e59128.

Fridlyand,J. et al. (2004) Hidden Markov models approach to the analysis of array
CGH data. J. Multivar. Anal., 90, 1327153.

Grozeva,D. et al. (2012) Independent estimation of the frequency of rare CNVs in the
UK population conﬁrms their role in schizophrenia. Scliizopltr. Res., 135, 177.

Hsu,L. et al. (2005) Denoising array—based comparative genomic hybridization data
using wavelets. Biostatistics, 6, 2117226.

Hupe,P. et al. (2004) Analysis of array CGH data: from signal ratio to gain and loss
of DNA regions. Bioiiy’ormatics, 20, 341373422.

Marioni,J.C. et al. (2006) BioHMM: a heterogeneous hidden Markov model for
segmenting array CGH data. Bioiiy’ormatics, 22, 11444146.

Picard,F. et al. (2005) A statistical approach for array CGH data analysis. BMC
Bioiiﬁ’ormatics, 6, 27.

Smith,M.L. et al. (2009) snapCGH: Segmentation, Normalisation and Processing of
aCGH Data. R package version 1.31.0.

Smyth,G.K. (2005) Limma: linear models for microarray data. In: Gentleman,R.
et al. (ed.) Bioinformatics and Computational Biology Solutions Using R and
Bioconiluctor. Springer, New York, pp. 3977420.

Valsesia,A. et al. (2013) The growing impormnce of CNVs: new insights for detec—
tion and clinical interpretation. Front. Genet., 4, 1719.

Venkatraman,E.S. and Olshen,A.B. (2007) A faster circular binary segmentation
algorithm for the analysis of array CGH data. Bioiiy’ormatics, 23, 657%63.
Vosse,S. and van de Wiel,M. (2009) CGHregions: Dimension Reduction for Array

CGH Data with Minimal Information Loss. R package version 1.7.1.

Wu,Y. et al. (2013) MATCHCLIP: locate precise breakpoints for copy number vari—
ation using CIGAR string by matching soft clipped reads. Front. Genet., 4, 177.

Zhao,M. et al. (2013) Computational tools for copy number variation (CNV)
detection using next—generation sequencing data: features and perspectives.
BMC Bioinﬁ)rmatics, 14, SI.

Zheng,C. et al. (2013) Determination of genomic copy number alteration emphasiz—
ing a restriction site—based strategy of genome re—sequencing. Bioiiy’ormatics, 29,
281372821.

 

1761

ﬁm'spzumot‘pmjxo'sopeuuqutotq/ﬁdnq

