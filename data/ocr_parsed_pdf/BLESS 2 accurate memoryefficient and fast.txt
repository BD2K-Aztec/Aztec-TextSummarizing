Bioinformatics, 32115), 2016, 2369—2371

doi: 10.1093/bioinformatics/btw146

Advance Access Publication Date: 24 March 2016
Applications Note

 

 

Genome analysis

BLESS 2: accurate, memory-efficient and fast

error correction method

Yun Heo1, Anand Ramachandran1, Wen-Mei ku1, Jian Ma2 and

Deming Chen1'*

1Department of Electrical and Computer Engineering, University of Illinois at Urbana-Champaign, Urbana, IL 61801,
USA and 2Computational Biology Department, Carnegie Mellon University, Pittsburgh, PA 15213, USA

*To whom correspondence should be addressed.
Associate Editor: Inanc Birol

Received on July 25,2015; revised on March 7, 2016; accepted on March 12, 2016

Abstract

Summary: The most important features of error correction tools for sequencing data are accuracy,
memory efficiency and fast runtime. The previous version of BLESS was highly memory—efficient and
accurate, but it was too slow to handle reads from large genomes. We have developed a new version
of BLESS to improve runtime and accuracy while maintaining a small memory usage. The new ver—
sion, called BLESS 2, has an error correction algorithm that is more accurate than BLESS, and the al—
gorithm has been parallelized using hybrid MP1 and OpenMP programming. BLESS 2 was compared
with five top—performing tools, and it was found to be the fastest when it was executed on two com—
puting nodes using MP1, with each node containing twelve cores. Also, BLESS 2 showed at least 11%
higher gain while retaining the memory efficiency of the previous version for large genomes.
Availability and implementation: Freely available at https://sourcef0rge.net/projects/bless—ec

Contact: dchen@illin0is.edu

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

Correcting errors in sequencing reads is a time-consuming and
memory-intensive process. The occurrences of patterns (k-mers in
many tools) in reads should be counted, and patterns with a small
number of occurrences have to be replaced with ones having a large
number of occurrences. Storing patterns requires a lot of memory,
and searching for alternative patterns takes a long time for large
genomes. Therefore, memory efficiency and fast runtime are as
important as accuracy in error correction methods.

To provide a memory-efficient error correction method, BLESS,
which uses a Bloom filter as the main data structure, was developed
(Heo et (11., 2014). While BLESS could generate accurate results
with a much smaller amount of memory than previous tools, it was
too slow to he applied to reads from large genomes.

Recently, some new error correction methods that can correct
errors in a large dataset in a short period of time have been de-
veloped (Li, 2015; Song et (11., 2014). However, to the best of our
knowledge, none of the present tools satisfy all the three constraints
(i.e. memory efficiency, runtime and accuracy).

To address the three requirements, we have developed a new ver-
sion of BLESS. In BLESS 2, the accuracy of the error correction algo-
rithm has been further improved over that of BLESS by adding new
algorithmic steps. BLESS 2 corrects errors even in solid k-mers, k-mers
that exist multiple times in reads, using the quality score distribution of
input reads. Solid k-mers were originally treated as error-free k-mers.
There is also a new algorithm introduced in BLESS 2 for trimming
reads where errors cannot be corrected or corrections are ambiguous.
In addition to quality improvements, the overall execution has been
parallelized using hyhrid MP1 and OpenMP programming, which
make BLESS 2 the fastest tool when executed on multiple computing
nodes. All these improvements were made without hurting the memory
efficiency of the predecessor.

2 Methods

BLESS 2 is parallelized using hyhrid MP1 and OpenMP program-
ming. Therefore, the process can not only he parallelized on a server

(63 The Author 2016. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 2369

/310‘slcumo[p10}xo‘sopcuHOJIItotq/ﬁdnq

Figure 1

Dcorowicz cl (1]., 2015

2013
2011

Li, 2015

Li, 2015

Song cl (1]., 2014
bdarcais cl (1]., 2013
Table 1

Liu cl (1].,
Simpson and Durbin,

 

/810'sleum0[pJOJxo'sopeuiJOJuioiq”:duq

BLESS 2: accurate, memory—efficient and fast error correction method 2371

 

among the compared tools. The percentage of trimmed bases rose
from 0.9% for D1 and D2 to 1.6% for D3. Since trimming increases
the chances that a read aligns to multiple locations, the aligned loca—
tions of BLESS 2’s output reads were compared with those of the un—
corrected reads. The result showed that 99.8% of D3 reads were
aligned the same location after error correction. This is discussed in
more detail in Section 5.1 of supplementary document.

The effect of error correction on DNA assembly was also as—
sessed. D3 and its error correction results were assembled using
Gossamer (Conway et al., 2012) and the assembly results were com—
pared using Quast (Gurevich et al., 2013). All the error correction
tools helped improve the NG50 length, and the improvement was
the most when using BLESS 2. Details are presented in Section 5.2.
of supplementary document.

While BLESS 2 consumed the smallest amount of memory for
D2, Lighter used the least memory for D1. This is because KMC that
is invoked in BLESS 2 requires a constant 4 GB of memory irrespect—
ive of genome size. For D2, the size of the Bloom filter in BLESS 2
was larger than 4 GB and KMC was no longer a memory bottleneck.

The runtime of BLESS 2 on one computing node was comparable
to that of the other methods, and BLESS 2 became the fastest tool
when more nodes were available. When four nodes were used,
BLESS 2 became 2.3 times faster than when one node was used. The
current version of BLESS 2 reads input read files three times (i.e. for
analyzing quality scores, counting k—mers using KMC and correcting
errors), and reading compressed input read files consumes a signifi—
cant amount of time. Since there is no efficient way to read a

compressed file in parallel, this part cannot be accelerated even
when the number of available nodes increases. In the next version,
KMC source code will be embedded in BLESS 2 and we could ana—
lyze quality scores while counting k—mers using KMC, giving further
speedup.

Conﬂict of Interest: none declared.

References

Conway,T. et a1. (2012) Gossamer — a resource-efﬁcient de novo assembler.
Bioinformatics, 28, 1937—1938.

Deorowicz,S. et al. (2015) KMC 2: Fast and resource-frugal k-mer counting.
Bioinformatics, 3 1, 1569—1576.

Gurevich,A. et al. (2013) QUAST: quality assessment tool for genome assem-
blies. Bioinformatics, 29, 1072—1075.

Heo,Y. et al. (2014) BLESS: Bloom ﬁlter-based error correction solution for
high-throughput sequencing reads. Bioinformatics, 30, 1354—1362.

Li,H. (2015) BFC: correcting Illumina sequencing errors. Bioinformatics, 31,
2885—2887.

Liu,Y. et al. (2013) Musket: a multistage k-mer spectrum—based error correc-
tor for Illumina sequence data. Bioinformatics, 29, 308—315.

Marcais,G. et al. (2013) QnorUM: An error corrector for Illumina reads.
arXiv preprint arXiv:1307.3515.

Simpson,]. and Durbin,R. (2011) Efﬁcient de novo assembly of large genomes
using compressed data structures. Genome Res., 22, gr.126953.126111-
126556.

Song,L. et al. (2014) Lighter: fast and memory-efﬁcient sequencing error cor-
rection Without counting. Genome Biol., 15, 509.

[BJO'SWHIHOIPJOJXO'SOplZIIJJOJLIIOIQ/[idnq

