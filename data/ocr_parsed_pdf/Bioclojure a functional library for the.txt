BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

J.Plieskatt et al.

 

importantly, it establishes a framework for parsing sequence files using
the functions ‘bs-reader’ and ‘biosequence-seq’. Almost every module in
BioClojure implements these functions to access its particular sequence
format or type of data. When used in combination with the in-built
Clojure macro ‘with-open’, these functions provide lazy access to on-
disk data. For example, a simple pipeline to translate a file of nucleotide
sequences in six-reading frames would use these functions in the following
way:

user> (with—open [r (bs—reader fasta—file)]
(—>> (biosequence—seq r)
(mapcat # (six—frame—translation %) )
realized?) )

false

This code provides a lazy sequence of FASTA protein sequences rep-
resenting the six-frame translation of nucleotide sequences from ‘FASTA-
file’. The final call to ‘realized?’ merely illustrates the lazy nature of the
calculation. The resulting sequences can be sent to the file using the
BioClojure function ‘biosequence->file’ or further processed using
BioClojure and/or user-defined functions. The use of immutable objects
and stateless iteration can lead to simple and easily understandable code.
A simple example of this is the following code, which returns counts for
biological process GO terms from secreted proteins in the UniProt
Human proteome dataset:

(with—open [r (bs—reader up—hs—proteome)]
(—>> (biosequence—seq r)
(filter # (some (fn [x] (= “Secreted”
( :text x) ) )
(subcellular—location %) ) )
(mapcat bp—go—terms)
frequencies) )
{“neurotrophin TRK receptor signaling pathway”
36,  .

The defined interfaces of BioClojure are designed to be lazy and com-
posable in this way, and thus, more complex examples of these simple
lazily evaluated pipelines can be developed.

2.2 Sequence formats

At present, BioClojure supports sequence data formatted as Uniprot
XML, Genbank XML FASTA and FASTQ. For each format, apart
from parsers, BioClojure provides accessors specific to that format (see
https://github.com/s312569/clj-biosequence for detailed documentation).
BioClojure also provides functions for remote searching and sequence
retrieval from UniProt and GenBank. For mapping of identification
numbers, BioClojure provides the ‘id-convert’ function that uses the
UniProt accession mapping service to convert accession numbers from
one database format to another. Integration of diverse file formats with
the structure provided by the core module is implemented using Clojure
protocols; therefore, implementation of modules for new formats is facile,
with additional formats, in particular GFF and GTF, expected to be
supported in the near future.

2.3 Application wrappers

In addition to sequence data, BioClojure also provides wrappers for
running BLAST, SignalP, THMHH and Interproscan as well as parsers
for their output. Once again, integration of these tools with BioClojure

emphasizes lazy evaluation and composability, which simplifies integra-
tion of the tools with other parts of BioClojure.

2.4 Persistence

The ‘index’ module provides functions for producing compressed and
indexed files. An indexed file implements ‘biosequence-seq’ and thus
can be used the same way as described above, but without the require-
ment for using ‘with-open’ or ‘bs-reader’. Indexed files also provide rapid
random access to indexed sequences using the ‘get-biosequence’ function.

2.5 Concurrency

One of the primary motivations for using Clojure is the built-in support
for concurrent operations. One simple example of this support is the
‘pmap’ function. The Clojure function ‘map’ serially applies a function
to a list of inputs, returning a list of the outputs, and ‘pmap’ performs the
same operations using multiple threads. If the computational cost of the
applied function outweighs the coordination costs, significant perform-
ance gains are possible, as shown below using the SwissProt database:

user> (time (with—open [r (bs—reader swissprot)]
(last (map protein—charge
(biosequence—seq r) ) ) ))
“Elapsed time: 101232 . 610534 msecs”
5.778330187793381
user> (time (with—open [r (bs—reader swissprot)]
(last (pmap protein—charge
(biosequence—seq r) ) ) ))
“Elapsed time: 30552 . 548286 msecs”
5.778330187793381

In practice, ‘pmap’ initiates a limited number of threads, based on the
number of cores; therefore, for large datasets, or asynchronous calls, a
finer-grained control over the number of threads and their behavior can
be obtained using Clojure’s software transactional memory, agent and
atom systems.

3 CONCLUSION

BioClojure is a functional software library speciﬁcally designed
for parsing and processing biological sequence data. It provides a
lazy and thread—safe framework for accessing and streaming
these data while using minimal amounts of memory. Presently,
we extensively use the library for the annotation of nucleotide
and peptide sequences arising from next—generation sequencing
and the proteomic analysis of complex protein mixtures. We plan
to extend the functionality of the library by incorporating mod—
ules for phylogenetic and proteomic analyses, and we welcome
contributions from the community.

Funding: National Health and Medical Research Council,
Australia (grant number 1051627), as well as award

ROlCA155297 from the National Cancer Institute.

Conﬂict of Interest: none declared.

 

2538

ﬁm'spzumol‘pmJXO'sopeuHOJmorq/ﬁdnq

A functional library for the manipulation of biological sequences

 

REFERENCES

Backus,J. (1978) Can programming be liberated from the von Neumann style?: a
functional style and its algebra of programs. Comman. ACM, 21, 6137641.
Cock,P.J. et a]. (2009) Biopython: freely available Python tools for computational
molecular biology and bioinformatics. Bioinformatiuv, 25, 142271423.

Dutheil,J. et a]. (2006) Bio ++: a set of C ++ libraries for sequence analysis, phylo—
genetics, molecular evolution and population genetics. BMC Bioinformatiuv, 7,
188.

Hickey,R. (2008) The clojure programming language. In: Proceedings of the 2008
Kymposium on Dynamic languages. p.l. ACM, New York, NY.

Hudak,P. (1989) Conception, evolution, and application of functional programming
languages. ACM Compat. Sarv. (CSUR), 21, 35%411.

Prlic,A. et a]. (2012) Biojava: an open—source framework for bioinformatics in 2012.
Bioinformatiex, 28, 269372695.

Stajich,J.E. et a]. (2002) The bioperl toolkit: Perl modules for the life sciences.
Genome Re.\'., 12, 161171618.

 

2539

/3.IO'S[BIIInO[p.IOJXO'SOIJBLUJOJIIIOIq/ﬂduq

