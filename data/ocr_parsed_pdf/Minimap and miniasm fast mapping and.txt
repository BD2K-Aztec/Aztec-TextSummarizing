Bioinformatics, 32(14), 2016, 2103—2110
doi:10.1093/bioinformatics/btw152

Advance Access Publication Date: 19 March 2016
Original Paper

 

Sequence analysis

Minimap and miniasm: fast mapping and de
novo assembly for noisy long sequences

Heng Li
Medical Population Genetics, Broad Institute, Cambridge, MA 02142, USA

Associate Editor: Inanc Birol

Received on Decemberﬁ, 2015; revised on March 14, 2016; accepted on March 14,2016

Abstract

Motivation: Single Molecule Real—Time (SMRT) sequencing technology and Oxford Nanopore tech—
nologies (ONT) produce reads over 10 kb in length, which have enabled high—quality genome as—
sembly at an affordable cost. However, at present, long reads have an error rate as high as 10—
15%. Complex and computationally intensive pipelines are required to assemble such reads.

Results: We present a new mapper, minimap and a de novo assembler, miniasm, for efficiently
mapping and assembling SMRT and ONT reads without an error correction stage. They can often
assemble a sequencing run of bacterial data into a single contig in a few minutes, and assemble
45—fold Caenorhabditis elegans data in 9min, orders of magnitude faster than the existing pipe—
lines, though the consensus sequence error rate is as high as raw reads. We also introduce a pair—
wise read mapping format and a graphical fragment assembly format, and demonstrate the inter—

 

operability between ours and current tools.

Availability and implementation: https://github.com/lh3/minimap and https://github.com/lh3/

miniasm
Contact: hengli@broadinstitute.org

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

High-throughput short-read sequencing technologies, such as
Illumina, have empowered a variety of biological researches and
clinical applications that would not be practical with the older
Sanger sequencing. However, the short read length (typically a few
hundred basepairs) has posed a great challenge to (16 1101/0 assembly
as many repetitive sequences and segmental duplications are longer
than the read length and can hardly be resolved by short reads even
with paired-end data (Alkan et (11., 2011). Although with increased
read length and improved algorithms we are now able to produce
much better short-read assemblies than a few years ago, the contigu-
ity and completeness of the assemblies are still not as good as Sanger
assemblies (Chaisson et (11., 2015).

The PacBio’s SMRT technology were developed partly as an an-
swer to the problem with short-read (16 1101/0 assembly. However,
due to the high per-base error rate, around 15%, these reads were
only used as a complement to short reads initially (Bashir et (11.,
2012; Koren et (11., 2012; Ribeiro et (11., 2012), until Chin et a1.
(2013) and Koren et a1. (2013) demonstrated the feasibility of

SMRT-only assembly. Since then, SMRT is becoming the preferred
technology for finishing small genomes and producing high-quality
Eukaryotic genomes (Berlin et (11., 2015).

Oxford Nanopore Technologies (ONT) has recently offered an-
other long-read sequencing technology. Although the per-base error
rate was high at the early access phase (Quick et (11., 2014), the latest
data quality has been greatly improved. Loman et a1. (2015) con-
firmed that we can achieve high-quality bacterial assembly with
ONT data alone.

Published long-read assembly pipelines all include four stages: (i)
all-vs-all raw read mapping, (ii) raw read error correction, (iii) as-
sembly of error corrected reads and (iv) contig consensus polish.
Stage (iii) may involve all-vs-all read mapping again, but as the error
rate is much reduced at this step, it is easier and faster than stage (i).
Table 1 shows the tools used for each stage. Notably, our tool mini-
map is a raw read overlapper and miniasm is an assembler. We do
not correct sequencing errors, but instead directly produce unpol-
ished and uncorrected contig sequences from raw read overlaps. The

idea of correction-free assembly was inspired by talks given by Gene

(63 The Author 2016. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 2103

/310‘srcumo[p10}xo‘sopcuHOJIItotq/ﬁdnq

2104

H.Li

 

Table 1. Tools for noisy long-read assembly

 

 

Functionality Program Reference

Raw read overlap BLASR Chaisson and Tesler (2012)
DALIGNER Myers (2014)
MHAP Berlin at al. (2015)
GraphMap Sovic et al. (2015)
minimap this article

Error correction pbdagcon http://bit.ly/pbdagc0n
falc0n_sense http://bit.ly/pbfcasm

nanocorrect Loman et al. (2015)
Assembly wgs-assembler Myers et al. (2000)
Falcon http://bit.ly/pbfcasm
ra-integrate http://bit.ly/raitgasm
miniasm this article
Consensus polish Quiver http://bit.ly/pbquiver

nanopolish Loman et al. (2015)

 

Myers. Sikic et a1. (personal communication) are also independently
exploring such an approach.

As we can see from Table 1, each stage can be achieved with
multiple tools. Although we have successfully combined tools into
different pipelines, we need to change or convert the input/output
formats to make them work together. Another contribution of this
article is the proposal of concise mapping and assembly formats,
which will hopefully encourage modular design of assemblers and
the associated tools.

2 Methods

2.1 General notations
Let 2 : {A. C. G.T} be the alphabet of nucleotides. For a symbol a
E 2. (E is the Watson—Crick complement of a. A string s : 111112 - - an
over 2 is also called a DNA sequence. Its length is ls) : 11; its reverse
complement is s : m : anew - - m. For convenience, we
define strand function TE : 2* X {0.1} —> 2* such that 7t(s. 0) : s and
n(s. 1) : 5'. Here 2* is the set of all DNA sequences.

By convention, we call a k—long DNA sequence as a k-mer. We
k i a, - - -a,~+k_1 to denote a k—long substring of s

i _

use the notation 5
starting at 1'. 2k is the set of all k—mers.

2.2 Minimap

2.2.1 Overview of k-mer based sequence similarity search

BLAST (Altschul et al., 1997) and BLAT (Kent, 2002) are among
the most popular sequence similarity search tools. They use one la—
mer hash function (i) : 2k —> Z to hash k—mers at the positions 1.w
+1.2w + 1.... of a target sequence and keep the hash values in a
hash table. Upon query, they use the same hash function on every la—
mer of the query sequence and look up the hash table for potential
matches. If there are one or multiple k—mer matches in a small win—
dow, these aligners extend the matches with dynamic programming
to construct the final alignment.

DALIGNER (Myers, 2014) does not use a hash table. It instead
identifies k—mer matches between two sets of reads by sorting k—
mers and merging the sorted lists. DALIGNER is fast primarily be—
cause sorting and merging are highly cache efficient.

MHAP (Berlin et al., 2015) differs from others in the use of
MinHash sketch (Broder, 1997). Briefly, given a read sequence 5 and
m k—mer hash functions {(1)1}1 31-5,”, MHAP computes la,- : min{¢>/~(
sf) : 1 g i g ls) — k + 1} with each hash function (1),, and takes list
(la/)1SI-Sm, which is called the sketch of s, as a reduced

 

Algorithm 1: Compute minimizers

 

Input: Parameter w and k and sequence 3 with |s| 2 w + k — 1
Output: (w,k:)-minimizers, their positions and strands

Function MinimizerSketch(s. w. k) begin

M <— 0 D NB: M is a set; no duplicates
f0ri<—1t0|s|—w—lc+1do
m <— oo
1 for j <— 0 to w — 1 do D Find the min value
own—weapaean)
if u 75 t) then D Skip if strand ambiguous

L m <— min(m. min(u. 11))

2 for j <— 0 to w — 1 do D Collect minimizers

(am) <— (¢(s§+j)a #311,»

ifu<vandu=mthen

| M <—MU{(m.i+j,0)}
else ifv < uand v = mthen
LM<—MU{(m.i—l—j.1)}

 

return M

 

 

 

 

representation of 5. Suppose (la/)l- and (10;)1- are the sketches of two
reads, respectively. When the two reads are similar to each other or
have significant overlaps, there are likely to exist multiple / such that
la; : la}. Potential matches can thus be identified. A limitation of
MinHash sketch is that it always selects a fixed number of hash val—
ues regardless of the length of the sequences. This may waste space
or hurt sensitivity when input sequences vary greatly in lengths.
Minimap is heavily influenced by all these works. It adopts the
idea of sketch like MHAP but takes minimizers (Roberts et al.,
2004; Schleimer et al., 2003) as a reduced representation instead; it
stores k—mers in a hash table like BLAT and MHAP but also uses
sorting extensively like DALIGNER. In addition, minimap is de—
signed not only as a read overlapper but also as a read—to—genome
and genome—to—genome mapper. It has more potential applications.

2.2.2 Computing minimizers

Loosely speaking, a (w, k)—minimizer of a string is the smallest la—
mer in a surrounding window of w consecutive k—mers. Formally, let
(i) : 2’2 —> Z be a k—mer hash function. A double-strand (w. k. (1))-
minimizer, or simply a Minimizer, of a string s, ls) 2 w + k — 1, is a
triple (10,1, 1’) such that there exists max(1.i — w + 1) S j S min(i. )
s) — w — k + 1) which renders

la : d)(rr(sf.r)) : min{¢>(n(slk+p.r’)) : 0 S p < w.r’ E {0.1}}

Let M(s) be the set of minimizers of 5. Algorithm 1 gives the
pseudocode to compute M(s) in O(w-  time. Our actual imple—
mentation is close to O()s)) in average case. It uses a queue to cache
the previous minimals and avoids the loops at line 1 and 2 most of
time. In practice, time spent on collecting minimizers is insignificant.

A natural choice of hash function (1) is to let (MA) : 0, (MC) : 1.
(MG) : 2 and (MT) : 3 and for a k—mer s : a1 mat, define

ma=¢uuxr4+¢uaxr4+~~+aa>

This hash function always maps a k—mer to a distinct 216-bit inte—
ger. A problem with this d) is that poly—A, which is often highly

[310'sp2umofp105xo'sopeuuopnorq/ﬁdnq

Long—read mapping and assembly

2105

 

 

 

Algorithm 2: Invertible integer hash function

 

Input: p—bit integer ac
Output: hashed p-bit integer

Function InvertibleHash(ac. p) begin
m <— 21” — 1
:17 <~ ("at + (a:<<21)) & m
ac (— x ‘ ac>>24
ac <— (m + (m«3) + (m«8)) & m
:17 <~ m ” a3>>14
ac <— (w + (and) + (x«4)) & m
ac <— ac ‘ x>>28
a: <~ (m + (m<<31)) & To
return at

 

 

Algorithm 3: Index target sequences

 

Input: Set of target sequences T = {31. . . . . 3T}
Output: Minimizer hash table 'H

Function Index(T. w. h) begin
H (— empty hash table
for t <— 1 to T do
M <—MinimizerSketch(st. w. h)
foreach (h. i. r) E M do
|_H[h] <— H[h] u {(t.i.r)}

return H

 

 

 

enriched in genomes, always gets zero, the smallest value. We may
oversample these non—informative poly—A and hurt practical per—
formance. To alleviate this issue, we use function d)’ : h°ri> instead,
where h is an invertible integer hash function on [0.42) (Algorithm
2; http://bit.ly/invihgi). The invertibility of h is not essential, but as
such d)’ never maps two distinct k—mers to the same Zk-bit integer, it
helps to reduce hash collisions.

Note that in a window of w consecutive k—mers, there may be more
than one minimizers. Algorithm 1 keeps them all with the loop at line
2. This way, a minimizer of 5 always corresponds to a minimizer of s.

For read overlapping, we use k : 15 and w : 5 to find
minimizers.

2.2.3 Indexing

Algorithm 3 describes indexing target sequences. It keeps minimizers
of all target sequences in a hash table where the key is the minimizer
hash and the value is a set of target sequence index, the position of
the minimizer and the strand (packed into one 64—bit integer).

In implementation, we do not directly insert minimizers to the
hash table. Instead, we append minimizers to an array of two 64—bit
integers (one for minimizer sequence and one for position) and sort
the array after collecting all minimizers. The hash table keeps the
intervals on the sorted array. This procedure dramatically reduces
heap allocations and cache misses, and is supposedly faster than dir—
ect hash table insertion.

Algorithm 4: Map a query sequence

 

Input: Hash table H and query sequence q
Output: Print matching query and target intervals

Function Map(7-l. q. to, k. e) begin
A (— empty array

M <—MinimizerSketch(q, w. k)
1 foreach (h.i.r) E M do
foreach (t. t". r’) E H[h] do

D Collect minimizer hits

if r = 7" then D Minimizers on the same strand
I Append (t.0.i — i’.i/) to A
else D On diﬂerent strands

|_ Append (t. 1.i + i’.i’) to A

Sort A = [(t. r. c. i’)] in the order of the four values in tuples

b <— 1

2 for e = 1 to |A| do D Cluster minimizer hits
if e = |A| or A[e + 1].t 75 A[e].t or A[e + 1].7~ 75 A[e].7~
or A[e + 1].c — A[e].e 2 s then

3 C (— the maximal colinear subset of A[b..e]

Print the left- and right-most query/target positions in C

b <— e + l

 

 

 

 

2.2.4 Mapping

Given two sequences 5 and s’, we say we find a minimizer hit (10. x. i.
i’) if there exist (19.1. r) E M(s) and (h.i’.r’) E M(s’) with x : rGBr’
(69 is the XOR operator). Here h is the minimizer hash value, x indi—
cates the relative strand and i and z" are the positions on the two se—
quences, respectively. We say two minimizer hits (h1.x.i1.i’1) and
(h2.x.iz.i’2) are e-away if 1) x20 and )(i1 —  — (i2 —  < e or
2) x21 and )(i1 +i’1)—(iz +i’2)) < e. Intuitively, e—away hits are
approximately colinear within a band of width 6 (500bp by default).
Given a set of minimizer hits {(h.x.i.i’)}, we can cluster i— i’ for
x : 0 or i + i’ for x : 1 to identify long colinear matches. This pro—
cedure is inspired by Hough Transformation mentioned by Sovic
et al. (2015).

Algorithm 4 gives the details of the mapping algorithm. The loop
at line 1 collects minimizer hits between the query and all the target
sequences. The loop at line 2 performs a single—linkage clustering to
group approximately colinear hits. Some hits in a cluster may not be
colinear because two minimizer hits within distance 5 are always 5—
away. To fix this issue, we find the maximal colinear subset of hits
by solving a longest increasing sequencing problem (line 3). This
subset is the final mapping result. In practical implementation, we
set thresholds on the size of the subset (4 by default) and the number
of matching bases in the subset to filter poor mappings (100 for read
overlapping).

2.3 Assembly graph

Two strings U and to may be mapped to each other based on their se—
quence similarity. If U can be mapped to a substring of w, we say to
contains U. If a suffix of U and a prefix of to can be mapped to each
other, we say U overlaps w, written as U —> w. If we regard strings U
and w as vertices, the overlap relationship defines a directed edge

ﬁm'spzumol‘pmyxo'sopeuuoturorq/ﬁdnq

Myers, 2005

mapped region

Fig. 1

Myers, 2005
Zerbino and Birney, 2008

Kahn, 1962

Li, 2012
Onodera et al. (2013)

Brankovic et al. (2015)

Myers et al., 2000

/3.IO'S[BIIm0[p.IOJXO'SOIJEIIIJOJIIIOIq/ﬂdnq

Long—read mapping and assembly

2107

 

 

Algorithm 6: Bubble detection

 

Input: G = (V. E ), starting vertex v0 and maximum probe
distance d
Output: the sink vertex of a bubble within d; or nil if not found

Function DetectBubb1e(V. E . 110. d) begin
if deg+ (710) < 2 then return nil D Not a source of bubble
for v E V d0 6[v] (— 00 D the min distance from 110 to v

6[’U()] (— 0
S (— empty stack D Vertices with all incoming edges visited
Push(S. v0)
p <— 0 D Number of visited vertices never added to S
while S is not empty do

u (— Pop(S)

foreach v —> w E E do
if to = no then D A circle involving the starting vertex

L return nil

if 6hr] + 6(1) —> w) > dthen DMoving toofar

L return nil

if 6[w] = 00 then D Not visited before
'y[w] (— deg‘ (m) D No. unvisited incoming edges
1) <— p + 1

if 6hr] + ((1) —> w) < 6[w] then

1 L6[w] <—6[v]+€(v—>w)

vlwl <— “rlwl — 1

if 'y[w] = 0 then
if deg+(w) gé 0 then
L Push(S. w)

pep—1

D All incoming edges visited
D Not a tip

 

if IS I = 1 and p = 0 then D Found the sink

|_ return Pop(S)

 

return nil

 

 

 

 

As miniasm does not correct sequencing errors, the error rate of
unitig sequence is the same as the error rate of the raw input reads.
It is in theory possible to derive a better unitig sequence by taking
the advantage of read overlaps. We have not implemented such a
consensus tool yet.

2.5 Formats: pairwise read mapping format and
graphical fragment assembly format

2.5.1 Pairing mapping format

Pairwise read mapping format (PAF) is a lightweight format keeping
the key mapping information (Table 2). Minimap outputs mappings in
PAF, which are taken by miniasm as input for assembly. We also pro—
vide scripts to convert DALIGNER, MHAP and SAM formats to PAF.

2.5.2 Graphical fragment assembly format

Graphical fragment assembly format (GFA) is a concise assembly
format (Table 3; http://bit.ly/gfaspec) initially proposed by us prior
to miniasm and later improved by community (Melsted et 111., per—
sonal communication). GFA has an explicit relationship to an as—
sembly graph—an ‘S’ line in the GFA corresponds to a vertex and its
complement in the graph; an ‘L’ line corresponds to an edge and its
complement. GFA is able to represent graphs produced at all the
stages of an assembly pipeline, from initial read overlaps to the uni—
tig relationship in the final assembly.

FASTG (http://bit.ly/fastgfmt) is another assembly format prior
to GFA. It uses different terminologies. A vertex in an assembly
graph is called an edge in FASTG, and an edge is called an adja—
cency. In FASTG, subgraphs can be nested, though no tools work
with nested graphs due to technical complications. In addition, with
nesting, one assembly graph can be represented in distinct ways,
which we regard as a limitation of FASTG.

2.6 Evaluating the layout accuracy

Miniasm outputs the approximate positions of trimmed reads on the
resulting unitigs. We extract these reads, map to the true assembly
with minimap (option: ‘—L100 —m0 —w5’) and select the best mapping
for each read. For a read 1', let utgi be the unitig name and rank, be
its index on utgi (i.e. read 1' is the rankith read on the unitig). If two
reads 1' and j are mapped adjacently on the true assembly, we say the
adjacency is w-consistent, if (i) utgi : utgl- and (rank, — rank/l < w,
or (11) both read 1' and j are the first or the last to reads of some uni—
tigs. We use to : 5 to detect large structural misassemblies.

3 Results

3.1 The accuracy of minimap

We mapped a human PacBio run ‘m130928_232712_42213_”“.13“
(http://bit.ly/chm1p5c3) with minimap and BWA—MEM (Li, 2013)
against GRCh37 plus decoy sequences (http://bit.ly/GRCh37d5). We
started from 23 235 reads (131 Mb), filtered out 7593 reads (10 Mb)
without 22 kb BWA—MEM alignments, and further dropped 815
reads (11 Mb) with two or more 22 kb chimeric alignments and 598
reads (4 Mb) with mapping quality below 10. Of the remaining reads,
we found only 2.0% not overlapping the best minimap mapping of
the same read. The majority of them hit to the decoy sequence where
defining the true alignment is challenging as decoy is enriched with in—
complete segments of centromeric repeats. If we exclude hits to the
decoy, the percentage drops to 0.7%. On this input, minimap is 50
times faster than BWA—MEM, while finding similar best mapping
positions. This experiment evaluates both the sensitivity and the spe—
cificity of minimap: if minimap had low sensitivity, it would miss the
BWA—MEM mapping completely; if minimap had low specificity, its
best mapping would often be a wrong mapping.

To test the sensitivity for read overlapping, we aligned all reads
from PBcR—PB—ec (Table 4) against the reference genome with BWA—
MEM, extracted reads with mapping quality 210, and identified
22kb overlaps between the extracted reads based on their positions
on the reference genome. Minimap finds 93% of these overlaps. It is
more sensitive than MHAP in its sensitive mode (78%) but less than
DALIGNER (98%).

3.2 Assembling bacterial genomes

We evaluated the performance of miniasm on 17 bacterial datasets
(Table 4) with command line ‘minimap —Sw5 —L100 —m0 reads.fa
reads.fa ) miniasm —f reads.fa —’. Miniasm is able to derive a single
contig per chromosome/plasmid for all but four datasets: 3 extra
>50 kb contigs for ERS554120, and 1 extra contig for ERS605484,
PBcR—ONT—ec and MAP—006—pcr—1 each. In the dotter plot between
the assembly and the reference genome (similar to Fig. 2), no large—
scale misassemblies are observed. We also applied the method in
Section 2.6. Except ERS473430, the miniasm layouts are 5—consist—
ent with the reference assemblies. For ERS473430, the NCTC pro—
ject page claimed the sample has a plasmid. Miniasm gives two
contigs, but the NCT C assembly has one contig only. The difference
in layout may be an error in the NCTC assembly.

ﬁm'spzumol‘pmyxo'sopeuuoturorq/ﬁdnq

2108

H.Li

 

Table 2. Pairwise mapping format (PAF)

Table 3. Graphical fragment assembly format (GFA)

 

 

 

 

 

Col Type Description Line Comment Fixed fields
1 string Query sequence name H Header N/A
2 int Query sequence length S Segment segName,segSeq
3 int Query start coordinate (BED-like) L Overlap segName1, segOri1,
4 int Query end coordinate (BED-like) segNameZ, segOriZ,
5 char ‘+’ if query and target on the same strand; ‘—’ CIGAR

if opposite
6 string Target sequence name GFA is a line-based TAB-delimited format. Each line starts with a single
7 int Target sequence length letter determining the interpretation of the following TAB-delimited ﬁelds. In
8 int Target start coordinate on the original strand GFA, segment refers to a read or a unitig. A line start with ‘5’ gives the name
9 int Target end coordinate on the original strand and sequence of a segment. When the sequence is not available, it can be a
10 int Number of matching bases in the mapping star “'“’. Overlaps between segments are represented in lines starting with ‘L’,
11 int Number bases, including gaps, in the mapping giving the names and orientations of the two segments in an overlap. The last
12 int Mapping quality (0—255 with 255 for missing) ﬁeld ‘CIGAR’ on an ‘L’—line describes the detailed alignment of the overlap if

 

PAF is TAB-delimited text format with each line consisting of the above
ﬁxed ﬁelds. When the alignment is available, column 11 equals the total num-
ber of sequence matches, mismatches and gaps in the alignment. Column 10
divided by column 11 gives the alignment identity. If the detailed alignment is
not available, column 10 and 11 can be approximate. PAF may optionally have
additional ﬁelds in the SAM-like typed key-value format (Li et al., 2009).

We have also run the PBcR pipeline (Berlin et al., 2015). PBcR
requires a spec file. We took ‘pacbio.spec’ from the PBcR—PB—ec ex—
ample and ‘oxford.spec’ from PBcR—ONT—ec, and applied them to
all datasets based on their data types. MAP"r datasets only provide
FASTA sequences for download. We assigned quality 9 to all bases
as PBcR requires base quality. PBcR assembled all PacBio datasets
without extra contigs longer than 50 kb—better than miniasm.
However, on the ONT datasets, PBcR produced more fragmented
assemblies for MAP—006—2, MAP—006—pcr—1 and MAP—006—pcr—2;
the PBcR—ONT—ec assembly is 300 kb shorter.

With four CPU cores, it took miniasm 14 s to assemble the 30—
fold PBcR—PB—ec dataset and 2 minutes to assemble the 160—fold PB—
ecoli dataset. PBcR, with four CPU cores, too, is about 700 times
slower on PBcR—PB—ecoli and 60 times slower on PB—ecoli. It is
slower on low—coverage data because PBcR automatically switches
to the slower sensitive mode. Here we should remind readers that
without an error correction stage, the contig sequences generated by
miniasm are of much lower accuracy in comparison to PBcR.
Nonetheless, miniasm is still tens of times faster than PBcR exclud—

ing the time spent on error correction.

3.3 Assembling a Caenorhabditis elegans genome
We assembled a 45—fold C.elegans dataset (Table 4). With 16 CPU
cores, miniasm assembled the data in 9min, achieving an N50 size
2.8 Mb. From the dotter plot (Fig. 2), we observed three structural
misassemblies (readers are advised to zoom into the vector graph to
see the details). PacBio has assembled the same dataset with HGAP3
(Chin et al., 2013). HGAP3 produces shorter contigs (N50:1.6
Mb), but does not incur large—scale misassemblies visible from the
dotter plot between the C.elegans reference genome and the contigs.

When we take the C.elegans reference genome as the truth, the
method in Section 2.6 also identifies the three structural misassem—
blies. The method additionally finds eight intra—unitig and one inter—
unitig inconsistencies. In all cases, miniasm agrees with HGAP3,
suggesting these inconsistencies may be true structural variations be—
tween the reference strain and the sequenced strain.

We have also tried PBcR on this dataset. Based on the intermedi—
ate progress report, we estimated that with 16 CPU cores, it would

available. In addition to the types of lines in the table, GFA may contain other
line types starting with different letters. Each line may optionally have add-
itional SAM-like typed key-value pairs.

Table 4. Evaluation datasets

 

Name Species Size Cov. N5 0

 

PB-ce-4OX Caenorhahditis elegans 104M 45 16 5 72

ERS47343O Citrohacter koseri 4.9M 106 7543
ERS5 44009 Yersinia pseudotuherculosis 4. 7M 147 9002
ERS5 54120 Pseudomonas aeruginosa 6.4M 90 7106
ERS605484 Vibrio vulniﬁcus 5.0M 155 5091
ERS617393 Acinetohacter haumannii 4.0M 237 7911
ERS646601 Haemophilus inﬂuenzae 1.9M 258 4081
ERS659581 Klehsiella 5p. 5.1M 129 8031
ERS670327 Shimwellia hlattae 4.2M 155 6765
ERS6 85285 Streptococcus sanguinis 2.4M 224 5791
ERS743109 Salmonella enterica 4.8M 188 6051
PB-ecoli Escherichia coli 4.6M 160 13 976
PBcR-PB-ec Escherichia coli 4. 6M 30 1 1 75 7
PBcR-ONT-ec Escherichia coli 4.6M 29 935 6
MAP-OO6-1 Escherichia coli 4.6M 54 10 892
MAP-OO6-2 Escherichia coli 4.6M 30 10 794
MAP-OO6-pcr-1 Escherichia coli 4.6M 30 8080
MAP-OO6-pcr-2 Escherichia coli 4.6M 60 8064

 

Evaluation dataset name, species, reference genome size, theoretical
sequencing coverage and the N50 read length. Names starting with ‘MAP’ are
unpublished recent ONT data provided by the Loman lab (http://bit.ly/
loman006). Names starting with ‘ERS’ are accession numbers of unpublished
PacBio data from the NCTC project (http://bit.ly/nctc3k). PB-ecoli and PB-ce—
40X are PacBio public datasets sequenced with the P6/C4 chemistry (http://
bit.ly/pbpubdat; retrieved on 11/03/2015). PBcR-PB-ec is the PacBio sample
data (P5/ C3 chemistry) used in the tutorial of the PBcR pipeline, PBcR-ONT-
ec is the ONT example originally used by Loman et al. (2015). ‘plstasta —
trimByRegion’ was applied to ERS"r and PB-ecoli datasets as they do not pro—
vide read sequences in the FASTQ format.

take a week or so to finish the assembly in the automatically chosen
‘sensitive’ mode.

For this dataset, minimap takes 27 GB RAM at the peak. As
minimap loads 4 Gbp bases to index, the peak RAM will be capped
around 27 GB. The memory used by miniasm is proportional to the
number of overlaps. Although it only takes 1.3 GB RAM here, it
will become the limiting factor for larger datasets.

3.4 Switching read overlappers
Miniasm also works with other overlappers when we convert their
output format to PAF. On the 30—fold PBcR—PB—ec dataset, we are

[BJO'SWHIHOIPJOJXO'SOplZIIJJOJLItOIQ/[idnq

53x\Ewogmoizmnnw.oxmoagoﬁsiwbwﬁ

 

2110

H.Li

 

Li,H. (2013). Aligning sequence reads, clone sequences and assembly contigs
with bwa-mem. arXiv:1303.3997.

Li,H. et al. (2009) The sequence alignment/map format and samtools.
Bioinformatics, 25, 2078—2079.

Loman,N.]. et al. (2015) A complete bacterial genome assembled
de novo using only nanopore sequencing data. Nat. Methods, 12, 733—735.

Myers,E.W. (2005) The fragment assembly string graph. Bioinformatics, 21,
ii79—ii85.

Myers,E.W. et al. (2000) A Whole-genome assembly of Drosophila. Science,
287, 2196—2204.

Myers,G. (2014). Efﬁcient local alignment discovery amongst noisy long reads.
In: Brown,D. G. and Morgenstern,B. (eds.) Proceedings Algorithms in
Bioinformatics — 14th International Workshop, WABI 2014, Wroclaw,
Poland, September 8—10, 2014, Springer, vol. 8701, pp. 52—67.

Onodera,T. et al. (2013). Detecting superbubbles in assembly graphs. In:
Darling,A.E. and Stoye,]. (eds.) In: WABI, volume 8126 ofLecture Notes in
Computer Science, Springer, pp. 338—348.

Quick,]. et al. (2014). A reference bacterial genome dataset generated on
the minionTM portable single-molecule nanopore sequencer. Gigascience, 3,
22.

Ribeiro,F.J. et al. (2012) Finished bacterial genomes from shotgun sequence
data. Genome Res, 22, 2270—2277.

Roberts,M. et al. (2004) Reducing storage requirements for biological se-
quence comparison. Bioinformatics, 20, 3363—3369.

Schleimer,S. et al. (2003). Winnowing: Local algorithms for document ﬁnger-
printing. In: Halevy,A.Y., Ives,Z.G., and Doan,A. (eds.) Proceedings ofthe
2003 ACM SI GMOD International Conference on Management of Data,
San Diego, California, USA, June 9—12, 2003, ACM, pp. 76—85.

Sovic,I. et al. (2015) Fast and sensitive mapping of error-prone nanopore
sequencing reads with graphmap. doi: http://dx.doi.org/10.1101/020719.
Zerbino,D.R. and Birney,E. (2008) Velvet: algorithms for de novo Short read

assembly using de Bruijn graphs. Genome Res., 18, 821—829.

/3.IO'S[BIIInOfp.IOJXO'SOIJBLUJOJIIIOIq/ﬂduq

