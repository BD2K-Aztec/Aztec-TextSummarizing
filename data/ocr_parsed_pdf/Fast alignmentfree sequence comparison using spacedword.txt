BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

C. -A.Leimeister et al.

 

while, in a second phase of the algorithm, seeds are extended into
both directions to find statistically relevant high—scoring segment
pairs.

In a pioneering paper, Ma et al. (2002) proposed to use spaced
seeds instead of contiguous—word matches as a first step in
homology searching. Here, a ﬁxed pattern or ‘mask’ of match
and don’t care positions is deﬁned, and two words of the cor—
responding length are considered to match if they coincide at the
speciﬁed match positions, while mismatches are allowed at the
don’t care positions. An obvious advantage of this approach is
that word matches at nearby positions are statistically less
dependent on each other than contiguous—word matches are.
Also spaced seeds are better able to identify homologue sequence
regions in the presence of mismatches. Ma et al. showed that
spaced seeds are superior to contiguous—word matches in terms
of sensitivity and speed; see also Brown (2008) for an overview.

Recently, we proposed to use spaced words, deﬁned by
patterns of match and don’t care positions, as a basis for align—
ment—free sequence comparison (Boden et al., 2013). Instead of
using spaced—word matches to trigger local alignments, we
compare the spaced—word composition of sequences to deﬁne a
measure of global similarity between them. In the present article,
we describe an efﬁcient algorithm based on recursive hashing and
bit operations to calculate and compare spaced—word frequencies
and we extend our approach to distance measures deﬁned by
multiple patterns. We use these distance measures to construct
phylogenetic trees for real—world and simulated DNA and
protein sequence families, and we compare our method to
established alignment—free methods using contiguous—word
frequencies, as well as to a traditional alignment—based approach.
Our results show that, for phylogeny reconstruction, spaced
words based on multiple patterns are superior to existing align—
ment—free methods that rely on contiguous words. A user—friendly
web interface for our program is described by Horwege et al.
(2014).

2 CALCULATING SPACED-WORD FREQUENCIES

As usual, for an alphabet 2 and Z 6 N, 2‘ denotes the set of all
sequences over 2 with length K. For a sequence S e 2‘ and
i 3 Z, S[i] denotes the i—th character of S. Instead of ‘sequence’,
we also use the term ‘word’ or ‘contiguous word’ to distinguish
them from the spaced words that we are going to deﬁne. In our
context, the alphabet 2 represents the set of nucleotides or amino
acids, respectively. In analogy to the terminology introduced by
Ma et al. (2002), we deﬁne for integers k 3 Z a spaced word w of
length Z and weight k as a pair (w’, P) where w’ 6 2k is a
‘contiguous word’ of length k and P e {0, 1}‘ is a sequence of
‘0’ and ‘1’ characters of length Z, such that there are exactly k
positions i in P with P[i] = 1. We call P the underlying pattern of
w. In addition, we require that P[1] = P[£] = 1 holds, i.e. the first
and the last characters in P must be ‘1’. The ‘1’ positions in the
pattern P denote match positions, while the ‘0’ positions are the
don’t care positions.

Let w = (w‘, P) be a spaced word with weight k and length Z
such that p1 < . . . <pk are the positions of the ‘1’ characters in P.
We say that w occurs in a sequence S at position i if

S[i+pj — l] = w‘[/]

for all 1 g j g k. For example, the spaced word w = (w’, P) with
w’ = AGT and P: 11001 occurs in the sequence
S = GGAGCTTCAGGA TCC at positions 3 and 9.

To define a distance function on a set of input sequences
S1, ...,SN over 2, we ﬁrst consider a single ﬁxed pattern P
with weight k. For each sequence S,-, we calculate the relative
frequencies of all possible spaced words with respect to our pat—
tern P (relative to the sequence length) and, similar as in other
alignment—free approaches, each sequence S ,- is represented by the
IEIk—dimensional vector of these relative frequencies. It is then
straightforward to define a distance dp(S,~, Si) between two
sequences S,- and S,- as the distance between these frequency
vectors, using some standard distance metric on vector spaces.

This approach can be generalized by considering a whole set

73={P1, ...,P,,,}

of patterns instead of a single pattern P [similarly, Li et al. (2003)
used multiple spaced seeds for database searching]. Here, we
deﬁne a distance dp as the average of the distances defined by
the patterns P e 73, i.e. we deﬁne

1
dust, 5;) = — Z dust, 5;) (1)
mPeP
We call this extension the multiple—pattern version of our
spaced—word approach.

3 IMPLEMENTATION

To calculate the frequencies of spaced words in a sequence with
respect to a pattern P, we implemented a hash function that maps
each spaced word to an integer in [0, 264). We first consider con—
tiguous words of length k and deﬁne the i—th word of sequence S as
w,~ = S[i]S[i+ 1] . . . S[i+ k — 1]. A fast way to hash successive
words is by using a hash function h for which the value h(w,~+1)
can be calculated in constant time from the previous value h(w,—) by
removing the value of the i—th character and adding the value of
the new character at i + k. Such hash functions are called recursive
or rolling (Cohen, 1997; Karp and Rabin, 1987). In practice, we
used recursive hashing by cyclic polynomials (Cohen, 1997),
which is also known as Buzhashing (Uzgalis, 1996).

While this approach is fast, it is possible, in principle, that
collisions occur, i.e. that two different words are mapped to the
same hash value. We do not correct such collisions but, instead,
we define our hash function in such a way that the probability of
such collisions is minimized. To this end, we use a hash function
that provides a good uniformity for arbitrary input strings. First,
we deﬁne a constant table rtab containing 256 values of 64—bit,
assigning to each character of the alphabet 2 an integer in the
interval [0, 264). According to Uzgalis (1996), a uniform distribu—
tion of the resulting hash values is ensured by deﬁning this array
such that every vertical bit position has exactly 128 zeros and 128
ones. With this deﬁnition, collisions are extremely unlikely. In all
test runs that we performed, we did not observe a single collision.

Next, we deﬁne the function s as the barrel shift that rotates
the bits by one position to the left, e.g. we have s(1100) = 1001.
69 is denoted as the bitwise exclusive or operator. With these
deﬁnitions, we define the hash value for a word w,- as

hm.) = 51“ (rtab(S[i])) ea sk’2(rtab(S[i + 1]))ea

...® s(rtab(S[i + k — 2]) 69 rtab(S[i + k — 1]) (2)

 

1992

ﬁm'sIeumoI‘pJOJXO'sopeuuopuorq/ﬁdnq

Spaced words

 

Once h(w1) is calculated with this formula, the values
h(w,~),i 3 2, can be calculated recursively as

h(W.~+1) = s(h(W.~)) 69 Sk(rtab(5[ll)) 69 rtab(S[i + kl) (3)

Note that, with this recursion, all hash values h(w,—) can be
calculated for a sequence S of length n in O(n) time, inde—
pendently of the word length k. The advantage of using bit
operationswompared with recursive hashing with multiplica—
tions and divisionsiis that rotating bits is much faster than
these algebraic operations.

So far, we only considered contiguous words. The above recur—
sive formula (3) can be easily adapted to spaced words as long as
the number of don’t care positions in the underlying pattern is
small. To do this, we ﬁrst calculate the hash value for words of
length Z, and we then remove the terms corresponding to the
don’t care positions in the underlying pattern. This corresponds
to removing single characters from a word when a sliding
window is moved to the next position. For example, if there is
a single don’t care at position p in the pattern, we calculate
sk’l’(rtab(S[i + p — 1])) and apply the 69 operator to erase the
term corresponding to the character S[i+p— 1] to calculate
the hash value h(w,~) for the spaced word starting at position i.
Consequently, the time complexity of this approach is
(9((Z — k) - n) where k is the weight of the pattern P.

However, if the number of don’t care positions in P is greater
than the number k of match positions, i.e. if k< g, the recursive
calculation is slower than the naive non—recursive approach,
which calculates the hash values based on the match positions
in the underlying pattern. In this case, the hash value h(w,—) must
be explicitly calculated for each spaced word wi leading to an
(9(n - k) algorithm.

To store the frequencies of all spaced words in a sequence, we
implemented a simple hash table. To determine an appropriate
size of our hash table, we ﬁrst calculate the maximum number
of distinct (spaced) words. Clearly, for a sequence S and a pattern
P of weight k and length Z, the maximum number of distinct
spaced words in S is given by min(|2|k,n — Z +1) where n is
the length of S. According to this observation, we choose as
hash table size the smallest integer b such that
2”>min(|2|k,n—Z+ 1). We then keep the b most signiﬁcant
bits of our 64—bit hash value, which is achieved by shifting the
bits 64 — b times to the right. These b bits are used as index in
the hash table, resulting in a complexity of (9(1) on average for the
common operations such as search or insert. We handle collisions
by sequentially searching the hash table for a free location, which
is known as open addressing. This method led to a better perform—
ance in our tests than an alternative approach using linked lists.

Once the word frequencies are determined for our input se—
quences, we can easily compare them for different sequences, as a
basis to calculate pairwise distances values. To do so, we iterate
over both hash tables and for each key we search the equivalent
key in the other hash table, which can be accomplished in (9(1) as
mentioned above. If the key is not found in a hash table, then the
corresponding spaced word does not occur in the other corres—
ponding sequence.

In our multiple—pattern approach, we need to calculate spaced—
word frequencies for a large number of patterns. To do this ef—
ﬁciently, we implemented multithreading in our program to

increase the speed. Both steps, counting word frequencies and
calculating pairwise distances are easily parallelizable. We are
using threads to determine the word frequencies as well as for
the computation of pairwise distances.

4 BENCHMARK SET-UP

To evaluate our approach and to compare it with other se—
quence—comparison methods, we used benchmark sequence sets
from different sources: for DNA and protein sequence compari—
son, respectively, we used real—world as well as simulated se—
quence sets. Each sequence set consists of a number of
evolutionarily related sequences together with a reference tree
that we consider to be reliable.

For all sequences, we calculated the relative frequencies of
contiguous as well as spaced words using the above—described
single—pattern and multiple—pattern approaches. To obtain dis—
tance matrices for these sequence sets, we applied the Jenseni
Shannon (JS) distance metric (Lin, 1991) to the obtained rela—
tive—frequency vectors. The JS distance between two frequency
vectors P and Q is deﬁned as

JS(P, Q) = éKL(P, Al) + éKL(Q, Al) (4)

where
M 2 go) + Q) (5)

is the mean of P and Q, and KL(P,M) is the KullbackiLeibler
divergence (Kullback, 1987) between P and M deﬁned as

Km), M) = Z logz  Pt (6)

The JS metric was also used by Sims et al. (2009) for their
Feature Frequency Profile (FFP) approach. In addition, we
applied the Euclidean distance to the relative—frequency vectors
obtained with our multiple—pattern approach.

Finally, we applied the NeighbourJoining program (Saitou and
Nei, 1987) from the PH YLIP package (Felsenstein, 1989) to
calculate unrooted trees from these distance matrices. As a com—
parison, we applied three state—of—the—art alignment—free
approaches, Average Common Substring (ACS) (Ulitsky et al.,
2006), K, (Haubold et al., 2005) and FFP (Sims et al., 2009), as
well as a traditional approach to phylogeny reconstruction using
Clustal W (Thompson et al., 1994) and Maximum Likelihood
(Felsenstein, 1981). For ACS, we used our own implementation
(Leimeister and Morgenstern, 2014) because the original soft—
ware is not publicly available. For FFP, we used the word
length that gave the best results for a given category of bench—
mark sequences. To evaluate these different methods, we com—
pared for each sequence set the resulting trees with the
corresponding reference tree using the RobinsoniFoulds (RP)
metric (Robinson and Foulds, 1981).

As test data for genomic sequence comparison, we used a set
of 27 primate mitochondrial genomes that have been previously
used by Haubold et al. (2009) to benchmark alignment—free
methods. For these sequences, a reliable phylogenetic tree is
known that is based on multiple sequence alignment and

 

1 993

ﬁm'sIeumoI‘pJOJXO'sopeuuopuorq/ﬁdnq

C. -A.Leimeister et al.

 

Maximum Likelihood. Further, we used a set of 13 fully
sequenced ﬂowering—plant genomes from the Malvidae clade
plus the grape vine genome as outgroup. As a reference tree for
these 14 genomes, we used a tree based on a multiple sequence
alignment of manually assembled CAP and Arp2/3 protein se—
quences as published by Hatje and Kollmar (2012). To bench—
mark our approach on protein sequences, we used BAliBASE
3.0, a standard benchmark database for multiple alignment
(Thompson et al., 2005). BAliBASE consists of 218 sets of
related protein sequences together with reference multiple align—
ments based on 3D superposition that are considered to be reli—
able. As BAliBASE contains no information about the
underlying phylogenetic trees, we constructed a reference tree
for each sequence set by applying the standard Maximum
Likelihood method (Felsenstein, 1981) to the corresponding ref—
erence multiple alignment.

In addition to these real—world benchmark sequences, we
generated a large number of simulated genomic and protein
sequence sets using the program Rose (Stoye et al., 1998). This
program mimics molecular evolution by producing a set of
sequences along an evolutionary tree, starting with a common
ancestral sequence at the root. Substitutions, insertions and dele—
tions are randomly incorporated according to a pre—deﬁned sto—
chastic model of molecular evolution. As a result, sets of
‘evolutionarily’ related sequences are produced, together with
known phylogenetic trees that we used as reference trees in our
study. A parameter called relatedness determines the average evo—
lutionary distance between the produced sequences, measured in
PAM units (Dayhoff et al., 1978). For DNA sequence compari—
son, we created a set of 50 sequences of 16000 nt length each
using Rose with a relatedness value of 70. To obtain simulated
protein benchmark data, we generated a set of 125 protein se—
quences with a length of 300 aa each. Here, we used a relatedness
value of 480. Except for the relatedness values, Rose was run with
default values.

For all of these benchmark sequence sets, except for the 14
plant genomes, we ﬁrst calculated trees based on contiguous—
word frequencies, and we identified the word length k that pro—
duces the best results for the respective category of sequence sets,
i.e. the trees with the smallest RF distances to the respective ref—
erence trees. For this value of k, we then generated patterns with
weight k, i.e. with k match positions, and with up to 30 don’t care
positions, i.e. with a length Z between k+ 1 and k+ 30. For each
Z, we randomly selected a set 737 of 100 patterns of length Z and
weight k. For small values of K where <100 patterns are possible,
we deﬁned 73] as the set of all possible patterns.

For each Z and each pattern P e 737, we applied our single—
pattern approach and then calculated the average RF distances of
the obtained trees to the respective reference trees. In addition,
we applied our multiple—pattern approach by calculating the pair—
wise distance values dp,(S,~,S/) for each sequence set using all
patterns P e 737 according to Equation (1). Moreover, we gener—
ated pattern sets 73 with 100 randomly selected patterns of weight
k and with varying length Z for the multiple—pattern approach. We
repeated these test runs using different sets of random patterns
and calculated the standard deviations of the obtained RD dis—
tances to the reference trees. Note that this re—sampling is only
possible if K is large enough because for a short pattern length Z,
the number of possible patterns is too small.

5 TEST RESULTS

5.1 Genomic sequences

For the primate mitochondrial genomes, the approach with con—
tiguous words produced best results with a word length of k: 9,
leading to a phylogeny with a RF distance of 4 to the reference
tree. Thus, we generated patterns P with weight k = 9 and length Z
between 9 and 39, i.e. with 9 ‘match’ positions and up to 30 ‘don’t
care’ positions. The results are shown in Figure 1. For each pattern
length Z>k, spaced words outperformed the standard contiguous
words (Z 2k). For practically all values of Z, the multiple—pattern
approach with the JS distance led to better results than the single—
pattem approach with the same pattern length K. For some values
of Z, the RF distance to the reference tree was 0, so here the tree
topology reconstructed by our approach precisely coincides with
the reference topology. For values Z < 19, the multiple—pattem ap—
proach with the Euclidean distance performed worse than with the
JS distance and even worse than the single—pattern approach. For
longer patterns, however, the Euclidean distance performed better;
for Z >20, multiple patterns with the Euclidean distance produced
perfect tree topologies, i.e. the RF distance was 0. The established
alignment—free approaches K, and ACS performed worse than
spaced words with single or multiple patterns for all Z >10. FFP
performed better than these two approaches, but was outper—
formed by multiple spaced words with the Euclidean distance for
all pattern lengths Z > 18 and by multiple spaced words with the JS
distance for most values Z > 13.

The test results for our plant genomes are shown in Figure 3.
Here, we used a set of 60 patterns of weight 14 and variable length.

For our simulated DNA sequences, we found that contiguous
words with length k = 8 gave the best results, with an average RF
distance of 50 to the respective reference trees. We therefore
generated patterns with weight k: 8 and with length Z between
8 and 38. The results of these test runs are summarized in
Figure 2. As can be seen, spaced words with single patterns
and one or several don’t care positions (Z>k) performed better
than the usual approach with contiguous words (k = 0), as long as
the number of don’t care positions is small. The relative improve—
ment in the quality of trees is modest, however, and if the
number of don’t care positions is increased, the tree quality de—
teriorates. By contrast, a substantial improvement could be
achieved by using our multiple—pattern approach. Here, increas—
ing the pattern length (fie. increasing the number of don’t care
positionsifurther improved the resulting trees, leading to aver—
age RF distances of around 16 between the constructed trees and
the reference trees. On these sequences, the difference between JS
and Euclidean distance was small. The three competing align—
ment—free methods were clearly outperformed by our multiple—
pattern approach. A classical approach using multiple sequence
alignment and maximum likelihood led to slightly better results
than our multiple—pattern program.

5.2 Protein sequences

Overall, our test results on proteins were similar to the results on
DNA. On BAliBASE, a word length of k: 4 produced best re—
sults for contiguous—word frequencies. Thus, we used patterns
with weight k=4 and lengths Z between 4 and 34. Figure 4
shows the results of these test runs. Again, the spaced—words

 

1 994

ﬁm'sIeumoI‘pJOJXO'sopnuuopnorq/ﬁdnq

raumtgoimondwmowoﬁo~&o§w5.o~m\

Eucalyptus grandls
Eucalyptus camaldulensrs
Theobroma cacao
Gossyplum raimondli
Citrus clementina
Citrus sinensis
Carica papaya

-» Capsella rubella

Myrtales
Malvales

Sapindales

 Arabidopsis thaliana
»- Arabidopsis lyrata Brassicales
- Eutrema halophilum
Brassica rapa

 

Eutrema halophilum
Brassica rapa

Eutrema parvulum
Capsella rubella
Arabidopsis lyrata
Arabido

    

Citrus sinensis
Eucalyptus camaldulensis
Eucalyptus grandis
Brassica rapa

Eutrema halophilum
Eutrema parvulum
Capsella rubella
Arabidopsis lyrata
Arabidopsis thaliana

ossypium raimondii
Citrus sinensis

Eucal ptus randis
Eutrema halophilum
Brassica rapa

Eutrema parvulum
Capsella rubella
Arabidopsis lyrata
Arabidopsis thaliana

 

 

 

ossyplum Talmoﬂll
Theobroma cacao

Citrus sinensis
Carica papaya
Brassica rapa
Eutrema halophilum
Eutrema parvulum
Capsella rubella
Arabidopsis lyrata
Arabidopsis thaliana

dnq

/310‘sreumo[p10}xo‘soneuuoprorqﬁ

53x\Ewogmoizmnnw.oxmoagoﬁsiwbwﬁ

 

 

+2: .

 

 

 

 

30

 

o
s
o
M
:1: a
3
a
z
o
o
o
15
n
a
o
9H
a
D.
of
80
r
m
mm
H
0N
e
o
5
o
4
o
a
o
2
o
o
o 5 o s o

25

2 1 1

muﬂmwmmm wuﬁﬂcmiH—Omﬂwﬁcm

C. -A.Leimeister et al.

 

Table 1. Runtimes of various established sequence-comparison methods
and our spaced-word implementation on 50 simulated DNA sequences of
length 16 000 nt each

 

 

Method Runtime (s)
Clustal W 1817
Clustal S2 1039

ACS 2.7

K ,. 0.9

FFP 123.3
Contiguous words 0.3
Spaced words, single pattern 0.31
Spaced words, multiple patterns 27.6

 

Note: Contiguous and spaced words were run with k: 8 match positions. The
multiple—pattern option was used with sets 73 of 100 randomly selected patterns of
varying length.

Table 2. Runtime on 14 plant genomes with a total size of 4.6 GB

 

 

Method Runtime (s)
ACS 14 808
FFP 2123
K, 30,060
Contiguous words 207
Spaced words, single pattern 242
Spaced words, multiple patterns 20 295

 

Note: Contiguous and spaced words were run with k = 14 match positions. Multiple—
pattern was run with 60 patterns of varying length.

matches at neighbouring sequence positions are less dependent
on each other if a non—periodic pattern P is used.

In the ﬁrst version of this spaced—word approach, we used a
tree structure to find matching spaced words (Boden et al., 2013).
Herein, we described an efﬁcient algorithm and implementation
based on recursive hashing and fast bitwise operations. While in
general, algorithms using sufﬁx—trees have the same linear time
complexity as hashing algorithms, tree—based pattern searching is
more difﬁcult in our approach where patterns contain don’t care
positions. Furthermore, the bitwise operations that we are using
are much faster than operations on characters. The efﬁciency of
our new approach enabled us to introduce a multi—pattern version
where spaced—word frequencies with respect to an entire set 79 of
patterns are used instead of a single pattern P.

Our test results show that spaced—word frequencies based on a
single pattern with a small number of don’t care positions lead to
better phylogenetic trees than contiguous—word frequencies, al—
though the improvement that we could achieve with this first
approach was limited; see also Boden et al. (2013). By contrast,
we obtained a signiﬁcant improvement by using our multiple—
pattern approach. Here not only the resulting phylogenetic
trees are superior to trees constructed with contiguous—word fre—
quencies or single—pattern spaced words, but also the results are
less sensitive to the number of don’t care positions. On simulated
DNA and protein sequences, the multiple—pattern approach led to
results not much worseiand sometimes even betterithan the
classical alignment—based approach to phylogeny reconstruction.

0.12
0.11‘
g 0.1
ﬁg 0.09 .
g 0.08
3 0.07
C
.0.» 0.06
.2
30:, 0.05
O
o 0.04
0.03
0.02 '
o 5 10 15 20 25 30

Don't care positions

Fig. 8. Variation coefﬁcients of distance values calculated with spaced-
and contiguous-word frequencies using single patterns (upper curve) and
multiple patterns (lower curve) on 100 pairs of simulated DNA sequences;
see subsection 5.4 for details. Note that for 0 don’t care positions, the
spaced-word approach coincides with the contiguous-word approach
(and the multi-pattern version coincides with the single-pattern version,
as only one single pattern is possible for a given number k of match
positions). Thus, for 0 don’t care positions, our graphic shows the vari-
ation coefﬁcient for the classical contiguous-word approach

While the results of the single—pattern method strongly depend
on the underlying pattern P (Boden et al., 2013), our new mul—
tiple—pattern approach led to high—quality results with randomly
selected sets 79 of patterns and the resulting trees are statistically
more stable. However, the runtime of this approach is longer
than if a single pattern is used, it is roughly proportional to
the number of patterns in 79. The single—pattern version of our
approach is faster than all other programs that we tested, but the
multiple—pattern version is slower than some state—of—the—art
alignment—free methods. A program run on a set of 14 full—
length plant genomes that cannot be handled by multiple—align—
ment methods took ~4 min with the single—pattern version and
about five and a half hours with the multiple—pattern version
using a set 79 of 60 patterns.

A crucial parameter in our approach is the weight k of the
patterns, i.e. the number of match positions. Clearly, optimal
values for k depend on the length of the input sequences. In
our study, we experimentally determined for a given group of
sequences the optimal weight k for contiguous patterns and used
this same value for our spaced patterns. First test results indicate
that the optimal weight for contiguous—word matches also works
best for spaced words (data not shown). There is no guarantee,
however, that this is always the case, so further research is ne—
cessary to ﬁnd suitable weights for k depending on the input
sequences.

Another open question is which size m of the set of 79 of pat—
terns should be used. Figures 6 and 7 demonstrate that increasing
m generally increases the quality of the resulting trees. For m > 60
or 70, however, no signiﬁcant further improvement could be
achieved in our test examples. It would be desirable to have a
general rule to ﬁnd a suitable number m of patterns in the mul—
tiple—pattem approach, depending on the input sequences.
Finally, it is not clear which distance measure on the spaced—
word frequency vectors is most suitable in our approach. In
this study, we used the JS and Euclidean distance measures,
but other distances may be more suitable to estimate

 

1 998

ﬁm'spzumot‘pmJXO'sopnuuopnorq/ﬁdnq

Spaced words

 

phylogenetic distances between DNA or protein sequences based
on their spaced—word frequencies.

To answer these questions, the statistical properties of spaced—
word frequencies need to be analysed in detail, as has been done
for the hit probabilities of spaced seeds in database searching
(Keich et al., 2004). Results on the probability of word occur—
rences (Robin et al., 2005) may help to better understand the
behaviour of our method theoretically, to optimize its param—
eters and to further improve its performance.

ACKNOWLEDGEMENTS

The authors would like to thank Susana Vinga, Bernhard
Haubold, Thomas Lingner and Anirban Mukhopadhyay for
helpful discussions, Martin Kollmar and Klas Hatje for help
with the plant genomes, Martin Sch'oneich for his work on an
early version of our program and Bingyao Zhu for help with the
program evaluation.

Funding: Expenses were covered by the last author’s department
budget

Conflict of Interest: none declared.

REFERENCES

Altschul,S.F. et al. (1990) Basic local alignment search tool. J. Mol Biol, 215,
4037410.

Blackshields,G. et al. (2010) Sequence embedding for fast construction of guide trees
for multiple sequence alignment. Algoritlmts Mol Biol, 5, 21.

Boden,M. et al. (2013) Alignment—free sequence comparison with spaced k—mers. In:
German Conference on Bioinformatics 2013. Volume 34 of OpenAccess Series in
Informatics (OASIcs). pp. 24~34.

Brown,D.G. (2008) A survey of seeding for sequence alignment. In: Mandoiu,I. and
Zelikovsky,A. (eds) Bioinformatics Algorithms: Techniques and Applications.
Wiley—Interscience, New York, pp. 1267152.

Chor,B. et al. (2009) Genomic DNA k—mer spectra: models and modalities. Genome
Biol, 10, R108.

Cohen,J.D. (1997) Recursive hashing functions for n—grams. ACM Trans. Inf. Syst.,
15, 2917320.

Comin,M. and Verzotto,D. (2012) Alignment—free phylogeny of whole genomes
using underlying subwords. Algorithms Mol Biol, 7, 34.

Corel,E. et al. (2010) MS4imulti—scale selector of sequence signatures: an align—
ment—free method for classiﬁcation of biological sequences. BMC
Bioinﬁ)rmatics, 11, 406.

Darling,A.E. et al. (2010) progressiveMauve: multiple genome alignment with gene
gain, loss and rearrangement. PLoS One, 5, e11147.

Dayhoff,M. et al. (1978) A model of evolutionary change in proteins. Atlas Protein
Seq. Struct., 6, 3457362.

Didier,G. (1999) Caracterisation des Auzmnms et application a’l etude des suites de
complexite ultimement n + c”. Theor. Comp. Sci., 215, 31419.

Didier,G. et al. (2007) Comparing sequences without using alignments: application
to HIV/SIV subtyping. BMC Bioinformatics, 8, 1.

Didier,G. et al. (2012) Variable length local decoding and alignment—free sequence
comparison. Theor. Comput. Sci., 462, 1711.

Ebersberger,I. et al. (2009) HaMStR: proﬁle hidden markov model based search for
orthologs in ESTs. BMC Evol. Biol, 9, 157.

Edgar,R.C. (2004) MUSCLE: Multiple sequence alignment with high score accur—
acy and high throughput. Nucleic Acids Res., 32, 179271797.

Felsenstein,J. (1981) Evolutionary trees from DNA sequences: a maximum likeli—
hood approach. J. Mol. Evol, 17, 3687376.

Felsenstein,J. (1989) PHYLIPiPhylogeny Inference Package (Version 3.2).
Cladistics, 5, 1647166.

Felsenstein,J. (2003) Inferring Phylogenies. Sinauer Associates, Sunderland, MA.

Goke,J. et al. (2012) Estimation of pairwise sequence similarity of mammalian en—
hancers with word neighbourhood counts. Bioinformatics, 28, 656%63.

Hatje,K. and Kollmar,M. (2012) A phylogenetic analysis of the brassicales clade
based on an alignment—free sequence comparison method. Front. Plant Sci., 3,
192.

Haubold,B. et al. (2005) Genome comparison without alignment using shortest
unique substrings. BMC Bioinformatics, 6, 123.

Haubold,B. et al. (2009) Estimating mutation distances from unaligned genomes.
J. Comput. Biol, 16, 148771500.

Hauser,M. et al. (2013) kClust: fast and sensitive clustering of large protein sequence
databases. BMC Bioinformatics, 14, 248.

Hohl,M. et al. (2006) Pattem—based phylogenetic dismnce estimation and tree re—
construction. Evol. Bioinform. Online, 2, 3597375.

Horwege,S. et al. (2014) Spaced words and kmacs: fast alignment—free sequence
comparison based on inexact word matches. Ntwleic Acids Res., doi: 10.1093/
nar/gku398.

Karp,R.M. and Rabin,M.O. (1987) Efﬁcient randomized pattern—matching algo—
rithms. IBM J. Res. Dev., 31, 2497260.

Katoh,K. et al. (2002) MAFFT: a novel method for rapid multiple sequence align—
ment based on fast fourier transform. Nucleic Acids Res., 30, 305973066.

Keich,U. et al. (2004) On spaced seeds for similarity search. Discrete Appl. Math,
138, 25%263.

Kolekar,P. et al. (2012) Alignment—free distance measure based on return time dis—
tribution for sequence analysis: applications to clustering, molecular phylogeny
and subtyping. Mol Phylogenet. Evol, 65, 51(k522.

Kullback,S. (1987) The kullbackleibler distance. Am. Stat., 41, 3407341.

Leimeister,C—A. and Morgenstern,B. (2014) kmacs: the k—mismatch average
common substring approach to alignment—free sequence comparison.
Bioinformatics, 30, 200(F2008.

Li,M. et al. (2003) PatternHunter II: highly sensitive and fast homology search.
Genome Inform., l4, l6¢l75.

Lin,J. (1991) Divergence measures based on the shannon entropy. IEEE Trans. Inf.
Theory, 37, 1457151.

Lingner,T. and Meinicke,P. (2006) Remote homology detection based on oligomer
distances. Bioinformatics, 22, 222472231.

Ma,B. et al. (2002) PatternHunter: faster and more sensitive homology search.
Bioinformatics, 18, 440—445.

Morgenstern,B. (2002) A simple and space—efﬁcient fragment—chaining algorithm
for alignment of DNA and protein sequences. Appl. Math. Lett., 15, 11716.
Needleman,S.B. and Wunsch,C.D. (1970) A general method applicable to the
search for similarities in the amino acid sequence of two proteins. J. Mol

Biol, 48, 4434153.

Robin,S. et al. (2005) DNA, Words and Models: Statistics of Exceptional Words.
Cambridge University Press, Cambridge, UK.

Robinson,D. and Foulds,L. (1981) Comparison of phylogenetic trees. Math. Biosci.,
53, 1317147.

Saitou,N. and Nei,M. (1987) The neighbor—joining method: a new method for re—
constructing phylogenetic trees. Mol Biol. Evol, 4, 40(r425.

Schreiber,F. et al. (2009) Orthoselect: a protocol for selecting orthologous groups in
phylogenomics. BM C Bioinformatics, 10, 219.

Sievers,F. et al. (2011) Fast, scalable generation of high—quality protein multiple
sequence alignments using Clustal Omega. Mol Syst. Biol, 7, 539.

Sims,G.E. et al. (2009) Alignment—free genome comparison with feature frequency
proﬁles (FFP) and optimal resolutions. Proc. Natl Acad. Sci. USA, 106,
267772682.

Sokal,R. R. and Michener,C.D. (1958) A Statistical Method for Evaluating Systematic
Relationships. University of Kansas Science Bulletin, 38, 140971438.

Song,K. et al. (2013) Alignment—free sequence comparison based on next generation
sequencing reads. J. Comput. Biol, 20, 64779.

Stoye,J. et al. (1998) Rose: generating sequence families. Bioinformatics, 14, 1577163.

Thompson,J.D. et al. (1994) CLUSTAL W: improving the sensitivity of progressive
multiple sequence alignment through sequence weighting, position—speciﬁc gap
penalties and weight matrix choice. Nucleic Acids Res., 22, 467374680.

Thompson,J.D. et al. (2005) BAliBASE 3.0: latest developments of the multiple
sequence alignment benchmark. Proteins, 61, 1277136.

Ulitsky,I. et al. (2006) The average common substring approach to phylogenomic
reconstruction. J. Comput. Biol, 13, 3367350.

Uzgalis,R. (1996) Hashing concepts and the java programming language. In:
Technical report. University of Auckland.

Vinga,S. and Almeida,J. (2003) Alignment—free sequence comparisonia review.
Bioinformatics, 19, 5137523.

Vinga,S. et al. (2012) Pattern matching through Chaos Game Representation: brid—
ging numerical and discrete data structures for biological sequence analysis.
Algorithms Mol Biol, 7, 10.

 

1 999

ﬁle'sreumot‘pmﬂo'sopnuuowrorq/pdnq

