ORIGINAL PAPER

Vol. 27 no. 15 2011, pages 2068-2075
doi:10. 1 093/bioinformatics/btr320

 

Phylogenetics

Advance Access publication June 2, 2011

Aligning short reads to reference alignments and trees

Simon A. Berger* and Alexandros Stamatakis*
The Exelixis Lab, Scientific Computing Group, Heidelberg Institute for Theoretical Studies, D—691 18 Heidelberg,

Germany
Associate Editor: David Posada

 

ABSTRACT

Motivation: Likelihood-based methods for placing short read
sequences from metagenomic samples into reference phylogenies
have been recently introduced. At present, it is unclear how to
align those reads with respect to the reference alignment that was
deployed to infer the reference phylogeny. Moreover, the adaptability
of such alignment methods with respect to the underlying reference
alignment strategies/philosophies has not been explored. It has also
not been assessed if the reference phylogeny can be deployed
in conjunction with the reference alignment to improve alignment
accuracy in this context.

Results: We assess different strategies for short read alignment
and propose a novel phylogeny-aware alignment procedure. Our
alignment method can improve the accuracy of subsequent
phylogenetic placement of the reads into a reference phylogeny by
up to 5.8 times compared with phylogeny-agnostic methods. It
can be deployed to align reads to alignments generated by using
fundamentally different alignment strategies (e.g. PRANK+F versus
MUSCLE).

Availability: http://www.exelixis-lab.org/software.html

Contact: simon.berger@h-its.org; alexandros.stamatakis@h-its.org
Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on December 21, 2010 revised on May 24, 2011; accepted
on May 25, 2011

1 INTRODUCTION

Currently, bioinformatics is facing two challenges: the many-core
revolution and the biological data avalanche that is driven by
novel wet-lab sequencing techniques. In a single run, these new
sequencing techniques can generate between hundreds of thousands
up to several millions of short DNA reads with a length ranging
between 30 and 450 nt (Karow, 2010). One important application of
next-generation sequencing methods is in vivo sampling of microbial
communities [e.g. in the human gut (Turnbaugh et al., 2008) or
on human hands (Fierer et al., 2008)]. For phylogenetic analysis
of such metagenomic environmental samples, new likelihood-
based methods such as the Evolutionary Placement Algorithm
(EPA) (Berger et al., 2011; Stark et al., 2010) and pplacer (Matsen
et al., 2010) have recently become available. These new placement
algorithms help to establish the provenance of the anonymous
and diverse environmental sample of short reads by means of
assigning the reads to a given—ﬁxed—reference phylogeny. The
reference phylogeny is a fully resolved (strictly bifurcating)

 

*To whom correspondence should be addressed.

 

 

 

 

 

 

 

 

 

 

 

 

 

Al—I B
A 0100101000110
|:referenceMSA:| c 1901011111011
|:(RA) :l 0 0111101011101
[—| T 1011001001010
05 ACGTTGCACAGTC
:' MATCH xx x x xxx
|:|
QSalignment
process
|:|

: unaligned query
: sequences (05)

Fig. 1. (A) General scheme of the QS alignment procedure. (B) Matching a
QS against an ancestral state vector.

unrooted phylogenetic reference tree (RT) that is based on a ﬁxed
multiple reference alignment (RA) of the full-length sequences in
the RT (Fig. l).

Phylogenetic placement algorithms like the EPA or pplacer work
by inserting and removing again one short read at a time into
different edges (branches) of the RT. Thereby, they strive to ﬁnd
the optimal score of the extended (by one taxon) trees in order
to individually determine the best insertion edge for each short
read. The likelihood-based scoring of alternative short read insertion
positions in EPA and pplacer is conducted under standard models
of nucleotide substitution [e.g. generalized time reversible model
using the 1" model of rate heterogeneity (GTR+l"; Yang, 1994)]. The
accuracy of such a likelihood-based placement of reads depend upon
the multiple sequence alignment (MSA), that entails the RA and the
short sequence reads [henceforth denoted as query sequences (QS)].
Therefore, a prerequisite for phylogenetic placement algorithms is,
that the Q5 need to be aligned to the RA (Fig. 1A), before conducting
a placement run. We investigate the problem of aligning short reads
to a given reference alignment and compare alignment quality of
HMMALIGN (Eddy, 1998) to a new phylogeny-aware short read
alignment method by means of likelihood-based phylogenetic QS
placement accuracy.

The most straightforward approach to align QS with the RA
(containing full-length reference sequences) is to simply compute
a new MSA from scratch comprising the sequences in the RT and
the Q5 [e.g. using MUSCLE (Edgar, 2004), MAFFT (Katoh et al.,
2005) or PRANK+F (Loytynoja and Goldman, 2008)]. Because of
the extremely large and continuously growing number of Q5, this
de novo alignment approach can be computationally prohibitive.

Alternatively, one can keep the existing (potentially manually
curated) RA ﬁxed, and only align the Q5 with respect to this
RA, using dedicated QS alignment methods. One such method

 

2068 © The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com

112 ﬁlo's[BumoprOJXO'sotwuiJOJutotq”:duq 11101} papeolumoq

9103 ‘Og JSanV uo ::

Aligning short reads

 

for aligning QS with respect to a RA is implemented in the
HMMER (Eddy, 1998) tool-suite. HMMER initially builds a proﬁle
Hidden Markov Model (HMM) from the RA. Thereafter, the QS are
aligned against the proﬁle-HMM that represents the RA. HMMER
implements a dedicated method, HMMALIGN that allows for
aligning multiple QS (one at a time) against the ﬁxed proﬁle-HMM
of the RA. HMMALIGN will then output an alignment that contains
the RA and the QS that have been aligned with respect to the proﬁle-
HMM of the RA. Note that, HMMALIGN frequently also modiﬁes
the RA by inserting gaps, if needed. When using a proﬁle-HMM,
the entire RA is represented by a monolithic—ﬂat—probabilistic
proﬁle that does not use the phylogenetic information of the RT.
MUSCLE and MAFFT offer similar options to align sequences (in
our case QS) against a monolithic proﬁle that is derived from an
existing RA. It has already been shown that QS alignment using
HMMALIGN performs reasonably well with respect to phylogenetic
placement accuracy (Berger et al., 2011; Matsen et al., 2010).
However, depending on the speciﬁc alignment strategy/philosophy
deployed to generate the RA, better alignment quality (as quantiﬁed
by QS placement accuracy) can be achieved by incorporating the
phylogenetic signal of the RT into the QS alignment process. Hence,
we mainly focus on adaptability of QS alignment methods to the
underlying, implicit RA structure.

We present PaPaRa (PArsimony-based Phylogeny-Aware short
Read Alignment), a novel, phylogeny-aware method for QS
alignment. To assess PaPaRa performance, we systematically
evaluate phylogenetic QS placement accuracy of the EPA for
different QS alignment methods. As baseline for comparisons, we
present corresponding results for EPA-based placement accuracy
based on QS alignments using HMMALIGN. While MUSCLE and
MAFFT also offer modes for sequence-proﬁle alignment (that can be
deployed for QS alignment), we exclusively focus on HMMALIGN
as a representative of monolithic proﬁle-based approaches for the
following reasons: MUSCLE offers an option to conduct proﬁle—
proﬁle alignments which corresponds to aligning two MSAs. Thus,
either all QS need to be represented by a single proﬁle (i.e. they
have to be ‘pre-aligned’ with respect to each other) or MUSCLE
needs to be invoked separately for each QS and the individual
results will have to be combined thereafter. Representing all QS
by a single proﬁle does not represent a good option, since it may be
impossible to align the QS to each other if the short fragments do not
exhibit sufﬁcient overlap. For the second MUSCLE alternative, it
is unclear, how the resulting individual per QS MSAs—possibly
containing gaps in the RA as well—can be synthesized/merged
into a single, comprehensive MSA. In contrast to MUSCLE,
MAFFT offers an analogous option for QS alignment as considered
here. However, in preliminary tests MAFFT returned considerably
worse QS alignments than HMMALIGN, with respect to our
evaluation criteria (placement accuracy; see below). For the above
reasons, we focus on comparing phylogeny-agnostic HMMALIGN
performance against phylogeny-aware performance of the PaPaRa
method described in the following section.

PaPaRa is available as open-source code at http://www.exelixis-
lab.org/software.html

2 ALGORITHM

PaPaRa is a novel method for short read alignment against a
ﬁxed reference MSA (RA) and the corresponding phylogenetic

Insertion Edges

IIIIIII 
/ r \ "'\
ancestral state

vector

    

Fig. 2. Unrooted RT and possible QS insertion positions. The QS are aligned
against the ancestral state vectors at the candidate insertion positions.

reference tree (RT). The underlying idea of PaPaRa is to align the
QS against the ancestral state vector of each edge in the RT. These
ancestral state sequences are conceptually similar to the proﬁles
used in HMMER. However, we do not use a probabilistic model
because of prohibitive run times (see below). A key difference
to HMMALIGN is that, in our approach we derive one proﬁle
per edge (branch) in the RT, as opposed to the single, monolithic
proﬁle that represents the whole RA in HMMALIGN. Thus, given
an RT with r taxa, m sites and q QS, we need to execute 0(rq)
alignment steps or 0(rqm2) operations. Note that, q is typically
signiﬁcantly larger than r. Because of this high time complexity, we
also introduce a proof-of—concept parallelization. The ancestral state
vectors, as used here, provide two different types of information:
the ancestral sequence proﬁle and a tree-derived gap signal (see
following paragraphs).

Ancestral sequence proﬁle: after reading the input data, our
algorithm visits the 2r—3 edges of the RT by means of a depth-
ﬁrst tree traversal, starting at an arbitrary terminal edge leading to
a tip. At each edge, we compute the parsimony state-vectors (Fitch
and Margoliash, 1967; Sankoff, 1975) of the RT at each end of the
edge. The signal from those two state vectors is then combined
using parsimony, to obtain the ancestral parsimony state for an
imaginary root node located on the current insertion edge (Fig. 2).
For DNA data, every edge b in the RT will thus be represented by
a parsimony state vector A), =A11,,...,AZ, where the individual A];
are the parsimony states for each alignment site i of the RA. Each
entry A]; is a bit vector; each bit corresponds to a character in the
sequence alphabet (see Fig. 1B). For DNA data, a bit vector at a site
i can have the following state set: Ai =aZ(A),aZ(C).aZ(G), aZ(T) E
{0, 1}4, where the a]; are the bits which correspond to the four DNA
characters. For practical reasons, the A]; are implemented using one
32-bit integer per site [e.g. sf, =a],(A)+2a],(C)+4a],(G)+8a],(T)
for DNA data]. This approach is not limited to DNA data; it can
be extended to alphabet sizes with up to 32 states in the current
implementation.

Gap signal: in addition to the parsimony states, we also use
phylogenetic information on the gap structure as induced by the
tree for our alignment process. This gap information is calculated
in conjunction with the parsimony state vectors when the RT is
traversed. For each alignment site, we recursively compute two ﬂags.
One ﬂag (denoted as ‘consistent gap’; CGAP) is used for indicating
that for a speciﬁc site in the RA, consistently there appears a gap. The
second ﬂag (denoted as ‘potential gap’; OPEN) is used to indicate if
the gap status of a site i is inconsistent. This type of a tree-derived gap
signal is based on similar ideas as used in PRANK+F (Loytynoja and
Goldman, 2008), which has been designed for de novo MSA. The
two ‘gap ﬂags’ are deployed in an analogous way as ‘compulsory

 

2069

112 ﬁlo's[BumoprOJXO'sotwuiJOJutotq”:duq 11101} papeolumoq

9103 ‘Og JSnﬁnV uo ::

S.A. Berger and A. Stamatakis

 

taxon taxon

 
 
     

TIP/TIP ub-tree

TIP/INNER

INNER/INNER

Fig. 3. Gap signal ‘ﬂow’ from the tips toward the QS insertion position.

gaps’ (CGAP) and ‘potential free gaps’ (OPEN) in PRANK+F.
Because the signal is calculated from the tips toward the current
insertion edge (Fig. 3), we need to consider three cases for combining
gap signals during a post-order tree traversal: TIP/TIP, TIP/INNER
and INNER/INNER. Thus, we need to devise rules for recursively
combining the gap signals from the child nodes. In the TIP/TIP case
(the children to the left and right of the node at which we intend to
compute the ‘ancestral’ gap signal are tips), the gap signal coming
from the two tips can either be gap or non-gap. If both tips have a
gap, the result is CGAP, which indicates that in the subtree deﬁned
by the current ancestral node the two tips have a gap signal at site
i. If only one tip has a gap, the outcome is OPEN, indicating a
‘potential gap’. For the TIP/INNER case, the ﬂags are computed
as follows: if either both child nodes have a gap or the tip has a
gap and the ancestral child node has a potential gap (indicated by
OPEN), the result is a CGAP. In this case, the ‘potential’ gap signal
coming from the INNER side is upgraded (promoted) to a consistent
gap. If only one child node signals a consistent or potential gap,
the result is OPEN. Finally, for the INNER/INNER case (i.e. two
ancestral child nodes), only two consistent CGAP signals will result
in a CGAP at the ancestral node. If only one child node has a CGAP,
the result at the ancestral node is OPEN. This rule set for combining
and propagating the gap signal through the tree has been derived
empirically. While the rule set can evidently be further reﬁned, it
already yields promising results on real biological datasets. Note
that, we align the QS to ancestral states derived from the edges of
the RT. Thus, for each edge, we combine the gap signals of the two
adjacent nodes. This combination of gap signals is accomplished
by using the same rules (TIP/INNER and INNER/INNER cases) as
described above. Essentially, this corresponds to placing a temporary
root in the middle of the insertion edge.

Dynamic programming alignment: once the gap signal and the
ancestral parsimony state at the candidate insertion edge have been
computed, they are deployed to calibrate the alignment scoring
scheme for the QS at this edge by modifying the match/mismatch and
gap open/extend penalties. Only the CGAP ﬂag and not the OPEN
ﬂag inﬂuences the scoring scheme of the alignment algorithm (see
below). In general, the CGAP ﬂag will calibrate the scoring scheme
such that, aligning QS characters against sites with a CGAP ﬂag
is strongly penalized. Opening and extending gaps at these CGAP
positions will be preferred. Thereby, if we try to align a QS against
the ancestral state of a tree region, where gaps are common for
certain alignment sites, it is very likely that the QS alignment will
also contain gaps at these sites.

The actual alignment of the QS against each ancestral state
vector is carried out by a standard dynamic programming algorithm
for pair-wise alignment using afﬁne gap penalties (Gotoh, 1982).
Pairwise alignment is conducted with two modiﬁcations. First, we
deploy a ‘free shift’ or overlapping alignment strategy (Huang,
1992), that is, gaps inserted at the beginning and/or end of the QS
are not penalized. Secondly, the afﬁne gap model is only used for
inserting gaps into the QS (i.e. deletions in the OS). For inserting
gaps in the RA (i.e. insertions in the OS), we deploy a ﬂat gap
penalty. In practice, instead of inserting gaps in the RA, we instead
simply delete these insertion characters in the QS. The rationale
for this is that, introducing gaps in the RA does not provide any
additional information for QS placement using the EPA. In other
words, ‘empty’ RA columns that entirely contain gaps (modeled
as undetermined characters in standard ML implementations) will
not affect the EPA placements, since we align only one QS at a
time. While inserting gaps in the RA may be useful for aligning the
QS with respect to each other, our focus here is on evolutionary
placement of the QS relative to the RA.

The alignment scoring function is provided in Equation (1). The
equation recursively deﬁnes the score of the dynamic programming
matrix cell Di’j in column i and row j for aligning site Ai of the
ancestral state vector against site Bi in the QS.

CGi _ 10 if CGAP is set for site i
— 0 otherwise

. . (2,1) ifCGi=0
GPl ,GP’ =
( OE E) {(0.0) otherwise
Sid? 0 ifAiandBimatch
— 3 otherwise

1131‘ = Di’j_1+3

- ~ Di_1’j +GPi
D2] = min i_1j QB
DE ’ +GP1E
Di_1’j_1+Si’j+CGi
D” = min DE] (1)
1131.

The term CGi is used to adapt the scoring scheme for sites where
the ‘constant gap’ (CGAP) ﬂag is set. Thereby, we substantially
penalize matching a QS site against such sites in the RT/RA
and allow for free gap insertion in the QS at such positions.
The remaining deﬁnitions correspond to a standard dynamic
programming implementation of the Gotoh (1982) algorithm for
sequence alignment with afﬁne gap penalties. As described above,
every stateAi is a bit vector with one bit per alphabet character. Thus,
one may think of the ancestral parsimony state vector as a simple
proﬁle, where the bits determine which character of the QS can be
aligned for ‘free’ against an ancestral state character (Fig. 1B). If,
for example Ai = 1, 1,0,0, this means that, As and Cs in the QS can
be matched against alignment site i for this ancestral state vector
without incurring a mismatch penalty. Thus, the score SM is 0 (i.e.
no penalty is induced), if the bit corresponding to character j of
the QS is set in Al. Otherwise, the scoring scheme Si’j will return
the default mismatch penalty of 3. Note that, the numerical values

 

2070

112 ﬁlo's[BumoprOJXO'sotwuiJOJutotq”:duq 11101} papeolumoq

9103 ‘Og isnﬁnv uo ::

Aligning short reads

 

given in Equation (1) represent the default parameters (used in all
our experiments), which have been derived empirically. PaPaRa
can also deploy user-deﬁned parameters. While there exist more
elaborate probabilistic methods (e.g. TKF92; Thome et al., 1992),
‘ad hoc’ scoring schemes (e.g. BLAST or Smith—Waterman) are
still widely used for bioinformatics analyses. Moreover, because of
the high computational complexity of our approach [0(rqm2)], it
is currently not computationally feasible to explore more elaborate
scoring schemes. In other words, there is a clear trade-off between
model accuracy and execution times.

2.1 Implementation

PaPaRa is implemented in C/C++ as experimental extension of
RAxML (Stamatakis, 2006). It uses the existing routines for
parsing alignment ﬁles and trees, as well as the existing parsimony
implementation. Initially, the algorithm reads and parses the RT, RA
and QS. The taxon names in the RT (Newick format) and the RA
(relaxed PHYLIP format, see RAxML v7.0.4 Manual) need to be
consistent: all taxa in the RT must have a corresponding sequence
in the RA. The QS that shall be assigned to the RT can be read
from a separate FASTA ﬁle or be included in the RA (for details see
PaPaRa README).

The aligner uses a custom-built sequential dynamic programming
implementation (i.e. the core alignment algorithm is single-threaded
and not vectorized). However, as (Farrar, 2007) demonstrated for the
Smith—Waterman algorithm (Smith and Waterman, 1981), dynamic
programming algorithms can be signiﬁcantly accelerated by means
of vectorization. Therefore, we plan to also develop a vectorized
version of PaPaRa. Further technical implementation details (e.g.
cache utilization, parallelization) are described in the Supplementary
Material.

We also implemented and tested a one-sided version of the
alignment method, where gaps are only inserted in the QS and not
the RA. The respective, simpliﬁed dynamic programming algorithm
exhibits fewer dependencies between matrix cell computations. This
property can be exploited for further performance improvements.
This comes at the cost of alignment quality if insertions (with respect
to the sequences in the RA) are common in the QS. For further
details, please refer to the Supplementary Material.

As already mentioned, PaPaRa relies on a free-shift alignment
strategy. Therefore, after the dynamic programming matrix has been
ﬁlled, we search for the optimal alignment score (minimum) in
the last row of the dynamic programming matrix. This allows for
insertion of free gaps at the end of the QS. In standard free-shift
alignment procedures, one has the search for the minimum score in
the last row and the last column of the matrix, because it allows for
free gaps at either end of both sequences. It is possible to deploy a
local alignment scheme or the standard free-shift alignment method
in PaPaRa to handle cases where the procedure presented here is not
applicable (e.g. QS not fully contained in the RA).

3 EXPERIMENTAL SETUP

The main application scenario for PaPaRa is for metagenomic
analyses using phylogenetic placement methods such as the
EPA (Berger et al., 2011) or pplacer (Matsen et al., 2010). As
mentioned in Section 1, for these algorithms the QS need to be
in alignment with the RA. To this end, our performance evaluation

A 3 Maximum
Reference . . placement Error
Insertion pOSItIO

.. . \
Edge Distance
1
s:-
 ‘

insertion Position
generated by EPA

    
     

  

«it».

on path

 

HHHHH'IHIIIHIIIH
(“III [II [I [II [I [II [II

I
h
I

Ii!

 
      

Reference
insertion Position

Fig. 4. (A) Distance measures: node distance (ND) and edge distance (ED).
(B) The maximum placement error for two exemplary reference insertion
position.

is speciﬁcally designed to assess the accuracy of alignment methods
(PaPaRa, HMMALIGN) with respect to analyzing (identifying)
short reads by means of phylogenetic placement algorithms. In other
words, we do not directly evaluate alignment quality. Instead, we
analyze the impact of the QS alignment method on the phylogenetic
placement quality/accuracy using the EPA. Therefore, we assess
alignment quality by means of the calculated/inferred evolutionary
position of the QS. In Berger et al. (2011), we devise measures and
methods for assessing the placement accuracy of short reads using
the EPA. We also carried out a basic assessment of QS placement
accuracy when QS are realigned with HMMALIGN (v3.0), albeit
in a different experimental setup and context. Here, we use the
same distance/accuracy measures (Fig. 4A). The node distance (ND),
which is deﬁned as the number of nodes along the path between the
‘true’ placement position and the inferred placement position (see
below) represents an absolute accuracy measure. The normalized
edge distance (EDN%), is a relative measure between ‘true’ and
inferred placement positions that is based on the actual edge lengths
in the RT. The EDN% reﬂects the relative evolutionary distance
between the two positions. In contrast to Berger et al. (2011), we
use a revised scheme for normalizing the edge distance: rather than
normalizing it by the tree diameter (longest path in the tree), we
now deploy a position-speciﬁc maximum possible placement error
(Fig. 4B). This position-speciﬁc placement error corresponds to the
QS-speciﬁc worst-case scenario, that is, we normalize by the longest
path from the ‘true’ insertion position to a terminal edge.

3.1 Realignment of simulated QS

The main part of our performance evaluation compares the
placement accuracy of EPA-computed QS placement with respect
to the placement position of the optimally aligned QS (‘true’
placement). The EPA placements obtained without QS alignment
are regarded as the optimal (‘true’) reference placements, against
which the phylogenetic placements after QS realignment with
PaPaRa/HMMALIGN are compared. For such an evaluation, we
require QS that are already in alignment with the RA in order
to compute an optimal reference placement with the EPA that
represents the ‘true’ placement. The QS. which are assumed to be

 

2071

112 ﬁlo's[BumoprOJXO'sotwuiJOJHtotq”:duq 111011 papeo1umoq

9103 ‘0g15n8nv uo ::

S.A. Berger and A. Stamatakis

 

correctly aligned in the reference QS alignment, are initially dis-
aligned (we simply remove all gaps), and passed to the two QS
alignment procedures (PaPaRa and HMMALIGN) for realignment.
The thereby realigned QS are then used as input for the EPA.

The correctly aligned QS were extracted from seven real-world
full-length biological MSAs (termed original MSAs). The taxon set
of each reference MSA is randomly split into two subalignments of
equal size (each containing 50% of taxa from the original MSA). One
half of the original MSA is then used as RA, on which we compute
the best-known maximum likelihood (ML) tree with RAxML. This
tree is then used as RT for the RA. The other half of the original
RA MSA is used to generate a QS set. Because both subalignments
originally formed part of the same MSA, all sequences in the QS
set (and all subsequences of these sequences) are in alignment with
the RA. The sequences in the QS set that are derived from an MSA
of full-length sequences are then reduced in length (see below for
details) to emulate QS that resemble short sequence reads.

For each dataset, we carried out our performance analysis using
three common MSA methods to generate three original MSA
versions respectively. We computed de novo MSAs using MUSCLE
(v3.70), MAFFT (v6.626) and PRANK+F. We selected these three
programs, because they are widely used state-of—the-art codes
for MSA and because they are based on fundamentally different
alignment philosophies. Since we adopt an agnostic View on what the
best MSA strategy may be, we thereby intend to assess the ﬂexibility
and adaptability of PaPaRa to diverse MSA philosophies that are
implicitly encoded in the underlying RAs. Finally, we also used
the partially manually curated MSAs as provided by the authors of
our test datasets. While manual curation is debatable, in particular
in the light of reproducibility of results, we nonetheless used the
given MSAs because hand curation is still a common practice and
may encode empirical biological knowledge about the underlying
data. We also conducted an experiment using simulated sequence
data. On the simulated alignment, the performance of PaPaRa and
HMMALIGN is considerably better than on the corresponding
real-world alignment and tree (see Supplementary Material for
details). Thus, the QS alignment problem is harder for real data than
for simulated data. Therefore, we use real sequence data for our
performance assessment. For each of the seven datasets, we thus
have four original MSA versions: manually curated (called ORIG
throughout the article), MUSCLE, MAFFT and PRANK+F. Table 1
contains information about the length (number of RA columns) in
the datasets as well as the number of taxa contained in the RAs and
the respective number of QS.

In our experiments, we assume that the full-length QS (and
the derived short QS) obtained from the four MSA versions for
each dataset represent ideally aligned QS. with respect to the
corresponding RA. To the best of our knowledge HMMALIGN and
PaPaRa currently represent the most suitable methods for aligning
short-reads to an RA. Therefore, we speciﬁcally did not use real short
read data, for which the correct alignment to the RA is not known.
Our experiments are designed to systematically test the impact of
QS alignment quality on the evolutionary placement process using
the EPA. Thus, we did not consider alignment quality criteria, other
than the relative QS placement error with respect to the reference
QS placement obtained from the original MSA.

From every full-length QS in the QS set, we randomly subsampled
20 contiguous QS with uniformly distributed position and normally
distributed lengths (mean length: 100:I: 10 bp and 200:I:60 bp).

Table 1. Datasets used for evaluation of the QS alignment algorithms

 

Dam No. of sites No. of sites No. of sites No. of sites No. of No. of

 

MSA ORIG MUSCLE MAFFT PRAN K taxa QS

D150 1269 1272 1336 1939 75 1500
D218 2101 2044 1993 6425 109 2180
D500 1398 1402 1402 1479 250 5000
D628 1199 1761 1348 2437 314 6280
D714 1241 1341 1273 2205 357 7140
D855 1436 1469 1443 2208 427 8560
D1604 1271 1325 1278 2475 802 16040

 

The values in columns 275 correspond to the four RA per dataset, which have
been generated with the different MSA approaches (ORIG, MUSCLE, MAFF’T and
PRANK+F).

We have already used this method for QS generation in (Berger
et al., 2011) to create simulated short read sequences that emulate
reads obtained from a high-throughput sequencer. For each of
the 20 subsampled QS. we computed an individual reference
placement, because the EPA placement of the subsampled QS can
differ from the placement of the full-length QS. Thereby, we can
more accurately assess the QS alignment impact on placement
accuracy, without the potential bias that is induced by QS length
variation [see Berger et al. (2011)]. To yield the evaluation more
realistic, we then also modiﬁed the subsampled QS by introducing
typical next-generation sequencer errors. Based on the methods
implemented in Grinder (Angly et al., 2009) and the empirical
data by Balzer et al. (2010), we reimplemented an appropriate
model for simulating representative 454 homopolymer sequencing
errors. Each homopolymer (this also includes single characters)
that is detected in the raw QS is randomly shortened or elongated,
according to empirical probabilities provided by Balzer et al. (2010).

Because we derive the new RA by splitting the original MSA into
two parts (i.e. the RA and the QS set), it is likely that the RA will
contain sites that entirely consist of gaps. This is especially true for
MSAs generated with PRANK+F, that frequently comprise sites
with only one or two non-gap characters. Since entirely ‘empty’
columns that only contain gaps are not present in real MSAs,
such columns are completely removed from the RA prior to QS
alignment (using HMMALIGN and PaPaRa) and placement in our
experiments.

4 RESULTS AND DISCUSSION

For each of the seven datasets, we determined PaPaRa- and
HMMALIGN-based QS placement accuracy for all four original
MSA versions. Tables containing the results for all datasets are
provided in the Supplementary Material. The values in the Tables
indicate RT-based average ND and EDN% distances between
the ‘true’ reference EPA placements, based on the QS alignment
extracted from the original MSA and the respective EPA placements
with QS realignment. Values for the two QS realignment methods
(PaPaRa, HMMALIGN) are provided separately. Preliminary tests
using MAFFT for QS alignment, generated placements that were at
least two times further away from their reference position than those
obtained with HMMALIGN (data not shown). We, therefore, only
report results for HMMALIGN and PaPaRa.

 

2072

112 ﬁlo's[BumoprOJXO'sotwuiJOJHtotq”:duq 111011 popco1umoq

9103 ‘0g isnﬁnv uo ::

Aligning short reads

 

Table 2. Placement accuracy for the two QS alignment methods on the
largest dataset (D1604)

 

 

 

 

ND EDN %
D MA PaPaRa HMM PaPaRa HMM
c, ORIG 0.28 1.35 (4.87) 0.71 1.35 (1.90)
; MUSCLE 0.43 1.35 (3.11) 0.87 1.48 (1.70)
8 MAFFT 0.29 1.21 (4.12) 0.72 1.29 (1.80)
PRANK+F 0.41 2.43 (5.88) 0.95 2.41 (2.52)
c, ORIG 0.25 0.90 (3.53) 0.63 0.80 (1.28)
3H” MUSCLE 0.40 1.03 (2.61) 0.76 0.92 (1.21)
g MAFFT 0.26 0.82 (3.18) 0.65 0.79 (1.21)
PRANK+F 0.34 1.65 (4.80) 0.84 1.39 (1.64)

 

The relative accuracy of HMMALIGN compared to PaPaRa is given in parentheses.

In Table 2, we provide results for the largest dataset (D1604) in
terms of number of taxa using QS with a mean length of 100:I: 10
bp. When HMMALIGN is used for realignment on the manually
curated MSA on this dataset, EPA placements are on average
1.35 nodes (column HMM, row ORIG) away from the reference
placement position. For PaPaRa the corresponding node distance
(ND) is 0.28 (column PA, row ORIG). When the relative distance
(EDN%) is used, the corresponding values are 1.35 (HMMALIGN)
and 0.71 (PaPaRa). Therefore, PaPaRa reduces the error in QS
node placement distance by a factor of 4.87 (factor 1.90 for the
relative distance) compared with HMMALIGN. For the automated
MSA methods (MUSCLE, MAFFT, PRANK+F), HMMALIGN and
PaPaRa yield analogous accuracy differences. The EPA placements
of realigned QS are on average 3.11—5.88 times closer (1.7—2.52
times for the EDN% distance) to the reference placements in terms
of node distance (ND) for PaPaRa than for HMMALIGN. On some
of the smaller datasets (D150, D218 and D714), the PaPaRa-aligned
QS can produce worse placements than the HMMALIGN-aligned
QS (see Supplementary Material). However, in most cases, PaPaRa
only produces worse results with respect to the EDN% measure.

For the longer QS of mean length 200, in most cases, placement
accuracy increases for both alignment methods. The improvements
are more pronounced for HMMALIGN, where the ND is improved
by up to a factor of 2. Generally, accuracy differences between
PaPaRa and HMMALIGN decrease. For ﬁve of the seven datasets,
PaPaRa produces worse results than HMMALIGN at least for some
of the tests (i.e. for certain RA and distance measure combinations,
see Supplementary Material). As with the shorter QS. this is
especially pronounced on the smaller datasets with less taxa. Thus,
apparently, the advantage of using a phylogeny-aware QS alignment
strategy on datasets with few taxa is smaller. In contrast to PaPaRa,
on small datasets HMMALIGN can take advantage of its more
powerful probabilistic RA model and the stronger signal contained
in the 200 bp long QS. However, the typical RT will be considerably
larger than the smallest datasets in this study, because of the very
dense taxon sampling of the 16S rRNA. Thus, while the accuracy
improvement induced by PaPaRa is minor on small datasets, it
substantially improves placement quality on the larger reference
datasets in our experiments.

The rather pronounced difference between the two distance
measures (i.e. when the ND is considered, the advantage of PaPaRa

A 45000 B 45000
40000 PaPaRa — — 40000 PaPaRa — —
35000 HMMAIign — - 35000 HMMAIign — -
a 30000 — a 30000 —
g 25000 - g 25000 -
3 20000 — 3 20000 —
15000 - 15000 -

10000
5000

0
0 2 4 6 8 101214
node-dist from reference placement

10000
5000

0
0 2 4 6 8 101214
node-dist from reference placement

 

 

 

 

15000
10000
5000

0
0 2 4 6 8 101214
node-dist from reference placement

15000
10000
5000

0
0 2 4 6 8 101214
node-dist from reference placement

C 45000 D 45000
40000 PaPaRa — — 40000 PaPaRa —
35000 HMMAIign — - 35000 HMMAIign —
._. 30000 - ._. 30000
E 25000 - E 25000
3 20000 — 3 20000

 

 

 

 

Fig. 5. Histograms showing the distribution of the placement error (ND)
for PaPaRa and HMMALIGN aligned QS. over all datasets. (A) Orig; (B)
muscle; (C) mafft; (D) prank.

over HMMALIGN is larger than for the EDN%) can be attributed
to the RT shape of this dataset (D1604): visual inspection revealed
that, it contains a large number of closely related taxa which gives
rise to a large number of relatively short edges (branches) near the
tips of the tree. Thus, if a QS is misplaced within such a region of
the tree, this can result in a relatively large ND (because there is a
large number of nodes in the region), but a small EDN% since edges
between the nodes are short. The HMMALIGN realigned QS tend
to be misplaced in such ‘dense’ areas of the tree, which results in a
relatively large average ND compared with PaPaRa realigned QS. To
this end, by using a phylogeny-aware approach, PaPaRa can better
use such densely sampled areas in the RT, while such a ﬁne-grained
resolution cannot be achieved by using a ‘ﬂat’ probabilistic proﬁle
(e.g. HMMALIGN). On smaller datasets, the differences between
the two distance measures are less pronounced (see Supplementary
Material).

In most cases, the largest difference in placement accuracy
between PaPaRa and HMMALIGN is observed for PRANK+F-
based MSAs. Because of the speciﬁc MSA approach in PRANK+F,
a strong and consistent gap signal is embedded into the original
MSA. In contrast to HMMALIGN, PaPaRa is able to use this
embedded gap signal in combination with the respective RT.
In Figure 5, we provide histograms of the average ND distribution
for QS (with mean length 100bp) over all datasets and for all
reference MSAs. PaPaRa-based QS alignments generate placements
that are, on average, closer to the ‘true’ reference position. The
histograms also show that for PRANK+F-generated MSAs, the
placement accuracy decrease induced by using HMMALIGN is
more pronounced compared with other MSA methods. In general,
PaPaRa is thus more robust with respect to different MSA
philosophies and hence more adaptable.

For the above experiments, we knew a priori that the QS had
sufﬁciently closely related sequences in the RA. If this is not given
(e.g. if reads from a distant clade not contained in the RT are
sampled), according to some preliminary experiments, neither the
QS alignment method nor the EPA can be expected to produce
reasonable results. This observation also holds when the QS stem
from a different (e.g. non-orthologous) genomic region than the
sequences in the RA. Therefore, we suggest that the QS should
be checked beforehand, for example by doing a quick BLAST

 

2073

112 /3.10's[BumoprOJXO'sotwuiiqutotq”:duq 111011 popco1umoq

9103 ‘0g isnﬁnv uo ::

S.A. Berger and A. Stamatakis

 

search against the sequences in the RA to reject completely unrelated
sequences.

4J, Execuﬁonthnes

We also carried out a runtime assessment of HMMALIGN and
PaPaRa. A serial execution of PaPaRa requires 385—44 270s on
the smallest (D150) and largest (D1604) dataset, respectively
(using the ORIG MSA and QS of lengths 200:I:60 bp on an
3.2GHz Intel Core i5; compiled with gcc 4.5.1 for Linux).
The corresponding HMMALIGN times range between 61s and
1031 s. Thus, HMMALIGN is 63—43 times faster than PaPaRa. This
performance difference is not surprising, because PaPaRa runtimes
depend on the number of QS and the number of taxa in the RT.
In other words, PaPaRa exhibits a signiﬁcantly higher theoretical
runtime complexity than HMMALIGN. Therefore, performance
optimization of the core alignment procedure is essential for
overall PaPaRa performance. The inherent—signiﬁcantly higher—
time complexity of PaPaRa is also one main reason for aligning
against ancestral parsimony state vectors (i.e. bit vectors), instead
of using a probabilistic approach that would require costly ﬂoating
point arithmetics.

Currently, PaPaRa creates the QS alignments in two phases:
initially, all QS are aligned, and thereby scored, against all ancestral
state vectors (insertion positions/edges of the RT). For performance
reasons, the actual alignments (i.e. the dynamic programming
traceback) are not generated in this phase. After the best scoring
insertion position has been determined for each QS, the actual
alignments are then generated by aligning them again to the best
positions in a second step. The initial step normally accounts
for >99% of overall runtime. As already mentioned, the core
alignment procedure could be further optimized by deploying 128
bit wide SSE or even 256 bit wide AVX vector instructions. One
could also think of a more compact bit-level representation of
the input data to reduce memory requirements and cache misses.
Our current dynamic programming implementation can perform
about 120 MCUPS (million cell updates/s) on the Intel Core i5.
For comparison, Farrar (2007) reports >3000 MCUPS for his SSE
optimized Smith—Waterman implementation on an older 2.0GHz
Intel Xeon Core 2 Duo processor. Note that HMMALIGN, as
used here, already includes SSE vectorization in the alignment
algorithm. We are therefore conﬁdent that, the runtime gap between
HMMALIGN and PaPaRa can be signiﬁcantly reduced in future
versions of the code.

5 CONCLUSKNJANDFUTUREINORK

We have conducted an experimental evaluation of methods for
aligning short QS against a ﬁxed RT and RA in the context of
likelihood-based evolutionary QS placement methods. We also
introduced PaPaRa, a novel phylogeny-aware method for this
purpose. On short QS and large RAs, PaPaRa performs better than
the currently best phylogeny-agnostic method (HMMALIGN). For
longer QS and small RAs, the performance of the current PaPaRa
implementation is relatively poor. Apparently, the more powerful
probabilistic model in HMMALIGN is beneﬁcial, if the RA is
small enough to be represented by a single ﬂat proﬁle. For larger
RAs, PaPaRa has the advantage of sampling different signals from
different parts of the associated RT and performs well, despite using

a simple model for ancestral states and an ‘ad hoc’ scoring scheme.
We intend to introduce additional heuristics for reducing the total
number of ancestral state vectors against which individual QS need
to be aligned. We also plan to exploit data parallelism in the core
alignment algorithm by using SSE and AVX vector instructions.
PaPaRa can also be used to generate multiple ‘candidate’ alignments
for each QS (it is likely that the current method generates multiple
alignments with equal scores per QS because of the discrete scoring
scheme). Those different per-QS alignment candidates could then
be scored by their placement scores under ML to select the ‘best
candidate’.

As a more fundamental improvement, we will explore methods
to reﬁne the gap propagation in the tree based on a binary
likelihood model. A further option, worth exploring, would be to
use a probabilistic alignment approach, where the ancestral states
resemble the probability vectors as used in likelihood-based tree
inference. In the long term, we will work on integrating the EPA with
PaPaRa. One possible application would be dynamic alignment/tree
extension by full-length sequences as they appear in GenBank. This
would represent a step toward simultaneous/integrated tree building
and alignment.

Funding: Auspices of the Emmy-Noether program by the German
Science Foundation (DFG; grant number STA 860/2) in part.

Conﬂict of Interest: none declared.

REFERENCES

Angly,F.E. et al (2009) The GAAS metagenomic tool and its estimations of viral
and microbial average genome size in four major biomes. PLoS Comput. Biol,
5, e1000593.

Balzer,S. et al (2010) Characteristics of 454 pyrosequencing data enabling realistic
simulation with ﬂowsim. Bioinformatics, 26, 14201425.

Berger,S.A. et al (2011) Performance, accuracy and web-server for evolutionary
placement of short sequence reads under maximum-likelihood. Syst. Biol, 60,
2917302.

Eddy,S. (1998) Proﬁle hidden markov models. Bioinformatics, 14, 7557763.

Edgar,R.C. (2004) Muscle: multiple sequence alignment with high accuracy and high
throughput. Nucleic Acids Res, 32, 179271797.

Farrar,M. (2007) Striped Smith-Waterman speeds database searches six times over other
SIMD implementations. Bioinformatics, 23, 1567161.

Fierer,N. et al (2008) The inﬂuence of sex, handedness, and washing on the diversity
of hand surface bacteria. Pmc. Natl Acad. Sci. USA, 105, 17994417999.

Fitch,W. and Margoliash,E. (1967) Construction of phylogenetic trees. Science, 155,
2797284.

Gotoh,O. (1982) An improved algorithm for matching biological sequences. J. Mol
Biol, 162, 7057708.

Huang,X. (1992) A contig assembly program based on sensitive detection of fragment
overlaps. Genomics, 14, 18725.

Karow,J. (2010) Survey: Illumina, solid, and 454 gain ground in research labs;
most users mull additional purchases. Available at http://www.genomeweb.com
/sequencing/survey-illumina-solid-and-454-gain-ground-research-labs-most-users-
mull-addition.

Katoh,K. et al (2005) MAFFT version 5: improvement in accuracy of multiple sequence
alignment. Nucleic Acids Res, 33, 5117518.

Loytynoja,A. and Goldman,N. (2008) Phylogeny-aware gap placement prevents errors
in sequence alignment and evolutionary analysis. Science, 320, 1632.

Matsen,F. et al (2010) pplacer: linear time maximum-likelihood and Bayesian
phylogenetic placement of sequences onto a ﬁxed reference tree. BMC
Bioinformatics, 11, 538.

Sankoff,D. (1975) Minimal mutation trees of sequences. SIAM. J. Appl Mat/1., 28,
3542.

Smith,T.F. and Waterman,M.S. (1981) Identiﬁcation of common molecular
subsequences. J. Mol Biol, 147, 1957197.

 

2074

112 /3.10's[BumoprOJXO'sotwuiiqutotq”:duq 111011 papeo1umoq

9103 ‘0g isnﬁnv uo ::

Aligning short reads

 

Stamatakis,A. (2006) RAxML-VI-HPC: maximum likelihood-based phylogenetic
analyses with thousands of taxa and mixed models. Bioinformatics, 22, 268872690.

Stark,M. et al (2010) MLTreeMap-accurate Maximum Likelihood placement
of environmental DNA sequences into taxonomic and functional reference
phylogenies. BMC Genomics, 11, 461.

Thorne,J.L. et al (1992) Inching toward reality: an improved likelihood model of
sequence evolution. J. Mol Evol, 34, 3716.

Turnbaugh,P. et al (2008) A core gut microbiome in obese and lean twins. Nature, 457,

480—484.

Yang, Z. (1994) Maximum likelihood phylogenetic estimation from DNA sequences

with variable rates over sites. J. Mol Evol, 39, 3067314.

 

2075

12 /310's12u1n0fp101x0'so112111101u101q//:d1111 111011 pap201um0q

9103 ‘0g1sn8nv 110 ::

