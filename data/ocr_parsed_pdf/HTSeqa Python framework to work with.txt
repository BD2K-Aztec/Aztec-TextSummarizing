BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

5AM_Alignment

read: SequenceWithQualities
name: string
read: string
qual: array of int

aligned: boolean

iv: Genamiclnterval
chrom' string

strand: string ("+
cigar: list of CigarOperation
objects
 (more fields)

 

/3.IO'S[BIIm0[p.IOJXO'SOIJBIIIJOJIIIOIq/ﬂdnq

S.Anders et al.

 

These approaches are prototypical for scripts built on HTSeq
and hence explained and demonstrated in detail in the documen—
tation (Section ‘A detailed use case: TSS plots’).

The second use case discussed in detail is that of counting
for each gene in a genome how many RNA—Seq reads map to
it. In this context, the HTSeq class CigarOperation is demon—
strated, which represents complex alignments in a convenient
form (Fig. lb). This section of the documentation also explains
HTSeq’s facilities to handle multiple alignments and paired—end
data.

The remainder of the documentation provides references for
all classes and functions provided by HTSeq, including those
classes not used in the highlighted use cases of the tutorial
part, such as the facilities to deal with variant call format
(VCF) ﬁles.

4 HTSEQ-COUNT

We distribute two stand—alone scripts with HTSeq, which can be
used from the shell command line, without any Python know—
ledge, and also illustrate potential applications of the HTSeq
framework. The script htseq—qa is a simple tool for initial quality
assessment of sequencing runs. It produces plots that summarize
the nucleotide compositions of the positions in the read and the
base—call qualities.

The script htseq—count is a tool for RNA—Seq data analysis:
Given a SAM/BAM file and a GTF or GFF file with gene
models, it counts for each gene how many aligned reads overlap
its exons. These counts can then be used for gene—level differen—
tial expression analyses using methods such as DESqu (Love
et al., 2014) or edgeR (Robinson et al., 2010). As the script
is designed speciﬁcally for differential expression analysis, only
reads mapping unambiguously to a single gene are counted,
whereas reads aligned to multiple positions or overlapping with
more than one gene are discarded. To see why this is desirable,
consider two genes with some sequence similarity, one of which
is differentially expressed while the other one is not. A read that
maps to both genes equally well should be discarded, because if
it were counted for both genes, the extra reads from the differ—
entially expressed gene may cause the other gene to be wrongly
called differentially expressed, too. Another design choice made
with the downstream application of differential expression test—
ing in mind is to count fragments, not reads, in case of paired—
end data. This is because the two mates originating from the
same fragment provide only evidence for one cDNA fragment
and should hence be counted only once.

As the htseq—count script has found widespread use over the
past 3 years, we note that we recently replaced it with an over—
hauled version, which now allows processing paired—end data
without the need to sort the SAM/BAM ﬁle by read name
ﬁrst. See the documentation for a list of all changes to the
original version.

5 DISCUSSION

HTSeq aims to ﬁll the gap between performant but monolithic
tools optimized for specialized tasks and the need to write data
processing code for HTS application entirely from scratch.
For a number of the smaller tasks covered by HTSeq, good

stand—alone solutions exist, e.g. FastQC (http://www.bioinfor—
matics.babraham.ac.uk/projects/fastqc/) for quality assessment
or T rimmomatic (Bolger et al., 2014) for trimming of reads. If
the speciﬁc approaches chosen by the developers of these tools
are suitable for a user’s application, they are easier to use.
However, the need to write customized code will inevitably
arise in many projects, and then, HTSeq aims to offer advantages
over more narrow programming libraries that focus on speciﬁc
file formats, e.g. PySam and Picard (http://picard.sourceforge.
net/) for SAM/BAM ﬁles, by integrating parsers for many
common file formats and ﬁxing conventions for data interchange
between them. For R developers, similar functionality is now
available within the Bioconductor project (Gentleman et al.,
2004) with packages like Rsamtools and GenomicRanges
(Lawrence et al., 2013). Within Python, HTSeq complements
Biopython (Cock et al., 2009), which provides similar function—
ality for more ‘classic’ bioinformatics tasks such as sequence
analysis and phylogenetic analyses but offers little support for
HTS tasks.

Although most uses of HTSeq will be the development of
custom scripts for one speciﬁc analysis task in one experiment,
it can also be useful for writing more general tools. The htseq—
count script, for example, prepares a count table for differential
expression analysis, a seemingly easy task, which, however, be—
comes complicated when ambiguous cases have to be treated
correctly. Despite being written in Python, htseq—count offers
decent performance: Tested on a standard laptop computer,
htseq—count (version 0.6.1) processed about 1.2 million reads
(0.6M read pairs) per minute, using about 250 MB of RAM to
hold the human gene annotation in memory. When the file was
sorted by position rather than read name, so that mate pairs were
not in adjacent records, processing time increased to a bit less
then twice as much, and, for a SAM ﬁle of 26 GB, less than
450 MB of additional space in RAM were needed for the
buffer holding reads with outstanding mates.

When HTSeq was first released in 2010, htseq—count was the
first comprehensive solution for this task, and has since then
been widely used. Recently, further tools for this task have
become available, including the summarizeOverlap function in
the GenomicRanges Bioconductor package (Lawrence et al.,
2013) and the stand—alone tool featureCount (Liao et al., 2014),
which achieves fast runtimes because of being implemented in C.
In a recent benchmark, Fonseca et a]. (2014) compared
htseq—count with these other counting tools and judged the
accuracy of htseq—count favourably. Nevertheless, neither htseq—
count nor the other tools offer much ﬂexibility to deal with spe—
cial cases, which is why the HTSeq documentation (section
‘Counting reads’) discusses in detail how users can write their
own scripts for this important use case.

Interval queries are a recurring task in HTS analysis problems,
and several libraries now offer solutions for different program—
ming languages, including BEDtools (Quinlan and Hall, 2010;
Dale et al., 2011) and IRanges/GenomicRanges (Lawrence et al.,
2013). Typically, these methods take two lists of intervals and
report overlaps between them. HTSeq uses a different paradigm,
namely that one list of intervals is read in and stored in a
GenomicArrayOfSets object, and then the other intervals are
queried one by one, in a loop. This explicit looping can
be more intuitive; one example is the read counting problem

 

168

ﬁre'spzumol‘pmJXO'sopeuuowrorq/ﬁdnq

HTSeq

 

discussed above, where split reads, gapped alignments, ambigu—
ous mappings, etc. cause much need for treatment of special
cases that is addressed by branching statements within the
inner loop.

In conclusion, HTSeq offers a comprehensive solution to
facilitate a wide range of programming tasks in the context of
HTS data analysis.

Funding: SA. and W.H. acknowledge support from the
European Union via the 6th Framework Programme network
Chromatin Plasticity (Project no. 35733) and 7th Framework
Programme project Radiant (Project no. 305626).

Conﬂict of interest: none declared.

REFERENCES

Beazley,D.M. et a]. (1996) SWIG: an easy to use tool for integrating scripting lan—
guages with C and C ++. In: Proceedings of the 4111 USENIX Tel/Tk workx'ltop.
pp. 1297139.

Behnel,S. et a]. (2011) Cython: the best of both worlds. Comput. Sci. Eng, 13,
31739.

Bolger,A.M. et a]. (2014) Trimmomatic: a ﬂexible trimmer for illumina sequence
data. Bioinformatics, 30, 21142120.

Cock,P.J. et a]. (2009) Biopython: freely available Python tools for
computational molecular biology and bioinformatics. Bioinformatiex, 25,
142271423.

Dale,R.K. et a]. (2011) Pybedtools: a ﬂexible Python library for manipulating
genomic datasets and annotations. Biotnﬂrmatiex, 27, 342373424.

Fonseca,N.A. et a]. (2014) RNA—seq gene proﬁling 7a systematic empirical compar—
ison. PLoS ONE, 9, e107026.

Gentleman,R.C. et a]. (2004) Bioconductor: open software development for
computational biology and bioinformatics. Genome Biol., 5, R80.

Josuttis,N.M. (1999) The C ++ Standard Library. Addison—Wesley, Boston.

Lawrenoe,M. et a]. (2013) Software for computing and annotating genomic ranges.
PLoS Comput. Biol., 9, e1003118.

Liao,Y. et a]. (2014) featurecounts: an efﬁcient general purpose program for
assigning sequence reads to genomic features. Bioiiy’ormatiex, 30, 9237930.
Love,M.I. et a]. (2014) Moderated estimation of fold change and dispersion

for RNA—Seq data with DESeq2. bioRYiv, doi:10.1101/002832.

Quinlan,A.R. and Hall,I.M. (2010) Bedtools: a ﬂexible suite of utilities for compar—
ing genomic features. Bioiiy’ormatiex, 26, 8414542.

Robinson,M.D. et a]. (2010) edgeR: a Bioconductor package for differential
expression analysis of digital gene expression data. Bioiiy’ormatiex, 26,
1397140.

van der Walt,S. et a]. (2011) The NumPy array: a structure for efﬁcient numerical
computation. Comput. Sci. Eng, 13, 2230.

 

169

ﬁre'spzumol‘pmJXO'sopeuuowrorq/ﬁdnq

