Bioinformatics, 32(7), 2016, 1009—1015
doi: 10.1093/bioinformatics/btv688
Advance Access Publication Date: 20 November 2015

Original Paper

 

 

Genome analysis

HYBRIDSPADES: an algorithm for hybrid assembly
of short and long reads

Dmitry Antipov1'*, Anton Korobeynikovm, Jeffrey S. McLean4 and
Pavel A. Pevzner1'3

1Center for Algorithmic Biotechnology, Institute for Translational Biomedicine, 2Department of Statistical
Modelling, St. Petersburg State University, St. Petersburg, Russia, 3Department of Computer Science and
Engineering, University of California, San Diego, USA and 4Department of Periodontics, University of Washington,
Seattle, WA 98195, USA

*To whom correspondence should be addressed.
Associate Editor: lnanc Birol

Received on August 20, 2015; revised on October 27, 2015; accepted on November 13, 2015

Abstract

Motivation: Recent advances in single molecule real—time (SMRT) and nanopore sequencing tech—
nologies have enabled high—quality assemblies from long and inaccurate reads. However, these
approaches require high coverage by long reads and remain expensive. On the other hand, the in—
expensive short reads technologies produce accurate but fragmented assemblies. Thus, a hybrid
approach that assembles long reads (with low coverage) and short reads has a potential to gener—
ate high—quality assemblies at reduced cost.

Results: We describe HYBRIDSPADES algorithm for assembling short and long reads and benchmark
it on a variety of bacterial assembly projects. Our results demonstrate that HYBRIDSPADES generates
accurate assemblies (even in projects with relatively low coverage by long reads) thus reducing the
overall cost of genome sequencing. We further present the first complete assembly of a genome
from single cells using SMRT reads.

Availability and implementation: HYBRIDSPADES is implemented in C++ as a part of SPAdes genome
assembler and is publicly available at http://bioinf.spbau.ru/en/spades

Contact: d.antipov@spbu.ru

Supplementary information: supplementary data are available at Bioinformatics online.

 

1 Introduction proved to be useful in generating high—quality assemblies at a rela—
tively low cost (Deshpande et (11., 2013; Koren et (11., 2012; Ribeiro
et (11., 2012). In some complex applications (e.g. metagenomics and
single cell genomics), the hybrid approaches may represent an at—
tractive alternative to de novo assembly for long reads.

We describe HYBRIDSPADES—a hybrid assembly approach that
benefits from synergy between accurate short and error—prone long
reads. HYBRIDSPADES uses the same algorithms for both Pacific
Biosciences reads (about z 14% error rate) and Oxford Nanopore

While de novo sequencing from long and inaccurate SMRT reads re—
sults in accurate assemblies (Berlin at 111., 2015; Chin et (11., 2013),
these projects require high coverage of a genome by reads and thus
remain expensive. Moreover, for Oxford Nanopore technology
(with even higher error rates than in SMRT reads), accurate de novo
assemblies remain challenging even in high coverage sequencing pro—
jects (Goodwin et (11., 2015; Loman et (11., 2015). For example, the

highest reported aeeuraey 0f assemblies from OXford Nanopore reads (an even higher error rate), e.g. recently, HYBRIDSPADES was
reads (99.5%) is signiﬁcantly below the acceptable standards for ﬁn‘ applied to studies of bacterial plankton using assembly of Illumina
ished genomes. and Pacific Biosciences reads (Labonte et (11., 2015) and for analyz—

On the other hand, recently developed hybrid approaches for ing antibiotics resistance using assembly of Illumina and Oxford
assembling long (and inaccurate) and short (and accurate) reads Nanopore reads (Ashton et al.,2015).

©The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 1009

9103 ‘Og JSanV uo salaﬁuv soc] ‘BtHJOJtIBQ JO AJtsraAtuf] 112 /310'slcu1n0[p103x0"sotwurJOJutotq/ﬁduq 11101} popcolumoq

1010

D.Antipov et aI.

 

We benchmark HYBRIDSPADES against other hybrid assembly tools
(Deshpande et al., 2013; Koren et al., 2012) and demonstrate that it en—
ables accurate assemblies even in the case when the number of long
reads is relatively small. We further show that HYBRIDSPADES works well
even in the difficult case of single cell genome assembly resulting in the
complete circular chromosome assembly of the elusive Candidate
Phylum TM6 (McLean et al., 2013) that remains uncultivated.

2 Approach

While the de Bruijn graph approach currently dominates the short
reads sequencing projects, its applications to assembling long reads
faces various challenges. Indeed, high error rate in long reads makes it
difficult to construct the de Bruijn graph from long reads for any rea—
sonable choice of the k—mer size. As a result, the existing de novo long
read assemblers use the overlap—layout—consensus approach instead of
the de Bruijn graph approach (Berlin et al., 2015; Chin et al., 2013).

Thus, one has to choose between the de Bruijn graph and the
overlap—layout—consensus approaches while assembling short and
long reads. SPADES constructs the de Bruijn graph from short reads
and transforms it into an assembly graph (Bankevich et al., 2012;
Nurk et al., 2013). The assembly graph is defined as the condensed
and simplified de Bruijn graph (Pevzner et al., 2001) of k—mers in
reads after removal of bulges, tips and chimeric edges. After SPADES
constructs the assembly graph, HYBRIDSPADES uses long reads for gap
closure and repeat resolution in this graph.

EXSPANDER (Prjibelski et al., 2014; Vasilinetc et al., 2015) is a
module of SPADES that utilizes various sources of data (e.g. multiple
paired—end or mate—pair libraries) for resolving repeats and closing
gaps in assembly. EXSPANDER is a modular and easily extendable al—
gorithm based on the path extension framework (Boisvert et al.,
2010; Bresler et al., 2012; Zhu et al., 2014). Given a path in the as—
sembly graph, ExSPANDER iteratively attempts to grow it by choosing
one of its extension edges (all the edges that start at the terminal ver—
tex of this path). The choice of the extension edge is controlled by the
EXSPANDER decision rule (Prjibelski et al., 2014) that evaluates how
well this extension edge is supported by data (e.g. paired reads).
Thus, in order to incorporate the repeat resolution by long reads in
the ExSPANDER framework, one has to represent each long read as a
read-path, the path in the assembly graph that spells out the error—
free version of the long read. HYBRIDSPADES uses a new decision rule
in ExSPANDER that is based on the analysis of these read—paths.

In addition to resolving repeats in the assembly graph constructed
from short reads, long reads can also contribute to closing the cover—
age gaps in this graph. In the case when a coverage gap is spanned by
multiple long reads, one can fill in the gap by constructing the con—
sensus of long reads within the gap’s span (Chin et al., 2013).

Overall, HYBRIDSPADES includes the following steps:

1. Constructing the assembly graph from short reads using SPAdes;

2. Mapping long reads to the assembly graph and generating read—
paths;

3. Closing gaps in the assembly graph using the consensus of long
reads that span the gaps;

4. Resolving repeats in the assembly graph by incorporating long
read—paths into the decision rule of EXSPANDER.

3 Methods

3.1 Mapping long reads to the assembly graph
Given a set of short reads SHORTREADS, DB k(ShortReads, k) is the de
Bruijn graph constructed on all k—mers from this set. SPAdes uses

various graph simplification procedures (Bankevich et al., 2012;
Nurk et al., 2013) to transform the de Bruijn graph DBk(
ShortReads, [2) into the assembly graph DB7a : DB7a (ShortReads, k).
In this section we describe an algorithm for analyzing how each long
read Read traverses the graph DB7a resulting in a read—path
Path(Read).

Similarly to BLASR tool for SMRT reads alignment (Chaisson
and Tesler, 2012), HYBRIDSPADES selects a seed length t (the default
value t : 13) and maps t—mers in long reads to edges in the assembly
graphs that contain these t—mers. This information is used to find
out how each long read traverses DB2. To answer this question, we
first find out how a long read traverses edges in the assembly graph.

3.1.1 Mapping t-mers from reads to the assembly graph
HYBRIDSPADES transforms each long read into a set of t—mers and
finds positions of these t—mers on the edges of the assembly graph.
Note that t—mers starting at the first positions or ending at the last
positions of an edge map to a vertex in the assembly graph. Thus,
since such t—mers may be assigned to multiple edges incident to these
vertices, we exclude them from further consideration.

Given a t—mer shared by a read and an edge in the assembly graph,
we define its t-mer mapping as a triple (e, i, j) where e is an edge in
the assembly graph where the t—mer is mapped, and i and j are the
positions of the t—mer on this edge and in the read, respectively.

Since there are many spurious t—mer mappings, the fact that a t—
mer in a read Read maps to an edge in the assembly graph does not
necessarily mean that the read—path Path(Read) traverses this edge.
However, our analysis revealed that for nearly all reads, if more
than MinSeedNumher t—mers in a read map to an edge in the assem—
bly graph then the read—path traverses this edge (the default value
MinSeedNumher : 8). We therefore say that an edge in the assembly
graph is supported by a read if at least MinSeedNumher t—mers in
this read map to this edge.

3.1.2 Mapping long reads to edges of the assembly graph

Consider mappings (e1,i1,/'1) and (e2,i2,/'2) of two t—mers from a
given read. Define dread : ([2 — [1) and dgmph as the distances be—
tween these t—mers in the read and in the assembly graph, respect—
ively. dgmph is defined as follows: if the mappings share the same
edge and i1 < i2, the distance is i2 — i1, otherwise it is the length of
the shortest path in the assembly graph from the position i1 on edge
e1 to position i2 on edge e2.

A mapping (e1,i1,/'1) is a predecessor of mapping (e2, i2,/'2) if

' /1 < i2;

' c1 3 dread/dgmph, i.e. the distance along the read is not too small
as compared to the distance in the assembly graph;

' dread /dg,aph 3 c; if these t—mers map to the same edge in the assem—
bly graph, i.e. the distance along the read is not too large as com—
pared to the distance along a single edge in the assembly graph.
This condition is not enforced if two t—mers map to different edges
in the assembly graph since the read—path between these edges is
not necessarily the shortest path in the assembly graph;

' both dread and dgmph are smaller than c3.

The default values of parameters c1, c2 and c3 are 0.7, 1.3 and 500,
respectively.

We further construct a directed graph Graph(DB*,Read) using
the set of all t—mer mappings from the read Read as the vertex—set.
We connect vertices (t—mer mappings) in this graph by a directed
edge if the first one is a predecessor of the second. Since the resulting
graph is acyclic (every edge connects a mapping with a smaller read

9103 ‘Og JSanV uo salaﬁuv soc] ‘BtHJOJtIBQ JO AJtsraAtuf] 112 /310'sleu1n0[p103x0"sotwurJOJutotq/ﬁduq 11101} papeolumoq

HYBRIDSPADES

1011

 

coordinate to a vertex with a larger read coordinate), we can find a
longest path in this graph using a fast dynamic programming
algorithm.

Next, we determine how the found path through t—mer mappings
in the graph Graph(DB" , Read) traverses long edges of the assembly
graph. Since there are many spurious t—mer mappings, we limit at—
tention to the sequence of edges EdgeSequence(Read) in this
path that are supported by the given read Read. Note that
EdgeSequence(Read) may have some missing edges as compared to
the correct read—path Path(Read). Our goal now is to reconstruct
these missing edges that often aggregate into complex subgraphs in
the assembly graph.

3.1.3 Mapping long reads to complex subgraphs

of the assembly graph

Consider two consecutive edges in the sequence
EdgeSequence(Read) that are not consecutive in the assembly graph.
Our goal is to figure out how the correct read—path Path(Read) tra—
verses the assembly graph between these edges.

Figure 1 depicts two consecutive edges from EdgeSequence(Read)
(shown in red) that are separated by a complex subgraph in the assem—
bly graph. We need to determine which of the alternative paths be—
tween these edges in the assembly graph in Figure 1 are traversed by
Path(Read).

Given a path Path in a directed graph with edges labeled by char—
acters from a given alphabet, we define String(Path) as the concaten—
ation of labels of the edges from Path. We define the edit distance
d(String1,String2) between strings String1 and String as the min—
imum total cost of substitutions and indels needed to transform one
string into another (we assume that every substitution has cost )1 and
every indel has cost a). Our goal is to solve the following problem:

Graph Alignment Problem: Find a path between two given vertices
of the labeled directed graph that spells out the string with

minimal edit distance to the given string (among all possible paths
between these vertices).

Input: A string String and a labeled directed graph Graph with verti—
ces source and sink.

Output: A path Path in Graph minimizing d (String, String(Path))
over all possible paths in Graph from source to sink.

A brute—force solution of this problem (in the context of hybrid
assembly) is to enumerate all possible paths between two long edges
(within a certain range of lengths) and to find a path with the min—
imum edit distance to the long read. While this approach works for
bacterial genomes and is used in the current HYBRIDSPADES imple—
mentation, the number of paths may be exponential in the number
of vertices of the assembly graph. Below we describe a polynomial
algorithm for solving the Graph Alignment Problem.

Given a labeled directed graph Graph and a string String, we de—
fine a graph Graph(String) with the vertex—set corresponding to the
pairs (v,i) where v is a vertex in Graph and i E [0, (Stringlj. In order
to define the edge—set of Graph(String), we specify the incoming
edges to the vertex (v, i) as follows:

' edge (to, i) —> (v, i) of length a for each edge (to, v) in Graph;

' edge (u, i — 1) —> (v, i) of length a for each vertex v in Graph;

' edge (v,i — 1) —> (uni) for each edge (v, w) in Graph. The length
of this edge is deﬁned as zero if the label of the edge (v, w) in
Graph is equal to the ith symbol of String, and )1 otherwise.

It is easy to see that each series of edit operations with total cost
score between String and a string spelled by a path from source
to sink in Graph corresponds to a path of length score between
(source, 0) and (sink, (Stringl) in Graph(String).

Therefore, in order to solve the Graph Alignment Problem, we
need to find a shortest path between (source, 0) and (sink, (Stringl)
in Graph(String). Since this graph may have directed cycles, we use
the Dijkstra algorithm (Cormen et al., 2001) with the worst case

’t

i

#’

 

 

 

 

'i

i.
\

Fig. 1. Three pairs of long edges in the assembly graph (corresponding to unique regions in the genome and shown as colored edges) separated by short edges
that represent repeats in the genome (shown in black). The genome path traverses edges of the same color in the consecutive fashion. Two dotted paths repre-
sent two different options for a long read (with fixed length and alignment to long edges) to traverse this repetitive region. The goal is to figure which of these dot-

ted paths is correct

9103 ‘Og JSanV uo salaﬁuv 50'] ‘BtHJOJtIBQ JO AJtsraAtuf] 112 /310'S[BIIJnOprOJXO'SOIJBLUJOJIIIOICI”Zduq 11101} papeolumoq

1012

D.Antipov et aI.

 

running time O((E’( + (V’(log(V’(), where V’ and E’ are the vertex—
set and edge—sets of the graph Graph(String), respectively.

In the case of the hybrid assembly, since there are at most 4
outgoing edges for each vertex in the assembly graph, there are at
most 4 + 1 +4 : 9 outgoing edges for each vertex in the graph
Graph(String). Thus, since the total number of edges in
Graph(String) is O((V( - (String(), the running time of the algorithm
is O((V( - (String( -log((V( - (String()), where V is the vertex—set of
the assembly graph.

In the context of a typical assembly graph, (V( is much larger
than (String(. Also, for the majority of reads, there exists a path of
length approximately (String( between source and sink in the assem—
bly graph. Therefore, we can ignore all the vertices of DB7a that are
farther than (String( from both source and sink while searching for a
path with the minimum edit distance.

3.2 Closing coverage gaps in the assembly graph

Although the coverage by short reads is rather uniform in most as—
sembly projects, there are sometimes significant drops in k-mer
coverage (Bankevich et al., 2012) and even regions where the k—mer
coverage drops to zero. However, these drops in the k—mer coverage
rarely affect repetitive edges in the assembly graph since it is unlikely
that they occur in all copies of a repeat. Below we focus on gaps in
the k—mer coverage that occur within a unique (non—repetitive) re—
gion of a genome corresponding a single edge in the assembly graph.

A coverage gap breaks this edge into two edges that we refer to
as a sink edge (ending in a vertex without outgoing edges) and a
source edge (starting in a vertex without incoming edges). If a long
read maps to both a sink and a source edge, then this read can po—
tentially close a gap in the assembly graph. However, a single error—
prone long read spanning the gap does not allow one to accurately
close a gap, i.e. to reconstruct the nucleotide sequence of the gap.
We thus collect the set of all long reads spanning the same pair of
sink and source edges (forming the set of reads SpanningReads) and
close the coverage gap using the consensus sequence of all these
reads.

For each read from SpanningReads, we align this read against
the sink edge (ending at position p of the read) and the source edge
(starting at position q of the read). The segment of the read from
position p+ 1 to q — 1 represents an error—prone sequence of the
gap. HYBRIDSPADES fills in the gap by solving the Multiple String
Consensus Problem (Sim and Park, 2003) for all such segments
derived from SpanningReads. To solve this problem, we apply the
Partial Order Graph approach (Lee et al., 2002) and use its
ConsensusCore library implementation from Pacific Biosciences that
proved to work well for SMRT reads (Chin et al., 2013).

3.3 Repeat resolution in the assembly graph

The read—against—graph alignment algorithm described above allows
one to map each long read to a read—path in the assembly graph.
During the repeat resolution stage of HYBRIDSPADES, we limit atten—
tion to paths traversing at least two long edges in the assembly
graph. Our goal is to transform this set of paths into contigs that
represent the genome assembly. Below we explain how to achieve
this goal using the EXSPANDER repeat resolution framework
(Prjibelski et al., 2014; Vasilinetc et al., 2015). EXSPANDER itera—
tively constructs a set of paths Paths that represent contiguous seg—
ments of the genome. In the beginning, Paths is formed by paths
consisting of single long edges in the assembly graph. ExSPANDER at—
tempts to iteratively extend each path in Paths using its decision rule
(see Section 2). If multiple extension edges pass the decision rule for

a given path (which usually implies that this path ends in a difficult—
to—resolve repeat), EXSPANDER stops the extension process for this
path.

Given a path P and its extension edge e, EXSPANDER defines the
scoring function scorep(e) and bases its decision rule on analyzing
all values scorep(e) for all extension edges. Below we describe how
HYBRIDSPADES defines scorep(e).

Read—paths P’ and P” overlap if a suffix of P’ (i.e. the path
formed by the last i edges of P’) coincides with a prefix of P” (i.e. the
path formed by the first i edges of P’/). We define overlap(P’, P”) as
the longest suffix of P’ that coincides with a prefix of P” .

A read—path is called trivial if it consists of a single edge and non-
trivial otherwise. Since trivial read—paths do not contribute to the re—
peat resolution, we exclude them from further consideration. Note
that there are typically multiple reads with the same read—path, at
least in projects with high coverage by SMRT reads. We define
multiplicity of a read—path as the number of long reads resulting in
this read—path and classify a read—path as reliable if its multiplicity
exceeds 1 (SMRT datasets have many chimeric reads that typically
have multiplicity 1).

Let ReadPaths be the set of all non—trivial reliable read—paths and
ReadPaths(e) be its subset formed by all read—paths containing an
edge e. An edge e in DB7a is called non-repetitive if

' all pairs of read—paths in ReadPaths(e) overlap and their overlap
contains e.
' edge e appears at most once in each read—path from ReadPaths;

For the datasets with relatively even coverage by Illumina reads
(e.g. reads generated from cultured cells but not single cells ampli—
fied with MDA) we impose an additional condition—an edge is
called non—repetitive if it is sufficiently long (exceeds 500 bp in the
default setting) and its coverage does not significantly exceeds the
median coverage of the entire dataset (does not exceed the median
coverage by more than 20% in the default setting).

A read—path ReadPath follows a path P in the assembly graph
if there exists a path P : e1 . . . e,- . . . e,- . . . en such that its prefix e1
. . . e,- . . . e,- coincides with P, its suffix e,- . . . e,- . . . en coincides with
ReadPath, and at least one of edges from e,- . . . e,- is non—repetitive.

Given a path P and a set of read—paths ReadPaths, we define
ReadPathsp as the set of all read—paths from ReadPaths that follow
P. Given an extension edge e of a path P, we define scorep (e) as the
total multiplicity of read—paths in the set ReadPathspege, where P QB e
is the path P extended by the edge e.

If a path P has an extension edge e whose score dominates scores
of all other extension edges (i.e. exceeds them by a factor of at least
c), HYBRIDSPADES extends P by e (the default value c : 2). Otherwise,
the extension procedure stops. If the highest scoring extension edge
does not dominate the scores of all other extension edges,
exSPAnder applies the standard extension rules based on read—pairs
(Prjibelski et al., 2014; Vasilinetc et al., 2015).

4 Results

4.1 Datasets

We analyzed datasets combining short and long reads from E.coli
str. K12 (datasets ECOLII 00, ECOLIZOO and ECOLI—NANO),
M.ruber (dataset MRUBER), Streptomyces sp. PAMCZ6508 (data—
set STREPTO) and candidate division TM6 bacterium TM6SC1
(dataset TM6). The reads in the latter dataset were generated from
single cells amplified with the Multiple Displacement Amplification
(MDA) technology (Lasken, 2007). Prior to this study, the genome

9103 ‘Og JSanV uo salaﬁuv 50'] ‘BtHJOJtIBQ JO AJtsraAtuf] 112 /310'S[BHJnOprOJXO'SOIJBLUJOJIIIOICI”Zduq 11101} papeolumoq

HYBRIDSPADES

1013

 

of TM6SC1 was only partially assembled (see McLean et al., 2013
for details).

ECOLIZOO dataset contains SMRT reads with 200 X coverage
and P6/C4 enzyme/chemistry (average read length 5280 bp).
ECOLII 00 dataset contains SMRT reads with 100 X coverage and
older P4/C2 enzyme/chemistry (average read length 10 598 bp).
ECOLI—NANO dataset contains Oxford Nanopore reads (average
read length 6060 bp). All three E.coli str. K12 datasets contain
Illumina reads of length 100 bp, mean insert length 215 bp and
coverage 230 X obtained with Illumina Genome Analyzer IIx.

Mapping of Illumina reads to E.coli str. K12 genome revealed
that the strain used for generating these datasets differs from the ref—
erence sequence of E.coli str. K12 (three insertions of mobile elem—
ents about 1 kbp in length). These differences result in six
breakpoints that are reported as six assembly errors by the assembly
evaluation tool QUAST (Gurevich et al., 2013). We thus ignored
these six (pseudo) errors while benchmarking various assemblers.

MRUBER dataset contains SMRT reads with 120 X coverage
(average read length 2430 bp). Illumina reads for this dataset were
generated using Illumina Nextera Mate Pair technology (there were
no paired—end reads in this dataset) with read length 150 bp, mean
insert length 3500 bp and low 20 X coverage.

STREPTO dataset contains SMRT reads with 25 X coverage
(average read length 1410 bp). Illumina reads were generated with
Illumina HiSeq 2000 with read length 150 bp, mean insert length
280 bp and coverage 95><. Streptomyces sp. PAMC26508 genome
has high (71%) GC content.

TM6 dataset contains both SMRT reads (45 X coverage) and
Illumina reads (265 X coverage) generated from MDA—amplified sin—
gle cells. The Illumina reads were generated with Genome Analyzer
IIx (read length 100 bp, mean insert length 270 bp). Note that
MDA—based single cell approaches result in highly uneven genome
coverage by reads (Bankevich et al., 2012).

The links to all the datasets and reference genomes are available
in supplementary materials.

4.2 Software tools

We benchmarked HYBRIDSPADES (as a part of SPADES 3.6 release),
Cerulean (Deshpande et al., 2013) and PBcR (Koren et al., 2012)
(version wgs—8.3rc1). In the hybrid mode (that we refer to as
hybridPBcR), PBcR uses short Illumina reads to error—correct the
long (SMRT or Nanopore) reads. In the self-correction mode (that
we refer to as selfPBcR) PBcR only uses long reads for assembly. We
used the QUAST assembly evaluation tool (Gurevich et al., 2013)
for benchmarking. While QUAST reports many assembly metrics,
the benchmarking tables below are limited to NG50, NG75, LG50,
the length of the longest contig, and the number of misassemblies
(MA), where NG50 is the length for which the collection of all con—
tigs of that length or longer covers at least half of the reference gen—
ome, NG75 is defined similarly to NG50 with 75% of reference
genome instead of 50%. LG50 is the number of contigs longer or
equal than NG50.

Although AllPaths—LG (Ribeiro et al., 2012) has a hybrid mode
for assembling short and long reads, we did not have an opportunity
to benchmark it since none of the datasets described above satisfy
the strict constraints on the insert sizes imposed by AllPaths—LG.

The field of hybrid assembly has been rapidly developing in the
last year when the Oxford Nanopore assembly pipeline Nanocorrect
(Loman et al., 2015), hybrid Nanopore 86 Illumina assembly pipe—
line NanoCorr (Goodwin et al., 2015) and hybrid scaffolder LINKS
(Warren et al., 2015) were added to the arsenal of tools for

assembling Oxford Nanopore reads. However, Nanocorrect and
NanoCorr focused on Oxford Nanopore reads rather than Pacific
Biosciences reads. We and others (Ashton et al., 2015; Liao et al.,
2015; Utturkar et al., 2014) demonstrated that HYBRIDSPADES works
well for hybrid assembly with both Pacific Biosciences and Oxford
Nanopore reads.

4.3 Benchmarking

HYBRIDSPADES and selfPBcR assembled both ECOLII 00 and
ECOLIZOO datasets in a single contig (Table 1). As expected, both
HYBRIDSPADES and selfPBcR resulted in six (pseudo) assembly errors
caused by the known differences between the analyzed and the refer—
ence strains (three insertions of mobile elements). selfPBcR produced
two additional (real) misassemblies and HYBRIDSPADES produced
one. Cerulean and hybridPBcR generated more fragmented assembly
and, in case of Cerulean, more misassemblies for ECOLII 00 data—
set. For ECOLIZOO dataset, both Cerulean and hybridPBcR gener—
ated inferior assemblies.

In addition to hybrid assembly of Illumina and SMRT reads,
HYBRIDSPADES also assembled ECOLI-NANO dataset into a single
contig. All other tested assemblers failed to assemble this dataset.

We have also investigated how the performance of HYBRIDSPADES
and PBcR deteriorates when the coverage by long reads is reduced.
To perform this analysis, we retained a fixed fraction of randomly
chosen SMRT reads resulting in coverage varying from 200>< to
6.25><. As Table 2 illustrates, even with low 12.5 X coverage by
SMRT reads, HYBRIDSPADES generates a high—quality assembly (bet—
ter than PBcR with 50 X coverage). The quality of PBcR assemblies
deteriorates when the coverage falls below 50>< .

selfPBcR assembled MR UBER dataset into a single contig with a
single misassembly, while HYBRIDSPADES assembled this dataset into
three error—free contigs with zero misassemblies (Table 3).
HYBRIDSPADES failed to assemble this dataset into a single contig be—
cause long reads in this dataset do not span over a long 7Kbp re—
peat. hybridPBCR produced an assembly with quite similar stats.
Cerulean produced lower quality assembly, HYBRIDSPADES generated
a high—quality assembly of STREPTO dataset with N G5 0 z
883 Kbp (2 misassemblies), while Cerulean generated an assembly

Table 1. Benchmarking of HYBRIDSPADES, PBcR and Cerulean on
E.coli datasets

 

LG50 NG50 NG75 longest MA

 

ECOLIZOO

HYBRIDSPADES

(Illumina + SMRT) 1 4652737 4652737 4652737 7
hybridPBcR — — — 34501 1
selfPBcR 1 4680888 4680888 4680888 8
Cerulean 16 108914 61790 225438 87
ECOLII 00

HYBRIDSPADES

(Illumina + SMRT) 1 4652737 4652737 4652737 7
hybridPBcR 14 109938 38778 311375 4
selfPBcR 1 4661789 4661789 4661789 8
Cerulean 2 1238378 1215680 1258795 10
ECOLI-NANO

HYBRIDSPADES

(Illumina+Nanopore) 1 4477336 4477336 4477336 7

 

For each parameter we boldfaced the best results. Longest contig, NG50
and NG75 were compared with reference (4639675 bp). We did not run vari—
ous genome polishing tools like Quiver (Chin et al., 2013) since our bench-
marking focused on assembly errors rather than basecalling errors.

9103 05 JSanV uo sopﬁuv soc] ‘BIIIJOJIIBD JO AJtsraAtuf] 112 /310'S[BHJnOprOJXO'SOIJ’BLUJOJIIIOICI”Zduq 11101} papeo1umoq

1014

D.Antipov et aI.

 

Table 2. Benchmarking of HYBRIDSPADES and selfPBcR on down-
sampled ECOLIZOO datasets with reduced coverage by long reads

Table 4. Benchmarking of HYBRIDSPADES, PBcR and Cerulean on
Streptomyces dataset

 

 

 

 

 

 

 

 

 

 

 

ECOLIZOO STREPTO
LG50 NG50 NG75 longest MA LG50 NG50 NG75 longest MA
HYBRIDSPADES 200x 1 4652737 4652737 4652737 7 HYBRIDSPADES 4 903095 679085 1366650 1
selfPBcR 200x 1 4680888 4680888 4680888 8 Cerulean 4 645600 388134 1240002 10
HYBRIDSPADES 100x 1 4652556 4652556 4652556 7 hybridPBcR 12 225991 124032 452318 1
selfPBcR 100x 1 4677843 4677843 4677843 8
HYBRIDSPADES 50>< 1 4652375 4652375 4652375 7
selfPBcR 50>< 3 758477 494886 876582 9
HYBRIDSPADES 25X 1 2643623 1817256 2643623 7 Table 5. Benchmarking of HYBRIDSPADES, PBcR and Cerulean on
selfPBcR 25x — — — 82951 6 TM6 dataset
HYBRIDSPADES 12.5 x TM6
(Illumina + PacBio) 1 3398297 746845 3398297 9
selfPBcR 125x - - - 15 884 0 LG50 NG50 NG75 longest MA
HYBRIDSPADES 6.25>< 5 356505 210465 692018 9
selfPBcR 6,25X _ _ _ _ HYBRIDSPADES 1 1088795 1088795 1088795 —
Cerulean 1 773677 221583 773677 1
The coverage was downsampled from 200x to 6.25><. NG50, LG50 and selfPBcR 7 41009 18600 146018 26

NG75 are not deﬁned for PBcR assembly with coverage 25 X and lower be—
cause the total assembly length is less than half of the genome length. For
coverage 6.25 X, PBcR failed to generate an assembly.

Table 3. Benchmarking of HYBRIDSPADES, PBcR and Cerulean on
M. ruber dataset

 

 

 

MR UBER

LG50 NG50 NG75 longest MA
HYBRIDSPADES 1 1709645 1387667 1709645 0
Cerulean 3 305771 262734 11 17272 4
hybridPBcR 1 1753481 766814 1753481 0
selfPBcR 1 3100304 3100304 3100304 1

 

with NG50 z 645 Kbp and 10 misassemblies (Table 4). hybridPBcR
failed on this dataset while selfPBcR produced a low—quality assem—
bly due to the low coverage by SMRT reads.

In contrast to the previous assemblies of SMRT reads in single
cell genomics (Labonte et al., 2015; Swan et al., 2014) that came
short of closing the assemblies, application of HYBRIDSPADES to TM6
dataset resulted in a single circular contig of length 1089 Kbp (which
contains all previously sequenced seven long contigs with total
length 1075 Kbp (McLean et al., 2013)). To the best of our know—
ledge, it is the first assembly of SMRT reads in single cell genomics
that resulted in a complete genome.

Since prior to this study, TM6 genome was incomplete, we used
the genome assembled by HYBRIDSPADES to evaluate performance of
other assemblers on this dataset.

Cerulean generated an assembly with the largest contig of length
774 Kbp and 1 misassembly (Table 5). hybridPBCR failed on this
dataset while selfPBcR produced a low—quality assembly.

Our benchmarking demonstrated that HYBRIDSPADES improves
on the state—of—the—art hybrid assemblers on all datasets we have
analyzed (on two of these datasets with a high SMRT read coverage,
selfPBcR showed similar results).

5 Conclusions

Early tools for hybrid assembly combined Illumina and Sanger reads
or Illumina and 454 reads (Boisvert et al., 2010; Chevreux et al.,
1999; Zimin et al., 2013). However, hybrid assembly of Illumina

 

The initial TM6 assembly by SPAdes had total size exceeding 4Mb that
greatly exceeds the genome length reported in McLean, 2013 (McLean et al.,
2013). This is caused by contaminants since TM6 dataset represents a mini-
metagenome. See (McLean et al., 2013) for details.

and SMRT reads presents new algorithmic challenges since SMRT
reads have higher error rates than Sanger reads or 45 4 reads.

Our benchmarking demonstrated that HYBRIDSPADES assembles
short accurate and long error—prone reads into long and accurate
contigs. The resulting low—cost high—quality assemblies are import—
ant for accurate genome annotations and comparative genomics.
Moreover, HYBRIDSPADES opens a possibility to complete genomes
assembled from single cells. Although 10005 of bacterial genomes
have been assembled from single cells in the last 3 years using speci—
alized single cell assemblers SPAdes (Bankevich et al., 2012) and
IDBA—UD (Peng et al., 2012), finishing genomes amplified from sin—
gle cells is often viewed as an impossible task (Lasken and McLean,
2014). Moreover, sequencing single cell genomes from SMRT reads
is likely to be excessively expensive due to highly non—uniform
coverage characteristic of the MDA—amplified datasets. Hybrid as—
sembly of short and long reads, on the other hand, turns complete
genome assembly from single cells into reality.

While the detailed analysis of the relative market costs and
trade—offs of various sequencing technologies remained beyond the
scope of this article, we anticipate that many future sequencing pro—
jects will use hybrid assembly of reads generated by various
technologies.

Acknowledgements

We thank Roger Lasken, Mark Novotny and Cheryl Heiner for their expertise
that helped to generate the SMRT reads for the MDA ampliﬁed TM6 genome.
We are grateful to Alla Lapidus, Kira Vyatkina and SPADES developing team
for many thoughtful discussions, suggestions and comments that improved
the article. We are also grateful to the anonymous referees whose comments
have beneﬁted the article greatly.

Funding

This work was supported by the Russian Science Foundation [grant 14—50-
00069].

Conﬂict of Interest: none declared.

9103 05 JSanV uo sopﬁuv soc} ‘BIIIJOJIIBD JO [(1151910qu 112 /310'S[BHJnOprOJXO'SOIJ’BLUJOJIIIOICI”Zduq 11101} papeo1umoq

HYBRIDSPADES

1015

 

References

Ashton,P.M. et al. (2015) MinION nanopore sequencing identiﬁes the pos—
ition and structure of a bacterial antibiotic resistance island. Nat.
Biotechnol., 33, 296—300.

Bankevich,A. et al. (2012) SPAdes: a new genome assembly algorithm and its
applications to single—cell sequencing. I. Comput. Biol., 19, 455—477.

Berlin,K. et al. (2015) Assembling large genomes with single—molecule
sequencing and locality-sensitive hashing. Nat. Biotechnol., 33, 623—630.

Boisvert,S. et al. (2010) Ray: Simultaneous assembly of reads from a mix of
high—throughput sequencing technologies. I. Comput. Biol., 17, 1519—15 33.

Bresler,M. et al. (2012) Telescoper: de novo assembly of highly repetitive re—
gions. Bioinformatics, 28, 311—317.

Chaisson,M.I. and Tesler,G. (2012) Mapping single molecule sequencing
reads using basic local alignment with successive reﬁnement (BLASR): appli—
cation and theory. BMC Bioinformatics, 13, 238.

Chevreux,B. et al. (1999) Genome sequence assembly using trace signals and
additional sequence information. In: German Conference on
Bioinformatics, pp. 45—5 6.

Chin,C.-S. et al. (2013) Nonhybrid, ﬁnished microbial genome assemblies
from long-read SMRT sequencing data. Nat. Methods, 10, 5 63—5 6 9.

Cormen,T.H. et al. (2001) Introduction to Algorithms. MIT Press,
Cambridge, MA.

Deshpande,V. et al. (2013) Cerulean: a hybrid assembly using high throughput
short and long reads. In: Algorithms in Bioinformatics. LNBI 8126
Springer, Berlin-Heidelberg, pp. 349—3 63.

Goodwin,S. et al. (2015) Oxford Nanopore sequencing and de novo assembly
of a eukaryotic genome. Bioinv, pp. 013490.

Gurevich,A. et al. (2013) QUAST: quality assessment tool for genome assem—
blies. Bioinformatics, 29, 1072—1075 .

Koren,S. et al. (2012) Hybrid error correction and de novo assembly of single—
molecule sequencing reads. Nat. Biotechnol., 30, 693—700.

Labonte,I.M. et al. (2015) Single—cell genomics—based analysis of virus—host
interactions in marine surface bacterioplankton. ISME I., 9, 2386—2399.

Lasken,R.S. (2007) Single—cell genomic sequencing using multiple displace—
ment ampliﬁcation. Curr. Opin. Microbiol, 10, 510—516.

Lasken,R.S. and McLean,I.S. (2014) Recent advances in genomic DNA sequenc—
ing of microbial species from single cells. Nat. Rev. Genet, 15, 5 77—584.

Lee,C. et al. (2002) Multiple sequence alignment using partial order graphs.
Bioinformatics, 18, 452—464.

Liao,Y.—C. et al. (2015) Completing bacterial genome assemblies: strategy and
performance comparisons. Sci. Rep., 5, 8747. doi: 10.1038/srep08747.

Loman,N.I. et al. (2015) A complete bacterial genome assembled de novo
using only nanopore sequencing data. Nat. Methods, 12, 733—735.

McLean,I.S. et al. (2013) Candidate phylum TM6 genome recovered from a
hospital sink bioﬁlm provides genomic insights into this uncultivated phy—
lum. Proc. Natl Acad. Sci., 110, E2390—E2399.

Nurk,S. et al. (2013) Assembling single—cell genomes and mini-metagenomes
from chimeric MDA products. I. Comput. Biol., 20, 1—24.

Peng,Y. et al. (2012) IDBA-UD: a de novo assembler for single—cell and meta—
genomic sequencing data with highly uneven depth. Bioinformatics, 28,
1420—1428.

Pevzner,P. et al. (2001) An Eulerian path approach to DNA fragment assem—
bly. Proc. Natl Acad. Sci. USA, 98, 9748—975 3.

Prjibelski,A.D. et al. (2014) ExSPAnder: a universal repeat resolver for DNA
fragment assembly. Bioinformatics, 30, i293—i301.

Ribeiro,F.I. et al. (2012) Finished bacterial genomes from shotgun sequence
data. Genome Res., 22, 2270—2277.

Sim,I.S. and Park,K. (2003) The consensus string problem for a metric is NP-
complete. I. Discret. Algorithms, 1, 111—117.

Swan,B.K. et al. (2014) Genomic and metabolic diversity of marine group i
thaumarchaeota in the mesopelagic of two subtropical gyres. PLoS One, 9,
e95380.

Utturkar,S.M. et al. (2014) Evaluation and validation of de move and hybrid
assembly techniques to derive high-quality genome sequences.
Bioinformatics, 30, 2709—2716.

Vasilinetc,I. et al. (2015) Assembling short reads from jumping libraries with
large insert sizes. Bioinformatics, btv337.

Warren,R.L. et al. (2015) LINKS: Scalable, alignment—free scaffolding of draft
genomes with long reads. GigaScience, 4, 1—1 1.

Zhu,X. et al. (2014) PERGA: a paired—end read guided de novo assembler for
extending contigs using SVM and look ahead approach. PLoS ONE, 9,
e1 1425 3.

Zimin,A.V. et al. (2013) The MaSuRCA genome assembler. Bioinformatics,
29, 2669—2677.

9103 05 JSanV uo sopﬁuv soc} ‘BIIIJOJIIBD JO [(1151910qu 112 IBJO'SIBHJnOprOJXO'SOIJBLUJOJIIIOIq/IZduq 11101} papeo1umoq

