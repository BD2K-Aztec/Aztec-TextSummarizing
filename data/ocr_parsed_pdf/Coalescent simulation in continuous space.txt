BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

J.Kelleher et al.

 

Algorithm S operates by mapping individuals in the sample to
the integers 1 g j g n and those ancestral to the sample to inte—
gers greater than n. The set S contains the lineages ancestral to
the sample at time t, and we proceed backwards in time
event—by—event. Because most events will not hit any lineages,
the majority of the time spent in the algorithm is looping quickly
around steps S2 and S3. Occasionally, a single lineage will be hit,
we execute step S4 and move the lineage to a new location. Very
rarely, an event hits more than one lineage, and C is the set of
lineages born from a single parent. Thus, in step S5 we set the
parent of each lineage in C to be 17 and the location of n to a
random point within the ball deﬁning the event. We then record
that lineage 17 entered the sample at time t by setting In to t.
Finally, we remove the children born in this event from the
sample (as we are no longer interested in them) and insert 17
into the sample (as we are interested in its further history).
This process continues until there is one individual in the
sample, and (n, ‘17) describes the full history of the sample.

3 MULTILOCUS ALGORITHM

The single locus model is extended to incorporate recombination
by letting each individual in the sample consist of multiple loci
and allowing for multiple parents in events, so that a given indi—
vidual may descend from different parents at different loci.
Speciﬁcally, we consider a model in which each individual has
m linearly arranged loci and there are 1) parents at each event.
(In sexually reproducing species, 1) = 2 in small—scale reproduc—
tion events. We must consider the possibility of more than two
parents in large—scale events, as several generations may elapse
before the local area is repopulated.) For each child in an event,
there is a probability [OK that loci Z and Z + 1 are inherited from
different parents. See Etheridge and Veber (2012) for more
details.

Simulating this multilocus coalescent follows the same pattern
as Algorithm S: we begin with a sample of n lineages and proceed
event—by—event until the ancestry of the sample is complete, and
we have a pair (71, T) describing the history at each locus. The
sample S is most conveniently represented as a set of (location,
ancestry) tuples (x, a1 . . . am). Each sequence a1 . . . am represents
the ancestry of a lineage such that at 75 0 if there is genetic ma—
terial ancestral to the sample present in this lineage at locus Z and
at = 0 otherwise (Hudson, 1983). Termination of the algorithm
is controlled by maintaining the invariant

K: 2 Z [@7150].

(x, a)eS lftifm

Thus K 2 nm initially, and the algorithm terminates when K = m,
indicating that all loci have coalesced.

Suppose that C is the set of lineages born in an event. We
must ﬁrst decide which children descend from which parent at
each locus. To do this, we ﬁrst set 6M <— (ZJ for 1 g k f v and
1 3 Z 3 m. Then, for each child lineage a1 . . . am e Cwe choose a
parent for the ﬁrst locus by setting k <— RU({1, . . . , v}). We then

iterate over each locus 1 3 Z 3 m, and if at 75 0 (that is, there is
ancestral material at this locus), we set 61,, g <— 61,, e U {at}.
Then, with probability pg, a recombination event occurs and
we choose a new parent for the next locus by setting
k <— RU({1, ...,v} \ {k}).

Having completed the task of deciding which children have
descended from which parents, we must generate the new paren—
tal ancestry sequences and update the genealogies and node
times. This is accomplished by examining the sets of descendants
6H for each parent k at locus Z and proceeding in the same
manner as algorithm S, updating 7T, 1' and n for each locus as
appropriate.

This algorithm is far from optimal and can be improved in
many ways to improve performance, particularly in special cases.
It does provide a useful starting point for these special cases,
however, and is easily adapted and analysed. A straightforward
implementation of the algorithm in Python is included as
Supplementary Material for reference.

4 IMPLEMENTATION

The multilocus coalescent algorithm described in the previous
section is implemented as a Python module, ercs. The implemen—
tation supports an arbitrary number of event classes, including
events from the Gaussian model (Barton et al., 2010b), and in—
corporates spatial indexing to improve performance over the
basic algorithm outlined here. The module is written primarily
in C in the interest of efﬁciency and is distributed freely under the
terms of the GNU General Public License.

Funding: N.H.B. is supported by European Research Council
grant 250152; A.M.E. is supported in part by EPSRC grant
EP/101361X/1 and J.K. is supported by EPSRC grant
EP/1013091/1.

Conﬂict of Interest: none declared.

REFERENCES

Barton,N.H. et al. (2010a) A new model for evolution in a spatial continuum.
Electron. J. Probal7., 15, 7.

Barton,N.H. et al. (2010b) A new model for extinction and recolonisation in two
dimensions: quantifying phylogeography. Evolution, 64, 270172715.

Barton,N.H. et a]. (2013) Modelling evolution in a spatial continuum. J. Stat.
Mes/1., 2013, P01002.

Etheridge,A.M. (2008) Drift, draft and structure: some mathematical models of
evolution. Banach Center Pub]., 80, 1217144.

Etheridge,A.M. and Veber,A. (2012) The spatial A—Fleming—Viot process on a large
torus: genealogies in the presence of recombination. Ann. App]. Probab., 22,
216572209.

Felsenstein,J. (1975) A pain in the torus: some difﬁculties with the model of isolation
by distance. Am. Nat., 109, 3597368.

Hudson,R.R. (1983) Properties of a neutral allele model with intragenic recombin—
ation. T/teor. Popul. Biol, 23, 1837201.

Knuth,D.E. (2011) Combinatorial algorithms. In: TIM Art of Computer
Programming, Vol. 4A, Addison Wesley, Upper Saddle River, New Jersey.

Malecot,G. (1948) Lex‘ mat/te'matiques de l'lte're'dite'. Masson et Cie, Paris, 1948.

Wright,S. (1943) Isolation by distance. Genetics, 28, 114438.

 

956

ﬁre'spzumofpmﬂo'sopeuuowrorq/ﬁdnq

