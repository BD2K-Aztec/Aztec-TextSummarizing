BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

KAnaIyze

 

place in two steps over two components. The split component writes
sorted subsets of data to disk, and the merge component accumulates
counts from each subset. Split and merge operations can be performed in
multiple steps, which allows counting to take place in a distributed
environment.

The split component reads k—mers into a memory array until it is full.
The array is sorted using J ava’s Arrays.sort() method, which implements
a dual—pivot quicksort algorithm. K—mers are counted by traversing the
sorted array. Each k—mer and its count are written to disk, and the loca—
tion of the output file is sent to the merge component. The memory array
is then filled with the next set of k—mers, and a new file of k—mer counts is
created. The process repeats until all k—mers have been written.

The merge component reads k—mers and their counts from each file
and sums the counts for each k—mer. To avoid loading entire files at once,
each file has a small buffer of k—mers. As the files are sorted by k—mer, this
module efficiently accumulates k—mer counts and writes a sorted output
file.

This modified external merge sort algorithm (Knuth, 1998) efficiently
counts all k—mers with limited memory and sorts k—mers as they are
processed.

3 SOFTWARE TEST RESULTS

We tested KAnalyze performance and accuracy on two public
datasets. We obtained human chromosome 1 (Chrl) from UCSC
and a randomly chosen dataset from The 1000 Genomes Project
Pilot Project 3 (gene region targeted), NA18580. The hg19 Chrl
sequence is a single fully assembled 249 Mb (megabase) sequence,
and NA18580 is a set of 1.5 million sequence reads totaling 453
Mb. See Supplementary Section 3.6 for links to these datasets.

We tested KAnalyze 0.9.3, Jellyfish 1.1.10 (Marcais and
Kingsford, 2011), DSK 1.5280 (Rizk et a1., 2013) and a Perl
pipeline we developed for verifying accuracy. These were the
latest versions available when testing began. We used Jellyfish
hash size 100000000 (108) because it yielded the best performance
results. Tests were run on a 12 core machine (2 x Intel Xeon
E5-2620) with 32 GB of RAM (DDR3-1600), RAID-6 over
SATA drives (3 GB/s, 72K RPM) and CentOS 6.4 (minimal
install).

Each pipeline was run in triplicate over both datasets. The run
time of each step of each pipeline was recorded with the Linux
utility time. The reported time is the average (mean) over all
three runs. See Supplementary Section 3 for individual run
times. Figure 1 shows the final results.

Memory usage for the NA18580 dataset was determined by
recording the maximum RSS (non-swapped physical memory
used) in 0.1 s interval with the Linux command ps. For pipelines
with multiple steps, we recorded the maximum memory usage of
all steps. Actual memory usage was 1.58 GB (KAnalyze count),
2.18 GB (Jellyfish), 0.03 GB (DSK) and 1.96 GB (Perl pipeline).
The memory test was done separately from the performance
tests.

To test scalability, we obtained HG01889 from the Human
Genome Project. This dataset contains 71.95 Gb over 988 million
reads. For Jellyfish, we uncompressed the files, which took
1.06 h. In three attempts, we could not get Jellyfish to complete
a run on this data in 24 h (see Supplementary Section 3.5). In one
attempt, we allowed Jellyfish to use 17 threads, which we deter-
mined to be optimal on NA18580. KAnalyze counted k-mers in
14.65h using 2 GB of memory and default settings in one run.

Runtime Performance

   

0
g l KAnalyze
l Jellyfish
- DSK 6994
I
0 Perl 6232
O
0
L0
5106
E
0.)
E o
‘2 O
C O
Z ‘3'
cc
0 2255
O
O
N
370 311
&_ £—

   

1000 Genomes NA18580 hth Chrl

Fig. 1. 31—mer performance with KAnalyze count, Jellyfish, DSK and a
Perl script implementation over two datasets, NA18580 (1000 Genomes)
and Chrl (hg19)

To see how KAnalyze scales in a high-performance setting, we
allowed it to use more memory, additional threads and we read
directly from the gzipped fastq files. In two tests, KAnalyze
counted a11 k-mers in an average of 3.35h with 26.01 GB of
memory.

For each test, we produced a tab delimited file of k-mers and
their counts sorted by k-mer. The KAnalyze sort module
(Section 2.3) produces this format. The Perl pipeline produces
this format using with Perl scripts with Linux utilities sort and
uniq. Jellyfish results were converted from their FASTA repre-
sentation to a tab-delimited file with a Perl script, and then
sorted with Linux sort. DSK produces an unsorted tab-delimited
file, which we sorted with Linux sort. The average time to con-
vert and sort results was 901s for Jellyfish and 507s for DSK.
This time is not shown in Figure 1.

The SHAl checksum on the sorted output files was recorded.
For each dataset, KAnalyze produced results consistent with
Jellyfish and the Perl pipeline. DSK k-mer counts did not
agree with the other methods (See Supplementary Section 3.4).
We obtained the same results running KAnalyze on A Windows
computer (Windows 7) and an Apple computer (OS 10.8.5).

4 CONCLUSION

KAnalyze offers an extensible API and a complete CLI for k-mer
processing tools. These interfaces allow KAnalyze to be inte-
grated directly into Java programs via the API, or into pipelines
of any language via the CLI. For desktop users, a graphical
interface is included for the count module.

With carefully chosen algorithms and data structures,
KAnalyze can perform at a level commensurate with programs
compiled to native code. Through extensive testing, we are
confident that it produces accurate results.

KAnalyze is designed to survive years of maintenance and
feature additions. The source is distributed under the GNU
Lesser GPL to restrict its usage as little as possible. We encour-
age others to contribute to the KAnalyze project.

 

2071

[310'sp2umofpmjxo'sopeuuopnoiq/ﬁdnq

P.Audano and F.Vannberg

 

Funding: Georgia Institute of Technology provided financial sup—
port through a startup grant to the Vannberg Lab.

Conﬂict of Interest: none declared.

REFERENCES

Knuth,D. (1998) The Art of Computer Programming. In: Sorting and Searching.
V01. 3, 2nd edn. Addison—Wesley, pp. 2487379.

Marcais,G. and Kingsford,C. (2011) A fast, lock—free approach for efﬁcient parallel
counting of occurrences of k—mers. Bioinformuticx, 27, 7644770.

Newburger,D.E. and Bulyk,M.L. (2009) UniPROBE: an online database of protein
binding microarray data on protein—DNA interactions. Nucleic Acids Rex, 37,
D777D82.

N0rdstr6m,K.J.V. et a]. (2013) Mutation identiﬁcation by direct comparison of
whole—genome sequencing data from mutant and wild—type individuals using
k—mers. Nat. Biotechnol, 31, 3257330.

Rizk,G. et a]. (2013) DSK: k—mer counting with very low memory usage.
Bioinfommticx, 29, 6527653.

Wilson,G. et a]. (2014) Best practices for scientiﬁc computing. PLoS Biol., 12,
e1001745.

 

2072

/310'S[BHmO[pJOJXO"SOIJBLUJOJIIIOIq/ﬂdnq

