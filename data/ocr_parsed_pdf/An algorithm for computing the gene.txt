Biainfarmatics, 32, 2016, i225—i233
doi: 10.1093/bioinformatics/btw261
ISMB 2016

 

An algorithm for computing the gene tree
probability under the multispecies coalescent
and its application in the inference of
population tree

Yufeng Wu

Department of Computer Science and Engineering, University of Connecticut, Storrs, CT 06269, USA

Abstract

Motivation: Gene tree represents the evolutionary history of gene lineages that originate from mul—
tiple related populations. Under the multispecies coalescent model, lineages may coalesce outside
the species (population) boundary. Given a species tree (with branch lengths), the gene tree prob—
ability is the probability of observing a specific gene tree topology under the multispecies coales—
cent model. There are two existing algorithms for computing the exact gene tree probability. The
first algorithm is due to Degnan and Salter, where they enumerate all the so—called coalescent his—
tories for the given species tree and the gene tree topology. Their algorithm runs in exponential
time in the number of gene lineages in general. The second algorithm is the STELLS algorithm
(2012), which is usually faster but also runs in exponential time in almost all the cases.

Results: In this article, we present a new algorithm, called CompactCH, for computing the exact
gene tree probability. This new algorithm is based on the notion of compact coalescent histories:
multiple coalescent histories are represented by a single compact coalescent history. The key ad—
vantage of our new algorithm is that it runs in polynomial time in the number of gene lineages if
the number of populations is fixed to be a constant. The new algorithm is more efficient than the
STELLS algorithm both in theory and in practice when the number of populations is small and
there are multiple gene lineages from each population. As an application, we show that
CompactCH can be applied in the inference of population tree (i.e. the population divergence his—
tory) from population haplotypes. Simulation results show that the CompactCH algorithm enables
efficient and accurate inference of population trees with much more haplotypes than a previous
approach.

Availability: The CompactCH algorithm is implemented in the STELLS software package, which is
available for download at http://www.engr.uconn.edu/ywu/STELLS.html.

Contact: ywu@engr.uconn.edu

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

 

Consider 71 gene lineages sampled from one population. When we
trace these lineages backward in time, sooner or later two of these
lineages will find a common ancestor. When this occurs, we say
these two lineages coalesce or the coalescent of these two lineages
occurs. Gene lineages coalesce in a stochastic way, which is inﬂu—
enced by multiple population genetic parameters, such as population
sizes. Therefore, coalescents may potentially reveal important as—
pects of population evolution. In 1982, Kingman (1982) introduced
the coalescent theory, which provides the analytical foundation for

©The Author 2016. Published by Oxford University Press.

the study of coalescents. Since then, coalescent theory has quickly
become a very active research subject in population genetics. There
are numerous theoretical results in coalescent theory, along with
many coalescent—based software tools. See Wakeley (2008) and
Hein et al. (2005 ) for an overview of the growing field of coalescent
theory.

While mathematically appealing, coalescent is known to be chal—
lenging computationally. One of the most important problems on
coalescents is computing the coalescent likelihood. That is, we want
to compute the probability of observing some population variation

i225

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/4.0/),
which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact

journals.permissions@oup.com

112 /310'slcum0fp1q1x0"soiJBuiJOJuioiq/ﬁduq 11101} popcolumoq

91oz ‘Og anﬁnv uo ::

i226

Y. Wu

 

data under a coalescent model. However, coalescent likelihood is
well known to be difficult under most formulations [see e.g. Hein
et (11., 2005; Wakeley, 2008]. At present, there are few polynomial
time algorithms for computing coalescent likelihood except under
very restricted conditions. Almost all existing approaches for coales—
cent likelihood computation are based on statistical techniques such
as Markov chain Monte Carlo (MCMC) or importance sampling
(Wakeley, 2008). These statistical approaches can be very useful in
practice. However, from the computational point of view, these
approaches cannot compute the exact coalescent likelihood.
Moreover, approaches using MCMC tend to be very slow. Since co—
alescent likelihood is usually used in the inference of population evo—
lution, accurate and efficient coalescent likelihood computation is
highly desirable.

Since the work by Kingman (1982), the basic coalescent has been
extended to address more aspects of population evolution. The mul—
tispecies coalescent is one such extension, and is the focus of this art—
icle. Multispecies coalescent concerns the coalescents among gene
lineages from multiple populations where coalescents may cross the
population boundary. Multispecies coalescent is fundamental to
population evolution (Degnan and Salter, 2005; Rosenberg, 2002).
Multispecies coalescent has also found applications in other do—
mains, such as species tree inference [see, e.g. Heled and
Drummond, 2010; Mirarab et (11., 2014; Wu, 2012].

A key computational problem on multispecies coalescent is the
computation of the gene tree probability (Degnan and Salter,
2005; Wu, 2012, 2015). Here, we are given a gene tree topology
(without branch lengths) and a species tree (with branch lengths in
the standard coalescent units). Note that the gene tree may not be
bifurcating and there can be more than one gene lineages for a
population (or taxon) in the gene tree. The gene tree probability is
the probability of the gene tree topology as a result of the multispe—
cies coalescent within the given species tree. There are only two
existing algorithms for the exact gene tree probability computa—
tion. The first such algorithm is due to Degnan and Salter (2005).
However, their algorithm has the exponential running time and
there are no known cases of species and gene trees for which their
algorithm runs in polynomial time. A much faster algorithm is
given in Wu (2012), which is implemented in the program
STELLS. However, the STELLS algorithm computes the gene tree
probability in polynomial time only for some very special types of
gene trees and species trees. We are not aware of any statistical
approaches for computing the gene tree probability. The closest
related approach is the MCMC approach in Heled and Drummond
(2010), which is also based on multispecies coalescent. However,
the likelihood computed in Heled and Drummond (2010) is for
DNA sequences, not for gene trees.

In this article, we present a new algorithm, called CompactCH,
for computing the exact gene tree probability. The main advantage
of CompactCH is that it runs in polynomial time for any gene tree
topologies and species trees when the number of taxa (populations)
is fixed to be a constant. That is, the CompactCH algorithm is effi—
cient for gene tree topologies with large number of gene lineages if
the number of populations is small (i.e. there can be many gene lin—
eages from each population). Note that although the number of
gene lineages in many phylogenetic studies tends to be relatively
small, the number of gene lineages in large—scale genetic studies
can be large. Therefore, CompactCH may become more useful
when more gene lineages are sampled from a population which is
the case in genetic projects such as the 1000 Genomes Project
(2015). To the best of our knowledge, CompactCH is the first al—
gorithm for computing the gene tree probability in polynomial

time that allows arbitrary gene trees and species trees when the
number of populations is fixed to a constant. Note that if gene tree
topologies are considered to be observed, then the gene tree prob—
ability is the likelihood of the observed gene tree topologies given
the species (population) tree. In this regard, the coalescent likeli—
hood of gene tree topologies can be computed in polynomial time
under the assumption of small number of populations. We show
through theoretical analysis and empirical simulations that
CompactCH outperforms the existing STELLS algorithm when the
number of populations is small and the gene tree contains multiple
gene lineages (alleles) per taxon. We also present a new method for
the inference of population divergence history (called the popula—
tion tree) from large population samples, which is based on the
CompactCH algorithm.

2 Background

2.1 Multispecies coalescent and incomplete lineage
sorting

In this article, we use population and species interchangeably.
Multispecies coalescent process (or just multispecies coalescent) con—
cerns the coalescents of gene lineages that may occur outside the spe—
cies boundary. See Figure 1 for an illustration. Multispecies
coalescent lies at the intersection of population genetics and phylo—
genetics, and has been widely used in phylogenetic and population
inference [see e.g. Heled and Drummond, 2010; Wu, 2012]. We use
a rooted bifurcating tree T, (with branch lengths) to represent the
population divergence history. We use a rooted tree topology Tg to
represent the genealogical history of gene lineages at a single locus.
It is important to note that Tg does not have branch lengths. Also Tg
may be multifurcating if the gene genealogy cannot be fully deter—
mined from the given genetic data. A common observation is that T,

 

 

,(h \q

D f \\ I,
x/ ' \-. r” 13
/ \. {I Er'
.r \  I. 'il \
a 1

\ \ 3" ."'
El: 1]] [‘1 an '32

A B C

The species tree T9 The gene tree Tg

Fig. 1. A gene tree (in thin lines) in the species tree (in thick lines) shown in
(a). Gene lineages a1, 32 and 33 originate from species A, b1 and b2 from B
and c, from C. The species tree TS is shown separately in (b), so is the gene
tree T5, in (0). Internal nodes of both T51 and TS are labeled. Coalescents: in-
ternal nodes of Ty. Branches of trees are represented by their lower nodes

112 /310'slcu1n0fp103x0"soiJBuiJOJuioiq/ﬁduq 11101} papeolumoq

9103 ‘Og anﬁnv uo ::

Algorithm for computing the gene tree probability

i227

 

and Tg do not always have the same topology. This phenomenon is
called incomplete lineage sorting. We define the gene tree probabil—
ity to be the probability of observing Tg for a given T5 under the
multispecies coalescent model. Computing the probability of gene
genealogies under multispecies coalescent is central both to phylo—
genetic inference of a species (or population) tree and to population
genetic inference of gene ﬂow between populations [e.g. Degnan
and Salter, 2005; Heled and Drummond, 2010; Hudson, 1983;
Rosenberg, 2002; Wu, 2012, 2015]. When T5 and Tg are small, sim—
ple closed—form formulas are known to calculate the gene tree prob—
ability (Hudson, 1983; Rosenberg, 2002; Takahata and Nei, 1985).
When Tg and T5 become larger, computation by hand is no longer
feasible and an algorithm is needed.

2.2 Computing gene tree probability using

coalescent history

Degnan and Salter (2005) gave the first algorithm for computing the
gene tree probability of a gene tree topology Tg and a species tree T5.
Their algorithm is based on the notion of coalescent history. We
give parts of technical details of their algorithm because our new al—
gorithm is an improvement over their algorithm. In the following,
we use the lower (i.e. closer to the leaves) node of an edge to refer to
the branch in a tree T. For example, when we say branch g in
Figure 1c, we mean the branch with lower node g in Tg. Each in—
ternal node v in Tg corresponds to a coalescent event between two
lineages. For simplicity, we use 11 to also refer to the coalescent at v.
For example, in Figure 1, the node g corresponds to a coalescent be—
tween lineages a1 and a2. A coalescent history determines, for each
coalescent v in Tg, on which species tree branch 11 occurs. In
Figure 1a, for example, the embedded Tg within T5 corresponds to a
coalescent history. In this history, coalescent g occurs on species tree
branch A, p on D and 17, q and r on E (the root branch). Note that
the precise positions of these coalescents within T5 are not important
since Tg does not have branch lengths and thus branches of Tg may
be stretched or shrunk as long as the coalescents occur within the
same species tree branches.

Degnan and Salter’s algorithm enumerates all possible coales—
cent histories h for the given Tg and T5. We denote the set of all co—
alescent histories for Tg and T, as ’H(Tg]TS). We let m be the
number of branches in T5 and use an integer b E [1 . .  to refer to
a branch in T5. We let 2;, be the branch length of the branch b in T5.
Then.

P(Tngs): Z Pagan)
hengst)
m h
I Z H—Zféhjpuxhwhﬂb) (1)

hEH(Tg]Ts) [2:1

Here, we call the number of gene lineages at the bottom (re—
spectively top) of a species tree branch b the lower (respectively
upper) lineage count of b and denote as m, (respectively 115). Recall
that a coalescent history 19 specifies along which species tree
branch each coalescent occurs. Thus, when 19 is given, both the
upper and lower lineage counts of each species tree branch are
known. So we use 14;,(19) and 11;,(19) to refer m, and 11;, specified by h.
For example, consider the branch A and let h be the coalescent his—
tory shown in Figure 1a. Then MA(h) : 3 and 12,409) : 2. {nu/(T) is
the probability of u lineages coalesce into 11 lineages within time T
(where T is the in the standard coalescent units). Equation (2) is a
classic result (Takahata and Nei, 1985; Tavaré, 1984; Watterson,
1984) [also see Wakeley (2008) and Rosenberg (2002)] in

coalescent theory which gives a closed form formula for calculat—

ing {ha/(T).

“ _ _ (zk—lx—lr‘“
Wm :28 W 1)T/2vl(k—v)l(v+k—1)

k:1/
k—l
w+ww—w
 <u+y> ‘ ‘2)

The reason why there are terms % in Equation (1) is that
17",,(T) does not impose the order of coalescents as specified in Tg.
For example, consider the coalescent history 19 shown in Figure 1a.
We have  : 4 and 113(k) : 1. Then, {741(23) only requires four
lineages coalesce to a single lineage within time 25, but does not im—
pose the condition that g and b1 must coalesce and also 17 and 61
must coalesce. That is, 1741 allows, for example, the coalescent
of g and 61, which violates the topology of Tg. Degnan and Salter de—
fine db(h) as the number of all possible ways of coalescing ub(h) lin—
eages into 11;,(19) lineages. Since any pairs of lineage can coalesce, we
have (Degnan and Salter, 2005):

min—1. ._
duh): H ’0 1’. <3>

emm 2

 

The wb(h) term is a little more complex. It is equal to the num—
ber of ways of coalescents on branch b as specified by h where these
coalescents match the topology of Tg. Note that there are 6;,(19) : 14;,
(h) — 11;,(19) coalescents on branch b. We denote these coalescents as
Cb(h). For convenience, we use 6;,(19) to denote the number of co—
alescents along a species tree branch b. There are 6;,(19)! ways of
ordering these coalescents, but only a subset of these ways match Tg.
For each coalescent u E Cb(h), let nu(h, b) be the number of coales—
cents in Cb(h) that are within the subtree rooted at node a in Tg.
Here, a is included in the subtree. For example, we again consider
the coalescent history 19 in Figure 1a. Then n,(h, E) : 3 and
71,7(19, E) : nq(h,E) : 1. Note only coalescents within branch E are
considered here and thus the coalescents p and g are not counted for
m,(h, E) and nq(h,  Note that among all possible permutations of
6;,(19) coalescents (with a being one of the coalescents), we want
those with u be placed after the nu(h,b) — 1 coalescents. There is
precisely one out of nu(h, b) permutations with this property. Then,
we have (Degnan and Salter, 2005):

1
h,b)'

 

mo) : cub)! H

( (M
uEC,,(h) "u

As an example, for the coalescent history 19 in Figure 1a,
7 1 1 1 7 1117
WE“)—CﬁhﬂzaE%MhmZUEi—3bTT—Z‘
The exact gene tree probability can be computed if all coalescent

 

histories are enumerated for Tg and T5. However, as shown in
Degnan and Salter (2005 ), the number of coalescent histories grows
rapidly when the sizes of Tg and T5 grow. In fact, when Tg and T,
have matching topology [assumed in most analytical results on co—
alescent history; see e.g. (Rosenberg, 2013)], there exists no known
cases where lead to polynomial number of coalescent histories.
Recently, an algorithm called STELLS was developed in Wu
(2012). The STELLS algorithm is based on dynamic programming on
a data structure called ancestral configuration (or AC). The STELLS
algorithm is much faster than the algorithm by Degnan and Salter.
Moreover, it is known that the number of ACs is bounded by a poly—
nomial when Tg and T, have matching topology and the topology is
the maximal—asymmetric (i.e. caterpillar) tree. So in this special case,
STELLS computes the gene tree probability in polynomial time.

112 /310'slcu1n0fp103x0"soiJBuiJOJuioiq/ﬁduq 11101} papeolumoq

9103 ‘Og anﬁnv uo ::

i228

Y. Wu

 

However, except the simple caterpillar trees (or trees very similar to
caterpillar), there are no known cases where STELLS can compute the
gene tree probability in polynomial time. Usually the STELLS algo—
rithm becomes slow when the sizes of Tg and T5 increase.

3 The CompactCH algorithm for computing gene
tree probability

We now present a new algorithm, called CompactCH, for comput—
ing the exact gene tree probability. CompactCH builds on Degnan
and Salter’s algorithm, and is very different from the STELLS algo—
rithm. The key idea of the CompactCH algorithm is combining mul—
tiple coalescent histories into a compact coalescent history and thus
making the computation in Equation (1) more efficient. For the ease
of exposition, we assume gene trees are bifurcating unless otherwise
stated. We will later extend to the multifurcating gene tree case.

3.1 Gene tree probability computation using compact
coalescent history

Since our algorithm involves a number of notations, we provide a
list of notations in the Supplemental Materials. We first recall that
Equation (1) is a summation of products over coalescent history 19.
Each product consists two terms for each species tree branch b: the

coalescent factor term who”

and the coalescent probability term
puh(;,),,h(;,)(lb). The coalescent probability term only depends on the
upper and lower lineage counts of the branch b. Suppose we group
the coalescent histories with the same upper and lower lineage
counts for every species tree branch into a compact coalescent his—
tory ch. Then all these histories will have the same coalescent prob—
ability terms. More precisely, a compact coalescent history is a list
of upper lineage counts at all species tree branches (except the root
branch). For example, consider the coalescent history shown in
Figure 1a. We arrange the upper lineage counts for species tree
branches in the order of A, B, C and D. Then the corresponding
compact coalescent history ch is represented as: {2, 2, 1, 3}. That is,
there are two, two, one and three gene lineages at the top of A, B, C
and D, respectively. We denote the set of all possible compact co—
alescent histories for the given Tg and T, as C’H(Tg]TS). A compact
coalescent history can be viewed as the combination of one or mul—
tiple coalescent histories. As an example, consider Tg and T5 in
Figure 1. There are total seven compact coalescent histories as
shown in Table 1. The compact history {2,2,1,3} combines two co—
alescent histories: the history shown in shown in Figure 1a and the
history with 17 as the only coalescent occurring within branch D and
p occurring within the branch E.

Table 1. The list of all compact coalescent histories CH(Tg]TS) for
the trees TS and T9 in Figure 1

 

 

CCH #histories
c171 {321,5} 1
c172 {321,4} 2
c173 {321,3} 2
c174 {321,2} 1
5/75 {221,4} 1
5/76 {2,2,1,3} 2
5/77 {221,2} 1

 

CCH: compact coalescent history (the numbers are the numbers of upper
lineage counts for species tree branches A, B, C and D). For each compact his-
tory, we give the number of coalescent histories that are merged into this com—
pact history (denoted as #histories).

While a compact coalescent history only specifies the upper lin—
eage counts, Lemma 3.1 shows that both upper and lower lineage
counts as well as the number of coalescent events on all species tree
branches (including the root branch) are all fully determined by a
compact coalescent history.

Lemma 3.1. The lower and upper lineage counts, and the numbers
of coalescent events along all species tree branches are determined
by a compact coalescent history.

Proof. Recall a compact coalescent history specifies the numbers
of gene lineages on top of each species tree branch (except the root
branch). Note that for the root r, the upper lineage count 11, is al—
ways one. This is because all gene lineages must coalesce into one
lineage within the root branch.

Consider a species tree branch b. If b is a leaf branch (i.e. one of
the nodes of b is a leaf in T5), its lower lineage count is equal to the
number of sampled linages from this leaf, which is given as part of
the input. This is because there is no time for coalescent to occur at
a leaf of T5.

Let b be an internal branch. Let Desc(b) be the set of descendant
branches of T5 (i.e. these branches are the outgoing edges from the
lower node of b). For example, in Figure 1, Desc(E) : {C, D} and
Desc(D) : {A, B}. Then, a), : ZXEDBSCW 15,. This is because the lin—
eages at the top of the descendant branches of b enter b from below.
Thus, the set of lineages at the lower node of b is simply the merged
set of the sets of lineages at the top of all b’s descendant branches.
Note that this merging process is instantaneous and there is no time
for coalescent to occur.

Note that the number of coalescents on b is simply equal to the
difference between the lower and the upper lineage counts at b.
Therefore, the number of coalescent events on b is fully determined
by the compact history for all b.

From Lemma 1, we use 14;,(ch) and 11;,(ch) to denote the lower
and upper lineage count at branch b, and cb(ch) as the number of
coalescents on b, which are specified by the compact coalescent his—
tory ch.

We now consider Equation (1) again. Note that each coalescent
history can be mapped to a compact coalescent history. For a com—
pact coalescent history ch, let ’H(ch) be the set of coalescent histories
combined in ch. We now group the coalescent histories in ’H(ch) to—
gether for each ch when applying Equation (1). Note that for all his—
tories h in ’H(ch), ub(h) (respectively 11;,(h)) are the same. Thus they
have identical coalescent probability terms puh(c;,),,h(c;,) (2),) terms in
the summation over ’H(ch). Moreover, we have the same W terms.
This is because according to Equation (3), (151(k) only depends on
ub(h) and 11;,(19), which are identical for histories in ’H(ch). This

Puhrchmrch) (847
C

 

allows us to extract the common product of the terms

out of the summation over ’H(ch). Therefore,

m M709)

H—pu (11):; (100.1,)
ChECHUngs) heH(ch)[7:1 Mb) ” ’7

m 141,1: 14,1: 4- m
2 2 Hi7  [7) Z Hwbw)

chECH(Tg]T5) {7:1 heH(ch) {7:1

P(Tngs) =

m puh(ch)1/,,(ch) (4b)
Wq 1’) (5)

chECH(Tg]T5) {7:1

In Equation (5), C(ch) : Zhsmch) H211 at), We call C(ch)
the coalescent coefficient of ch. We now show for a given ch, its co—
alescent coefficient can be computed efficiently.

112 /310's112u1n0[p101x0"soiJBuiJOJHioiq/ﬁduq 111011 pap1201um0q

9103 ‘0g anﬁnv uo ::

Algorithm for computing the gene tree probability

i229

 

3.2 Efficient computation of coalescent coefficient
We first note in Equation (4), 6;,(19) : ub(h) — 11;,(19). Thus, for all h
in ’H(ch), 6,,(19) can be written as the same 6;,(ch). So,

C(ch): 2 How)! U (1197b)

heH(ch) {7:1 7760,07) n“

 

m 1

 

ll
{:s

6;,(ch)! Z
hEH(ch) 12:1 {160701) may)

T
a

cb(ch)!C1(ch). (6)

{:s

b

l l
._.

In Equation (6), C1(ch) : Zhsmch) H211 HuECM)  Note
that the species tree branch b is implicit in C1(ch). In C1(ch), the
term m depends on specific 19 because the numbers of coalescents
along species tree branches depend on b. When the number of h is
large, direct summation of these #0,) terms is inefficient. We now
show C1(ch) can be computed efficiently using a recurrence.

For the remaining part of this section, we consider a specific ch.
Thus, we omit ch [e.g. by writing C1(ch) as C1 and ’H(ch) as ’H]. We
consider each coalescent (internal node) 6 in Tg. We denote the spe—
cies tree branch on which 6 occurs as b. We denote the number of
coalescent events that are within the subtree of Tg rooted at c and
occur on b as 715. We denote the set of species tree branches below
(and including) b as 8(b). That is, b E 8(b). Here, 6 itself is con—
sidered to be within the subtree rooted at c and thus is included in
715. We denote SC as the set of species tree branches where the coales—
cent 6 may occur. For example, In Figure 1, B(D) : {A,B, D} and
Sg : {A, D,  bth, quE, 71,: 3 (including coalescents r, 17 and
q) in the coalescent history shown in Figure 1a. We denote the list of
the numbers of coalescents on each species tree branch as n. We de—
fine unit vector U,- as the vector where 11,-[1'] : 1 and U,- : 0 when
/' : i. For a specific integer list 11 of length m, we say 115 is a sublist of
n if 0 S n5 3  for all 1 S i S m. We denote the set of all pos—
sible sublists of n as  For example, suppose n : [2,2,1,3].
Then a possible sublist is [1,1,1,2].

For a coalescent c, a branch b, of T5 and an integer list 11, we define:

C2(c,b5,n) : 1

 

heH,{7,:{7,,n,:n[c] [768(k) 146C170!) "('(h).

That is, C2(c, b5, u) restricts C1 to the subtree rooted at c where 6
occurs on b, and the numbers of coalescents within the subtree
rooted at c is n. We impose the following constraints for C2 (6, b5, 
If any of the constraints is violated, we have C2(c, b5, u) : 0.

(1). u only specifies coalescent numbers for species tree branches
in 8(bs) (i.e. either at b, or within the subtree below b,): n[b] : 0 for
any b a 8(bs).

(2). There is at least one coalescent at b5: 11%,] Z 1. Moreover,
b, 6 8,.

We let b, be the root branch of T5 and c, be the root of Tg. Note
that we assume there is at least one gene lineage from each species.
Then 6, must occur on b,. We have:

C1(ch) : C2(c,, br, c(ch)). (7)

Here, C(ch) refers to the list of upper lineage counts implied by
the compact history ch. We initialize the computation of C2(c, b5, u)
for the coalescent c, where there is no coalescent within the subtree
of Tg rooted at 6 except 6 (i.e. c is the lowest coalescent in Tg):

1, ifbs E Sc,n[bs] : 1andn[b] : 0whenb : b5

0, otherwise

C2(c,b5,n) :{

If c is not the lowest coalescent, then c may have one or two chil—
dren that are also internal nodes. Recall that we assume bifurcating
gene trees in this section. We have two cases.

Case 1: c1 is the only descendant internal node. Note that if there
are still more coalescents along b5 (i.e. 11%,] Z 2), 61 must also occur
along b. If there is only a single coalescent on b5, 61 has to occur in
some branch in 8(bs). Then:

C2(c,b5,n) : 1

 

Z C2(C1ibin—Ub,)- (8)

"i 5] {763075)

Case 2: both immediate descendants c1 and C2 of c are internal
nodes. In this case, we need to split 11 — 111,5 into two parts, one for c1
and one for 62. Then, we may sum over all such partitions and all
possible species tree branches where 61 and 62 may occur.

C2(c,b5,n) :;

"i S] n1ES(n—ubi), {7,,{7,eB({7,)
n2 : "—917. — n1
SSW—1117‘)

(9)

REMARK: Equations (8) and (9) can be written in a more compact
form because many terms contained in these two equations are zero.
This is because many partitions of 11 lead to violations to constraints
1 and 2. The current exposition is a simplification to avoid overly
complicated formula.

EXAMPLE. To illustrate the process of computing the C2 terms, we
show how to calculate these terms for the compact history ch : {2,
2,1,3} in Figure 1a. We have C(ch) : {1,0,0,1,3}. Starting from
the more recent (i.e. close to the extant time) coalescents,

C2(g,A,{1,0, 0, 0, 0}) : 1.0,

C2(p,D,{0,0,0,1,0}) : 1.0, C2(p,E,{0,0,0,0,1}) : 1.0,
C2(h,D,{1,0,0,1,0}) : C2(g,A,{1,0, 0, 0,0}) : 1.0, ,
C2(h,E,{1,0,0,0, 1} C2(g,A,{1,0,0,0, 0}) : 1.0,

(

) :

C2 q,E,{0,0,0,1,1}) : C2(p,D,{0,0,0,1,0}) : 1.0
C2(q,E,{0,0,0,0,2}):%C2(p,E,{0,0,0,0,1}):0.5. Then, C1(ch):

C2(r,E,{1,0,0,1,3}) is equal to %(C2(17,D,{1,0,0,1,0})C2(q,E,{0,0,0,

0,2}+ C2(17,E,{1,0,0,0,1})C2(q,E,{0,0,0,1,1}): 0.5. Here, we omit

all terms in C2 calculations that are zero.

3.3 The CompactCH algorithm for computing the gene
tree probability

The CompactCH algorithm for computing the gene tree probability
is as follows.

1. Enumerate and compute all coalescent coefﬁcients for Tg and T,
as in Equations (8) or (9).

2. Enumerate all compact coalescent histories ch for Tg and T5. The
enumeration can be performed in a bottom—up way. Compute
the terms puhghmgh) (21,) and db(ch) for each species tree branch
b. Obtain C(ch) using Equations (6) and (7).

3. Compute the gene tree probability by summing over all compact
coalescent histories using Equation (5).

3.4 Analysis of the CompactCH algorithm

We now analyze the running time of the CompactCH algorithm in
Section 3.3. It can be shown that CompactCH runs in exponential
time when the number of populations is unbounded. See the
Supplemental Materials for more details. We now show that

C2(C1, b17n1)C2(627527n2)-

112 /310's112u1n0[p101x0"soiJBuiJOJHioiq/ﬁduq 111011 pap1201um0q

9103 ‘0g anﬁnv uo ::

i230

Y. Wu

 

CompactCH runs in polynomial time in the number of gene lineages
when the number of populations is fixed to be a constant.

The gene tree probability computation in Equation (5) depends
on the number of compact coalescent histories N(Tg, T5) for the
given Tg and T5, which in turn depends on the number of gene lin—
eages n and the number of species tree branches m. The main advan—
tage of our new algorithm is that it runs in polynomial time when
there are constant number of species. The algorithm is more efficient
than the existing algorithms when there are multiple gene lineages
per species. Thus, we assume m is fixed to a constant. We first show
that N(Tg, TS) is polynomial in terms of 71 when m is a constant. We
then show that coalescent coefficient is polynomial time computable
for each compact history.

First, recall that a compact coalescent history consists of a list of
the upper lineage counts, one for each species tree branch. For a T5
with m species tree branches, the length of this list is m — 1, and at
each position of the list the upper lineage count is at most 71 — 1. So
the number of choices for each position is 71. Therefore, there are at

most rim—1

compact histories. When m is fixed to be a constant, this
is polynomial in n. For each compact history, Equation (5 ) takes
O(m) time. So, the total time is O(mnm‘l).

We now show coalescent coefficient computation in Equation
(6) runs in polynomial time for a given compact coalescent history
ch in a bifurcating Tg when m is a constant. These coalescent coeffi—
cients are pre—computed before Equation (5 ) is evaluated. By
Equation (7), we need to show C2(c,, b), c(ch)) can be computed ef—
ficiently. Note that C2(c,, b,,c(ch)) is computed using a recurrence
over C2(c,b,n). Here, 6 is a coalescent in Tg, b is a species tree
branch and n is the list of coalescent counts (i.e. the number of co—
alescents) for the branches with the subtree of T5 rooted at b. The
number of such C2(c, b, n) is bounded by (n — 1)m(n — 1)m, which
is a polynomial of 71 when m is a constant. Each C2(c, b, n) can be
computed by Equations (8) or (9) in O(m2(n — 1)m) time. So, all co—
alescent coefficients can be computed in O(nm3(n — 1)2m) time.
Therefore, we have:

Theorem 3.2. The CompactCH algorithm runs in O(m3n2mH)
time for a bifurcating Tg, which is polynomial in 71 when the number
of species in T5 is a constant.

REMARK. The CompactCH algorithm computes the gene tree
probability runs in polynomial time in 71 when m is fixed to be con—
stant. At the first glance, the CompactCH algorithm appears to be
very slow: when m : 3 (i.e. two populations), the running time is
O(n7). In practice, CompactCH appears to be significantly faster
than the STELLS algorithm when m is small. This is because we
may overestimate the number of needed steps (e.g. for computing
the coalescent coefficients). Table 2 shows that when there are two
populations, the CompactCH algorithm can remain practical when
n is as large as 200 where the STELLS algorithm becomes very slow.
See the Section 5 for empirical performance of this algorithm. It can
be shown that STELLS runs in exponential time in the number of
gene lineages when there two populations. See the Supplemental
Materials for details.

3.5 Multifurcating gene trees

So far, gene trees are assumed to be bifurcating. The original
STELLS algorithm (Wu, 2012) and the algorithm in Degnan and
Salter (2005 ) also assume bifurcating gene trees. Multifurcating
gene trees, however, may be preferred for gene tree probability com—
putation in some cases. For example, it is possible that some splits in
the gene trees do not have sufficient support and thus multifurcating
gene trees may be used to allow uncertainty in gene tree topologies.
The STELLS algorithm was extended to allow multifurcating gene
trees in Wu (2015). The STELLS algorithm is slower for multifurcat—
ing trees than bifurcating trees.

Our new algorithm can be extended to compute the gene tree
probability for multifurcating gene trees. Compact coalescent histor—
ies remain the same as the bifurcating gene tree case. For each spe—
cies tree branch b, we specify the number of gene tree lineages at the
top of b. Note that at a multifurcating gene tree node v of out—
degree d, there are d — 1 coalescents at v. For a given compact co—
alescent history ch and a species tree branch b, the terms pumhmgh)
(2),) and db(ch) can all be easily computed as before. This is because
these terms only depend on the numbers of gene lineages at specific
positions of T5, which are fully determined by ch. These terms do
not depend on the topology of Tg. The main difference of the multi—
furcating gene tree case is on the coalescent coefficient computation.
At a gene tree internal node 6 with out—degree d, recurrences in
Equations (8) and (9) need to be modified. Let DC be the set of c’s
children in Tg that are internal nodes. We let 8(DC) be the set of all
possible proper subsets of DC. We define C3(c, b,, S, n) for
S E 8(DC), a branch b, of T5 and an integer list 11 in the same way as
C2(c, b5, u) when we treat the lineages in S form a new split in Tg.
Then, following the same reasoning as in Equations (8) and (9):

1

C2(c,b5,n) : m

SES(DC),n’,n”
C3 (C) b5) S) "()C3 (C) b5) Dc _ S) "’0‘

Here, n’ and n” are two integer lists which combine to n — 111,5.
Thus, coalescent coefficients for multifurcating Tg can be computed
in a recursive way, similar to the bifurcating case. The running time
for coalescent coefficient computation depends on the maximum de—
gree dma,X in Tg. Since there are 2dmax — 2 non—empty proper subsets
for dma.X gene lineages, the algorithms becomes slow when dma.X is
large. If dma.X is bounded by a constant, the gene tree probability for
a multifurcating tree can be computed efficiently when the number
of species is small.

4 Inference of population tree from haplotypes
from pairwise population distance
In Wu (2015), we demonstrate that gene tree probability can be

used in the inference of population tree (i.e. the population diver—
gence history) when the given data is in the form of haplotypes.

Table 2. Running time of CompactCH (outside the parenthesis) and the STELLS algorithm (inside parenthesis) for computing gene tree

probability for 500 simulated gene trees

 

 

mp 1 2 5 10 15 20 50 100

2 <1 (<1) <1 (<1) 1(1) 3(7) 20 (453) 94 (21 516) 21 974 (—) 1 166 613 (—)
3 <1 (<1) 1 (<1) 11(5) 2062 (18747) 83 272 (—) —(—) —(—) —(—)

4 <1 (1) 1(1) 1634 (218) — (—) — (—) — (—) — (—) — (—)

 

Results are not given if it takes longer than 15 days. mp: number of populations. Columns: g6, the number of gene alleles per population. Time: in seconds.

112 /310's112u1n0[p101x0"soiJBuiJOJHioiq/ﬁduq 111011 pap1201um0q

9103 ‘0g anﬁnv uo ::

Algorithm for computing the gene tree probability

i231

 

Brieﬂy, haplotypes contain the alleles (states) at closely linked gen—
etic variation sites. See e.g. Wu (2015) for some background on
haplotypes. Assuming population haplotypes satisfy the infinite sites
model of mutations (Kimura, 1969) and no intra—locus recombin—
ation, we may infer the underlying genealogical tree topologies, al—
though these trees are usually multifurcating [see, e.g. Gusfield,
1991]. For a single locus, there is a unique gene tree topology and
there are mutations on the branches of the gene tree. Under the in—
finite sites model of mutations and with no recombination, the prob—
ability of haplotypes is exactly equal to the probability of the unique
gene tree with mutations [see, e.g. Wakeley, 2008]. For the sake of
computational efficiency, the approach in Wu (2015 ) uses the prob—
ability of the gene tree topology (i.e. ignoring mutations) to approxi—
mate the probability of haplotypes. The probability of gene tree
topology is easier to compute than that of haplotypes and can be
used to infer the population tree by maximum likelihood (Wu,
2015). See Wu (2015) for more details. We use the same approxima—
tion in this article. In Wu (2015 ), we demonstrate that population
tree inference with gene tree probability performs well when com—
pared with the program TreeMix (Pickrell and Pritchard, 2012).
STELLS infers population trees by searching the tree space to find
the maximum likelihood estimate of the population tree. However,
one main computational challenge in Wu (2015) is the computa—
tional efficiency: population tree inference becomes slow when the
numbers of taxa and hapotypes increase (see the Section 5). Genetic
studies now routinely involve ten or more populations, and multiple
haplotypes are collected from each population. For example, the
1000 Genomes Project (2015) recently released over 1000 genome—
scale haplotypes from more than 20 populations. Such large—scale
genetic data imposes huge challenges for inference.

In this article, we develop a new population tree inference
method based on the CompactCH algorithm. This method is dis—
tance based, and does not perform maximum likelihood inference.
The main idea of our method is (i) first infer the distance of pairs of
two populations using haplotypes from the two populations, and (ii)
construct the population tree using neighbor joining from the
inferred pairwise population distances. The key is in the population
distance estimate. There is exactly one population tree topology (i.e.
population divergence history) of two populations A and B. With
the haplotypes from A and B (and the implied gene genealogies), we
can infer the branch lengths (L; and d3. Here dA (respectively dB) is
the length of the branch connecting A (respectively B) and the com—
mon ancestor of A and B in the species tree of A and B. This can be
done by optimizing (L; and dB to maximize the gene tree probability
of the genealogies. See Wu (2012, 2015) for more details. Once (L;
and d3 are estimated, the pairwise distance between A and B is esti—
mated to be dA + d3. Then these pairwise distances are then used to
infer the population tree of all populations by neighbor joining. The
CompactCH algorithm enables fast pairwise population distance es—
timate from large number of haplotypes. In the Section 5, we dem—
onstrate that this simple method can give accurate population tree
inference using more haplotypes per population than the original
method in Wu (2015) can handle.

5 Results

We have implemented our new CompactCH algorithm as part of
the STELLS program (http://www.engr.uconn.edu/ywu/STELLS.
html). We compare with the STELLS algorithm, which is currently
the best algorithm for computing the gene tree probability. We first
show that CompactCH outperforms the original STELLS when the

number of species is small and there are multiple gene lineages per
species. Then, as an application, we show that CompactCH allows
fast and accurate inference of population trees from haplotypes
when there are multiple haplotypes from each population.

5.1 Performance of CompactCH in gene tree probability

computation

We evaluate the efficiency of CompactCH in computing the gene
tree probability. We first set the number of populations mp to be
two, three and four. We randomly generate species trees. We let the
number of gene copies g5 to be 1, 2, 5, 10, 20, 50 and 100. Note the
total number of haplotypes n is gcm. We generate 500 bifurcating
gene trees for a species tree using the program ms (Hudson, 2002).
The running times of using CompactCH and STELLS to compute
the probability of these 500 gene tree topologies for each simulated
species tree are shown in Table 2. Both algorithms are very slow on
many settings where both mp and g5 are large. So no results are col—
lected on these settings. Here, we say the computation is too slow if
the computation does not finish within 15 days on a 3192 MHz
Intel Xeon workstation running Linux (with 32 GB memory). Our
second simulation aims to investigating the efficiency with larger
number of populations. We fix g5 to be one, and then run
CompactCH and STELLS on the data. The results are shown in
Table 3. As expected, the STELLS is more efficient than
CompactCH for larger number of populations. Overall,
CompactCH is much faster than STELLS when m is relatively small
and g5 is relatively large.

5.2 Using CompactCH in population tree inference from
haplotypes

We run CompactCH and STELLS to infer population trees on simu—
lated data. The design of simulations is similar to that in Wu (2015).
Brieﬂy, we generate simulated datasets as follows. We use randomly
generated populations trees with mp populations to model the popu—
lation divergence history. Here, we let mp to be eight. The popula—
tion trees are the same as in Wu (2012). The length of each branch
in the tree is assigned to a length that is uniformly chosen between
0.0 and 1.0. We then scale the population trees so that the trees sat—
isfy clock property and the trees have fixed heights (being either 0.1
or 0.5). Note that CompactCH does not require clock—like popula—
tion trees. The clock property is mainly for the ease of simulation,
where we can reduce the number of parameter combinations. Then
we simulate haplotypes for 100 loci from a given population tree
using the program ms Hudson (2002), where there are g5 gene lin—
eages per species. Mutation parameters are fixed to be 20. We as—
sume constant population size, no recombination within each locus
and no migration between populations. Recall that the inferred genea—
logical tree topologies from haplotypes are usually multifurcating, and
CompactCH becomes slow when the gene tree topologies have large
degree at internal nodes. Thus, we discard gene trees with node degree
larger than 10. We use the normalized Robinson—Foulds (RF) distance

Table 3. Running time of CompactCH (outside the parenthesis) and
the STELLS algorithm (inside parenthesis) for computing gene tree
probability for 50 simulated gene trees and gc=1 (i.e. 1 allele per
population)

 

2 3 4 5 10 15

 

<1(<1) <1(<1) <1(<1) <1(<1) 3(1) 208(1)

 

Columns: number of populations. Time: in seconds.

12 /310's12u1noip101x0"$0112u1101u101q//:d11r1 111011 pap201um0q

9103 ‘0g1sn8nv uo ::

 

 

 

i232 Y.Wu
Table 4. Accuracy and time for inferring population trees using pairwise population distances
Ht Accuracy/Time g6
2 4 10 20 30
0.1 Inf. error 0.38 (0.47) STELLS: 0.30 0.20 (0.34) 0.20 (0.24) 0.11 (0.18) 0.11 (0.16)
Time 8s(44h,18 m,8s) 33s 21 m,49s 7h,2m,4s 36h, 42 m, 495
0.5 Inf. error 0.23 (0.22) STELLS:0.14 0.20 (0.15) 0.10 (0.12) 0.12 (0.14) 0.12 (0.13)
Time 6s(25h, 30m, 37s) 29s 7m,185 1h, 33 m,5s 5h, 56m, 555

 

 

Average over 50 replicates. Eight populations. Inference error: normalized RF distance. Population tree height (Ht): 0.1 or 0.5. 100 loci. g6: number of haplo—

types per population. Time: in seconds (s), minutes (In) and hours (h). Results for TreeMix are inside the parentheses. The original STELLS is only feasible for

g, = 2 and so only the results for the g, = 2 case are provided for the original STELLS.

to measure the inference error in the topology. That is, for the inferred
population tree topology T and the true tree 7* with n taxa, the nor—
malized RF distance is [3(T,T*) 2%. Here, B(T,T*) is the
number of splits in 7* but not in T.

It has been demonstrated in Wu (2015) that the inference of
population trees from these inferred genealogical tree topologies can
give accurate results. In Table 4, we show that more accurate infer—
ence results can be obtained by using the pairwise population dis—
tance approach (denoted as CompactCH) in Section 4 than the
STELLS approach (denoted as STELLS), when more haplotypes are
used. These simulations are conducted on a computer cluster.
STELLS is more accurate than CompactCH when only two haplo—
types are used for each population. The main advantage is that
CompactCH is much more scalable than STELLS: STELLS takes
more than 5 h on average for each dataset with two alleles per popu—
lation. CompactCH only takes seconds in this case. Note that
STELLS can be more accurate than the results by CompactCH be—
cause STELLS uses the maximum likelihood approach to search in
the tree space while CompactCH builds trees from pairwise dis—
tances. The accuracy of CompactCH increases when more haplo—
types are provided. For example, when 20 or more haplotypes per
population are used for the population trees of height 0.1, the infer—
ence error of CompactCH is only about one—third of that of STELLS
which uses two alleles per population. It appears CompactCH per—
forms relatively better for the species tree of height 0.1 than those of
height 0.5. We also note that CompactCH becomes slow if a large
number of haplotypes are analyzed. For comparison, we also run
TreeMix on these data. Our results indicate that CompactCH out—
performs TreeMix in most of the cases, especially for the case of
shorter species tree height.

5.2.1 Inference with the 1000 Genomes Haplotypes

We use CompactCH to infer population trees with haplotypes from
the 1000 Genomes Project (2015). We use haplotypes from the fol—
lowing ten populations in the 1000 Genomes Project: Han Chinese
in Beijing, China (CHB), Japanese in Tokyo, Japan (JPT), Southern
Han Chinese (CHS), Utah Residents with Northern and Western
European ancestry (CEU), Toscani in Italia (TSI), Finnish in Finland
(FIN), British in England and Scotland (GBR), Iberian population in
Spain (IBS), Yoruba in Ibadan, Nigera (YRI), and Luhya in Webuye,
Kenya (LWK). We use ten diploid individuals (i.e. 20 haplotypes)
for each population. We choose the loci where there are few recom—
binations, and then construct gene trees from haplotypes within
these loci. See Wu (2015) for details on how the loci are picked. We
infer one gene tree topology from the haplotypes at each locus.
These gene trees are then used to infer the population trees. Here,
we discard gene trees that have out—degrees at internal nodes of nine
or larger because gene trees with large degrees greatly slow down
the computation. We first infer the population tree for four

13.\'

Fig. 2. The inferred population tree from ten populations in the 1000
Genomes Project using 20 haplotypes from then individual per population.
Branch length shown is the estimated time in coalescent units

populations: CEU, CHB, JPT and YRI. As expected, CHB and JPT
are close siblings and in the population tree, and the ancestral popu—
lation of CHB and JPT is the sibling of CEU. We then infer the
population tree for all ten populations (which takes less than 2h).
The inferred neighbor joining tree is shown in Figure 2. Note that
the tree should be viewed as an un—rooted tree. As expected,
African, European and Asian populations cluster on the tree. The
tree agrees mostly with the result in Wu (2015) with small differ—
ences (e.g. the location of GBR).

6 Discussion and conclusions

In this article, we present the CompactCH algorithm for computing
the gene tree probability under the multispecies coalescent model.
While CompactCH is much faster than the STELLS when the num—
ber of populations is small, computing the exact gene tree probabil—
ity for more populations remains a challenging task (Table 2).
Nonetheless, we show in this article that efficient computation of
gene tree probability for small number of (say two) populations can
find applications in the inference of population history. We believe
the CompactCH algorithm is a step forward for more efficient com—
putation on coalescent models. The key idea of CompactCH is using
compact coalescent histories. While merging multiple entities is a
common idea in algorithm design, designing a working algorithm
for coalescent computation based on this high—level idea is not triv—
ial, as we show in this article. Our work suggests that coalescent
computation can indeed be made more efficient by a well—designed
algorithm [see Wu (2010) for an algorithm that speeds up coalescent
computation under a different formulation].

We note that coalescent histories (in particular the mathematical
properties of coalescent histories) have been actively studied recently
[see e.g. Rosenberg 2013]. Our result presented here demonstrates

12 /310's12u1noip101x0"$0112u1101u101q//:d11r1 111011 pap201um0q

9103 ‘0g1sn8nv uo ::

Algorithm for computing the gene tree probability

i233

 

that computation based on coalescent history can also be improved
computationally. The CompactCH approach may also lead to
speedup in coalescent computation in other formulations, where
more complex coalescent models are used and computational effi—
ciency is highly desirable. For example, the coalescent likelihood
computed by MCMC in Heled and Drummond (2010) considers se—
quences, not the gene trees inferred from the sequences. Our tech—
niques may be applied to speed up the computation of such
likelihood.

Funding: This work is partly supported by US National Science Foundation
grant [115—095 35 63]. Parts of simulations are performed on a computer cluster
that is supported under grant [SlO—RR027140] from National Institutes of
Health.

Conﬂict of Interest: none declared.

References

The 1000 Genomes Project Consortium (2015) A global reference for human
genetic variation. Nature, 526, 64—74.

Degnan,J.H. and Salter,L.A. (2005 ) Gene tree distributions under the coales-
cent process. Evolution, 59, 24—37.

Gusﬁeld,D. (1991) Efﬁcient algorithms for inferring evolutionary history.
Networks, 21, 19—28.

Hein,J., Schierup,M. and Wiuf,C. (2005) Gene Genealogies, Variation and
Evolution: A Primer in Coalescent Theory. Oxford University Press, UK.

Heled,J. and Drummond,A.J. (2010) Bayesian inference of species trees from
multilocus data. Mol. Biol. Evol., 27, 570—580.

Hudson,R.R. (2002) Generating samples under the Wright—Fisher neutral
model of genetic variation. Bioinforrnatics, 18, 337—338.

Hudson,R.R. (1983) Testing the constant—rate neutral allele model with pro—
tein sequence data. Evolution, 37, 203—217.

Kimura,M. (196 9) The number of heterozygous nucleotide sites maintained
in a ﬁnite population due to steady ﬂux of mutations. Genetics, 61,
893—903.

Kingman,J.F.C. (1982) The coalescent. Stochast. Process. Appl., 13, 235—248.

Mirarab,S. et al. (2014) Astral: genome—scale coalescent—based species tree es—
timation. Bioinforrnatics, 30, i541—i548.

Pickrell,J.K. and Pritchard,J.K. (2012) Inference of population splits and
mixtures from genome—wide allele frequency data. PLoS Genet., 8,
e1002967.

Rosenberg,N.A. (2002) The probability of topological concordance of gene
trees and species trees. Theor. Popul. Biol., 61, 225—247.

Rosenberg,N.A. (2013) Coalescent histories for caterpillar-like families.
IEEE/ACM Trans. Comput. Biol. Bioinforrnatics, 10, 1253—1262.

Takahata,N. and Nei, M. (1985) Gene genealogy and variance of interpopula—
tional nucleotide differences. Genetics, 110, 325—344.

Tavare,S. (1984) Line—of—descent and genealogical processes, and their appli—
cations in population genetics models. Theor. Popul. Biol, 26, 119—164.,

Wakeley,J. (2008) Coalescent Theory: An Introduction. Roberts and
Company Publishers, Greenwood Village, CO, USA.

Watterson,G.A. (1984) Lines of descent and the coalescent. Theor. Popul.
Biol., 26, 77—92.

Wu,Y. (2010) Exact computation of coalescent likelihood for panmictic and
subdivided populations under the inﬁnite sites model. IEEE/ACM Trans.
Comput. Biol. Bioinformatics, 7, 611—618.

Wu,Y. (2012) Coalescent-based species tree inference from gene tree topolo—
gies under incomplete lineage sorting by maximum likelihood. Evolution,
66, 763—775.

Wu,Y. (2015) A coalescent-based method for population tree inference with
haplotypes. Bioinforrnatics, 31, 691—698.

12 /310's12u1n0[p101x0'so112111101u101q//:d1111 111011 pap201um0q

9103 ‘0g1sn8nv u0 ::

