BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

Read alignment for resequencing

 

2 APPROACH

Squlto takes the genome hashing approach but uses large con—
tiguous seeds and adaptive stopping to achieve efﬁciencies much
greater than all read aligners tested in this article. Hashing of the
reference genome is a common approach also used in Snap,
Stampy, Novoalign, BFAST etc. Squlto differs from all aligners
surveyed except Snap as it is possible for all overlapping seeds to
be indexed from the reference genome. Squlto also improves
upon Snap by aligning reads with a banded afﬁne—gap penalty
NeedlenamiWunsch. As a result, Squlto is able to make use of
longer reads to improve the alignment of reads with larger indels.
We will show that the large seeds do not hurt alignment sensi—
tivity when the targeted read lengths are greater than about
100 bp. In general, using large contiguous seeds requires huge
amounts of memory to store the index. In order to overcome
this difﬁculty, a novel sub—sampling approach is designed to ﬁt
the entire genome into under 8 GB of memory. The other feature
of Squlto, adaptive stopping, declares each read to be aligned
based on the current best alignment and the number of seeds
examined. This approach works well for Illumina reads where
the majority of errors are due to substitutions rather than gaps. It
also offers users the ability to trade alignment accuracy for efﬁ—
ciency. Overall, the approach taken by Squlto targets
high—quality reads with low number of gaps as errors. When
aligning reads satisfying these criteria, Squlto is extremely fast
and is able to accurately place reads with large insertions or
deletions.

3 RESULTS

Squlto is compared to Snap, Bowtie2, SOAP2 BWA,
Novoalign and Stampy in terms of alignment accuracy and efﬁ—
ciency. Snap is a new read aligner that follows a similar approach
to Squlto, but puts its emphasis on alignment speed. Bowtie2,
SOAP2 and BWA are based on the BWT and are among the
most popular tools for read alignment. Novoalign is a commer—
cial read alignment package not based on the BWT and is among
the most accurate read aligners. Stampy is a relatively new align—
ment tool that is targeted towards resequencing with Illumina
reads similar to Squlto. Stampy was run in hybrid mode, as
recommended by the documentation, where a combination of
BWA with a hash—based approach is used. Squlto is run in
two modes, one with only a sub—set (Section 5.1) of seeds in
the genome indexed (Squlto) and the other with all seeds
indexed (Squlto—all).

A simulated dataset (Section 4) with single and paired—end
reads is used to compare each algorithm. The algorithms sup—
porting gapped alignment are compared at aligning reads with
various indel sizes. The algorithms are also compared with real
Illumina HiSeq 2000 data (Short Read Archive, accession
number SRX100628). Alignment accuracy does not always indi—
cate variants called will be accurate and comprehensive. For ex—
ample, an aligner may place many reads very accurately, but fail
to place a few polymorphic reads. This could result in increased
conﬁdence in already conﬁdent variants, while missing other
variants. Hence, variants are called from simulated paired—end
reads and also the real dataset to directly evaluate the effect of
each aligner on the variants called. All simulations were run with

a single thread on an 8—core 2.27 GHz Intel Xeon X7560 unless
otherwise speciﬁed. An alignment is called correct if its start
location is within 50 bp of the simulated location not counting
bases inserted or deleted. The effect of varying this correctness
criteria is discussed in the Supplementary Material. For Squlto,
22—bp and 28—bp seeds were used for 100—bp and 200—bp reads,
respectively. For Snap, 20—bp and 22—bp seeds were used for
100—bp and 200—bp reads, respectively as suggested by the
author. Exact parameters used for each program can be found
in the Supplementary Material. The %Err given in each table
refers to the percentage aligned incorrectly among the reads sat—
isfying each uniqueness criteria. The elapsed time recorded for
Novoalign and Stampy includes the index loading time since they
do not provide an option to record only the alignment time.
Empirically, the index loading time is independent of the
number of reads aligned and not more than 10(L200 s.

3.1 Simulated single-end reads

One million single—end reads with parameters as described in
Section 4 were generated. The command—line parameters used
for each tool can be found in the Supplementary Material.
Novoalign is not able to align 200—bp reads so it was excluded
from the simulation for that read length.

Table 1 shows the results for 100—bp and 200—bp single—end
reads. For both read lengths, Squlto is significantly faster
than all of the other tools except Snap while retaining excellent
accuracy. Snap is very fast, but not as sensitive as Squlto.
Stampy and Novoalign are both highly accurate. However,
both take much longer to align the reads. SOAP2 and Snap do
not report MAPQ. In addition, SOAP2 was not able to be run in
gapped mode, hence it only outputted ungapped alignments.

3.2 Simulated paired-end reads

1 million paired—end reads with the same parameters as in the
single—end case were generated. The template size was chosen
from a normal distribution with mean 250 bp and 450 bp for
read lengths 100 bp and 200 bp, respectively. A standard devi—
ation of 50 is used for both read lengths. A read is called correct
if both pairs are within 50 bp of the simulated location.

Table 2 shows the results for 100—bp and 200—bp paired—end
reads. Squlto takes advantage of the longer effective read
length of paired—end reads to further improve alignment sensitiv—
ity and accuracy. For 100—bp reads, Squlto is on par with
Stampy and Novoalign in terms of accuracy while being about
10 ><faster. When aligning paired—end reads, BWA tends to
output partial alignments more frequently compared to the
other algorithms, hence its accuracy drops as the read length
increases.

3.3 Simulated large indel reads

Detection of large indels in the genome is of particular interest to
researchers performing resequencing. Although indels larger
than about 25 bp can potentially be detected from pairing infor—
mation, indels that are moderate in size pose a problem to many
aligners. One million 100—bp single—end reads with a single
deletion or insertion of fixed size and a 1% substitution rate
are generated from the human genome. Results for a 2%

 

2367

ﬁlO'SIIZIImOprOJXO'SODBILLIOJLIIOICV/idnq

—X— SquIto(10)
—A— Bowti92(10)
—V— SnaPUO)

—B— Novoalign(10)
—e— BWAUO)

—l—— Stampy/BWA(10)
—e— Stampy/BWA(37)

—><— SquIto(10)
—A— Bovvti92(10)
—v— SnapUO)

—El— Novoalign(10)
—<>— BWAUO)

—I— Stampy/BWA(10)
—e— Stampy/BWA(37)

 

/310'S[BIIJHO[pJOJXO'SOIJBLUJOJIIIOIq/ﬂduq

 

—x— SquIto(10)
—A— BowtieZ(10)
—v— SnapUO)

—E|— Novoalign(10)

—9— BWAUO)
—-l— Stampy/BWA
—e— Stampy/BWA

(10)
(37)

—x— SquIto(10)
—A— Bowti92(10)
—V— Snapﬂ 0)

—El— Novoalign(10)
—<>— BWAUO)

—t— Stampy/BWA(10)
—e— Stampy/BWA(37)

 

 

/310'S[BIIJHO[pJOJXO'SOIJBLUJOJIIIOIq/ﬂduq

J.C.Mu et al.

 

Table 3. Summary of the SNPs and indels called by GATK after align-
ment with each algorithm

Table 5. Summary of the SNPs and indels called by GATK on
Chromosome 1 after alignment of real data with each algorithm

 

 

 

 

 

Aligner Called %Correct %Discovered Aligner Called %dbSNP %Discovered

(a) GATK SNPs called (a) GATK SNPs Called

Squlto 429 949 96.688 98.481 Squlto 252 965 91.212 87.780

Snap 432023 96.078 98.332 Snap 305281 75.623 87.830

Bowtie2 412 753 98.250 96.070 Bowtie2 203 508 95.973 74.304

BWA 426 207 97.466 98.409 BWA 241084 93.324 85.595

Stampy 427137 97.290 98.446 Stampy 218289 93.620 77.747

Novoalign 430 906 96.674 98.686 Novoalign 227 350 92.932 80.380

(b) GATK Indels called (b) GATK Indels Called

Squlto 22 057 99.941 98.477 Squlto 9729 76.986 82.808

Snap 25 563 93.319 90.303 Snap 7399 70.915 58.010

Bowtie2 20 750 99.918 91.809 Bowtie2 8794 80.964 78.718

BWA 21228 99.915 95.174 BWA 8838 80.878 79.027

Stampy 22 696 99.277 98.288 Stampy 10 408 73.770 84.887

Novoalign 20 899 99.947 93.610 Novoalign 9386 78.329 81.282
%Discovered refers to percentage of the known variants in dbSNP found.

Table 4_ Results for real Illumina reads of length 101 bp Let the index be deﬁned as a list of tuples recording the k-mer and the
location in the reference of that k-mer. The index is sorted by the numeric
value of each k-mer for fast searching. Squlto achieves its high speed

Aligner Time %Align %Unique %QlO ﬁrst by using much larger k-mer sizes compared to existing approaches,
examining less repetitive k-mers ﬁrst and by adaptively stopping the

(a) 101-bp real single end reads k-mer search. Large contiguous k-mers greatly reduce the number of

Squlto 545 94.970 88.927 88.339 locations of each k-mer in the reference to mostly unique hits. In general,

Squlto-all 656 95.015 88.944 88.357 large k-mers would reduce the sensitivity of the alignment. However, for

Snap 49 93.661 85.261 * longer reads this choice of k-mer size does not reduce sensitivity as shown

Bowtie2 521 96.122 94.347 86.213 in the simulation results. Furthermore, a novel sub-sampling approach is

SOAP2 1261 90.985 85.575 * used to reduce the amount of memory required for the index to under

BWA 1056 91-826 86-803 86-655 8 GB. Compared to BWT-based approaches for large k-mer search, our

Novoalign 3128 95-582 89-499 89-214 approach requires less random access to memory per index lookup re-

Stampy 1851 98-634 92-866 91-123 sulting in signiﬁcantly improved performance.

(b) 101-bp real paired-end reads

Squlto 1394 96.122 91.117 90.794

Se Alto-all 1627 96.136 91.127 90.803 .

anap 172 88.692 88.692 * 5.1 Index constructlon

Bowtie2 1075 94_ 579 93746 g7_733 A genome index ideally contains the location of all overlapping k-mers in

so AP2 2935 89128 85857 * the genome. Naiver storing all k-mers of size between 17 bp and 32 bp in

BWA 2024 93315 90_494 90_109 one strand of the human genome requires about 36 GB of memory. Using

Novoaﬁgn 4982 93346 90_421 90_239 a combination, of two strategies, we can reduce the size of the index to

Stampy 5003 96.274 92.640 91.623 under 8 GB with only a minor penalty on the sensitivity. This

 

A 22—mer seed was used for Squlto Time measured is elapsed time (seconds).
Unique refers to MAPQ: 1 if MAPQ available. Q10 refers to MAPQ: 10.

5 METHODS

Squlto searches for the global alignment of sequencer reads to a refer-
ence using the commonly known seed and extend approach. There are
three phases to the alignment process: index construction, ungapped
alignment and Needleman7Wunsch extension.

Deﬁne a k-mer (seed) to be a sequence of nucleotides of length k. Each
nucleotide must come from the set {A, C, T, G}. Hence, each k-mer is
encoded as an unsigned integer with 2 bits per nucleotide. On a 64-bit
system, this allows for k-mers of size of up to 32 bp. If the a k-mer has a
nucleotide other than {A, C, T, G}, such as N, it is replaced with a uni-
form random nucleotide since there is only a 2-bit alphabet available.
This encoding is the same approach used in BWA and many other tools.

enables Squlto to be run on almost all desktop computers. These stra-
tegies can be tuned for more powerful computers as they become
available.

At the ﬁrst stage of the index construction, each overlapping k-mer
together with its location is extracted from the genome and stored in an
array W. This array of tuples is then sorted by the k-mer value. Then the
leading m bits are removed from each k-mer such that (2k 7 m) is less than
32. These m bits are stored in a preﬁx array P that records the start and
end locations in W of k-mers tuples preﬁxed with the same m bits. Since
W is sorted, k-mers with the same preﬁx exist next to each other. Now,
only the (2k 7 m) remaining bits of each k-mer needs to be stored in W.
This array of tuples W together with the preﬁx array P form the genome
index. Considering only genomes with less than 4 billion nucleotides, this
two-level index reduces the size of each (k-mer, location) tuple in the
index to 8 Bytes instead of 12 Bytes. Hence, for small preﬁx table sizes
the entire human genome index will only take about 24 G to store. This
index construction also greatly improves the lookup speed over a naive
binary search.

 

2370

ﬁm'spzumofpiopro'sopeuuowrorq/ﬁdnq

Read alignment for resequencing

 

Squlto has the option to not store every k-mer in the reference. In
order to reduce memory consumption without greatly impacting align-
ment, quality and speed of alignment we only store a k-mer if it satisﬁes a
hash function ﬁx), where X is the numeric value of the k-mer. The hash
function ﬁx) is chosen so that there is approximately uniform coverage of
the genome. In Squlto, (1) is used.

ﬁx) = (x (mod 7) = 5)OR(X (mod 17) = 7)
OR(X (mod 19) = 13)OR(X (mod 53) = 31) (1)
OR(X (mod 71) = 47).

Equation (1) was selected so that memory usage for the human
genome is under 8 GB and for Chromosome 1, the median gap size is
3 bp and the largest gap apart from the centromere is 131 bp. Empirically,
there is little loss in sensitivity from using this approach as seen in the
Section 3. In principle, this expression can also be easily tuned for ma-
chines with more memory, as any expression of similar form is adequate.
On machines with 32 GB or more memory, this second step is not
required and a larger index can be constructed for improved sensitivity
and accuracy.

The index is essentially a large sorted list. Hence, it is easy to add
arbitrary additional k-mers to the index with negligible cost to both the
construction and search. k-mers overlapping known SNPs and indels
could easily be added to the index to improve the sensitivity of alignment.
This change would only moderately increase the size of the index.

5.2 Ungapped alignment

The ﬁrst stage of the alignment process is the ungapped alignment stage.
This stage is separate from the gapped stage since we expect that most
gapped reads will not align anywhere in the genome as high-quality
ungapped alignments. This separation also allows for easy interfacing
with a hardware accelerator for the gapped alignment.

Each read is treated separately in the alignment process. All overlap-
ping k-mers are extracted from each read. k-mers satisfying the function
ﬁx) as deﬁned in (1) are retained and the other k-mers are discarded.
Highly repetitive k-mers are also discarded.

Each k-mer is then searched for in the index according to the following
order. Starting with the non-overlapping k-mers, the number of locations
the k-mer exists in the genome is computed from the index. If this number
is less than a predeﬁned variable MAX_LOC, all of the locations are
examined for an ungapped alignment of the read. Once all k-mers with
number of locations less than MAX_LOC have been examined, the other
k-mers are examined. Due to the large k-mer size, many k-mers either
align uniquely to the genome or do not align at all. Hence, the ungapped
alignment stage proceeds very quickly.

Similar to the idea in Baeza-yates and Perleberg (1992), it is not ne-
cessary to examine all k-mers in a read. For instance, reads with no
mismatches should be unambiguously identiﬁed after examining just
one non-overlapping k-mer. By the pigeon hole principle, reads with m
mismatches only require examination of (m + 1) non-overlapping k-mers.
Additional k-mers are examined in order to determine if a read is from
a repetitive region (see Section 5.6). Hence, Squlto decides to stop
examining k-mers according to the following boolean function
g(l. m) = l > (m +2), where m is the number of mismatches and gaps
of the best alignment so far and l is the number of k-mers examined. For
reads with high number of mismatches, this early stopping does not guar-
antee ﬁnding the correct hit. This procedure is described in Algorithms 1
and 2. Overall, this procedure results in Squlto spending less time on
high-quality reads.

If the ungapped alignment outputs a best alignment with penalty score
greater than a single gap open, the read is then examined for a single gap
alignment. At this stage, the location of each k-mer is normalized by sub-
tracting the location of the k-mer in the read. For each pair of normalized
locations with distance smaller than the maximum gap size, the locations

 

Algorithm 1 Ungapped Alignment
I <— 0
m <— 00
while not g([, m) and (exists k—mers unexamined) do
i <— index of next unexamined k imer
5: x <— examine(i’h k—mer)
if x > 0 then

 

I <— I+ 1
end if
if x<m then
10: m <— x
end if
end while

 

 

Algorithm 2 Examine k—mer
i <— index of k—mer to be examined
11 <— number of locations k—mer exists
if n<MAX_LOC then
Mark k—mer i as examined
5: Check all locations of k—mer i for ungapped alignment
return number of mismatches in best alignment
else if all k—mer with n < MAX—LOC examined then
Mark k—mer i as examined
Check all locations of k—mer i for ungapped alignment
10: return number of mismatches in best alignment
else
return—1
end if

 

 

are extended to ﬁnd single gap alignments with at most one mismatch on
each side. This is able to resolve some indels in repetitive regions.

5.3 Needleman—Wunsch extension

All reads that do not align in the ungapped alignment stage are passed to
the Needleman7Wunsch extension stage. The order of examining k-mers
is the same as for the ungapped alignment. Each k-mer location is
searched with a banded Needleman7Wunsch with afﬁne gap penalty to
ﬁnd gapped alignments. The width of the band can be chosen by the user
and by default it finds up to at least 50 bp indels. The same function g(l,
m) is used to determine if the program should continue examining k-mers.
Single instruction multiple data (SIMD) acceleration through SSE2 in-
structions is used to improve the performance of this stage.

5.4 Paired-end alignment

Paired-end information is both used to help search for alignments and
also resolve discordant read pairs. If one read in a pair aligns and the
other read does not, Squlto searches for the remaining read within the
maximum insert size of the pair with a combination of Smith7Waterman
and Needleman7Wunsch. These alignments are ﬂagged in the output
giving the user additional ﬂexibility in post-processing. If both pairs
align with one or more equally good hits, all possible combinations are
checked for a concordant pair. If all possible combinations are discord-
ant, Squlto searches for a concordant alignment within a region around
each alignment deﬁned by the maximum insert size.

5.5 Hybrid mode

For reads much less than 100 bp, Squlto has some trouble aligning reads
in repeat regions and also reads with high numbers of mismatches due to

 

2371

ﬁm'spzumoﬁuqxo'sopeuuowrorq/ﬁdnq

J.C.Mu et al.

 

an inability to locate enough seeds on the reads. In hybrid mode, Squlto
outputs reads with few valid seeds as a FASTQ ﬁle that can be then
aligned with BWA or any other alignment tool. The two resulting
SAM ﬁles can then be merged to produce the ﬁnal alignment.

5.6 Mapping quality score

Mapping quality (MAPQ) scores provide a way for users to judge the
reliability of each alignment. They were ﬁrst introduced in MAQ
(Li et al., 2008) as an estimation of the probability a read was aligned
incorrectly. Accurate calculation of mapping quality considerably slows
down the alignment process since all k-mers should be visited. Despite not
visiting all k-mers, Squlto also provides an estimate of mapping quality.
The mapping quality reported by Squlto is not as speciﬁc as the map-
ping quality reported by other tools. However, in practice there is little
difference.

As discussed in the Mapping and Assembly with Quality (MAQ) art-
icle (Li et al., 2008), there are mainly two sources of alignment error. The
ﬁrst is when the best alignment fails to be reported by the alignment
algorithm. The second is when a read aligns optimally to an incorrect
location due to genetic variation or read errors. Similar to BWA, Squlto
ignores the first source of error and assumes either the best alignment will
be reported or no alignment will be reported at all. Squlto estimates the
second source of error by recording all alignments that differ from the
best by at most one mismatch and also the percentage of the read covered
by highly repetitive k-mers. The formula used is similar to that of BWA
for compatibility with downstream tools.

5.7 Choice of k-mer size

The size of the k-mer seed needs to be selected prior to index construction.
A single size is clearly not optimal for all read lengths. Smaller k-mers will
be too repetitive and larger k-mers will reduce sensitivity. Table 6 displays
the performance with various k-mer sizes.

As indicated in Table 6, 22-mer seeds are optimal for 100 bp reads. For
longer reads, using 28-mer seeds is probably a better choice.

5.8 Multi-threading

Squlto is able to take advantage of modern multi-core computers by
distributing the alignment of each read to multiple threads. There is little
communication between the threads except when reading and writing
ﬁles. Squlto is run in default mode on 1 million 101-bp paired-end
reads from the real Illumina dataset and the alignment time is recorded.

Table 7 shows that Squlto scales well up to at least eight threads
while BWA is limited by its non-parallelized pairing step. An Illumina
HiSeq2000 generates about 600 gigabases of data per run. This translates
to about 3 billion 100-bp pairs. On a modern octa-core workstation com-
puter, Squlto is able to align the 3 billion pairs in about 6 days com-
pared to about 15 days with BWA on the same computer. Considering
one Illumina HiSeq 2000 takes 11 days to generate the sequence data, this
allows one inexpensive desktop workstation to service several large se-
quencers. As read lengths and the quality of sequencer output improves,
these results will become even more signiﬁcant.

6 DISCUSSION

Overall, Squlto is an efﬁcient alignment tool that targets the
future of resequencing where reads are long and high quality.
When aligning longer reads, Squlto is faster than most existing
tools while retaining the ability to accurately align complex vari—
ants. This is particularly important for the high volume of rese—
quencing that will be required as sequencing enters clinical
applications. For convenience, Squlto outputs in the common

Table 6. Alignment performance with various k-mer sizes for 100-bp
single-end reads

 

 

k-mer Time %Aln %Unique [%Err] %Q10 [%Err]
18 218 94.26 89.53 [0.151] 89.15 [0.074]
20 197 94.16 89.44 [0.152] 89.04 [0.077]
22 178 93.94 89.23 [0.167] 88.83 [0.090]
25 151 93.22 88.52 [0.202] 88.12 [0.119]
28 146 91.95 87.30 [0.266] 86.90 [0.167]

 

Time measured in seconds.

Table 7. Speed-up due to multi-threading of Squlto and BWA

 

Squlto BWA

 

Threads Time Speed-up MPH Time Speed-up MPH

 

1 1395 1.0>< 2.58 2010 1.0>< 1.79
2 700 2.0>< 5.14 1121 1.8>< 3.21
4 360 3.9>< 10.00 612 3.3>< 5.88
8 184 7.6>< 19.57 436 4.6>< 8.26

 

Time measured in seconds. MPH stands for millions of pairs aligned per hour.

SAM format that is compatible with numerous downstream ana—
lysis tools.

The comparison of alignment algorithms is primarily per—
formed with simulated reads as real reads do not have a clear
ground truth available. On simulated reads Squlto is shown to
be faster than most current tools and able to accurately align
reads with large indels. When aligning real Illumina reads,
Squlto maintains its efficiency advantage over most of the
tools. This advantage is expected to increase as read quality im—
proves. The ability to align reads with large indels is particularly
evident when variants are called from the aligned reads. Both
GATK and Samtools were able to correctly call more indel vari—
ants from Squlto’s aligned reads from both real and simulated
data compared to all the other tools except Stampy. In the cases
where less variants were called, Squlto was more accurate.

There is a clear trend towards longer read lengths among
high—throughput sequencers. Squlto has been shown to be
ideal for aligning long high—quality reads for the purpose of
resequencing. We expect that the large seed approach taken by
Squlto to be the standard approach for read alignment as the
volume and length of reads increase.

ACKNOWLEDGEMENT

Many thanks to the help and comments from the team at Bina
Technologies Inc. Especially, AJ Minich and Jian Li for help
with running the real variant comparisons.

Funding: John C. Mu, Hui Jiang and Wing H. Wong were
partially supported by National Institutes of Health grants
R01HG004634 and R01HG005717 to Wing H Wong.

 

2372

ﬁm'spzumol‘pmyo'sopeuuowrorq/ﬁdnq

Read alignment for resequencing

 

Conﬂict of Interest: All authors are hold stock in Bina
Technologies inc. John C. Mu partially completed the work as
an intern at Bina. Hui Jiang and Wing H. Wong are scientiﬁc
advisors for Bina. Amirhossein Kiani, Marghoob Mohiyuddin
and Narges Bani Asadi are currently employed at Bina. Narges
Bani Asadi and Wing H. Wong are co—founders of Bina.

REFERENCES

Baeza—yates,R.A. and Perleberg,C.H. (1992) Fast and practical approximate string
matching. In Combinatorial Pattern Matching, Third Animal Symposium.
Springer—Verlag, pp. 1857192.

Burrows,M. and Wheeler,D.J. (1994) A block—sorting lossless data compression
algorithm. HP Labs Technical Reports, SRC—RR—124.

David,M. et al. (2011) SHRiMPZ: sensitive yet practical short read mapping.
Bioinﬁ)rmatics, 27, 101171012.

DePristo,M.A. et al. (2011) A framework for variation discovery and genotyping
using next—generation dna sequencing data. Nat. Genet, 43, 4914198.

Ferragina,P. and Manzini,G. (2000) Opportunistic data structures with applica—
tions. In Proc. 41st IEEE Symposium on Foundations of Computer Science
(FOCS). Redondo, Beach, CA, USA.

Homer,N., Merriman,B. and Nelson,S.F. (2009) BFAST: an alignment tool for
large scale genome resequencing. PLoS One, 4, e7767.

Huang,W., Li,L., Myers,J.R. and Marth,G.T. (2012) Art: a next—generation sequen—
cing read simulator. Bioinformatics, 28, 5937594.

Jiang,H. and Wong,W.H. (2008) SeqMap: mapping massive amount of oligonucleo—
tides to the genome. Bioinformatics, 24, 239572396.

Konagurthu,A.S. et al. (2010) Design of an efﬁcient out—of—core read alignment
algorithm. In Proceedings of the 10th International Conference on Algorithms
in Bioinformatics. pp. 1897201.

Langmead,B.S. and Steven,L. (2012) Fast gapped—read alignment with bowtie 2.
Nat. Methods, 9, 3577359.

Li,H. (2011) A statistical framework for SNP calling, mutation discovery, associ—
ation mapping and population genetical parameter estimation from sequencing
data. Bioinformatics, 27, 298772993.

Li,H. and Durbin,R. (2009) Fast and accurate short read alignment with Burrowsi
Wheeler transform. Bioinformatics, 25, 17544760.

Li,H. and Durbin,R. (2010) Fast and accurate long—read alignment with Burrowsi
Wheeler transform. Bioinformatics, 26, 5897595.

Li,H. et al. (2008) Mapping short DNA sequencing reads and calling variants using
mapping quality scores. Genome Res., 18, 185171858.

Li,R. et al. (2009) SOAP2: an improved ultrafast tool for short read alignment.
Bioinformatics, 25, 196(rl967.

Lunter,G. and Goodson,M. (2011) Stampy: a statistical algorithm for sensitive and
fast mapping of illumina sequence reads. Genome Res., 21, 93(r939.

Malhis,N. et al. (2009) Slidemiaximum use of probability information for alignment
of short sequence reads and snp detection. Bioinﬁ)rmatics, 25, (#13.

Rizk,G. and Lavenier,D. (2010) GASSST: global alignment short sequence search
tool. Bioinformatics, 26, 2534e2540.

The 1000 Genomes Project Consortium (2010) A map of human genome variation
from population—scale sequencing. Nature, 467, 106171073.

Zaharia,M. et al. (2011) Faster and more accurate sequence alignment with snap.
arXiv, arXiv:1111.5572v1.

 

2373

ﬁm'spzumol‘pmyo'sopnuuowrorq/ﬁdnq

