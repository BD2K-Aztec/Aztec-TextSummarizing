Advance Access Publication Date: 27 November 2014

Bioinformatics, 3118), 2015, 1183—1190
doi: 10.1093/bioinformatics/btu780

 

Original Paper

 

Sequence analysis

Faster sequence homology searches by

clustering subsequences

Shuji Suzuki1'2, Masanori KakutaI, Takashi lshida1 and

Yutaka Akiyama1'2'*

1Graduate School of Information Science and Engineering, Tokyo Institute of Technology and 2Education Academy
of Computational Life Sciences (ACLS), Tokyo Institute of Technology, Tokyo 152-8550, Japan

*To whom correspondence should be addressed.
Associate Editor: John Hancock

Received on July 7,2014; revised on October 25, 2014; accepted on November 12, 2014

Abstract

Motivation: Sequence homology searches are used in various fields. New sequencing technolo—
gies produce huge amounts of sequence data, which continuously increase the size of sequence
databases. As a result, homology searches require large amounts of computational time, especially

for metagenomic analysis.

Results: We developed a fast homology search method based on database subsequence cluster—
ing, and implemented it as GHOSTZ. This method clusters similar subsequences from a database
to perform an efficient seed search and ungapped extension by reducing alignment candidates
based on triangle inequality. The database subsequence clustering technique achieved an ~2—fold
increase in speed without a large decrease in search sensitivity. When we measured with metage—
nomic data, GHOSTZ is ~2.2—2.8 times faster than RAPSearch and is ~185—261 times faster than

BLASTX.

Availability and implementation: The source code is freely available for download at http://www.

bi.cs.titech.ac.jp/ghostz/
Contact: akiyama@cs.titech.ac.jp

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

DNA sequencing technologies have improved rapidly. The
HiSeq2500 can produce several hundred billion base pairs (bp) of
sequence data in a single run and its throughput is ~10 000 times
higher than that of old-generation sequencers. Most sequencers pro-
duce information in short fragments (reads) that range in length
from 100 to 1000 bp. Thus, it is necessary to determine the location
of each read in a genome, to use known biological information
even when a reference genome is available. This process is called
mapping, and many effective mapping programs, such as BWA
(Li and Durbin, 2009, 2010) and Bowtie (Langmead and
Salzberg, 2012; Langmead et (11., 2009), have been developed for
this purpose.

In metagenomic analysis, environmental samples frequently
include DNA sequences from many different species, and the

(C7 The Author 2014. Published by Oxford University Press.

reference database often does not contain closely related genome
sequences. Thus, more sensitive approaches are required to identify
novel genes in these samples. In a typical metagenomic analysis,
reads are translated into protein coding sequences and assigned to
protein families by running homology searches against publicly
available databases, such as COG (Tatusov et (11., 1997, 2003) and
Pfam (Finn et (11., 2010). The BLASTX program (Altschul et (11.,
1990, 1997) is commonly used for such binning and classification
searches. To identify homologs that may not have high nucleotide
sequence identities, BLASTX translates nucleotide sequences into
protein sequences, because protein sequences are often more similar
than the original nucleotide sequences (Kurokawa et (11., 2007;
Turnbaugh et (11., 2006). However, the search speed of BLASTX has
become insufficient for analysis of the large quantities of sequence
data now available.

1183

This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/|icenses/by/4.0/), which permits
unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.

/310‘srcumo[p10}xo‘sopcuHOJIItotq/ﬁdnq

Kent, 2002

Ye er [1]., 2011

Murphy et (11., 2000 Manber and Myers, 1993

Zhao
etal., 2012

The Human Microbiome
Project Consortium, 2012

Qin et at, 2010
Gilbert 62‘ (11., 2010

Daniels 62‘ (11., 2013

Vouzis and Sahinidis, 2011

Figure 2

Figure 1

 

 

 

 

 

 

 

 

 

/810'spzumo_fp10}xo"sorJBmJOJurorq/ﬁdnq

Faster sequence homology searches

1185

 

In the database subsequence clustering and seed search processes,
the query and database amino acid sequences are both converted to
a reduced amino acid alphabet to increase search sensitivity.
We used a 10—letter reduced amino acid alphabet (A, {K, R}, {E, D,
N, Q}, C, G, H, {I, L, V, M}, {F, Y, W}, P, {5, T}), which was derived
based on the BLOSUM62 matrix (Murphy et al., 2000). This
reduced alphabet has been used successfully in previously reported
research on homology searches (Ye et 41., 2011). For the ungapped
and gapped extensions, the alignments are performed with the
standard 20 amino acids.

2.2 Database subsequence clustering and construction
of hash tables

The database subsequence clustering approach was developed for
efficient homology sequence searches. In this method, subsequences
in a database are clustered for use in similarity filtering; however,
we do not cluster subsequences for seed themselves used in seed
searches, but instead use longer subsequences, overlapping subse—
quences for seed (Fig. 3). To avoid confusion of terms, we use
‘subsequence for seed’ for subsequences used in general seed
searches, denoted by S. And we use ‘subsequence for clustering”
for subsequences used in the database subsequence clustering and
similarity filtering processes. These are denoted by C. All subse—
quences for clustering depend on a subsequence for seed. Therefore,
GHOSTZ first builds a hash table of subsequences for seed, and
then determines which subsequences should be used for clustering,
using this hash table. Database subsequence clustering is performed
using these subsequences. Therefore, we will first describe the con—
struction of hash tables of subsequences for seed, and then describe
the construction of subsequences for clustering and database subse—
quence clustering.

Here, the text T : TIO. n] : to. . .tn_1 denotes a sequence of sym—
bols and the length of T is (Tl : 11. Each symbol is an element of an
alphabet 2 ((21 of protein is 20). Tli] : t, and TIi.i+/] : ti. . .ti+;_1
are substrings. The sequence of a query is Q. The sequences D0,
D1,. . .,DN_1 in a database are connected by inserting delimiters to
transform them into a single long sequence D : D0D1,. . .,DN_1
(marked by the special symbol ). A seed is a pair of identical or simi—
lar subsequences of Q and D. SQ, : Qli.i+ l] and SD.) : BIL/+1]
is the subsequence of Q and D for a seed, and {SQ,.SD,,'} is a seed.
The hash table used to identify subsequences for seed stores the pair
of hash values of SDJ' and the starting point i of SDJ'.

In BLAST—like seed—extension algorithms, the search speed can
be increased by decreasing the number of seeds. The number of seeds
can be decreased if longer subsequences are used for seeds, because
this decreases the number of randomly matched cases. However,
this also causes a decrease in the search sensitivity. Thus, tolerances
are required in the matching to retain sufficient search sensitivity.

_D_
1

Fig. 3. Relationship between a subsequence used for clustering and the start-
ing position of the seed

In BLASTX, the length of the subsequence for seed is three and
neighborhood words are identified, as well as exact subsequences
(Altschul et 41., 1997). A neighborhood word is a subsequence that
is similar to each subsequence (Altschul et al., 1990). BLAST uses a
large variety of subsequences of each subsequence in a seed search to
increase the search sensitivity using neighborhood words. However,
neighborhood words are ineffective for longer subsequences for seed
because the variety of neighborhood words is great.

GHOSTZ identifies long subsequences by employing a reduced
amino acid alphabet in the seed search. The amino acid alphabet in
the subsequences is converted to the reduced amino acid alphabet,
and then the hash value for this subsequence is calculated. The var—
iety of subsequences for each original subsequence becomes one,
using the reduced amino acid alphabet. In addition, use of the
reduced amino acid alphabet allows GHOSTZ to find longer subse—
quences without a large decrease in search sensitivity. In GHOSTZ,
the length of the subsequence for seed is determined by the sum of
the match scores of the subsequence. Because the frequency of each
amino acid differs in the subsequences, the probability of finding
each particular subsequence is different. Therefore, different subse—
quences may have different lengths. A score definition has previ—
ously been proposed for calculating matches between reduced
amino acid alphabets (Melo and Marti-Renom, 2006). However, in
this study we used a simpler definition. We defined the match scores
of the groups of reduced amino acid alphabets by the largest match
score in the group based on the original score matrix. For example,
in the BLOSUM62 score matrix, the match scores of amino acids F,
Y and W, are 6, 7 and 11, respectively; thus, the match score for the
group including F, Y and W is 11. To avoid insignificant hits, only
subsequences with scores that exceed the score threshold Tseed are
hashed as subsequences for seed. For example, when Tseed : 39,
‘HDGLNP’ is not used in the seed search because its score is 38 and
does not exceed Tseed. However, ‘HDGLNPA’ is used in the seed
search because its score is 42, which exceeds Tseed. In addition, in
our implementation, the length of subsequences for seed is restricted
to 6—8 residues, because a perfect hash function is used.

After building the hash table of subsequences for seed, the subse—
quences for clustering are constructed, and database subsequence
clustering is performed as follows: If i is the starting point of
SDJ' : Dli. j] and L is the length of the subsequence used for cluster—
ing, then let CD, : Dli — L/2. i + L/2] be the subsequence for clus—
tering. For clustering, a subsequence for clustering with i as the
center is used, instead of a subsequence for seed with i as the starting
point. The relationship between CD, and SDJ' is shown in Figure 3.
If CD,- has delimiters, CD, are not used for clustering because CD,
contains the subsequence of several sequences in the database. CD,
becomes a member of a cluster if it has the same hash value of SD.)
as the cluster representative CD.) and the distance between the repre—
sentative of a cluster CD.) and CD, is lower than or equal to the dis—
tance threshold Tcluster. Hamming distance, which is the number of
mismatches between sequences, is used to measure this distance.
To reduce the computation time required for clustering, a greedy al—
gorithm similar to CD—HIT (Fu et 41., 2012; Li and Godzik, 2006)
was employed. The algorithm for database subsequence clustering is
shown in Figure 4. In this algorithm, the first subsequence sampled
always becomes a cluster representative. All subsequences are com—
pared with each cluster representative, and the subsequence becomes
a new cluster representative if it is not a member of any other
cluster. Before running the database subsequence clustering, we
recommend that similar sequences are arranged close to each other
in the input file, using a clustering tool such as CD—HIT, because
this allows the clustering algorithm to cluster subsequences more

ﬁm'srcumol‘prqxo'sopeuuowtotq/ﬁdnq

 

 

 

 

 

1186 S.Suzuki etal.

1: D D The concatenated sequence of a database

2: L D The length of 0D,;

3: Talus)” D The distance threshold of clustering [I [I

4: clusters D The results of clustering

5: build hash table H from D

6: for each hash value h in H do 3 D I]

7: flags R D The ﬂag for representative subsequences

8: members D The lists of members ®

9: for 2' in H.find(h) do
10: build subsequence 0D,,» \
11: f lag M (— false D The ﬂags for member subsequences I] [I
12: if 0D,,- does not have delimiters then
13; for j in H. find(h) do D
14: if j 2 i then
15; break Fig. 5. Relationships among a query subsequence, a representative cluster
16: end if subsequence and a member of the cluster that satisfies the triangle inequality
17: build subsequence 0D,]-
18: if flagsR[j]&(d(CD,,,CD,j) S Tcluster) then
19: add CD7,- to membersLj] distance between $1 and $2. The distance should satisfy the follow-
20: flagM <— true ing triangle inequality:
 endbirfeak 01091.32) 3 01091.33) + c1092., 33) (1)
23: end for If C9,, is the subsequence of the query, MD‘) (C3,) is the sequence
24: end if of a cluster member, and RD), (CD‘k) is the subsequence of a repre-
25: if flagM the“ sentative cluster member, then the lower bound of the distance be-
:S: l flagsRIiI <— false tween RDJ' and MD‘I- from this inequality will be:

: e se

28: flagsR[i] <— true d(CQ.i~,MD./‘) 2 d(CQ.i~,RDJe) — d(RDJe~, Mm) (2)
29: end if . . .
30: end for This lower bound of the distance between C9,, and MD‘) is calcu-
31: Store flagsR and members to Clusters lated, and the seed is extended Without gaps if this lower bound of
32: end for the distance is less than or equal to the distance threshold Tdistance.

33: build the tables Be, Br and Bm from H and clusters

Fig. 4. Pseudo-code for database subsequence clustering

efficiently. After subsequence clustering, the results are used to
construct three tables to be used as indexes for the seed searches.
The Be hash table stores the hash values of SD, and the starting
points i of SD, for the representatives of clusters where the number
of members in the cluster is only one. The B, hash table stores the
hash values of SD}, their cluster IDs and the starting points i of SD‘,‘
that are representative of a cluster (not stored in Be). The Bm table
stores the mapping from the cluster IDs to the starting points i of
SD, whose CD, are members of that cluster. These three tables are
used for the seed search. Examples of Be, B, and Bm are shown
in Supplementary Figure S1A—C.

2.3 Seed search and similarity filtering

The seed search is performed with Be, 3,, Bm and the hash table of
queries. The hash table of the queries is constructed before the seed
search. This hash table contains the hash values of $9,}, the query
IDs and the starting points of subsequences for the corresponding
hash values. An example of a hash table of queries is shown in
Supplementary Figure 51D.

In the seed search, seeds of query subsequences and representa-
tive subsequences in the database are found using Be and B,. If the
seeds are from Be, an ungapped extension is performed because
there are no other subsequences in the cluster. If the seeds are from
B,, the similarity filtering process is performed. Then, the hamming
distance between a query and the database subsequence is calcu-
lated. Given two sequences 81 and 82, we denote by d(S1,Sz) the

The relationships among the query, the cluster representative and
the cluster members are shown in Figure 5. The pseudo-code for the
seed search and similarity filtering is shown in Figure 6.

2.4 Ungapped extension

Gapped extension generally requires large amounts of computation
time; therefore, most homology search algorithms perform an
ungapped extension before a gapped extension. We used an
ungapped extension to filter candidate seeds in the output from
the seed search. Only seeds with ungapped extension scores that
exceed the score threshold Tungapped are stored and extended with
gaps after the ungapped extension is complete. In the ungapped
extension, the cutoff technique that is used in BLAST (Altschul et
al., 1990) is used to accelerate the extension process. The Tungapped
and the other parameters for ungapped extensions are the same as
the BLAST default parameters.

To access memory efficiently when performing the ungapped ex-
tension, seed searches are performed for multiple queries simultan-
eously. If the hash values of query subsequences are the same, their
starting points are packed using the hash table. Then, an ungapped
extension is performed for the queries that have identical hash val-
ues in sequential order, because this increases the cache hit ratio
when accessing the positions of the sequences in the database
(line 9—31 in Fig. 6).

2.5 Chain filtering and gapped extension

Chain filtering is performed after an ungapped extension because
some seeds overlap. Therefore, the number of gapped extensions
can be reduced by merging overlapping seeds. After chain filtering,
the seeds are extended with gaps using a score-limited dynamic
programming technique (Altschul et al., 1997).

/3.IO'S[EIIm0Ip.IOJXO'SOIJEIIIJOJUlolq/ﬂduq

Faster sequence homology searches

1187

 

1: hashquer,es D The hash value of queries

2: positionslistqumies D The list of positions of hashquwies of
each query

3: B,. D The hash table for the representative subsequences in a

database

4: BW D The inverted table for the member subsequences in a
database

5: Tungapped D The threshold for ungapped extension

6: List, D The list of query data passed through similarity
ﬁltering

7: pairs'id.position S; BT-find(ha5hqueries)
8: for idel'uste'r': pr‘ in pairsidqmsitinn do

9: for iqumquumy in positionslistqumies do
10: d <— CalculateDristmLce(iquwy , pqWW7 p,.)
I I: if SirrrilarityFilfer‘mg(d) then
12: add iquerquuew to List,

13: end if

14:  S Tdistance then

15: build seed, by using rig/“my,pqueryJJr-
16: score 9 UngappedEwterrf’ion(seed,)
17: if score > Tungappcd then

18: store seed,

19: end if

20: end if

2]: end for

22: positionsm e Bm.find(idclusmr)

23: for pm in positionsm d0

24: for iq,,€,.y,pque,.y in Listq do

25: build seed", by using imuypwpqmry, pm
26: score 9 UrLgappedEzL'te’nt’ion(seedm)
27: if score > Tungappcd then

28: store seedy",

29: end if

30: end for

3 I: end for

32: clear Listq

33: end for

Fig. 6. Pseudo-code for seed search, similarity filtering and ungapped exten-
sion in the case of multiple cluster members

 

Fig. 7. Flow of the proposed homology search method without database
subsequence clustering for the purpose ofcomparison

2.6 Execution ofthe homology search method without
subsequence clustering

The flow of the homology search without subsequence clustering
is shown in Figure 7. This method is almost identical to that used
in GHOSTZ, except that subsequence clustering and similarity fil-
tering are not used for the seed search. This method, without subse-
quence clustering, was used to evaluate the improvement in
processing time obtained by subsequence clustering. Here, the query
subsequences are searched against all the subsequences in the

database using hash tables. Next, all seeds are directly extended
using the ungapped extension process. Finally, chain filtering is
performed to merge similar seeds, and gapped extension is used to
extend the seed sequences.

3 Results

3.1 Datasets and the computing environment

\We evaluated the performance of the homology searches with and
without subsequence clustering. \We used the amino acid sequences
in the Kyoto Encyclopedia of Genes and Genomes (KEGG) GENES
database (as of May 2013). This database contains ~10 million pro-
tein sequences, which comprise a total of ~3.6 billion residues.
For the query sequences, we used three datasets: soil microbiome
metagenomic sequences (accession number, SRR407548, read
length: 150 bp), human microbiome metagenomic sequences
(accession number, SRS011098, read length: 101 bp) and marine
microbiome metagenomic sequences (accession number,
ERR315856, read length: 104bp). SRR407548 and ERR315856
were obtained from the DNA Data Bank of Japan Sequence Read
Archive, which is a member of the International Nucleotide
Sequence Database Collaboration and which archives data in close
collaboration with the NCBI Sequence Read Archive and the
European Bioinformatics Institute Sequence Read Archive.
SRS011098 was obtained from the Data Analysis and Coordination
Center for the HMP web site (http://www.hmpdacc.org/). \We used
the whole metagenomic shotgun sequencing data from SRS011098.
For all datasets, 10 000 DNA short reads were randomly selected
and used. The evaluation tests were performed on a workstation
with a 2.93GHz Intel Xeon 5670 processor, 54 GB memory and
SUSE Linux Enterprise Server 11 Service Pack (SP) 1.

For the homology search with and without subsequence cluster-
ing, we used a seed score threshold of de:39. Tde was deter-
mined to be similar in sensitivity to RAPSearch. The parameters
used for gapped and ungapped extensions were the same as the
BLASTX default parameters. To perform the database subsequence
clustering efficiently, similar sequences were arranged close to each
other in the database file, based on the results of CD-HIT.

3.2 Relationship between subsequence length and
acceleration ratio and accuracy

The subsequence clustering method has three parameters: the length
of the subsequence L, the distance threshold for the representative
of a cluster wam and the distance threshold for the similarity check
lemncc. The subsequence length L particularly affects the perform-
ance of the search method because 71.1mm and lemnu. depend on L;
therefore, we first determined the optimal length of a subsequence
using L:6, 8, 10, 12 and 14 and fixed distance thresholds of
Tdusm:0.1 L and Tdmmmc:0.2 L. \We used 10 000 randomly
selected DNA short reads from soil microbiome metagenomic se-
quences (SRR407548) and the KEGG GENES database. The accel-
eration ratios with different L for the subsequence clustering search
method over the method without subsequence clustering are shown
in Table 1. As shown, the speed of the search method that included
subsequence clustering increased when L decreased.

The accuracy of the homology search for the different query
sequences was estimated using the search results obtained by the
Smith—\X/aterman local alignment algorithm implemented in
SSEARCH (Pearson, 1991) as the correct result. The performance
was estimated in terms of the fraction of the results that corres-
ponded to the correct result. A search result was considered to be

/310'S[BHm0[pJOJXO'SOIJEIIIJOJIIIOIq/ﬂdnq

III

 

 

 

 

 

III

Fig. 8

Altschul ct £11., 2005

 

 

 

Figure 9 Supplementary Figures S2

Turnbaugh ct a]. (2006)
Kurokawa ct a]. (2007)

Table 2 Supplementary Tables S1

S3

82

/310'S[EUm0prOJXO'SOIJEIIIJOJUlolq/ﬂduq

Faster sequence homology searches

1189

 

Table 3. Memory usage for database construction and homology
search with various database chunk sizes

Table 4. Computation time for database construction and hom-
ology search with various database chunk sizes

 

 

Memory size for Memory size for
constructing index (GB) homology search (GB)

Tool (chunk size)

 

GHOSTZ (128 MB) 5.4 1.4
GHOSTZ (256MB) 10.1 2.2
GHOSTZ (512MB) 21.0 3.8
GHOSTZ (1 GB) 41.0 6.7
RAPSearch 6.9 4.1

 

Note: The ﬁrst, second and third columns show the size of the database
chunks, the memory required for constructing the index (GB) and the memory
required for the homology search (GB), respectively. We searched the KEGG
GENES (3.9 GB) database.

We also measured the search accuracy and computation time
of each tool using different parameters. We used 10 000 randomly
selected DNA short reads from SRR407548 and the KEGG GENES
database. Because it is difficult to compare many plots showing the
results for various parameters, we used single—value accuracy, which
is calculated as the ratio of correctly searched queries to all queries
whose E—values < 1.0 X E_3. These evaluations were performed on
the same workstation used for the other evaluation, but the version
of the operating system had been updated from SUSE Linux
Enterprise Server 11 SP1 to SP3. Using this computing environment
and these measurements, the computation time of GHOSTZ was
396.35 and the accuracy was 0.84. Supplementary Tables 53, S4
and 55 show the accuracy and computation time of RAPSearch,
BLAT and BLASTX, respectively, using different parameters.
RAPSearch showed a drastic decrease in accuracy in the fast mode,
and the accuracy of BLAT was not drastically improved the accur—
acy, even using a smaller tile size parameter. Using the fastest par—
ameter, the accuracy of BLASTX was similar to that of GHOSTZ;
however, the computation time required was much greater.

3.4 Evaluation of memory size

The amount of memory required for running GHOSTZ depends
on the size of database. Current computing systems often have rela—
tively small memory sizes relative to the size of current databases.
Therefore, GHOSTZ divides a database into several chunks.
GHOSTZ sequentially searches each database chunk, and merges its
results with the results of previous chunk searches, when this chunk
division is performed before the construction of its database indexes.
The default chunk size is 1 GB. Using this approach, GHOSTZ dra—
matically reduces working memory requirements. However, even
using this technique, GHOSTZ requires more memory than
RAPSearch. When we used 10 000 randomly selected DNA short
reads from soil microbiome metagenomic sequences (SRR407548)
and the KEGG GENES database, GHOSTZ required ~41 GB of
memory for constructing the indexes of the database, and ~7 GB for
the homology search itself (Table 3). In contrast, RAPSearch
required only ~4 GB for the homology search. However, GHOSTZ
can reduce the memory required by decreasing the database chunk
size. As shown in Table 3, the memory required for GHOSTZ in—
creases nearly linearly in proportion to the size of the database
chunks. If a database is divided into a larger number of chunks, the
memory required decreases accordingly. Of course, a trade—off exists
between database chunk size and search speed. Homology search
computation times increase as the size of a database chunk
decreases. This is so because the number of clusters increases and
the cache hit ratio in ungapped extension decreases. However, the

Tool (chunk size) Computation time (s) Acceleration ratio

 

GHOSTZ (128 MB) 545.2 0.88
GHOSTZ (256 MB) 488.2 0.94
GHOSTZ (512 MB) 479.1 0.96
GHOSTZ (1 GB) 460.8 1.00
RAPSearch 1285.5 0.35

 

Note: The ﬁrst, second and third columns show the size of the database
chunks, the computation time and the acceleration in processing speed
relative to GHOSTZ, respectively, using 1 GB database chunks. We searched
the KEGG GENES (3.9 GB) database.

situation is not dire, as shown in Table 4, the search speed of
GHOSTZ with 128 MB chunks is ~12% slower than that with 1 GB
chunks. Therefore, using smaller database chunks, GHOSTZ is
executable even on a typical PC.

4 Discussion

In the evaluation experiment, GHOSTZ achieved an ~2—fold
increase in speed, relative to GHOSTZ without clustering. This
acceleration can probably be attributed to the reduction in the num—
ber of ungapped extensions that were required when using
GHOSTZ. To validate this hypothesis, we compared the total num—
ber of ungapped extensions required by each method. In the data—
base subsequence clustering approach, similarity filtering requires
comparable computing time to the ungapped extension process;
therefore, we added the number of similarity filterings performed to
the number of ungapped extensions. We found that the number of
ungapped extensions could be reduced to approximately one—third
of the original number using database subsequence clustering.
Currently, ungapped extension is one of the primary bottlenecks
in fast homology searches. Thus, we think that this effective de—
crease in ungapped extensions contributed to the large acceleration
we observed when using subsequence clustering for homology
searches.

CaBLASTP, which is based on a compression approach,
achieved 2.4—3.1—fold faster processing speed than the original
BLASTP (Daniels et al., 2013). The acceleration achieved by
GHOSTZ was ~2—fold faster than the speed of GHOSTZ without
clustering, which is comparable to that of CaBLASTP. However, we
achieved a processing speed that was much faster than that of the
BLAST homology search algorithm. As described earlier, the com—
pression approach used in CaBLASTP requires high search sensitiv—
ity and cannot be applied to faster, but less sensitive, homology
search algorithms. In the initial processing, the compression search
algorithm needs to find remote homologs in a coarse database,
and less sensitive homology search algorithms often fail to find such
sequences. In contrast, the clustering targets used in our approach
are subsequences in a database, which does not depend on search
sensitivity. In addition, GHOSTZ uses hamming distance in data—
base subsequence clustering to measure the dissimilarity between
sequences, whereas CaBLASTP uses sequence similarity. Using
distance allows search seeds to be pruned efficiently using triangle
inequality in an ungapped extension process, contributing to the
acceleration in processing.

GHOSTZ allows the indexes of a database to be constructed
anew, so that users who wish to use other parameters can use this

ﬁm'sreumol‘prqxo'sopeuuowtotq/ﬁdnq

1190

S.Suzuki et al.

 

method. Construction of database indexes for a 1 GB database
requires ~3 h of computation time. However, when a huge number
of DNA reads obtained using next—generation sequencing are to be
processed, the computation time for homology searches is generally
much greater than the time required for database construction.
Therefore, we consider that the computational time involved in
rebuilding database indexes and clustering is not likely to be a prob—
lem in practice.

4.1 Evaluation of computing time for more queries
Reading of database files, including indexes, accounts for a larger
fraction of the computing time required for GHOSTZ, compared
with the other tools evaluated, especially if the number of queries is
small. In Section 3, we used 10 000 queries for evaluation because
of the limitations imposed by our computational resources. Thus,
the performance of GHOSTZ might have been underestimated. To
investigate the point, we evaluated the computation time required
for GHOSTZ and RAPSearch for 1000, 10 000, 100 000 and 1 000
000 queries. The queries were randomly selected from SRR407548
and searched against the KEGG GENES database. These evaluation
tests were performed on a workstation with a 2.93 GHz Intel Xeon
5670 processor, 54 GB memory and SUSE Linux Enterprise Server
11 Service Pack 3. The acceleration ratio of GHOSTZ relative to
RAPSearch is shown in Supplementary Figure S4. When 1000
queries were used, the acceleration was only 2.9. In contrast,
GHOSTZ was ~3.8—fold faster than RAPSearch when the number
of queries was 1 000 000. These results indicate that GHOSTZ
achieves its full potential only when working on a sufficient number
of queries.

5 Conclusion

We developed a new homology search algorithm with subsequence
clustering. We reduced the number of ungapped alignment exten—
sions by clustering subsequences in a database, and achieved a
2—fold acceleration in processing speed without a drop in search
sensitivity. The algorithm was designed for functional and taxo—
nomic annotation in metagenome analysis. The proposed database
subsequence clustering method could also be useful in proteome
research, which requires a huge number of sequence homology
searches.

Acknowledgements

The authors thank Prof. Ken Kurokawa and Dr Takuji Yamada for their
helpful discussion of metagenomic analysis.

Funding

This work was supported by a Grant-in-Aid for the Japan Society for the
Promotion of Science (JSPS) Fellows [Grant number 248766], the Strategic
Programs for Innovative Research (SPIRE) Field 1 Supercomputational Life
Science of the Ministry of Education, Culture, Sports, Science and
Technology (MEXT) in Japan and Cancer Research Development funding
from the National Cancer Center, Japan.

Conﬂict of Interest: Home declared.

References

Altschul,S.F. et al. (1990) Basic local alignment search tool. ]. Mol. Biol., 215,
403—410.

Altschul,S.F. et al. (1997) Gapped BLAST and PSI-BLAST: a new generation
of protein database search programs. Nucleic Acids Res., 25, 3389—3402.
Altschul,S.F. et al. (2005) Protein database searches using compositionally

adjusted substitution matrices. FEBS]., 272, 5101—5109.

Daniels,N.M. et al. (2013) Compressive genomics for protein databases.
Bioinformatics, 29, i283—i290.

Finn,R.D. et al. (2010) The pfam protein families database. Nucleic Acids
Res., 38 (Suppl. 1), D211—D222.

Fu,L. et al. (2012) CD-HIT: accelerated for clustering the next-generation
sequencing data. Bioinformatics, 28, 3150—3152.

Gilbert,J.A. et al. (2010) Meeting report: the terabase metagenomics work-
shop and the vision of an Earth microbiome project. Stand. Genomic Sci., 3,
243—248.

Kent,W.J. (2002) BLAT—the BLAST-like alignment tool. Genome Res, 12,
65 6—664.

Kurokawa,K. et al. (2007) Comparative metagenomics revealed commonly
enriched gene sets in human gut microbiomes. DNA Res., 14, 169—181.

Langmead,B. and Salzberg,S.L. (2012) Fast gapped-read alignment with
Bowtie 2. Nat. Methods, 9, 357—359.

Langmead,B. et al. (2009) Ultrafast and memory-efﬁcient alignment of short
DNA sequences to the human genome. Genome Biol., 10, R25.

Li,H. and Durbin,R. (2009) Fast and accurate short read alignment with
Burrows-Wheeler transform. Bioinformatics, 25, 1754—1760.

Li,H. and Durbin,R. (2010) Fast and accurate long—read alignment with
Burrows-Wheeler transform. Bioinformatics, 26, 589—5 95.

Li,W. and Godzik,A. (2006) CD-HIT: a fast program for clustering and com-
paring large sets of protein or nucleotide sequences. Bioinformatics, 22,
165 8—165 9.

Manber,U. and Myers,G. (1993) Sufﬁx arrays: a new method for on-line string
searches. SIAM]. Comput., 22, 935—948.

Melo,F. and Marti-Renom,M.A. (2006) Accuracy of sequence alignment and
fold assessment using reduced amino acid alphabets. Proteins, 63, 986—995.

Murphy,L.R. et al. (2000) Simpliﬁed amino acid alphabets for protein fold
recognition and implications for folding. Protein Eng., 13, 149—152.

Pearson,W.R. (1991) Searching protein sequence libraries: comparison of the
sensitivity and selectivity of the Smith-Waterman and FASTA algorithms.
Genomics, 11, 635—650.

Qin,J. et al. (2010) A human gut microbial gene catalogue established by meta-
genomic sequencing. Nature, 464, 59—65.

Tatusov,R.L. et al. (1997) A genomic perspective on protein families. Science,
278, 631—637.

Tatusov,R.L. et al. (2003) The COG database: an updated version includes
eukaryotes. BMC Bioinformatics, 4, 41.

The Human Microbiome Project Consortium (2012) Structure, function and
diversity of the healthy human microbiome. Nature, 486, 207—214.

Turnbaugh,P.J. et al. (2006 ) An obesity-associated gut microbiome with
increased capacity for energy harvest. Nature, 444, 1027—1031.

Vouzis,P.D. and Sahinidis,N.V. (2011) GPU-BLAST: using graphics proces-
sors to accelerate protein sequence alignment. Bioinformatics, 27, 182—188.

Ye,Y. et al. (2011) RAPSearch: a fast protein similarity search tool for short
reads. BMC Bioinformatics, 12, 159.

Zhao,Y. et al. (2012) RAPSearch2: a fast and memory—efﬁcient protein
similarity search tool for next-generation sequencing data. Bioinformatics,
28, 125—126.

ﬁm'srcumol‘prqxo'sopcuuowtotq/ﬁdnq

