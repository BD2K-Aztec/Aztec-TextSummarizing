Bioinformatics, 31 (20), 2015, 3262—3268
doi: 10.1093/bioinformatics/btv337
Advance Access Publication Date: 3 June 2015

 

Original Paper

 

Sequence analysis

Assembling short reads from jumping libraries

with large insert sizes

Irina Vasilinetc1, Andrey D. Prjibelski1'2'*, Alexey Gurevich1'2,

Anton Korobeynikov1'2'3

and Pavel A. Pevznerz'4

1Algorithmic Biology Lab, St. Petersburg Academic University 194021, 2Center for Algorithmic Biotechnology,
Institute of Translational Biomedicine, St.Petersburg State University, 199004, 3Department of Mathematics and
Mechanics, St. Petersburg State University, St. Petersburg, 198504, Russia and 4Department of Computer Science
and Engineering, University of California, San Diego, CA 92093-0404, USA

*To whom correspondence should be addressed.
Associate Editor: Inanc Birol

Received on February 12, 2015; revised on May 3, 2015; accepted on May 26,2015

Abstract

Motivation: Advances in Next—Generation Sequencing technologies and sample preparation
recently enabled generation of high—quality jumping libraries that have a potential to significantly
improve short read assemblies. However, assembly algorithms have to catch up with experimental
innovations to benefit from them and to produce high—quality assemblies.

Results: We present a new algorithm that extends recently described EXSPANDER universal repeat
resolution approach to enable its applications to several challenging data types, including jumping
libraries generated by the recently developed lllumina Nextera Mate Pair protocol. We demonstrate
that, with these improvements, bacterial genomes often can be assembled in a few contigs using

only a single Nextera Mate Pair library ofshort reads.

Availability and implementation: Described algorithms are implemented in C++ as a part of
SPAdes genome assembler, which is freely available at bioinf.spbau.ru/en/spades.

Contact: ap@bioinf.spbau.ru

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

In an article titled ‘De novo fragment assembly with short mate-
paired reads: Does the read length matterP’, Chaisson et a1. (2009)
argued that availability of paired reads with long and accurate insert
sizes (rather than the increase in the read length) is the most import-
ant factor for improving the quality of short read assemblies.
However, while paired reads with long insert sizes have been exten-
sively used in many assembly projects, robust generation of read-
pairs with accurate insert sizes proved to be difficult and have only
been achieved recently.

The recently emerged sample preparation technologies open new
opportunities for genome assembly from short reads. For example,
Illumina Nextera Mate Pair protocol generates long inserts (3 kb
and longer) that feature rather tight insert size distribution and small
rate of non-circularized fragments that result in read-pairs with

abnormal distances. As discussed in Chaisson et al. (2009), such
read-pair libraries may enable assemblies approaching the quality of
assemblies from long reads of length equal to the insert size.
Moreover, they can potentially substitute the existing assembly
approaches based on a combination of short paired-end libraries
(with insert size less than lkb) and long jumping libraries (with in-
sert sizes typically longer than lkb) by a pipeline based on a single
Nextera Mate Pair library.

However, even though the popular assembly algorithms perform
well with the previously proposed approaches to sample prepar-
ation, they have not kept up with recent experimental innovations.
To catch up, bioinfomaticians either need to design novel tools for
every technology improvement or to develop a universal assembler
that can be easily modified to support new data types. For example,
Ray (Boisvert et (11., 2010) and SPAdes (Bankevich et (11., 2012)

(C7 The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 3262

/310‘spzumo[p10}xo‘sopcuHOJIItotq/ﬁdnq

Assembling jumping libraries

3263

 

[with the recently implemented EXSPANDER (Prjibelski et al., 2014)
algorithm] use similar approach to repeat resolution that can be
adapted for new types of sequencing data. However, the recently
proposed Nextera Mate Pair libraries present new computational
challenges that go beyond the algorithmic framework of both Ray
and SPAdes. In this work, we describe several algorithmic advances
to EXSPANDER that allows one to efficiently utilize jumping libraries
and to perform assembly using only high—quality Nextera Mate Pair
libraries.

The EXSPANDER algorithm (Prjibelski et al., 2014) is based on the
path extension framework that was proposed by the authors of the
Ray assembler (Boisvert et al., 2010) and later implemented in
the Telescoper (Bresler et al., 2012) and PERGA (Zhu et al., 2014)
assemblers. Given a path P in the assembly graph (Bankevich et al.,
2012; Prjibelski et al., 2014), ExSPANDER iteratively attempts to
grow it by choosing one of its extension edges (all edges starting at
the terminal vertex of the path P). The assembly graph is defined as
simplified de Bruijn graph (Pevzner et al., 2001) of k—mers in reads
after removal of bulges, tips and chimeric edges.

To extend a path P, EXSPANDER computes the scoring function
Scorep(e) for each extension edge e using read—pairs with one read
mapping to P and another read mapping to e (further referred to as
(P, e)-connecting read-pairs). Afterward, EXSPANDER decides whether
to select the top—scoring extension edge or to stop growing P. It itera—
tively repeats the path extension procedure starting with single—edge
paths until every edge in the assembly graph is covered by at least one
path and no path can be extended further. To generate equivalent con—
tigs on both strands, EXSPANDER is implemented as a bidirectional ap—
proach that can extend a path in both directions.

While the scoring function Scorep(e) described in Prjibelski et al.
(2014) works well with short libraries, it appears to be rather ineffi—
cient when using jumping libraries. The key limitation of the previ—
ously defined scoring function is that it analyses only (P, e)—
connecting read—pairs (where e is an extension edge of path P) and
ignores read—pairs that connect path P with other edges. When an
edge e is short and the variations in the insert sizes are large, there is
a danger that no (P, e)—c0nnecting read—pairs exist and thus
Score(P, e) : 0 even if e is the correct extension edge (Fig. 1). Thus,
the decision rule may stop extending path P or even select an incor—
rect extension edge. Additionally, the approach described in
Prjibelski et al. (2014) is inapplicable for scaffolding procedure,
since it is unable to jump over coverage gaps. In this article, we ex—
tend the EXSPANDER approach to scaffolding. This extension is im—
portant since scaffolding with jumping libraries may dramatically
improve the assembly quality.

We describe several algorithms that address these bottlenecks
based on the following idea. Consider a set of extension paths 5
[rather than extension edges as in Prjibelski et al. (2014)] that con—
tain all sufficiently long paths (longer than the insert size) starting
from the extension edges of the path P. Once the set 5 is constructed,

1

p1 p2 f2

     

f3

Fig. 1. An example of the assembly graph with path P : (phpz) (blue) and its
correct short extension edge 6 (red). In this case, there may be no (P, e)—con-
necting read-pairs, but there may be (P, f1)-connecting read-pairs since the
correct genomic path includes the path (p1, pz, 6, f1), which is shown in green
above the graph

we choose the best—scoring path E in 5 and extend path P by the first
edge of E. Our analysis has shown that such conservative extension
(by the first edge of the best—scoring extension path rather than by
the entire path) provides more accurate assemblies. To perform scaf—
folding procedure, we allow extension paths to ‘jump’ over coverage
gaps in the assembly graph.

This intuitive approach, while appealing, is often impractical
since the assembly graph is usually tangled, resulting in a prohibi—
tively large number of extension paths. To reduce the running time,
we have implemented the new algorithm based on the observation
that, instead of the exhaustive search through the set of all extension
paths, one can significantly prune this set using single reads and
paired—end libraries (if available).

We demonstrate that the new algorithm enables assemblies of
nearly complete genomes from a single Nextera Mate Pair library.
We also show that SPAdes, coupled with the improved EXSPANDER
algorithm, outperforms other popular assemblers, such as ABySS
(Simpson et al., 2009), IDBA—UD (Peng et al., 2012), Ray (Boisvert
et al., 2010), SOAPdenovo (Li et al., 2010) and Velvet (Zerbino and
Birney, 2008) on various types of datasets.

2 Methods

2.1 The exSPAnder framework

2.1.1 Rectangles

ExSPANDER utilizes the concept of the rectangle graph introduced by
Bankevich et al. (2012) and further developed in (Vyahhi et al.,
2012). Let e and e’ be edges in the assembly graph (see (Bankevich et
al., 2012) for the construction of the assembly graph) separated by a
known distance D and (r, r’) be a read—pair, such that read r maps to
e at position x0 and read r’ maps to e’ at position yo (Fig. 2a). We
note that while D is not known a priori, EXSPANDER only considers
edges that are connected by a previously constructed path, which
unambiguously defines distance D.

Figure 2b shows the read—pair (r, r’) represented as a point (x0,
yo) within the rectangle formed by the edges e and e’. We further
refer to this rectangle simply as (e,e’ Because of variations in the
insert sizes, real read—pairs connecting edges e and e’ typically corres—
pond to the points that are scattered in the confidence strip—a strip
between the 45° lines 3! : x — dmin and y : x — dmaX within the rect—
angle (e, e’) (Fig. 2c), where

dmin : D — 1min + ReadLength,
dinax : D _ Imax ‘I' ReadLength.

Here, [Imim Imaxl is the confidence interval of the insert size distri—
bution defined as the smallest insert size interval that contains at
least 80% of read—pairs. Since reads may have variable lengths (e.g.
after quality trimming or error correction), we set ReadLength as
the maximal read length across all reads in the current library.

2.1.2 The decision rule

The decision rule relies on the scoring function that will be described
in the next section. To extend a path P, we score all extension edges
e1, . . . ,en and select e, as a correct extension if the following condi—
tions are met:

1. Scorep(e,) > C- Scorep(ey) for all/ 9E i
2. Scorep(e,) > 6)

Here, C and G) are the EXSPANDER parameters described in
(Prjibelski et al., 2014). If no extension edge meets these conditions,
the algorithm stops growing path P.

/310‘Sjcumo[p10}xo‘sopcuHOJIItotq/ﬁdnq

 

 

3254 I. Vasilinetc et al.
r r’ where the density value is defined as
,— ,—
1‘0 I yo I Ob d ( )
0—)0- - - - - - - - - - - )o—n serve .. e.
e e' DensityD (phey) : ﬂ.
D ‘/ ExpectedDU (pi, Bf)

yo

63;

62;

 
     

___-_-____-__»_

 

‘L
‘E

1’1 P2 :03

Fig. 2. (a) A read-pair (r, r’) mapping to edges 6 and e’ in the assembly graph
at positions X0 and yo, respectively. (b) Read-pair (r, r’) is represented as a
point (X0, yo) in the rectangle (e, e’). (c) Since the insert size varies, most read-
pairs correspond to the points scattered within the confidence strip in the
rectangle (e, e’). (d) An example of a composite rectangle formed by paths P
: (p17p27p3) and E : (61,62,63), which consists of nine simple rectangles.
Note that the confidence strip crosses only five out of nine simple rectangles.
The points outside the confidence strip appear in eight out of nine simple
rectangles and represent read-pairs with abnormal insert sizes

In the case of multiple read-pair libraries, we process them in the
order of increasing insert sizes until a certain library provides an ex-
tension edge satisfying the decision rule. We stop growing path P if
no library provides an extension edge satisfying this rule. Processing
libraries in a step-by-step fashion (rather than incorporating all
libraries at once) has proven to result in more accurate and continu-
ous assemblies.

2.2 Scoring function
Given a path P : (p1,p2,  ,pn) and its extension path E : (e1,e2,
. ,em), the composite rectangle for paths P and E is formed by n - m
simple rectangles (p,, e,) (Fig. 2d). The distance D,, between a pair of
edges p, and e, according to the paths P and E is equal to
n f—l
Diy- : Z Length(pk) + Z Length(e[).
le:i [:1
We define the following variables [see Prjibelski et al. (2014) for
more details]:

' Expectele/(piwf): the expected number of (p,, e,)-connecting
read-pairs;

' ObservedD,,(pi,ef): the observed number of (p,, e,)-connecting
read-pairs.

To filter out rectangles filled by chimeric read-pairs, we use the
support function

1, DensityDl/(pi,ef) > ‘P
Supporto, (Pia er) I

0, otherwise

Thus, ExSPANDER ignores rectangles with a density lower than a
pre-defined threshold ‘P.

While this approach worked well for short libraries, our bench-
marking revealed that it deteriorates for long jumping libraries that
typically have a higher rate of read-pairs with abnormal insert sizes
(referred to as chimeric read-pairs).

We thus define a new support function that evaluates whether
a simple rectangle (p,, e,) within the composite rectangle (P, E) can
be considered as trusted and used for calculating the scoring
function:

1, ObservedD,,(pi,ef) > r]
Supporto, (Pie 6/) I

0, otherwise

where r] is a user-controlled parameter with very conservative de-
fault value 11 : 30.

While it is not clear how to select optimal 11, our analysis of the
distribution of the number of chimeric points within all rectangles
across a wide range of bacterial genomes revealed that hardly any
rectangles contain more than 30 chimeric points. We note that by
setting the parameter 11, one essentially ignores the contribution
from small rectangles containing less than 11 points. While it may ap-
pear that we unfairly ignore small rectangles, our benchmarking re-
vealed that this approach actually improves the assembly quality.
Moreover, the users can change the parameter r] in the case of as-
sembly projects with unusually low or high coverage.

When the extension path contains a single edge e, ExSPANDER
uses the following path-edge scoring function:

Z SupportD‘ (pi, e) - Expectele (pi, e)
i:1

 

Scorep(e) :

Z Expectele (pi, e)

i:1

In this article, we generalize this path-edge scoring function to a
path—path scoring function as follows:

nm

ZZSupportDU (pi, Bf) - ExpectedDU (pi, Bf)
Scorep(E) : 1:1]:1 n

ZiExpectedDU (pi, Bf)

i:1 ):1

 

Given a confidence interval [ImimImax] of the insert size distribu-
tion, we call a path long if its length exceeds 11mX and short other-
wise. The algorithm that we describe below limits attention to the
long extension paths (e1,e2, . . . ,em) whose prefix (e1,e2, . . . ,em_1)
is short. Given a path P, for each extension edge e, of P, we con-
struct a set of extension paths 5. A top-scored path E in E is called a
representative path for edge e (Fig. 3a). The score of the extension
edge e is now defined as the score of its representative path, i.e.
Scorep(e) : Scorep(E).

The new approach to define Scorep(e) can be applied to the
libraries with both short and long insert sizes. While the resulting
improvements are significant for long insert sizes, they appear to be
minor for the libraries with small insert sizes. Thus, in the default
ExSPANDER mode, the new scoring function is used only for the
jumping libraries.

[310'sp2umofp105xo'sopeuHOJIItotq/ﬁdnq

Assembling jumping libraries

3265

 

 

Fig. 3. (a) An example of path Pin the assembly graph (shown in blue) and its
extension edges 91 and 9;. The representative path for 91 is shown in red
above the graph, whereas another extension path for 91 (with lower score) is
shown in orange. (b—d) A step-by-step example of the work of
ExtensionSearch algorithm for constructing extension paths (marked orange)
for edge 91 using the pre-constructed paths from the set 8 (shown as five
green paths in the top figure). At each step, the ExtensionSearch algorithm
grows an extension path E (that is shorter than lmax) using only E—consistent
extension edges (with respect to S)

2.3 Constructing extension paths

In the case of long libraries, the Depth-First Search (DFS) algorithm
for exploring all paths and selecting representative paths becomes
rather slow, e.g. the number of extension paths can reach millions
even for a bacterial genome. To decrease the number of extension
paths, we developed the ExtensionSearch algorithm that uses a set
of pre-constructed paths 5 that are generated by the previous
EXSPANDER algorithm (Prjibelski et al., 2014) using single reads and
short paired-end libraries if they are available.

We use the notation Suffix(E, l) [and Prefix(E, l)| to refer to a
path formed by the last (first) ledges of a path E. For a path E and a
set of pre-constructed paths 5, we say that an extension edge e of
path E is E—consistent (with respect to S) if 5 contains a path E’,
such that Suffix(E + e. l) : Prefix(E’. l) for some l> 0. Instead of ex-
tending a path E by all its extension edges (like in the DPS algo-
rithm), ExtensionSearch uses the following heuristics to construct
extension paths:

‘ Extend a path E only by E-consistent extension edges;
‘ Extend only paths that are shorter than Imax.

As the result, we obtain a set of extension paths that ‘comply’
with the set of pre-constructed paths 5 with length at least Imax
(Fig. 3b—d).

 

 

(a) 51  61
° >0 >° c = >’/\+ : >0
8 V /
82 e2 6

Fig. 4. An example of a simple bulge (a) and simple loop (b) consisting of
edges 91 and 9;. A simple bulge (loop) is formed by two parallel (anti-parallel)
edges between two vertices. Regions used for calculating the local coverage
in the vicinity ofthe loop are marked with bold segments

ExtensionSearch greatly reduces the number of the extension
paths when compared with the DPS algorithm. However, in the
tangled regions of the assembly graph with many bulges (corres-
ponding to variations in repeats) and loops (corresponding to tan-
dem duplications), the number of paths is still high (Fig. 4). For
example, each bulge potentially doubles the number of extension
paths explored by the EXSPANDER algorithm (e.g. ExtensionSearch
can select either of edges el and e; in Fig. 4a). Each loop potentially
multiples the number of extension paths by the (unknown) multipli—
city of the loop (i.e. the number of times the loop traverses the edge
e; in Fig. 4b). In the ExtensionSearch, we focus only on simple
bulges (Fig. 4a) and simple loops (Fig. 4b) since they represent the
majority of all cases that may trigger the increase in the running
time of the algorithm.

To limit the explosion of the extension paths, we add the follow-
ing constrains to the ExtensionSearch algorithm:

‘ For each bulge formed by two edges, only the top-scoring edge is
used as an extension edge.

‘ Each simple loop is traversed as a ﬁxed number of times equal to
the estimated multiplicity of the loop. The loop multiplicity is
estimated as the closest integer to Chop/Claw], where (3100}, is the
average read coverage of the loop edges, and Claw] is the read
coverage in the vicinity of the loop, i.e. the average read coverage
of the last ReadLength nucleotides of edge e and ﬁrst
ReadLength nucleotides of edge e’ (Fig. 4b).

Our benchmarking has demonstrated that the described modifi-

cations reduce the running time by an order of magnitude.

2.4 Scaffolding

2.4.1 Jumping over the coverage gaps

Existing genome assemblers are often complemented by scaffolding
tools such as Bambus (Pop et al., 2004), Opera (Gao et al., 2011),
SCARPA (Donmez and Brudno, 2013), SOPRA (Dayarian et al.,
2010) and SSPACE (Boetzer et al., 2011) to improve the contiguity
of the resulting assemblies. However, most of these scaffolding tools
work with contigs rather than the assembly graphs and none of
them uses the rectangle framework that EXSPANDER utilizes. We thus
added a rectangle-based scaffolder to EXSPANDER and evaluated its
performance.

jumping from an out-tip to an in-tip. A coverage gap typically
creates a pair of tips in the assembly graph [see Bankevich et al.
(2012) for detailsl formed by an out—tip (an edge that ends in a ver-
tex with out-degree O) and an in-tip (an edge that starts in a vertex
with in-degree 0). We further refer to these tips as paired tips. Since
coverage gaps are usually short, read-pairs from the jumping libra-
ries often span them. Below we describe how ExtensionSearch finds
pairs of tips and uses them for scaffolding.

Let E be an extension path for a path P, such that E ends with
an out-tip e and Length(E) < In”X (Fig. 5a). To further extend path
E, we search for an in-tip paired with e by considering a set of
P-supported edges, i.e. all edges e’ that have (P. e’)-connecting

/810's12um0_fp10}x0'saueuuogutotq/ﬁduq

3266

l. Vasilinetc et al.

 

JUMPING OVER COVERAGE GAPS IN THE ASSEMBLY GRAPH
FROM AN OUT -TIP To AN IN -T|P

 

JUMPING OVER COVERAGE GAPS IN THE ASSEMBLY GRAPH
FROM AN OUT -TIP To AN INTERNAL EDGE

 

E2

E1

o——"'

Fig. 5. Jumping over coverage gaps in the assembly graph from an out-tip to
an in-tip: (a) an extension path E(marked red) ending with an out-tip e; (b) the
only P—supported edge e’ is an in-tip (marked green); (c) the path E is ex-
tended by an edge 6’ with a gap (red line). Jumping over coverage gaps in
the assembly graph from an out-tip to an internal edge: (d) the only P—sup-
ported edge e’ is not an in-tip (marked green) and (e) paths E1 and E2 that
start with in-tips and contain P—supported edge 6’, both paths are considered
as possible extensions for E(shown by red lines)

read-pairs. Since the set of P—supported edges typically contains
many false short edges (due to high rate of chimeric read-pairs in the
jumping libraries), we filter out all P-supported edges shorter than a
certain threshold (default value is 500 bp).

Figure 5b presents a simple example when there is only one P-
supported edge e’ and this edge is an in-tip. We then consider e and
e’ as paired tips and extend the path E by edge e’ with a gap
(Fig. 5c). Since the size of a gap is difficult to estimate using a jump-
ing library with large insert size variation, we assign a fixed length
to each gap (100 bp by default). Once we extended the path E with
an edge, we continue growing E using ExtensionSearch until its
length exceeds Imax.

jumping from an out-tip to an internal edge. A more difficult
(and more common) case is illustrated in Figure 5d, where there
exists only one P—supported edge e’ and this edge is not an in-tip.
Such situations arise when the in-tip paired with e is either not
P—supported or is shorter than 500 bp (and thus ignored). To grow
the path E in such cases, we consider all in-tips in the assembly
graph and extend them further using ExtensionSearch limiting

the path length to 11mX — Length(E). Afterward, we select only
paths that contain edge e’ and use them as potential extensions for E
(Fig. Se).

When assembling real datasets, we often encounter several
P—supported edges longer than 500 bp. In this case, we apply the
strategy described above, i.e. extend the paths starting from every
in-tip and choose paths containing at least one P-supported edge. If
some of the extension paths remain shorter than Imax, we continue
growing them with the ExtensionSearch algorithm.

However, growing paths from every in-tip can be extremely
time-consuming, especially for single-cell datasets that often contain
thousands of coverage gaps. To address this issue, we implement the
described approach the other way around: instead of starting a path
from every in-tip, we start growing paths from P—supported edges in
the reverse direction and select only those that reach an in-tip. Since
the number of long P—supported edges is typically much smaller than
the number of all in-tips in the assembly graph in the case of single-
cell assemblies, this implementation greatly reduces the running
time of ExSPANDER.

2.4.2 Jumping over complex subgraphs

Even after applying the described heuristics for run-time reduction,
there are cases when the number of extension paths remains huge.
Such cases are often associated with complex subgraphs of the as-
sembly graph (typically formed by short repeats with high multiplic-
ities). To keep the running time under control, ExSPANDER stops
growing a path if the number of its extension paths exceeds a thresh-
old. The threshold is automatically calculated based on the number
of edges in the assembly graph (e.g. the threshold value is set to 50
for graphs with > 10 000 edges).

A better approach is to use jumping libraries and to ‘jump over’
complex subgraphs in the assembly graph (instead of generating all
extension paths traversing these complex subgraphs). If the ‘size’ of
a complex subgraph is smaller than the insert size, a path P may
start on ‘one side’ of this subgraph and be connected with edges on
the ‘other side’ of this subgraph, thus allowing us to jump over the
entire subgraph and to continue growing P. The question is how to
identify such complex subgraphs and jump over them.

To jump over complex subgraphs, we first identify a path P with
unusually large number of extension paths. Afterward, we find all
P—supported edges and order them using the rule: an edge e’ follows
an edge e if e’ can be reached by ExtensionSearch within a certain
distance starting from e. If all P—supported edges can be ordered into
a single list, we extend path P by the first edge in this list (with a

gap).

3 Results

To evaluate how availability of Nextera Mate Pair libraries affects
the quality of assembly, we assembled several bacterial genomes
using multicell datasets provided by Illumina (Nextera Mate Pair
libraries only). In this article, we describe benchmarking
(using seven different assemblers and three scaffolders) on
Meiothermus ruher str. 21 T (Tindall et al., 2010) Nextera Mate Pair
library and additionally, on Escherichia coli st. K12 suhst. MG1655
(Blattner et al., 1997) single-cell dataset that contains both a short
paired-end library and a long jumping library. Results for other
Nextera Mate Pair libraries are presented in the Supplementary
Material.

Since the assemblers we used for comparison were not designed
for assembling Nextera Mate Pair libraries, we have conducted

[310'sp2umofp105xo'sopeuuoprtotq/ﬁdnq

Tindall etal.,2010 Blattner er al., 1997

23 90.3 1475

I 0 9 9

ALLPATHSALG " I . . 50.," 3801

SOAPdenm‘o

 

Simpson et al., 2009 Boisvert et
al., 2010 Li et al., 2010
Zerbino and Birney, 2008 Chitsaz et al., 2011

Peng et al., 2012
Prjibelski et al., 2014

Gao et al.,
2011 Donmez and Brudno, 2013
Boetzer et al., 2011

Supplementary Material

Gurevich et al., 2013 Chin
et al., 2013

Table 2

Table l
Gnerre et al., 2011

Table 2

/810'sleumofp103xo"soueuuogutotqﬂ:duq

3268

l. Vasilinetc et al.

 

Acknowledgement

We would like to thank Ilya Chorny from Illumina for providing various
datasets for Nextera Mate Pair libraries, which are now available at Illumina
BaseSpace public repository (https://basespace.illumina.com).

Funding

This study was supported by the Russian Science Foundation [14-50-
00069]

Conﬂict of Interest: none declared.

References

Bankevich,A. et al. (2012) SPAdes: a new genome assembly algorithm and its
applications to single-cell sequencing. Comput. Biol., 19, 455—477.

Blattner,F.R. et al. (1997) The complete genome sequence of Escherichia coli
K-12. Science, 277, 1453—1462.

Boetzer,M. et al. (2011) Scaffolding pre-assembled contigs using SSPACE.
Bioinformatics, 27, 578—579.

Boisvert,S. et al. (2010) Ray: simultaneous assembly of reads from a mix of
high-throughput sequencing technologies.]. Comput. Biol., 17, 1519—1533.

Bresler,M. et al. (2012) Telescoper: de novo assembly of highly repetitive re-
gions. Bioinformatics, 28, 311—317.

Chaisson,M. et al. (2009) De novo fragment assembly with short mate-paired
reads: does the read length matter?. Genome Res, 19, 336.

Chin,C.-S. et al. (2013) Nonhybrid, ﬁnished microbial genome assemblies
from long-read SMRT sequencing data. Nat. Methods, 10, 563—569.

Chitsaz,H. et al. (2011) Efﬁcient de novo assembly of single—cell bacterial gen-
omes from short-read data sets. Nat. Biotechnol., 29, 915—921.

Dayarian,A. et al. (2010) SOPRA: Scaffolding algorithm for paired reads via
statistical optimization. BMC Bioinformatics, 11, 345.

Donmez,N. and Brudno,M. (2013) SCARPA: scaffolding reads with practical
algorithms. Bioinformatics, 29, 428—434.

Gao,S. et al. (2011) Opera: reconstructing optimal genomic scaffolds
with high-throughput paired-end sequences.  Compnt. Biol., 18,
16 8 1—1 6 91.

Gnerre,S. et al. (2011) High-quality draft assemblies of mammalian genomes
from massively parallel sequence data. Proc. Natl. Acad. Sci. USA., 108,
1513.

Gurevich,A. et al. (2013) QUAST: quality assessment tool for genome assem-
blies. Bioinformatics, 29, 1072—1075.

Li,R. et al. (2010) De novo assembly of human genomes with massively paral-
lel short read sequencing. Genome Res, 20, 265—272.

Peng,Y. et al. (2012) IDBA-UD: A de novo assembler for single—cell and meta-
genomic sequencing data with highly uneven depth. Bioinformatics, 28,
1—8.

Pevzner,P.A. et al. (2001) An Eulerian path approach to DNA fragment assem-
bly. Proc. Natl. Acad. Sci. USA, 98, 9748—9753.

Pop,M. et al. (2004) Hierarchical scaffolding with Bamhus. Genome Res, 14,
149—159.

Prjibelski,A.D. et al. (2014) EXSPAnder: a universal repeat resolver for DNA
fragment assembly. Bioinformatics, 30, i293—i301.

Simpson,]. et al. (2009) ABySS: a parallel assembler for short read sequence
data. Genome Res, 19, 1117—1123.

Tindall,B.]. et al. (2010) Complete genome sequence of Meiothermns rnher
type strain (21T). Stand. Genomic Sci., 3, 26—36.

Vyahhi,N. et al. (2012) From de Bruijn graphs to rectangle graphs for genome
assembly. In: Raphael,B. and Tang,]. (eds) Workshop on Algorithms in
Bioinformatics 2012, volume 7534 of Lecture Notes in Computer Science,
Springer Berlin Heidelberg, pp. 200—212.

Zerbino,D.R. and Birney,E. (2008) Velvet: Algorithms for de novo short read
assembly using de Bruijn graphs. Genome Res, 18, 821—829.

Zhu,X. et al. (2014) PERGA: a paired-end read guided de novo assembler for
extending contigs using SVM and look ahead approach. PLoS One, 9,
e1 1425 3.

ﬁm'spzumol‘pmjxo'sopcuuowtotq/ﬁdnq

