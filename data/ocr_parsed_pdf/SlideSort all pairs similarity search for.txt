ORIGINAL PAPER

Vol. 27 no. 4 2011, pages 464—470
doi: 1 0. 1093/bioinformatics/btq677

 

Sequence analysis

Advance Access publication December 9, 2010

SlideSort: all pairs similarity search for short reads

Kana Shimizulai‘ and Koji Tsudala2

1Computational Biology Research Center, National Institute of Advanced Industrial Science and Technology (AIST)
and 2EFIATO Minato Project, Japan Science and Technology Agency, Japan

Associate Editor: Alex Bateman

 

ABSTRACT

Motivation: Recent progress in DNA sequencing technologies calls
for fast and accurate algorithms that can evaluate sequence similarity
for a huge amount of short reads. Searching similar pairs from a
string pool is a fundamental process of de novo genome assembly,
genome-wide alignment and other important analyses.

Results: In this study, we designed and implemented an exact
algorithm SlideSort that finds all similar pairs from a string pool in
terms of edit distance. Using an efficient pattern growth algorithm,
SlideSort discovers chains of common k-mers to narrow down the
search. Compared to existing methods based on single k-mers, our
method is more effective in reducing the number of edit distance
calculations. In comparison to backtracking methods such as BWA,
our method is much faster in finding remote matches, scaling easily
to tens of millions of sequences. Our software has an additional
function of single link clustering, which is useful in summarizing short
reads for further processing.

Availability: Executable binary files and C++ libraries are available
at http://www.cbrc.jp/~shimizu/slidesort/ for Linux and Windows.
Contact: slidesort@m.aist.go.jp; shimizu-kana@aist.go.jp
Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on August 19,2010; revised on October 27, 2010; accepted
on December 3, 2010

1 INTRODUCTION

Due to the dramatic improvement of DNA sequencing, it is
required to evaluate sequence similarities among a huge amount
of fragment sequences such as short reads. We address the problem
of enumerating all neighbor pairs in a large string pool in terms of
edit distance, where the cost of insertion, deletion and substitution is

one. Namely, given a set of 11 sequences of equal length L S1,...,Sn,
the task is to ﬁnd all pairs whose edit distance is at most d,
E={(i,j)|EditDist(si,sj)§d,i<j}. (1)

It is conventionally called all pairs similarity search.

All pairs search appears in important biological tasks. For
example, it is required in ﬁnding seed matches in all pairs alignment
necessary in sequence clustering (Abouelhoda et al., 2004). Such
alignments can then be used to detect and correct errors in short
reads (Qu et al., 2009). In the ﬁrst step of de novo genome
assembly (Simpson et al., 2009; Zerbino and Bimey, 2008), short

 

*To whom correspondence should be addressed.

reads are decomposed to k-mers, and sufﬁx—preﬁx matches of length
k — 1 are detected. In most cases, exact matches are employed due to
time constraint. Using approximate matches, the length of contigs
can be extended, which leads to ﬁnal assembly of better quality. This
problem reduces to all pairs similarity search by collecting all k— 1
preﬁxes and sufﬁxes into a sequence pool. From the output, only
preﬁx—sufﬁx pairs are reported.

Basically, most popular methods solve the search problem by
either of the following two approaches or a combination of them.
(i) Finding a common k-mer and verify the match (Lipman and
Pearson, 1985; Simpson et al., 2009; Warren et al., 2007; Weese
et al., 2009; Zerbino and Bimey, 2008). (ii) Backtracking in an
index structure (i.e. sufﬁx array and FM-index) (Langmead et al.,
2009; Li and Durbin, 2009; Li et al., 2009; Rajasekaran et al., 2005;
Sagot, 1998; Trapnell et al., 2009). The ﬁrst type ﬁnds common
k-mers in strings (i.e. seed match) and verify if two strings sharing
the k-mer are neighbors indeed by extending the match with dynamic
programming. It works perfectly well when the string is long enough.
However, when strings are short and the threshold d is large, the
length of shared k-mers falls so short that too many candidate
pairs have to be veriﬁed. The second type stores the strings into
an index structure, most commonly a sufﬁx array. Then, similar
strings are found by traversing nodes of the corresponding sufﬁx
tree. This approach works ﬁne if d is small, e.g. d f 2, and employed
in state-of-the-art short read mapping tools such as BWA (Li and
Durbin, 2009), bowtie (Langmead et al., 2009) and SOAP2 (Li et al.,
2009). However, it becomes rapidly infeasible as d grows larger,
mainly because the complexity is exponential to d and no effective
pruning is known. ELAND and SeqMap (Jiang and Wong, 2008)
decompose sequences into blocks and use multiple indices to store
all k-concatenations of blocks. Obviously, it requires much more
memory compared with BWA, which would be problematic in many
scenarios. Multisorting (Uno, 2008) uses multiple substring matches
to narrow down the search effectively, but it can ﬁnd neighbors in
terms of Hamming distance only.

Our method termed SlideSort ﬁnds a chain of common substrings
by an efﬁcient pattern growth algorithm, which has been successfully
applied in data mining tasks such as itemset mining (Han et al.,
2004). A pattern corresponds to a sequence of substrings. The
space of all patterns is organized as a tree and systematically
traversed. Our method does not rely on any index structure to avoid
storage overhead. Instead, radix sort is employed to ﬁnd equivalent
strings during pattern growth. To demonstrate the correctness of
our algorithm, the existence of a common substring chain in any
neighbor pair is proved ﬁrst. In addition, we deliberately avoid
reporting the same pair multiple times by duplication checking.
As a result, our method scales easily to 10 million sequences and is

 

© The Author(s) 2010. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non—Commercial License (http://creativecommons.org/licenses/
by—nc/2.5), which permits unrestricted non—commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.

112 /3.Io's[Bumo[pJOJXO'sorquJOJurorqn:duq 11101} pQPBOIIIAAOG

9103 ‘0g1sn8nv uo ::

SlideSort

 

much faster than seed matching methods and sufﬁx arrays for short
sequences and large radius.

The rest of this article is organized as follows. Section 2 introduces
our algorithm. In Section 3, results of computational experiments are
presented. Section 4 concludes the article.

2 METHOD

Two similar strings share common substrings in series. Therefore, we can
detect similar strings by detecting chains of common strings systematically.
Before proceeding to the algorithm, let us describe fundamental properties
ﬁrst. Divide the interval 1, . . .,E into 1) blocks of arbitrary length w1,...,w;,,
2L] W,’ :6. The starting position of each block is deﬁned as (1,»: 1 +

Z]:in The alphabet is denoted as 2. We assume that each string in the

database {Xi}?: 1 consists of 6 letters, s, e lZ lf. Given two strings s, t, s = t
holds if all letters are identical. The substring from positions i to j is described
as s[i , j].

A pattern of length k is deﬁned as a sequence of strings and block indices,

X=[(XI.y1).---I(Xk.yk)]

wherexi e lElwyr‘ , 15y] <y2, . . . , <yk 5 1). Pattern X matches to string s, with
offsetp=(pl,...,pk), if

s,»[qyf+pj,qyf+pj+wyf—1]=xj, forallj=1,...,k.
All occurrences of X in the database are denoted as
C(X) = {(i,p) |Xmatchessi with offsetp}.

For convenience, an index set I (X ) is deﬁned as the set of sequences
appearing in C(X). The number of sequences in I(X) is deﬁned as l] (X )|.

The relationship between neighbor pairs and patterns are characterized by
the following theorem.

THEOREM 1. If si ana1 sj of equal length 6 are neighbors, i.e. Ea'itDist(s,*, sf) 5
a1 , i < j, there exists a patternX of length I) —a1 such thatX matches s, with zero
aﬁ‘set (pl :17; = . . . =[7b—d = 0) and matches sj with bounded oﬁset — |_a'/2j 5
pk 5 |_a'/2j , k=1,...,b—a’.

PROOF. There are multiple possible alignments of s, and sf. An alignment
is characterized by the number of matches m, that of mismatches f , that of
gaps g, in s, and that of gaps g in sj.The length of s, is equal to m+f+gj
and that of sj is m+ f + g, because any letter in s, is aligned to either a letter
in sj or gap symbol in sj and Vice versa. Thus, we obtain gizgj 5 La1 /2j
by taking into account that the maximum number of gaps does not exceed
a’. Therefore, an aligned position of any letters is within a bound of La1 /2j
letters from its original position.

Let us divide s, into 1) blocks of length w1,...,w;,. Since the number of
mismatches are at most a’, at least b—a’ blocks match exactly with their
counterparts in sj in any alignment. Also, since aligned positions are bound
within |_a1 / 2] from their original positions, the matching counterpart of any
block of s, can be found in sj within offset between — |_a1 / 2] and La1 /2j. I

Figure 1 illustrates an example of patterns with b =5,a1 :3. This theorem
implies that any neighbor pair has a chain of b—a’ common blocks and the
corresponding blocks lie close to each other. It serves as a foundation of our
algorithm presented later on.

X={("AT",1 ), ("AGC",3 )}
3.- in I GOT | 39;: | GAG IACT
s, metilmnenuct

Fig. 1. An example pattern for block size 5 and edit-distance threshold 3.
s, matches to X with no offset in the ﬁrst block and the third block. sj matches
to X with no offset in the ﬁrst block but with —1 offset in the third block.

2.1 Pattern growth

In our algorithm, all patterns X of |I(X)| 32 are enumerated by a recursive
pattern growth algorithm. In a pattern growth algorithm, a pattern tree is
constructed, where each node corresponds to a pattern (Fig. 2). Nodes at
depth k contain patterns of length k.

At ﬁrst, patterns of length 1 are generated as follows. For each block y 1 =
1, ...,a'+1, a string pool is made by collecting substring of {s,»}l’.‘:l starting
at qyl — |_a'/2j,...,qyl + |_a'/2j. Applying radix sort to the string pool and
scanning through the sorted result, repetition of equivalent strings can be
detected (Fig. 3). Each pattern of length 1, denoted as X], is constructed as
a combination of the repeated string x1 and y 1 ,

X1<—{(x1w)}-

At the same time, all occurrences C (X 1) are recorded. If s, matches the same
pattern X1 by several different offsets, only the smallest offset is recorded.
They form the nodes corresponding to depth 1 of the pattern tree.

Given a pattern X, of length t, its children in the pattern tree are generated
similarly as follows. For each yt+1 2y, + 1, . . . ,a1 +t+1, a string pool is made
by collecting substrings of I(X,) starting at gym — |_a'/2j ,...,qyr+l + |_a'/2j.
Because the string pool is made from the occurrence set only, the size of the
pool decreases sharply as a pattern grows. By sorting and scanning, a next
string xt+1 is identiﬁed and the pattern is extended as

Xt-i—l <—Xt+{(xz+1~Yz+1)}~

and the occurrences C(X,) are updated to C(X,+1) as well.

To avoid generation of useless patterns, the pattern tree is pruned as soon
as the support falls below 2. Also, the tree is pruned if there is no string
in I(X) that matches X with zero offset. As pattern growth proceeds in a
depth-ﬁrst manner, memory is reserved as a pattern is extended, and then
immediately released as the pattern is contracted to Visit another branch.
This dynamic memory management keeps peak memory usage rather small.

2.2 From patterns to pairs

As implied in Theorem 1, every neighbor pair (Fig. 1) appears in index set
I (X ) of at least one pattern. Since one of the pair must have zero offset, the
set of eligible pairs is described as

PX = {(i,j)|i <j, i,j e I(X), s, matcheszith zero offset}.

Since not all members of PX correspond to neighbors, we have to verify if
they are neighbors by actual edit-distance calculation.

A problem here is that the same pair (i, j) possibly appears in the index
set of many different patterns. It is also possible that pair (i , j) in the same
index set is derived from different offsets. In most applications, it is desirable
to ensure that no pair is reported twice. The straightforward solution of the
problem is to check if a new pair is previously reported by storing all pairs,
which requires huge amount of memory. We propose an alternative solution
that rejects non-canonical pairs without using any extra memory as follows.

A match of s, and sj can occur in various ways, each of which can be
described as the tuple (y,p), wherey =y1 , . . . ,yb_d describe the blocks in the
pattern and p is the offset with which the pattern matches sf. We deﬁne the
canonical match as the one with lexicographically smallest y and p, where
priority is given to y. For example, consider the case s, =AATT, sj =ATAT,
a1 = 2 and all block widths set to 1. There are 10 different (y,p) pairs as shown
in Figure 4, where matching residues are shown in red squares. In this case,
(1) is canonical. Among them, the matches with overlapping squares do not
have correct alignment. We do not exclude such pairs to avoid an extra run
of dynamic programming.

To judge if a given match (y,p) is canonical or not, it is sufﬁcient to
check if there exists another match that is lexicographically smaller. More
precisely, the match represented by y,p is not canonical, iff there exists a
block 1 Sz 5 max(y),z ¢y and an offset — |_a'/2j 5 r5 |_a'/2j such that

siIQZvQZ‘l'Wz—llzstQZ‘l—erZ‘l'r‘l'Wz—ll- (2)

This canonicity check can be done in 0(a'E) time.

 

465

112 /3.Io's[Bumo[pJOJXO'sorwurJOJurorqn:duq uroii papeolumoq

9103 ‘0g1sn8nv uo ::

K.Shimizu and K. Tsuda

 

d=2. w1=w2=w3=3

pusiuml23456'i‘89 
51 ATATAGCTA 
52 TATAGGTAG 
53 TTATAGGTA 

gu-

 

E'.‘

i:
L

rm] yi—I
449  p={0} m

52. n=~{1} ATA
51. p={1} TAT
2. p={0} TAT
. p={1} TAT
. HO} TTA as

)'2—2
51. p={0.0} TAG X2=[(‘ATA'.1).(‘TAG'.2)I

“cm.” W —

saga-am %
51. p={u,1} A60 33
52 g=11 01MB
52. n={1, 1} GOT 33

51. p=IIAOI 
$2. FI={U.-1}TAG 3:
53. p={1.0} TAG
st. p={1,-1}ATA
52. p={1,-1}ATA x

mm,” s. p={1.1} A60

52‘ F3403} AGE x2=rrTATznerc22n

53, p={1.1} ABC
52. IJ={U.1} GOT 3%

Fig. 2. Pattern growth and pruning process of the proposed method. Patterns are enumerated by traversing the tree in depth-ﬁrst manner. In each node, new
elements are generated by sorting substrings in sequence pool (‘ATA’, ‘TAT’, ‘TTA’ for y 1 = 1). Useless patterns (‘TTA’ in this case) are removed. Remaining
elements are added to yield new patterns. This process is executed by recursive call until the pattern size reaches 1) —a’.

 

 

 

AAAATT MAMA
ATATGT MAMA
MAAM so AAMTI
ATATGT ‘2 ATATGT
MAAM ATATGT
ATATGT ATATGT

 

 

 

Fig. 3. Discovery of equivalent strings by radix sort.

(1} "AE'=V={1.2}I.P={O.1} [51"A "=Y={2.3}l.p={1.-1}
A TT T
A T T
{2} "AT":V={1.3}}.D={0.-1} 1?} "AT":V={2.3}LD={1,1}

AyT
A AT

(31" T"IV=Il.3}l,p={0.1}

A%
T A
{4} " T"=\t={1.4}},p={0.0} [9} "'IT”IV={3.4}I. p={-1,0}

AAT A

[3} "AT"IV={2.3}I.P={'1:1}

%

|>>

 

 

A T A A A
(51 "AT": v={2.3}}. p=t-1.-1} [101“1'F"rv={3.4}i.p={1.0}
T “SE

Fig. 4. All (y,p) ofsi =AATT, sj =ATAT. Matching residues are shown in red
squares. Since the red squares overlap in (6) and (10), they do not correspond
to correct alignment.

Pseudocode of the overall algorithm is shown in Algorithm 1. In line 18,
it sufﬁces to compute diagonal stripe of width 2d+1 of DP matrix. Thus,
the distance calculation is performed in 0(a'E) time.

2.3 Remarks

With small modiﬁcation, SlideSort can deal with gap opening and gap
extension penalties. Deﬁne the gap open and extension cost as ya and
14,, respectively. Denote the number of mismatches, gap opens and gap
extensions as f , g0 and g9, respectively. Then our all pairs similarity search
problem is reformulated as ﬁnding pairs such that f +g0y0 + g9 ye 5 a1 . Denote

the number of gaps in each sequence as g, and gj. Then, ggzgi+gj and
g032 (if g9 750), g0=0 (if gg=0) by deﬁnition. When g9 750, we have
(gi+gj)ygfa’—2y0. Since the lengths of two sequences are equal, the
number of gaps is also equal, g, =gj, leading to the following inequality,

31':ng I(d/2_ 70)/Vel-
Therefore, the offsets pk, for k: 1, . . .,b—a’, are bounded by

-L(d/2—J/a)/J/el SPAS I(d/2_y0)/Vel- (3)
When g9 :0, we can ﬁnd all pairs by zero offsets, hence the offset range
(3) covers this case as well. Notice that the block size I) must be larger
than max(a', |_a1 /(y0+yg)j ). This modiﬁcation is effective to reduce both
computation time and memory space when ya and ye are larger than
substitution cost.
It is worthwhile to notice that SlideSort can handle sequences of slightly
different lengths without any essential modiﬁcation. See a Supplementary
Method in Supplementary ﬁle 1 for details.

2.4 Complexity

Denote by a: |E| the alphabet size. Space complexity of SlideSort is
0((b—a’)a'nlogn+n€loga), because it requires an pointer array to describe
the pattern tree, and the original strings must be retained. Denote by m
the number of all pairs included in the index set I(X). Time complexity of
SlideSort is 0(deIa'I’TdEn+ma'E), in which the ﬁrst part is for sorting and
the latter part is for edit-distance calculations. The time complexity depends
on the effectiveness of pruning through In. The worst case of the latter part
becomes 0(n2a1 B) when all the input short reads are identical. In most cases,
however, short reads are quite diverse and m is expected to scale much better
than 0(n2).

The all pairs similarity search problem can be solved by ﬁnding
approximate non-tandem repeats in the concatenated text of length n6. An
enhanced sufﬁx array can solve it with 0(EdTIUdn) time and 0(nlogn+
nEloga) space (Abouelhoda et al., 2004). This time complexity is essentially
achieved by producing all variants within distance a1 of all sequences and
ﬁnding identical pairs. The difference is that the time complexity of the sufﬁx
array depends on the alphabet size and that not of SlideSort. Thus, SlideSort
can be applied to large alphabets (i.e. proteins) as well.

3 EXPERIMENTS

From NCBI Sequence Read Archive (http://www.ncbi.n1m.nih
.gov/sra/), we obtained two datasets: paired-end sequencing of

 

466

112 /3.Io's[BurnoTpJOJXO'sorwurJOJHrorq”:duq urori papeo1umoq

9103 ‘0g1sn8nv uo ::

SlideSort

 

 

Algorithm 1 SlideSort

1. function SLIDESORT
SlideSortRecursive(¢, (1))
3. end function
4. function SLIDESORTRECURSIVEO’ , X)
5 if y=¢ then
6. m <— 1
7
8
9

 

.N

go to line 26
end if
. if |I(X)| <2 then
10. return
11. end if
12. if no strings in I(X)match X with zero offset then
13. return

|> Pruning by frequency

14. end if

15. if Ly|=b—d then

16. for (i,j)ePX do

17. if (i, j) is canonical then |> See equation 2
18. if EditDist(sl-,sj) 3d then
19. Report (i,j)

20. end if

21. end if

22. end for

23. return

24. end if

25. m=max(y)+1
26. forz=m,---,d+Lv| do

27. R <— (j)

28. for — |_d/2j f r f |_d/2j do |> Generate a string pool
29. R<—RU{s[qz+r,qz+r+wz—1]|seI(X)}

30. end for

31. Sort and scan R to ﬁnd the set of new elements X

32. for all (xnew,z) e X do

33. SlideSortRecursive(y + {z},X+ {(xnew,z)})

34. end for

35. end for
36. end function

 

Human HapMap (ERR001081) and whole genome shotgun bisulﬁte
sequencing of the IMR90 cell line (SRR020262). They will be
referred to as dataset 1 and 2, respectively. Sequence length of
dataset 1 is 51 and that of dataset 2 is 87. Both datasets were
generated by Illumina Genome Analyzer II. Reads that do not
include ‘N’ were selected from the top of the original fastq ﬁles.
Our algorithm was implemented by C++ and compiled by g++.
All the experiments were done on a Linux PC with Intel Xeon
X5570 (2.93GHz) and 32 GB RAM. Only a single core is used
in all experiments.

As competitors, BWA (Li and Durbin, 2009) and SeqMap (Jiang
and Wong, 2008) are selected among many alternatives, because
the two methods represent two totally different methodologies,
backtracking and block combination. BWA is among the best
methods using index backtracking, while SeqMap takes an
ELAND-like methodology of using multiple indexes for all block
combinations. SlideSort is also compared to the naive approach that
calculates edit distances of all pairs. BWA and SeqMap are applied
to all pairs similarity search by creating an index from all short reads
and querying it with the same set of reads.

Notice that both BWA and SeqMap are not originally designed
for all pairs similarity search but for read mapping, which requires
a larger search space. Although fair comparison is difﬁcult between
tools of different purposes, we used mapping tools as competitors,
because no tool is widely available for all pairs similarity search, to
our knowledge.

For our method, the number b of blocks has to be determined.
In the following experiments, we set b relative to the distance
threshold d as b=d+k. Here, k corresponds to the pattern size.
In the following experiments, we tried k= 1,...,5 and reported the
best result.

The number of neighbor pairs for both datasets are shown in
Supplementary Figure S1. We conﬁrmed that both SlideSort and
the naive approach reported exactly the same number of neighbor
pairs, which ensures correctness of our implementation of SlideSort.

3.1 Computation time and memory usage

Figure 5 plots computation time against the distance threshold d.
SlideSort is consistently faster in all conﬁgurations. As the number
of sequences grows and the distance threshold is increased, the
difference from BWA and SeqMap becomes increasingly evident.
Not all results are obtained, because of the 30 GB memory limit
and 300 000 s time limit. Figure 6 compares peak memory usage of
SlideSort, SeqMap and BWA. We separately measured the memory
usage of the indexing step and searching step for BWA, because
BWA is designed to execute those steps separately. The peak
memory of BWA for the search step is the smallest in most of the
conﬁgurations, while that of SlideSort is comparable or slightly
better than BWA’s peak indexing memory. Detailed results for
100 000 short reads are shown in Table 1.

BWA is most efﬁcient in space complexity, because its index size
does not depend on the distance threshold. Instead, BWA’s time
complexity rapidly deteriorates as the edit-distance threshold grows
due to explosion of the number of traversed nodes in backtracking.
In contrast, SeqMap indexes and hashes all the combination of key
blocks, which leads to huge memory usage. SlideSort is similar to
SeqMap in that it considers all block combinations, but is much more
memory efﬁcient. The difference is that SlideSort is an indexing free
method, which dynamically generates the pattern tree by depth-ﬁrst
traversal. It allows us to maintain only necessary parts of tree in
memory.

3.2 Effect of pattern size

Figure 7 investigates the inﬂuence of pattern size k on the efﬁciency.
Except for d = 1, the best setting was around k =2—4. Our method
k = 1 roughly corresponds to the single seed approach, so this result
suggests the effectiveness of using chains. Overall, the computation
time was not too sensitive to the choice of k.

3.3 Comparison to single seed

Our algorithm employs a chain of common substrings to narrow
down the search. Compared with the single seed approach that uses
a k-mer to derive candidate pairs, the total length of substrings
can be much larger than the k-mer without losing any neighbors.
It yields higher speciﬁcity leading to a smaller number of candidate
pairs. Instead of a chain, one can detect multiple k-mers and verify
those pairs containing multiple matches (Burkhardt and Karkkainen,
2002). However, this approach has lower speciﬁcity in comparison

 

467

112 /3.Io's[BurnoTpJOJXO'sorwurJOJHrorq”:duq uror} papeo1umoq

9103 ‘0g1sn8nv uo ::

K.Shimizu and K. Tsuda

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

10000 reads 100000 reads 1000000 reads 10000000 reads
‘1‘ In
+— +— .. m_ m—
2 4‘ g ' _ x__.___.$I E: “a E: I,’
.x-—-r’->< m x  ‘1— e" t— ’ 0
8Tx" . A’.' +— a" E 2, E x, /
‘—_ a 2_ ,_'+' — _ r —A o
-_.  r a-  8-3' /=* 8— /
a /o — its /0 '- o v- c
U ,_-0_F'_#—o g/ _0/ _
a: Q— '—.— .—_ .__
3 0 I I I a I I I I I I I I
"g 1 3 s 1 s 1 3 5 1 3 5
5 q‘ {n
E $- nir- _,x.— --X LEE -' A "'3 ’
.— ﬂ - .-- . «u a It I
u _ 1x _>< + .13 .. A-— .. I
x__ -.X_-‘,"" m .-A," E_ z E_ A o
.3- /“" $— - r‘ -— A, -— 5’ /
_ 9 ‘—_ I — , _ o
. v +,’ r
'__El 043 O Eta /,o §_O/
_._._,_,..--‘O '— f _ /o _
—_o.--"'""_O _0/ o
‘33— -.— .—— .——
0 I I I ‘3 I I I I I I I I
1 3 5 1 5 1 3 5 1 3 5
Edit distance threshold —9— SlideSort Aer BWA
-x- naive -+- SeqMap

 

 

 

L 135 919 p

Z 13S]? 12 p

Fig. 5. Computation time on the two short read datasets. Among the four methods, ‘naive’ represents the exhaustive distance calculation.

0
o
In
0
In
E
Em
.._.
OJ
m.—
TO
to
D
)\
.—
O
50
2?.
0
m
m

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

10000 reads 100000 reads 1000000 reads 10000000 reads
x x 'I ."
_ f _ ' _ " — I
. , . .
(f E {I g x" u§1 3': _ _ éﬁg
_ ,' o — .’ c, — . I o T
' -x' 8 ‘ .’ 3 ‘ .r' 9. '
I; ' >< Bz—-— — éF—rn
:X" o : , 7 c: :  D :
Ln . . Lﬁ If!
f— — —  O _S— — — 9 ﬂ C) _ O _
I I I '— l I I '— l I I T I I I
1 3 1 3 5 1 3 5 1 3 5
X x f I’-
_ x _ - _ I _ ,
_ , . _
:  g :  g :  g :
ll.’< «n X- In g-J“8“‘e m
: '7 o : ,"- ca :' ' ' D :
é---e---e  m m
_ Cr c: _ o _
I I I '— l I I '— l I I T I I I
1 3 5 1 3 S 1 3 5 1 3 5
Edit distance threshold —6— SlideSort as BWAIIndexJ
- K- SeqMap BWAlsearch}

 

 

 

|_ 13591913

Z laSEIEp

Fig. 6. Memory usage on the two short read datasets. BWA’s memory usage is separately evaluated for the indexing step (index) and the search step (search).

Table 1. Computation time on 100 000 short reads

 

 

 

Dataset 1 Dataset 2
SlideSort BWA SeqMap Naive SlideSort BWA SeqMap Naive
Index Search Index Search
d=1 0.2 2.34 3.25 7.68 8743.46 0.33 5.07 6.91 39.59 15 678
d=3 0.85 2.37 562.63 205.26 23 796.1 1.84 5.09 1647.16 10698.6 39 046.3
d=5 6.56 2.19 19 697.67 93115.2 38179.5 5.56 5.08 12876.88 >300000 65 244.6

 

 

468

112 ﬁlo's[Bumo[p101x0's01112u1101urorqn:duq urori popeo1umoq

9IOZ ‘OE ISUEHV Ho ::

SlideSort

 

to the chain of the same total length, because the matching positions
of each elements of the chain are strictly localized due to Theorem 1.

Figure 8 compares the number of candidate pairs generated by our
method and single seed (k-mer in plot). It corresponds to the number
of edit-distance calculations. We have two variations of the single
seed method: ‘k-mer/nonredundant’ stores previously reported pairs
in memory, and does not include previously reported pairs in
candidates. ‘k-mer/redundant’ does not use additional memory but
counts the same pair multiple times. Here we set the length of the
k-mer to [/d so that no neighbors are lost. In the plot, one can
see a signiﬁcant reduction in the number of candidate pairs in our
algorithm. Notice that the number of candidate pairs is shown in
log scale. In our method, the number of candidates is minimum
at the largest pattern size, because the total length of substrings
is maximized and speciﬁcity becomes optimal. However, since the
search space of patterns is expanded, the total computation time is
not optimal in this case.

3.4 Clustering analysis of short reads

A main application of SlideSort is hierarchical sequence clustering,
which would be used in correcting errors in short reads and
preprocessing for metagenome mapping, for example. SlideSort
provides an undirected graph G, where vertices represent short
reads and weighted edges represent edit distances of neighbor
pairs. Among hierarchical clustering algorithms, single link is
most scalable (Manning et al., 2008). Since the dendrogram of

 

 

 

 

 

 

 

 

 

 

 

 

 

dataset 1 dataset 2
‘ +.
o + ,+ +  +d=1 —A 11:: »+ d=5
a _ ».+.. + ----- " o _ 
_ 9, - +'-».
o A 
ﬂ 8 _ A q + .....  +
E g_ ___A—---A----A"" o
3 N “ A "A
n. — ‘77‘A“"A-‘
U
.,, _
o oﬂo ° o m o o o o 0
N _
I I l I I I I I I l
1 2 3 4 5 1 2 3 4 s
k k

Fig. 7. Comparison of performance of the proposed method with different
k evaluated on 1 000 000 short reads.

single link clustering is isomorphic to the minimum spanning
tree (Gower and Ross, 1969), one can perform single link clustering
via minimum spanning trees (MSTs) construction by the Kruskal or
Prim algorithm (Kruskal, 1956; Prim, 1957).

Since storing all edges can require a prohibitive amount of
memory, we used a well-known online algorithm for building
MSTs (Tarjan, 1983). It creates MSTs from a stream of edges,
discarding unnecessary edges along the way. It essentially maintains
all cycle-free connected components and, if a cycle is made by a new
edge, it removes the heaviest edge from the cycle. In our experiment,
the additional computation time for ﬁnding MSTs was trivially small
compared with that of SlideSort ﬁnding similar pairs (Table 2).
Figure 9 visualizes largest MSTs found in 10000 000 short reads
of dataset 2 with edit-distance threshold 3 by the 3D visualization
tool Walrus (http://www.caida.org/tools/visualization/walrus/).

4 CONCLUSION

In this study, we developed a novel method that enumerates all
similar pairs from a string pool in terms of edit distance. The
proposed method is based on a pattern growth algorithm that can
effectively narrow down the search by ﬁnding chains of common
k-mers. Using deliberate duplication checks, the number of edit
distance calculations is reduced as much as possible. SlideSort was
evaluated on large datasets of short reads. As a result, it was about
10—3000 times faster than other index-based methods. All these
results demonstrate practical merits of SlideSort.

One naturally arising question is if SlideSort can be used for
mapping. In fact, it is possible by storing the pattern tree (Fig. 2) in
memory, and using it as an index structure. However, the index
would cost too much memory for genome-scale data. What we
learned from this study is that all pairs similarity search is essentially
different from mapping in that one can employ pruning and dynamic
memory management. Thus, all pairs similarity search is not a
subproblem of mapping and deserves separate treatment.

In future work, we would like to implement SlideSort with parallel
computation techniques. Recent progress in hardware technology
enables end-users to use many types of parallel computing scheme
such as SSE and GPGPU. SlideSort would be further improved by
using these technologies.

 

 

 

 

 

 

 

 

 

 

 

dataset 1 dataset 2
k—mer length k—mer length
25 12 8 43 21 14
O
I I I 1 I 9L 3;
3 § _* a" 3 a" —e— SIideSort(k=1)
'5 E SlideSort(k=2)
3 1 , E _ SIideSort(k=3)
E- 15 g - — ' 9< - SIideSort(k=4)
E $ _ v; , — ’ \D -<>- SlideSort(k=5)
'c -— ,s E 0 3 _ -V- k—mer/redundant
g m v g . — ’ / g + k—mer/nonredundant
“8 o .—' -élé naive
+ — gr 0 V 96 . .
9 g 7,, _ e neighbour pairs
E 61")” ,
:1 A 9 2 / <$ 3 2 ’T
2 E _ O //,/V / $ < — - » N o ’fr’r’, 6 > ‘ > ‘ >$
m ,J’-/" o ,/’/>,-$»—
F s—/ $-$<—<
I I I ‘— I I I
'I 3 5 'I 3 5

Edit distance threshold

Edit distance threshold

Fig. 8. Comparison of number of candidate pairs. The evaluations were done on 100000 short reads. The proposed method was examined with k: 1, . . .,5.
‘Neighbor pairs” represent the actual number of neighbor pairs in data. ‘k-mer/nonredundant’ and ‘k-mer/redundant’ represent two variants of the single seed

method (see text).

 

469

112 /3.Io's[BurnoTpJOJXO'sonBuIJOJHrorq”:duq uror} pap1201umoq

9103 ‘0g1sn8nv uo ::

K.Shimizu and K. Tsuda

 

Table 2. Comparison of computation time of searching pairs and ﬁnding MSTs for two types of short read datasets with edit-distance threshold 3

 

 

 

 

Number of reads Dataset 1 Dataset 2
Searching pairs only (s) Finding MSTs (s) Searching pairs only (s) Finding MSTs (s)
10 000 0.08 0.00 0.06 0.00
100 000 0.85 0.08 1.84 0.01
1000 000 23.08 1.08 31.34 2.06
10 000 000 495.15 17.69 554.09 5.61

 

 

Fig. 9. Visualization of large MSTs from a neighbour graph of 10000 000 short reads with edit-distance threshold 3. The left graph shows 360 MSTs of

112 995 nodes, each of which consists of more than 100 nodes. The right graph focuses on the largest MST that consists of 6990 nodes. It is straightforward

to obtain the dendrograrns of single link clustering from these MSTs.

ACKNOWLEDGEMENT

The authors thank Kiyoshi Asai, Hisanori Kiryu, Takeaki Uno,
Tetsuo Shibuya, Yasuo Tabei and Martin Frith for their fruitful
discussions.

Funding: Grant-in-Aid for Young Scientists (22700319, 21680025)
by JSPS; FIRST program of the Japan Society for the Promotion of
Science in part.

Conﬂict of Interest: none declared.

REFERENCES

Abouelhoda,M. et al. (2004) Replacing sufﬁx trees with enhanced sufﬁx arrays.
J. Discrete Algorithms, 2, 53786.

Burkhardt,S. and Karkk'ainenJ. (2002) One-gapped q-gram ﬁlters for levenshtein
distance. In Proceedings of the 13th Symposium on Combinatorial Pattern Matching
(CPM'fOZ). Vol. 2373 of Lecture Notes in Computer Science, Springer, Berlin,
Germany, pp. 257234.

Gower,J. and Ross,G (1969) Minimum spanning trees and single-linkage cluster
analysis. Appl. Stat., 18, 5L64.

Han,J. et al. (2004) Mining frequent patterns without candidate generation. Data Min.
Knowl. Discov., 8, 53787.

Jiang,H. and Wong,W.H. (2008) Seqmap: mapping massive amount of oligonucleotides
to the genome. Bioinformatics, 24, 239572396.

Kruskal,J.B. (1956) On the shortest spanning subtree of a graph and the traveling
salesman problem. Proc. Am. Math. Soc., 7, 48750.

Langmead,B. et al. (2009) Ultrafast and memory-efﬁcient alignment of short dna
sequences to the human genome. Genome Biol, 10, R25.

Li,l-l. and Durbin,R. (2009) Fast and accurate short read alignment with burrows-
wheeler transform. Bioinformatics, 25, 175L1760.

Li,R. et al. (2009) Soap2: an improved ultrafast tool for short read alignment.
Bioinformatics, 25, 196671967.

Lipman,D.J. and Pearson,W.R. (1985) Rapid and sensitive protein similarity searches.
Science, 227, 143571441.

Manning,C. et al. (2008). Introduction to Information Retrieval. Cambridge University
Press, Cambridge, UK.

Prim,R. (1957) Shortest connection networks and some generalizations. Bell Syst. Tech.
J., 26, 138971401.

Qu,W. et al. (2009) Efﬁcient frequency-based de novo short-read clustering for error
trimming in next-generation sequencing. Genome Res., 19, 130971315.

Rajasekaran,S. et al. (2005) High-performance exact algorithms for motif search.
J. Clin. Monit. Comput, 19, 3197328.

Sagot,M.-F. (1998) Spelling approximate repeated or common motifs using a sufﬁx
tree. In Lucchesi,C.L. and Moura,A.V. (eds), LATIN ’98: Theoretical Informatics,
Third Latin American Symposium, Vol. 1380 of Lecture Notes in Computer Science,
Springer, Berlin, Germany, pp. 37L390.

Simpson,J.T. et al. (2009) Abyss: a parallel assembler for short read sequence data.
Genome Res, 19, 111771123.

Tarjan,R. (1983) Data Structures and Network Algorithms. Society for Industrial and
Applied Mathematics (SIAM), Philadelphia, USA.

Trapnell,C. et al. (2009) Tophat: discovering splice junctions with rna-seq.
Bioinformatics, 25, 110571111.

Uno,T. (2008) An efﬁcient algorithm for ﬁnding similar short substrings from large
scale string data. Proceedings of the 12th Paciﬁc-Asia Conference on Advances in
Knowledge Discovery and Data Mining (PAKDD'08), Vol. 5012 of Lecture Notes
in Computer Science, Springer, Berlin, Germany, pp. 3457356.

Warren,R.L. et al. (2007) Assembling millions of short dna sequences using ssake.
Bioinformatics, 23, 509501.

Weese,D. et al. (2009) Razers-fast read mapping with sensitivity control. Genome Res.,
19, 16431654.

Zerbino,D.R. and Birney,E. (2008) Velvet: algorithms for de novo short read assembly
using de bruijn graphs. Genome Res., 18, 8217829.

 

470

112 /3.Io's[BurnoprOJXO'sorwurrowrorq”:duq uror} pap1201umoq

9103 ‘0g1sn8nv uo ::

