BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

JEnsembl

 

Although the ActiveRecord design allows the API code to
remain ‘in sync’ with the database schema automatically, no
higher level data model is generated and scripts that run against
a particular release of the Ensembl databases will not run against
other releases if the names of tables or columns have been
changed. Several Python—based APIs that have been made avail—
able have not evolved with schema changes and provide limited
data models [e.g. PyCogent (http://pycogent.sourceforge.net)
(Knight et al., 2007), PyGr (http://code.google.com/p/pygr/
wiki/PygrOnEnsembl), cache—ensembl (http://pypi.python.org/
pypi/cache_ensembl)].

A new, easily maintainable Java—based API to the Ensembl
system would be a timely and highly effective addition to the bio—
informatics toolbox. Such an API would allow integration be—
tween graphical user interfaces and Ensembl datasources and
between other bioinformatic resources and libraries implemented
in Java [for example, the BioJava (http://www.biojava.org)
framework; Holland et al., 2008].

A full Java API to the Ensembl system would replicate all the
data access functionality of the Perl API Core, Compara,
FuncGen and Variation modules and would:

(1) Connect to and extract data from the current release ver—
sion of Ensembl.

(2) Access all instances of Ensembl data systems including
single—species databases at Ensembl and EnsemblGenomes
and the multi—species databases (bacterial collections) at
EnsemblGenomes.

(3) Access data from all database types: Core, FuncGen,
Variation, Compara, etc.

(4) Emit software objects corresponding to the major ob—
ject types within Ensembl including Sequence
Regions, Markers, Alleles, Genes, Exons, Transcripts,
CoordinateSystems and AnnotationFeatures of numerous
kinds.

(5) Map between appropriate CoordinateSystem levels for a
given genome (thus allowing actual DNA sequence data to
be retrieved for features annotated at higher levels, e.g.
genes on chromosomes).

(6) Provide an architecture for updating the API connectivity
and functionality as new versions of Ensembl are released,
while maintaining backwards compatibility with earlier re—
leases (improve on the Perl requirement for version—
specif1c API releases).

(7

v

Be compatible with (and build upon) existing open source
Java libraries for bioinformatics where relevant (e. g.
BioJava 3.0).

We report here the implementation of an extendable Ensembl
Java API that demonstrates the tractability of the objectives
above; speciﬁcally it provides access to all versions of databases
currently published at Ensembl and EnsemblGenomes. It imple—
ments core functionality for the retrieval of chromosome, gene,
transcript, exon, protein data, etc. from ‘Core’ databases; maps
locations between CoordinateSystems and maps transparently
between database versions where changes in the schema necessi—
tate different SQL statements to extract the same information.
We have also implemented retrieval of SNP variation

information from the ‘Variation’ databases and comparative
homology information from the ‘Compara’ databases.

We demonstrate the potential utility of our Ensembl Java API
by incorporating the J Ensembl libraries in a plug—in created for
the Savant Genome Browser (http://www.savantbrowser.com/)
(Fiume et al., 2010), and in our Genetic Map Drawing applica—
tion ‘ArkMAP’ (http://www.thearkdb.org/arkdb/download.jsp).
These plug—ins demonstrate how third—party developers can use
JEnsembl to access data from Ensembl datasources, allowing
the graphical display and alignment of chromosomal sequences,
variations and exceptions, gene annotations and gene
homologies.

2 IMPLEMENTATION

J Ensembl is implemented in Java version 1.6 following a modu—
lar design pattern using Maven software management. Project
development is hosted on SourceForge where code is available
from the subversion repository (http://jensembl.sourceforge.net/;
https://sourceforge.net/projects/jensembl/). The architecture of
the project is shown schematically in Figure 1. Each of the sep—
arate interdependent modules of the API is built as a Maven
artifact allowing for public distribution via Maven repositories.
Alternatively, the Jar artifacts can be used as standard Java
libraries outwith a Maven build environment. Each module is
coded against full JUnit tests, with an additional module provid—
ing demonstration code and functional tests for data retrieval by
the API from remote datasources. Current release versions of the
libraries are available on the project website and Maven
repository.

The modular design of the JEnsembl artifacts is described
more fully in the online documentation. In brief, the J Ensembl
API def1nes Java objects corresponding to the various genetic
objects described in the Ensembl datasources (i.e. Chromosomes,
DNASequences, Features, Species, Genes, etc.). These data ob—
jects are created and populated through the data access layer (see
Fig. 1) using MyBatis (http://www.mybatis.org/) as the
RDBMS—to—Java object—mapping tool. A fundamental goal of
the project design was to separate schema version—specif1c data—
base query code from the data model; this is achieved by parti—
tioning the SQL code and MyBatis data mapping rules into a
hierarchy of XML conﬁguration files in the conﬁguration
module (see Fig. 2). Conﬁgurations in the schemaproperties flle
automate which mapping rules are used for each Ensembl
release—version, allowing the data access code seamlessly to main—
tain correct data mappings as the Ensembl data schema evolves,
while retaining backwards compatibility with earlier schema.

To connect to a datasource (e.g. Ensembl), a DBRegistry
object is instantiated by injecting either a default RegistryConﬁ—
guration object read from the current enseme—conﬂg module or a
RegistryConﬁguration generated from locally supplied proper—
ties. The RegistryConﬂguration deﬁnes the set of MyBatis con—
ﬁguration files to read for each version of the database/ schema
identiﬁed within the installation. Upon DBRegistry initializa—
tion, the names of available databases at the conﬁgured data—
source are parsed using the Ensembl naming conventions and
meta—data tables to identify database—type, species, assembly and
schema release versions. The DBRegistry object can then be
queried for lists of known databases or species, or can return

 

2725

ﬁm'spzumofpmjxo'sopeuuopuorq/ﬁdnq

User Application Code

JEnsemib:l

Ensem bl Java API

m-
-

 

m pmgpmpemes:

 

/810'spzum0fp10}x0'sopBLuJOJuioiq”:duq

JEnsembl

 

species/version Variation Database, with its own correctly con—
ﬁgured SQLSessionFactory. This DAOVariationFactory sup—
plies a DAOVariation object, which may be used to retrieve all
the variations for a given chromosomal region. Comparative
genomic data are stored somewhat differently in Ensembl, and
a DAOComparaFactory accesses a single Compara database for
each release of Ensembl, which holds the results of pair—wise
inter—species comparisons (comprising both genomic alignments
and gene family and homology data).

The EnsemblGenomes datasource uses the same (versioned)
schema as Ensembl (which is now focused as a Vertebrate re—
source), but with species organized into five separate taxonomic
groups, each with its own Compara database. Therefore, as with
the Ensembl Perl API, J Ensembl can use the same API for data
access from EnsemblGenomes with the added beneﬁt of version
aware conﬁguration on the fly. However, EnsemblGenomes bac—
terial datasources differ signiﬁcantly in being organized into
multi—species databases according to phylogeny. Ensembl
adapted their schema to handle multi—species resources, and the
Perl API handles all schema identically (as potentially
multi—species). In J Ensembl, multi—species resources are currently
handled by implementing separate ‘multi—species’ interfaces in
Database and Factory objects. Because the underlying schema
is identical, the multi—species data access architecture could be
used for accessing standard single—species datasources. However,
currently we feel retaining the single—species database paradigm is
simpler for the majority of users and allows for easier represen—
tation of a ‘species’ object, shared between database release
versions.

In order to harness the comprehensive sequence manipulation
features of BioJava libraries, we extended the BioJava 3.0 Core
DNASequence object for the JEnsembl DNASequence object,
providing an Ensembl SequenceReader that can lazy—load se—
quence on demand from the Ensembl datasource. This provides
the J Ensembl Sequence objects with BioJava API behaviour, for
example reading protein sequences from translated transcripts.
Incorporation of third—party open source libraries not only ob—
viates code duplication but also enables interoperability with a
wider range of third—party software.

The JEnsembl release libraries were used to create a novel
plug—in for the Savant Genome Browser (Fiume et al., 2011).
The plug—in source code and binary Jars for different versions
of the browser are also available from the J Ensembl project site
on SourceForge (http://jensembl.sourceforge.net/savant.html).
Our ‘ArkMAP’ map drawing tool has recently been converted
to retrieve chromosome gene annotation data directly from
Ensembl datasources using the JEnsembl API instead of the
BioMart web services, thus allowing ArkMAP to be ‘Version
Aware’ for Ensembl data. JEnsembl—mediated access to
Compara data allows the discovery and alignment of regions
of conserved synteny between species and SNP marker mappings
can be retrieved from Variation datasources.

3 RESULTS AND DISCUSSION

3.1 J Ensembl

The JEnsembl development code, Jar library releases (Maven
artifacts) and documentation including JavaDocs are available

on SourceForge (current release 1.12). Access to an Ensembl
datasource is achieved by initializing a DBRegistry object
either with one of the two conﬁgurations provided
(ENSEMBLDB or ENSEMBLGENOMES) or with user—speci—
ﬁed conﬁguration properties that allow connection to alternate
datasources using the Ensembl schema, for example Ensembl
Archives or private, local data resources. Initialization of the
Registry object sorts and registers the available databases at
the selected datasource: their release number, schema type and
species, determining which releases match the schema version
mappings in the current JEnsembl Conﬁguration module.
Thereafter, data from any ‘known’ database type and version
can be interrogated through the Registry. In the absence of spe—
ciﬁed type or version number, a query retrieves data by default
from the most recent conﬁgured (i.e. ‘known’) version of the
appropriate database type. In addition to providing public
access to the databases, the Registry provides public access to
Species objects by name or alias, suitable for more high—level
usage. Species can then be queried for information about
genes, sequences, etc. without any knowledge of the Ensembl
data structure.

Figure 3 demonstrates example code usage, starting with
Registry initialization and retrieval of a Species object, which is
then used to access data from specified release versions of the
Ensembl datasource. Thus, the current or any earlier release ver—
sion of chicken chromosome 2 (together with all of it annota—
tions) can be retrieved (e.g. release ‘60’ in Fig. 3). This allows
reproducible access to the correct version of data used by histor—
ical analyses and allows comparison of different versions of the
data using a single API code installation. This is illustrated by the
single code snippet shown in Figure 4 where data pertaining to a
single human gene can be retrieved from the current and previ—
ous 17 human core database releases available at the Ensembl
datasource (and for which the JEnsembl API has conﬁgured
schema mappings). This allows, for example, the location of
the gene to be compared over time, between Ensembl releases,
assembly builds, patches and changes to the gene model and
permits many other ‘through—time’ analyses of genome assem—
blies to be contemplated. The retrieval of similar multi—release
data using Perl would require multiple, separate, release—speciﬁc
versions of the Ensembl Perl API to be installed and involve
complex library path manipulations.

A central concept within the J Ensembl model is a ‘Mapping’:
between source and target ‘MappableObjects’, with source and
target coordinates (start, stop, strand). Mappings allow any of
the Ensembl annotation types to be located on other types (e. g.
genes, exons, variations on chromosomes). When genes are
retrieved from a chromosome, the query returns a set of genes,
each with its own mapping to the chromosome, while the
chromosome is returned with an ordered set of the (inverse)
mappings of genes on the chromosome.

Retrieval of data across the database schema types is achieved
transparently, by loading appropriate DAOFactories, and using
appropriate identiﬁers shared across the schema. For example,
querying a gene for homologues uses the gene’s stable Ensembl
identiﬁer to query the Compara schema, and the target ‘hits’
retrieved contain enough information to convert them to Core
schema objects if required (target stable id, chromosome name
and coordinates, and target species name). Similarly, queries to

 

2727

ﬁm'spzumofpmjxo'sopeuuopuorq/ﬁdnq

10075
3 7 325.4559

(FORWARD75TRAN D)

(FORWARD75TRAND)

 

/810'spzum0fp10}x0'sopBLuJOJuioiq”:duq

TTTA-LA

EHHHIJI.I:I‘I|II|I'I I'. l'.|.l

 

 

 

 

JEnsembl

 

Funding: Supported by Institute Strategic Grant funding from
the Biotechnology and Biological Sciences Research Council.

Conﬂict of Interest: none declared.

REFERENCES

Fiume,M. et a]. (2010) Savant: genome browser for high—throughput sequencing
data. Bioinformutim‘, 26, 193871944.

Flicek,P. et a]. (2008) Ensembl’s 10th year, 2010. leeie Aeidx Re.\'., 38 (Suppl. 1),
D5577D562.

Holland,R.C.G. et a]. (2008) BioJava: an Open—Source Framework for
Bioinformatics. Bioinformutiex, 24, 209(rZOQ7.

Knight,R. et a]. (2007) PyCogent: a toolkit for making sense from sequence. Genome
Biol., 8, R171.

Stabenau,A. et a]. (2004) The Ensembl core software libraries. Genome Rex, 14,
9297933.

Strozzi,F. and Aerts,J.A. (2011) A Ruby API to query the Ensembl database for
genomic features. Bioinﬁnmutiex, 27, 101371014.

 

2731

/810'sleum0prOJxo'sopBLuJOJutotq”:duq

