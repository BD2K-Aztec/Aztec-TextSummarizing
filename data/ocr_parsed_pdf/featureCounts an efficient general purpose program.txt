BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

Y.Liao et al.

 

multiple transcripts are being expressed from the same gene.
Reads can generally be assigned to genes with good confidence,
but estimating the expression levels of individual isoforms is in—
trinsically more difﬁcult because different isoforms of the gene
typically have a high proportion of genomic overlap. A number
of model—based methods have been developed that attempt to
deconvolve the expression levels of individual transcripts for each
gene from RNA—seq data, essentially by leveraging information
from reads unambiguously assigned to regions where isoforms
differ (Li and Dewey, 2011; Trapnell et al., 2010). This article
concentrates on the read count problem, which is generally ap—
plicable even when the sequencing depth is not sufﬁcient to make
transcript level analysis reliable. Many statistical analysis meth—
ods have been developed to detect differential expression or dif—
ferential binding on the basis of read counts (Anders and Huber,
2010; Auer and Doerge, 2011; Hardcastle and Kelly, 2010; Li
et al., 2012; McCarthy et al., 2012; Wu et al., 2013). Recent
comparisons have concluded that the read count methods per—
form well relative to model—based methods for the purposes of
gene—level differential expression (Nookaew et al., 2012;
Rapaport et al., 2013) or detection of splice variation (Anders
et al., 2012).

Only a handful of general purpose read count software tools
are currently available. The software packages GenomicRanges
(Aboyoun et al., 2013) and [Ranges (Pages et al., 2013), de—
veloped by the core team of the Bioconductor project
(Gentleman et al., 2004), include functions for counting reads
that overlap genomic features. The c0unt0verlaps function of
[Ranges is designed for counting reads overlapping exons or
other simple genomic regions, whereas the summarizeOverlaps
function of GenomicRanges is designed for counting reads at
the gene level. Another tool is the htseq—count script distributed
with the HT—Seq Python framework for processing RNA—seq or
DNA—seq data (Anders, 2013). All of these are popular and well—
tested software tools, but all make extensive use of programming
in the interpreted computer languages R or Python and none are
fully optimized for efﬁciency and speed. BEDTooIs is a popular
tool for finding overlaps between genomic features that can be
used to count overlaps between reads and features (Quinlan and
Hall, 2010). It is fully implemented in the compiled language
C++, making it faster than the aforementioned tools. It is, how—
ever, not speciﬁcally designed for RNA—seq data, so can count
reads for exons or interval features only, similar to
c0unt0verlaps.

This article presents a highly optimized read count program
called featureCounts. featureCounts can be used to quantify
reads generated from either RNA or DNA sequencing
technologies in terms of any type of genomic feature. It imple—
ments chromosome hashing, feature blocking and other strate—
gies to assign reads to features with high efﬁciency. It supports
multithreading, which provides further speed improvements
on large data problems. It is available either as a Unix command
or as a function in the R package Rsubread. In either case, all
the core functionality is written in the C programming
language. The R function is a wrapper for the compiled C
code that provides the convenience of the R programming envir—
onment without sacrificing any of the efﬁciency of the C
implementation.

2 DATA FORMATS AND INPUTS
2.1 Input data

The data input to featureCounts consists of (i) one or more ﬁles
of aligned reads in either Sequence Alignment/Map (SAM) or
Binary Alignment/Map (BAM) format (Li et al., 2009) and (ii) a
list of genomic features in either general feature format (GFF)
(W ellcome Trust Sanger Institute, 2013) or simplified annotation
format (SAF) (Shi and Liao, 2013b). The read input format
(SAM or BAM) is automatically detected and so does not
need to be speciﬁed by the user. Both the read alignment and
the feature annotation should correspond to the same reference
genome, which is a set of reference sequences representing
chromosomes or contigs. For each read, the SAM or BAM file
gives the name of the reference chromosome or contig to which
the read mapped, the start position of the read on the chromo—
some or contig and the so—called Concise Idiosyncratic Gapped
Alignment Report (CIGAR) string giving the detailed alignment
information including insertions and deletions and so on relative
to the start position.

The genomic features can be speciﬁed in either GFF or SAF
format. The SAF format is the simpler and includes only five
required columns for each feature: feature identifler, chromosome
name, start position, end position and strand. These ﬁve columns
provide the minimal sufﬁcient information for read quantification
purposes. In either format, the feature identiﬁers are assumed to
be unique, in accordance with commonly used Gene Transfer
Format (GTF) reﬁnement of GFF (Brent Lab, 2013).

The number of reference sequences may be small or large de—
pending on the application. For well—established genomes, the
number of reference sequences is equal or close to the number
of chromosomes. The number of reference sequences can
be, however, much larger for genomes with incomplete or low—
quality assemblies because each contig becomes a reference
sequence. RNA—seq reads are sometimes aligned to the transcrip—
tome instead of to the genome. In this case, there may be hun—
dreds of thousands of transcripts and each transcript becomes a
reference sequence.

featureCounts supports strand—speciﬁc read counting if strand—
speciﬁc information is provided. Read mapping results usually
include mapping quality scores for mapped reads. Users can op—
tionally specify a minimum mapping quality score that the as—
signed reads must satisfy.

2.2 Single and paired-end reads

Reads may be paired or unpaired. If paired reads are used, then
each pair of reads defines a DNA or RNA fragment bookended
by the two reads. In this case, featureCounts will count fragments
rather than reads. featureCounts automatically sorts reads by
name if paired reads are not in consecutive positions in the
SAM or BAM file.

2.3 Features and meta-features

Each feature is an interval (range of positions) on one of the
reference sequences. We also define a meta—feature to be a set
of features representing a biological construct of interest. For
example, features often correspond to exons and meta—features
to genes. Features sharing the same feature identifier in the GFF

 

924

ﬁm'spzumofpmﬂo'sopeuuopnorq/ﬁdnq

55,2kgogmoddmmowoio~&o:~=£¢o~m\

Y.Liao et al.

 

feature annotation data required at each stage of the computa—
tion. The C code supports multithreading, and the user can spe—
cify the number of threads to be used. One thread is the default.
The R function featureCounts in the Rsubread package
for R is a wrapper for the same compiled C code as for the
Unix command line. The R function provides the convenience
of the R programming environment without sacriﬁcing any of
the efﬁciency of the C implementation. It produces a data object
in R that can be input directly into R—based statistical analysis
software such as edgeR (Robinson et al., 2010) or [imma (Law
et al., 2013) that are designed to analyze next—gen read counts.

5 PERFORMANCE ON RNA-SEQ DATA

5.1 Data and annotation

First we compare the performance of featureCounts with existing
software tools for counting RNA—seq reads at the gene level. As
an example case study, we use RNA—seq data that were gener—
ated as part of the SEQC (SEquencing Quality Control) project,
the third stage of the MicroArray Quality Control (MAQC) pro—
ject (Shi et al., 2006). These data consist of 6.8 million pairs of
101bp reads generated by sequencing a sample of Universal
Human Reference RNA on an Illumina HiSeq 2000.

The SEQC RNA—seq dataset was aligned to the human
genome GRCh37 using the Subjunc aligner included in the
Subread package (Liao and Shi, 2013; Liao et al., 2013; Shi
and Liao, 2013a). We used Subjunc for this analysis because it
explicitly identiﬁes exoniexon junctions and outputs the map—
ping location of every base of every read including those that
span multiple exons. This allowed us to examine rigorously the
ability of the read count programs to count reads spanning mul—
tiple exons as well as reads falling within exons.

Genes and exons were defined as in the NCBI human RefSeq
annotation build 37.2. This included 25 702 genes and 225071
exons.

Counts were summarized at the gene level. That is, exons were
deﬁned to be features, genes were deﬁned as meta—features and
quantiﬁcation was at the meta—feature level. As this is RNA—seq
data, reads or fragments that overlapped multiple genes should
be excluded from the counts.

5.2 Comparative performance when counting reads

To demonstrate featureCounts on single—end reads, the first
evaluation uses only the first read from each read pair. Table 1
compares the performance of featureCounts to that of the
summarizeOverlaps function of the GenomicRanges package
and to the htseq—count script. featureCounts and
summarizeOverlaps yielded identical counts for every gene
(Table 1, column 2).

htseq—count counted slightly fewer reads than featureCounts
and summarizeOverlaps. We had a close look at the summariza—
tion results for each read given by htseq—count and featureCounts
and found that only a small number of reads were assigned to
different genes by the two methods (Fig. 2a). By comparing the
features regions with the regions these reads were mapped to, we
identiﬁed the reason causing this discrepancy. htseq—count takes
the right—most base position of each feature as an open position
and excludes it from read summarization, whereas featureCounts

Table 1. Performance results on the SEQC RNA-seq data

 

Method Number Number of Time Memory
of reads fragments (min) (MB)

 

featureCounts 4 385 354 4 796 948 1.0 16

SummarizeO verlaps 4 385 354 3 942 439 12.1 3400
(whole genome at once)

SummarizeO verlaps 4 385 354 3 942 439 41.7 661
(by chromosome)

htseq—count 4385 207 4769913 22.7 101

 

Note: Results are given for genewise counts of either single—end reads or paired—end
fragments. feutureCoumx yields the same read counts as summarizeOverlupX but is
much faster and memory efﬁcient. sumnmrizeOverlupX counts fewer fragments be—
cause it excludes read pairs with only one end successfully mapped. htseq—wum
counts slightly fewer reads or fragments than featureCounts because it interprets
GFF annotation differently and calls more ambiguously assigned fragments. The
table gives the total number of reads counted when using single—end reads and the
toml number of fragments counted when using paired—end reads. Running time and
memory usage are for fragment summarization. featureCounts was set to exclude
reads or fragments overlapping multiple genes. .x‘umnmrizeOverlupX and lztseq-coum
were run in ‘union’ mode. Results are shown for countOverlaps (i) when run on the
whole genome at once and (ii) when run chromosome by chromosome.

(3) featureCounts htseq—count

4384994

Single-end

(b) featureCounts htseq—count

4769846

Paired—end
Fig. 2. Concordance between featureCounts and htseq-count regarding
assignment of reads (a) or fragments (b) to genes. The dataset is the
same as for Table 1. The Venn diagram overlap gives the number of
reads or fragments assigned by both methods to the same gene. The
remaining counts give the number of reads or fragments assigned by
one method to some genes but not by the other method

and summarizeOverlaps take it as a closed position and includes
it in their summarizations. The GFF speciﬁcation states that the
start and end positions of features are inclusive (Wellcome Trust
Sanger Institute, 2013), so the interpretation of featureCounts
and summarizeOverlaps appears to be correct. GFF is the only
annotation format supported by htseq—count. We modified the
annotation ﬁle provided to htseq—count by adding one to the
right—most position of each exon to let htseq—count include
these positions. After this modiﬁcation, htseq—count yielded iden—
tical counts to featureCounts and summarizeOverlaps.

Here and all subsequent comparisons, the software tools were
tested on a HP Blade supercomputer with 64 AMD Opteron

 

926

ﬁm'spzumofpmjxo'sopeuuopnorq/ﬁdnq

featureCounts

 

2.3 GHz CPUs and 512 GB of memory. All programs were run
using a single CPU without multithreading. Comparisons used
software packages Subread 1.4.2, Rsubread 1.12.2,
GenomicRanges 1.12.5, [Ranges 1.18.4, htseq—count 0.5.4p3 and
BEDTooIs 2.17.0.

5.3 Comparative performance when counting fragments

We went on to compare the same methods for counting paired—
end fragments, using the full SEQC paired—end data. Summarize
Overlaps counted far fewer fragments than featureCounts and
htseq—count (Table 1, column 3). The main reason for this dis—
crepancy is that summarizeOverlaps requires fragments to have
both end reads successfully mapped before assigning them to
genes, whereas featureCounts and htseq—count do not have such
a requirement, i.e. they can assign fragments just one end
mapped. With a read length of 101bp, fragments with only
one end mapped can still have relatively high mapping conﬁ—
dence. Counting such fragments seems likely to beneﬁt down—
stream analyses. Many aligners report fragments that have only
one end mapped, including Subread, Subjunc (Liao et al., 2013),
Bowtie (Langmead et al., 2009) and TopHat (Trapnell et al.,
2009). Almost all (92%) of fragments counted by
featureCounts but not by summarizeOverlaps were assigned to
genes that also had at least 100 assigned fragments with both
ends mapped. This shows that the fragments were assigned to
genuinely expressed genes, giving confidence that the extra frag—
ments have been assigned correctly. Only 0.1% of extra frag—
ments counts by featureCounts were assigned to genes not
supported by any fragment with both ends mapped.

htseq—count also counts fewer fragments than featureCounts in
this evaluation (Fig. 2b). Running htseq—count in
‘IntersectionStrict’ or ‘IntersectionNotEmpty’ modes instead of
‘Union’ mode did not cause it count more fragments.

featureCounts can distinguish those features that overlap with
different numbers of reads from the same fragment. For ex—
ample, if two genes were found to both overlap with a fragment
but one gene was found to overlap with only one read and the
other with both reads from that fragment, featureCounts will
assign that fragment to the gene overlapping with both reads.
However, htseq—count will take this fragment as ambiguous and
will not assign it to any gene. This is the main reason why
featureCounts counted slightly more fragments than htseq—
count. featureCounts uses the size of overlap (in terms of reads)
to recover those ‘ambiguous’ fragments. For this dataset, >86%
of fragments assigned by featureCounts but not by htseq—count
were assigned to genes that already had at least 100 unambigu—
ous fragments assigned by both methods. Only 0.2% of extra
fragments assigned by featureC ounts were not supported by com—
monly assigned fragments. This again shows that the extra frag—
ments are being assigned to genuinely expressed genes,
suggesting that the extra fragments are likely to have been cor—
rectly assigned.

Table 1 (columns 4 and 5) shows that featureCounts was con—
siderably faster (>10—folds) and more memory efﬁcient than the
other programs. summarizeOverlaps was also run chromosome
by chromosome to save memory. That is, reads were split into
groups according to the chromosomes they were mapped to and

each group of reads was summarized separately. But it still used
20 times as much memory as featureCounts.

6 PERFORMANCE ON CHIP-SEQ DATA

6.1 Data and annotation

Now we compare the performance of featureCounts with existing
software tools for counting gDNA—seq reads at the feature level.
As an example case study, we use a ChIP—seq dataset that was
generated as part of a study of global changes in the mammary
stem cell epigenome under hormone perturbation (Pal et al.,
2013). Speciﬁcally the dataset was generated to find genomic
regions associated with the H3K27me3 epigenetic histone mark
(tri—methylation of the histone H3 lysine 27) in mouse mammary
stem cells. This dataset consists of 15 million pairs of 35 bp DNA
reads generated by an Illumina Genome Analyzer IIx. The study
analyzed the total number of fragments mapped to the broad
region of each gene, where the broad region is defined to be the
entire gene body from ﬁrst to last base plus the 3 kb region im—
mediately upstream from the transcription start of the gene rep—
resenting the putative promotor region (Pal et al., 2013).

The read mapping and annotation used here follows the ori—
ginal study. Reads were mapped to the mouse genome (mm9)
using the Subread aligner (Liao et al., 2013). Fragments were
included in the evaluation only if both paired reads were success—
fully mapped to the genome and if the fragment deﬁned by the
end reads was between 50 and 500 bp long. The transcription
start and end positions for each gene were obtained from the
NCBI mouse RefSeq annotation (build 37.2).

6.2 Comparative performance

We summarized paired—end fragments at the feature level, where
the features represented the broad regions of all annotated genes.
In this application, a fragment should be counted multiple times
if it overlaps multiple genes.

Table 2 compares the performance of featureCounts to that of
the countOverlaps function of the [Ranges package, the htseq—
count script and the coverageBED program in the BEDTooIs
software suite. countOverlaps was used for this comparison in—
stead of summarizeOverlaps because it allows multi—overlap reads
to be assigned to multiple features.

featureCounts and countOverlaps yielded identical counts for
every gene, but featureCounts was considerably faster and more
memory efﬁcient. countOverlaps was also run chromosome by
chromosome to save memory. This reduced the peak memory
usage, although it remained more than a hundred times that used
by featureCounts. Note that featureCounts, unlike countOverlaps,
can count fragments with only one end successfully mapped, but
such fragments were not included in this evaluation to ensure
that the timings and memory use for featureCounts and
countOverlaps were for identical operations.

coverageBED assigned slightly fewer fragments than
featureCounts. We found this was because coverageBED used
only the first read of each fragment to assign the whole fragment
to features. htseq—count counted 778% fewer fragments, presum—
ably because it does not count multi—overlap fragments. htseq—
count was run in ‘intersection—nonempty’ mode as well as in

 

927

ﬁm'spzumofpmjxo'sopnuuopnorq/ﬁdnq

Y.Liao et al.

 

Table 2. Performance results on the H3K27me3 ChIP-seq dataset

 

Method Number of Time Memory
fragments (min) (MB)

 

featureCounts 5 392 155 0.9 4

CountOverlaps 5 392 155 24.4 7000
(whole genome at once)

CountOverlaps (by chromosome) 5 392 155 36.6 783

htseq-count (union) 4978050 36.0 31

htseq-count (intersection-nonempty) 4 993 644 35.7 31

coverageBED 5 366 902 4.4 41

Table 3. Performance with RNA-seq reads simulated from an annotated
assembly of the Budgerigar genome

 

 

Methods Number Time Memory
of reads (mins) (MB)
featureCounts 7 924065 0.6 15
summarizeO verlaps 7 924 065 12.6 2400
(whole genome at once)
summarizeO verlaps 7 924 065 53 .3 262
(by scaffold)
htseq—count 7912439 12.1 78

 

Note: featureCounts is the fastest method and uses least memory. It counts the same
number of fragments as countOverlaps but more than Ittseq—wunt or coverageBED.
Table shows the total number of fragments counted, time taken and peak memory
used. featureCounts was set to count multi—overlap fragments. Results are shown for
countOverlaps (i) when run on the whole genome at once and (ii) when run chromo—
some by chromosome. Running by chromosome conserves memory but takes
longer. Results are shown for Ittseq—count in two possible counting modes. For
coverageBED, the BAM input ﬁle was converted to a BED ﬁle for summarization
using bumToBed with options ‘—bedpe’ and ‘—split’.

‘union’ mode so as to count more fragments, but this did not
make up much of the shortfall.

Columns 3 and 4 of Table 2 show that featureCounts was
about ﬁve times faster and used about 10 times less memory
than the next most efficient tool.

7 PERFORMANCE WHEN THE NUMBER OF
REFERENCE SEQUENCES IS LARGE

7.1 Simulated data

Datasets with large numbers of reference sequences are challen—
ging because the read count software must match the contig
names of features to those of reads in an efﬁcient manner. To
examine performance under these conditions, we simulated reads
from an incompletely assembled genome with relatively large
number of scaffolds. We used an assembly of the budgerigar
genome generated in the Assemblathon 2 project (Bradnam
et al., 2013; Howard et al., 2013). For this assembly there are
16204 annotated genes with 153 724 exons located on 2850 scaf—
folds. Eight million 100 bp single—end reads were randomly ex—
tracted from the annotated exonic regions in the assembled
scaffolds. The simulated reads were entered into a SAM ﬁle.
Read mapping information was filled according to the locations
from where the reads were extracted.

7.2 Comparative performance

The simulated reads were then summarized at the gene level.
Table 3 compares featureCounts to summarizeOverlaps and
htseq—count for this dataset. As seen before on the RNA—seq
data, summarizeOverlaps yields the same counts as
featureCounts, whereas htseq—count yields slightly fewer.
featureCounts maintained its efficiency advantage over the
other methods in this evaluation, increasing its speed advantage
over summarizeOverlaps in this context.

Note: The annotation includes 16204 genes located on 2850 scaffolds. featureCounts
is fastest and uses least memory. Table gives the total number of reads counted, time
taken and peak memory used. lttseq—count was run in ‘union’ mode.

8 THEORETICAL ANALYSIS OF ALGORITHMIC
COMPLEXITY

This section gives a theoretical analysis of the computational
time and memory storage required by featureCounts and the
other algorithms. The actual time and memory consumed by a
computer program depends on the computer hardware, operat—
ing system and other factors as well as on the mathematical ef—
ficiency of the algorithm used. However, we can derive
theoretical expressions for the rate at which time and memory
used by any speciﬁc algorithm should increase with the number
of reads, the number of features and the density of features in the
genome. The time complexity of the featureCounts algorithm can
be derived as 0(flog f + er—l), where f is the number of features,
r is the number of reads and k1 is the number of features included
in a genomic bin. This means that the number of elementary
computations used by the algorithm increases linearly with the
number of reads, independently of the number of features and
somewhat faster than linearly with the number of features. The
space complexity of the featureCounts algorithm is 0(f+ b1),
meaning that memory used increases linearly with the number
of features plus the number of bins b1. Time and space complex—
ities for all the algorithms are given in Table 4.

The number of reads is typically large, so rate of increase with
r is especially important. The featureCounts algorithm has the
lowest time complexity of the algorithms being compared. The
red—black tree search algorithm used by htsesq—count has higher
complexity because log f is typically larger than the square root
of the number of features per bin used by featureCounts. The
hierarchical search within bins used by featureCounts is more
efﬁcient than the sequential search carried out by coverageBED
because most reads overlap multiple levels of bins with
coverageBED causing k2 to be typically greater than k1.
countOverlaps and summarizeOverlaps sort reads according to
their mapped locations and then use an interval tree to ﬁnd fea—
tures overlapping with reads. The sort step is especially expensive
and introduces rlogr terms.

The htseq—count algorithm has the best theoretical space com—
plexity, but featureCounts is not far behind because the number
of bins b1 is usually small compared with f. BEDTooIs has a
higher space complexity than featureCounts because it uses

 

928

ﬁm'spzumofpmjxo'sopnuuowrorq/ﬁdnq

featureCounts

 

Table 4. Theoretical time and space complexity

 

 

Method Time Memory
featureCounts flogf+ m/Fl‘ f+ b1
countOverlaps f log f + r log r + r f + r
summarizeOverlaps 2f log f + 2r log r + r + f f + r
htseq-count flogf+ r logf f
coverageBED f log f + rkz f + [72

 

Note: The table gives proportionality factors for the number of computations (time
complexity) and memory locations (space complexity) required by each algorithm.
Time complexities depend on the number of features f, the number of reads r and
the number of features included in genomic bins overlapping the query read, k.
Space complexity also depends on the number of bins, b. Complexities are inter—
preted as 0(x) where x is the expression given in the table. The number of bins used
by coverageBED, [72, is greater than the number of bins used by featureCounts, bl.
The number of within—bin features k2 for coverageBED is typically >kl for
featureCounts.

more bins. CountOverlaps and summarizeOverlaps have higher
space complexities that depend on the number of reads as well
as on the number of features.

In practice, the running time and memory usage of a software
program are determined not just by the inherent time and space
complexities of the algorithm it adopts but also by the efﬁciency
of the software implementation. The practical timings show that
featureCounts achieves further efﬁciency gains from high per—
formance C programming and direct memory manipulation.

9 DISCUSSION

Read summarization is an important step in many next—gen
sequencing data analyses. In this study, we developed a new
read summarization program called featureC ounts and compared
it with existing methods in terms of efﬁciency and accuracy. Our
results showed a high concordance between alternative methods
in summarization accuracy. However, there was a large differ—
ence observed in their computational cost. The featureCounts
method was found to be an order of magnitude faster on average
and far more memory efﬁcient than other methods. The high
computational efﬁciency of featureCounts is due to its ultrafast
feature search algorithm and its highly efﬁcient implementation
entirely using the C programming language.

All results presented in this article were produced using a
single thread, but featuresCounts also supports multithreaded
processing, making it particularly useful for summarizing data
generated in large sequencing studies. It is the only existing read
count method that supports multithreading.

This program provides a wide range of options to allow users
to fully control how their read data can be best summarized.
Users can choose whether they should count the reads that over—
lap with more than one feature or meta—feature. This choice is
often determined by the experiment type. Reads overlapping
with more than one gene (a meta—feature) should not be counted
in a RNA—seq experiment because such reads can only originate
from one gene, but usually they should be counted in a
gDNA—seq experiment such as a histone ChIP—seq experiment.

This program also allows users to filter out reads before summar—
ization using a number of metrics such as mapping quality scores,
fragment mappability (whether two ends from the same fragment
are both successfully mapped or not), fragment length, strand—
ness, chimerism and so on. It can automatically detect either
SAM or BAM format read input and sort reads by name if
paired reads are not in consecutive positions in the input. It
also allows users to specify whether those reads that were reported
with more than one mapping location (multi—mapping) should be
counted or not. Many of these useful features are not supported
by other programs.

The featureCounts program has been implemented in both
SourceForge Subread package (Liao and Shi, 2013) and
Bioconductor Rsubread package (Shi and Liao, 2013a). The R
function provides users with an R interface so that they can
access this program from their familiar R environment. It calls
the underlying compiled C program to perform all the read sum—
marization operations, and hence has the same speed and
memory usage as that of the SourceForge Subread package,
which is written entirely in C. The implementation of
featureCounts in R enables complete pipelines to be established
for analyzing next—gen sequencing data using Bioconductor soft—
ware programs. For example, functions included in
Bioconductor packages Rsubread, [imma and edgeR can be
used to perform complete RNA—seq and histone ChIP—seq ana—
lyses, starting from read mapping, to read summarization and
ﬁnally to differential expression analyses or differential histone
modiﬁcation analyses. Owing to its high efﬁciency and accuracy,
we believe the featureCounts program will be a useful tool in the
bioinformatics toolbox for analyzing next—gen sequencing data.

ACKNOWLEDGEMENT

The authors thank Leming Shi and Charles Wang for providing
the SEQC pilot data and Aaron Lun for helpful comments.

Funding: Project grant (1023454) and a Fellowship (to G.K.S.)
from the Australian National Health and Medical Research
Council (NHMRC). Victorian State Government Operational
Infrastructure Support and Australian Government NHMRC
IRIIS.

Conﬂict of Interest: none declared.

REFERENCES

Aboyoun,P. et a]. (2013) GenomicRanges: representation and manipulation of gen—
omic intervals. R package version 1.12.5. http://www.bioconductor.org (30
April 2013, date last accessed).

Anders,S. (2013) HTSeq: analysing high—throughput sequencing data with Python.
http://www—huber.embl.de/users/anders/HTSeq/doc/overview.html (30 April
2013, date last accessed). Version 0.5.4p3.

Anders,S. and Huber,W. (2010) Differential expression analysis for sequence count
data. Genome Biol, 11, R106.

Anders,S. et a]. (2012) Detecting differential usage of exons from RNA—seq data.
Genome Res., 22, 200872017.

Anders,S. et a]. (2013) Count—based differential expression analysis of RNA sequen—
cing data using R and Bioconductor. Nat. Protoc., 8, 176571786.

Auer,P. and Doerge,R.W. (2011) A two—stage Poisson model for testing RNA—seq
data. Statistical Applications in Genetics and Molecular Biology, 10, 1726.

Bhattacharyya,S. et a]. (2013) Genome—wide hydroxymethylation tested using the
help—gt assay shows redistribution in cancer. Ntwleic Acids Res., 41, e15743157.

 

929

ﬁm'spzumofpmjxo'sopnuuowrorq/ﬁdnq

Y.Liao et al.

 

Bradnam,K. et al. (2013) Assemblathon 2: evaluating de novo methods of genome
assembly in three vertebrate species. Gigascience, 2, 10.

Brent Lab. (2013) GTF2.2: a Gene Annotation Format. Washington University,
St Louis. http://mblab.wustl.edu/GTF22.html. (27 September 2013, date last
accessed).

Flicek,P. et al. (2012) Ensembl 2012. Nucleic Acids Res., 40, D84VD90.

Fonseca,N.A. et al. (2012) Tools for mapping high—throughput sequencing data.
Bioiry’ormatics, 28, 316973177.

Gentleman,R. et al. (2004) Bioconductor: open software development for compu—
tational biology and bioinformatics. Genome Biol, 5, R80.

Hardcastle,T.J. and Kelly,K.A. (2010) baySeq: Empirical Bayesian methods for
identifying differential expression in sequence count data. BMC
Bioiry’ormatics, 11, 422.

Harris,R.A. et al. (2010) Comparison of sequencing—based methods to proﬁle DNA
methylation and identiﬁcation of monoallelic epigenetic modiﬁcations. Nat.
Biotechnol, 28, 109771105.

Howard,J. et al. (2013) De novo high—coverage sequencing and annotated assemblies
of the Budgerigar genome. GigaScience Database, http://dx.doi.org/ 10.
5524/ 100059 (22 July 2013, date last accessed).

Kent,W. et al. (2002) The human genome browser at UCSC. Genome Res., 12,
99(r1006.

Langmead,B. et al. (2009) Ultrafast and memory—efﬁcient alignment of short DNA
sequences to the human genome. Genome Biol, 10, Article R25.

Law,C.W. et al. (2013) Voom! precision weights unlock linear model analysis tools
for RNA—seq read counts. http://www.statsci.org/smyth/pubs/VoomPreprint.
pdf (25 September 2013, date last accessed).

Li,B. and Dewey,C. (2011) RSEM: accurate transcript quantiﬁcation from
RNA—Seq data with or without a reference genome. BMC Bioinformatics, 12,
323.

Li,H. and Durbin,R. (2009) Fast and accurate short read alignment with Burrowsi
Wheeler transform. Bioinformatics, 25, 17544760.

Li,H. et al. (2009) The sequence alignment/map format and SAMtools.
Bioinformatics, 25, 207872079.

Li,J. et al. (2012) Normalization, testing, and false discovery rate estimation for
RNA—sequencing data. Biostatistics, 13, 5237538.

Liao,Y. and Shi,W. (2013) The Subread package: a toolkit for processing next—gen
sequencing data. http://subread.sourceforgenet (15 November 2013, date last
accessed). SourceForge package version 1.4.2.

Liao,Y. et al. (2013) The Subread aligner: fast, accurate and scalable read mapping
by seed—and—vote. Nucleic Acids Res., 41, e108.

Man,K. et al. (2013) The transcription factor IRF4 is essential for TCR afﬁnity—
mediated metabolic programming and clonal expansion of T cells. Nat.
Immunol, 14, 115571165.

Marco—Sola,S. et al. (2012) The GEM mapper: fast, accurate and versatile alignment
by ﬁltration. Nat. Methods, 9, 118571188.

McCarthy,D.J. et al. (2012) Differential expression analysis of multifactor RNA—
Seq experiments with respect to biological variation. Nucleic Acids Res., 40,
428874297.

Metzker,M.L. (2009) Sequencing technologiesthe next generation. Nature Rev.
Genet., 11, 31746.

Nookaew,I. et al. (2012) A comprehensive comparison of RNA—Seq—based
transcriptome analysis from reads to differential gene expression and cross—com—
parison with microarrays: a case study in Saccltaromyces cerevisiae. Ntwleic
Acids Res., 40, 1008¢10097.

Oshlack,A. et al. (2010) From RNA—seq reads to differential expression results.
Genome Biol, 11, 220.

Pages,H. et al. (2013) IRanges: infrastructure for manipulating intervals on se—
quences. R package version 1.18.4. http://www.bioconductor.org (30 April
2013, date last accessed).

Pal,B. et al. (2013) Global changes in the mammary epigenome are induced by
hormonal cues and coordinated by Ezh2. Cell Rep., 3, 4114126.

Park,P.J. (2009) Chijrseq: advantages and challenges of a maturing technology.
Nat. Rev. Genet., 10, 669$80.

Pruitt,K. et al. (2012) NCBI Reference Sequences (RefSeq): current status, new
features and genome annotation policy. Nucleic Acids Res., 40, D13(%D135.

Quinlan,A. and Hall,I. (2010) BEDTools: a flexible suite of utilities for comparing
genomic features. Bioinformatics, 26, 8417842.

Rapaport,F. et al. (2013) Comprehensive evaluation of differential gene expression
analysis methods for Rna—seq data. Genome Biol, 14, R95.

Reyes,A. et al. (2013) Drift and conservation of differential exon usage across tissues
in primate species. Proc. Natl Acad. Sci. USA, 110, 15377715382.

Robinson,M. et al. (2010) edgeR: a Bioconductor package for differential expres—
sion analysis of digital gene expression data. Bioinﬁ)rmatics, 26, 1397140.

Ross—Innes,C.S. et al. (2012) Differential oestrogen receptor binding is associated
with clinical outcome in breast cancer. Nature, 481, 3897393.

Schuster,S.C. (2008) Next—generation sequencing transforms today’s biology. Nat.
Methods, 5, lfrlS.

Shi,W. and Liao,Y. (2013a) Rsubread: an R package for the alignment, summar—
ization and analyses of next—generation sequencing data. R package version
1.12.2. http://www.bioconductor.org (20 November 2013, date last accessed).

Shi,W. and Liao,Y. (2013b) Subread/Rsubread Users Guide. http://bioinf.wehi.edu.
au/subread—package/SubreadUsersGuide.pdf (20 November 2013, date last
accessed). Version Subread 1.4.2/Rsubread 1.12.2.

Shi,L. et al. (2006) The microarray quality control (MAQC) project shows inter—and
intraplatform reproducibility of gene expression measurements. Nat.
Biotechnol, 24, 115171161.

Trapnell,C. et al. (2009) TopHat: discovering splice junctions with RNA—seq.
Bioiry’ornmtics, 25, 110571111.

Trapnell,C. et al. (2010) Transcript assembly and quantiﬁcation by RNA—seq reveals
unannotated transcripts and isoform switching during cell differentiation. Nat.
Biotechnol, 28, 5117515.

Valouev,A. et al. (2008) Genome—wide analysis of transcription factor binding sites
based on chip—seq data. Nat. Methods, 5, 8297834.

Wellcome Trust Sanger Institute. (2013) GFF (General Feature Format) speciﬁca—
tions document. http://www.sanger.ac.uk/resources/software/gff/spec.html. (7
July 2013, last date accessed).

Wu,H. et al. (2013) A new shrinkage estimator for dispersion improves differential
expression detection in RNA—seq data. Biostatistics, 14, 2327243.

Zhang,Y. et al. (2008) Model—based analysis of ChIP—Seq (MACS). Genome Biol, 9,
R137.

 

930

ﬁre'spzumofproyo'sopnuuowrorq/ﬁdnq

