Vol. 2618MB 2010, pages i367—i373
doi:1 0. 1 093/bioinformatics/btq21 7

 

Efficient construction of an assembly string graph using the

FM-index
Jared T. Simpson* and Richard Durbin

Wellcome Trust Sanger Institute, Wellcome Trust Genome Campus, Cambridge, C81 0 18A, UK

 

ABSTRACT

Motivation: Sequence assembly is a difficult problem whose
importance has grown again recently as the cost of sequencing has
dramatically dropped. Most new sequence assembly software has
started by building a de Bruijn graph, avoiding the overlap-based
methods used previously because of the computational cost and
complexity of these with very large numbers of short reads. Here,
we show how to use suffix array-based methods that have formed
the basis of recent very fast sequence mapping algorithms to find
overlaps and generate assembly string graphs asymptotically faster
than previously described algorithms.

Results: Standard overlap assembly methods have time complexity
0(N2), where N is the sum of the lengths of the reads. We use
the Ferragina—Manzini index (FM-index) derived from the Burrows—
Wheeler transform to find overlaps of length at least I among a set of
reads. As well as an approach that finds all overlaps then implements
transitive reduction to produce a string graph, we show how to output
directly only the irreducible overlaps, significantly shrinking memory
requirements and reducing compute time to 0(N), independent of
depth. Overlap-based assembly methods naturally handle mixed
length read sets, including capillary reads or long reads promised
by the third generation sequencing technologies. The algorithms we
present here pave the way for overlap-based assembly approaches
to be developed that scale to whole vertebrate genome de novo
assembly.

Contact: js18@sanger.ac.uk

1 INTRODUCTION

The sequence assembly problem is one of the most important and
difﬁcult problems in bioinformatics. Most genomes, particularly
eukaryotic genomes, are highly repetitive that complicates their
assembly by obscuring true relationships between reads with many
false options. To help disambiguate the true relationships between
the reads from those induced by different copies of repeats, it is
useful to construct a graph where all the copies of a repeat are
collapsed into a single segment. Such a graph is commonly referred
to as a repeat graph. This structure is a natural consequence of the
de Bruijn graph method of sequence assembly as the deconstruction
of the sequence reads into k-mers (short subsequences of the reads
of length k) collapses repeats that share the same k-mer into a
single vertex (Pevzner et al., 2001). An alternative formulation was
proposed by Gene Myers and is called the string graph (Myers,
2005). The string graph is built by ﬁrst constructing a graph of
the pairwise overlaps between sequence reads and transforming
it into a string graph by removing transitive edges. The string
graph shares with the de Bruijn graph the property that repeats are

 

*To whom correspondence should be addressed.

collapsed to a single unit without the need to ﬁrst deconstruct the
reads into k-mers. Because it is based on maximal overlaps, which
are typically longer than de Bruijn k-mers, it also disambiguates
shorter repeats that de Bruijn methods would only resolve in later
processing steps (if at all). The string graph is much more expensive
to construct, however, as the set of all pairwise, inexact overlaps
between sequence reads must be found. For this reason, the majority
of assemblers of short read sequence data have been based on
the de Bruijn approach (Chaisson and Pevzner, 2008; Simpson
et al., 2009; Zerbino and Bimey, 2008). A notable exception is
the Edena assembler (Hernandez et al., 2008) that uses a sufﬁx
array to compute exact overlaps between reads that are then used to
construct the string graph. We address the construction of a string
graph with a related approach by indexing the set of sequence
reads using the Burrows—Wheeler transform(BWT)/Ferragina—
Manzini(FM)-index, which has recently been used for the short
read alignment problem (Langmead et al., 2009; Li and Durbin,
2009; Li et al., 2009). We show how to efﬁciently compute the
set of overlaps needed to construct the string graph from the FM-
index. Furthermore, we show that the string graph can be constructed
directly using the FM-index without the need for explicitly ﬁnding
all overlaps and a subsequent transitive removal step, yielding a
space and time efﬁcient construction algorithm.

2 BACKGROUND

2.1 Deﬁnitions and notation

LetX be a string of symbols a1,...,al from an alphabet 2. The length
of X is denoted |X|. We consider all strings to be terminated by a
sentinel symbol $ that is not in 2 and is lexographically lower than
all the symbols in 2. X[i] =al- is the i-th symbol ofX and X[i,j] is
the substring ai, ...,aj. A substring X[k, |X|] is a suﬁx ofX and a
substring X[l,k] is apreﬁx of X. Let X’=al,al_l-, ...,a1 denote the
reverse of X.

2.2 Genomes and sequence reads

We deﬁne a genome to be a long string from the alphabet {A, C, G, T}
representing the complete DNA sequence of an individual, for
simplicity ignoring potential subdivisions into chromosomes.
A sequence read is a short substring from a genome. DNA is a
double stranded molecule and sequence reads can originate from
either strand. We use the notation X for the reverse-complement of
a read X. In a shotgun sequencing experiment, a set of sequence
reads, which we denote by the indexed set R, is randomly sampled
from a genome with an unknown sequence. The sequence assembly
problem is to reconstruct the sequence of the genome given R. We
say that two reads X and Y overlap if a preﬁx of X is equal to
a sufﬁx of Y or vice versa. If X and Y originate from opposite
strands, they overlap if the reverse complement of one of them

 

© The Author(s) 2010. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non—Commercial License (http://creativecommons.org/licenses/
by—nc/2.5), which permits unrestricted non—commercial use, distribution, and reproduction in any medium, provided the original work is properly cited.

112 /3.Io's[Bumo[pJOJXO'sorwuiJOJurorqp:duq 11101} pQPBOIHMOG

910E ‘IE JSHBHV 110::

J.T.Simpson and R.Durbin

 

overlaps the other. To help distinguish true overlaps from spurious
overlaps, we set a threshold of ‘L' on the minimum acceptable overlap
length. We assume for the moment that sequence reads are perfect
representations of the genome—there are no sequencing errors. We
discuss how to relax this constraint in the discussion at the end of
this article.

2.3 Overlap and string graphs

To help reconstruct the source genome from R, we can build a graph
of the relationships between sequence reads. One such graph is the
overlap graph. In the overlap graph, each sequence read in R is a
vertex and two vertices are joined by an edge if their corresponding
reads overlap. Myers’ string graph is a reﬁnement of such a graph.
In the string graph, reads that are contained within some other read,
that is they are a substring of (or perhaps identical to) another read,
are considered to be redundant and are not vertices in the graph. Each
edge in a string graph is bidirectional to model the double-stranded
nature of DNA and labelled with the unmatched substrings of the
sequence reads. More formally, let X and Y be two reads where
X [sxy,exy] = Y [syx, eyx]. We call X [sxy,exy] the matched portion of
X and the remainder unmatched. If sxy = 1 and exy = |X | the entirety
ofX is matched by Y and X is said to be contained by Y. If Y is
also contained by X (st = 1 and eyx = |Y|), X and Y are identical. In
this case, we break the tie by saying the read with the higher index
in R is contained within the read with the lower index. If neither
X nor Y are contained and X [sxy,exy] is a preﬁx of X (sxy = 1) and
Y[syx,eyx] is a sufﬁx of Y (eyx=|Y|), or vice versa, we say the
overlap between X and Y is proper. If X and Y are reads from
opposite strands of the genome they can still form an overlap. In this
case, X[sxy,exy]=Y[syx,eyx] and both X[sxy,exy] and Y[syx,eyx]
must be preﬁxes or both must be sufﬁxes.

All non-contained reads are vertices in the string graph. For each
proper overlap between two reads, we add a bidirected edge to
the graph X <—>Y. The bidirected edge describes the nature of the
overlap between the reads and has two labels, one for each of the
unmatched substring of the reads. We denote the tuple of data for
each edge as (typexy,typeyx,labelxy,labelyx). We deﬁne the typexy
property (respectively, typeyx) as:

I _ B ifsxy=1
ypexy— E ifexy=|X|

In other words, typexy is B if the matched portion of X is a preﬁx
of X , otherwise the matched portion of X must be a sufﬁx and typexy
is E. Note that since the graph does not have contained reads these
cases are mutually exclusive. The labelxy property is

Y[e‘x+1,|Y|] ifstx=1
labelxy=l Y[1y,syx— 1] ife:x= |Y|

Restated, labelxy is the unmatched sufﬁx of Y if the matched
portion of Y is a preﬁx and vice versa. The concatenation of X
and labelxy is an assembly of reads X and Y — the resulting string
contains both the sequence of X and Y. If the overlap between X
and Y is reverse complemented, i.e. X [sxy,exy]=Y [syx,eyx] then
labelxy and labelyx are also reverse complemented. Note that in the
case of an edge built from a reverse-complement overlap, typexy
is necessarily the same as typeyx. To perform a walk in the string
graph, if one enters a vertex on an edge of type B then an edge of

A R1 ACATACGATACA
R2 TACGATACAGTT
R3 GATACAGTTGCA

B 9
K 6‘
K A o
e v
9 re"
GTTGCA
ACATAC
Fig. 1. Diagram of a simple string graph. Three overlapping reads

(R 1 , R2 , R3) are shown in (A). (B) shows the string graph constructed from the
overlaps between the reads. The arrowheads pointing into the nodes depict

   

an edge of type B and arrowheads pointing away from the nodes depict edges
of type E. The edge R1 <—>R3 is transitive.

type E must be used to exit and vice versa. Figure 1 depicts a simple
string graph built from three overlapping reads.

The initial graph built from the overlaps between reads is not a
string graph yet. Consider a read X that overlaps reads Y and Z,
which mutually overlap. The initial string graph will contain the
edges X <—> Y, X <—>Z and Y <—>Z. If Y and Z overlap the same end of
X, i.e typexy = typexz, then Y and Z must share a common substring
of X which is a preﬁx or sufﬁx of one of Y or Z. This implies that
there is a valid path that visits each of the three reads in succession.
Let X —> Y —>Z be such a path. The string corresponding to this
path is a valid assembly of the three reads which is identical to
the string corresponding to the path X —>Z. In this case, we say
that the edge X <—>Z is transitive. We will refer to non-transitive
edges as irreducible. The transitive edges can be removed from
the graph without losing any information—the transitive edges
(and their corresponding overlaps) could be inferred from the
irreducible edges. We can determine useful properties of transitive
and irreducible edges. As the graph does not have contained reads,
the length of the overlap between X <—> Y is necessarily larger than
the overlap between X <—>Z. Equivalently, the length of labelxy is
shorter than labelxz, and labelxz can be seen as the concatenation of
labelxy and labelyz. In other words, labelxy of the irreducible edge
is a preﬁx of labelxz of the transitive edge.

2.4 The sufﬁx array, BWT and FM-index

The suﬂix array data structure was introduced by Manber and Myers
(1990) as a succinct representation of the lexographic ordering of
the sufﬁxes of a string. The sufﬁx array of a string X, denoted SAX,
is a permutation of the integers {1,2, ..., |X|} such that SAX[i] =j iff
X [j, |X |] is the i-th lexographically lowest sufﬁx of X . For example,
ifX =AAGTA$ then SAX = [6,5, 1,2, 3,4]. Since the sufﬁx array is
a sorted data structure, the start positions of all the instances of a
pattern Q in X will occur in an interval in SAX. We refer to such
an interval as a suﬁx array interval and associate with it a pair of
integers [l , u] denoting the ﬁrst and last index in SAX that correspond
to a position in X of an instance of Q. Using SAX and the original
string X, l and u can be efﬁciently found with a binary search for Q.
Ferragina and Manzini developed a related method of indexing text,
called the FM-index, which requires considerably less memory than
a sufﬁx array and can compute l and u in 0(|Q|) time, independent

 

i368

112 /3.Io's[BumolpJOJXO'sorwuiJOJurorq”:duq mot} popcolumoq

9103 ‘{g anﬁnv 110::

String graph construction

 

of the size of the text being searched. Central to the FM-index is
the BWT. Originally developed for text compression (Burrows and
Wheeler, 1994) the BWT of X, denoted BX, is a permutation of the
symbols of X such that

if SAX [i] > 1

X[SAX[i] — 1]
$ if SAX[i] =1

Bx[i1={

Restated, BX[i] is the symbol preceding the ﬁrst symbol of
the sufﬁx starting at position SAX[i]. Ferragina and Manzini
(2000) extended the BWT representation of a string by adding
two additional data structures to create a structure known as the
FM-index. Let CX(a) be the number of symbols in X that are
lexographically lower than the symbol a and Och(a,i) be the
number of occurrences of the symbol a in BX[1 , i]. We note that CX
and Och include counts for the sentinel symbol, $. Using these
two arrays, Ferragina and Manzini provided an algorithm to search
for a string Q in X (Ferragina and Manzini, 2000). Let S be a string
whose sufﬁx array interval is known to be [1, u]. The interval for the
string aS can be calculated from [1,14] using CX and Och by the
following:

1=Cx(a)+0ccx(a,l—1) (l)

u = CX(a)+Och (a, u) — 1 (2)

We encapsulate Equations (1) and (2) in the following algorithm,
updateBackward.

 

Algorithm 1 updateBackward([l, u], a)
1(— Cx(a) +Och(a, l — l)
u <— CX(a) +Occx(a, u) — 1
return [1, u]

 

 

To search for a string Q, we need to ﬁrst calculate the interval
for the last symbol in Q then use Equations (1) and (2) to
iteratively calculate the interval for the remainder of Q. The
interval for a single symbol is simply calculated from CX. The
backwardsSearch algorithm presents the searching procedure in
detail. If backwardsSearch returns an interval where l>u, Q is
not contained in X otherwise SAX[i] is the position in X of each
occurrence of Q for lg isu.

 

Algorithm 2 backwardsSearch(Q) - ﬁnd the interval in SAX for the
pattern Q
i<— |Q|
1 <— CX(Q[il)
'4 <—CX(Q[i] + 1)— 1
i<— i — 1
whilelsu&i21 do
[1,u] <— updateBackward([l, u], Q[i])
i <—i — 1
end while
return [1 ,u]

 

 

The backwardsSearch algorithm requires updating the sufﬁx array
interval |Q| times. As each update is a constant-time operation,
the complexity of backwardsSearch is 0(|Q|). To save memory
Och(a,i) is stored only for i divisible by d (typically d is
around 128). The remaining values of Och can be calculated as
needed using the sampled values and BX.

2.5 The generalized sufﬁx array

We can easily expand the deﬁnition of a sufﬁx array to include
multiple strings. Let ’Tbe an indexed set of strings and ’7; be element
7'[i]. We deﬁne SAT[i] = (j, k) iff71'~[k, |7J'~|] is the i-th lowest sufﬁx
in 7'. In the generalized sufﬁx array, unlike the sufﬁx array of a single
string, two sufﬁxes can be lexographically equal. We break ties in
this case by comparing the indices of the strings. In other words, we
treat each string in 7' as if it was terminated by a unique sentinel
character S,- where S,- < $j when i < j. We extend the deﬁnition of the
BWT to collections of strings as follows. Let SAT[i] =(j,k) then

._ ’7;[k—1] ifk>1
BT[‘]_{$ ifk=1
Like the BWT of a single string, B7 is a permutation of

the symbols in 7'; therefore, the deﬁnitions of the auxiliary data
structures for the FM-index, CT(a) and OccT(a, i), do not change.

3 METHODS

The construction of the string graph occurs in two stages. First, the complete
set of overlaps of length at least I is computed for all elements of R. The
initial overlap graph is then built as described in Section 2.3 and transformed
into the string graph using the linear expected time transitive reduction
algorithm of Myers (2005). The ﬁrst step in this process is the computational
bottleneck. The all-pairs maximal overlap problem can be optimally solved
in 0(N+k2) time using a generalized sufﬁx tree where N |Ri| and
k = |R| (Gusﬁeld, 1997). It is straightforward to restrict this algorithm to only
ﬁnd overlaps of length at least I at a lower computational cost; however, the
amount of memory required for a sufﬁx tree makes this algorithm impractical
for large datasets. Myers” proposed the use of a q-gram ﬁlter to ﬁnd the
complete set of overlaps. This requires 0(N2/D) time where D is a time-
space tradeoff factor dependent on the amount of memory available. We will
show that by using the FM-index of R the set of overlaps can be computed
in 0(N +C) time for error-free reads where C is the total number of overlaps
found. We then provide an algorithm that detects only the overlaps for
irreducible edgesiremoving the need for the transitive reduction algorithm
and allowing the direct construction of the string graph.

3.1 Building an FM-index from a set of sequence reads

To build the FM-index of R, we must ﬁrst compute the generalized sufﬁx
array of R. We could do this by creating a string that is the concatenation
of all members of R, S =R 1R2...Rm and then use one of the well-known
efﬁcient sufﬁx array construction algorithms to compute SAS (Puglisi et al.,
2007). We have adopted a different strategy and have modiﬁed the induced-
copying sufﬁx array construction algorithm (Nong et al., 2009) to handle
an indexed set of strings R where each sufﬁx array entry is a pair U,k) as
described in Section 2.5. This sufﬁx array construction algorithm is similar
to the KoiAluru algorithm (Ko and Aluru, 2005). A set of substrings of the
text (termed LMS substrings for leftmost S-type, see Nong et al., 2009) is
sorted from which the ordering of all the sufﬁxes in the text is induced.
Our algorithm differs from the Nongizhang£han algorithm as we directly
sort the LMS substrings using multikey quicksort (Bentley and Sedgewick,
1997) instead of sorting them recursively. This method of construction is
very fast in practice as typically only 30—40% of the substrings must be
directly sorted. Once SAR has been constructed, the BWT of R, and hence
the FM-index is easily computed as described above. We also compute the
FM-index for the set of reversed reads, denoted R’, which is necessary to
compute overlaps between reverse complemented reads. We also output the
lexographic index of R, which is a permutation of the indices {1,2,  |R|}
of R sorted by the lexographic order of the strings. This can be found directly
from SAR and is used to determine the identities of the reads in R from the
sufﬁx array interval positions once an overlap has been found.

 

i369

112 /3.IO'S[1211,1110prOJXO'SOIJBLUJOJIIIOIq”Idllq wort pepeolumoq

9103 ‘{g isnﬁnv uo ::

J.T.Simpson and R.Durbin

 

3.2 Overlap detection using the FM-index

We now consider the problem of constructing the set of overlaps between
reads in R. Consider two reads X and Y. If a sufﬁx of X matches a preﬁx
of Y an edge of type (E ,B) will be created in the initial overlap graph. We
will describe a procedure to detect overlaps of this type from the FM-index
of R. Let X be an arbitrary read in R. If we perform the backwardsSearch
procedure on the string X , after k steps we have calculated the interval [1, u]
for the sufﬁx of length k of X. The reads indicated by the sufﬁx array entries
in [1,14], therefore, have a substring that matches a sufﬁx of X. Our task is
to determine which of these substrings are preﬁxes of the reads. Recall that
if a given element in the sufﬁx array, SAR[i], is a preﬁx then BR[i] =$ by
deﬁnition. Therefore, if we know the sufﬁx array interval for a string P, the
interval for the strings beginning with P can be determined by calculating
the interval for the string $P using Equations (1) and (2). This interval,
denoted [l$,u$], indicates that the reads with preﬁx P are the l$-th to u$-th
lexographically lowest strings in R. We can, therefore, recover the indices in
R of the reads overlapping X using lexographic index of R. The algorithm
is presented below in ﬁndOverlaps.

 

Algorithm 3 ﬁndOverlaps(X, 1') - determine the reads in R that
overlap X by at least 1' symbols
i<— |X |
l <— CR (X [i])
u<—CR(X[i]+ 1)— 1
i<— i — 1
whilelsu&i21 do
if |X| —i+ 1 2‘17 then
[155 , 14$] <— updateBackwards([l , u], S)
if 155 E 14$ then
outputOverlaps(X , [l$ , 1455])
end if
end if
[1 , u] <— updateBackward([l , u] , X [i])
i<—i — 1
end while
if 13 u then
outputContained(X, [l , 14])
end if

 

 

The ﬁndOverlaps algorithm is similar to the backwards search procedure
presented in Section 2.4. It begins by initializing [1,u] to the interval
containing all sufﬁxes that begin with the last symbol of X. The interval
[1, u] is then iteratively updated for longer sufﬁxes of X. When the length of
the sufﬁx is at least the minimum overlap size, I, we determine the interval
for the reads that have a preﬁx matching the sufﬁx of X and output an
overlap record for each entry (using the subroutine outputOverlaps). When
the update loop terminates, [1, u] holds the interval corresponding to the full
length of X. The outputContained procedure writes a containment record
for X if X is contained by any read in [La] based on the rules described in
Section 2.3. The overlaps detected by ﬁndOverlaps correspond to edges of
type (E ,B). We must also calculate the overlaps for edges of type (E ,E) and
(B, B), which arise from overlapping reads originating from opposite strands.
To calculate edges of type (E ,E), we use ﬁndOverlaps on the complement
of X (not reversed) and the FM-index of R’ . Similarly, to calculate edges of
type (B,B), we use ﬁndOverlaps on X (the reverse complement of X) and
the FM-index of R.

The overlap records created by outputOverlaps are constructed in constant
time as they only require a lookup in the lexographic index of R. Let
C,» be the number of overlaps for read R). The ﬁndOverlaps algorithm
makes at most |Ri| calls to updateBackwards and a total of C,» iterations in
outputOverlaps for a total complexity of 0(|Ril +61). For the entire set R, the
complexity is 0(N +C) where C 2:17:11 0,». Note that the majority of these
edges are transitive and subsequently removed. We can, therefore, improve

this algorithm by only outputting the set of irreducible edges, allowing the
direct construction of the string graph. We address this in Section 3.3.

In rare cases, multiple valid overlaps may occur between a pair of reads. In
this case, the intervals detected during ﬁndOverlaps will contain intersecting
or duplicated intervals. To handle this, we can modify ﬁndOverlaps to ﬁrst
collect the entire set of found intervals. This interval set could then be sorted
and duplicated or intersecting intervals that represent sub-maximal overlaps
can be removed. The outputOverlaps procedure can be called on the entire
reduced interval set to output the set of maximal overlaps.

3.3 Detecting irreducible overlaps

To directly construct the string graph, we must only output irreducible edges.
Recall from Section 2.3 that the labels of the irreducible edges for a given read
are preﬁxes of the labels of transitive edges. We use this fact to differentiate
between irreducible and transitive edges during the overlap computation.
Consider a read X and the set of reads that overlap a sufﬁx of X , (9. We
could devise an algorithm to ﬁnd the subset consisting only of irreducible
edges by calculating the edge-labels of all members of O and ﬁltering out
the members whose label is the extension of the label of some other read.
This would require iterating over all members of O, which can be quite
large for repetitive reads. We will now show that the labels of the irreducible
edges can be constructed directly from the sufﬁx array intervals using the
FM-index.

Consider a substring S that occurs in R and its sufﬁx array interval [1, a].
Let a left extension of S be a string of length |S| +1 of the form aS. We can
use BR [1,u] to determine the set of left extensions of S. Let B be the set of
symbols that appear in the substring BR [1, u]. The left extensions of S are the
strings aS such that a e 8. Note that we do not have to iterate over the range
BR [1,u] to determine 8. Since OccR(a,i) is deﬁned to be the number of
times symbol a occurs in BR[1, i] we can count the number of occurances of
a in BRU, u] (and hence aS in R) in constant time by taking the difference
OccRm, u) — OccR(a, l — 1). If the $ symbol occurs in BRU, u] we say that
S is left terminal, in other words one of the elements of R has S as a preﬁx.
We similarly deﬁne a right extension of S as a string of length |S| +1 of the
form Sa. While we cannot build the right extensions of S directly from the
FM-index, the right extensions of S are equivalent to left extensions of S’
(the reverse of S) in R’. Let S be right terminal if $ exists in BR~[1’,u’], in
other words S is a sufﬁx of some string in R.

The procedure to ﬁnd all the irreducible edges of a read X and construct
their labels is to ﬁnd all the intervals containing the preﬁxes of reads that
overlap a sufﬁx of X , then iteratively extend them rightwards until a right-
terminal extension is found. The terminated read forms an irreducible edge
withX and the label of the edge is the sequence of bases that were used during
the right-extension. All non-terminated strings with the same sequence of
extensions are transitive and, therefore, not considered further.

The algorithm requires searching the FM-index in two directions, ﬁrst
backwards to determine the intervals of overlapping preﬁxes and then
forwards to extend those preﬁxes and build the irreducible labels. Naively
this would require ﬁrst determining the intervals [1,u] for each matching
preﬁx, P, and then reversing the preﬁx and performing a backwards search
on the FM-index of R’ to ﬁnd the interval [1’ , u’] for P’ . The intervals [1’ ,u’]
would then be used in the extension stage to determine the labels of the
irreducible edges. We can do better, however, by noting that the interval
[1’ , u’] can be calculated directly during the backwards search without using
the FM-index of R’. We deﬁne OchTR(a, i) to be the number of symbols
that are lexographically lower than a in BR [1 , i]. Let S=X[i, |X|] be a sufﬁx
of X and [1,, 14,] its sufﬁx array interval. Suppose we know the interval [11114;]
for S’ in R’. Let a=X[i— 1]. The interval for Sci: [11 u;_l] is therefore

i—l’

t;_, :1; +(OchTR(a,u,)—OchTR(a,l, — 1)) (3)

u;_l =11;l +(OccR(a,ui)— OccR(a, 1,» — 1) — 1) (4)

The interval for X ’ [1] is identical to that of X [|X |], since BR and 137;» are
both permutations of symbols in R, therefore, CR 2 CR» . We can, therefore,

 

i370

112 /3.IO'S[1211,1110prOJXO'SOIJBLUJOJIIIOIq”K1111] uror} pepeo1umoq

9103 ‘1gisn8nv uo ::

String graph construction

 

initialize the interval [1’ ,u’] to the same initial value of [La] and perform a
forward search of X’ simulatenously while performing a backward search of
X using only the FM-index of R. This does not require any additional storage
as the OchTR array can easily be computed from OccR by summing
the values for symbols less than a. This procedure is similar to the 2way-
BWT search recently proposed by Lam et a1. (2009). The updaterdde
algorithm implements Equations (3) and (4) along with updateBackward to
calculate the pair of intervals. The J: parameter to updaterdde indicates
the FM-index used 7 that of R or R’.

Algorithm 4 updaterdde([l,u, l’ ,u’], a, .77)
1’ <—1’+(OchT]:(a,u)—OchT]:(a,1— 1))
u’<—1’+(Occ]:(a,u)—Occ]:(a,1— 1)—1)
[1,u] <—updateBackwards(l, u, a, .77)
return [1,u,1’,u’]

 

 

 

We now give the full algorithm for detecting the irreducible overlaps for
a read X. The algorithm is performed in two stages, ﬁrst a backwards search
on X is performed to collect the set of interval pairs, denoted I, for preﬁxes
that match a sufﬁx of X. This algorithm is presented in ﬁndIntervals below
and is conceptually similar to ﬁndOverlaps.

 

Algorithm 5 ﬁndIntervals(X, T)
I<—l[l
i<— |X|
l<—C(X[i])
u<—C(X[i]+1)—1
[l’,u’] <—[l,u]
i<—i—l
whilelsu&i21 do
if |X|—i—l—12‘E then
[l$,u$,l§£,ugs] <—updaterdde([l,u,l’,u’],$,R)
if 155 314$ then
If—IU[1$,u$,l§B,u§S]
end if
end if
[l,u,l’,u’] <—updaterdde([l,u,l’,u’],X[i],R)
i<—i—l
end while
return I

 

 

The interval set found by ﬁndIntervals is processed by extractIrreducible to
ﬁnd the intervals corresponding to the irreducible edges of X. This algorithm
has two parts. First, the set of intervals is tested to see if some read in the
interval set is right terminal. If so, the intervals corresponding to the right
terminal reads form irreducible edges with X and are returned. If no interval
has terminated, we create a subset of intervals for each right extension of I
and recursively call extractIrreducible on each subset.

The algorithm above assumes that there are no reads that are strict
substrings of other reads (in other words, all the containments are between
identical reads). If this is not the case, a slight modiﬁcation must be made.
If the set of reads overlapping X includes a read that is a proper substring of
some other read it is possible that the ﬁrst right terminal extension found is
not that of an irreducible edge but of the contained read. It is straightforward
to handle this case by observing that such a read will have an overlap which
is strictly shorter than that of the irreducible edge. In other words, the only
acceptable right terminal extension is to the reads in I that have the longest
overlap with X.

We can similarly modify extractIrreducible to handle overlaps for reads
from opposite strands. To do this, we use ﬁndIntervals to determine the
intervals for overlaps for the same strand as X and overlaps from the opposite
strand of X (using the complement of X as in the previous section). When
extending an interval that was found by the complement of X , we extend

 

Algorithm 6 extractIrreducible(l')
if I = ((1 then
return it)
end if
[I <— ((1
for all [l,u,l’,u’] 61' do
[l$,ugs,l$,u$] <—updaterdde([l’,u’,l,u],$,R’)
if 155 314$ then
I: (— l: U [13; , 14$]
end if
end for
if [1 7S ((1 then
return [I
end if
for all a e 2 do
L, <— ((1
for all [1,u,1’,u’]el' do
[12,u;,la,ua] <—updaterdde([l’,u’,l,u],a,R’)
if 101 fun then
Ia <—l'a U[la,ua,l:1,u:1]
end if
end for
[I <— £ U extractIrreducible(l'a)
end for
return [I

 

 

it by the complement of a. In other words, if we are extending same-strand
intervals by A, we extend opposite strand intervals by T and so on.

We now offer a sketch of the complexity of the irreducible overlap
algorithm. Let L, be the label of irreducible edge i. During the construction
of L, at most k, intervals must be updated, corresponding to the number of
reads that have an edge-label containing L». The sum over all irreducible
edges, E =Zi(|Li|ki), is the total number of interval updates performed by
extractIrreducible. Note that each read in R is represented by a path through
the string graph. The total number of times edge i is used in the set of paths
spelling all the reads in R is k, and the amount of sequence in R contributed
by edge i is |L,»|k,». This implies E can be no larger than N , the total amount
of sequence in R, and extractIrreducible is 0(N). As ﬁndIntervals is also
0(N), the entire irreducible overlap detection algorithm is 0(N).

4 RESULTS

As a proof of concept, we implemented the above algorithms. The
program is broken into three stages: index, overlap and assemble.
The index stage constructs the sufﬁx array and FM-index for
a set of sequence reads, the overlap stage computes the set of
overlaps between the reads and the assemble stage builds the string
graph, performs transitive reduction if necessary, then compacts
unambiguous paths in the graph and writes out a set of contigs.
We tested the performance of the algorithms with two sets of
simulations. In both sets of simulations, we compared the exhaustive
overlap algorithm (which constructs the set of all overlaps) and
the direct construction algorithm (which only outputs overlaps for
irreducible edges). First, we simulated Escherichia coli read data
with mean sequence depth from 5x to 100>< to investigate the
computational complexity of the overlap algorithms as a function
of depth. After constructing the index for each dataset, we ran the
overlap step in exhaustive and direct mode with ‘L' = 27. The running
times of these simulations are shown in Figure 2. As expected,

 

i371

112 /3.IO'S[1211anprOJXO'SOIJBLUJOJIIIOIq”K1111] uror} pepeo1umoq

9103 ‘1gisn8nv uo ::

J.T.Simpson and R.Durbin

 

 

 

 

 

 

O
O—
O
(V)
@
(D
g 8—
l— 8
3
a.
O
O
O_
O
I Overlap (exhaustive)
O I Overlap (direct)

 

 

| | | | |
20 4O 60 80 100

Sequence Depth

Fig. 2. The running time of the direct and exhaustive overlap algorithms
for simulated E. coli data with sequence depth from 5 X to 100x. The direct
overlap algorithm scales linearly with sequence depth. As the number of
overlaps grows quadratically with sequence depth, the exhaustive overlap
algorithm exhibits above-linear scaling.

the direct overlap algorithm scales linearly with sequence depth.
The exhaustive overlap algorithm exhibits the expected above-
linear scaling as the number of overlaps for a given read grows
quadratically with sequence depth.

To assess the quality of the resulting assembly, we assembled the
data using the direct overlap algorithm and compared the contigs to
the reference. For each level of coverage, we selected I to maximize
the assembly N50 value. The N50 values ranged from 1.7 kbp (5 X
data, I: 17) to 80 kbp (100>< data, 1:85). We aligned the contigs
to the reference genome with bwa-sw (Li and Durbin, 2010) and
found that no contigs were misassembled.

We also simulated data from human chromosomes 22, 15, 7 and
2 to assess how the algorithms scale with the size of the genome.
We pre-processed the chromosome sequences to remove sequence
gaps then generated 100 bp error-free reads randomly at an
average coverage of 20X for each chromosome. The results of
the simulations are summarized in Table 1. The running time of
the exhaustive and direct overlap algorithms are comparable. As
the sequence depth is ﬁxed at 20x, both overlap algorithms scale
linearly with the size of the input data. The ﬁnal stage of the
algorithm, building the string graph and constructing contigs, is
much shorter for the direct algorithm as the transitive reduction
step does not need to be performed. In addition, this step requires
considerably less memory as the initial graph constructed by the
direct algorithm only contains irreducible edges.

The bottleneck in terms of both computation time and memory
usage is the indexing step, which builds the sufﬁx array and FM-
index for the entire read set. This required 8.5h and ~55 GB
of memory for chromosome 2. Extrapolating to the size of the
human genome indicates it would require ~4.5 days and 700 GB
of memory to index 20>< sequence data. While the computational
time is tractable, the amount of memory required is not practical for
the routine assembly of human genomes. We address ways to reduce
the computational requirements in Section 5.

Table 1. Simulation results for human chromosomes 22, 15, 7 and 2

 

chr 22 chr 15 chr 7 chr 2 ratio

 

Chr. size (Mb) 34.9 81.7 155.4 238.2 6.8
Number of reads (M) 7.0 16.3 31.1 47.6 6.8
Contained reads (k) 684 1668 3103 4709 6.9
Contained (%) 9.8 10.2 10.0 9.9 7
Transitive edges (M) 38.0 93.0 177.7 274.6 7.2
Irreducible edges (M) 6.3 14.9 28.7 44.4 7.0
Assembly N50 (kbp) 4.0 4.6 4.2 4.7 7
Longest contig (kbp) 31.9 47.7 53.1 48.6 7
Index time (s) 2606 9743 19 779 30 866 11.8
Overlap -e time (s) 2657 6572 12 970 18 060 6.8
Overlap -d time (s) 2885 6750 13 271 19 437 6.7
Assemble -e time (s) 1836 4043 8112 13 095 7.1
Assemble -d time (s) 423 1161 204-4 3226 7.6
Index memory (GB) 8.0 18.6 35.4 54.5 6.8
Overlap -e mem. (GB) 2.4 5.5 10.5 16.1 6.7
Overlap -d mem. (GB) 2.4 5.5 10.4 16.1 6.7
Assemble -e mem. (GB) 5.9 14.2 27.2 41.9 7.1
Assemble -d mem. (GB) 2.7 6.3 12.1 18.6 6.9

 

For the overlap and assemble rows, -e and -d indicate the exhaustive and direct
algorithms, respectively. The last column is the ratio between chromosome 2 and 22.

5 DISCUSSION

We have described an efﬁcient method of constructing a string
graph from a set of sequence reads using the FM-index. This
work is the ﬁrst step in the construction of a new, general purpose
sequence assembler that will be effective for both short reads of
the current generation of sequence technology and the longer reads
of the sequencing instruments on the horizon. Unlike the de Bruijn
graph formulation, the string graph is particularly well-suited for the
assembly of mixed length read data. While the primary algorithms
are in place, a considerable amount of work remains. Most pressing
is the issue of adapting the assembler to handle real sequence
data that contains base-calling errors. This amounts to adapting
the algorithms to handle inexact overlaps. The BWA, Bowtie and
SOAP2 aligners implement a number of strategies and heuristics
for dealing with base mismatches and small insertion/deletions
(Langmead et al., 2009; Li and Durbin, 2009; Li et al., 2009).
These strategies directly translate to ﬁnding overlaps. Let 6 be the
maximum allowed difference between two overlapping reads. When
performing the backwards search to ﬁnd overlaps, we can allow the
search to proceed to mismatched bases or gaps while ensuring that
the e bound is respected. We can similarly modify the irreducible
overlap detection algorithm by allowing the right-extension phase to
extend to mismatch bases or gaps. Here, we would only consider an
interval to be transitive with respect to one of the irreducible intervals
if the inferred difference between the intervals is less than 6.

Our intention is to build an assembler that can handle genomes up
to several gigabases in size, such as for human or other vertebrate
genomes and our initial results indicate that our algorithms scale
well. The introduction of sequencing errors will increase the
complexity of the irreducible overlap identiﬁcation step but this
step is straightforward to parallelize if necessary because it is
carried out for each non-contained read. The construction of the
sufﬁx array is currently the computational bottleneck; however,
there are a number of established ways to improve this. We can

 

i372

112 /3.Io's1eu1noipJOJXO'sorwuiJOJurorq”:duq uror} pepeo1umoq

9103 ‘1gisn8nv uo ::

String graph construction

 

lower the amount of memory required by exploiting the redundancy
present in a set of sequencing reads by using a compressed
index. The compressed sufﬁx array is one such index and a
method was recently developed to merge two compressed sufﬁx
arrays that possibly allows a distributed construction algorithm
(Siren, 2009). Additionally, efﬁcient external memory (disk-based)
BWT construction algorithms have been developed that allow the
construction of the FM-index for very large datasets while using a
limited amount of main memory (Dementiev et al., 2008; Ferragina
et al., 2010).

It is worth investigating the equivalency of the de Bruijn graph
and string graph formulations (Pop, 2009). This has been studied
in terms of the computational complexity of reconstructing the
complete sequence of the genome and both formulations have been
shown to be NP-hard (Medvedev et al., 2007). We would like to
know the equivalence in terms of the information contained in the
graph. Consider the case where all sequence reads are of length l and
every l-mer in the genome has been sampled once. In this case, the
de Bruijn graph and string graph constructions (using parameters
k=l—1 and ‘L'=l—1 respectively) are equivalent. In the realistic
case where the genome is unevenly sampled, the relationship is
not clear. In the original paper on the EULER assembler Pevzner
presents an algorithm to recover the information lost during the
deconstruction of reads into k-mers by ﬁnding consistent read-paths
through the k-mer graph (Pevzner et al., 2001). It is conceivable that
if this procedure is able to perfectly reconstruct the information lost
the resulting graph would be equivalent to Myers’ string graph. This
is not clear, however, and the equivalency of these formulations is
a question we would like to address.

ACKNOWLEDGEMENTS

We thank Veli Makinen and members of the Durbin group for
discussions related to string matching and sequence assembly.

Funding: This work was supported by the Wellcome Trust (grant
number WT077192). J TS. is supported by a Wellcome Trust Sanger
Institute Research Studentship.

Conﬂict of interest: none declared.

REFERENCES

Bentley,J.L. and Sedgewick,R. (1997) Fast algorithms for sorting and searching strings.
In SODA '97: Proceedings of the Eighth Annual ACM-SIAM Symposium on Discrete
Algorithms. Society for Industrial and Applied Mathematics, Philadelphia, PA,
pp. 36%369.

Burrows,M. and Wheeler,D.J. (1994) A block-sorting lossless data compression
algorithm. In Technical report 124, Digital Equipment Corporation, Palo Alto, CA.

Chaisson,M.J. and Pevzner,P.A. (2008) Short read fragment assembly of bacterial
genomes. Genome Res, 18, 3247330.

Dementiev,R. et al. (2008) Better external memory sufﬁx array construction. J. Exp.
Algorithmics, 12, 1724.

Ferragina,P. and Manzini,G. (2000) Opportunistic data structures with applications. In
Proceedings of the 41st Symposium on Foundations of Computer Science ( F OCS
2000), IEEE Computer Society, Los Alamitos, CA, USA, pp. 39w398.

Ferragina,P. et al. (2010) Lightweight data indexing and compression in external
memory. In Proceedings of the Latin American Theoretical Informatics Symposium.
Lecture Notes of Computer Science, Springer, Heidelberg, Germany.

Gusﬁeld,D. (1997) Algorithms on Strings, Trees, and Sequences : Computer Science
and Computational Biology. Cambridge University Press, Cambridge, UK.

Hernandez,D. et al. (2008) De novo bacterial genome sequencing: millions of very
short reads assembled on a desktop computer. Genome Res, 18, 8027809.

Ko,P. and Aluru,S. (2005) Space efﬁcient linear time construction of sufﬁx arrays.
J. Discrete Algorithm, 3, 1437156.

Lam,T. W. et al. (2009) High throughput short read alignment via bi-directional bwt. In
2009 IEEE International Conference on Bioinformatics and Biomedicine, Vol. 0.
IEEE, Los Alamitos, CA, pp. 31736.

Langmead,B. et al. (2009) Ultrafast and memory-efﬁcient alignment of short DNA
sequences to the human genome. Genome Biol, 10, R25+.

Li,H. and Durbin,R. (2009) Fast and accurate short read alignment with Burrows-
Wheeler transform. Bioinformatics, 25, 175471760.

Li,H. and Durbin,R. (2010) Fast and accurate long-read alignment with Burrows-
Wheeler transform. Bioinformatics, 26, 5897595.

Li,R. et al. (2009) Soap2: an improved ultrafast tool for short read alignment.
Bioinformatics, 25, l96&1967.

Manber,U. and Myers,G. (1990) Sufﬁx arrays: a new method for on-line string searches.
In SODA '90: Proceedings of the ﬁrst annual ACM-SIAM symposium on Discrete
algorithms. Society for Industrial and Applied Mathematics, Philadelphia, PA,
pp. 3197327.

Medvedev,P. et al. (2007) Computability of models for sequence assembly.
In Algorithms in Bioinformatics, Lecture Notes in Computer Science, chapter 27,
Heidelberg, Germany, pp. 2897301.

Myers,E.W. (2005) The fragment assembly string graph. Bioinformatics, 21 (suppl_2),
ii79785.

Nong,G. et al. (2009) Linear sufﬁx array construction by almost pure induced-sorting. In
DC C ’09 Proceedings of the IEEE Conference on Data Compression, Los Alamitos,
CA, USA, pp. 1937202.

Pevzner,P.A. et al. (2001) An eulerian path approach to DNA fragment assembly. Proc.
Natl Acad. Sci. USA, 98, 974879753.

Pop,M. (2009) Genome assembly reborn: recent computational challenges. Brief
Bioinform, 10, 3547366.

Puglisi,S.J. et al. (2007) A taxonomy of sufﬁx array construction algorithms. ACM
Comput. Surv., 39, 4+.

Simpson,J.T. et al. (2009) Abyss: a parallel assembler for short read sequence data.
Genome Res, 19, 111771123.

Sirén,J. (2009) Compressed sufﬁx arrays for massive data. In String Processing and
Information Retrieval, pp. 63774.

Zerbino,D.R. and Birney,E. (2008) Velvet: algorithms for de novo short read assembly
using de bruijn graphs. Genome Res, 18, 8217829.

 

i373

112 /3.Io's1eu1noipJOJXO'sorwuiJOJurorq”:duq uror} pepeo1umoq

9103 ‘1gisn8nv uo ::

