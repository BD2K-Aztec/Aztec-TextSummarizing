BIOINFORMA TICS

Antimony

C E! | | |".-'1 L
S i m Ll | at c- r

OpenCell

 

/3.10'S[Bum0[p10}x0'SOpBLUJOJuyqu”:duq

L.P.Smr'th et al.

 

et al., 2002), Virtual Cell (Moraru et al., 2002) and OpenCell
(Reeve et al., 2010), as well as direct converters such as
CellML2SBML (Schilstra et al., 2006) and SBMLToolbox
(Keating et al., 2006), do and will continue to encounter the
same issues detailed here as the formats and the software
develop.

2 METHODS

Both the JSim program and the Antimony library have internal data
models to and from which all translations are accomplished. In addition,
JSim can export models to an intermediary XML-based model format
called XMML, which contains a processed version of the mathematics
from the MML model. XMML was used as an intermediary format for
both SBML and CellML export.

Translation to and from SBML in both Antimony and JSim used
libsbml (Bornstein, 2008). Antimony was written in C++, and thus
was able to use the C++ library directly, whereas J Sim, written in
Java, used the Java bindings to the library.

Translation to and from CellML in Antimony used the CellML API
(Miller et al., 2010). Translation to and from CellML in J Sim did not use
this API, and instead simply used the native Java XML DOM.

Both CellML and SBML models can be translated to Antimony by
importing them into the QTAntimony editor or by using the ‘sbtranslate’
command-line tool. In addition, the libantimony library can be used to
add translation capabilities to other software tools. Cross-platform
source code is provided for all tools, as are pre-compiled binaries for
Windows.

Similarly, CellML, SBML and Antimony (version 2.1) models can be
translated to J Sim by importing them using the J Sim GUI interface or by
invoking JSim from the command line. Source code and pre-compiled
binaries are available for Windows, MacOS and UNIX.

Translation between SBML and CellML is possible with both tools by
using the native format of each as an intermediary: one can use the GUI
or the command-line tools for both JSim and Antimony to import one
format and export the other.

The translation algorithms themselves import the original model, then
take each individual element and create a corresponding element in the
target format. If possible, when no such corresponding element exists, the
original elements are processed to better match the target format (such as
converting processes to ODEs or ﬂattening any modularity). If this is not
possible, the element is omitted and a warning is produced.

3 RESULTS

There were two main obstacles to translating models between
different languages: differences in capabilities and differences in
design philosophies. Differences in capabilities are usually insur—
mountable: the bits of the model that have no equivalent con—
struct in the target language simply get lost along the way.
Differences in design philosophies can more often be overcome,
but the model must often change along the way, sometimes in
surprising directions.

3.1 Processes versus math

The most obvious design difference between the various lan—
guages is the decision to encode processes as core elements in
SBML and Antimony (the ‘Reaction’ construct) versus the deci—
sion to only encode math in CellML and J Sim (where everything
is an equation). Models in SBML and Antimony can be con—
verted to CellML or J Sim, but the semantics of the processes are

lost: the overall rate of change for any particular symbol is re—
tained, but the information about which processes it might have
participated in that contributed to that rate of change is no
longer present.

For translation from CellML and JSim to SBML or
Antimony, the math is retained (when compatible) but no pro—
cesses are created. Only CellML has the possibility of including
this information at all (via XML annotations), but even in that
language, this capability is rarely, if ever, actually used by mod—
elers. It is also theoretically possible to programmatically analyze
rates of change to discover and group like terms, and build up
possible coupled processes from this: if one term of ‘dB/dt’ is
ik1*B, and one term of ‘dC/dt’ is +k1*B, it is not unlikely that
there is a single process that converts B to C at a rate of k1*B.
But such methods are not foolproof, and usually need to be
vetted by a human with ﬁrst—hand knowledge of the system
being modeled. For that reason, we did not attempt to re—
create processes from math—only descriptions.

3.2 Modularity

A modular model is one composed of submodels created directly
for organizational purposes, collected from other sources or
both.

Neither core SBML nor J Sim have modularity, so translations
to and from those languages were relatively straightforward: the
models were ﬂattened (collapsed into a single model with one
copy of each entity) before translation to SBML or JSim and
translated into a single module when translated into Antimony
or CellML.

The one tricky part of ﬂattening a modular model is ensuring
that the resulting symbols are unique: in the original model, it is
possible to have the same symbol in different submodels without
overlap, but when ﬂattened, they need to have unique names. In
the Antimony to SBML translator, all names were given hier—
archical translations: if a submodel ‘A’ contained the symbol ‘sl’,
it would be always be given the id ‘A_s1’ in the ﬂattened model.
In the CellML to JSim translator, ‘sl’ would be used even in the
ﬂattened model unless some other ‘sl’ was already present: only
then would ‘A_s1’ be used instead.

Translations between CellML, Antimony and SBML—comp
(SBML plus the hierarchy package) retained the modularity,
but with two major differences. The ﬁrst difference is that
CellML has a ‘black box’ structure, such that it is illegal to con—
nect variables between modules that have not been explicitly
exposed as interface variables. Antimony and SBML—comp, in
contrast, allow all variables to be connected whether or not they
were tagged as interface variables. Although these designs are
different philosophically, it was simple to pragmatically translate
from one system to the other: translations from CellML were
straightforward as all connected variables were obviously already
in the interface. Translations to CellML were also straightfor—
ward: all connected variables simply needed to be explicitly
marked as such.

A more interesting difference was seen when translating
Antimony to CellML. Because Antimony may encode processes
from which the ODEs are derived, the elements in the interfaces
often cannot be used in an explicit—math system like CellML,
which contains no such derived ODEs. As Figure 2 illustrates,

 

904

ﬁm'spzumofpmﬂo'sopeuuopuorq/ﬁdnq

A —> B; k1*A

B 9 C; k2*B

B —> $35; k3*B

J0 = k1*A

dC/dt= J1

12 =k3*B
dB/dt =JO—Jl —J2

 

/310'S[BIIJHO[pJOJXO'SOIJBLUJOJIIIOIq/ﬂduq

L.P.Smr'th et al.

 

The CellML to Antimony translator is deficient hereibecause
the CellML API had no automatic unit conversion routines pro—
vided, the Antimony translation simply drops the unit defin—
itions, effectively changing the mathematics of any model that
relied on automatic unit conversion.

3.5 Math handling

Differences also exist in the different languages as to what math
each can handle. SBML explicitly defines a subset of
MathML2.0 (http://www.w3.org/TR/MathML2/) it allows in
its models, so anything in JSim that uses math outside of that
subset (such as <int> (integral), <sum>, and <diff>) is not trans—
latable to SBML, and must be dropped from the model.
Conversely, a few elements of that subset have no current equiva—
lent in JSim (such as <factorial> and <xor>), so SBML equa—
tions with these elements cannot be expressed in JSim. CellML
officially accepts the entirety of MathML, making it and JSim
more closely compatible. However, there are a few built—in math—
ematical constructs in J Sim like ‘random’ that have no MathML
equivalent and must be dropped from both SBML and CellML.
As these languages develop, more capabilities are planned: J Sim
will add factorialO and xor() functions in future releases, and the
‘distributions and ranges’ package for SBML (http://sbml.org/
Community/Wiki/SBML_Level_3_Proposals/Distributions_
and_Ranges) will add distribution functions such as ‘randomO’
to SBML.

Antimony, due to not having to include a simulator and being
solely a model definition language, is at an advantage here, as it
can borrow the MathML—to—infrx routines of libSBML and the
CellML API and simply use the result verbatim in the model.

Beyond the use of individual constructs, there are more basic
differences in how the languages approach the math at all. J Sim
includes a robust multidomain simulator that allows the con—
struction and simulation of PDEs. CellML does allow multiple
domains to be used, and can store many parts of a PDE model,
but has no way of specifying the boundary conditions, making
translations of such models incomplete.

SBML and Antimony have only a single pre—defrned domain
(time). This makes models with multiple domains impossible to
translate fully to SBML or Antimony. Partial translation is ac—
complished by choosing the single domain most likely to repre—
sent time (e. g. the one having base units of ‘seconds’) translating
that, and dropping references to any other domains.

It is also possible in J Sim to encode models with references to
actual computational code (Java or Fortran routines, for ex—
ample). These models are obviously not computationally trans—
latable to any other language. Even if one had access to the
source code, it would still be necessary to translate procedural
code to something declarative, which is often problematic at best:
there is no accepted universal standard for exchanging arbitrary
data structures or language embedding.

3.6 Model versus experiment

CellML, Antimony and SBML all deﬁne models and allow vari—
ous software tools to deﬁne the simulation experiment desired.
JSim defines both a model and a simulation experiment within
MML. It is, therefore, necessary when translating a model to
MML to know what kind of experiment is desired. In our

translations, we assume the experiment is a simple deterministic
time series with a user—deﬁned end point, but it would be possible
to translate to other experimental scenarios such as reaching a
steady state or performing a stochastic analysis.

Conversely, some simulation experiments involve parameter—
ization of variables, which may be stored separately from the
model (as they are in JSim), and therefore not exported during
translation. In the future, SED—ML, the Simulation Experiment
Description Language (Kohn and Le Novere, 2008) could be
used to translate this part of J Sim models.

3.7 Structural rules

CellML, Antimony, J Sim and SBML—comp all provide ways of
referencing other ﬁles from within a single file. This is done in
fairly idiosyncratic ways in each system, and is best handled by
the native libraries for each. In our case, Antimony and JSim
handle their own ‘include’ statements (and J Sim’s exported
XMML models already include any information from externally
referenced files), and because the Antimony/CellML translations
used the CellML API, the complications of ﬁnding and parsing
the referenced ﬁles were handled by that library, though the
translator did have to handle submodels from the base file dif—
ferently than submodels from external files.

For the CellML to J Sim translator, however, the CellML API
was deemed too awkward to use and distribute in Java, so the
Java XML DOM was used instead. For all other CellML fea—
tures, this was adequate, but finding and parsing the extra ﬁles
from multiple—frle models proved to be overly complicated, was
pushed to a design goal of a later version of JSim.

For SBML—comp, libSBML handles import routines for exter—
nally defined models on the same file system, so these routines
were used to create single modular Antimony files.

4 CONCLUSIONS

Models translated to JSim and Antiony from the originals at
http://models.cellml.org/and from the curated branch of http://
biomodels.net/ (Le Novere et al., 2006), together representing the
vast majority of all publically available models in the CellML
and SBML formats, can be found at http://antimony.sf.net/
antimony—translations. Table 1 summarizes the results. Despite
the differences discussed earlier in text, >90% of the models were
fully translatable, and >98% were partially translatable. The dif—
ferences in the number of CellML models reﬂects a different
starting set of models unrelated to the translation efforts

Table 1. Translation results

 

Language CellML Full Partial Biomodels Full Partial

 

Models
Antimony 787 719 787 366 366 366
Jsim 910 840 884 366 284a 366

 

 

Note: The total number of models translated from each source, with the number of
fully and partially translated models to Antimony and J Sim.

"All biomodels that were not fully translatable to JSim included the SBML event
construct.

 

906

ﬁm'spzumofpmﬂo'sopeuuowrorq/ﬁdnq

SBML and CellML translation

 

Table 2. Language feature comparison

 

 

Language Math Processes Modularity Events Unit Text XML
Antimony + + + + + + import
CellML + import + — + import +
JSim + + import — + + import
SBML + + import + + import +
SBML-comp + + + + + import +

 

Note: Each language feature is designated supported (‘+’), not supported (‘—’) or
whether a model with that feature can be imported to that language (‘import’).

above: of the full set of 1055 hosted models, 787 were parsable by
the CellML API (used by Antimony) and 910 were CellML ver—
sion 1.0 models, paresable by J Sim.

Table 2 summarizes the differences in features of the four lan—
guages. When there is clear overlap of features in different mod—
eling languages, it is relatively straightforward to translate
concepts between them. But any modeling language is going to
have areas of specialty or concepts it handles in idiosyncratic
ways, and those areas present unique challenges for those want—
ing to translate models between languages.

One of the most interesting differences between the languages
that we found when developing these translators was how differ—
ent modular design looked in the math—only CellML versus the
process—based Antimony and SBML—comp. As the latter lan—
guages develop, and the research community begins to build
models with them, we predict that those models will be funda—
mentally different in design from those written in CellML, and
their modular design will end up being almost entirely incompat—
ible with each other. This could be mitigated by curated hand—
translations of the models between the different systems.

But automatically translated models from one system will be
hard to use when translated to the new system without adopting
the original design scheme, re—writing the model or using some
sort of interface layer that converts one design to the other. It
could be argued that as the computational results are the same in
modular and ﬂattened models, the main use of a modular design
is the design itself, and how well it affords a more comprehen—
sible analysis by human readers. As such, a translation of a pro—
cess—based design to a math—based design loses its most desirable
feature: the thought that went into presenting the original design
to other researchers.

In the future, we expect the design of most modular models to
be entirely either process—based or math—based, and that the ex—
change and re—use of models between these two paradigms will be
low. To promote the exchange and re—use of a particular model,

it may become necessary to hand—design both a process—based
and a math—based version of the model, so that researchers in
both communities will be able to use the version that best fits
with the rest of the models they use.

ACKNOWLEDGEMENTS

The authors would like to thank the developers of libsbml and
the CellML API for many productive conversations on how best
to use their software.

Funding: NIH (grants 1R01EB08407 and 1R01GM081070—01).

Conﬂict of Interest: none declared.

REFERENCES

Bassingthwaighte,J.B. et a]. (2006) GENTEX, a general multiscale model for in vivo
tissue exchanges and intraorgan metabolism. Phil. Trans. R. Soc. A, 1843,
142371442.

Bornstein,B.J. et a]. (2008) LibSBML: an API Library for SBML. Bioinformatics,
24, 880.

Hucka,M. et a]. (2003) The systems biology markup language (SBML): a medium
for representation and exchange of biochemical network models. Bioinformatics,
19, 5247531.

Hoops,S. et a]. (2006) COPASI: a complex pathway simulator. Bioinformatics, 22,
306773074.

Hucka,M. et a]. (2002) The ERATO Systems Biology Workbench: enabling inter—
action and exchange between software tools for computational biology. Pac.
Symp. Biocomput., 2002, 4504161.

Izhikevich,E.M. (2004) Which model to use for cortical spiking neurons? IEEE
Trans. Neural Netnt, 15, 106371070.

Keating,S.M. et a]. (2006) SBMLToolbox: an SBML toolbox for MATLAB users.
Bioinformatics, 22, 127571277.

Kohn,D. and Le Novere,N. (2008) SED—MLiAn XML Format for the
Implementation of the MIASE Guidelines. Comput. Methods Syst. Biol,
5307, 1767190.

Le Novere,N. et a]. (2006) BioModels Database: a free, centralized database of
curated, published, quantitative kinetic models of biochemical and cellular sys—
tems. Nucleic Acids Res., 34, D6897D691.

Lloyd,C.M. et a]. (2004) CellML: its future, present and past. Prog. Biophys. Mol.
Biol., 85, 4334150.

Miller,A.K. et a]. (2010) An overview of the CellML API and its implementation.
BMC Bioinﬁ)rmatics, 11, 178.

Moraru,I.I. et a]. (2002) The virtual cell: an integrated modeling environment for
experimental and computational cell biology. Ann. N. Y. Acad. Sci., 971,
5957596.

Novak,B. and Tyson,J.J. (1997) Modeling the control of DNA replication in fission
yeast. Proc. Natl Acad. Sci. USA, 94, 914779152.

Reeve,A. et a]. (2010) Biological modelling using CellML and MATLAB. Open
Pacing Electrophysiol. Ther. J ., 3, 7.

Schilstra,M.J. et a]. (2006) CellMLZSBML: conversion of CellML into SBML.
Bioinformatics, 22, 101871020.

Shen—Orr,S.S. et a]. (2002) Network motifs in the transcriptional regulation network
of Escherichia coli. Nature genetics, 31, 64—68.

Smith,L.P. et a]. (2009) Antimony: a modular model definition language.
Bioinformatics, 25, 245272454.

 

907

ﬁre'spzumofpmﬂo'sopeuuowrorq/ﬁdnq

