BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

Bit-parallel, general integer-scoring alignment

 

The complexity of our algorithms depends on the weights, not
the ultimate score of the alignment. Our method works for gen—
eral alphabets, but our interest derives from frequent use of
DNA alignment when analyzing high—throughput sequencing
data to detect genetic variation.

2 METHODS

The problem to be solved is stated in terms of similarity scoring, but the
technique applies to distance scoring as well.

PROBLEM. Given two sequences X and Y, of length n and m respectively,
and a similarity scoring function S deﬁned by three integer weights M
(match), I (mismatch) and G (indel or gap), calculate the global alignment
similarity score for X and Yusing logic and addition operations on computer
words of length w.

We are interested in two measures of efﬁciency for the algorithms. The
ﬁrst is standard time complexity and the second is a ratio of the word size,
w, and the count, p, of logic and addition operations required to process
w consecutive cells in the alignment scoring matrix. The efﬁciency,
e = w/ p, is the average number of cells computed per operation. For ex-
ample, when using 64 bit words, LCS has e = 64/4 = 16 [P = 4 operations
per word (Hyyro, 2004)], and edit distance has e= 64/ 15 a 4.2 [an im-
provement from 64/ 16 in the method of Hyyro et al. (2005) and Myers
(1999); see Supplementary Information for details]. As P is
independent of w, if the word size doubles, e doubles too. Note that we
are counting only logic and addition operations, not storage of values in
program variables. Adding store operations would be more accurate but
the number of these operations is compiler and optimization level
speciﬁc.

We require that the alignment method be global or semi-global. That
is, we do not restrict the initializations in the ﬁrst row or column of the
alignment scoring matrix or where in the last row or column the align-
ment score is obtained. Typical initializations require (i) a gap weight to
be added successively to every cell (global alignment from the beginning
of a sequence), and (ii) a zero in every cell (semi-global alignment where
an initial gap has no penalty). We assume that match scores are positive
or zero, M 2 0, mismatch and gap scores are negative, I, G<0 and
that the use of mismatch is possible, meaning that its penalty is no
worse than the penalty for two adjacent gaps, one in each sequence,
I 2 2G. While other weightings are possible, they either reduce to simpler
problems from a bit-parallel perspective (e.g. LCS has
G = 0, I = — 00, M = 1) or require more complicated structures than de-
tailed here (e.g. protein alignment using PAM or BLOSUM style amino
acid substitution tables).

2.1 Function tables

Let S be a recursively-deﬁned, global similarity scoring function for two
sequences X and Y computed in an alignment scoring matrix:

S[i—1,1—1]+M ifX,»=Y1

S[i—1,1—1]+I iin75Yj
S[i,1]=max

S[i—1,1]+G delete X,»

S[i,1'—1]+G delete Y]-

Instead of actual values of S, we store only the differences, A V, between a
cell and the cell above, and AH, between a cell and the cell to its left:

AVll'le = 51th - S[i-171]

AH[i,1] = Sm] — S[iJ - 1]-

It is an easy exercise to prove that the minimum and maximum values
for AV and AH are G and M 7G, respectively. Lemma 2.1 gives the
recursive deﬁnitions for AV and AH in terms of M, I and G.

LEMMA 2.1. The values for AV are as shown below and the values for AH
are computed similarly. That is, AH [i, 1] in matrix S is equal to V[j, I] in the
transpose of matrix S.

AVll'le =

wk 1

M—AHIi— 1,1] Match, i.e.: ile: 

I— AH]i — 1,1] Mismatch, i.e.: 

 

AHIi— 1,1]
I— G 2
AVUJ— 1]
G Indelfrom above, i.e.: 
AH[i— 1,1] 3 _
AVUJ— 1]
AV[i,1'— 1]+
G — AH]i — 1,1] Indelfrom left, i.e.: 
An 1] I—
IIj— 2
AHIi— 1,1]

V121 ijl

(V1011 = G 0" V[0~Jl = 0)

PROOF. By substitution in the recursive formula for S. D

The recursion for A V is summarized in the Function Table in Figure 1.
Note the value I 7 G, which frequently occurs in the recursion, and the
relation AH =AV. They set the boundaries for the marked zones in
the table. These zones comprise (A V, AH) pairs, which determine how
the best score of a cell in S is obtained in the absence of a match, either as
an indel from the left (Zones A and B), a mismatch (Zone C) or an indel
from above (Zone D). Borders between zones, indicated by dotted lines,
yield ties for the best score. Figure 2 shows how the relative size of the
Zones changes with changes in I and G.

3 ALGORITHM

DEFINITIONS. min=G, max=M — G, mid =I— G, low 6 {min,
...,mid} and high 6 {mid+1,...,max}.

For the illustrations in this article, we use the scoring weights:
M=2, 1= —3, G= —5,
which yield
min = — 5, max= 7, mid =2,
low e {—5,...,2},highe {3,...,7}.

The AV Function Table for these weights is shown in Figure 3.

 

3167

ﬁm'spzumofpmgxo'sopeuuoguiorq/pdnq

J.Loving et al.

 

The algorithm proceeds row—by—row through the alignment
matrix. For each row, the input is:

o the AH values from the preceding row,
0 the leftmost AV value in the current row and

o the match positions in the current row.

The computation ﬁrst determines all the remaining A Vvalues for
the current row and then, using those, determines the AH values
for the current row. A central concept is a run of AHmin. This is a
set of consecutive positions in the preceding row for which the
values of AH all equal min (in Fig. 4, positions for which
AH = — 5).

The algorithm has the following steps (see Fig. 4), which
follow from Lemma 2.1.

 

 

 

AH
I — Gx'
G .
AWOW C
AV
AVhigh

 

 

 

 

k
G+M—I—1

Fig. 1. Zones in the Function Table for AV. Zone A: all values are in
Vhigh e {I— G+ 1, . . . , M— G}; Zone B: all values are in
VIOW e {G, . . . , I — G}; Zone C: all values are in VIOW and values depend
only on AH; Zone D: all values are G; Last row: values also apply when
there is a match;. First column: identity column for values in Vhigh

 

 

1. Find the locations where A V= max (highest value in Zone
A):

Step 1A: because of a match between the characters in
Sequence X and Sequence Y. These occur at match loca—
tions where AH = min.

Step 1B: in any run of AHmin to the right of a match
location in the run.

2. Find the locations where AV= i,fori e {mid-I- l, . . . , max
—1} (the remaining values in Zone A). These are computed
in decreasing order of i. For each i, there are two categories,
those locations:

Step 2A: because of a match or a larger preceding AV
value. These also depend on the AH value.

Step 2B: because of the value 1' being carried through a run
Of min.

3. Find the locations where AV= i, for i e {min+ l, . . . , mid}
(the values in Zones B and C). These are computed separately
for each value 1' and depend on:

Step 3A: a match or the preceding AV value and the AH
value (Zone B).

Step 3B: the AH value alone (Zone C).

4. Find the locations where AV= min (the values in Zone
D). These are:

Step 4: all the remaining locations with undetermined AV
values.

5. Find the current row locations where the new AH =i for:
Step 5A: i>min.
Step 5B: 1' =min.

We describe the simplest case where the length of the ﬁrst
sequence is less than the computer word size w. Longer sequences
can be handled in ‘chunks’, where each chunk has size w. Match

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

mismatch mismatch mismatch mismatch
gap I gap I gap I gap
0 2*gap 0 2*gap 0 2*gap 0 2*gap
C
C
0 D D
D C D
A B
A A B
ALI B ‘I

 

Fig. 2. Relative size of Zones as I (mismatch penalty) decreases from 2G (twice gap penalty) where there is no preference for mismatches, to zero, where

mismatches are free and gaps are introduced only to obtain matches

 

3168

ﬁm'spzumot‘pmgxo'sopeuuogquIq/pdnq

an?kgogmomammowoio~&o:3m7.omm\

 

J.Loving et al.

 

Steps 2A and 2B: Remaining AVhigh vectors are calculated, in
descending order from AV=max — 1 to AV=mid + 1 because of
the dependencies as discussed above. The operations are: (i) ﬁnd—
ing the locations because of a preceding higher AV value using
AND of appropriate (AV, AH) pairs (which intersect along a
common diagonal in the Function Table) and collecting them
together with ORs; (ii) shifting the initial vectors right one
position for subsequent calculations; (iii) carrying through runs
of AHmin computed in two operations, an ADDITION (+) as
before and an XOR with AHmin to complement the bits within
the AHmin runs (Fig. 6). Before the addition, those AHmin pos—
itions that have already output a AVmax value must be removed.

Steps 3A and 3B. (Fig. 7). At this point, all the AVhigh input
values for Zone B have been computed (they are the outputs
from Zone A), remaining output values are all AVIOW. The oper—
ations are: (i) the AND of appropriate (AV, AH) pairs, which
intersect along a common diagonal (Zone B); (ii) the AND of
the appropriate AH vector and all positions without a Athgh
output (Zone C); (iii) an OR combination of the preceding two
results and (iv) a shift of the locations one position to the right
for subsequent calculations.

Step 4: Zone D has only one output value, AVmin. It is as—
signed to all remaining locations as well as the zero location if
gap penalty in the ﬁrst column is being used.

Step 5: After the AV values are computed, all inputs are avail—
able and the new AH vectors for the current row can be computed
immediately. The Function Table for the new AH is the transpose
of the table for A V, i.e. the input labels are swapped. Each new AH
vector is obtained by the AND of appropriate (A V, AH) input
pairs, which intersect along a common diagonal, collected to—
gether with ORs. Before this can proceed, though, the Match pos—
itions must be added to the previous row’s AHmax vector (with OR)
and removed from all other previous row AH vectors. Also, all
previous row AH]0W locations must be converted to AHmid.

 

 

 

 

 

1 1 1 1 1 1 Matches
AND 1110 1110 111110 1110 AHm;n
0100 1000 010100 0000 AVmax (initial)
+ 1110 1110 111110 1110 AHmin
1001 0001 100101 1110
XOR 1110 1110 111110 1110 AHmin
0111 1111 011011 0000
XOR 0100 1000 010100 0000 AVmax (initial)
0011 0111 001111 0000 >> AVmax
(ﬁnal and shifted)
ExampleCode:
INITpos7 =DHneg5 & Matches;
DVpos7shift = ((INITpos7 + DHnegS) A DHneg5) A INITpos7;

 

 

 

Fig. 5. Finding Ame. Each line represents a computer word with low
order bit, corresponding to the ﬁrst position in a sequence, on the left. 1s
are shown explicitly, OS are shown only to ﬁll runs of AHmin and the
ﬁrst position to the right of each run. Symbol > > indicates that the ﬁnal
A me values are shifted to the right one position. Bits erroneously set by
the ADDITION (+) are shown in bold. Sample code is from the com-
plete listing in Supplementary Information

3.2 BitPAl Packed

Data structure for BitPAl packed The number of logic oper—
ations in BitPAl scales linearly with the size of the function table.
Many of these are the AND and OR operations to compute
identical values along Zone B diagonals. These calculations can
be performed more efﬁciently with a new representation. The
idea is to store the input AH and AV values in such a way that
they can all be added simultaneously to give the appropriate
output values.

Rather than using bit—vectors to represent single AH or AV
values, we use them to represent binary digits (Fig. 8). We
map the AV values {min, . . . ,max} one—to—one onto the
positive values {0, . . . , max — min} and store them in the vectors
AVp0,AVp1,AVp2, etc. where p,- is the place holder for the ith
power of 2. The mapping for AH is onto negative numbers, i.e.

{min,...,max} are mapped to {0,...,—(max—min)}
and stored in vectors AHp0,AHp1,AHp2, etc. After addition,
the sums will fall in {—(max—min),...,max—min}, so we

use I'log2(2(max — min)+1)] bit—vectors for AH and AV. For
our example, the AV values are mapped to {0, . . ., 12}, the AH
values are mapped to {0, . . . , —12} and the sums fall within
{—12, . . ., 12}, so we use ﬁve vectors each for AH and AV.

BitPAl Packed does not change the computation of the AV
values in Zone A. The AH values are always maintained in the
packed representation, but some are unpacked into the original
representation for the Zone A computations. Once Steps 1 and 2
are completed, all locations without a A V value are set to mid, all
match locations are set to max, and the AV values are converted
into the packed representation.

Steps 3 and 4 are computed by ‘adding’ together the two sets
of packed vectors using a series of AND, OR and XOR operations
(Fig. 8) to produce the ﬁnal encoded values for AV. Any negative
values (sign bit set) are converted to min (Zone D). For Step 5,
the new AH values are determined with a second addition.
Because all input AH in the range [min, mid] give the same
result, we ﬁrst re—encode that range to mid.

Packing and unpacking Packing AV vectors involves identifying
the locations where the binary representation of the encoded

 

1110 1110 11101110 AHm;n (remaining)
+ 1 1 1 1 X >> AV (initial shifted)
0001 l 0001 00011110
XOR 1110 1110 11101110 AHmin (remaining)
1111 1 1111 11110000 >> AV (ﬁnal andshifted)
Example Code:
RemainDHnegS = DI-Lneg5 A (DVpos7shif‘t >> 1);
INITposBs = (DHnegl & DVpos7shiftorMatch)I
(DHneg2 & DVposSshiftNotMatch)I
(DHneg3 & DVposSshiftNotMatch)|
(DHneg4 & DVpos4shiftNotMatch);
DVposSshift = ((INITposSs << 1) -I- RemainDHnegS) A RemainDHnegS;
DVposSshiftNotl/[atch = DVposSshift & NotMatches;

 

 

 

Fig. 6. Carry through runs of AHmin for remaining values in AVhigh.
Symbol X marks a single position between runs which cannot be 1 in
the initial shifted values

 

3170

ﬁm'spzumol‘pmﬂo'sopnuuqugoIq/pdnq

1.4—5.0],

U)
c
.9
Hi
I—
<1)
0.
O

..A

i.e.-1 .-1 If!”

 

BIIIDAI BitPAlp‘Jacked

/310's112um0fp101x0'soIJBuIJOJuIOIq”:duq

W U — |'-.-‘Ianhe r

in
EU
4.. _
35
E
E

h

k = Maximum Errors for WM

 

BiIPAI

BitPAIF‘acked

1'0 20
Height Of the FUHCIIOI‘I Table

/310's112um0fp101x0'soIJBuIJOJuIOIq”:duq

Bit-parallel, general integer-scoring alignment

 

Table 1. Table of run times in minutes

 

 

 

Algorithm Parameters (M, I, G)
0, 71, 71 2, 73, 5 3, 41, 76 4, 75, 79 4, 77, 711
BitPAl 0.284000 1.903778 2.702000 5.408722 8.517500
BitPAl 0.390500 0.999945 1.126500 1.475222 1.755500
Packed

 

Note. Shown are averages over three trials for 25 million alignments. Needlemani
Wunsch has the same runtime for all parameters, 7.056056 min.

were 63 characters long. For WM, we varied k, the maximum
number of allowed errors, from 1 to 15. For N, we varied k from
1 to 12. All programs were compiled with GCC using optimiza—
tion level 03 and were run on an Intel Core 2 Duo E8400
3.0GHz CPU running Ubuntu Linux 12.10. Results are shown
in Figure 10 and Table 1.

5 DISCUSSION

The BitPAl and BitPAl packed algorithms outlined above can be
extended in several ways. Computers now in common usage have
special 128 bit SIMD registers (Single Instruction, Multiple
Data). Using these, with the addition of several bookkeeping
operations, would essentially double the efﬁciency and the
speed of computation. Another extension derives from the unex—
ploited parallelism of the operations. There are no dependencies
on prior computations after the AV vectors in Zone A are com—
puted. This means that all the computations in Zones B, C and D
for AVand all the subsequent computations for AH can be done
simultaneously, an ideal situation for the use of general purpose
graphical processing units (GPGPU).

Another possible extension expands the types of scoring
schemes allowed. BLOSUM type scoring, which is useful for
protein alignments, eliminates match and mismatch scoring
and instead assigns different substitution weights to each pair
of characters. Afﬁne—gap scoring replaces single character indel
scoring with gap initiation and gap extension weights.

Extension to local alignment is also possible. This is a different
class of problem in that the best ﬁnal alignment score can occur
in any cell of the alignment matrix. If all the cells have to be
examined, then the time complexity shifts back to 0(nm). Hyyré
and Navarro (2006) had some success with this problem using
unit cost weights and identifying columns in which the score of at
least one cell exceeds a predeﬁned threshold k.

The BitPAl methods have already been used to accelerate soft—
ware for detecting tandem repeat variants in high—throughput
sequencing data (Gelfand et al., 2014) and are well—suited to
other DNA sequence comparison tasks that involve computing
many alignments.

Funding: This work was supported by the National Science
Foundation (HS-1017621 to G.B., DGE—0654108 to J.L. and
Y.H.).

Conﬂict of interest: none declared.

REFERENCES

Allison,L. and Dix,T.I. (1986) A bit—string longest—common—subsequence algorithm.
Inf. Process. Lett., 23, 3057310.

Baeza—Yates,R. and G0nnet,G.H. (1992) A new approach to text searching.
Commun. ACM, 35, 74e82.

Benson,G. et al. (2013) A bit—parallel, general integer—scoring sequence alignment
algorithm. In: Fischer,J. and Sanders,P. (eds) Combinatorial Pattern Matching,
Vol. 7922 of Lecture Notes in Computer Science. Springer, Berlin, Heidelberg,
pp. 50%].

Bergeron,A. and Hamel,S. (2002) Vector algorithms for approximate string match—
ing. Int. J. Found. Comput. Sci., 13, 53%5.

Crochemore,M. et al. (2001) A fast and practical bit—vector algorithm for the longest
common subsequence problem. Inform. Process. Lett., 80, 27%285.

Gelfand,Y. et al. (2014) VNTRseek—a computational tool to detect tandem repeat
variants in high—throughput sequencing data. Nucleic Acids Res, doi: 10.1093/
nar/gku642.

Hyyr6,H. (2004) Bit—parallel LCS—length computation revisited. In: Proceedings
of the 15th Australasian Workshop on Combinatorial Algorithms ( A WOCA
2004), University of Sydney, Australia.

Hyyr6,H. and Navarro,G. (2005) Bit—parallel witnesses and their applications to
approximate string matching. Algorithmica, 41, 2037231.

Hyyr6,H. and Navarro,G. (2006) Bit—parallel computation of local similar—
ity score matrices with unitary weights. Int. J. Found. Comput. Sci., 17,
132571344.

Hyyr6,H. et al. (2005) Increased bit—parallelism for approximate and multiple string
matching. J. Exp. Algorithmics, 10, 276.

Kernighan,B. and Ritchie,D. (1988) The C Programming Language. 2nd edn.
Prentice Hall, Upper Saddle River, NJ, USA.

Myers,G. (1999) A fast bit—vector algorithm for approximate string matching based
on dynamic programming. J. ACM, 46, 3957415.

Navarro,G. (2004) Approximate regular expression searching with arbitrary integer
weights. Nordic J. Comput., ll, 35(r373.

Needleman,S. and Wunch,C. (1970) A general method applicable to the search for
similarities in the amino acid sequence of two proteins. J. Mol. Biol, 48,
4434153.

Smith,T. and Waterman,M. (1981) Identiﬁcation of common molecular subse—
quences. J. Mol. Biol, 147, 1957197.

Wu,S. and Manber,U. (1992) Fast text searching: allowing errors. Commun. ACM,
35, 83791.

Wu,S. et al. (1996) A subquadratic algorithm for approximate limited expression
matching. Algorithmica, 15, 50—67.

 

3173

ﬁm'spzumol‘pmgxo'sopnuuogquIq/pdnq

