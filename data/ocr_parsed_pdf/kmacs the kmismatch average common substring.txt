BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

kmacs: the k-mismatch average common substring approach

 

2 APPROACH

2.1 The ACS approach and k-mismatch substrings

As usual, for a sequence S over an alphabet 2, S0] is the i—th
element of S, by |S| we denote the length of S and S[i..j] is the
(contiguous) substring of S from i to j. In particular, S[i..|S|] is
the i—th suffix of S. For two sequences S1 and S2, the ACS ap—
proach determines for every position i in S1 the length 51 (i) of the
longest substring of S1 starting at position iand exactly matching
some substring in S2. The lengths 51 (i) are averaged and normal—
ized to deﬁne a similarity measure
ISII

L(sl.32>= ﬁ>kzs1<i> (1)
i=1

which is turned into a (non—symmetric) distance measure by
defining

[080520 _ [080510
L031, 52) L031, 51)

To obtain a symmetric distance, the distance between S1 and
S2 is then deﬁned by Ulitsky et al. (2006) as

(1031, Sz)+d($2, $1)
2

In this article, we generalize this distance measure by using
substring matches with k mismatches instead of exact matches.
That is, instead of using the maximum substring lengths 51 (i), we
define 51f0) as the length of the longest substring of S1 starting at
position i and matching some substring of S2 with up to k mis—
matches, minus k. (We subtract k from the length of this string,
counting only the matching positions). 550) is defined accord—
ingly. We then define a distance measure as above, but
with sq(i) replaced by 520). In the special case where k = 0,
we have 52(i)=sq(i), so in this case our distance is exactly the
distance dACS.

61(51, 52) = (2)

07/165091, 52) = (3)

2.2 Approximating the length of k-mismatch substrings

For a pair of sequences, the exact values 5’30) can be calculated in
(9(k >1< n2) time using sufﬁx trees or similar data structures where
n is the maximal length of the sequences. As we want to compare
sequences in linear time, however, we propose a heuristic to ap—
proximate these values. To do so, we ﬁrst calculate for each
position i in S1 the length 510) of the longest common substring
starting at i matching a substring of S2, as is done in ACS. Let j
be the start of this matching substring in S2; the character
S1[i+s(i)] must therefore differ from S2[j+s(i)]. We then
extend this match without gaps in S1 from position i + s(i)+1
and in S2 from j+s(i) + 1, until the next mismatch occurs. This is
repeated until the k + 1—th mismatch or the end of one of the two
sequences is reached.

In the example below, for position i = 4 in S1 and with k = 2
mismatches, our approach would return the following
k—mismatch common substring, starting at position j = 2 in S2:

SiCATTGCATACGA
S2ATGGATCCAATAG

To obtain this k—mismatch common substring, our program
would ﬁrst determine the longest common substring for position
i = 4 in S1 that exactly matches a substring in S2. We find such a

match at position j = 2 in S2 with the length 51(4) = 2. Then this
match is extended without gaps until the third mismatch is
reached. The length of this 2—mismatch substring is 7, so we
have sf(4) = 5 (in the deﬁnition of 520), we count only the match—
ing positions).

It should be mentioned that, for a position i in S1, the corres—
ponding position j in S2 of the longest exact match to a substring
starting at i may not be unique. Consider, e.g. position i = 2 in
the first sequence of the above example:

SiCATTGCATACGA
S2ATGGATCCAATAG

Here, the substring AT starting at position 2 in S1 is the long—
est substring starting at this position and matching a substring
of Szibut this substring occurs at positions 1, 5 and 10 in S2.
In such a case, we calculate all k—mismatch extensions of these
occurrences as described above, and we define 51f(i) as length of
the maximal possible extension minus k.

The above heuristic reduces the complexity of ﬁnding the k mis—
match maximal substring lengths from (9(k >1< n2) to (9(k >1< n >1< z),
where z is the average number of maximal matches to a substring
in S2 starting at a position i in S1. In principle, this complexity
could be achieved by using suffix trees (Weiner, 1973) as the
underlying data structure. Here, one would build a generalized
suffix tree for the sequences in O(|S1|+|S2|) time, e.g. using
Ukkonen’s algorithm (Ukkonen, 1995). To determine the longest
substring starting at i in S1 and also occurring in S2, one needs to
ﬁnd the lowest node v in the sufﬁx tree that is above leaf i and also
above some leaf that belongs to S2. The length 510) of the longest
common substring starting at i is then the string depth of the node
v, that is, the length of the edge labels on the path from the root to
v. Moreover, the leaves below v appertaining to S2 exactly corres—
pond to the positions of this longest exact match in S2.

Next, we want to extend the longest exact matches that we
have found by this procedure until the k + 1—th mismatch is
found. Thus, we need be able to ﬁnd the longest exact match
between two sequences starting at two given positions i and j (the
positions after a mismatch, in our case). In a sufﬁx—tree ap—
proach, this could be accomplished by lowest common ancestor
(LCA) queries. Similar to the aforementioned approach, we
would have to look up the lowest node v that is above both
leafs i and j; the string depth of v is then the length of the longest
exact match starting at i and j, respectively. LCA queries can be
carried out for any i and j in constant time after a linear—time
preprocessing step (Harel and Tarjan, 1984), resulting in k con—
stant—time LCA queries for the full k—mismatch extension of an
exact longest match.

3 IMPLEMENTATION

Abouelhoda et al. (2004) have shown that every algorithm that
uses sufﬁx—trees can be replaced by an algorithm using enhanced
suffix arrays that has the same complexity. Here, an enhanced
suffix array is defined as a data structure ‘consisting of the sufﬁx
array and additional tables’. Both, sufﬁx trees and enhanced
sufﬁx arrays, can be calculated in linear time and space, but
sufﬁx arrays require substantially less memory per input charac—
ter than sufﬁx trees do (Manber and Myers, 1990). In our

 

2001

ﬁle'sreumofpmJXO'sopeuuopnorq/ﬁdnq

C. -A.Leimeister and B.Morgenstem

 

implementation, we therefore used enhanced sufﬁx arrays instead
of sufﬁx trees, making use of recent improvements of linear—time
sufﬁx array construction algorithms.

A suffix array SA of a string S = S[1] . . . S[n] is a permutation
of the indices 1...n according to the lexicographical ordering of
the corresponding sufﬁces. That is, we have SA[i] = j if the j—th
sufﬁx of S is at the i—th position in the lexicographical ordering of
all sufﬁces of S. In addition to the SA, we need the so—called
longest common prefix (LCP) array for S. Here, the entry LCP[z]
stores the length of the LCP of the SA[z]—th sufﬁx and its prede—
cessor in SA, the SA[i— 1]—th sufﬁx. The SA of a sequence S
together with the corresponding LCP array is called, in this con—
text, the enhanced suffix array of S. To calculate enhanced suffix
arrays in linear time, we used a program described by Fischer
(2011), which is available at http://algo2.iti.kit.edu/english/ 1828.
php. The underlying algorithm is based on sais—lite by Y uta M ori,
a fast implementation of induced sorting (Nong et al., 2009).
Sufﬁx arrays provide an efficient solution to our longest k—mis—
match substring problem.

For a single sequence S and a position SA[i] in S, the enhanced
sufﬁx array of S can be used to ﬁnd the length of the longest
substring in S starting at a different position in S and matching a
substring starting at SA[i]. It is easy to see that this substring
must be the LCP of the SA[z]—th sufﬁx with one of its neighbours
in SA, i.e. either with the SA[i+ 1]—th or the SA[i — 1]—th sufﬁx,
whichever is longer. With an enhanced sufﬁx array, the length of
this substring is given as the maximum of the values LCP[z] and
LCP[i+ 1] and can therefore be looked up in constant time. The
position where this second substring starts is then either
SA[i — 1] or SA[i+1]ior both of these positionsalepending
on where the maximum is reached.

If matches between two sequences are to be found, the situ—
ation is slightly more complicated. For a position in sequence S1,
we want to find a position in S2 such that the common substring
starting at these two positions is maximal, and vice versa. To
solve this problem, we build the generalized enhanced suffix array
of our sequences, i.e. the enhanced sufﬁx array of the concate—
nated sequence S :=S1$52 where S is a special character not
contained the alphabet 2; see also Babenko and Starikovskaya
(2008) for a related approach. Thus, each sufﬁx from S1 or S2 is
represented in lexicographical order by an entry in SA. Figure 1
shows the enhanced sufﬁx array for two sequences.

To ﬁnd the length of the longest substring starting at SA[i] in
one sequence, matching a substring of the other sequence, and its
occurrences there, we need to look up the largest integer p10)
with p1(i)<i, such that SA[p1(i)] belongs to the other sequence.
Correspondingly, we need the smallest integer p2 (i) with p2(i)>i
with SA[p2(i)] belonging to the other sequence. The length of this
common substring is then given as the minimum of all LCP
values between p10) + 1 and i or the minimum between the
LCP values between i + 1 and p20thichever minimum is
larger. Formally, the length of the longest substring starting at
a position SA[i] and matching a substring of the respective other
sequence is given as follows:

s(SA[z]) =max(  LCP[x], _ min LCP[y]) (4)
[71 I

xsi I<.v:p2(i>

with p1 and p2 deﬁned as above.

1' SA [ i ] Sufﬁx LCP[1]
1 7 $ananas -
2 6 a$ananas 0
3 4 ana$ananas 1
4 2 anana$ananas 3
5 8 ananas 5 } min: 3
6 10 anas 3
7 12 as 1 }min=0
8 1 banana$ananas 0
9 5 na$ananas 0
10 nana$ananas 2
11 9 nanas 4
12 11 nas 2
1 3 1 3 s 0

Fig. 1. Generalized SA and LCP array for the strings S1 =hanana and
S2 =ananas, concatenated by the symbol 3%. Sufﬁces of S1$S2 starting in
S, are shown in orange, sufﬁces starting in S2 are in blue

The position of this longest substring in S is then SA[p1(i)] or
SA[p2(i)] (or both), depending on where the maximum in
Equation (4) is reached. All positions in this formula refer to
the concatenated sequence S, but it is trivial to retrieve the pos—
itions in the original sequences S1 and S2 from these values by
subtracting |S1| + 1 where necessary.

As an example, consider Figure 1. For i = 6, we want to find
the longest common substring starting at SA[6] = 10 (marked by
an arrow) that exactly matches a substring starting at some pos—
ition in the other sequence. Position SA[6]= 10 in the concate—
nated sequence S corresponds to a position in sequence S2, so we
have p1(6) = 4, as 4 is the largest integer smaller than 6 such that
SA[4] belongs to the other sequence, i.e. to S1. Similarly, we
obtain p2(6) = 8. According to Equation (4), we get the following:

s(SA[6])=max {min {5, 3}, min {1, 0}}=max {3, 0} =3.

Position 10 in S corresponds to position 3 in the original se—
quence S2, so, as a result, we obtain 52(3)=3, i.e. the longest
substring starting at position 3 in S2 matching a substring
from S1 has length 3 (the substring itself is ‘ana’).

 

Algorithm 1 Calculation of Equation (4)

 

Require: SA {generalized sufﬁx array for S1 and S2 of length n}
Require: LCP {corresponding longest common preﬁx array}
Ensure: 5 {stores the results of Equation (4)}
min <— 0
fori=2tonil do
if SA[I] and SA[i+ 1] belong to the same sequence then
if LCP[i+ l]< min then
min <— LCP[i+ 1]
end if
s[i+ l] <— min
else

 

2002

ﬁle'sreumofpmJXO'sopeuuopnorq/ﬁdnq

kmacs: the k-mismatch average common substring approach

 

min <— LCP[I'+ l]
s[i+ 1] <— LCP[I'+ 1]
end if
end for
min <— 0
for 1' = n to 2 do
if SA[I] and SA[i+ 1] belong to the same sequence then
if LCP[I] <min then
min <— LCP[I]
end if
S[I' — l] <— max(min, s[1' — 1])
else
min <— LCP[I]
S[I' — l] <— max(min, s[1' — 1])
end if
end for

 

All values s(i) can be calculated for the entire concatenated
string S in linear time using Algorithm 1. Here, the ﬁrst loop
computes min [,1 <0¥f,~LCP[x] for all indices i and stores them as
50]. Then the second loop calculates min ,~<.‘,gp,LCP[y] and up—
dates s[z] if the result is greater than the actual value of 50]. This
way, algorithm 1 applies Equation (4) to all indices i and stores
the corresponding values 50].

Finally, for our heuristic we need to ﬁnd for an index i all
positions belonging to the respective other sequence, where a
match of length s(i) occurs. This can be achieved by a simple
extension of Algorithm 1. Without loss of generality, we assume
that the ﬁrst minimum in Equation (4) is strictly larger than the
second minimum, so p10) is a position where a maximal match
to the other sequence occurs (as was the case in our small ex—
ample above). To find possible additional matching positions, we
consider all indices p 3 p10) in descending order, as long as one
has the following inequality:

LCP[p+ 1] g min LCP[x]
p1(i)<x:i

For all such p that belong to the other sequence, the positions
SA[p] are occurrences of longest substrings matching a substring
starting at i. In our example, we find one further position p = 3,
so SA[3] = 4 is an additional occurrence. If the maximum in (4) is
achieved by the second term, one proceeds accordingly.

Next, the second step in our approach involves ﬁnding the
length of the longest common substring starting at pre—defined
positions in S1 and S2, respectively. Using the enhanced sufﬁx
array of a sequence S, the length of the longest substring starting
at positions SA[i] and SA[/] (with SA[i]< SA[/]) is given as the
minimum over the values LCP[p], i < p g j. There is an approach
similar to LCA queries to obtain this value known as range min—
imum queries (RMQ). A RMQ returns the index of an array A
that stores the smallest element between two speciﬁed indices 1
and r, denoted as RM Q A(l, r).

Several algorithms are available that can solve RMQ in con—
stant time, after a linear preprocessing step, e.g. Fischer and
Heun (2007). According to Fischer and Heun (2006), the longest
common substring starting at i and j can be calculated as
LCP[RMQLCP(SA’1[1]+ 1, SA’l[/])] where SA’1 is the inverse
sufﬁx array. As a result, the same complexity as for sufﬁx trees
can be achieved by using enhanced suffix arrays. In our imple—
mentation, however, we extend the substrings by matching single

characters because in our test runs this ‘naive’ approach was
faster than the RMQ implementation that we tested.
Nevertheless, our downloadable program has an option for
using the RM Q algorithm so the user can compare these two
approaches.

4 BENCHMARKING

4.1 Benchmark sequences

To evaluate kmacs and to compare it with other methods of
sequence comparison, we applied these methods phylogeny re—
construction. We used a large number of DNA and protein se—
quence sets for which reliable phylogenetic trees are available,
and we measured how similar the constructed trees are to the
respective reference trees. The following sequence sets were used
in our study:

For eukaryotic DNA comparison, we used a set of 27 primate
mitochondrial genomes that were previously used by Haubold
et al. (2009) as benchmark for alignment—free methods. These
sequences have a total length of 446 kb. A benchmark tree that
has been constructed based on a multiple alignment.

As prokaryotic genomes, we used a set of 32 Roseobacter gen—
omes, which were previously analysed by Newton et al. (2010).
They constructed a phylogenetic tree for these sequences based
on alignments of 70 universal single—copy genes that we used as
reference tree in our study. The total size of this sequence set is
135.9 mb.

As benchmark proteins, we used 218 sequence sets contained
in the BAliBASE (v3.0) database (Thompson et al., 2005).
To obtain reference trees, we applied Maximum Likelihood
(Felsenstein, 1981), implemented in the program proml from
PH YLIP to the reference multiple alignments in BAliBASE. As
these reference alignments are considered to be reliable, the
resulting trees should also be reliable.

In addition to these real—world sequences, we used the pro—
gram Rose (Stoye et al., 1998) to generate simulated DNA and
protein families. Rose generates sets of related sequences based
on a probabilistic model of substitutions and insertions/deletions
for which the parameters can be adjusted by the user. These
sequences are created along a randomly generated tree, starting
from one common ancestral sequence at the root of the tree. This
way, the ‘evolution’ of the generated sequences is logged, so a
reference tree is generated alongside the sequences. We used Rose
with default parameters, except for the parameter relatedness,
which deﬁnes the average evolutionary distance between the gen—
erated sequences, measured in PAM units. We generated 20
DNA sequence sets, each of which contains 50 sequences with
an average length of 16000 nt using a relatedness value of 70.
Furthermore, we generated 20 protein sequence sets, each con—
taining 125 sequences with an average length of 300 amino acids.
Here, we set the relatedness to 480.

4.2 Compared methods

We compared our new method with seven state—of—the—art align—
ment—free methods, namely ACS (Ulitsky et al., 2006), K, v2.0.2
(Haubold et al., 2009), FFP (Sims et al., 2009), spaced words
(Leimeister et al., 2014), CVTree (Qi et al., 2004), the underlying
approach (UA) (Comin and Verzotto, 2012) as well as to a

 

2003

ﬁm'spzumofpmJXO'sopeuuopnorq/ﬁdnq

raumtgoimondwmowoxmoamoﬁdﬁmbnﬁ

raumtgoimondwmowoxmoamoﬁdﬁmbnﬁ

 

L
m

C. -A.Leimeister and B.Morgenstem

 

      

normalized distance

ispaced words
*ACS c-FFP1=20
*kmacs k=1o -KI‘

—kmaes k:3o +UA

.kxnacs k=5o +CVTree k:8

 

 

o 0.05 0.1 0.15 0.2 0.25 0.3 0.35 0.4 0.45 0.5 0.55 0.6 0.65 0.7 0.75

substitutions per site

Fig. 8. Distances calculated by different alignment-free methods as a
function of substitutions per site for pairs of simulated DNA sequences.
Distances were normalized such that they are equal for 0.75 substitutions
per site

Table 1. Program runtime for different methods on a set of 50 simulated
DNA sequences of length 16 000 nt each

 

 

Method Runtime (5)
Clustal W 1817
Clustal Q 1039
8-mer 0.3
FFP, l = 23 123.3
spaced words, 100 patterns, k = 8 27.6
ACS 2.8
K,- 0.9
CVTree 0.5
UA 572
kmacs, k = l 4.2
kmacs, k = 10 7.6
kmacs, k = 20 4.2
kmacs, k = 50 21.4

 

Note: Spaced words was run with 100 random patterns of varying length as
described by Leimeister et a]. (2014). For Clustal W and Clustal $2, the time for
calculating a multiple alignment is shown; for the six alignment—free methods the
time for calculating pairwise distances is shown.

patterns. K, was more than one order of magnitude faster than
kmacs and spaced words, respectively, although UA was the slow—
est method. The fastest method was our implementation of the
generic word—frequency approach, followed by K, and C VT ree.
In general, spaced words used with the single—pattern option is
only slightly slower than the k—mer approach. As shown in our
companion paper, however, spaced words produces considerably
better results when used with multiple patterns (Leimeister et al.,
2014). We therefore applied only the multiple—pattern version in
this study.

The relatively long runtime of UA is partially because of the
fact that this program is written in Java, while all other programs
that we tested are written in C + +. As expected, the multiple—
alignment approaches Clustal W and Clustal S2 (Sievers et al.,
2011) were far slower than the alignment—free methods; the

Table 2. Program run time for different methods on a set of 32 genome
sequences of total length 135 mi; from various Roseobacter species

 

 

Method Runtime (5)
17-mer 34.9
FFP, l = 24 9022
Spaced words, 100 patterns, k = 17 3617
ACS 531
K, 206
CVTree 84
kmacs, k = l 784
kmacs, k = 10 1302
kmacs, k = 50 3158
kmacs, k = 100 5433

 

Note: Parameters for spaced words as in Table 1.

difference in speed between alignment—based and alignment—free
methods was between three and four orders of magnitude.
All test runs were done on a Intel Core i7 4820k, which we over—
clocked to 4 .5 Ghz.

As explained in Section 2.2, kmacs searches for each pos—
ition i in one sequence the maximum substring starting at i
that matches a substring in the second sequence. There can be
more than one such maximal match, and all these matches are
extended to k—mismatch common substrings. Thus, the runtime
of kmacs depends on 2, the average number of such maximal
substring matches for a given position i. In principle, 2 can be
large and the worst—case time complexity of our algorithm is
therefore high. In practice, however, 2 is small, independent of
sequence length and substitution probability. Figure 9 shows
values of z for different sequence lengths and mutation
frequencies.

Finally, we wanted to know how accurately our greedy
heuristic approximates the exact maximal k—mismatch sub—
string length. Figure 10 compares the average maximal k—mis—
match substring length for varying substitution probabilities
(a) as estimated with our heuristic and (1)) calculated with a
slow and exact algorithm. The ﬁgure shows that our heuristic
is clearly suboptimal. But the goal of our project was not so
much to precisely estimate the maximal k—mismatch substring
lengths, but rather to deﬁne a distance measure on sequences
that can be efﬁciently calculated and that can be used to
obtain biologically meaningful results. Therefore, we think
that the discrepancies between the optimal substring lengths
and the values estimated by our heuristic are acceptable.
Figure 10 suggests, however, that better estimates of the k—
mismatch common substring lengths might improve the sensi—
tivity of kmacs on divergent sequence sets because the curves
for the exact solutions converge at higher substitution frequen—
cies. In fact, on the mitochondrial genomes that we used as
benchmark data, an exact algorithm led to better phylogenetic
trees than our greedy heuristic (Supplementary Material).
Therefore, it may be worthwhile to develop heuristics that
approximate the maximal k—mismatch substring lengths more
accurately.

 

2006

ﬁle'spzumofpmJXO'sopeuuowrorq/ﬁdnq

kmacs: the k-mismatch average common substring approach

 

 

-¢-sequence length: 10.000

-l-sequence length 100.000
+sequence length 1.000.000

*sequence length: 10.000.000

 

0.05 0i 005 0.2 0.25 0.5 0.55 0.4 0.45 0.5 0.55 0.0 0.05 0.7 0.75 0.8 0.85 0.9 0.95 I
substitutions per site

Fig. 9. Average number 2 of maximal exact matches starting at a position
i in one sequence to a substring in a second sequence. We used simulated
DNA sequences with different lengths and substitution frequencies

   

 

    

 

—exact lengths _exact lengths
55 : . . =
so k 10 —heunstic 90 k 20 —heurisﬁc
45 30
40 7o
.1:
= 35 SE 60
l, 30 5 50
- 25 "2
El] 0
g 20 ‘5“
15 30 g
10 20
5 10
0 I
0.2 0.3 0.4 0.5 0.6 0.7 0.3 0.9 1 1.1 1.2 1.3 1.4 1.5 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 1.5
Substitutions per site Substitutions per site
_ —exact lengths _ —exact lengths
'40 k—30 —heuristic 180 k—40 —iieunsns
120 16°
140
100
g] '5 120
an
5 80 E 100
' 60 ab 80
E’ z 60
40
40
2° 20
0 0 I
0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 1.5 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1.1 1.2 1.3 1.4 1.5

Substitutions per site Substitutions per site

Fig. 10. Average common k-mismatch substring lengths depending on
the substitution frequency in simulated DNA sequences, estimated with
our greedy heuristic (lower curve) and calculated with an exact algorithm
(upper curve) for various values of k

6 CONCLUSION

Most alignment—free approaches to sequence analysis are based
on exact word matches. In this article, we presented a novel
alignment—free algorithm that takes mismatches into account.
This is similar in spirit to the spaced—words approach that we
previously proposed (Leimeister et al., 2014). But while spaced
words uses word pairs of a fixed length with possible mismatches
at pre—deﬁned positions, kmacs considers maximal substring
matches with k mismatches at arbitrary positions. In the
spaced—words approach, the number of match positions in the
underlying patterns is a critical parameter for the performance
of the method. In contrast, in kmacs, there seems to be a fairly
large range of values for k that lead to high—quality results, as
shown by our test results. kmacs seems therefore less sensitive to
user—deﬁned parameters.

The implementation of our approach using generalized
enhanced suffix arrays enables us to analyse large sequence sets
efﬁciently. Still, the program K, is roughly one order of magni—
tude faster than kmacs. One reason for this is that K, uses one
single generalized sufﬁx tree representing all input sequences,
which can be calculated in time proportional to the number of
sequences (Domazet—Loso and Haubold, 2009). In contrast,

kmacs calculates one generalized enhanced sufﬁx array for each
pair of sequences, so its run time is quadratic in the number of
sequences. On the other hand, calculating sufﬁx arrays for two
sequences at a time is less memory consuming, as one does not
need to keep the sufﬁx array for all input sequences simultan—
eously in main memory. Thus, our approach can be applied to
larger datasets than K,.

The two approaches that we developed, kmacs and spaced
words, are slower than the corresponding approaches based on
exact matches, ACS and the generic k—mer approach. Our new
approaches, however, produce significantly better results than
those established methods. Our test results suggest that spaced
words performs slightly better than kmacs on genomic sequences,
whereas on protein sequences, kmacs is superior.

In our program evaluation, we used DNA sequence sets with
large evolutionary distances. On these sequences, our new align—
ment—free methods performed better than established methods
that rely on exact word matches. Algorithms using exact
matches, on the other hand, seem to work better on smaller
evolutionary distances. K,, for example, performs best on evolu—
tionary distances of up to 0.6 substitutions per site (Haubold
et al., 2009). Similarly, we observed that on closely related
DNA sequences, kmacs produces sometimes best results with
k = 0, i.e. without mismatches (unpublished results). It seems
therefore best to apply kmacs to distantly related sequence sets,
while methods such as K, and ACS may be preferred on evolu—
tionarily more closely related sequences.

In biological sequences, substitutions are more frequent than
insertions and deletions. Consequently, exact matches between
local homologies can usually be extended until the ﬁrst substitu—
tion is reached. The average length of longest common substrings
and of shortest unique substrings, respectively, can therefore be
used to estimate substitution probabilities (Haubold et al., 2009).
This is similar for kmacs as long as k is small enough. In this
case, all k mismatches are likely to be used up in a k—mismatch
common substring extension before the first indel occurs. Thus,
the average length of the longest k—mismatch common substrings
depends on the frequency of mismatches and could be used to
estimate substitution probabilities, just as in K,.

In contrast, if k is sufﬁciently large, substring matches between
local homologies are essentially extended until the ﬁrst indel
occurs. From this point on, the mismatch frequency is high
and the remaining mismatches will be used up quickly. So in
this situation, the average k—mismatch substring length depends
on the frequency of indels rather than on the frequency of sub—
stitutions. This may explain why ACS and K, work well on
closely related sequences, while kmacs is superior on distantly
related sequences where the frequency of indels may be a
better measure for evolutionary distances than the frequency of
mismatches.

In our study, we used alignment—free methods to reconstruct
phylogenetic trees and evaluated the quality of these trees. But
phylogeny reconstruction is only one important application of
sequence comparison. Clustering, classiﬁcation and remote—
homology detection are other fundamental challenges in DNA
and protein sequence analysis. With the rapidly growing size of
sequence databases, alignment—free methods have become indis—
pensable for these tasks (Comin and Verzotto, 2012; Hauser
et al., 2013; Lingner and Meinicke, 2006). Given the speed of

 

2007

ﬁre'spzumofpropo'sopeuuopnorq/ﬁdnq

C. -A.Leimeister and B.Morgenstem

 

kmacs and the quality of the phylogenetic trees that we could
produce with it, our approach should be useful not only for fast
phylogeny reconstruction, but also for other tasks in compara—
tive sequence analysis.

ACKNOWLEDGEMENTS

The authors want to thank Bernhard Haubold, Sebastian
Horwege and Manuel Landesfeind for useful comments and dis—
cussions as well as Sebastian Lindner, Martin Sch'oneich and
Marcus Boden for providing datasets used in this study.

Conﬂicts of Interest: none declared.

REFERENCES

Abouelhoda,M.I. et al. (2004) Replacing sufﬁx trees with enhanced sufﬁx arrays.
J. Discrete Algoritlmts, 2(1), 53786.

Babenko,M.A. and Starikovskaya,T.A. (2008) Computing longest common sub—
strings via sufﬁx arrays. In: Computer Science — Theory and Applications,
volume 5010 of Lecture Notes in Computer Science. Springer: Berlin,
Heidelberg, pp. 64475.

Boden,M. et al. (2013) Alignment—free sequence comparison with spaced k—mers. In:
Proceedings German Conference on Bioinformatics ( GCB '13 ). OpenAccess
Series in Informatics, pp. 21731.

Comin,M. and Verzotto,D. (2012) Alignment—free phylogeny of whole genomes
using underlying subwords. Algorithms Mol. Biol., 7, 34.

Didier,G. et al. (2012) Variable length local decoding and alignment—free sequence
comparison. Theor. Comput. Sci., 462, 1711.

Domazet—Loso,M. and Haubold,B. (2009) Efﬁcient estimation of pairwise dismnces
between genomes. Bioinformatics, 25, 322173227.

Felsenstein,J. (1981) Evolutionary trees from DNA sequencesza maximum likeli—
hood approach. J. Mol. Evol., 17, 3687376.

Felsenstein,J. (1989) PHYLIP — Phylogeny Inference Package (Version 3.2).
Cladistics, 5, 164466.

Fischer,J. (201 1) Inducing the LCP—array. In: Proceedings of12th Algorithms and Data
Structures Symposium, Lecture Notes in Computer Science 6844. pp. 37¢385.
Fischer,J. and Heun,V. (2006) Theoretical and practical improvements on the
RMQ—problem, with applications to LCA and LCE. In: Proceedings of the
17th Annual Symposium on Combinatorial Pattern Matching, Lecture Notes in

Computer Science 4009. pp. 36—48.

Fischer,J. and Heun,V. (2007) A new succinct representation of RMQ—information
and improvements in the enhanced sufﬁx array. In: Proceedings of the
International Symposium on Combinatorics, Algorithms, Probabilistic and
Experimental Methodologies, Lecture Notes in Computer Science 4614.
pp. 4594170.

Harel,D. and Tarjan,R.E. (1984) Fast algorithms for ﬁnding nearest common
ancestor. SIAM J. Comput., 13, 3387355.

Haubold,B. et al. (2005) Genome comparison without alignment using shortest
unique substrings. BMC Bioinformatics, 6, 123.

Haubold,B. et al. (2009) Estimating mutation distances from unaligned genomes.
J. Comput. Biol., 16, 148771500.

Hauser,M. et al. (2013) kclust: fast and sensitive clustering of large protein sequence
databases. BMC Bioinformatics, 14, 248.

Horwege,S. et al. (2014) Spaced words and kmacs: fast alignment—free sequence
comparison based on inexact word matches. Nucleic Acids Res., [Epub ahead
of print, doi:10.1093/nar/gku398].

Leimeister,C.A. et al. (2014) Fast alignment—free sequence comparison using
spaced—word frequencies. Bioinformatics, 30, 199171999.

Lin,J. (1991) Divergence measures based on the shannon entropy. IEEE Trans. Inf.
Theory, 37, 1457151.

Lingner,T. and Meinicke,P. (2006) Remote homology detection based on oligomer
distances. Bioinformatics, 22, 222$2231.

Manber,U. and Myers,G. (1990) Sufﬁx arrays: a new method for on—line string
searches. In: Proceedings of the first annual ACM—SIAM symposium on
Discrete algoritlmts, SODA '90. pp. 3197327.

Newton,R. et al. (2010) Genome characteristics of a generalist marine bacterial
lineage. ISME J, 4, 78¢798.

Nong,G. et al. (2009) Linear sufﬁx array construction by almost pure induced—
sorting. In: Proceedings of 19th IEEE Data Compression Conference (IEEE
DCC). pp. 193202.

Qi,J. et al. (2004) CVTree: a phylogenetic tree reconstruction tool based on whole
genomes. Nucleic Acids Res., 32 (Suppl. 2), W457W47.

Robinson,D. and Foulds,L. (1981) Comparison of phylogenetic trees. Math. Biosci.,
53, 1317147.

Saitou,N. and Nei,M. (1987) The neighbor—joining method: a new method for
reconstructing phylogenetic trees. Mol. Biol. Evol., 4, 406—425.

Sievers,F. et al. (2011) Fast, scalable generation of high—quality protein multiple
sequence alignments using Clustal Omega. Mol. Syst. Biol., 7, 539.

Sims,G.E. et al. (2009) Alignment—free genome comparison with feature frequency
proﬁles (FFP) and optimal resolutions. Proc. Natl Acad. Sci., 106, 26772682.

Stoye,J. et al. (1998) Rose: generating sequence families. Bioinformatics, 14,
1577163.

Thompson,J.D. et al. (1994) CLUSTAL W: improving the sensitivity of progressive
multiple sequence alignment through sequence weighting, position—speciﬁc gap
penalties and weight matrix choice. Nucleic Acids Res., 22, 467341680.

Thompson,J.D. et al. (2005) BAliBASE 3.0: latest developments of the multiple
sequence alignment benchmark. Proteins, 61, 1277136.

Ukkonen,E. (1995) On—line construction of sufﬁx trees. Algorithmica, 14, 242260.

Ulitsky,I. et al. (2006) The average common substring approach to phylogenomic
reconstruction. J. Comput. Biol., 13, 33(r350.

Vinga,S. and Almeida,J. (2003) Alignment—free sequence comparisonia review.
Bioinformatics, 19(4), 5137523.

Weiner,P. (1973) Linear pattern matching algorithms. In: Proceedings of the 14th
IEEE Symposium on Switching and Automata Theory. pp. 1711.

 

2008

ﬁle'spzumol‘pmjxo'sopeuuqurorq/pdnq

