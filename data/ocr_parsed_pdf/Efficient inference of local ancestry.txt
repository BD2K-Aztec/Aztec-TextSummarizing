BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

Efficient inference of local ancestry

 

ancestral populations is discussed in Section 3.3. We also assume
the samples of ancestral populations are available so that we can
infer ancestral genotype distributions. Based on these assump—
tions, we infer local ancestry using three samples: one study
sample of admixed individuals with unknown local ancestry
and two reference samples from different ancestral populations.
Sections 2172.3 describe technical details of the EILA method.

2.1 Mapping admixed genotypes onto continuous scores

Deﬁne gj‘ ,~(= 0, l, or 2) as the number of reference alleles for an
individual i at locus j. Genotypes from the reference ancestral
populations are denoted by the superscript A and B. Given a
collection of 111 individuals from Ancestry A and 112 individuals
from Ancestry B, we deﬁne a score em for the observed admixed
genotype gj‘ ,~ as the probability that g.“ is descended from
Ancestry A:
e/‘i = Pr[gj‘,~ e A‘gﬁ‘Al), ...,gﬂ: and gig), ...,gEﬂ].

Unlike g.“ that is a discrete variable with little information
about the closeness of the SNPs to a certain ancestral population,
em is a continuous variable (with the range 071) that has an
intuitive interpretation. Suppose that we have a set of closely
linked SNPs from an admixed individual and that the two seg—
ments ﬂanking these SNPs are descended from Ancestry A, the
majority of ell ,~ would be close to 1. However, if the segments are
descended from Ancestry B, the majority of em would be close to
0. In another situation where one segment is descended from
Ancestry A and the other segment from Ancestry B, the average
of em would be ~0.5. Because the event ng e A is binary, the
logistic regression is a natural choice for calculating the score e) ,~.

2.2 Using fused quantile regression to identify breakpoints
of the ancestral haplotypes

For an admixed individual i, the ﬁrst step of EILA generates a
sequence of scores e/‘i,j = l, ...,m. Define 6“ to be a smooth
series. Using the fused quantile regression proposed by Eilers and
de Menezes (2005), we can estimate 6“ by ﬁnding the value that
minimizes

Zle/J—e/Jl+XZIQ/J—e/71JI- (1)
1:1 1:2

Equation (1) contains two terms: the ﬁrst term is a median re—
gression that is robust to outliers; the second term is a penalty
that determines the smoothness of 6N using the tuning parameter
k>0. When 9» is small, the effect of the penalty is small, so the
ﬁtted value of 611 ,~ is very close to the observed ell ,~. On the other
hand, when 9» is large, the penalty term dominates, so the 611 ,~’s in
proximity are similar. The choice of 9» is discussed in detail in
Section 3.2.

In summary, the ﬁtted curve has plateaus and sudden jumps
between them. The plateau indicates that all of the SNPs within
this region are in one of three cases: (i) descended from Ancestry
A, (ii) descended from Ancestry B or (iii) equally admixed. The
jumps between plateaus are possible breakpoints between ances—
tral blocks. The fused quantile regression is used in this step to
achieve two goals: one is to smooth SNP scores within admixed

individuals and the other is to infer the location of breakpoints
for ancestral blocks.

2.3 Using k-means classiﬁer to infer local ancestry

Given the breakpoints for each admixed individual identiﬁed in
the previous step, we propose to infer the local ancestry for each
segment between breakpoints using the k—means classiﬁer be—
cause of its efﬁciency and accuracy in assigning local ancestry.
It is important to note that all SNPs in each segment are used in
this step to achieve high power of inference.

To classify genomic segments into Ancestry A, Ancestry B or
equally admixed, we need the corresponding three types of SNP
distributions. Although we have samples from ancestral popula—
tions A and B, we do not have samples that are known to have
equal admixture from these two ancestral populations at every
locus. Our approach for dealing with this issue is to simulate
ﬁrst—generation admixed individuals through random mating of
two individuals of whom one is randomly selected from Ancestry
A and the other from Ancestry B. The random mating process is
repeated many times to generate a sample of equally admixed
individuals. In practice, the number of simulated admixed indi—
viduals would be equal to the average number of individuals in
populations A and B.

To infer local ancestry for each segment between breakpoints
using unsupervised k—means classiﬁcation, we deﬁne the test set
as all SNPs within the segment being studied. The training set
consists of the corresponding segments from the simulated
sample of equally admixed individuals along with the two refer—
ence samples from the ancestral populations A and B. Note that
the ancestral statuses for the training set are known but the an—
cestral status for the test set is unknown. We use the k—means
classiﬁer to train the three reference samples in the training set
and to identify the three centroids (or means) corresponding to
the three reference populations. To infer the local ancestry of the
test segment, we find the centroid nearest to the test segment.
This procedure is repeated until every segment of unknown local
ancestry SNPs for every admixed individual in the study sample
has been classiﬁed.

3 IMPROVEMENT AND EXTENSION OF THE EILA
METHOD

The direct implementation of the EILA method for high—
throughput arrays requires a huge amount of computer
memory and computation time. For example, we found that
when the total number of SNPs was 20 000, the fused quantile
regression implemented in R required >192—GB RAM, which is
beyond the capacity of most computers. For 10 000 SNPs, it took
10 h on 2.53 GHz Intel(R) Xeon(R) CPU running R under
Linux. Thus, for Genome—Wide Human SNP Array 6.0
(Affymetrix Inc., Santa Clara, CA) that contains >70 000 SNPs
on chromosome 1, the required computer memory and compu—
tation time are not practically feasible. Sections 3.1 and 3.2 de—
scribe our approaches to drastically improve the computational
efﬁciency (it took only 0.6s rather than 10h for 10000 SNPs on
the same machine). Section 3.3 extends the EILA to the case of
three ancestral populations.

 

2751

ﬁle'spzumofpmjxo'sopeuHOJmqu/ﬁdnq

J.J.Yang et al.

 

3.1 Improving fused quantile regression

The simplest way to improve computational efﬁciency is to
adopt the FrischiNewton method following the recommenda—
tion of Eilers and de Menezes (2005) and Koenker (2005). The
computation time of this method is, however, proportional to the
third power of the number of SNPs. In addition, the required
computer memory for the FrischiNewton method at the scale of
high—throughput arrays is not feasible in most settings. Thus, we
propose the following two approaches to increase the computa—
tional efﬁciency without losing accuracy of breakpoint identiﬁ—
cation. First, we used the Wilcoxon rank—sum test to compare the
distributional difference between the two reference samples at
each locus. For every M base pairs, we selected 1 SNP with
the smallest P—value. Our preliminary analysis found that
M = 50, 000 is sufﬁcient for fused quantile regression to identify
the breakpoints without missing any potential ones. Second, be—
cause even 1 SNP per 50 000 bp requires a lot of computation
time to ﬁt the fused quantile regression on one whole chromo—
some, we further improved the algorithm by ﬁtting the fused
quantile regression piecewise. That is, we partitioned the whole
chromosome into several segments, each of which has a length
between 10 and 25 MB. As our purpose is to identify break—
points, ﬁtting fused quantile regression in each partition does
not affect breakpoint identiﬁcation.

3.2 Choice of the tuning parameter

In Section 2.2, we brieﬂy explain that the function of the tuning
parameter 9» of the fused quantile regression is to control the
smoothness of the fitted curve. In this section, we provide the
technical details of how to choose the tuning parameter.

One approach commonly adopted in quantile regression is the
Schwarz information criterion [SIC; (Schwarz, 1978)] under
which the optimal value of 9» (i.e. the one that minimizes SIC)
can only be determined empirically. This is, however, a time—
consuming process, especially for a large number of SNPs, and
thus is not practical in genetic data analysis. Furthermore, we
conducted a simulation study ﬁtting the fused quantile regression
with various values of 9» on simulated admixed samples (see
Section 4.2 for the detailed procedure of data generation) and
found that SIC is not an effective approach to determine the
optimal 2». For example, Figure 1 based on our simulation results
shows that any 9» value >8 could be the optimal value.

Instead of the SIC approach, we propose a simulation ap—
proach to ﬁnd the optimal 2». We evaluated the relationship be—
tween )» and breakpoints by using the fused quantile regression
with various values of 9» to fit simulated data resulting from the
procedure described in Section 4.2. Figure 2 displays the simu—
lation results based on three values of 2»: 5,15, 50 in the top,
middle and bottom panels, respectively. The blue points indicate
that both alleles of the corresponding SNP were descended from
AncestryA; the green points indicate that both alleles were des—
cended from Ancestry B; and the brown points indicate that two
alleles were descended from Ancestries A and B. The red lines are
the ﬁtted lines of fused quantile regression that are between the 0
and 0.5 horizontal lines in the region of blue points, between the
0.5 and 1 horizontal lines in the region of green points and in
proximity to the 0.5 horizontal line in the region of brown points.

 

SIC

 

 

 

Fig. 1. The relationship between SIC and 7» based on simulation

The true breakpoints are at the boundary of regions with differ—
ent colors.

The top panel of Figure 2 shows that the fitted fused quantile
regression with a small value of 9» (e.g. 5) detected all true break—
points and yet had short segments that tended to result in low
power in local ancestry inference because very few SNPs can be
used in the k—means clustering. On the other hand, the bottom
panel shows that the ﬁtted fused quantile regression with a large
value of 9» (e.g. 50) had long segments and also tended to miss
many breakpoints. The middle panel, otherwise, shows a com—
promise between the two when )» = 15, which was the largest
value at which all true breakpoints can be identiﬁed in the simu—
lation and thus was chosen to be the optimal value. The results in
Section 4 show that the EILA method with this particular 9»
value performs well in comparison with two competing methods,
HAPMIX and LAMP, under different ancestral distributions
and number of generations.

3.3 Extension to three ancestral populations

It is straightforward to extend our method to the case of three
ancestral populations (e. g. A, B and C) for which there are three
possible pairs (i.e. AiB, BiC, and AiC). Following the steps in
Sections 2.1 and 2.2, we can identify a set of breakpoints for each
pair of ancestral populations. For example, the breakpoints S A B
of the AiB pair can be identiﬁed using the admixed sample and
ancestral samples from populations A and B. For the other two
ancestral pairs, the breakpoints S BC and S AC can be identified in
similar ways. The set of breakpoints for these three ancestral
populations, S ABC, is thus the collection of breakpoints from
the three sets, SAB, SEC, SAC.

To infer local ancestry for each segment speciﬁed by the break—
points S A BC, we can follow the procedure in Section 2.3 to simu—
late an admixed sample from each pair of the three reference
samples. Using the k—means classiﬁer with k = 6 based on the
three reference samples and three simulated admixed samples, we
can assign each unknown segment for each individual in the
study sample to one of the six possible ancestral populations.

4 SIMULATION STUDY

We evaluated the performance of the proposed EILA method in
comparison with two existing methods for inference of local

 

2752

ﬁle'spzumofpmjxo'sopeuHOJmqu/ﬁdnq

53x\Ewogmoizmnnw.oxmoagoﬁsiwbwﬁ

 

               

’: .!

...<m—.—________

,...

    
 

*0.

o o 0‘:

 

J.J.Yang et al.

 

Table 1. The RMSD values based on chromosome 1 using independent samples from HapMap

 

 

Population ASW CEU CHB CHD GIH JPT LWK MEX MKK TSI YRI
ASW 0.1851 0.2232 0.2251 0.1803 0.2240 0.0753 0.1781 0.0776 0.1835 0.0720
CEU 4.79 0.2011 0.2043 0.1142 0.2022 0.2300 0.1083 0.1937 0.0515 0.2370
CHB 5.78 5.21 0.0386 0.1687 0.0588 0.2501 0.1590 0.2267 0.2047 0.2556
CHD 5.83 5.29 1.00 0.1701 0.0641 0.2516 0.1621 0.2291 0.2068 0.2576
GIH 4.67 2.96 4.37 4.40 0.1689 0.2184 0.1169 0.1859 0.1145 0.2264
JPT 5.80 5.24 1.52 1.66 4.37 0.2509 0.1595 0.2277 0.2056 0.2562
LWK 1.95 5.95 6.48 6.52 5.65 6.50 0.2177 0.0771 0.2279 0.0595
MEX 4.61 2.80 4.12 4.20 3.03 4.13 5.64 0.1845 0.1112 0.2253
MKK 2.01 5.01 5.87 5.93 4.81 5.89 2.00 4.78 0.1900 0.0942
TSI 4.75 1.33 5.30 5.35 2.96 5.32 5.90 2.88 4.92 0.2355
YRI 1.86 6.14 6.62 6.67 5.86 6.63 1.54 5.83 2.44 6.10

 

Note: Population descriptors.

ASW, African ancestry in Southwest USA; CEU, Utah residents with Northern and Western European ancestry from the CEPH collection; CHB, Han Chinese in Beijing,
China; CHD, Chinese in Metropolitan Denver, Colorado; GIH, Gujarati Indians in Houston, Texas; I PT, Japanese in Tokyo, Japan; LWK, Luhya in Webuye, Kenya; MEX,
Mexican ancestry in Los Angeles, California; MKK, Maasai in Kinyawa, Kenya; TSI, Toscani in Italia; YRI, Yoruba in Ibadan, Nigeria.

values listed in the lower triangle are the ratio of the RMSD of a
particular pair to the RMSD of the reference pair CHB/CHD
(Han Chinese in Beijing/Chinese in Metropolitan Denver), which
has the smallest value of RMSD among all pairs. We simulated
all pairwise admixed samples from the HapMap ancestral sam—
ples. Among them, the following six pairs have been chosen to be
the focus of the simulation experiments because of the common
interest in studying them and the wide range of differences rep—
resented by them: CEU/YRI and GIH/YRI represent the high
level of difference; CEU/MEX, GIH/MEX and GIH/CEU are at
the moderate level; and CEU/TSI represents the low level (CEU:
Utah residents with Northern and Western European ancestry
from the CEPH collection; GIH: Gujarati Indians in Houston,
Texas; MEX: Mexican ancestry in Los Angeles, California; TSI:
Toscani in Italia; YRI: Yoruba in Ibadan, Nigeria).

To simulate ancestral samples, the genotypes at each locus
were generated using the allele frequencies estimated from
HapMap ancestral populations. We simulated 60 ancestral sam—
ples on chromosome 1 for each ancestry. For each pair of an—
cestral samples from HapMap, we deﬁned one as Ancestry A
and the other as Ancestry B. To generate one admixed individual
from Ancestries A and B for g generations, we simulated 23 in—
dividuals with the probability 1' from Ancestry A and the prob—
ability 1 — ‘L' from Ancestry B. The resulting 2g individuals thus
served as the ancestry of the admixed individual. The next gen—
eration of size 2g’1 was derived by randomly pairing the 23 in—
dividuals and having each pair generate one child. This process
of random mating was executed recursively to simulate g gener—
ations. We simulated 30 admixed individuals from Ancestries A
and B by repeating the process of generating one admixed indi—
vidual 30 times. We also set the recombination rate at the com—
monly adopted level of 10’8/bp (Nachman and Crowell, 2000).

4.3 Simulation results

This section compares the performance of three competing meth—
ods (EILA, HAPMIX and LAMP) when T = 0.25 and the time
since admixture (measured in the number of generations) is

varied: g=1,5,10. The accuracy of local ancestry inference
for each method was calculated for each admixed individual.
Figure 3 shows the boxplots of the accuracy rates among the
simulated 30 admixed individuals from the same ancestral pair
under each conﬁguration of the method and the number of gen—
erations. This figure consists of six panels, each of which corres—
ponds to an ancestral pair including CEU/YRI, CEU/MEX,
CEU/TSI, GIH/YRI, GIH/MEX and GIH/CEU.

The major factor that affects the accuracy of local ancestry
inference is the ancestral distance (i.e. RMSD). For ancestral
populations with a large RMSD such as CEU/YRI
(RMSD = 0.237), all three programs had high average accuracy
rates (> 0.90). For moderately related ancestral populations such
as CEU/MEX (RMSD=0.108), the average accuracy rates
ranged from 0.62 to 0.86 across the methods. For closely related
ancestral populations such as CEU/TSI (RMSD=0.051), the
average accuracy rates of local ancestry inference ranged from
0.35 to 0.60 across the methods.

In comparison with HAPMIX and LAMP, EILA had higher
accuracy and lower variation when the ancestral distance was
large or moderate (i.e. all ancestral pairs but CEU/TSI). In the
case of closely related ancestral populations such as CEU/TSI,
all the three methods performed poorly (the average accuracy
rate <0.60). Although HAPMIX performed slightly better
than the other two methods for the CEU/TSI pair, its perform—
ance appeared to be heavily dependent on the quality of phased
ancestral samples. Particularly, for any simulated admixed sam—
ples involving GIH ancestral population, HAPMIX had lower
accuracy and higher variation in comparison with the other two
methods. We also conducted paired t—tests to compare the dif—
ferences in average accuracy between EILA and LAMP and be—
tween EILA and HAPMIX. The results show that the average
accuracy of EILA was signiﬁcantly higher than the other two
methods (P <0.05) for all the ancestral pairs, except for the pairs
of CEU/YRI and CEU/TSI. To benchmark the computational
efﬁciency of the three programs, we measured the total time to
infer local ancestry for the 30 admixed individuals simulated in

 

2754

ﬁle'spzumofpmjxo'sopeuHOJmqu/ﬁdnq

Efficient inference of local ancestry

 

CEU/YRI

CEU/MEX

CEU/TSI

E i := :2 :_ E I E
I
? o 0' ! I I i 0
2E I I I . I I I
>, g g I I g I I
O
E I I I I I I
a; z 2 I .
o I I I I
< q I EILA ., N
O I HAPMIX ° O
Q I LAMP Q
l 5 10 1 5 10 1 5 10
GIH I YRI GIH I MEX GIH / CEU
S i :I __ _ S _ — 3 I
I I I I I : I : l
2 g I g I
’3 ' ' I I
5 I' I I I
> 3 S I g I
0
g I
8 g 3 22 I I |
o I I
< . N ._ I
I 5 10 1 5 10 1 5 10
Generation Generation Generation

Fig. 3. The boxplots of the accuracy of local anccstry infcrcncc using EILA. HAPMIX and LAMP

our study. The total computation time was 332 s for EILA. 116 s
for HAPMIX and 552s for LAMP. Thus. the computational
efﬁciency of EILA is comparable with that of the other two
programs in practical settings.

We also evaluated the effect of the time since admixture on the
accuracy of local ancestry inference. When g = 1. all the simu-
lated admixed individuals had no breakpoints for ancestral seg-
ments (i.e. all SNPs were either descended from one ancestral
population or admixed from the two ancestral populations).
Thus. this situation was used to evaluate whether any of the
methods require the existence of breakpoints. The result shows
that none of the methods failed in such a situation. Overall. all
the three methods performed worse as the time since admixture
became longer (i.e. more generations). This effect was. however.
relatively small in comparison with the effects of ancestral dis-
tances and analytical methods.

5 CONCLUSIONS

This study contributes to the field by developing a statistical
method. EILA. to efﬁciently infer local ancestry in admixed in-
dividuals based on the three steps that were designed to deal with
the existing methodological challenges. The major strength of
EILA is that it relaxes the assumption of linkage equilibrium

and uses all genotyped SNPs rather than only unlinked loci to
increase the power of inference. We also propose new approaches
to improve the computational efﬁciency of the EILA method
drastically and extend it to the case of three ancestral popula-
tions. The R package EILA implementing the EILA method will
be available at http:ffcranr-project.org}.

Our simulation results show that the ancestral distance is the
major factor affecting the accuracy of local ancestry inference.
The accuracy rates decreased as the ancestral distance decreased.
When the ancestral distance was large or moderate. EILA had
higher accuracy and lower variation in comparison with the two
competing methods. HAPMIX and LAMP. In the case of closely
related ancestral populations. all the three methods performed
poorly. In terms ofcomputational efﬁciency. EILA performed as
well as the other two methods. Overall. all the three methods
performed worse as the time since admixture became longer. This
effect was. however. relatively small in comparison with the ef-
fects of ancestral distances and analytical methods.

Funding: National Institutes of Health (NIH) grants (K01
AA016591 and R01 AIO79139). The content is solely the respon-
sibility of the authors and does not necessarily represent the
official view of the NIH.

Conﬂict af'I/ileresl: none declared.

 

2755

/810'SIEumo_fpmjxo'SOIJEmJOJUIOIW/zduq

J.J.Yang et al.

 

REFERENCES

Collins,F.S. et a]. (2003) The human genome project: lessons from large—scale biol—
ogy. Science, 300, 2867290.

Devlin,B. and R0eder,K. (1999) Genomic control for association studies.
Biometrics“, 55, 99771004.

Eilers,P.H. and de Menezes,R.X. (2005) Quantile smoothing of array CGH data.
Bioinformutics‘, 21, 114(r1153.

K0enker,R. (2005) Quantile regression. Cambridge University Press, New York.

Nachman,M.W. and Crowell,S.L. (2000) Estimate of the mutation rate per nucleo—
tide in humans. Genetics, 156, 2977304.

Price,A. et a]. (2006) Principal components analysis corrects for stratiﬁcation in
genome—wide association studies. Nat Genet, 38, 9047909.

Price,A.L. et a]. (2009) Sensitive detection of chromosomal segments of distinct
ancestry in admixed populations. PMS Genet, 5, e1000519.

Pritchard,J.K. et a]. (2000) Inference of population structure using multilocus geno—
type data. Genetics', 155, 9457959.

Sankararaman,S. et a]. (2008) Estimating local ancestry in admixed population. Am.
J. Hum. Genet, 82, 29(F303.

Schwarz,G. (1978) Estimating the dimension ofa model. Ann. Stat, 6, 987108.

Tang,H. et a]. (2006) Reconstructing genetic ancestry blocks in admixed individuals.
Am. J. Hum. Genet, 79, 1712.

 

2756

/810'slaumoprOJxo'sopBLuJOJuioiq”:duq

