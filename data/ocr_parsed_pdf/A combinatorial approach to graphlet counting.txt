BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

55,2\Ewowsmoddmmowoio~&o:~=£¢o~m\

Graphlet counting

 

comparison of the networks with some additional mathematical
models (Kuchaiev et al., 2011). The graphlet counting procedure
in the new version remained essentially the same.

Rapid graphlet enumerator (RAGE) (Marcus and Shavitt,
2012) takes a different approach to counting four—node graph—
lets. Instead of counting the induced subgraphs directly, it recon—
structs them from counts of non—induced subgraphs. For
computing the latter, it uses speciﬁcally crafted methods for
each of the six possible subgraphs (G3 to G8 in Fig. 1). The
time complexity of counting non—induced cycles and complete
graphs is 0(e-d+ez), whereas counting other subgraphs re—
quires 0(e - (1). Another bound, which is also more suitable for
comparison with our method, is 0(e-aa) = 0(n-d3). Unlike
FANMOD and GraphCrunch, RAGE works only for up to
four—node graphlets.

2 METHODS

Let X represent a certain node of interest in graph G. Our task is to
compute the number of times, 0,, that X appears in each orbit 0,- across
all graphlets induced in G. We will present an approach based on a system
of linear equations that relate the orbit counts 0,. The rank of the system
is smaller than the number of orbits by one, so we can compute all values
of 0,- from directly enumerating only a single one. The algorithm allows to
compute the orbits for all points X in a graph in time that is smaller than
the existing direct enumeration approaches by an order of magnitude.

We will ﬁrst show how to construct a system of equations for four-
node graphlets. As for the single orbit that must be enumerated, we chose
014, which represents nodes of the complete graph, K4 (or G8); we show
an efﬁcient way to enumerate it. The approach used for four-node graph-
lets is less suitable for larger graphlets, so we present a different technique
for ﬁve-node graphlets.

2.1 Orbits in four-node graphlets

Right sides of equations we are about to construct contain terms that are
computed from the graph G. Let C(u, v) = |N(u) ﬂ N(v)| denote the
number of common neighbours of nodes u and v. Let p(u, v) denote the
number of paths on three nodes that start at node u, continue with v and
end with some node I, which is not connected to u. We can compute
p(u, v) as p(u, v) = deg(v) — l — C(u, v).

If some node X participates in a k-node graphlet G,-, it also participates
in some (k — l)-node graphlet G). This can be seen by removing one of
the graphlet’s nodes that are the farthest away from X. The subgraph
induced by the remaining nodes is connected (any disconnected node
would have to be farther from X than the removed node), so it is iso-
morphic to some (k — l)-node graphlet G).

We will use this observation in reverse: every four-node graphlet can be
constructed by adding a node to some three-node graphlets. To ﬁnd the
relations between counts of orbits in four-node graphlets for a certain
node X, we enumerate all three-node graphlets touching the node and
count their possible extensions with the fourth node.

An example is shown in Figure 2. Nodes X, y and z induce graphlet G1,
a path on three nodes; we will observe its extensions to four-node graph-
lets with the fourth node, w, connected to y and 2 (dashed lines). The
number of such nodes w is C(y, 2). In our example, there are c(y,z) = 3
such nodes, which we marked by w 1, wz and W3 (Fig. 2a). The edge (X, w)
might exist in the graph G (as in the case of W3, the dotted line) or not (as
for w] and wz). With no edge, nodes X, y, z and w form a paw (G6) with X
in orbit 09 (Fig. 2b). With an edge between X and w, they form a dia-
mond (G7) with X in orbit 012 (Fig. 2c). Because all c(y,z) nodes in
N01) ﬂ N(z) must participate either in G6 or G7, which puts X in 09 or
012, this gives 09 + 012 = c(y,z) for the particular triplet X, y and z.

      

(b) wgm (c)
 10
z ‘\ ‘ z z
y 11‘ y y
N(y)ﬂN(z)  
9 x 12 x
c(y,z)=3
66 G7

Fig. 2. Relation between orbits 09 and 012. Solid lines are edges in the
three-node graphlet being extended. Dashed lines exist by deﬁnition: w
(or w,-) are the common neighbours of y and z. Dotted lines are optional
edges that make the resulting four-node graphlet on X, y, z and w,- iso-
morphic to G6 or G7

We sum this over all possible three-node paths starting at X.
Summation must account for symmetries: each graphlet G6 appearing
in the graph is counted twice with roles of z and w reversed, and G7 is
counted twice with reversed roles of y and w. Accounting for this, we get

209 + 2012 = 2 CU}, Z)

y. z: X. zeN(y)

GHX. y. 2}]EGI
where g denotes graph isomorphism (e.g. G[{X,y, 2}], a subgraph on
nodes X, y and z is isomorphic to G1, a path with three nodes).

For a different example, we will relate orbits 06 and 09. We will extend

a path on nodes X, y and z with another path that starts with nodes X and
y; we denoted the number of such paths by p(X, y) (Fig. 3a). Depending
on whether the new node is adjacent to z, the extended graphlet is either a
claw (G4, Fig. 3b) or a paw (G6, Fig. 3c). After accounting for symmetries
and subtracting 1, as p(X, y) also covers the case when w = 2, we get

2 (my) — 1)
y. z: X. zeN(y)
GHX. y. 2}]EGI

206 + 209 2

There are only two three-node graphlets and relatively few possible
extensions. Investigating all possibilities in a similar manner yields 10
linearly independent equations with 11 variables that correspond to
counts of 11 orbits in four-node graphlets (see the Supplementary
Material).

Right sides depend on the graph G and need to be computed for each
point X. To accelerate their computation, we precompute values of C(u, v)
and p(u, v). In all equations, except for the last one, C(u, v) is computed on
pairs of nodes (u, v) that are connected; in p(u, v), they are connected by
the deﬁnition of 17. Therefore, it sufﬁces to precompute C(u, v) and p(u, v)
only for all pairs of connected nodes u and v, which requires 0(8) space.
The last equation, in which the new node closes a cycle, is treated separ-
ately. Nodes X and z are not adjacent but we can precompute the number
of paths of length 2 that start at node X and end at node y. This requires
0(n) space for each point; because we compute orbits for one point at a
time, this memory can be recycled. Altogether, all lookups in the sums on
the right sides can be done in constant time by sacriﬁcing the memory of
size 0(e + n) for precomputed values C(X, y) and p(X, y).

The total time complexity for computing all orbits for all nodes is
0(e - d+ T4), where 0(T4) is the time needed to enumerate complete
graphlets on four nodes. Later in the text, we describe an algorithm
that does this in 0(n - d3), yet the actual importance of this term depends
on the structure and density of the graph.

2.2 Counting complete graphlets

For every node, we still have to determine the count of one of the 11
orbits. Because graphs are usually sparse, a good candidate is the rare
orbit 14, which represents the nodes of the complete graphlet on four

 

561

ﬁm'spzumofpmﬂo'sopeuuopnoiq/ﬁdnq

T.Hoéevar and J.Dem§ar

 

    

(b) (C)
10
10
z 6 z “1.; """ ~ z
w... 
y 6 ‘7‘ y 11 y
p(x,y)-1=4 x 6 x 9 x
G4 G6

Fig. 3. Relation between orbits 06 and 09. Edges are marked like in
Figure 2

nodes G8. Because of few occurrences of this graphlet and its symmetri-
city, we can efﬁciently restrict the enumeration.

A straightforward way to count the complete graphlets of size four
that touch a given node X1 is to start with that node and in every step add
a neighbour X,- of the last added node XH, while checking that the new
node is also connected to all nodes before X,-, Xj<i,1. In this way, when we
add X4 as a neighbour of X3 we have to check whether it is connected to X]
and X2 (dotted lines in Fig. 4a), which is unlikely, especially in sparse
graphs.

A better strategy is to ﬁnd the common neighbours of X1 and X2,
N(X1) ﬂ N(X2), which can be done in 0(d). We then choose pairs
(X3,X4) from this set and check whether they are connected (Fig. 4b).
Candidates generated in this way have to satisfy only one additional
condition, as opposed to two in the straightforward approach.

To avoid counting the same graphlet multiple times, we request that
X2 <X3 <X4 under some ﬁxed arbitrary ordering of nodes. Although the
theoretical time complexity for ﬁnding all G8 that touch X using this
algorithm is the same for both approaches, 0(d3), the latter is much
faster on sparse graphs.

This method can be generalized for efﬁcient counting of larger com-
plete graphlets in sparse graphs. In every step, we maintain a list of can-
didate nodes C ,- for X,- that are adjacent to all previously added nodes. We
select one of these candidates and form a new candidate set CH1 consist-
ing only of nodes in C,- that are adjacent to the selected node,
CH1 2 C,» H N(X,») and C1 = V. The time complexity of ﬁnding all com-
plete k-node graphlets that touch X using this algorithm is 0(dk’1). Later
in the text, we use such procedure to enumerate complete subgraphs on
ﬁve nodes.

2.3 Orbits 0n five-node graphlets

For counting four-node graphlets, we constructed a list of equations by
adding nodes to three-node graphlets and observing the resulting four-
node graphlets. Extending the four-node graphlets to ﬁve-node graphlets
would yield a huge number of equations that are not linearly independ-
ent. We will use a different approach: for each orbit, we choose some
node y from the corresponding graphlet and observe the graphlets and
orbits in which the node of interest, X, appears if we add edges between y
and other nodes in the graphlet.

Let X be the node of interest, let y be the node whose edges we observe
and let X1, X2 and X3 be the other three nodes in that graphlet.

Figure 5 illustrates counting of appearances of X in 059, which belongs
to G24 (Fig. 5a). We will focus on the node marked by y, which is con-
nected to the nodes marked by X] and X3. Removing y reduces G24 into a
diamond, G7, with X in orbit 012.

Now assume that we are computing orbits for a certain node X and
discover some induced subgraph H a G7 with X in 012. We assign labels
X1, X2 and X3 to the remaining nodes as shown in the figure. Altogether,
the graph G contains C(X], X3) common neighbours of X1 and X3 (similar
to nodes marked with w in Fig. 3a). Although all these nodes are—by
deﬁnition of C(X], X3)4COIIIICCICC1 to X] and X3, some are also connected

(b) N(x )nN(x)

    

Fig. 4. Enumerating G8 by adding one neighbour at a time or by check-
ing pairs of neighbours. Dashed edges are added by iterating through
neighbours, and dotted edges are checked in the last step

   

(a) (d)
y 0.43
: x,
x1
x2
x 59
G24 G26 G27 GZS

Fig. 5. Computing orbit count 059; ﬁgures show graphlets for different
edges between y and other nodes and the orbits of X

to X2 or X, or both. Figure 5 shows all four possibilities, which give
graphlets G24, G26, G27 and G28 with X in orbits 59, 65, 68 and 70, re-
spectively. Therefore, 0’59 + 0’65 + 0’68 + 0’70 2 C(X1,X3) — 1, where 01’.
denote orbits of X with respect to H.

For the relation between 059, 065, 068 and 070 for the entire graph, we
sum this over all possible induced G7 with X in 012. After considering the
symmetries that cause counting the same graphlet multiple times with
different assignments of y, X1, X2 and X3, we get

059 + 4065 + 2068 + 6070 = Z C(Xi , X3) + 6062, X3) — 2
X1 
G[(X.XI.X3.X3}]EG7

Condition X1 <X2 (under some arbitrary ordering of nodes) is needed to
consider each graphlet G7 just once. The other two conditions put X in
012. The second term in the sum, C(Xz, X3), accounts for the case in which
the roles of X1 and X2 are exchanged.

Using a similar construction for other orbits, except for 072, gives 57
linear equations for 58 orbits (see the Supplementary Material). Like for
four-node graphlets, we directly enumerate the orbit 072, which belongs
to the complete graphlet. Equations are linearly independent due to the
way in which they were constructed: each equation is set up with one
orbit in mind (e.g. 059 in the aforementioned example), and the other
orbits that appear in the equation belong to graphlets with a larger
number of edges (the additional edges between y and the other nodes,
like the dotted edges in Fig. 5b41). Additional nice consequence besides
independence is that the system is easy to solve, as orbit counts can be
computed from those belonging to graphlets with more edges towards
those with less.

When constructing the equations, we choose y that allows for efﬁcient
computation of the right sides: we will ensure that the right sides contain
only the node degrees and the numbers of common neighbours of pairs
and of c0nnected triplets [C(u, v), C(u, v, t)]. This will allow us to precom-
pute and store the values of C(u, v) and C(u, v, t) for all pairs and con-
nected triplets in G before computing the orbit counts for individual
nodes.

First, we choose the node y so that the remaining nodes constitute
a four-node graphlet, i.e. removing y does not break the graphlet
into disconnected components, which would require enumeration of
disconnected subgraphs. Second, the node y has to have at most three
connections to avoid the need to compute the number of common

 

562

ﬁm'spzumofpmjxo'sopeuuopnoiq/ﬁdnq

Graphlet counting

 

neighbours of four points, C(u, v, w, t). Besides, when y has three neigh-
bours, they need to be connected.

A node y that fulﬁls these criteria exists for all orbits except 072.
Precomputing the values C(u, v, t) for all connected triplets takes
0(e - dz) time, and storing them in a hash table takes 0(e - 0]) space.
Computation of the right sides also requires enumerating all the four-
nodes graphlets, which again has a complexity of 0(e - dz).

The total time required to compute all orbit counts for all X e Vis then
0(e - d2 + T5) with 0(e - 0]) space, where 0(T5) is the time required to
enumerate all complete ﬁve-node graphlets (G29). The algorithm thus has
the same upper bound complexity as the existing algorithms, 0(n - 04).
However, experiments show that the bound is not tight: the contribution
of the 0(T5) is negligible over the range of sensible graph densities, and
the actual running times are smaller by an order of magnitude.

We could use the same technique to construct systems of equations for
larger graphlets. However, we reduced the running times by imposing
some conditions to the selection of the node y. We have not researched
whether such nodes also exist for larger graphlets; although theoretically
interesting, this may be of little practical use in the context of
bioinformatics.

3 RESULTS AND DISCUSSION

We compared the speed of Orca with RAGE, GraphCrunch and
FANMOD. We ran all experiments on a modest desktop com—
puter (Intel Core 2, 2.67 GHz). We have not experimented with
parallel execution; all four algorithms allow for trivial distribu—
tion of work on multiple cores, so the benefits of parallelization
should be the same for all.

We compared the performance of methods on the three largest
species—speciﬁc PPI networks from the July 2013 update of the
Database of Interacting Proteins (Salwinski et 0]., 2004) and the
human PPI network from the BioGRID (Chatr—Aryamontri

Table 1. Statistics of benchmark real-world networks

 

 

 

et 0]., 2013) 3.2.104 release. The sizes of individual datasets are
presented in Table 1.

All algorithms except the signiﬁcantly slower FANMOD
counted orbits for four—node graphlets in the smaller graphs in
a few seconds (Table 2). Five—node graphlets present a more
difﬁcult task: running GraphCrunch on the S.cerevisiae PPI
network took >9 min (as compared with 4.4s for four—node
graphlets). FANMOD was almost 10 times slower, whereas
Orca finished the same task 80 times faster, in 6.6 s. RAGE is
limited to four—node graphlets. We got similar results for the
other two networks.

In the larger human network, Orca counted the four—node
graphlets 100 and 1800 times faster than Rage and
GraphCrunch, respectively; we aborted FANMOD after 24h.
Orca was also the only algorithm capable of counting five—
node graphlets in a human PPI network in less than a day.

For comparison with RAGE, we included a test network of
Internet autonomous systems (http://www.netdimes.org/
PublicData/csv/ASEdges4_2012.csv.gz) that was used as the
benchmark for RAGE (Marcus and Shavitt, 2012). FANMOD
required >9 h, GraphCrunch finished in 37 min, RAGE in 3 min
and Orca in 2.5 s. Orca ﬁnished the computation for ﬁve—node
graphlets in 49 min, whereas the other two algorithms were
stopped after 24 h.

The time that Orca needs for counting orbits in ﬁve—node
graphlets is comparable with those that GraphCrunch needs
for four—node graphlets. This is consistent with the way the
two algorithms are constructed: GraphCrunch enumerates
four—node graphlets to count them, whereas Orca enumerates
them to count ﬁve—node graphlets. As expected, the time
needed for enumeration of complete ﬁve—node graphlets is neg—
ligible at these network densities.

For more insight into time complexities of the compared al—
gorithms, we tested them on synthetic data using three different
random network modelsiErdosiRenyi, geometric and

 

 

 

Network NOdeS Edges Maximum BarabasiiAlbert, random graphs. ErdosiRenyi graphs are con—
degree structed by randomly connecting 6 pairs of nodes. We generated
geometric graphs by randomly placing nodes in a 3D unit cube
S'Cemmm 5097 22 282 289 and connecting the e closest pairs; geometric graphs show largest
Escherichia 0011' 2984 11 626 178 . . . v -
resemblance to prote1n 1nteractlon networks (Przulj et 0]., 2004).
D.me]0n0gaster 7618 22 864 178 , . .
Human 18 170 1 37 775 9716 Barabas1iAlbert preferent1al attachment model generates scale——
Internet autonomous Systems 25 368 75 004 3781 free networks that exhibit hubs and individual highly connected
nodes.
Table 2. Comparison of algorithms on real-world networks
Network Four-node graphlets Five-node graphlets
FANMOD GraphCrunch RAGE Orca FANMOD GraphCrunch Orca
S.cerevisiae 62s 4.4s 1.7s <0.1s 87min 9.5min 6.6s
E.c0]i 34s 1.8s 1.0s <0.1s 38min 4.1min 4.8s
D.melan0gaster 21s 3.1 s 1.6 s <0.1 s 18 min 2.8 min 2.3 s
Human / 183 min 11.8 min 6.1 s / / 269 min
Internet autonomous systems 574 min 37 min 3.0 min 2.5 s / / 49 min

 

Note: We aborted the algorithms that took more than a day and marked the corresponding results with /.

 

563

ﬁm'spzumofpmjxo'sopeuuopnoiq/ﬁdnq

T.Hoéevar and J.Dem§ar

 

 

Erdés—Rényi Geometric

W

"o

g 40 >:<

_ 20 >5:

Q)

s F

a 0 0

0 100 200 0 100 200

edges [thousands]

 

edges [thousands]

Barabasi—Albert

 

  GraphCrunch
— a— RAGE
—e— Orca

0 O 100 200

edges [thousands]

Fig. 6. Comparison of times needed for counting orbits in four-node graphlets in random networks. Graphs are cut off at one minute; results of
experiments in which the methods were allowed to run for up to 1 h are available in the Supplementary Material

Geometric

Erdos—Rényi

time [seconds]

 

10 20 30

10 20 30 40

edges [thousands]

 

edges [thousands]

Barabasi-Albert

    

0 10 20  .. GraphCrunCh

edges [thousands] —e— Orca

Fig. 7. Comparison of times needed for counting orbits in ﬁve-node graphlets in random networks

We explored the performance of GraphCrunch, RAGE and
Orca at different network densities. FANMOD was not included
as it consistently ﬁnished previous tests far behind
GraphCrunch. All graphs had 1000 nodes; for each method,
we increased the graph density until the method needed more
than a minute to complete the test. The corresponding graphs
were relatively dense, containing up to 40% of all possible edges
for test with four—node graphlets and ~10% for ﬁve—node
graphlets.

RAGE counted the four—node graphlets slightly faster than
GraphCrunch, but they were both signiﬁcantly outperformed
by Orca (Fig. 6 and Supplementary Tables 81786). We observed
similar results when counting five—node graphlets (Fig. 7). Orca
achieved the highest gain in comparison with other methods on
BarabasiiAlbert models, in which hubs present a large obstacle
for GraphCrunch and RAGE. This makes Orca more suitable
for real—world networks, which often display the small—world
property and contain hubs.

4 CONCLUSION

Graphlet—based network analysis is useful for various tasks in
bioinformatics, such as alignment of PPI networks and predic—
tion of protein functions based on topological similarities. Past
studies used these approaches to, for instance, identify genes
related to cancer (Milenkovic et 0]., 2010b) and aging
(Milenkovic et 0]., 2013).

We presented a new algorithm for counting graphlet orbits
that is based on derived relations between orbit counts. To
count the orbits for k—node graphlets, it enumerates (k— 1)—
node graphlets and a single k—node graphlet. Empirical results
confirm that this decreases the time complexity by an order of
magnitude in comparison with other known methods. In

practical terms, the algorithm counts orbits in large PPI net—
works 5(P100 times faster than other state—of—the—art algorithms.

Funding: Slovenian Research Agency (P2—0209, J2—5480).

Conﬂict of Interest: none declared.

REFERENCES

Betkaoui,B. et al. (2011) A framework for FPGA acceleration of large graph prob—
lems: graphlet counting case study. In: 2011 International Conference on Field—
Programmable Technology. IEEE, pp. 145.

Chatr—Aryamontri,A. et al. (2013) The BioGRID interaction database: 2013 update.
Nucle‘w Acids Res., 41, D81frD823.

Hayes,W. et al. (2013) Graphlet—based measures are suitable for biological network
comparison. Bioinformatics (Oxford, England), 29, 4837491.

Kashmn,N. et al. (2004) Efﬁcient sampling algorithm for estimating subgraph con—
centrations and detecting network motifs. Bioinformatics, 20, 174G1758.

Kloks,T. et al. (2000) Finding and counting small induced subgraphs efﬁciently. Inf.
Process. Lett., 74, 1157121.

Kowaluk,M. et al. (2011) Counting and detecting small subgraphs via equations
and matrix multiplication. In: Proceedings of the Twenty—Second Annual ACM—
SIAM Symposium on Discrete Algorithms. pp. 146871476.

Kuchaiev,O. and Przulj,N. (2011) Integrative network alignment reveals large re—
gions of global network similarity in yeast and human. Bioinformatics (Oxford,
England), 27, 139071396.

Kuchaiev,O. et al. (2010) Topological network alignment uncovers biological func—
tion and phylogeny. J. R. Soc. Interface, 7, 134171354.

Kuchaiev,O. et al. (2011) GraphCrunch 2: software tool for network modeling,
alignment and clustering. BMC Bioinﬁ)rmatics, 12, 24.

Marcus,D. and Shavitt,Y. (2012) RAGE — a rapid graphlet enumerator for large
networks. Compat. Netw., 56, 8104519.

Milenkovic’,T. and Przulj,N. (2008) Uncovering biological network function via
graphlet degree signatures. Cancer Inform., 6, 2577273.

Milenkovic’,T. et al. (2008) GraphCrunch: a tool for large network analyses. BMC
Bioinformatics, 9, 70.

Milenkovic,T. et al. (2010a) Optimal network alignment with graphlet degree vec—
tors. Cancer Inform., 9, 1217137.

 

564

ﬁm'spzumofpmjxo'sopeuuopnoiq/ﬁdnq

Graphlet counting

 

Milenkovic’,T. et al. (2010b) Systems—level cancer gene identiﬁcation from protein
interaction network topology applied to melanogenesis—related functional gen—
omics data. J. R. Soc., 7, 4234137.

Milenkovic’,T. et al. (2011) Dominating biological networks. PLoS One, 6, e23016.

Milenkovic’,T. et al. (2013) Global network alignment in the context of aging. In:
Proceedings of the International Conference on Bioinformatics, Computational
Biology and Biomedical Inﬂ)rmatics. pp. 23732.

Przulj,N. (2007) Biological network comparison using graphlet degree distribution.
Bioinformatics (Oxford, England), 23, e1777e183.

Przulj,N. et al. (2004) Modeling interactome: scale—free or geometric? Bioinformatics
(Oxford, England), 20, 350873515.

Przulj,N. et al. (2006) Efﬁcient estimation of graphlet frequency distributions in
protein—protein interaction networks. Bioinformatics (Oxford, England), 22,
97¢980.

Salwinski,L. et al. (2004) The database of interacting proteins: 2004 update. Nucleic
Acids Res., 32, D4497D451.

Solava,R.W. et al. (2012) Graphlet—based edge clustering reveals pathogen—interact—
ing proteins. Bioinformatics (Oxford, England), 28, i4807i486.

Stoica,A. and Prieur,C. (2009) Structure of neighborhoods in a large social network.
In: 2009 International Conference on Computational Science and Engineering.
IEEE, pp. 2&33.

Wernicke,S. (2006) Efﬁcient detection of network motifs. IEEE/ACM Trans.
Comput. Biol. Bioinform., 3, 3477359.

Wernicke,S. and Rasche,F. (2006) FANMOD: a tool for fast network motif detec—
tion. Bioinformatics (Oxford, England), 22, 115271153.

Whelan,C. and Sonmez,K. (2012) Computing graphlet signatures of network nodes
and motifs in Cytoscape with GraphletCounter. Bioinformatics (Oxford,
England), 28, 29(F29l.

 

565

/310'S[BHmOprOJXO"SOIJBLUJOJIIIOIq/ﬂdnq

