BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

MolBioLib: C++11 framework for rapid development and deployment

 

a line on tabs and constructs to index and traverse a text file.
These, and many other common tasks, are built into MolBioLib,
thus greatly simplifying the code one needs to write. It is hoped
that MolBioLib will allow bioinformaticians to consider C++11
as a possible language of choice. Second, MolBioLib is efficient.
C++11 is used because it is the new standard that intro—
duces constructs for making objects such as Table. C++11 is
efﬁcient since it is a compiled language with no inherent restric—
tion on memory heap size at run time. Templates are used ex—
tensively to compact code, avoid inefﬁcient virtual table lookups
and maintain type safety. Objects and method parameters are
often templated so that they may be in—lined by the compiler.
Third, MolBioLib promotes clarity and compactness by conso—
lidating common operations into a concise set of objects. We also
provide an extensive library of functions that are not intrinsic to
one object, such as those that convert one data type to another,
e.g. splitString converts a string to a vector<string>.

Given the range of problems MolBioLib addresses, the source
code is compact: ~10 000 lines of code and comments for the
core objects and functions. Among the 101 included applications,
86% are coded in fewer than 200 lines and 59% in fewer than
100 lines. In contrast, without such a framework, the user would
have to code the thousands of lines of code to reproduce
MolBioLib’s functionality. Finally, MolBioLib is extensively
tested and facilitates easy testing and debugging of its applica—
tions. Automated tests are provided for all objects and functions.
Additional validation of the code base comes from extensive
application of MolBioLib to many molecular biology projects
(Lau et al., 2009; Sharp et al., 2011; Talkowski et al., 2011;
Zhao et al., 2010; Raif S. Geha, manuscript in preparation).
To simplify use of MolBioLib, all libraries are include ﬁles fol—
lowing the Boost convention (Schaling, 2011). Debugging and
memory checking is thus facilitated with tools such as with
Valgrind (Nethercote and Seward, 2007; Seward and
Nethercote, 2005) since applications in MolBioLib consist of a
main program file with many include ﬁles. Additional input and
programming checks are incorporated into the framework
through optional compiler ﬂags.

2 METHODS

MolBioLib is hierarchically structured for ease of use. It contains three
main components: the library consisting of a set of objects and functions,
the set of applications and the documentation.

// First, read in the ref. fasta file
// into refSequence.
Fasta refSequence( ‘ ‘ref.fasta’ ’);

// The Fasta object makes it easy to apply
// a function to a subset of sequences based
// on, for instance, header text.
// Define a wrapper function that
// reverse—complements a sequence:
void f (Sequence & seq) {

seq. selfReverseComplement () ; }

A script is included to compile all the external packages [such as
BAMTools (Barnett et al., 2011)], applications and optionally build
and run tests. MolBioLib can be used independently of the external pack-
ages and interfaces. The documentation for all of MolBioLib may be
generated automatically using the included Doxygen conﬁguration ﬁle

(van Heesch, 2011). The introductory pages of the Doxygen output
show how to compile and use MolBioLib both as a set of tools as well
as a programming framework. Functions that transform one data type to
another are separated from the objects. Finally, the applications are hier-
archically organized by usage type.

Table<string, string, size_t> myTablel,
myTable2;
Table<string, string, size_t, string,
string, size_t> innerJoinedTable;
readTSVTable (myTablel, ‘ ‘tableData. tsv’ ’ ) ;
string s1, s2; size_t i1;
// Below gets the values from the 5th row.
myTablel.getRow(4, s1, s2, i1);
// Below adds data to myTable2, much like
// the vector push_back operator.
myTable2 .push_back( ‘ ‘ some string 1 ’ ’ ,
‘ ‘string2’ ’ , 5);
// Fill myTable2 similarly. . .
// Bellow inner joins the two tables on the
// first column of both myTable’ s and
// stores the result in innerJoinedTable
innerJoinTables<O, O> (myTablel, myTableZ ,
innerJoinedTable) ;
// Below sorts the innerJoinedTable
// on the 6th column.
sortTable<5> ( innerJoinedTable) ;
writeCSVTable (innerJoinedTable ,
‘ ‘innerJoinedTable.outputFile. csv’ ’ ) ;

Several novel classes power rapid development with MolBioLib. The
primary object that stores data in MolBioLib is Table, which is a con-
tainer class similar to the C++ STL vector class except that each column
may store a different data type, through C++11’s variadic templates.
Variadic templates allow the coding of objects that can accept an arbi-
trary number of template parameters. However, writing variadic tem-
plated objects and functions can become cumbersome (Gregor and
Jarvi, 2008; Kalev, 2008). Therefore, MolBioLib includes the Table
object to represent tabular data, a mainstay of bioinformatics data ex-
change, in an intuitive and easily used fashion. The Table structure was
based on the relational database (Codd, 1970) model, where related data
are stored row-wise. Column data types are speciﬁed through the tem-
plate parameters. A Table may be thought of as a generalized vector.
It includes data row insertion and retrievals operations that are simple to
use. Database-like operations for Table, such as concatenation, ﬁltering
and inner and outer joins, are provided. Example usage of a Table is:

where the readTSVTable is a function to read a TSV ﬁle into a table.
This tabular grouping of data can be used for many bioinformatics tasks.
One example is the Fas ta object, derived from the Table object, which
stores sequences and their headers. The Fas ta object simpliﬁes access to
sequence data:

The primary object to read text ﬁles is ReadOnlyStringFile. The
class automatically creates an index of a ﬁle, if not already present, so the
ﬁle may be accessed as if it were a string array. The index ﬁle is created by
going through the text ﬁle once and noting the starting ﬁle position of
each line in the index ﬁle. The index ﬁle itself has a ﬁxed length per line,
simplifying the process of ﬁnding the index position. Thus, to access a line
in the text ﬁle, the appropriate line in the index ﬁle is looked up.
Subsequently, the line starting at the ﬁle position indicated by the look
up is read in. Almost no memory is required in using the index. A
ReadOnlyStringFile object functions like an array in which each
element is one row of the ﬁle. ReadOnlyTSVFile is a particularly
useful derived class of ReadOnlyStringFile. The values of each
tab-separated ﬁeld of each row can be accessed by the operatorﬂ
method, returning a vector containing the parsed elements of one row.

 

2413

/310‘S{12u1no[p10}xo‘soneuHOJIIrorq/ﬁdnq

T.K.Ohsumi and M.L.Borowsky

 

Applications written with MolBioLib capitalize on the ability of the
ReadOnlyStringFile class to hide all the housekeeping chores
involved in parsing data from delimited text ﬁles.

For example, to sample a random subset of a TSV input ﬁle, one
would code:

If a file only needs to be traversed once, sequentially a line at a time,
ReadOnlyStringFile can traverse the ﬁle without creating an index
ﬁle. This eliminates the time to build and store an index.

The ReadOnlySequencesFile, based on the
ReadOnlyStringFile, is a FASTA/FASTQ reader object. It can
work in a random access mode or sequentially traverse the ﬁle, providing
all the read-only operations of the Fas ta object, thus greatly simplifying
access to sequence read ﬁles.

// Then apply function f to all sequences
// whose header does not have the string
// ‘ ‘chr_Un’ ’ in it (false means not matches) :
refSequence . applyToHeaderRegex(
‘ ‘chr_Un’ ’ , f, false);

Other general objects in MolBioLib include a sparse vector object, e.g.
for use in storing sparse coverage, a map facilitator between keys and
rows in a Table, and a parameterized type interval object with asso-
ciated overlap and set functions. A random number generator class that
includes a permutation vector is also provided. Other bioinformatics ob-
jects included are an alignment object, a Sequence class with operations
such as reverse-complementing, a feature object and a peak object for
storing local extrema of numeric data. All of these classes have been used
to simplify coding of novel bioinformatics analyses.

ReadOnlyTSVFile fileArray( ‘ ‘ input. tsv’ ’ ) ;
size_t numLines = fileArray. size ();
// RandomLib below is part of MolBioLib
// The numbers are seeds .
RandomLib randf (1802, 9373);
for (size_t i=0; i<100; ++i){

size_t randRowNum =

randf .randomSize_t(0, numLines—l) ;
vector<string> tokens =
fileArray [randRowNum] ;

// Process tokens here. . .

}

fileArray.close ( );

Functions included in MolBioLib are diverse, intended to cover four
broad categories: algorithms, ﬁle readers and writers for various data
types, system utilities and transformation of data types to different
data types. Algorithm functions include Table functions, peak detection
and statistics. Table functions include smoothing values, sorting and
upper_bound and lower_bound of Tables analogous to their
vector class counterparts. File reader and writers include those for
various alignment formats, including SAM (Li et al., 2009), Helicos
BioSciences’ TXT format (Helicos, 2010), NCBI tabular BLAST
output (Madden, 2003), feature readers for tabular ﬁles such as for
UCSC’s refGene annotation table (refGene.txt; Kent, 2012), Ensembl’s
Biomart in TSV format (Flicek et al., 2011; Smedley et al., 2009) and the
GFF format (Wellcome, 2012), streams for intervals and vectors, tuple
streams and writers and Table reader and writers. Peak detection func-
tions for numeric arrays will be discussed in more detail in the ChIP-seq
section.

System utilities include a powerful command-line parsing system.
Various command-line argument types are provided, including numeric
and string. Input and output ﬁle name argument types provide ﬁle check-
ing to ensure all input ﬁles are present at run time and to prevent acci-
dental overwrites of output ﬁles. Furthermore, the command-line parser
automatically records the date and time the program was compiled as

well as the command line to simplify documentation of computational
steps and pipelines. System utilities also provide functions to transform
one data type to another, such as string conversions to and from various
data types as well as string splitting (on one or more delimiters).

The compiler of choice for MolBioLib is clang++ version 3.0
and above (Clang, 2012) using the associated libc++ library and is avail-
able on the Linux, Mac OS X and MS Windows platforms. It supports a
large subset of C++11, has very good compiler error messages and
is efﬁcient. MolBioLib also works with GNU g++ 4.7 and above
(Gcc, 2012).

3 RESULTS

One of the primary goals of MolBioLib is to provide a set of
programs that address the most common bioinformatics ana—
lyses. Here we describe applications in MolBioLib that address
four common bioinformatics analyses: annotating a list of fea—
tures, counts of hits to features, coverage and ChIP—Seq. We also
touch upon additional useful utilities included in MolBioLib.

The MolBioLib application addFeaturesToTSVFile per—
forms the very common task of adding gene annotations or more
generically ‘features’, to an input file in which each row describes
a genomic interval. Examples of annotations include the
refGene.txt ﬁle downloadable from UCSC’s genome browser
site (Fujita et al., 2011) that contains the gene ID, name, chromo—
some, strand, and start and stop positions of the transcript.
Other annotation ﬁles include tabular data from the Ensembl/
Biomart website (Flicek et al., 2011; Smedley et al., 2009), where
one can download any set of genes with user—selected attributes
such as IDs, names, positions, expression data and protein
domain. There are numerous other annotation sources, many
of which consist of carefully curated private data, on a topical
website, or in a published supplement to a journal article.
Other common tabular formats include the BED,
PSL and GFF formats (Kent, 2012; Wellcome, 2012). Using
addFeaturesToTSVFile, the genomic footprint of any such
annotation can be intersected with another TSV ﬁle containing
genomic intervals. The application will use the genomic interval
speciﬁed on each row of the input ﬁle and find all intersecting
feature coordinates (with matching strand, if speciﬁed)
and add the appropriate annotation(s) to the row in the
output. Importantly, this application will take in any input
TSV as well as any annotations in TSV form (such as
those noted above) and thus may be used on a wide variety of
projects.

Another common bioinformatics task is to count the number
of alignments mapping to a set of features in a TSV file, such as
refGene.txt, promoter regions or classes of sequence repeats. For
example, we have used this method to quantify the number of
reads derived from genic regions, different classes of genomic
repeats and from different classes of non—coding RNAs (Sharp
et al., 2011). refFeaturesAnalys is offers a number of op—
tions, such as shifting the positions of features (e. g. probing hits
to upstream UTRs instead of the genes), ﬁltering for a speciﬁc
set of reads, maximum error in alignments and RPKM normal—
ization (Mortazavi et al., 2008). The input features are printed
along with the count of alignments overlapping each input fea—
ture and meeting any ﬁltering criteria.

 

2414

ﬁre'spzumol‘pmjxo'sopeuHOJmoiq/ﬁdnq

MolBioLib: C++11 framework for rapid development and deployment

 

Sequence coverage can be used for determining the number of
reads mapped to a base or region and also for finding
polymorphisms. MolBioLib has a unique coverage tool that out—
puts strand—speciﬁc statistics as well as a count of mismatched
bases observed at each position. Coverage can be run on a
user—deﬁned set of regions and normalized to the number of
million reads in the input reads file. Additionally, coverage can
be executed using only the midpoint position to identify where
the reads align. Finally, coverage can be run using uniquely
aligning reads. Programs are provided to post—process coverage
output in various ways, such as multiplying by some constants
(either for the whole file or by contig/chromosome), windowing
the coverage and converting the coverage to a wiggle file.
Coverage output is the input for the ChIP—Seq analysis program
discussed next.

An experimental ChIP—Seq program with a novel wavelet
method is our ﬁnal example of application of the MolBioLib
library. Peak detection is one major next—generation sequencing
application. Given an alignment ﬁle, this algorithm ﬁnds the
coverage on each strand at each location, computed either per
base or in bins spanning a user—deﬁned number of bases. This is
done for both the sample as well as for a background sample or
control, and coverage is smoothed using a kernel smoother. One
challenge of peak detection is finding peaks having a wide range
of widths and heights. We address this by applying a
translation—independent wavelet smoother applied at various
scales, finding local peaks at each scale, and then ranking puta—
tive peaks by using ridge lines that identify peaks detected across
multiple scales (Du et al., 2006). Peaks with a longer ridge length
are more isolated from other peaks, because they show up as
peaks at various length scales. Optional ﬁlters remove low signals
and spikes. This peak detection method is included in
MolBioLib. Other smoothers, such as Gaussian, are also imple—
mented in MolBioLib.

We validated the wavelet peak detector on published
H3K4me3 ChIP—Seq data (Myers et al., 2011). As expected,
H3K4me3 peaks are enriched in promoter regions (Zhao et al.,
2007). The percentage of peaks in promoter regions was 57%
compared to 33% using the window tag density method
(Kharchenko et al., 2008) and 53% using MACS (Zhang et al.,
2008). Peaks were well deﬁned, with a mean width of 232 bp
compared to 2840 bp and 654 bp for the other two methods
tested on the same data.

There are many other applications included with MolBioLib
that address much of the essential bioinformatics analyses done
in next—generation sequencing projects. Some of the more
common tasks include computing statistics on a list of numbers,
creating histogram files from data files (both numeric and string),
converting alignment formats. Additional tasks include common
operations on FASTA and FASTQ files, such as obtaining a
subset, trimming and removing duplicate reads. Moreover,
there are programs to combine, print subsets and inner join
TSV ﬁles. Intersection, subtraction and union operations of
text files are also included.

4 DISCUSSION

MolBioLib ﬁlls the need for an efﬁcient, reliable and compact
C++11 bioinformatics framework. It is portable across many

platforms and aligner formats and is fully documented.
MolBioLib is unique in offering complete analysis programs
for a variety of other very common tasks not addressed by
other toolkits, from feature hit counts to coverage to ChIP—Seq.

MolBioLib classes offer considerable power and convenience
for creating novel analysis applications. A central and very gen—
eral Table class simulating the functionality of a database eases
construction of many programs. The Table class is based on a
collection vectors, thus having a small memory overhead com—
pared to other data structures such as a map. Capacity for larger
datasets is only limited by the amount of available memory.
File readers provide efﬁcient methods to perform ubiquitous
ﬁle I/O tasks. These classes will have general utility for applica—
tion development beyond the specific needs of computational
biology.

As MolBioLib gains adoption, we aim to incorporate many of
the applications both user—contributed and those developed for
our projects into the main distribution through the SourceForge.
net code repository mechanism.

ACKNOWLEDGEMENTS

We would like to thank our current and former collaborators in
the Department of Molecular Biology at MGH, particularly Drs.
M. Blower, R. Kingston, J. Sharp, and C. Woo. We would also
like to thank Drs. J. Gusella and M. Talkowski in the Center for
Human Genetic Research at MGH and Drs. J. Chou and R.
Geha in the Division of Immunology at the Boston Children’s
Hospital for their fruitful collaborations. Finally, many thanks
to the reviewers for their constructive comments that have
strengthened this article and software.

Conﬂict of Interest: none declared.

REFERENCES

Barnett,D.W. et ul. (2011) BamTools: a C++ API and toolkit for analyzing and
managing BAM ﬁles. Bioinformuiicx, 27, 169171692.

Batzoglou,S. et ul. (2002) ARACHNE: a whole—genome shotgun assembler. Genome
Res, 12, 1777189.

Clang. (2012) Clang: a C language family frontend for LLVM. llvm.org.

Codd,E.F. (1970) A relational model of data for large shared data banks. Commun.
ACM, 13, 3777387.

Doring,A. et ul. (2008) Squnian efﬁcient, generic C++ library for sequence
analysis. BMC Bioinfromuiicx, 9, doi:10.l186/1471—2105—9—1 l.

Du,P. et ul. (2006) Improved peak detection in mass spectrum by incorporating
continuous wavelet transform—based pattern matching. Bioinformuiicx, 22,
205972065.

Dutheil,J. and Boussau,B. (2008) Non—homogeneous models of sequence evolution
in the Bio++ suite of libraries and programs. BMC Evol. Biol., 8, 255.

Flicek,P. et ul. (2011) Ensembl 2011. Nucleic Acids Res, 39 (Database issue),
D80(%D806.

Fujita,P.A. et ul. (2011) The UCSC Genome Browser database: update 2011.
Nucleic Aciilx' Re.\'., 39 (Database issue), D8767D882.

Gcc. (2012) GCC, the GNU Compiler Collection. gcc.gnu.org.

Gregor,D. and J arvi,J . (2008) Variadic Templates for C++0x. Special Issue OOPS
Track at SAC 2007, 7, 31751.

Helicos. (2010) H€li.\‘]7/l€r€ User's Guide. Helicos BioSciences Corporation,
Cambridge, Massachusetts.

ISO/IEC. (2011) ISO/IEC l4882:2011. In Programming Language? C++.
International Organization for Standardization, Geneva, Switzerland.

Jaffe,D.B. et ul. (2003) Whole—genome sequence assembly for mammalian genomes:
Arachne 2. Genome Res, 13, 91796.

 

2415

ﬁre'spzumol‘pmjxo'sopeuHOJmorq/ﬁdnq

T.K.Ohsumi and M.L.Borowsky

 

Kalev,D. (2008) C++ Reference GuidelVariadic Templates, Part IlliCritique l
InformIT. http://www.informit.com/guides/content.aspx?g : cplusplus&seq
Num : 399.

Karolchik,D, Hinrichs,AS, Furey,TS, Roskin,KM, Sugnet,CW, Haussler,D and
Kent,WJ (2004) The UCSC Table Browser data retrieval tool. Nucleic Acids
Res., 32, D493$.

Kharchenko,P.V. et al. (2008) Design and analysis of ChIP—seq experiments for
DNA—binding proteins. Nat. Biotechnol, 26, 135171359.

Lau,N.C. et al. (2009) Systematic and single cell analysis of Xenopus Piwi—
interacting RNAs and Xiwi. EMBO J., 28, 294572958.

Li,H. et al. (2009) The sequence alignment/map format and SAMtools.
Bioinformatics, 25, 207872079.

Madden,T. (2003) The BLAST sequence analysis tool. In McEntyre,J. and Ostell,J.
(eds) The NCBI Handbook. National Center for Biotechnology Information,
Bethesda, MD, USA.

Majoros,B. (2012) TIGR++. Available at www.cbcb.umdedu/software/pirate/
tigr++.shtml (last accessed June 12, 2012).

McKenna,A. et al. (2010) The genome analysis toolkit: a MapReduce framework
for analyzing next—generation DNA sequencing data. Genome Res., 20,
129771303.

Mercer,S.J. (2012) Net Bio FAQ. Available at bio.codeplex.com/
wikipage?title=FAQ (last accessed June 12, 2012).

Mortazavi,A. et al. (2008) Mapping and quantifying mammalian transcriptomes by
RNA—Seq. Nat. Methods, 5, 621$28.

Myers,R.M. et al. (2011) A user’s guide to the encyclopedia of DNA elements
(ENCODE). PLoS Biol, 9, e1001046.

Nethercote,N. and Seward,J. (2007) Valgrind: a framework for heavyweight dy—
namic binary instrumenmtion. In ACM SIGPLAN 2007 Conference on
Programming Language Design and Implementation (PLDI 2007). San Diego,
California, pp. 897100.

Oracle. (2011) Javaithe Java application launcher. Vol 2012. http://docs.oracle.—
com/javase/6/docs/technotes/tools/solaris/java.html.

Outercurve. (2012) NET Bio. Outercurve Foundation. Available at bio.codeplex.—
com (last accessed June 12, 2012).

Schaling,B. (2011) The Boost C++ Libraries. XML Press, Laguna Hills, California.

Seward,J. and Nethercote,N. (2005) Using Valgrind to detect undeﬁned value errors
with bit—precision. In UNSENIX '05 Annual Technical Conference, Anaheim,
California, USA.

Sharp,J.A. et al. (2011) Functional analysis of the microtubule—interacting transcrip—
tome. Mol. Biol. Cell, 22, 431241323.

Smedley,D. et al. (2009) BioMartibiological queries made easy. BMC Genom.,
10, 22.

Talkowski,M.E. et al. (2011) Next—generation sequencing strategies enable routine
detection of balanced chromosome rearrangements for clinical diagnostics and
genetic research. Am. J. Hum. Genet., 88, 4694181.

Thornton,K. (2003) libsequence: a C++ class library for evolutionary genetic ana—
lysis. Bioinformatics, 19, 232572327.

Tsirigos,A. et al. (2012) GenomicTools: a computational platform for developing
high—throughput analytics in genomics. Bioinformatics, 28, 2827283.

van Heesch,D. (2011) Doxygen. http://www.stack.nl/~dimitri/doxygen/index.html.

Vatakov,D. (2012) The NCBI C++ Toolkit. Available at www.ncbi.nlm.nih.gov/
IEB/ToolBox/CPP_DOC (last accessed June 12, 2012).

Wellcome. (2012) GFF. In GFF: an Exchange Format for Feature Description.
Wellcome Trust Sanger Institute.

Zhang,Y. et al. (2008) Model—based analysis of ChIP—Seq (MACS). Genome Biol, 9,
R137.

Zhao,J. et al. (2010) Genome—wide identiﬁcation of polycomb—associated RNAs by
RIP—seq. Mol. Cell, 40, 9397953.

Zhao,X.D. et al. (2007) Whole—genome mapping of histone H3 Lys4 and 27 tri—
methylations reveals distinct genomic compartments in human embryonic stem
cells. Cell Stem Cell, 1, 28(r298.

 

2416

ﬁre'spzumol‘pmjxo'sopeuHOJmorq/ﬁdnq

