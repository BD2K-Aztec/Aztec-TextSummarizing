ORIGINAL PAPER

Vol. 28 no. 11 2012, pages 1429—1437
doi:10. 1093/bioinformatics/bts1 75

 

Sequence analysis

Advance Access publication April 6, 2012

GRASS: a generic algorithm for scaffolding next-generation

sequencing assemblies

Alexey A. Gritsenkolaasa‘k, Jurgen F. Nijkamp1’3, Marcel J.T. Reinderslaza3 and

Dick de Ridder1’2’3

1The Delft Bioinformatics Lab, Department of Mediamatics, Delft University of Technology, Mekelweg 4, 2628 CD
Delft, 2Platform Green Synthetic Biology and 3Kluyver Centre for Genomics of Industrial Fermentation, PO. Box

5057, 2600 GA Delft, The Netherlands
Associate Editor: Michael Brudno

 

ABSTRACT

Motivation: The increasing availability of second-generation high-
throughput sequencing (HTS) technologies has sparked a growing
interest in de novo genome sequencing. This in turn has fueled the
need for reliable means of obtaining high-quality draft genomes from
short-read sequencing data. The millions of reads usually involved
in HTS experiments are first assembled into longer fragments called
contigs, which are then scaffolded, i.e. ordered and oriented using
additional information, to produce even longer sequences called
scaffolds. Most existing scaffolders of HTS genome assemblies are
not suited for using information other than paired reads to perform
scaffolding. They use this limited information to construct scaffolds,
often preferring scaffold length over accuracy, when faced with the
tradeoff.

Results: We present GRASS (GeneRic ASsembly Scaffolder)—
a novel algorithm for scaffolding second-generation sequencing
assemblies capable of using diverse information sources. GRASS
offers a mixed-integer programming formulation of the contig
scaffolding problem, which combines contig order, distance
and orientation in a single optimization objective. The resulting
optimization problem is solved using an expectation-maximization
procedure and an unconstrained binary quadratic programming
approximation of the original problem. We compared GRASS with
existing HTS scaffolders using Illumina paired reads of three
bacterial genomes. Our algorithm constructs a comparable number
of scaffolds, but makes fewer errors. This result is further improved
when additional data, in the form of related genome sequences, are
used.

Availability: GRASS source code is freely available from
http://code.google.com/p/tud-scaffolding/.

Contact: a.gritsenko@tudelft.nl

Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on March 27, 2012; revised on March 27, 2012; accepted
on April 2,2012

1 INTRODUCTION

High-throughput sequencing (HTS) technologies, such as Illumina
(Illumina, Inc., San Diego, CA), 454 (Roche Applied Science,
Penzberg, Germany) and SOLiD and IonTorrent (Life Technologies,

 

*To whom correspondence should be addressed.

Carlsbad, CA) produce millions of short DNA reads of typical
lengths of 36—500 bp at low cost, making them attractive for de novo
sequencing applications. With the aid of assembly algorithms (Miller
et (11., 2008; Peng et (11., 2010; Zerbino and Bimey, 2008), short
reads can be joined together into longer sequences called contigs.
However, contigs are typically shorter than the sequenced DNA
molecules, as genomic repeat regions longer than the read length
cannot be unambiguously assembled using the read sequences alone.
Scaffolding, the process of using additional data to place contigs
in the right order, orientation and at the right distance in longer
(gapped) supercontigs called scaﬁ’olds, is a crucial step in obtaining
high-quality draft genome sequences.

Paired reads (mate pair or paired end reads, depending on the
sequencing protocol), i.e. reads of known relative orientation, order
and approximate physical distance, are often used for scaffolding.
Additional information, including reference sequences of related
organisms, restriction maps (Nagarajan et (11., 2008) and RNA-seq
data, can be used to derive more accurate contig placement (Kent
and Haussler, 2001; Pop et (11., 2004), thereby reducing the cost of
ﬁnishing experiments and allowing for more reliable downstream
analyses. However, most existing scaffolding algorithms are not able
to utilize such information for scaffolding. To our knowledge, only
Bambus (Pop et (11., 2004) and SOPRA (Dayarian et (11., 2010) can
make use of additional data sources, although the latter was not
originally designed for this purpose.

Generally, the contig scaﬁ’olding problem (CSP) is ﬁnding a linear
ordering and orientation of contigs that minimizes the number of
unsatisﬁed scaffolding constraints. These constraints are derived
from the available data through translation of the inherent distance,
order and orientation constraints onto the contigs. The derived
constraints can be mutually exclusive, which makes the problem of
minimizing the number of unsatisﬁed constraints NP-hard (Huson
et (11., 2002; Kececioglu and Myers, 1995). Consequently, practical
scaffolding algorithms only approximately solve this problem:
Bambus (Pop et (11., 2004) separately ﬁnds contig orientation and
order and uses greedy heuristics to remove inconsistent constraints;
SSPACE (Boetzer et (11., 2011) greedily extends scaffolds using a
heuristic stopping criterion; and SOPRA (Dayarian et (11., 2010) uses
an iterative procedure to identify a subset of contigs with consistent
scaffolding constraints. Notable exceptions are OPERA (Gao et (11.,
2011) and the MIP Scaffolder (Salmela et (11., 2011), which simplify
the CSP by dropping types of constraints. OPERA implements
an algorithm for ﬁnding an exact CSP solution without minimum

 

© The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com 1429

112 /3.Io's[BumoprOJxosorwuiJOJurorq”:duq urori papeolumoq

91oz ‘Og anﬁnv uo ::

A.A.Gritsenko et al.

 

 

 

|—>  61] = 1
I I
l at, m be '
I I 7'1], 2 0
l Hlj :l: alj I

“l:  bli _. 61, = 0
l I
: bl. m at, :
I I le = 1
I Mlj i Ulj I

Fig. 1. Examples of contig links 11- between contigs all, and 11)]. and their
corresponding relative orientation (elf ). relative order (rlf) and distance (11)]. :l:
(7),.) constraints

contig distance constraints; the MIP Scaffolder (Salmela et (11.,
2011) couples a Mixed-Integer Programming (MIP) formulation of
the CSP that does not enforce order constraints with an algorithm
heuristically dividing the original problem into subproblems to be
solved exactly.

We propose a novel GeneRic ASsembly Scaffolding (GRASS)
algorithm that can be applied to any type of scaffolding information.
Our work is similar to Salmela et (11. (2011), as we propose
a MIP formulation of the scaffolding problem. However, we
combine contig orientation, order and distance in a single quadratic
optimization objective. Similar to Dayarian et (11. (2010), we
employ an iterative procedure to select a consistent subset of
contigs. However, we apply an expectation—maximization strategy
to maximize the objective ﬁinction that identiﬁes inconsistent
constraints rather than contigs, thereby retaining more scaffolding
information.

We implemented the algorithm in C++ and tested it on de
novo assemblies of paired read data for the bacteria Eschrichia
coli, Pseudoxanthomonas suwonensis, and Pseudomonas syringae
and compared it with the SSPACE, OPERA and MIP scaffolders.
GRASS produces a competitive number of scaffolds with fewer
scaffolding errors, particularly when combining various sources of
scaffolding information.

2 METHODS

2.1 Data representation

Scaffolding constraints on contig distance. order and orientation are derived
from the data in a manner depending on the data type. For example.
the known relative orientation. relative order and approximate distance of
paired reads that map to different contigs can be translated into relative
contig orientation. order and approximate contig distance by taking mapping
orientations and positions into account; similarly. physical distance. relative
order and orientation of two contigs mapping to the same reference sequence
can be translated into corresponding constraints. However. different data
types eventually deﬁne the same type of pair-wise contig constraints. which
can be conveniently represented as arcs (i.e. directed edges) 1- = (all. , 12),.) e E
of weight (all. in a digraph G:  deﬁned over the set of contigs V (Gao
et al.. 2011; Huson et al.. 2002; Pop et al.. 2004). The weight can be chosen
to reﬂect information source importance and consistency. A relative order r1]. .
relative orientation elf and approximate distance suggested by the pair-wise
constraints. are then associated with every arc 11-. The approximate distance is
recorded as mean m]. and its SD (71].. This form is a natural choice for capturing

 

 

 

 

I len(a1j) I xblj — walj I len(b1j) I

l at]  blj 
ta, = 1 : : tb, =0

22., Job,

I len(blj) I mat], — wblj I len(a1j) I

l blj  alj 
tb, = 1 : : ta, :0

 1.,

Fig. 2. Optimization variables xalv . x,” . tar and tblv associated with contigs.
l l l 1

Example for elf = 0/\ r1]. = O

variation in contig distances derived from the paired read insert size. It is
also suitable for scaffolding constraints without (reliable) distance estimates.
for example constraints derived from paired RNA-seq data of an organism
with abundant intron splicing. or by mapping contigs to genome of a distant
relative. Such constraints can use a large (7)]. to reﬂect the uncertainty in the
data source. We refer to 11-. its importance weight (all. . and the corresponding
contig pair-wise constraints as a contig link. and to G as the conti g link graph.
For succinct notation. for every contig link constraints are recorded as

0, all, and 11)]. are from different strands
e , = .
ll 1, all, and 11)]. are from the same strand

0, a . follows I). . , . .
r1]. = { [7 ll glven that all. has forward orlentatlon.

1, 1)), follows a).
l 1

This abstract deﬁnition is illustrated in Figure 1. It allows capturing any
combination of contig order. distance and orientation. including constraints
derived from paired end reads. mate pair reads and contig mapping.

2.2 Contig link bundling and erosion

We create a single contig link for every available piece of evidence
(e.g. pair of reads) and by default set its importance weight to one (a
parameter adjustable per information source). For high-coverage HTS data
this procedure creates a large number of links. Contig link bundling is used
to reduce the number of links. and thereby the complexity of the problem.
For every ordered pair of contigs (u,v). arcs (u,v) EE that agree on contig
distance. order and orientation are combined into one or more contig links
as in Huson et al. (2002). The weight of a link after bundling is equal to
the sum of weights of links bundled together to create it. Our deﬁnition of
contig links permits having links that agree on all constraints. yet cannot
be bundled together because they are oppositely directed in G. To enable
bundling of such links. we re-set r1], relative to one of the end points of
11- to make sure that all links connecting a pair of contigs have the same
directionality. Finally. contig links with importance weight smaller than a
pre-deﬁned erosion threshold e are removed from the graph. This assumes
that erroneous links are rare.

2.3 Optimization formulation

We present a mixed-integer quadratic programming (MIQP) formulation
of the CSP. Our formulation is equivalent to the traditional one [minimize
the number of unsatisﬁed constraints. Huson et al. (2002)]. but uses slack
variables as continuous measures of the extent to which each order and
orientation constraint is satisﬁed. This allows for uncertain data. yielding less
trustworthy constraints. to be accurately exploited in the scaffolding process.
A number of optimization variables are associated with every contig and
contig link. We maximize an objective function f of these variables subject
to scaffolding constraints expressed as linear optimization constraints.
The function reaches its maximum value when all distance. order and

 

1430

112 /3.IO'S[1211anprOJXO'SOTJBLUJOJIITOTq”K1111] wort papeolumoq

9103 ‘Og anﬁnv uo ::

GRASS: generic assembly scaffolder

 

_l. a
I—p-
b 7‘

|
I
I l
I I
I I
I I

 

$1, ma

Fig. 3. Contigs a and b are not in the order predicted by mapped paired
reads 1 and r. although the paired reads are in the correct order

orientation constraints are satisﬁed. Each valid collection of the optimization
variable values forms a solution to the optimization problem. These values
are sufﬁcient to puzzle contigs into scaffolds. For every contig ci. i = 1, . . . , n
the following variables are deﬁned. as illustrated in Figure 2.

. t, _ 0, c, comes from the forward strand of the scaffold
’_ 1, c, comes from the reverse strand of the scaffold
is used to deﬁne contig orientation in the scaffold.

0 x, 6 RT corresponds to the 5’ position of c, in the scaffold (when input
contigs and the constructed scaffold are viewed as having a 5’ to 3’
orientation).

Naturally xi should be an integer variable. but it is relaxed to simplify the
optimization problem and is rounded to the nearest integer when the solution
is converted into scaffold nucleotide sequences. Additionally. with every link
lj.j= 1, . . . ,m the following variables are associated:

—> <—
- Slack variables for distance constraints. a]. = {$11. , $11.} 6 R+ >< R+. and

order constraints. A1]. = {A7, A2,} 6 RT >< RT. for forward (talf =0)
and reverse (ta) 2 1) orientations of the contig pair. respectively. By
design these variables reﬂect the degree to which the corresponding
constraints are violated. They are penalized in the optimization
objective f.

' Switch variables for distance constraints. 01). E {0, 1}. and order
constraints. ﬁll. 6 {0,1} (0. constraint is disabled; 1. enabled) used for
disabling contig link constraints with high penalties.

As distance and order constraints are inﬂuenced by the orientation. different
slack variables are required for both orientations. We omit orientation arrows
above slacks S1]. and All. when the contig pair orientation is not important. or
is clear from the context.

Contig links impose scaffolding constraints. which can be modeled as
MIQP optimization constraints. We demonstrate here how such constraints
can be derived from paired read data; the same type of constraints can be
derived in a similar way from other sources of scaffolding information (for
example. see Section 3.2).

Distance constraints are expressed as:

W01, 1 1710-111, |

(7)].

5st,. (1)

where a’(alf,b)f) is the distance between contigs all. and 17)], and S1]. is a
distance slack variable. This inequality captures uncertainty in the distance
by measuring the difference with the mean in SDs. We derive contig distance
a’(alf,blf) from the paired read insert size as the gap size plus the contig
lengths. The calculation then depends on the order and orientation of contigs
connected by 11-. It can be ﬁxed by assuming that the contigs have relative
orientation and order suggested by if. For example. for the case of (elf =
0/\ r1]. :0) shown in Figure 2. the distance expression depends on contig
pair orientation through tall, :

d(ai,.bi,)=Xa,/, —Xb,f +len(ai,)+len(bt,), 1a,]. =0
a'(alf,b)f)=x;,,f —x,,,f +len(a)f)+len(b)f), talf = 1.

Combined with (1) the following constraints are obtained:

A

_,
xalv —x;,,v _ elf). +11). —len(a),)—len(b),)
, , l l l l l
—>
x11. —Xb. Z -UIEi +111 -len(ai)-len(bt)
I] I] l l l l l
1. .
X12). _xa,. S Ui,§t, +le - 1611011,) - 1611071,)
l l

i.
X12). _xa,. Z -UIEi +111 -len(ai)-len(bt)
, , l l l l l

where different slack variables are used for the two contig pair orientations.
The expressions for other combinations of elf and r1]. are derived similarly.

Order constraints are derived from read order constraints (i.e. if cj follows
ci. then they should not overlap and cj must be upstream of ci). which
additionally can be relaxed. The relaxation is necessary because (i) assembled
contigs may overlap (Pop et al.. 2004); (ii) in some cases the order constraints
on data are not valid when extended to contigs. as illustrated in Figure 3.
Translating order constraints into optimization constraints as

IV

_,
xalv —x;,,v —len(b).)- A), talv =0
l l 7 7 l

(3)

1.
1%,], -Xa,f 2 461401041,» 1a,], =1

(formulas shown for elszArlf20) discourages overlaps while still
allowing the order constraint to be violated when All. > 1. These slack
variables are weighed by the length of the downstream contig to allow
measuring them on a single scale. As for the distance optimization
constraints. it is assumed that the relative contig orientation is correct.

Orientation constraints are modeled in the optimization objective
function. which is designed to attain larger values when more orientation
constraints are satisﬁed. The function is given by a polynomial

e .20 e .21
ll ’1

8(1): 2 Qalfblfwlf‘l‘ Z (1_qub,f)wlf»

j:l,...,m j:l,...,m

O, a and b are equally oriented

1, otherwise i

It is equal to the sum of weights of contig links with satisﬁed orientation
and serves as a basis for the optimization objective that is further penalized
proportionally to slack variables.

Slack penalties: the distance and order constraints are added to the
optimization problem through slack variable penalization. The penalty is
proportional to the importance weight of the corresponding contig link and
to the value of the slack variable. To avoid situations when a low-weight
violated constraint results in a large penalty. a maximum penalty of half of
the importance weight is enforced. after which the constraint is considered

where q”), = ta + t}, — 2t,,t;, E {

disabled. Doing this has the additional beneﬁt of equalizing the inﬂuence of
order and distance constraints. To this end we penalize as follows

wt, min(§t,15s)

2 SE (4)

—> <—
where S1]. is chosen as S1]. or $11.. according to the contig pair orientation

and Sg is the maximum slack threshold (after which the slack is disabled).
Because the expression min(§ , Sg) is not suitable for direct use in a MIP. it is
unrolled using the switch variables as [01)]. S1]. +(1 —01)f)S§]. Similar penalties
with variables All. and ﬁll, and maximum slack threshold S A are used for
the order constraints. We set Sg =6 (i.e. six SDs) as in Gao et al. (2011); Li
and Durbin (2009); and S A = 1. as at this value of slack the physical order
constraint is not satisﬁed anymore. Further. only the slacks for the appropriate
contig pair orientation have to be penalized. This is achieved by penalizing

—> <—

(1—ta,,)§)f+ta,,§)f in place of S1]. in (4). This expression ‘chooses’ which
1 l

slack variable to penalize depending on the contig pair orientation. Finally.

the constraints have to be penalized only when they are meaningful (i.e.
the relative contig orientation elf is assumed to be satisﬁed). The resulting

 

1431

112 /3.IO'S[1211,1110prOJXO'SOTJBLUJOJIITOTq”K1111] wort papeolumoq

9103 ‘Og anﬁnv uo ::

A.A.Gritsenko et al.

 

function looks as follows:

:0
el) wt] _) <_
h(t.a.E.Sg)= Z q.,]1,] E [(1 —z..,] >51, +2., 51,] +
j:l,...m

e)]:l

a) . —> <—
+- Z (1 —qq)].b)].  [(1 _ta)]. )Sl) +la)]. Sh] -
1:1,...,m
Expansion of this function leads to a fourth degree polynomial. containing
only terms that consist purely of binary variables. or one continuous and up
to three binary variables. To construct a MIQP formulation. using the big-M
formulation (Nemhauser and Wolsey. 1988). these terms can be replaced
by a single new auxiliary variable each at the expense of introducing new
optimization constraints.
Putting it all together: we maximize

f(leimﬁiéiA)Eg(l)-h(l.€¥.§.5s)-h(tiﬁi4.51).

s.t. constraints (2) and (3) are satisﬁed. Here g(t) is maximized for orientation.
h(t,01,§,S§) is minimized for orientation and distance. and h(t,)3, A,SA) is
minimized for orientation and order. in a single optimization objective. Given
the NP-hard nature of MIPS and the large number of binary variables in
the proposed formulation. this problem becomes intractable even for small
numbers of contigs.

2.4 Problem splitting

We tackle this intractability with an expectation—maximization (EM) like
procedure.
The maximization step assumes the contig orientations are known (i.e. t)

_,
and q”), are ﬁxed). Knowing t) allows us to choose the slack variables (E l]

or El]. and Z)]. or Z)].) depending on the contig pair orientations. and to
select contig links with satisﬁed relative orientation before the optimization
problem is constructed. signiﬁcantly reducing the number of optimization
constraints and the complexity of the optimization problem:

ﬂinch/3f.A)=g-h(a.E.Ss)-h(ﬁiA.SA)

. (1’1) . (5)
g:Zw[]ECOIlSt, h(cx,§,S§)=me(§l]]SE).E

This ﬁxed optimization problem. however. is still NP-hard due to the binary
variables 01)]. and 13)]. involved in expansion of the min terms. We obtain an
approximate solution to this problem by ﬁrst exactly solving its continuous
relaxation. choosing 01)]. and 13)]. according to the slack values in the relaxation
solution and ﬁnally. re-solving the problem with these values ﬁxed. The
relaxation is obtained by replacing h(01,§,S§) by h(§,S§)=1/2S§Zw)]§)]
in (5). This eliminates all binary variables. allowing the use of efﬁcient
optimization algorithms (Dantzig. 1988). The solution for the relaxed
problem gives us optimal values for slacks a]. and A)].. which are used to
choose 01)]. and 13)]. as

a _ 0v Slf>S§ ﬂ _ 0, A[]>SA
’1" 1. $153.5 ’1" 1. A1,:SA’

and allows us to re-solve problem (5). The rationale behind is that. since the
majority of link information is assumed to be correct. large slack values will
be associated with incorrect constraints that have to be disabled. The total
penalty for l]- is memorized (initially set to zero) for use in the expectation
step as
min(§)].,S§) min(A)].,SA)
If a T0”) TM!“
s A

The expectation step is used to obtain the expected contig orientations
t). which maximize the objective function for the previously observed
penalties. Consider the MIQP problem when penalties associated with the
links are known (i.e. A)].. §)].. 01)]. and 13)]. are ﬁxed). and the optimal contig
orientation is sought. In this problem. when a contig link is enabled. its
weight is penalized by the associated slack 8)]. We can. therefore. consider

an equivalent problem where all slacks are zero and link weights are modiﬁed
as (71)]. <—w)]. — 8)]. The problem is then to maximize

e .:0 e .21
ll ’1

mega): Z q.,]1,]au,+ Z (l—q.,]1,]>cai, (6)

j:l,... m j:l,...m

free of any constraints. This is an unconstrained binary quadratic
programming (UBQP) problem (Beasley. 1998). the problem of maximizing
a function c(t) =t’ Ct. where x is a binary vector of length n and C is an n X n
real matrix. Consider a vector of orientations te{0,1}” and a matrix C of
size n. Starting from a zero matrix. C =(cij) can be obtained by updating it
for every link 1- = (a, b) as

9). ~ 9). ,.
can <—(—1) ’w1,+61m. Cbb <—(—1) ’w1,+Cbb

. 1
cat <—(—1)e’7+

- 26711, + Cab -
The functions f(t) and c(t) will then differ by a constant and. therefore.
reach maxima for the same t. Solving a UBQP is known to be an NP-hard.
but well-studied problem with efﬁcient heuristic algorithms available (Merz
and Katayama. 2004; Nesterov. 1997; Pardalos et al.. 2008). Thus. the UBQP
formulation of the problem is preferred over (6) for obtaining values of t).
The EM steps are iterated while contig orientations change. The algorithm
can be viewed as an iterative UBQP approximation of the original MIQP
problem. In practice. it converges to a solution within seven iterations.

2.5 Scaffold extraction and post-processing

Repeat contigs in the contig link graph G are connected by ambiguous links.
hindering a conﬁdent positioning in scaffolds. In a pre-processing step. we
detect such contigs using a modiﬁcation of the A-statistic (Myers et al.. 2000)
proposed by Zerbino (2009). and prevent their incorporation in scaffolds by
removing all links from G incident to them. The connected components of
G correspond to separate subproblems. which are solved independently.

After optimization. each solution tuple (x, t,01, )3) and corresponding
subgraph G’ are converted into one or more scaffolds. First. contig links with
disabled constraints (i.e. 01)]. =0Vﬁ)]. :0) are removed from G’ to minimize
the chance of incorrectly incorporating contigs in the same scaffold. Every
connected component of the resulting G’ is used to construct a single
nucleotide sequence. Contigs are processed in order of their downstream end
coordinates. The left end of the ﬁrst contig is put at the start of the sequence;
every new contig is added to the scaffold such that the gap between two
consecutive contigs is preserved. When consecutive contigs are predicted to
overlap (i.e. have a negative gap size). the new contig is pushed upstream to
eliminate the overlap.

Because resolving contig overlaps in this way potentially leads to
erroneous sequence reconstruction. we also explore an optional post-
processing approach that performs global sequence alignment on consecutive
contigs to ﬁnd the best overlap. Global alignment is performed using a divide-
and-conquer version of the Needleman7Wunsch algorithm (Hirschberg.
1975). Algorithm implementation from the NCBI C++ Toolkit was
used (National Center for Biotechnology Information. 2011). For every
consecutive pair of contigs predicted to have a gap of )1 bp. all gap sizes of at
most 11 = 100 bp away from the predicted value are examined. Negative gap
sizes indicate overlaps. For each gap size g. global alignment of overlapping
contig ends is performed (match score of pmalch22. mismatch penalty of
pmismalch =—3). The best gap size is then chosen based on the alignment
score S and proximity to the predicted gap size )1 by maximizing

L . W

8 ‘Pmatch d .
With the (mis)match scores chosen as above. this expression takes values in
[—1.5; 1]. Due to computational complexity only overlaps of no more than

1500 bp are considered (gap sizes with longer overlaps are assigned a score
of —1). The decision to join two contigs. to leave a gap between them or to

(7)

 

1432

112 /3.Io's1712an0prOJxosoueuiJOJurorq”:duq mot} papeo1umoq

9103 ‘0g15n8nv uo ::

GRASS: generic assembly scaffolder

 

split the scaffold is then made:

0 If none of the considered gap sizes suggest overlaps. the two contigs
are positioned in a scaffold with a gap of )1 bp.

0 If value of expression (7) for the chosen gap size g passes a quality
threshold of 0.8. the contigs are positioned to have an overlap of g
bp. The overlap is replaced with the alignment consensus sequence.
where mismatches are masked with unknown nucleotides.

0 If the chosen gap size does not pass the quality threshold and is shorter
than 50 bp. the two contigs are positioned successively one following
another with no overlap.

Finally. if the chosen gap size suggests a longer overlap. the currently
constructed scaffold is split into two with a new scaffold starting from
a contig that was predicted to lie upstream.

In principle. the proposed post-processing step with scaffold splitting allows
for construction of more accurate scaffolds compared with the naive scaffold
extraction. We refer to the combination of GRASS and post-processing as
GRASS+.

2.6 Evaluation criteria

Similar to assemblies. scaffolds are evaluated based on accuracy and
contiguity. Scaffold accuracy can be assessed by comparing scaffolds to
available reference sequences. We adopted the evaluation criteria from
Dayarian et al. (2010); Gao et al. (2011) and counted the number of scaffold
breakpoints. i.e. consecutive contig pairs in the scaffold that do not agree
with the reference on contig distance. order or orientation. We perform local
alignment of scaffolds to the reference and count the number of breakpoints
within each scaffold. Two consecutive alignments are counted as a breakpoint
if any of these hold: (i) they align to two different chromosomes in the
reference; (ii) their relative orientations in the scaffold and in the reference
do not match; (iii) their relative orders in the scaffold and in the reference do
not match; (iv) the difference in distance in the scaffold and in the reference
is larger than A. We used A = 10 kb and A = 500 bp to asses contig distance
correctness at low and high resolution. respectively.

MUMmer (Delcher et al.. 2002) was used to align scaffolds to references.
Best hits for each position in the scaffold were computed. Only hits with at
least 90 aligned bases (alignment length >< alignment identity). were taken
into account. In practice. very few alignments do not pass this cutoff. The
alignments are also used to calculate the percentage of the scaffold bases and
the reference bases that are aligned (Salmela et al.. 2011). These numbers
capture scaffold accuracy and completeness.

Finally. scaffold completeness and contiguity are captured as in sequence
assembly. calculating total length of all scaffolds. number of scaffolds.
maximum scaffold length and the N50 statistic.

3 IMPLEMENTATION

GRASS source code is available under the GNU GPL v3 license. It was
developed in C++ and tested on Linux. GRASS consists of linker and
scaﬁ‘older modules. The linker takes contigs and the available information
sources as input and produces linking and coverage data. which is then used
by the scaffolder module. It ﬁlters out repeat contigs and uses the remaining
data to produce scaffolds. Scaffolds are output both as lists of contigs with
assigned coordinates and orientations. and as linear FASTA sequences with
gaps.

3.1 Paired read data processing

To obtain contig links from paired read data. the linker module performs
single-end mapping of the reads to contigs. The algorithm used for mapping
depends on the data type: BWA (Li and Durbin. 2009) for Illumina reads.
NovoAlign (http://www.novocraft.com/) for 454 data. The aligners are set to
output all mapping locations. including non-unique hits. as a SAM ﬁle (Li

et al.. 2009). which is then converted to BAM for further processing. This
process is applied to each paired read library.

Read alignments are pre-processed to remove read pairs with low quality
and ambiguous alignments. As a rule. only unique hits with no mismatches
and minimum read length of 30 bp are kept. The ﬁltered alignments are
then scanned for paired reads that align to different contigs. Each such read
pair mapping is used to create a single contig link with distance. order and
orientation constraints derived from the mapping and the given read pairing
method (i.e. paired ends or mate pairs). The BamTools API (Barnett et al..
2011) is used for ﬁltering and processing read alignments.

3.2 Related genome data processing

An available reference sequence. such as the genome of a related organism.
can be used for guiding the scaffolding process. For this purpose. contigs are
aligned to the reference sequence. For every contig. a position in the reference
sequence is obtained from contig tiling constructed from local alignments
using MUMmer. Contig links are then created for every pair of consecutive
contigs aligning to the same reference sequence. with relative orientation
and order derived from the tiling. To capture alignment quality. weights for
links lj=(a)].,b)].) are set to 1",] XI),,] >< Cal] X C),,] X W. where 1",] and 1b,]
are alignment identities. Cal] and C1,] are alignment coverages reported by
MUMmer for the corresponding contigs. and W > O is a weight assigned to
the reference sequences as a scaffolding information source. This procedure
is applied for each available reference sequence to create links. which are
then used together in the optimization.

3.3 Optimization problem solution
The EM procedure proposed for solving the MIQP formulation of the
CSP splits it into a continuous linear programming (LP) problem. and an
UBQP problem. Although more efﬁcient algorithms for solving UBQPs are
available (Nesterov. 1997; Pardalos et al.. 2008). a memetic algorithm from
Merz and Katayama (2004) was chosen for ease of implementation. Usually.
contig link graphs are sparse due to the linear scaffold structure that they
encompass. Memetic algorithms improve individual solutions through local
search. which in turn is well-suited for smooth search landscapes (as in the
case of sparse contig link graphs). Graph sparsity is further exploited by
implementing sparse matrix operations as in Merz and Katayama (2004).
We use the C++ Concert API for the CPLEX Optimizer (IBM ILOG.
2011) to solve LPs. CPLEX is freely available for academic use.

4 RESULTS AND DISCUSSION

4.1 Experimental setup

We have evaluated GRASS on de novo HTS assemblies of three
bacterial genomes: E.coli K12, substr. MG1655; P.suwonensis
11-1; and P.syring(1e B728a. For these organisms, ﬁnished genome
sequences and HTS data from resequencing experiments are
available. Presence of a ﬁnished genome sequence allows for
reliably evaluating the algorithm and comparing it to other
scaffolders in a de novo setup. This is achieved by using the reference
sequence only in scaffold evaluation (thus not as an additional
information source in the scaffolding process). The available test
data is summarized in Table 1. Insert size and coverage were
obtained from paired read mapping using BWA and BEDTools
(Quinlan and Hall, 2010).

Velvet (Zerbino and Bimey, 2008) was used to assemble reads
into contigs. All assemblies had a coverage cutoff of 6 and were
not scaffolded by the assembler. Only contigs longer than 150 bp
were kept. Repeat resolution was disabled (i.e. no expected coverage
was provided). For each organism, the k-mer length was chosen

 

1433

112 /3.Io's1712an0prOJxosoueuiJOJurorq”:duq mot} papeo1umoq

9103 ‘0g15n8nv uo ::

A.A.Gritsenko et al.

 

Table 1. Available datasets NCBI/EBI accession numbers are given for reference sequences and read sets. In all cases reads were produced by the Illumina

sequencing platform.

 

 

 

 

 

E.coli Psuwonensis Rsyringae
Genome size 4.64 Mb 3.42 Mb 6.09 Mb
Reference NC_OOO9 13 .2 CPOO2446.1 NC_007005 .1
Dataset SRR001665 SRR001666 SRRO97515 SRR191848 ERROOS 143
Read count 2><10408 224 2><7047 668 2><23 960004 2X 19 789 425 2X3551 133
Read length 36 bp 36 bp 76 bp 76 bp 36 bp
Coverage 160 X 107 X 709 X 824 X 38 X
Insert size 216:l:10 488:l:18 189:l:17 189:l:17 401:l:33
(a)35_ (Jl’l-.lt.\ -_Hl:ltIJIIl[j[i'::- .' \.' (bLDI ._\1|1- 3.5..Hjl'..|‘1‘.l (c) “11, Ht “HUM. I.
35
9 30' 3 25' m 30-
.E (JI‘E-IIIA IsliIHIIIImIrII - .g _ E
25- -: .- '5
g 5"; geo' :‘u  £25 .\-1'I\'I‘I
E 20 I? E "3 “PM” SN '5‘. E .(:JI_-\.~'H
“c: 3c“ _—. 'b 15' {3‘ i E 20- I'.
E 15- 5°  2 f  2 
510 g)? H_] cml' H:.Ill'n|r|I-r E10 f: ;_ 5‘5”  “pt-1m
J.‘ t' \ l‘ ,W I; ."—' :r.
5' ot:|t.\.‘-2:~' 5 :7 0' E 10
5- c;  . 3
.“R‘WS— 0- °(II‘I'IHH_ '- 5 tst‘;].'.-\.~;H+
D . . . . .
100 150 fur-Inn “.2322”: 250 300 150 Nurﬁggr of scafIUIdEED 300 200 300 NIIrf‘Ilggr of scaﬁlfoolilcs 600 130

Fig. 4. Scaffold accuracy and contiguity tradeoff on the available datasets. Marker size indicates scaffolding running time in minutes. exact numbers are given
in Table S4. GRASS+ using paired reads and two related genomes is shown in (a) as ‘GRASS+ (all)’. (a) E.coli data. Running time ranges in [8 s; 27 min 495].
(b) Rsuwonensis data. Running time ranges in [13 s; 8 min 195]. (c) Rsyringae data. Running time ranges in [1 s; 72 min 22 s]

by performing assemblies for various k and Choosing one based
on assembly contiguity, length, percentage of mapped single reads,
and percentage of properly paired reads (Li and Durbin, 2009)
(Supplementary Tables S1, S2 and S3). For E.coli, P.suwonensis
and P.syring(1e, k = 31, k = 59 and k = 23 were chosen, respectively.
This way of Choosing k reﬂects real-life de novo assembly scenarios,
yielding a realistic algorithm evaluation. Final assemblies are
Characterized in Tables 2—4.

4.2 Comparison to other scaffolders

We compared GRASS with SSPACE, MIP and OPERA scaffolders.
Where required, insert size estimates from Table 1 were used.
Tables 2—4 show evaluation metrics calculated for these scaffolders
and the available test data. Unless stated otherwise, all scaffolders
were run with default parameter settings. BWA was used to map
reads to scaffolds and produces SAM ﬁles required by the MIP
Scaffolder. As in Salmela et (11. (2011), at most two mismatches
were allowed in read mapping. For SSPACE and OPERA, reads
were aligned with Bowtie (Langmead et (11., 2009) using scripts
provided with the scaffolders.

GRASS used an erosion cutoff of 4 (although better results can be
obtained by tuning this parameter) and coverage estimates obtained
from exact mapping of the reads to the assembly contigs. The latter
is available from output of the linker module.

The SSPACE maximum distance parameter was set to 6 SDs
for each paired library. Libraries were input in order of increasing
insert size.

The MIP Scaffolder was also provided with coverage estimates
computed from exact read mapping. Following the original
publication, we tried different ﬁltering parameters ((0,1)) and
chose those which gave the highest N50 value. Settings (36,08),
(70,04) and (5006) were selected for the E.coli, P.suwonensis
and P.syring(1e data, respectively. Maximum partition sizes were
set to 100 for the E.coli scaffolds and 50 for the P.suwonensis
and P.syring(1e scaffolds. Maximum and minimum insert sizes
were chosen by adding and subtracting 6 SDs to the mean
insert size.

OPERA does not allow using multiple read sets. It was applied to
each read library separately, and in the case of P.suwonensis, also to
a join of the available read sets, as they have the same insert size.
The minimum contig length was set to 150 bp, i.e. the contig length
cutoff parameter used in Velvet. We used the default PET parameter
value whenever possible and increased it to the minimum value that
allowed OPERA to ﬁnish without triggering a timeout abort. Cutoff
values 6 and 7 were used for the E.coli dataset; cutoffs 27, 5 and
5 were used for the P. suwonensis dataset; and 11 was used for the
P.syring(1e dataset (values are given in the order of the experiments
in Tables 2—4).

SOPRA was applied to assembly graphs produced by Velvet.
However, when used with parameters chosen in accordance
to the manual provided, SOPRA produced highly fragmented
scaffolds compared with results from Salmela et (11. (2011). To
allow for a fair comparison, its results were not taken into
account.

 

1434

112 /3.Io's1712an0prOJxosoueuiJOJurorq”:duq mot} papeo1umoq

9103 ‘0g15n8nv uo ::

GRASS: generic assembly scaffolder

 

Table 2. Contiguity and accuracy statistics of the initial assembly of E.coli and its scaffolds

 

 

 

Scaffolder Breakpoints Breakpoints Number of N50 Maximum Total Reference Scaffolds
A = 10 kb A 2500 bp scaffolds length (bp) length (bp) covered (%) covered (%)
Velvet contigs 1 1 481 19 872 73 062 4 535 181 97.44 99.79
Velvet scaffolds 9 10 106 171 726 312 219 4 561 490 97.98 99.74
SSPACE 15 16 63 178 023 374 265 4 547 685 97.79 99.70
GRASS 6 6 116 117 964 267 989 4 546 975 97.53 99.55
GRASS+ 2 2 120 112 254 268 030 4 546 640 97.53 99.55
MIP Scaffolder 11 12 148 89 070 221 548 4 546 430 97.54 99.59
OPERA (SRR001665) 36 38 323 32 799 131 842 4 544 447 97.52 99.67
OPERA (SRR001666) 26 28 262 37 330 126 797 4 556 203 97.52 99.42

 

Results with the smallest number of breakpoints or scaffolds are shown in bold.

Table 3. Contiguity and accuracy statistics of the initial assembly of Rsuwonensis and its scaffolds

 

 

Scaffolder Breakpoints Breakpoints Number of N50 Maximum Total Reference Scaffolds
A = 10 kb A 2500 bp scaffolds length (bp) length (bp) covered (%) covered (%)
Velvet contigs 1 1 303 26 043 90 572 3 394 128 99.01 99.90
Velvet scaffolds 4 5 134 57 614 153 169 3 395 148 99.03 99.78
SSPACE 2 2 127 60 526 151 961 3 388 872 99.09 99.99
GRASS 2 2 138 62 908 152 258 3 394 155 99.02 99.91
GRASS+ 1 1 144 53 211 151 938 3 389 098 99.02 99.91
MIP Scaffolder 31 32 138 52 743 115 278 3 390 104 99.03 99.93
OPERA 17 18 184 45 559 186 349 3 413 751 99.01 99.34
OPERA (SRRO97515) 1 1 302 26 053 90 582 3 397 028 99.01 99.81
OPERA (SRR191848) 4 4 225 34 214 90 582 3 397 065 99.02 99.84

 

Results with the smallest number of breakpoints or scaffolds are shown in bold.

As a scaffolder, Velvet was provided with mean insert size and
SD for each library. The data was reassembled with repeat resolution
(expected coverage estimated automatically) and scaffolding turned
on. Its performance was used as a baseline over which all scaffolders
improved on P.syring(1e data and only SSPACE and GRASS
improved on E.coli and P.suwonensis data.

Tables 2—4 contain the results. Note that the minimum number of
breakpoints is one, due to the circular structure of bacterial genome.
Breakpoints at A = 10 kb and A =500 bp differ only slightly,
suggesting that gap lengths are estimated with high precision.
SSPACE produced the longest scaffolds for E. coli. It also produced
the smallest number of scaffolds for E.coli and P.suwonensis.
The longest scaffolds and the smallest number of scaffolds on the
P.syring(1e dataset are achieved by the MIP Scaffolder. Similar
scaffold and reference coverage percentages were achieved by
all scaffolders. However, GRASS+ has the smallest number of
breakpoints for all considered organisms. Additionally, for the case
of P.suwonensis, GRASS constructed the longest scaffolds and
GRASS+ produced breakpoint-free scaffolds while providing a
2-fold reduction in the number of contigs. Scaffolds produced by
the MIP Scaffolder and OPERA are either very fragmented or have
a large number of breakpoints.

When constructing scaffolds, scaffolding algorithms balance
between scaffold contiguity and scaffold accuracy. This tradeoff
is captured in Figure 4 by plotting the number of breakpoints (at
A = 10 kb) against the number of scaffolds. A good scaffolder would
be located in the lower left corner of such a plot. In many cases,
GRASS combines a smaller number of breakpoints with a small
number of scaffolds, compared with other scaffolders. The MIP
Scaffolder and SSPACE can achieve smaller numbers of scaffolds,
but at the cost of (much) larger numbers of breakpoints. Clearly,
GRASS and SSPACE represent two possible choices of scaffolding
algorithms, with GRASS being more accurate with respect to the
number of breakpoints and SSPACE constructing longer scaffolds.
This behavior of the two algorithms is consistent over all datasets.

We also measured scaffolding running times, these are depicted in
Figure 4 using marker size. Exact numbers, as well as read mapping
running times are available in Table S4. Like most scaffolders,
GRASS spends a majority of its time on read alignment, making
running times of different scaffolders comparable and running
time of the core scaffolding part of GRASS on the considered
datasets negligible. Based on simulation results, we do not
expect computation to become a bottleneck for large genomes.
Nevertheless, to reduce computational load it is always possible to

 

112 /3.Io's1712an0prOJxosoueuiJOJurorq”:duq urorJ papeo1umoq

9103 ‘0g15n8nv uo ::

A.A.Gritsenko et al.

 

Table 4. Contiguity and accuracy statistics of the initial assembly of Rsyringae and its scaffolds

 

 

 

Scaffolder Breakpoints Breakpoints Number of N50 Maximum Total Reference Scaffolds
A = 10 kb A 2500 bp scaffolds length (bp) length (bp) covered (%) covered (%)
Velvet contigs 1 1 1560 8599 46 055 5 902 217 96.41 99.78
Velvet scaffolds 25 27 200 122 286 683 615 6 012 535 97.78 99.37
SSPACE 21 26 192 87 996 520 403 5 946 936 96.61 99.09
GRASS 22 25 243 85 493 618 916 5 931 679 96.57 99.38
GRASS+ 6 7 266 77 945 460 726 5 945 096 96.56 99.01
MIP Scaffolder 37 47 167 94 327 279 875 5 943 358 96.58 99.17
OPERA 14 14 705 18 108 76 357 5 950 236 96.58 99.17

 

Results with the smallest number of breakpoints or scaffolds are shown in bold.

Table 5. Contiguity and accuracy statistics of E.coli scaffolds obtained with GRASS+ using additional data

 

 

 

Reads DH10B BW2952 Breakpoints Breakpoints Number of N50 Maximum Total Reference Scaffolds
used used used A = 10 kb A = 500 bp scaffolds length (bp) length (bp) covered (%) covered (%)
Yes No No 2 2 120 112 254 268 030 4 546 640 97.53 99.55
No Yes No 10 66 105 425 724 1 948 314 5 047 825 97.51 89.65
No Yes 4 65 90 843 564 1 099 102 4 773 879 97.52 92.64
Yes Yes 6 7O 81 612 889 1 315 367 4 763 935 97.52 94.80
Yes Yes No 376 4049 727120 a 273 503 % 850 450 % 4 804 124 % 97.52 % 94.99
No Yes 277 5155 67—80 % 497 383 % 1 077 789 % 4 569 001 97.53 % 99.06
Yes Yes 3 4446 71773 % 363 105 % 988 508 % 4 583 534 97.53 % 98.75

 

The ‘m’ sign indicates mean values over 10 repeated runs in cases, when variation was observed. Results with the smallest number of breakpoints or scaffolds are shown in bold.

split the contig graph into graphs of manageable size by increasing
the erosion parameter e.

4.3 Using additional information

To demonstrate the ability of GRASS to utilize various scaffolding
information sources, we used two related genomes (see Fig. 5) to
help scaffold the E.coli assembly: DH10B and BW2952. These
genomes were used individually, together and in combination with
paired reads. When combining several information sources, care has
to be taken in Choosing the weights W, and the erosion threshold
parameter e. In individual genome experiments, W = 100 and e = 80
were chosen to remove links derived from low-quality alignments.
In the experiment using only two related genomes (thus no links
derived from paired read data) a higher weight was given to the more
closely related strain: e=70 and WDHlOB = 80, WBW2952 = 100
were used for the DH10B and BW2952 strains correspondingly. For
experiments combining a single genome with paired reads, W: 10
and e=4 were chosen. Finally, WDHlOB = WBW2952 = 3 and e=5
were used in the experiment combining all data (including the paired
read constraints) to emphasize use of links supported by at least two
information sources. When used in the experiment, paired read link
weights were set to 1. An SD of 3000 bp was used for links derived
from related genomes.

Interestingly, using just related genomes GRASS constructs a
smaller number of scaffolds than when only paired reads are used.
Table 5 shows, however, that this is achieved at the expense
of scaffold accuracy: besides having an increased number of

DH1DB

f/
Y,

MG 1 655

BW2952

Fig. 5. Phylogenetic tree showing evolutionary distance between the E.coli
MG1655 strain and two related strains. Genome sequences were obtained
from GenBank

breakpoints, scaffolds constructed based on related genomes alone
have a high-total assembly length and, as a consequence, a low-
scaffold coverage. The higher than anticipated total assembly length
is due to differences in contig distances (i.e. physical distances
obtained by aligning contigs to a genome sequence) between the
MG1655 strain and the related strains. This is also the reason for
the large differences observed between breakpoints at A: 10 kb
and A=500 bp: while relative order and orientation have been
preserved for large parts of the genomes of the considered strains,
the exact physical distances have not. This situation is partially
alleviated when information from the two genomes is combined,
because (i) consistent links (derived from the two genomes) get
higher weights after link bundling, and (ii) the more closely related
strain BW2952 was given a higher weight. In this case, GRASS is
able to ﬁirther reduce the number of scaffolds without introducing
new breakpoints.

 

1436

112 /3.Io's1712an0prOJxosoueuiJOJurorq”:duq urorJ papeo1umoq

9103 ‘0g15n8nv uo ::

GRASS: generic assembly scaffolder

 

Combining paired read data with information from individual
related genomes allows for construction of a smaller number
of scaffolds with fewer breakpoints than when using these data
individually. The results vary between repeated runs of the
algorithm, due to inconsistencies between linking information
provided by paired reads and related genomes, combined with
the stochastic nature of the optimization strategy used for solving
the MIQP formulation. Depending on the intermediate solutions
found, different contig links are disabled in the optimization process,
leading to different ﬁnal solutions and, thereby to different scaffolds.
Table 5, hence, shows a range of scaffold and breakpoint counts, and
other results as averages over ﬁve repeated runs. This variability is
smaller when all data is combined, since a ‘voting’ approach can
be implemented by setting W and e in such a way that all links
supported by only a single information source have low weights
and are ignored. Using all available information, GRASS reduced
the number of scaffolds by 40% compared with just using paired
reads, at the expense of introducing a single new breakpoint. The
increase in the number of breakpoints is not surprising, as the de
novo scaffolding information is augmented with links derived for
a different (related) organism. The best result on combined data is
shown in Figure 4a.

5 CONCLUSION

We presented GRASS, a generic scaffolding algorithm suitable
for combining multiple information sources, as well as GRASS+,
incorporating a post-processing scaffolding step. Its use was
demonstrated by scaffolding genomes based on paired read data
and information in related genome sequences, both individually
and combined. GRASS achieves the best results when all
available scaffolding information is used, as this allows conﬂicting
information from a single source to be ignored when the majority of
sources do not support it. Such a mode of operation is supported by
the possibility of Choosing weights for the individual information
sources, combined with the contig link erosion threshold.

We compared GRASS with a number of state-of—the-art
scaffolders (SSPACE, MIP and OPERA) on three datasets. GRASS
constructs the most accurate scaffolds on all datasets, while keeping
the number of scaffolds low. Only SSPACE consistently produces
lower numbers of scaffolds, but these are signiﬁcantly less accurate.
The accuracy/contiguity tradeoff displayed by GRASS puts it in a
unique niche compared with existing scaffolders.

The current implementation of GRASS supports the use of paired
read information and related genomes for scaffolding. However, the
algorithm is not limited to any particular set of information sources.
We will extend GRASS to allow use of other sources, such as optical
restriction maps, RNA-seq and EST data.

ACKNOWLEGEMENT

We would like to thank Bas Dutilh for fruitful discussion and
the anonymous reviewers for comments which helped improve the
manuscript.

Funding: Plant Green Synthetic Biology Consortium and Kluyver
Centre for Genomics of Industrial Fermentation, subsidiaries of the
Netherlands Genomics Initiative (NGI).

Conﬂict of Interest: none declared.

REFERENCES

Auch,A.F. et al. (2010) Standard operating procedure for calculating genome-to- genome
distances based on high-scoring segment pairs. Stand. Genomic Sci., 2, 1427148.

Barnett,D.W. etal. (2011) BamTools: a C++ API and toolkit for analyzing and managing
BAM ﬁles. Bioinformatics, 27, 169171692.

Beasley,J.E. (1998) Heuristic algorithms for the unconstrained binary quadratic
programming problem. Technical Report. Management School, Imperial College,
London, UK.

Boetzer,M. et al. (2011) Scaffolding pre-assembled contigs using SSPACE.
Bioinformatics, 27, 5787579.

Dantzig,G.B. (1998) Linear Programming and Extensions. Princeton University Press,
Princeton, NJ, USA.

Dayarian,A. et al. (2010) SOPRA: scaffolding algorithm for paired reads via statistical
optimization. BMC Bioinformatics, 11, 345.

Delcher,A.L. et al. (2002) Fast algorithms for large-scale genome alignment and
comparison. Nucleic Acids Res, 30, 247872483.

Gao,S. et al. (2011) Opera: reconstructing optimal genomic scaffolds with high-
throughput paired-end sequences. J. Comput. Biol., 18, 168171691.

Henz,S.R. et al. (2004) Whole-genome prokaryotic phylogeny. Bioinformatics, 21,
232972335.

Hirschberg,D.S. (1975) A linear space algorithm for computing maximal common
subsequences. Commun. ACM, 18, 3417343.

Huson,D.H. et al. (2002) The greedy path-merging algorithm for contig scaffolding.
J. ACM, 49, 6037615.

Huson,D.H. and Bryant,D. (2006) Application of phylogenetic networks in evolutionary
studies. Mol. Biol. Evol., 23, 2544267.

IBM ILOG (2011) ILOG CPLEX: high-performance software for mathematical
programming and optimization. Available at http://www.ilog.com/products/cplex.
Last accessed date: April 6, 2012.

Kececioglu,J.D. and Myers,E.W. (1995) Combinatorial algorithms for DNA sequence
assembly. Algorithmica, 13, 7751.

Kent,W.J. and Haussler,D. (2001) Assembly of the working draft of the human genome
with GigAssembler. Genome Res, 11, 154171548.

Langmead,B. et al. (2009) Ultrafast and memory-efﬁcient alignment of short DNA
sequences to the human genome. Genome Biol., 10, R25.

Li,H. and Durbin,R. (2009) Fast and accurate short read alignment with Burrows-
Wheeler transform. Bioinformatics, 25, 175471760.

Li,H. et al. (2009) The Sequence Alignment/Map format and SAMtools. Bioinformatics,
25, 207842079.

Merz,P. and Katayama,K. (2004) Memetic algorithms for the unconstrained binary
quadratic programming problem. BioSvstems, 78, 997118.

Miller,J.R. et al. (2008) Aggressive assembly of pyrosequencing reads with mates.
Bioinformatics, 24, 281872824.

Myers,E.W. et al. (2000) A whole-genome assembly of Drosophila. Science, 287,
21964204.

National Center for Biotechnology Information (2011) Biological Sequence Data
Model. In Vakatov,D. (ed.) The NCBI C++ Toolkit Book (Internet). Bethesda, MA,
USA.

Nagarajan,N. et al. (2008) Scaffolding and validation of bacterial genome assemblies
using optical restriction maps. Bioinformatics, 10, 122971235.

Nemhauser,GL. and Wolsey,L.A. (1988) Integer and combinatorial optimization.
Wiley-Interscience, New York, NY, USA.

Nesterov,Y. (1997) Quality of semideﬂnite relaxation for nonconvex quadratic
optimization. CORE Discussion Papers 1997019. Université Catholique de
Louvain, Center for Operations Research (CORE).

Pardalos,P.M. et al. (2008) Global equilibrium search applied to the unconstrained
binary quadratic optimization problem. Optim. Met/i. Softw., 14, 1297140.

Peng,Y. et al. (2010) IDBA 7 a practical iterative de Bruijn graph de novo assembler.
Genome Res., 13, 1497159.

Pop,M. et al. (2004) Hierarchical scaffolding with Bambus. Genome Res., 14, 1497159.

Quinlan,A.R. and Hall,I.M. (2010) BEDTools: a ﬂexible suite of utilities for comparing
genomic features. Bioinformatics, 26, 8417842.

Salmela,L. et al. (2011) Fast scaffolding with small independent mixed integer
programs. Bioinformatics, 27, 325973265.

Zerbino,D.R. and Birney,E. (2008) Velvet: algorithms for de novo short read assembly
using de Bruijn graphs. Genome Res, 18, 8217829.

Zerbino,D.R. (2009) Genome assembly and comparison. PhD Thesis, European
Bioinforrnatics Institute, Cambridge, UK.

 

112 /3.Io's1712an0prOJxosoueuiJOJurorq”:duq urorJ papeo1umoq

9103 ‘0g15n8nv uo ::

