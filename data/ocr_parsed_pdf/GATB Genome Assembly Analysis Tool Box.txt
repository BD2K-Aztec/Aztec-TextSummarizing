APPLICATIONS NOTE V°" 232%.iggillélﬁéﬁaﬁffiﬁiﬁé

 

Genome analysis

Advance Access publication July 1, 2014

GATB: Genome Assembly & Analysis Tool Box
EnNan Drezen‘, Guillaume Rizkl, Rayan Chikhi2, Charles Dellel‘, Claire Lemaitre‘,

Pierre Peterlongo1 and Dominique Lavenier”

llNRlA/lRlSA/GenScale, Campus de Beaulieu, 35042 Rennes Cedex, France and 2Department of Computer Science
and Engineering, Pennsylvania State University, PA 16802, USA

Associate Editor: John Hancock

 

ABSTRACT

Motivation: Efficient and fast next-generation sequencing (NGS) algo-
rithms are essential to analyze the terabytes of data generated by the
NGS machines. A serious bottleneck can be the design of such algo-
rithms, as they require sophisticated data structures and advanced
hardware implementation.

Results: We propose an open-source library dedicated to genome
assembly and analysis to fasten the process of developing efficient
software. The library is based on a recent optimized de-Bruijn graph
implementation allowing complex genomes to be processed on desk-
top computers using fast algorithms with low memory footprints.
Availability and implementation: The GATB library is written in C ++
and is available at the following Web site http://gatb.inria.fr under the
A—GPL license.

Contact: lavenier@irisa.fr

Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on March 25, 2014; revised and accepted on June 20, 2014

1 INTRODUCTION

The analysis of next-generation sequencing (NGS) data remains
a time- and space-consuming task. Many efforts have been made
to provide efficient data structures for indexing the terabytes of
data generated by the fast sequencing machines (Sufﬁx Array,
BurrowseWheeler transform, Bloom filter, etc.). Genome assem-
blers such as Velvet (Zerbino and Birney, 2008), ABySS
(Simpson et al., 2009), SOAPden0V02 (Luo et al., 2012),
SPAdes (Bankevich et al., 2012) or mappers such as BWA (Li
and Durbin, 2009) or variant detection such as CRAC (Philippe
et al., 2013) for instance make an intensive use of these data
structures to keep their memory footprint as low as possible.

At the same time, parallelism has been largely investigated to
reduce execution time. Many strategies such as GPU implemen-
tation (Liu et al., 2012), cloud deployment (Zhao et al., 2013),
algorithm vectorization (Rizk and Lavenier, 2010), multithread-
ing, etc., have demonstrated high potentiality on NGS
processing.

The overall efﬁciency of NGS software depends on a smart
combination of data representation and use of the available pro-
cessing units. Developing such software is thus a real challenge,
as it requires a large spectrum of competence from high-level

 

*To whom correspondence should be addressed.

data structure and algorithm concepts to tiny details of
implementation.

The GATB library aims to ease the design of NGS algorithms.
It offers a panel of high-level optimized building blocks to
speedup the development of NGS tools related to genome as-
sembly and/0r genome analysis. The underlying data structure is
a memory efﬁcient de-Bruijn graph (Compeau et al., 2011), and
the general parallelism model is multithreading. The GATB
library targets standard computing resources such as current
multicore processor (laptop computer, small server) with a few
gigabytes of memory.

Hence, from the high-level C+-l- functions available in the
GATB library, NGS programing designers can rapidly elaborate
their own software based on state-of-the-art algorithms and data
structures of the domain.

Based on the same idea, other bioinformatics libraries exist,
from which domain-speciﬁc tools can be elaborated. The
NGS-l- -l- library (Markovits et al., 2013) is speciﬁcally tailored
for developing applications that work with genomic regions and
features, such as epigenomics marks, gene features and data that
are associated with BED type ﬁles. The Squn library (Doring
et al., 2008) is a general-purpose library targeting standard se-
quence processing. Advanced data structures such as de-Bruijn
graphs are not included in Squn. Khmer (Crusoe et al., 2014) is
a library and toolkit for doing k-mer-based NGS dataset ana-
lysis. As with GATB, most of khmer relies on an underlying
probabilistic data structure (Bloom ﬁlter). The khmer library
can be used in various k-mer processing such as abundance
ﬁltering, error trimming, graph size filtering or partitioning.

2 METHODS

One of the main concerns of the GATB-core library is to provide com-
puting modules able to run on standard machines, i.e. computers not
requiring large amount of main memory.

The central data structure is a de-Bruijn graph from which numerous
actions can be performed as shown Figure 1: data error correction, as-
sembly, biological motif detection [e.g. single nucleotide polymorphism
(SNP)], etc. The graph is constructed by extracting and by counting all
the different k-mers from one or several sequencing datasets. This time-
and space-consuming task is conducted by a disk streaming algorithm,
DSK (Rizk et al., 2013), which adapts its memory requirement according
to the available computer memory. Trade-off between execution time and
memory occupancy can be set up: the larger the computer memory,
shorter the computation time (reduced disk access).

The de-Bruijn graph memory footprint is kept low thanks to an opti-
mized Bloom ﬁlter representation (Chikhi and Rish, 2012; Salikhov et al.,
2014). Only vertices of the de-Bruijn graph are memorized. Edges are

 

© The Author 2014. Published by Oxford University Press.

This is an Open Access article distributed under the terms of the Creative Commons Attribution Non—Commercial License (http://creativecommons.org/licenses/
by—nc/3.0/), which permits non—commercial re—use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial

re—use, please contact journals.permissions@oup.com

112 /310's112u1n0fp10}x0"sotwuiJOJutotq/ﬁduq uIOJJ papeolumoq

9103 ‘Og anﬁnV uo ::

E.Drezen et al.

 

 

Fig. 1. Schematic View of the GATB organization

deduced by querying the Bloom ﬁlter. False positives (owing to the prob-
abilistic behavior of the Bloom ﬁlter) are suppressed by adding an extra
data structure enumerating critical vertices. This efﬁcient de-Bruijn graph
representation ﬁts, for example, a complete mammal genome in ~4 GB.

3 IMPLEMENTATION

The GATB library is composed of five main packages: system,
tools, bank, kmer and de—Bruijn packages.

The system package holds all the operations related to the
operating system (OS): ﬁle management, memory management
and thread management. Using such an abstraction allows client
code to be independent from the OS, thus suppressing compil-
ation directive inside the code or improving some OS accesses
by hiding speciﬁc OS optimization. The supported operating
systems are Linux, Mac and Windows.

The tools package offers generic operations used throughout
the user application but not speciﬁc to genomics area. For ex-
ample, this package includes design pattern tools (such as itera-
tors, observers, smart pointers, etc.) and object collections (such
as containers, bags, iterables, etc.). It also optimizes the way
GATB data structures are saved. The HDFS ﬁle format is cur-
rently used (HDFS, 2012). This powerful technology is extremely
well suited for large and complex data collection such as those
handled in the GATB library.

The bank package provides operations related to standard
genomic sequence dataset management. All the main sequence
ﬁle formats are supported, and high-level interfaces allow
sequences to be easily iterated regardless of the input format.
In other words, algorithms are written independently of the
input formats.

The kmer package is dedicated to fine-grained manipulation of
k-mers. Optimized routines are provided to perform k-mer
counting from large sequence datasets, to find k-mer neighbor-
hood or to select k-mers based on different criteria.

Finally, the de-Bruijn package provides high-level functions to
manipulate a static de-Bruijn graph data structure: creation from
a set of k-mers, iteration through different nature of nodes
(simple k-mers, branching k-mers, etc.), extraction of neighbor
nodes, etc. Additional information (e. g. k-mer coverage, markers
of Visited nodes) is stored in the graph branching nodes. From

this abstraction level, developing new tools based on de—Buijn
graphs is fast, and does not require programmers to delve into
low-level details.

The GATB library takes beneﬁt of the parallel nature of
today’s multicore architecture of microprocessors. When pos-
sible, time-consuming parts of the code are multithreaded to
provide fast runtime execution.

The GATB library is developed in C+-l- under the A-GPL
license and is available from the following Web site: http://gatb.
inria.fr. An extensive documentation with tutorials is available to
guide designers in the process of developing new NGS tools from
the GATB building blocks: http://gatb-core.gforge.inria.fr (see
also Supplementary File 2 for technical implementation details).

4 RESULTS

To demonstrate the efﬁciency of the GATB library, a few soft-
ware implemented from GATB are brieﬂy presented. The idea is
to give a quick overview of the application spectrum of the
GATB library and some performance numbers.

lVﬁnia (Chikhi and Rish, 2012) is a short-read de—Bruijn as-
sembler capable of assembling large and complex genomes into
contigs on a desktop computer. The assembler produces contigs
of similar length and accuracy to other de-Bruijn assemblersv
e.g. Velvet (Zerbino and Birney, 2008). As an example, a Boa
constrictor constrictor (1.6 Gb) dataset (Illumina 2 x 120 bp
reads, 125 x coverage) from Assemblathon 2 (Bradnam et al.,
2013) can be processed in ~45h and 3GB of memory on a
standard computer (3.4GHz 8-core processor) using a single
core, yielding a contig N50 of 3.6 kb (prior to scaffolding and
gap-ﬁlling).

Bloocoo is a k-mer spectrum-based read error corrector, de-
signed to correct large datasets with low memory footprints.
It uses the disk streaming k-mer counting algorithm contained
in the GATB library and inserts solid k-mers in a Bloom filter.
The correction procedure is similar to the Musket multistage
approach (Liu et al., 2013). Bloocoo yields similar results while
requiring far less memory: for example, it can correct whole
human genome re-sequencing reads at 70x coverage with
<4 GB of memory (see Supplementary ﬁle 1 for extra informa-
tion on Bloocoo).

DiscoSNP aims to discover Single Nucleotide Polymorphism
from non-assembled reads and without a reference genome.
From one or several datasets a global de-Bruijn graph is con-
structed, then scanned to locate speciﬁc SNP graph patterns
(Uricaru et al., 2014). A coverage analysis on these particular
locations can finally be performed to validate and assign scores
to detected biological elements. Applied on a mouse dataset
(2.88 Gb, 100 bp Illumina reads), DiscoSnp takes 34h and re-
quires 4.5 GB RAM. In the same spirit, the TakeABreak soft-
ware discovers inversion variants from non-assembled reads. It
directly ﬁnds particular patterns in the de-Bruijn graph and pro-
vides execution performances similar to DiscoSNP (Lemaitre
et al., 2014).

Funding: ANR (French National Research Agency) (ANR-12-
EMMA- 0019-01).

Conﬂict of interest: none declared.

 

2960

112 /310's112u1n0fp10}x0"sotwuiJOJutotq/ﬁduq uIOJJ papeolumoq

9103 ‘Og isnﬁnV uo ::

GATB: Genome Assembly & Analysis Tool Box

 

REFERENCES

Bankevich,A. et a]. (2012) SPAdes: a new genome assembly algorithm and its
applications to single—cell sequencing. J. Comput. Biol, 19, 4554177.

Bradnam,K.R. et a]. (2013) Assemblathon 2: evaluating de novo methods of
genome assembly in three vertebrate species. Gigascience, 2, 10.

Chikhi,R. and Risk,G. (2012) Space—efﬁcient and exact de—Bruijn graph represen—
tation based on a Bloom ﬁlter. Algorithms Bioinform., 8, 2367248.

Compeau,P. et a]. (2011) How to apply de Bruijn graphs to genome assembly. Nat.
Biotechnol, 29, 9877991.

Doring,A. et a]. (2008) Squn:an efﬁcient generic C ++ loibrary for sequence ana—
lysis. BMC Bioinformatics, 9, 11.

HDF5 group help desk. (2012) File format speciﬁcation v2.0. http://www.hdfgroup.
org/HDF5/doc/HS.format.html.

Crusoe,M.R. et a]. (2014) The khmer software package: enabling efﬁcient sequence
analysis. [Epub ahead of print, doi: 10.6084/m9.ﬁgshare.979190].

Lemaitre,C. et a]. (2014) Mapping—free and assembly—free discovery of inversion
breakpoints from raw NGS reads. In: First International Conference on
Algorithms for Computational Biology (AlCoB 2014). Tarragona, Spain.

Li,H. and Durbin,R. (2009) Fast and accurate short read alignment with Burrows—
Wheeler Transform. Bioinformatics, 25, 17544760.

Liu,Y. et a]. (2013) Musket: a multistage k—mer spectrum—based error corrector for
Illumina sequence data. Bioinformatics, 29, 3087315.

Liu,Y. et a]. (2012) CUSHAW: a CUDA compatible short read aligner to large
genomes based on the Burrows7Wheeler transform. Bioinformatics, 28,
183G1837.

Luo,R. et a]. (2012) SOAPdenovoZ: an empirically improved memory—efﬁcient
short—read de novo assembler. Gigascience, l, 18.

Markovits,A. et a]. (2013) NGS -l- +: a library for rapid prototyping of epigenomics
software tools. Bioinformatics, 29, 189371894.

Philippe,N. et a]. (2013) CRAC: an integrated approach to the analysis of RNA—seq
reads. Genome Biol, 14, R30.

Rizk,G. and Lavenier,D. (2010) GASSST: global alignment short sequence search
tool. Bioinformatics, 26, 2534w2540.

Rizk,G. et a]. (2013) DSK: k—mer counting with very low memory usage.
Bioinformatics, 29, 652$53.

Salikhov,K. et a]. (2014) Using cascading bloom ﬁlters to improve the memory
usage for de—Bruijn graph. Algorithms M0] Biol, 9, 2.

Simpson,J.T. et a]. (2009) ABySS: a parallel assembler for short read sequence data.
Genome Res., 19, 111771123.

Uricaru,R. et a]. (2014) Reference—rec detection of genotypable SNPs, in revision to
NAR[Epub ahead of print].

Zhao,S. et a]. (2013) Rainbow: a tool for large—scale whole—genome sequencing data
analysis using cloud computing. BMC Genomics, 14, 425.

Zerbino,D.R. and Bimey,E. (2008) Velvet: algorithms for de novo short read as—
sembly using de—Bruijn graphs. Genome Res., 18, 8217829.

 

2961

112 /310's112u1n0fp10}x0"soiJBuiJOJuioiq/ﬁduq 1,110.1} papeolumoq

9103 ‘Og isnﬁnV uo ::

