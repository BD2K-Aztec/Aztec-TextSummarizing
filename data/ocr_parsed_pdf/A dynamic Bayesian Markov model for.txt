ORIGINAL PAPER

Vol. 29 no. 7 2013, pages 878-885
doi:10. 1 093/bioinformatics/btt065

 

Genetics and population analysis

Advance Access publication February 13, 2018

A dynamic Bayesian Markov model for phasing and characterizing
haplotypes in next-generation sequencing

Yu Zhang

Department of Statistics, The Pennsylvania State University, 325 Thomas, University Park, PA 16802, USA

Associate Editor: Jeffrey Barrett

 

ABSTRACT

Motivation: Next-generation sequencing (NGS) technologies have
enabled whole-genome discovery and analysis of genetic variants in
many species of interest. Individuals are often sequenced at low
coverage for detecting novel variants, phasing haplotypes and infer-
ring population structures. Although several tools have been de-
veloped for SNP and genotype calling in NGS data, haplotype
phasing is often done separately on the called genotypes.

Results: We propose a dynamic Bayesian Markov model (DBM) for
simultaneous genotype calling and haplotype phasing in low-coverage
NGS data of unrelated individuals. Our method is fully probabilistic
that produces consistent inference of genotypes, haplotypes and re-
combination probabilities. Using data from the 1000 Genomes Project,
we demonstrate that DBM not only yields more accurate results than
some popular methods, but also provides novel characterization of
haplotype structures at the individual level for visualization, interpret-
ation and comparison in downstream analysis. DBM is a powerful and
flexible tool that can be applied to many sequencing studies. Its stat-
istical framework can also be extended to accommodate broader
scopes of data.

Availability and implementation: http://stat.psu.edu/~yuzhang/soft
ware/dbm.tar

Contact: yuzhang@stat.psu.edu

Supplementary information: Supplementary data are available at
Bioinformatics online.

Received on September 25, 2012; revised on February 1, 2013;
accepted on February 5, 2013

1 INTRODUCTION

Haplotype phasing is a long-standing problem in population
genetics. The task is to computationally infer the combination
of alleles (haplotype) at multiple single nucleotide polymorph-
isms (SNPs) on a single copy of chromosome, while the data are
collected in genotype format (combination of alleles per SNP on
two copies of chromosomes) from diploid genomes. Haplotype
phasing is important because haplotypes provide rich informa-
tion about the evolution history of individuals. Haplotype phas-
ing is challenging because its complexity grows exponentially
with respect to the number of SNPs. Although SNP arrays
have been routinely used to collect genotype data from individ-
uals, they only quantify genetic variants at known SNPs. Next-
generation sequencing (NGS), on the other hand, has the ability
to detect all genetic variants in individuals’ genomes. Sequencing
machine reads out genomes as short DNA fragments called

‘reads’. After aligning the reads to a reference genome or by de
novo assembly, putative SNPs are called if reads aligned at the
same position carry alternative alleles. Genotypes are further
called at the putative SNPs by comparing the read counts of
alternative alleles. For haplotype phasing, SNPs are sorted by
their positions so that information of linkage disequilibrium
(LD) can be used. In this study, we will focus on NGS data,
because genotype data is just a special case.

Many haplotype-phasing algorithms have been developed over
the past decade (Browning and Browning, 2007; Howie et al.,
2009; Li and Stephens, 2003; Li et al., 2009; Scheet and
Stephens, 2006; Williams et al., 2012). Recent methods all use
pairs of Markov chains per diploid individual to model LD
among SNPs. The states in Markov chains correspond to haplo-
types, and the transitions of states indicate recombination events.
Most methods, however, are designed for genotype data only.
Although NGS data can be converted to genotypes before haplo-
type phasing, such approach will produce poor results in low
coverage sequencing studies. Some methods (Howie et al., 2009;
Williams et al., 2012) also require genetic maps, which are unavail-
able in many studies. We identiﬁed three methods that can phase
haplotypes in NGS data: THUNDER (Li et al., 2011), PPHS
(Efros and Halperin, 2012) and HapSeq (Zhi et al., 2012).
THUNDER is a wrapper of MaCH (Li et al., 2009), where the
latter works on genotype data and is among the most accurate
methods in haplotype phasing (Browning and Browning, 2011).
We therefore used THUNDER as a benchmark in this study.
PPHS uses perfect phylogeny to infer haplotypes. It, however, is
designed for data in short regions without recombination, and
relies on other methods to assemble short haplotypes into longer
ones. We therefore did not include PPHS in this study. HapSeq is
modiﬁed from THUNDER that improves on haplotype phasing if
a read carries multiple alleles. We did not compare HapSeq, as it
addresses a different problem. We included BEAGLE (Browning
and Browning, 2007) as a second benchmark method. BEAGLE
runs faster than THUNDER but performs as accurate (Browning
and Browning, 2011). Although BEAGLE does not directly work
on NGS data, it takes genotype likelihoods as input, which can be
generated from read counts.

We introduce a Dynamic Bayesian Markov model (DBM) for
phasing and characterizing haplotypes in NGS data of unrelated
individuals. Three main reasons motivated this work. First, we
want to design a coherent probabilistic model for haplotype
phasing, such that inference consistency is theoretically justiﬁ-
able. Some existing methods (Howie et al., 2009; Li and
Stephens, 2003; Li et al., 2009; Scheet and Stephens, 2006)

 

878 © The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e—mail: journals.permissions@oup.com

112 /310's112u1n0fp10}x0"sotJBuiJOJutotq/ﬁduq 11101} pQPBOIIIAAOG

91oz ‘Og anﬁnV uo ::

Phasing and characterizing haplotypes in NGS

 

use iterative conditional probabilities to infer haplotypes, for one
individual at a time with the remaining individuals serving as
donors. Such models do not have joint distributions correspond-
ing to the conditionals used in iteration, and thus their results
may not be consistent. Second, we want to develop a concise, but
sufﬁcient, representation of haplotypes for intuitive interpret-
ation, Visualization and comparison in downstream analysis.
Existing methods only output strings of alleles as haplotypes,
which neither reﬂect SNP dependencies nor suggest haplotype
relationships among individuals. In many studies, haplotypes are
not of direct interest. They are instead used as input in down-
stream studies such as association mapping and population in-
ference. HaploView (Barrett et al., 2005) is one example of
haplotype characterization, which shows haplotype block struc-
tures and SNP correlation. HaploView, however, does not char-
acterize haplotypes at the individual level. Our third motivation
is to provide users with a ﬂexible tool for NGS data analysis,
which can be applied to any species of interest with minimum
input from the users.

A schematic View of our approach is shown in Figure 1. The
observed read counts (Fig. 1a) do not carry haplotype informa-
tion across SNPs. DBM takes read counts as input and infers
haplotypes Via three key components (Fig. 1b): an inﬁnite-state
hidden Markov model (HMM) modelling templates of haplo-
types, with two Markov chains ﬁtted to each individual; an emis-
sion probability of alleles from the state at each SNP; and an
observation probability connecting alleles to the observed read
counts. DBM is an example of non-parametric Bayes model
(Dunson and Xing, 2009) equipped with Markov structures,
and is also a variant of infinite-state HMM (Beal et al., 2002).
We use Markov Chain Monte Carlo GVICMC) algorithms to
estimate posterior distributions of model parameters of interest.
Particularly, DBM outputs genotypes, haplotypes and recombin-
ation probabilities between SNPs. In addition, DBM produces
segmentations of haplotypes at the individual level as mosaic
combinations of states (Fig. lc). Haplotypes within the same
states are similar across SNPs, but not necessarily identical due

(3;) Input Read Counts (c) Inferred Haplotypes & Segmentation

 

Individuals
1 2 3 4 5
Individuals
1 2 3 4 5

   

 

 

 

 

   

SNPs ' SNPs

\ DBM Model

A
U'
v

HMM s“
Haplotype Zi,1
Read Counts Di
HaplotypeTZig
HMM SL2

 

Fig. 1. Schematic View of DBM. (21) Input read counts of ﬁve individuals
at 40 SNPs (grey scale of dots is proportional to the estimated mean
number of minor alleles per SNP). (b) Each individual is ﬁtted by two
HMMs; alleles are generated independently by states; and read counts are
generated by alleles (notations are deﬁned in Section 2). (c) DBM inferred
alleles (dots) and segmentation of haplotypes

to random mutations. The state information produced by DBM
can be directly Visualized to evaluate the relationships of haplo-
types among individuals at the SNP resolution. Haplotype
blocks and recombination hotspots can also be easily identiﬁed.

A challenging problem in HMM is to determine the number of
states. Although too many states may reduce inference efﬁciency
and over ﬁt the data, too few states may not be sufﬁcient to
capture all the information in the data and thus loose power.
In DBM, we allow the number of states to vary across SNPs.
DBM uses a non-parametric Bayesian process to dynamically
infer the number of states across SNPs. It has great ﬂexibility
to ﬁt regions with either simple or complex structures.
Simultaneously, DBM avoids over fitting the data Via Bayesian
regularization.

2 METHODS

2.1 Input data

DBM requires input of read counts of two alleles per putative SNP per
individual. The SNPs should be ordered by their positions. DBM can also
work for partially ordered (e.g. when reads are aligned to contigs) or
unordered SNPs, but the accuracy of genotype calling and haplotype
phasing will be affected due to loss of LD information (Nielsen et al.,
2011). Although DBM only considers biallelic SNPs, multi-allelic SNPs
can always be converted to pseudo biallelic SNPs.

2.2 A dynamic Bayesian Markov model

Suppose that the NGS data (denoted by D) are collected from N indi-
viduals with L putative SNPs. For notation consistency, we use capital
letters to denote an entire quantity and lower case letters to denote indi-
vidual values. For example,  denotes a pair of read counts observed
from individual i at SNP j, and D = {dif} denotes all data for i: 1, . . . ,N
andj=1,...,L.

For diploid genomes, we ﬁt two HMMs per individual to model haplo-
type structures, where each HMM corresponds to one haplotype. Let
S: {Silk} denote the collection of HMMs, for i: 1,. . . ,N and k: 1,2,
with Silk=(s,-1yk,. .., silk) denoting the states in one HMM across L
SNPs, and .s,/Vk=1,2,...taking positive integer values. In our model,
states represent haplotype templates, and we allow inﬁnite number of
templates to be ﬁtted to the data. For example, let
Silk=(1,1,1,3,3,2,2,2) denote the states of eight consecutive SNPs. It
means that the corresponding haplotype is a concatenation of alleles
from three templates: SNPs 173 carry alleles from template 1, SNPs
4eS carry alleles from template 3 and SNPs $8 carry alleles from
template 2. We assume that each state has its own allele distribution
per SNP, and the alleles are independently generated from the states at
each SNP.

To infer the state-speciﬁc allele distributions, we introduce an auxiliary
variable Z: {Zirk}= {(ziLk, . . . ,ziLyk)}, for i: 1,. . . ,N and k=1,2, with
2,731,: 0 or 1 indicating the presence of a ‘minor’ allele in the k-th haplo-
type of individual i at SNP j. Z represents the actual haplotypes in the
sample. For instance, let Ziyk= (0,0,1,1,0,1,0,1) at eight SNPs. Combined
with Silk=(1,1,1,3,3,2,2,2), we may infer that template 1 emits alleles
0,0,1 at SNPs 173, respectively, template 3 emits alleles 1,0 at SNPs 4e
5, respectively, and template 2 emits alleles 1,0,1 at SNPs $8, respect-
ively. Given S and Z, we will not only learn the genotypes and the haplo-
types in the sample, but also we can infer the state distributions and the
state-speciﬁc allele distributions. We infer S and Z from the data using
the following probabilistic model

 

879

112 /310's112u1n0fp10}x0"sotJBuiJOJutotq/ﬁduq 11101} papBOIII/lAOG

91oz ‘Og isnﬁnv uo ::

Y.Zhang

 

Pr(D, z, S) = Pr(DlZ)Pr(Z|S)Pr(S) =
  Pr(d’jlz’jvl’z’jvzﬂ X   H::1 Pr(Z’i'kaSV’kﬂ' (1)
X  H::1 Pr(silk)  “(SM |Si<H>,1c)j

Formula (1) has three components (Fig. 1b): the HMM Pr(S) of haplo-
type structures; the conditionally independent emission probability
Pr(Z|S) of alleles given states; and the observation probability of read
counts given alleles Pr(DlZ).

The observation probability Pr(DlZ) is a product of Pr(diflziﬂziﬂ),
where (2,7,1,z,-,~,2) denote the two alleles at SNP j in individual i. Let
dij = (A,-,~,a,-,~) denote the read counts of the two alleles at SNP j in individ-
ual i. Let a (default 0.01) denote the sequencing error rate. Let 11, (default
0.999) denote the probability that a putative SNPj is a true SNP, which
can be calculated from its SNP quality score. Let e/=Hun(2,A,/,Z,a,/)/
Z,(A,-,~+ (1,) denote the conditional probability of observing a wrong allele
given that SNP j is a false-positive SNP. We write

Pr(dijlzij, 1, Zij, 2) = Pr(Aijaailerj,1aer,2)
q,(1 — £)A’78“” + (1 — q,)(1 — ej)AileJI-l”, if 2,11 + 2,2 = 0
OC 0.5A’7Jra’7, leijq +Z,'j,2 = 1 .

qJEA’l'U - 8)“ + (1 - qj)eJ/'4if(1 - 61')”, if 217,1 + 217,2 = 2

(2)

For homozygotes (2,7, 1+z,-,~,2=0 or 2), formula (2) is a mixture model
with two components corresponding to whether or not SNP j is a true
SNP. For heterozygotes (2,7,1 +2932: 1), SNP j is a true SNP and thus
only has one component. The normalizing constants are not used in the
model-ﬁtting process and are ignored. More details of formula (2) can be
found in Supplementary Material.

The emission probability Pr(Z|S) is modelled as a product of inde-
pendent Bernoulli distributions conditioning on states. Each term
Pr(ziﬂklsiﬂk) in formula (1) is a Bernoulli probability with state-speciﬁc
‘minor’ allele frequency {pow} in state s at each SNP j. Without knowing
{pwj}, we assign a Dirichlet prior Dir(8,8) and integrate {pow} out, where
8 denotes a small constant (default max{0.1,10/(AN)}, and A denotes the
sequencing coverage). Let no”), mo”) denote the number of haplotypes in
state s carrying the major and the minor alleles at SNPj, respectively, we
write

N L 2
Pr(Z|S) = l—L:1 UH Hk:1 Pr(Zij,leij,k)
_HL Hoe  P08) (3)
'=1 3:1 1“(n3“)+n(1“)+28) 1"(8)1"(8)

 

In formula (3), the multiplication over states s can be computed in ﬁnite
time, because rim): 0 for all unoccupied states and hence their terms in
(3) equal to 1. Derivation of formula (3) can be found in Supplementary
Material.

Finally, the HMM Pr(S) is a product of 2N—independent identically
distributed Markov chains, with all chains governed by two sets of par-
ameters: an inﬁnite vector of state probabilities and a L-dim vector of
SNP-speciﬁc recombination probabilities. Let {vs} denote the inﬁnite
vector of state probabilities that sum to 1. We use a stick-breaking pro-
cess (Sethuraman, 1994) to describe the prior distribution of {vs}. Let {VS}
denote an inﬁnite set of independent Beta random variables,
VS~ Beta(1,a), with or denoting a hyper-parameter. We determine vs by
vs: VSHKYU — V,). Using this prior, DBM allows and regularizes an
inﬁnite number of states in the model. The posterior distribution of
{vs} is again a stick-breaking process. By default, we let 01:1. While
larger or prefer more states to be ﬁtted to the data, smaller or prefer
fewer states.

To model the transition between states in our inﬁnite-state HMM, we
use a recombination mechanism: at each SNP j, the HMM decides
whether or not to select a new state; if yes, a new state is randomly
selected from distribution {vs}, otherwise the state at SNP j remains the

same as the state at SNP j — 1. Let {rj} denote a L-dim vector of recom-
bination probabilities at SNPs j: 1, . . . ,L, with r1 = 1 ﬁxed. Let
CI) 2 {Clark} 2 {(dmyk, . . . ,¢,Lyk)} denote the corresponding indicators of
recombination events. We model ¢,/Vk~Bernoulli(r‘/) independently. The
model for (Silk, (1),-k) is therefore written as

L
Pr(Si,k, (PM) = Pr(Si1,k) 111:2 Pr(sij,ka ¢ij,k Isl-(jinx)

L 17¢," .. 1, ..
_ I I _ . /,k . ¢mk ¢mk
_ vSilJe 1:2 (1 r1) (r1 vSii. k) [Kim l),k:Si/',k

[1 7¢iﬂ k

where the indicator Winkﬂmkequals to 0 if (1),-ilk = 0 and Si/71’k75Si/Vk.we

assign a Dirichlet prior Dir(y,1 — y) and integrate {rj} out, with 0 < y<<1
denoting a small constant (default 0.01). Let S]:  (1),-ilk denote the
total number of recombination events at SNPj in all Markov chains, we
obtain (see Supplementary Material)

N 2 L 7 "k M
Pr(S’ CD) = [Hi:1 Hk21 v‘lilvk l—L':2 liiufiiikﬂitkvﬁikj
X UL re- + y)r(2N — a + 1 — mm) (4)
1:2 r(2N+ 1 )F(y)l"(1 — y)

Putting formulas (274) back to formula (1), along with the prior distri-
bution of {vs} and the auxiliary variable <1), we obtain the full DBM
model in the form of Pr(DlZ)Pr(Z|S)Pr(S,<1>|{vs})Pr({vS}).

In summary, DBM is an inﬁnite-state HMM with the states represent-
ing haplotype templates that emit alleles independently at each SNP. In
turn, alleles generate the observed read counts. There are four sets of
variables to be inferred from our model: (Z, S, <1), {vs}). Our HMM is
speciﬁed by the initial distribution v={vs} and the transition matrix
diag(1 — r;,oo)+r,~1v’. Instead of estimating {rj}, we introduce an auxiliary
variable <1) and integrate {rj} out. The state variable S is a realization of
HMMs regularized by El) and {vs} with priors. Given S, alleles Z are
generated independently at each SNP, which can also capture spurious
mutations unexplained by LD. Although the dimensionality of these four
sets of parameters is greater than the sample size, DBM is identiﬁably in a
Bayesian framework. Particularly, the posterior distributions of the vari-
ables are balanced between the observations and the model priors. We
next discuss our model inference using MCMC algorithms.

2.3 MCMC update

We infer DBM parameters iteratively using MCMC algorithms. Starting
from a random initialization of model parameters, we use a forward-
summation and backward-sampling algorithm to update (Z,, (1),, S,) for
each individual i, conditioning on the parameters for the other individuals
and {vs} in the current iteration. In the forward-summation step, we cal-
culate the marginalized probability of data at SNPs 1, . . . ,j, with param-
eters for SNPs 1, . . . ,j — 1 marginalized out via recursive summation, for
j: 1, . . . ,L in ascending order, respectively. Marginalization is done over
all possible states, recombination events and alleles at SNPs 1, . . . ,j — 1.
To handle inﬁnite number of possible states, we collapse states that are
unoccupied in the current iteration into a ‘super state’, such that the total
number of states in our calculation becomes ﬁnite. In the
backward-sampling step, we then use the marginal probabilities to
update {Ziiyk}, {(1)9316}, {SW}, for k: 1,2 and j=L,...,1 in descending
order, respectively. Sampling at SNP j is also conditioning on the states
updated at SNPj+ 1. If a ‘super state’ is sampled, indicating an unoccu-
pied state, we further sample an unoccupied state. To avoid local mode
problems, we implemented additional MCMC updating schemes, includ-
ing switching state labels and splitting states during burn-in. The detailed
sampling procedures can be found in Supplementary Material.

Given the current states (S) and recombination events ((1)), we next
update the state distribution {vs}. Let {cs} denote the total number of
state s selected at all recombination sites, i.e. at sites with (1),/3k = 1. We ﬁrst
sample VS from VS~Beta(cS+ 1,Z,>XC, + 1 + or), the posterior distribution
of VS. We then calculate vs: VSHKYU — V,). We only calculate vs for a

 

880

112 /310's112u1n0fp10}x0"sotJBuiJOJutotq/ﬁduq 11101} papeolumoq

9103 ‘Og isanV uo ::

Phasing and characterizing haplotypes in NGS

 

ﬁnite number of states up to state s*, where s* denotes the maximum state
index in S in the current iteration, because we collapse the unoccupied
states with indices >s* into a super state during MCMC, the probability
of which is 1 — 2336 vs.

We repeat the above updating procedures many times and then collect
posterior samples of (Z, S, (1)). The output of DBM includes the inferred
haplotypes (and genotypes and SNP calls), the recombination probabil-
ities at each SNP and the underlying haplotype structures. To determine
the ﬁnal haplotypes, we ﬁrst use maximum a posteriori (MAP) to call
genotypes from the posterior samples of Z, at each SNP for each indi-
vidual separately. We then slide a ﬁve-heterozygote window across all
detected heterozygotes in each individual to determine their haplotype
conﬁgurations. Starting from the ﬁrst ﬁve heterozygotes, we use MAP to
determine their joint haplotype conﬁgurations. We then slide the window
to the right by one heterozygote, and we use MAP to determine the
conﬁguration of the new heterozygote conditioning on the haplotype
conﬁgurations of the other four heterozygotes in the window. We
repeat this procedure across all heterozygotes to obtain the entire haplo-
type pair for each individual. Direct MAP of the entire haplotypes is
computationally intractable. Using this procedure, we can recover haplo-
type information accurately and efﬁciently. When summarizing haplo-
types, we further determine their underlying states from the posterior
samples of states (S). Conditioning on the haplotype pair determined in
the current window, we identify all posterior samples of states carrying
the haplotype pairs. We then use MAP to determine the state conﬁgur-
ation for both heterozygotes and homozygotes. Finally, we estimate the
recombination probabilities from the posterior samples of <1) by calculat-
ing the proportion of recombination events occurred at each SNP.

3 RESULTS

3.1 Simulation from human data

We evaluated the performance of DBM using datasets generated
from human sequences with European (CEU) and African W RI)
origins. We downloaded the phased haplotypes of CEU and YRI
individuals from the 1000 Genomes Project (The 1000 Genomes
Project Consortium, 2010). Using these reference haplotypes, we
simulated haplotypes of new individuals and their corresponding
read counts as follows: (i) we generated new haplotypes as
mosaic combination of reference haplotypes with transition
rate 1 per 200kb, and reference individuals are randomly
chosen; (ii) we randomly paired new haplotypes to form new
individuals; (iii) we simulated read counts at each SNP using a
Poisson distribution with mean Ax/2, where A denotes the
sequencing coverage and x=0,1,2 denotes the allele count; (iv)
we generated random sequencing errors in read counts across the
genome at rate 0.01 per basepair per read; this created both false-
positive alleles and false-positive SNPs; and (V) we removed all
reads carrying alleles that are different from the two most fre-
quent alleles at each SNP, as they are most likely sequencing
errors; we also removed SNPs whose minor read count is less
than a threshold, such that the total number of false-positive
SNPs in the data is controlled <5%.

3.2 Accuracy in genotyping and haplotype phasing

We ran DBM on the simulated datasets with sequencing cover-
ages A = 1.0, 3.0 and 6.0, and sample sizes N: 10, 20, 40, 80,
160, 320, 640, respectively. Each dataset contained 10000 SNPs
from a randomly chosen genomic region. We compared DBM
with THUNDER (Li et al., 2011) and BEAGLE (Browning and

Browning, 2007). We ran THUNDER by its default setting for
100 iterations with sequencing error rate speciﬁed at 0.01. For
computing speed, the maximum number of states used by
THUNDER is bounded by 200. We also run DBM and
BEAGLE for 100 iterations. BEAGLE does not take read
counts. We therefore input BEAGLE with the genotype likeli-
hoods generated by DBM. To evaluate the beneﬁt of using LD in
genotype calling, we further implemented a single SNP call
method, which determines genotypes at each SNP separately.
This is done by ﬁxing the recombination probability at 1 at all
SNPs in DBM. In practice, one may call genotypes first and then
make a bona ﬁde use of the called genotypes to infer haplotypes.
To evaluate the power of this two-step approach, we ran MaCH
on the called genotypes generated by the single SNP call method.

We used two accuracy measures to compare the results, one
for genotype calling (percentage of incorrect alleles) and one for
haplotype phasing (percentage of switch errors). For genotype
calling, we calculated the number of alternative alleles (relative to
an arbitrarily chosen reference allele), denoted by xi], estimated
by each program at SNP j in individual i. Further, we denote the
true number of alternative alleles by gij. The percentage of incor-
rect alleles is deﬁned as Zijlxij—gijl / (2NL). For haplotype
phasing, we ﬁrst calculated the number of switches needed to
convert the inferred haplotypes to the true haplotypes in each
individual. We then divided that number by the number of het-
erozygous SNPs in the individual minus 1. We only used the
correctly inferred heterozygous SNPs by each program, so that
the results were not strongly affected by genotyping errors.
Finally, the overall switch error is averaged across all individuals.

Figure 2 shows the genotyping accuracy of the four programs.
At low sequencing depth (A = 1), DBM performed consistently
the best among all methods, especially in small samples. In con-
trast, THUNDER performed slightly worse than DBM, but
BEAGLE performed poorly in small samples. It was as inaccur-
ate as the single SNP call method at N: 20. At larger sequencing
depths (A = 3 or 6), the performance of the ﬁrst three programs
became much more similar in both CEU and YRI individuals,
except that BEAGLE performed slightly worse than DBM and
THUNDER at N: 10. All three programs substantially outper-
formed the single SNP call method, suggesting that LD can
greatly help improving the accuracy of genotype calling
(Nielsen et al., 2011).

We next show in Figure 3 the haplotype phasing result. At all
sequencing depths (A = 1,3,6), DBM performed consistently the
best in small samples (e.g. N 5 80). BEAGLE performed worse
than both DBM and THUNDER at A = 1, which may be related
to its erroneous genotype calls. THUNDER performed consist-
ently and substantially worse than DBM in small samples (e.g.
N 5 80) regardless of the sequencing depth. In large samples
(N 3 320), DBM performed slightly worse than BEAGLE and
THUNDER, which may be due to the local mode problem in the
MCMC algorithm. Given the dynamic nature of DBM that se-
lects varying numbers of states to ﬁt the data, the method may be
trapped in a suboptimal mode when many individuals are fitted
simultaneously. In such cases, multiple independent runs of
DBM from different starting values and advanced MCMC sam-
pling techniques (Liu, 2001) may be desirable to improve its
performance. Finally, the two-step approach of single SNP
call + MaCH phasing performed the worst in most cases.

 

881

112 /310's112u1n0fp10}x0"sotJBuiJOJutotq/ﬁduq 11101} papeolumoq

9103 ‘Og isanV uo ::

Y.Zhang

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

   

 

 

A=1.0 A=3.0 A=6.0
9 5‘3 1’
5 o' o' _ o' _
LILJ O O O
a, F. F. - F. -
a g C O O
0 g LO LO x X  LO
a, O. Q— "  o.-
o o o ‘. .X....x 0
°\0 0 O O
O. — O. — O.
O I I I I I I I O I I I I I I I O
10 20 40 80 160 320 640 10 20 40 80 160 320 640 10 20 4O 80 160 320 640
:9 5‘3 _ :9 _ —e— DBM
‘9' o' o' o' "A" THUNDER
m o o o ---+--- BEAGLE
“3 '7 F- F F- F  -
E g o o o SIngIe
>- E to I" m
a, O. O. 0. —
(D O o o
\o  . . . . . . . . . . . . . . . . . . . ..
o  _   _ x X X X X
0 I I | | I I | o O

10 20 40 80 160 320 640
Sample Size

 

1O 20 4O 80 160 320 640

 

10 20 4O 80 160 320 640

Sample Size Sample Size

Fig. 2. Genotyping accuracy in CEU and YRI samples at different sequencing depth (A) by DBM, THUNDER, BEAGLE and Single SNP Call. Sample

size is shown in log scale

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

        

A=1.0 A=3.0 A=6.0
IE) 0 o ‘ o —
E N N N
a f, o' o' d
O E ,_ .— -
‘2 o' o' o'
o\
0. 0. 0.
o | l I | | l I o o l I | | l I |
10 20 4O 80 160 320 640 10 20 4O 80 160 320 640 10 20 4O 80 160 320 640
<2 <2 _ <2 _
° ° o —e— DBM
5   _  _ "A" THUNDER
=2 t-«+-«- BEAGLE
LIJ x
_ I a! a! -. c\!_§\  Single
0: 3 o o o -.\_\
>-  >§\
0’ S E S - ~ “A
o\° .2 "'-1§§.\
0. 0. 0. _ ' .
O O o I I I I I I I

 

 

 

 

 

 

 

 

 

 

10 2O 40 80 160 320 640
Sample Size

10 20 40 80 160 320 640
Sample Size

 

10 20 40 80 160 320 640
Sample Size

Fig. 3. Haplotype phasing accuracy in CEU and YRI samples at different sequencing depth (A) by DBM, THUNDER, BEAGLE and a two-step
approach of Single SNP Call followed by MaCH phasing. The sample size is shown in log scale

3.3 Run time

Figure 4 shows the computing time of the three programs for the
simulated CEU datasets at A : 3. At N: 10, DBM was the slow-
est program among the three. At N3 20, however, DBM ran up
to 8 x faster than THUNDER. Both DBM and THUNDER ran
in time complexity O(|S|2NL), i.e. proportional to the square of
the number of states and linear to the number of individuals and
SNPs. Since DBM dynamically selects the number of states to fit

the data, the number of states used by DBM can be far less than
that used by THUNDER in large samples, which then can
greatly improve the computation speed. Interestingly, while
BEAGEL ran the fastest among the three programs in small
samples (N 5 160), its computing speed does not scale up well
in large samples. Particularly, BEAGEL ran slower than DBM
at N 3 320 in this study. In Figure 4, we also observed that the
computing time of DBM is almost linear with respect to the

 

882

112 /310'S[BIIJUOIPJOJXO"SOIJBHIJOJIIIOIq/ﬂduq 111011 pap201umoq

9103 ‘0g isanV uo ::

Phasing and characterizing haplotypes in NGS

 

 

 

—9— DBM

 

—A— THUNDER

Running Time (Sec) of 100 Iterations

 

 

 

 

--+-- BEAGLE

 

| | | | | | |
10 20 40 BO 160 320 640

Sample Size

Fig. 4. Computing time of DBM, THUNDER and BEAGLE on CEU
datasets with sequencing depth 1: 3 at 10000 SNPs. Time and sample
size are both shown in log scale

sample size. The computing time of THUNDER is theoretically
cubic to the sample size, but due to the fact that its maximum
number of states is bounded at 200, its computing time is linear
at N >100. The computing time of BEAGLE appears to be
non-linear with respect to the sample size. As previously reported
(Williams et al., 2012), BEAGLE’s running time grows faster
than the sample size.

3.4 Using reference input

DBM can further take input of reference genotypes and haplo-
types. To use reference genotypes, one can simply convert
genotypes to pseudo read counts. For genotypes AA, Aa and
ad, the read counts can be written as (2X ,0), (X ,X) and (0,2X),
respectively, with large X (e. g. 3 15). If the reference data are in
haplotype format, we treat each reference haplotype as an ‘indi-
vidual’, and we ﬁt each reference haplotype with one Markov
chain only. To do this, we replace the observation probability
Pr(DlZ) in formula (2) by an indicator function I :6, at each
SNP, with ‘a’ denoting the true allele in the current haplotype
at each SNP.

To evaluate the beneﬁt of using extra data in genotype calling
and haplotype phasing, we simulated 40 individuals (CEU and
YRI, respectively) at 10000 SNPs with sequencing depth A : 3
and sequencing error rate 0.01. These are the sample individuals.
We further simulated additional 40 individuals (CEU and YRI,
respectively) as the references. We ran DBM to analyse the 40
sample individuals along with various numbers of references
input to the program. The references were input in three ways:
(i) in form of read counts at sequencing depth A : 3, which then
merely increased the sample size; (ii) in form of known
genotypes, which eliminated genotyping uncertainties in the ref-
erence data; and (iii) in form of known haplotypes, which further
provided phasing information in the reference data. As shown in
Figure 5, DBM can indeed gain power in genotype calling and
haplotype phasing from the reference data. By comparing the
three types of reference input, reference haplotypes provided
the largest accuracy boost in both CEU and YRI samples.
In practice, however, haplotypes are expensive to obtain.
Alternatively, reference genotypes also signiﬁcantly improved
the accuracy of genotyping and haplotype phasing, just slightly
worse than using reference haplotypes, but clearly better than
merely increasing the sample size.

 

 

 

 

 

 

 

   

 

 

 

 

 

 

(\I
§g- ea.
u'iw' u']°_
a: - .:
g8— .28..
oo_ 30
0:30 "3 -
<38_ CEU o\8__
o\ol I I I I o
._ L8
0 Lu?”
,_ 0
Se— '50"
2.0 :N_
0 3<3.
50' "3"
(58_ YRI °\8: YFII
$6 I I I I I 0' I I I I I
O 10 20 30 40 O 10 20 30 40

Reference Size Reference Size

Fig. 5. Performance of DBM using different types of reference in differ-
ent sizes. Left: genotyping error rate. Right: haplotype phasing switch

error rate. Reference data are input in three ways: haplotypes (solid line),
genotypes (dashed line), read counts (dotted line)

3.5 Haplotype characterization

Our method further produces haplotype segmentation that cap-
tures the allele compositions and dependencies. Haplotype seg-
mentation is speciﬁed by the recombination indicator d3 in DBM
that partitions each haplotype into consecutive intervals, and
also by the state variable S in DBM that speciﬁes the haplotype
template index of each interval. Since haplotypes in the same
templates at the same SNPs have similar allele compositions,
the haplotype segmentation output by DBM is useful in down-
stream analysis, e.g. for population structure inference and asso-
ciation studies. An example of haplotype segmentation is shown
in Figure 6a, a mixture of 10 CEU and 10 YRI individuals from
1000 Genomes at 2000 SNPs. DBM segmented the 20 individuals
using 14 states as shown in colours. Relationships among indi-
viduals can be clearly seen: the states shared by the CEU indi-
viduals are quite different from the states shared by the YRI
individuals. Recombination hotspots can also be observed at
SNPs with frequent transitions between states. In association
studies, one can use the haplotype segmentation in similar
ways to Visually identify associated loci among individuals ascer-
tained by phenotypes. Formal test on the association of haplo-
type segments is also possible.

DBM outputs haplotype templates as summary statistics from
the data. The haplotype templates can be intuitively treated as a
reconstruction of the ancestral haplotypes, although not exactly
so because our model does not involve a time component. In
Figure 6b, we show the inferred haplotype templates in CEU
and YRI samples, respectively. Each colour represents one tem-
plate (the colours match with those shown in Fig. 6a), and the
height of colour bars indicates their estimated population abun-
dance at each SNP. Darkness of colours is drawn proportionally
to the probability that the SNP carries a minor allele in the cor-
responding template. Comparing the haplotype templates in
CEU and YRI, we observed that the two sets of individuals
only shared small proportions of genetic contents (templates)
at each SNP, and hence they are genetically separable. The
YRI samples carried more diverse genetic contents than the
CEU samples. Also, the proportions of templates varied across
regions, reﬂecting genetic variability. Figure 6c shows the
number of distinct states fitted to the data by DBM, where the
number of states ﬁtted to the YRI sample is consistently larger

 

883

112 /310'S[BIIJUOIPJOJXO"SOIJBHIJOJIIIOIq/ﬂduq 111011 pap201umoq

9103 ‘0g isanV uo ::

 

 

 

o 500 1000 1500 2000
(b) SNPs

 

 

 

 

 

0 500  1500 2000
S

(0)

E
E
.‘B
U)
M5
4::

o
(d) SN Ps
.o (D
8 0'
CI.
.o
E ALMM‘JMLJ‘ML‘JJ‘ALLJ—I—L—
8
CD 0.
I o I I I I I

0 500 1000 1500 2000
SN PS

Fig. 6. Comparing CEU and YRI samples using DBM. (a) Haplotype
segmentation of 10 CEU and 10 YRI individuals; each row corresponds
to one chromosome, and each colour corresponds to a state.
(b) Reconstructed haplotype templates with the same colours as used in
(a); each colour represents one haplotype template over 2000 SNPs; at
each SNP, the height of each colour bar represents the population pro-
portion of the template; colour darkness at each SNP is proportional to
the alternative allele frequency. (c) Number of distinct haplotype
templates used at each SNP in CEU and YRI samples. ((1) Inferred
recombination probabilities

than the number of states ﬁtted to the CEU sample, again indi-
cating greater genetic diversity of YRI than CEU. Finally,
Figure 6d shows the estimated recombination probabilities
between SNPs. This example illustrates the utility of DBM char-
acterization of haplotypes for evaluating genetic relatedness and
diversity among individuals at the SNP resolution.

4 DISCUSSION

We introduced a dynamic Bayesian Markov model for joint in-
ference of genotypes and haplotypes in NGS data. The method is
fully probabilistic and produces consistent inference results. A
main feature of DBM is its inﬁnite-state Markov chain that
allows varying numbers of mixture components fitted to the
data depending on the structural complexity of the data across
regions, such that haplotype structures and SNP dependencies
can be most efﬁciently and sufﬁciently captured by the states.
Using data from the 1000 Genomes Project with individuals of
different ethnicity, we compared DBM with two popular algo-
rithms: THUNDER and BEAGLE, as they both have been used
to phase haplotypes in the 1000 Genomes Project (the 1000
Genomes Project Consortium, 2010). In all scenarios tested,
DBM produced either similar or better results than the two
benchmark programs. Particularly, for small sample datasets

and/or low sequencing studies, DBM performed substantially
better than the other two programs. DBM is thus desirable for
exploratory sequencing studies that involve limited samples at
low sequencing coverage. For large sample datasets, DBM per-
formed similarly to the other two methods, and DBM had better
runtime scalability with respect to the sample size. All three pro-
grams tested in this study call genotypes and phase haplotypes
simultaneously, which is more powerful than the two-step ap-
proach. Consistent with previous reports (Nielsen et al., 2011),
we demonstrated that using LD information can substantially
increase the accuracy of genotype calling.

DBM is a ﬂexible tool that can be applied to many sequencing
projects with minimum input requirement from the user. DBM
takes input of either read counts or genotypes (in form of pseudo
read counts), and outputs genotypes, haplotypes and recombin-
ation probabilities. Additional information such as SNP quality
scores and genetic maps can also be provided, but not manda-
tory. Missing genotypes can be easily accommodated and
imputed by specifying zero read counts for both alleles in the
input file. Although all examples shown in this article were gen-
erated from data in human genome, DBM can be directly
applied to sequencing studies of any diploid species. To fully
use LD information, SNPs should be ordered by their genomic
positions. On the other hand, DBM can work on unsorted SNPs,
in which case it reduces to a single SNP call method.

DBM characterizes haplotypes Via segmentation that captures
the haplotype relationships among individuals and de-correlates
alleles across SNPs. It also reveals the most likely recombination
loci at the individual level. One can use DBM segmentation in
downstream analysis for hypothesis testing and parameter infer-
ence, such as association mapping and population evolution stu-
dies. Most de novo population detection algorithms require
independent SNPs, whereas our approach enables use of all
SNPs in form of haplotype segments, which can potentially sig-
niﬁcantly increase the power for detecting subtle stratiﬁcation.

DBM reports summary statistics of a sample in form of haplo-
types templates. The templates are identiﬁed as commonly
shared haplotypes among individuals. The haplotype templates
can be used to learn genetic relatedness and diversities within and
between groups of samples at the SNP resolution. To compare
groups of individuals, data from all groups of individuals should
be input to DBM together, such that the state indices are
matched across groups.

Population NGS data are being increasingly generated in
many species of interest, and the sequencing cost continues to
drop. Although DBM only facilitates the first step in population
sequencing studies, the DBM model itself has broader applica-
tions. For example, we can modify the observation and emission
probability functions to take various types of data into account.
We can also modify the DBM model for de novo detection of
population stratiﬁcation and admixture mapping, where we
allow unknown numbers of populations to be admixed without
requiring ancestral references.

ACKNOWLEDGEMENTS

The author is grateful to the two anonymous reviewers for their
constructive comments that have substantially improved the
quality of this manuscript.

 

884

112 /310'S[BIIJUOIPJOJXO"SOIJBHIJOJIIIOIq/ﬂduq 111011 pap201umoq

9103 ‘0g isanV uo ::

Phasing and characterizing haplotypes in NGS

 

Funding: The author acknowledges the grant support of NIH
R01HG004718 and NIH lULlRR033184.

Conﬂict of Interest: none declared.

REFERENCES

Barrett,J.C. et a]. (2005) Haploview: analysis and visualization of LD and haplotype
maps. Bioinformatics, 21, 2637265.

Beal,M.J. et a]. (2002) The inﬁnite hidden Markov model. In: Advances in Neural
Information Processing Systems 14. The MIT Press, Cambridge, MA, USA,
pp. 5777584.

Browning,S.R. and Browning,B.L. (2007) Rapid and accurate haplotype phasing
and missing-data inference for whole—genome association studies by use of loca—
lized haplotype clustering. Am. J. Hum. Genet, 81, 108431097.

Browning,S.R. and Browning,B.L. (2011) Haplotype phasing: existing methods and
new developments. Nat. Rev. Genet, 12, 7037714.

Dunson,D.B. and Xing,C.H. (2009) Nonparametric Bayes modeling of multivariate
categorical data. J. Am. Stat. Assoc, 104, 104271051.

Efros,A. and Halperin,E. (2012) Haplotype reconstruction using perfect phylogeny
and sequence data. BMC Bioinformatics, 13 (Suppl. 6), S3.

Howie,B.N. et a]. (2009) A ﬂexible and accurate genotype imputation method for the
next generation of genome—wide association studies. Plos Genet, 5, e1000529.

Liu,J.S. (2001) Monte Carlo Strategies in Scientﬂic Computing. New York,
Springer.

Li,N. and Stephens,M. (2003) Modeling linkage disequilibrium and identifying re—
combination hotspots using single—nucleotide polymorphism data. Genetics, 165,
22137233.

Li,Y. et a]. (2009) MaCH: using sequence and genotype data to estimate haplotypes
and unobserved genotypes. Genet. Epi, 34, 813834.

Li,Y. et a]. (2011) Low—coverage sequencing: implications of design of complex trait
association studies. Genome Res., 21, 940951.

Nielsen,R. et a]. (2011) Genotype and SNP calling from next—generation sequencing
data. Nat. Rev. Genet, 12, 4434151.

Scheet,P. and Stephens,M. (2006) A fast and ﬂexible statistical model for large scale
population genotype data: applications to inferring missing genotypes and hap—
lotypic phase. Am. J. Hum. Genet, 78, 629$44.

Sethuraman,J. (1994) A Constructive Deﬁnition of Dirichlet Priors. Statistica
Sinica, 4, 639$50.

The 1000 Genomes Project Consortium (2010). A map of human genome variation
from population—scale sequencing. Nature, 467, 106171073.

Williams,A.L. et a]. (2012) Phasing of many thousands of genotyped samples. Am.
J. Hum. Genet, 91, 2397251.

Zhi,D.G. et a]. (2012) Genotype calling from next—generation sequencing data using
haplotype information of reads. Bioinformatics, 28, 9387946.

 

112 /310'S[BIIJDOIPJOJXO'SOIJBLUJOJIIIOIq/ﬂduq 111011 papeo1um0q

9103 ‘0g1sn8nv uo ::

