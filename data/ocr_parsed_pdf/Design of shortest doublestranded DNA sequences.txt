BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

Y.Orenstein and R.Shamir

 

Mintseris and Eisen (2006) does not provide an optimal solution
for even values of k. In the context of sequence assembly,
Medvedev et al. (Medvedev and Brudno, 2009; Medvedev
et al., 2007) solved the problem of constructing a minimum
length sequence that covers a given set of k—mers, using reverse
complementarity. Although their algorithm can be applied to
solve the problem raised in this study, they do not address it
directly. When applied to our problem, their algorithm requires
0(k2 log2(| 2|)l 2|2k) time. As we shall see, our algorithm is much
faster.

In this study, we address the problem of constructing an op—
timal RC complete sequence. We ﬁrst give a lower bound for the
length of such a sequence. We prove that for odd k, there exists a
sequence that achieves the lower bound and show how to con—
struct it in time complexity that is linear in the output sequence
length. For odd k, the algorithm constructs two tours that are
reverse complementary to each other and together cover all edges
of the de Bruijn graph and is identical to Mintseris and Eisen
(2006). Then, we show how to adjust the algorithm to handle the
case of even k, achieving a saving factor approaching 2 as k
increases. We give two solutions: a simple near—optimal one
requiring linear time and a more complex (0(k|2|5k/4log(|2|))
time) solution that guarantees optimality of the resulting se—
quence. In particular, this implies that the lower bound is not
tight for even k. We implemented the algorithm and we demon—
strate the saving it achieves. The produced sequences are nearly
half the length compared with a regular de Bruijn sequence.

The article is organized as follows. We ﬁrst provide for—
mal definitions and preliminaries. We then present a lower
bound for the length of an optimal sequence based on k—mer
counts. Then, we present an algorithm that works in linear time
on the de Bruijn graph and prove that it solves the problem for
odd k. We conclude by describing the two possible solutions for
even k and report on experimental results with all the algorithms.

2 PRELIMINARIES

We start with some basic definitions of graphs and sequences.
For more details see, e.g. West et al. (2001).

A directed graph (digraph or simply a graph) G = (V,E) is a
set of vertices V: {v1, v2, ..., v,,} and a set of edges
E: {e1,e2, ...,em}. Each edge is an ordered pair of vertices
(v,~, vi), and we say the edge is directed from v,- to v,. The indegree
of vertex v is the number of edges entering v. Similarly, the out—
degree is the number of edges outgoing from v. A vertex is
balanced if its indegree equals its outdegree. A path in a digraph
is a sequence of vertices, v,~], . . . , v,~,_,, such that for each 1 g j <k
there is an edge (v,~j, v0“). A cycle is a path where i1 = ik. A
digraph is strongly connected if for every pair of vertices u,v
there exists a path from u to v and a path from v to u. A strongly
connected component in a digraph is a maximal set of vertices that
induces a strongly connected subgraph.

An Eulerian tour through a digraph G is a cycle that traverses
all edges in G, such that each edge is traversed exactly once. If a
digraph contains an Eulerian tour, we call it Eulerian. A digraph
is Eulerian if and only if it is strongly connected and all vertices
are balanced (West et al., 2001).

A de Bruijn sequence of order k over alphabet 2 is a minimum
length sequence that covers each k—mer over 2 exactly once. For

convenience, we define the length of the sequence as the number
of k—mers in it. Hence, a sequence of length t contains t+ k — 1
characters. A de Bruijn sequence has length IEIk, which is the
minimum possible for covering all k—mers.

Given sequences a,b over alphabet 2, the overlap between a
and b, denoted ov(a, b), is the largest sufﬁx of a that is also a

prefix of b.

A de Bruijn graph of order k is a digraph in which for every
possible k—mer x1, ...,xk there is a vertex denoted by
[.x1,...,xk]. There is an edge from u to v if and only if
u =[x1, ...,xk] and v = [.m, ...,ka], that is,
|ov(u, v)| = k — 1. Each edge represents a unique (k + 1)—mer.
For example, the edge (u, v) above represents (x1, ...,ka).
To distinguish vertices from edges, we will use square brackets
for vertices. Hence, (x1, ...,ka) is the edge between
[.xl, ...,xk] and [x2, ...,ka]. Obviously, for each vertex v the

indegree and outdegree are |2|, and the graph is strongly con—
nected. Thus, a de Bruijn graph is Eulerian. Any Eulerian tour
represents a de Bruijn sequence of order k+ 1. Each edge and
vertex in the graph is represented by 0(klog(|2|)) bits.
Throughout the article, we assume this number of bits is con—
tained in one computer word; hence, we deduce that it takes 0(1)
time to find an edge or a vertex.

A complementarity relation between characters is a symmetric
non—reﬂexive one—to—one relation. The alphabet of DNA is
2 = {A, C, G, T} with the complementarity relation rl = T and
C = G. By symmetry also T: A and G = C. The reverse com—
plement of sequence (x1, ...,xk), denoted RC(x1,...,xk), is
deﬁned as the sequence obtained by reversing the original se—
quence and replacing each character by its complement, i.e.
RC(xl, ...,xk) = (5%, ...,Scl). For example, RC(CGAA)=
T T CG . A sequence s is called a palindromic reverse complemen—
tary sequence or in short a palindrome, if s = RC(s). For ex—
ample, ACGT is a palindrome. We deﬁne a reverse
complementary complete sequence of order k over alphabet 2
(RC complete sequence for short) as a sequence such that for
each k—mer s, at least one of s and RC(s) are in the sequence.
Note that unlike a regular de Bruijn sequence, the deﬁnition of
an RC complete sequence does not require minimality. An RC
complete sequence is optimal if it is of minimum length.

3 RESULTS
3.1 A lower bound for the length of an RC complete
sequence

First, we derive a lower bound for the length of an RC complete
sequence from k—mer counts.

PROPOSITION 1. Denote by n*(k) the length of an optimal RC
complete sequence of order k.

 ifk is odd
n* k > , 2  1
( ) _ —'2'A+2'2'U" , ifk is even ( )

PROOF. We consider separately the cases of odd and even k. For
odd k, there are no palindromes, as the middle position in a
k—mer differs from its reverse complement. Each k—mer must be
represented in the sequence by itself or its reverse complement.

 

i72

ﬁm'spzumofpmﬂo'sopnuuopnorq/ﬁdnq

Design of shortest double-stranded DNA sequences covering all k-mers

 

Thus, a lower bound for the minimum length is half the number
of unique k—mers, which is |2|k/2. For even k, some k—mers are
palindromes. For palindromes, the ﬁrst k/2 characters deﬁne the
last k/2 characters. Hence, there are exactly IEIk/2 different pal—
indromes. All palindromes must appear at least once in any RC
complete sequence, whereas for the non—palindromic k—mers,
either they or their reverse complement must appear in the
sequence. Thus, for even k, n*(k) 3  + IEIk/Z. I

We shall show later that n*(k) is tight for odd k, but not for
even k.

3.2 Constructing an optimal RC complete sequence
for odd k

In this section, we prove constructively that for odd k there exists
an RC complete sequence that achieves the lower bound of
Proposition 1 and is thus optimal. The proof modifies the
Euler tour algorithm (West et al., 2001). The modiﬁed algorithm
was presented without proof in Mintseris and Eisen (2006). The
algorithm for generating the sequence will work on the de Bruijn
graph of order k — 1. Every k—mer is represented in the graph as
an edge, the graph is strongly connected and all vertices are
balanced. As there are no palindromes of odd length, every
edge has a unique reverse complement counterpart that is differ—
ent from it. This deﬁnes a perfect matching M on the edges of the
graph.

Given a directed path F in the graph, its reverse complement
path is defined as the path R in which each edge (u, v) in F is
replaced by the edge (17, 12). For example, for the path
(ACG) —> (CGG) —> (GGT), its reverse complement is
(ACC) —> (CCG) —> (CG?) (Fig. 1). We will refer to F and R
as forward and reverse paths, respectively.

The following theorem provides a necessary and sufﬁcient
condition for the existence of an RC complete sequence that
achieves the lower bound.

THEOREM 1. For odd k, an RC complete sequence s achieves
the lower bound (Proposition 1) if there exist two edge—disjoint
paths with no repeating edges, corresponding to s and RC(s), that
together cover all edges of the de Bruijn graph of order k— 1.

 oe.

Fig. 1. An illustration of forward and reverse paths (top and bottom,
respectively). The forward path traverses the edges in their direction. The
corresponding reverse path traverses the reverse complementary edges in
reverse direction

PROOF. :> Observe that the lower bound assumes one occur—
rence of either w or RC(w) but not both in the sequence for
each k—mer w. Assume an RC complete sequence s* achieves
the lower bound. Then, because of its minimality, it contains
no repeating k—mers; therefore, it must correspond to a path F
in the de Bruijn graph with no repeating edges. The ordered set
of k—mers in s* corresponds to consecutive edges in F. Note
that the reverse complement sequence t* = RC(s*) is also a
path R in the graph: the k—mers in R are the reverse complement
of those in F; therefore, consecutive edges form a path in
the graph traversed in reverse order. As each k—mer or its re—
verse complement is covered in s*, it is also true that each
k—mer or its reverse complement is covered by t*, and the two
paths F and R, corresponding to the two sequences, together
cover all edges.

<= Suppose there are two edge—disjoint paths F and R with no
repeated edges that together cover all edges. As they are reverse
complement of each other, and together cover all edges, for each
k—mer w, the sequence s (corresponding to path F) must contain
either w or RC(w) (otherwise, some edges would have been un—
covered). Hence, s is an RC complete sequence. The same argu—
ment holds for RC(s) (corresponding to path R). As each
contains exactly half the edges, the length of each of them
equals the lower bound I.

Before presenting the algorithm for ﬁnding an optimal RC
complete sequence, we remind the reader of the algorithm for
ﬁnding an Eulerian cycle in a digraph (Fleischner, 1990). The
algorithm starts from an arbitrary source vertex. Initially all
edges are unmarked. It traverses a path of unmarked edges in
arbitrary order. Each traversed edge is marked; therefore, no
edge is traversed more than once. The algorithm also maintains
a set A of the visited vertices that are still active, i.e. they have
outgoing unmarked edges. When the last unmarked edge outgo—
ing from a vertex is traversed, the vertex is removed from A. If
the algorithm reaches a dead end, it starts another traversal from
another vertex in A. A dead end can only be achieved when
closing a cycle (i.e. returning to the source vertex), as in any
other vertex there is always a free incoming edge and a free
outgoing edge (as for every vertex except the source the un—
marked outdegree and the unmarked indegree are equal). If
not all edges have been traversed, A is not empty, and the process
can start from a new source. In the end, as the graph is strongly
connected and all cycles start from visited vertices (except for the
initial vertex), the cycles can be joined to form one Eulerian
cycle. The running time of the algorithm is linear in the
number of vertices and edges.

Algorithm 1 ﬁnds an optimal RC complete sequence in a de
Bruijn graph of order k— 1 when k is odd. The algorithm imi—
tates the Euler path algorithm but maintains both a forward
sequence and a reverse complement sequence simultaneously.
The collection of cycles traversed so far is kept in f and the
corresponding reverse complement cycles set is R.

 

Algorithm 1. Find forward and reverse paths that cover all edges in a de
Bruijn graph G = (V,E) of even order k— 1.
(1) Initially all edges are unmarked, f = R 2 ill, and A = {u},
an arbitrary vertex.

 

 

i73

ﬁm'spzumofpmﬂo'sopnuuopnorq/ﬁdnq

Y.Orenstein and R.Shamir

 

(2) Although A 75 ((1 do
(3) F = R = ((1.
(4) Pick any starting vertex v = [x1, . . . , x164] from A.

(5) Although there exists an unmarked edge
e = (x1, ...,xk) outgoing from v do

(6) Append e to F. Prepend RC(e) to R.
(7) Mark e and RC(e).
(8) Set v: [)62, ...,xk]; A =AU{v}.
(9) Remove v from A.
(10) IfF7é (ll, add Fto 7-"; add R to R;
(11) Merge the cycles in f to obtain a single forward path.

Do the same for R.

 

THEOREM 2. For odd k, Algorithm 1 returns forward and reverse
paths that cover together all edges of the graph and represent
two optimal RC complete sequences. The algorithm runs in
0(| VI) time.

PROOF. We prove the theorem using several lemmas. We first
show that if the forward path F reaches a dead end, then so
does the reverse path R, and in that case, a cycle is closed
(Lemma 1). Note that each pair F, R constructed in Steps #7
are reverse complementary paths by the way they are con—
structed. Then, we show that the cycles in f can be merged
into one cycle (Lemma 2). Third, we deduce that a strongly con—
nected component is covered by f and R (Lemma 3). Finally,
we conclude that f and R cover all edges, as there is only one
strongly connected component in any de Bruijn graph (Corollary
1). As each edge is traversed once, the paths are of length 
and, hence, optimal.

LEMMA 1. If the forward traversal reaches a dead end, then so
does the reverse. Both paths close a cycle in this case.

PROOF. Distinguish two cases in which the forward path reaches
a dead end:

CASE 1. F reaches a vertex v and R reaches a vertex u 75 v, and all
outgoing edges from v were already traversed. We prove that in
that case, F must close a cycle. Assume to the contrary that F
contains no edge outgoing from v. In that case, all outgoing
edges were traversed by R. Then, all incoming edges must have
been traversed by R as well, as each time R reached v, it must
have exited it as well. The only exception is if v is also the first
(last added) vertex u in R, contradicting our assumption that
u 75 v. Therefore, all incoming and outgoing edges were covered
by R, contradicting the fact that F just entered v. We conclude
that F has an edge outgoing from v and thus it closed a cycle.

Denote by (x1, . . . , xk) the last edge traversed by F. All edges
of the form (x2, . . . ,xk,a), where a e 2, were traversed. Hence,
the reverse edges of the form (ing, ...,E) were traversed as
well. The last edge traversed by R was (ﬁ, ...,ﬁ), outgoing
from the vertex [E, ...,E]. All incoming edges to this vertex
have already been traversed, as they are the reverse complements
of the edges outgoing from v, which were traversed by F. Thus, R
reaches a dead end as well. R closes a cycle because of a sym—
metrical argument to that made for F.

CASE 2. F and R reach the same vertex v simultaneously. Denote
the incoming edge used by F (x1, xz, ..., xk). Then, the reverse
outgoing edge, which is traversed by R, is (ﬂ, . . . ,5, K). From
the fact that both reach the vertex simultaneously, we get that
[.xz, ...,xk] = [ﬁ, ...,E]. Hence, in all previous traversals of
this vertex F and R also reached the vertex simultaneously.
Moreover, the forward and reverse paths reach a dead end to—
gether at v. Hence, all incoming and outgoing edges were already
traversed, and they are all of the form (a, x2, ...,x") and
(E, . . . ,E, a), for all a e 2. Thus, both paths close a cycle I.

LEMMA 2. The cycles in f can be merged into one cycle.

PROOF. According to Lemma 1, when F is added to 7-", it is a
cycle in the graph. Thus, f is a set of cycles. The first cycle starts
from an arbitrary vertex, but all other cycles start from a vertex
of another cycle in f (denote encompassing cycle). Thus, each
inner cycle can be merged into its encompassing cycle, forming
one merged cycle. This is true to all cycles, except for the initial
cycle I.

LEMMA 3. The merged cycle of f and R either cover two
strongly connected components separately or one strongly con—
nected component together.

PROOF. Cycles are added to f and R as long as there are un—
marked edges. If there are no shared vertices between f and R,
then both sets cover edges of different components. As each set is
added edges until all are traversed, they cover two strongly con—
nected components separately. Else, there is at least one shared
vertex; thus, they cover the same component. The component is
strongly connected, as no edges are left to traverse I.

COROLLARY 1. f and R cover all edges of a de Bruijn graph.

PROOF. Following Lemma 3, as there is only one strongly con—
nected component in a de Bruijn graph, f and R cover it
together I.

This completes the proof of Theorem 2 I.

3.3 Two solutions for the case of even k

Algorithm 1 cannot be applied when k is even. A palindrome is
represented by one edge in the de Bruijn graph (like any other
k—mer). The algorithm must traverse both an edge and its reverse
complement edge on the forward and reverse paths; therefore,
for a palindromic edge, both paths should use the same edge,
which is impossible.

One possible way to rectify the problem is by adding one more
copy of each palindromic edge to the de Bruijn graph. Note that
in the resulting (multi—) graph, the number of edges is exactly
twice the lower bound. Adding the parallel edges would solve the
problem discussed earlier in the text, but it will make some ver—
tices unbalanced; therefore, the resulting graph is not Eulerian.
Such a graph cannot be represented as a union of two reverse
complementary edge—disjoint paths.

A more aggressive augmentation that overcomes this difﬁculty
is adding a cycle for every palindromic edge. This would preserve
the balance of all vertices and the strong connectivity as well. If,
in addition, the added non—palindromic edges have a perfect

 

i74

ﬁm'spzumofpmjxo'sopnuuopnorq/ﬁdnq

Design of shortest double-stranded DNA sequences covering all k-mers

 

matching between reverse complementary edges, the algorithm
can be applied.

We present two possible augmentations. One is simple, based
on the ideas aforementioned, and near—optimal; the other is
optimal but requires a more complex augmentation.

3.3.1 A simple near—optimal augmentation In this approach, for
each palindromic edge, we add to the de Bruijn graph all possible
cyclic shifts of it. More formally, let k 2 21. For the palindrome
e = (x1, ...,x,,.>_c,, ...,Scl), we add k edges corresponding to
all possible cyclic shifts of e. Obviously, as these edges form a
cycle, all vertices remain balanced. In fact, this cycle contains two
edges that are palindromes, (x1, . . . , x,, Sq, . . . , 5:1) and
(So, ...,.>_c1,x1, ...,xl); therefore, only one cycle is added for
both, and the cycle doubles both palindromic edges. It is easy
to see that the remaining 2l — 2 edges are in fact 1— 1 matching
pairs of reverse complementary edges. For each edge that repre—
sents the cyclic shift starting at position i, for 1<i<k/2, the
matching edge starts at k+ 2— i. Hence, a perfect matching
exists after adding the new cycles. In total, during the edge aug—
mentation process, for each pair of palindromic k—mers, we add k
edges. For example, for the palindromes ACGT and GTAC, we
add ACGT, CGTA, GTAC and TACG (Fig. 2). The added
edges CGTA and TACG match each other. The added palin—
dromes match the original edges in the graph. The resulting aug—
mented graph contains |2|k + k -  edges, where the ﬁrst term
is the number of edges in the original de Bruijn graph, and the
second is k for each pair of palindromes.

In some cases, the number of added edges can be reduced.
If the palindrome (x1, ...,xk) is periodic, then the number of
cyclic shifts needed to return to the original k—mer is the length of
the period. For example, the period of (ATAT . . . T) and

Q
CD
'ﬂ
:3

i

 

Fig. 2. A cycle and edge matching. For the pair of palindromes ACGT
and GTAC, all cyclic shifts of these palindromes are added once (dashed
edges). In the matching, palindromic edges in the original cycle are paired
with their added copies (encircled by small red ovals). Other non-palin-
dromic added edges are paired (encircled by a large red oval)

(TATA...A) is 2. Only two edges suff1ce in this case, the
edges (ATAT . . . T) and (TATA. . . A). This also applies to
(CGCG . . . G) and (GCGC. . . C). Therefore, each two periodic
palindromes that are a cyclic shift of each other require an add—
ition of a number of edges equal to the length of their period.
Hence, a smaller augmented graph and a shorter RC complete
sequence can be obtained by considering the different possible
periods, which can only be of even length, as each period is a
palindrome.

Denote by (p(k) the set of even integers that divide k, and by
6(k) the exact number of additional edges.

THEOREM 3.

i . ,
6k 2 —. 2'/2— 21/2 2
0 220' an") 0

few/c)

PROOF. All k—mer palindromes are divided to pairs, which are
cyclic shifts of each other. For each pair, all distinct cyclic shifts
are added. The number of shifts is equal to the length of the
period of the k—mer. The periods can only be even, as the periodic
sequences are palindromes by themselves. The number of i—peri—
odic palindromes is IZIi/Z. These contain shorter periods, for
which edges have already been counted. Thus, IZII/l/2 is sub—
tracted, where j is the maximum even integer that divides i/2.
The number of edges added for each pair of i—periodic palin—
dromes is i I.

THEOREM 4. Running Algorithm 1 on the augmented graph pro—
duces forward and reverse paths that together cover all edges of
the graph and represent two RC complete sequences.

PROOF. Algorithm 1 can be run on graphs that satisfy the fol—
lowing properties:

(i) The graph is strongly connected.
(ii) All vertices are balanced.
(iii) There exists a perfect matching of the edges, such that each
pair of edges represent a k—mer and its reverse
complement.

The original de Bruijn graph of order k satisﬁes (1) and (2),
and there exists a perfect matching for all non—palindromic
k—mers in it. Added edges cannot disturb the connectivity. The
addition of cycles preserves the balance. Each added palindromic
k—mer matched the edge representing the same k—mer in the ori—
ginal graph. As discussed earlier in the text, the added non—pal—
indromic edges form a perfect matching. Thus, Algorithm 1 can
be run on the augmented graph. According to Theorem 2, it
produces a forward and reverse path that together covers all
edges of the augmented graph.

Each k—mer is represented in the augmented graph as an edge.
All edges are covered together by the forward and reverse paths.
For each path and for each k—mer, either it or its reverse com—
plement is covered by the path. Thus, the paths represent RC
complete sequences I.

Algorithm 1 produces two sequences, forward and reverse,
each of which is an RC complete sequence (Fig. 3). The length
of the produced sequences is the number of edges divided by two.
For each pair of palindromic edges, at most k edges were added,

 

i75

ﬁm'spzumoipmjxo'sopouuopnorq/ﬁdnq

Y.Orenstein and R.Shamir

 

and by Theorem 3 exactly 6(k) edges were added in total. Hence,
the length of the sequence is (| 2|” + 6(k))/ 2, which is bounded by
(|2l” +  - k)/2. This is an addition of O(\/Elog(L)) charac—
ters, where L denotes the lower bound in Proposition 1 for an
RC complete sequence of even order k.

3.3.2 An optimal augmentation We now present another aug—
mentation that has higher time complexity but leads to an opti—
mal RC complete sequence. As before, starting from the de
Bruijn graph G = (V, E), all palindromic edges are doubled, re—
sulting in a graph G/ = (V, E U B). We temporarily disregard the
reverse complementarity matching constraints. As a result of the
edge doubling, there are unbalanced vertices in G/. We rectify
this by adding short paths between unbalanced vertices. By
adding paths of minimum total length, we will obtain a third
graph G2 = (V,E U E’ U E”) in which all degrees are balanced
and it has minimum number of edges. Finding an optimal set
of edges E” can be done by solving a maximum weight—matching
problem on a related graph. In fact the problem is equivalent to
the Chinese postman problem (Edmonds and Johnson, 1973)
[the Chinese postman problem is used in Medvedev and
Brudno (2009) and Medvedev et al. (2007) and is also mentioned
in Mintseris and Eisen (2006) as a solution on the original de
Bruijn graph]. We shall later show that G2 can be modiﬁed to
satisfy the reverse complementarity matching requirement with—
out losing optimality. Hence, applying Algorithm 1 on it will
produce an optimal RC complete sequence.

Finding an optimal set of edges E” is done by solving a max—
imum weight—matching problem in a bipartite graph, where ver—
tices with greater indegree than outdegree constitute one part,
and the vertices with greater outdegree than indegree are the

00

     

‘---..---...---..----..

0

Fig. 3. An augmented de Bruijn graph of order 1 and an example of
forward and reverse paths in it. The dashed edges are added edges. The
blue and brown paths represent the forward and reverse paths, respect-
ively. Numbers on edges are the order of the edges in the forward path.
The sequences are ACCGAATGCT and AGCATTCGGT for forward
and reverse paths, respectively

other. The edge weights are k minus the number of characters
on the path from one vertex to the other. More formally, let
V’ (V+) be the set of vertices with indegree greater (smaller)
than outdegree in G/. For k = 21, there are IEI/‘l2 — |2|
vertices in V’ of the form u = [x2, ...,x,,)—c,, ...,Scl] and the
same number of vertices in VJr of the form
v = [x1, ...,x,,.>'c,, ...,)":2] [note that |2| palindromes of period
2 are already balanced (e.g. ATA. . . T)]. We deﬁne a complete
bipartite graph H = (V’, V+, F), where the weight of edge (u, v)
is the maximum overlap between the sufﬁx of u and the preﬁx of
v (i.e. |ov(u, v)|). The length of the shortest path p(u, v) between u
and v is k — |ov(u, v)| (Fig. 4). We are looking for a maximum
weight matching in H. The procedure is summarized in
Algorithm 2, Steps 175.

 

Algorithm 2. Find an optimal augmentation for a de Bruijn graph
G = (V,E) of odd order.
1. Add to G the set E’ of palindromic edges.
The resulting (multi-)graph is G’ = (V, E U E’).
2. Deﬁne VJr = {v e V|(v, u) e E’ /\ (u, v)¢E’ for some u}

V’ = {u e V|(v, u) e E’ /\ (u, v)¢E” for some v}.

 

LA)

. Deﬁne a complete bipartite graph H = (V’, V+,F)
with edge weights w(x, y) = |ov(x, y)|.

4. Find a maximum weight-matching M in H.

. Deﬁne G2 = (V, EU E’ U E”)
where E” = {(u, v) e p(x,y)|(x,y) e M}.

. Modify M, so that each cycle in the graph (V, E’ U E”)
contains exactly two palindromic edges (Lemma 6).

{J}

0

 

The graph G2 produced in Step 5 of Algorithm 2 is strongly
connected with all vertices balanced, but it is not guaranteed to
satisfy the third property of Theorem 4, i.e. having a perfect
matching among reverse complementary edges, which is needed
to apply Algorithm 1. We now prove that it can be modiﬁed to
satisfy this property without losing optimality. In fact, as E U E’
has a perfect matching, we only need to prove this property on
the added edges E”. Once this is done, Algorithm 1 can be
applied to produce two reverse complementary paths that
cover all edges.

To establish Algorithm 2, we prove several lemmas:

LEMMA 4. The shortest path from palindrome A to the palin—
drome B is the reverse complementary of the shortest path from
B to A.

PROOF. Denote A = (x1, ...,xk) and B = (yl, ...,yk) two pal—
indromes. Let (x,, ...xk,y1, ...,yH) for any 2 5 i: k be an
edge in the shortest path from A to B. Its reverse complement
is (ya—,1, ...,yT,ﬁ, ...,E), which, as A, B are palindromes,
which is the same as (yr/(4+2, ...,yk, x1, ..., kaHI), an edge in
the shortest path from B to A I.

LEMMA 5. No cycle in (V, E’ U E”) contains a single palindrome.

PROOF. Suppose there exists a cycle containing only one palin—
drome. The shortest path to return to the palindrome is t cyclic
shifts of the palindrome where t is the length of its period. Let
(x1, ...,x,,ﬁ, ...,K) be the palindrome. Its cyclic shift
(5, ...,ﬁ, x1, ...,x,) is another palindrome. Thus, the cycle
includes more than one palindrome I.

 

i76

/810'SIEumo_fpm}Xo'soiJEmJOJUioiW/zduq

Design of shortest double-stranded DNA sequences covering all k-mers

 

LEMMA 6. Every cycle in (V, E’ U E”) can be decomposed into
cycles containing exactly two palindromes each, without decreas—
ing the total weight of the matching.

PROOF. The proof is by induction on n, the number of palin—
dromes in the cycle. For the induction base, n=1 is impossible
by Lemma 5, and n = 2 is trivially true. Induction step, for n 3 3,
denote by X, Y, Z and W palindromes in the cycle, where W, X,
Y and Z appear in this order in the cycle. Let x = |ov( W,X)|,
y = |ov(X, Y)|, z = |ov(Y,Z)| and let w be the sum of overlaps of
all palindromes between Z and W (inclusive). In case n=3,
Z: Wand w = 0. Without loss of generality, let y be a maximum
overlap. The total sum of overlaps is x + y + z + w (Fig. 5).
Remove X and Y and form a cycle of these two palindromes.
As X, Y are palindromes, ov(X, Y) = ov(Y, X); therefore, the
contribution of this cycle to the matching is 2y. The total overlap
of the remaining cycle is w plus the overlap between W and Z,
which is at least min(x,z). To see this, denote by Pref(X, i) the
i—long preﬁx of string X, and denote by Suf(X, i) the i—long sufﬁx
of X. If x f z, Suf(W, x) = Pref(X, x) = Pref(Y, x) = Suf(Y,x)
= Pref(Z, x), where the ﬁrst, second and fourth equalities
follow from the overlap assumptions and the second, third
and fourth use the palindrome property. If 2 g x, simi—
larly Suf(W,z) = Pref(Z,z). Hence, |ov(W,Z)| Z min(z,x)_
The total weight of the two cycles in the new matching is
at least 2y + w + min(x, 2). Hence, the difference between
the new matching and the previous one is at least
2y+w+min(x,z)—x—y—z— w=y+min(x,z)—x—Z=y

@@@@@@

  

0

—max(x, z) 3 0, where the last inequality follows by the choice of
y as a maximum overlap.

The remaining cycle has n — 2 palindromes, and by the induc—
tion step, it is breakable to cycles of size two I.

PROPOSITION 2. There exists a maximum weight matching in
which all the added edges form reverse complementary pairs.
Any maximum weight matching can be modified to such
matching.

PROOF. Consider the graph G2 produced in Step 5 of Algorithm
2. If E’ U E” contains cycles of more than two palindromes, by
Lemma 6, they can be decomposed into cycles of two palin—
dromes. The new matching is of the same size, and for each
cycle with exactly two palindromic edges, the remaining edges
match in reverse complementary pairs (Lemma 4) I.

The maximum weight—matching problem, also known as the
assignment problem (West et al., 2001), can be solved by the
Hungarian method in 0(| V|2log| V| + |V||E|) time (Kuhn,
2006). As WI 2 ®(|2|k/2) and |E| = ®(| VIZ) = ®(|2|k), the run-
ning time is 0(|2l3k/2). An improvement to this algorithm (Kao
et al., 1997), when the edge weights are integers, runs in
0(mlEllog(|V|N)) time, where N is the largest edge weight.
In our case N: k, which gives 0(k| 2|5k/4 log(| 2|)) running time.
The post—processing of the matching (Lemma 6) requires ﬁnding
two palindromes with maximum overlap. This can be done in
total time linear in the number of palindromes, as overlap lengths
are integers in the range of 0 to k, and thus can be sorted using
count sort. Hence, we conclude

O@@@@®

¥o

      
   

0 2

 

0 0

Fig. 4. The bipartite graph for matching unbalanced vertices (Algorithm 2). On the top are the vertices with greater indegree, and on the bottom are the
vertices with greater outdegree. Weights on the edges are the maximum overlap between the vertices’ sequences. Only the edges out of one vertex are
drawn (the graph is a complete bipartite graph). Note that only unbalanced vertices corresponding to (k — l)-long preﬁxes and sufﬁxes of palindromes
are included

X:
Y: -

X:
Y: -

2:

Fig. 5. Breaking down cycles with more than two palindromes. Left: Palindrome overlaps in a cycle found by the maximum matching. The rectangles at
the ends indicate overlap between contiguous palindromes. Right: Partition into two cycles, one containing only the palindromes X and Y with a
maximum overlap y. As t 3 min(x, z), the partition does not decrease the total contribution of the cycles to the weighted matching (Lemma 6)

 

i77

ﬁm'spzumoipmjxo'sopouuoonIq/ﬁdnq

Y.Orenstein and R.Shamir

 

THEOREM 5. An optimal RC complete sequence for even k can be
produced in time 0(k|2|5k/4log(|2|)).
Summarizing Theorems 2 and 5 we obtain

THEOREM 6. For every value of k, an optimal RC complete se—
quence can be obtained in time polynomial in the size of a de
Bruijn graph of order k — 1.

4 EXPERIMENTAL RESULTS

Table 1 shows the results of the two algorithms for even k. As we
can see, the sequence obtained by the algorithm is of length
nearly half that of the original de Bruijn sequence. For example,
for k: 12, the minimum length is within 0.15 per cent of 412/2
and within 10, 116 characters from the theoretical lower bound.

Table 2 lists the number of probes of length p needed to cover
all k—mers, by cutting an optimal RC complete sequence to
p—long probes with overlaps of k— 1. As we can see, the saved
factor in using the RC complete sequence is roughly 2.
A comparison to the Table 1 of (Mintseris and Eisen, 2006)
shows that the sequence produced in (Mintseris and Eisen,
2006) is sub—optimal.

Running times: The simple near—optimal algorithm runs in
time roughly linear in IZIk. For example, for k=8, 10 and 12
the running times are 1.5, 26 and 445 s, respectively. The optimal
algorithm requires 5, 126 and 2937 s, respectively.

5 SUMMARY AND DISCUSSION

In this article, we studied the problem of constructing a min—
imum length sequence that covers each k—mer or its reverse com—
plement at least once. The problem has applications in
construction of dense double—stranded probe arrays for in vitro
measuring of proteiniDNA binding (Berger et al., 2006; Fordyce
et al., 2010), and for design of synthetic enhancers for in vivo
developmental studies (Smith and Ahituv, 2012). For the case of
odd k, we provided a proof that a simple modiﬁcation of the
Eulerian tour algorithm applied to the de Bruijn graph of order
k—l gives an optimal solution. The algorithm requires linear
time in the output sequence length, and it cuts the sequence
length in half compared with using a regular de Bruijn sequence.

The problem is a bit more involved for even k, and here we
provided two algorithms, a linear time near—optimal algorithm
and a more complex polynomial algorithm that produces an
optimal sequence. The length of the sequence produced by the
optimal algorithm is slightly shorter, and both algorithms nearly
halve the total length of the sequence.

The following related problem was studied by Medvedev et al.
(Medvedev and Brudno, 2009; Medvedev et al., 2007): what is
the minimum length sequence that contains a given set of
k—mers? Their solution is based on bidirected graphs, which are
similar to de Bruijn graphs, with the difference that a k—mer and
its reverse complement are represented by the same vertex, and
the edges represent the possible ways that double—stranded

Table 1. Length of reverse complementary de Bruijn sequences produced by the two algorithms for even k

 

 

k 2 4 6 8 10 12 14

Original 16 256 4096 65 536 1048 576 16 777 216 268 435 456
Lower bound 10 136 2080 32 896 524 800 8 390 656 134 225 920
Algorithm 1 10 142 2140 33 262 526 840 8 400 808 134 275 060
Optimal 10 142 2140 33 262 526 816 8 400 772 134 274 844
Saving factor 1.6 1.8 1.91 1.97 1.990 1.997 1.999

 

Note: The top row is the length of a regular de Bruijn sequence that does not exploit complementarity. The next row contains the theoretical lower bound on RC complete
sequence length (Proposition 1). The next two rows are the lengths of the sequence computed by the two algorithms of Section 3.3.1 and 3.3.2. The saving factor is the ratio
between the original sequence length and length of the optimal RC complete sequence. Note that the lower bound is not tight.

Table 2. Number of probes needed to cover all k-mers as a function of probe length and k

 

 

k 6 7 8 9 10 ll l2 l3 l4 l4-DB

25 107 432 1848 7711 32926 139811 600056 2581 111 11189571 22 369 622
30 86 342 1447 5958 25 087 104 858 442146 1864136 7 898 521 15 790 321
35 72 283 1188 4855 20 263 83 887 350 033 1458 889 6103 402 12 201 612
40 62 241 1008 4096 16 995 69 906 289 682 1 198 373 4 973 143 9 942 054
45 54 211 876 3543 14634 59919 247082 1016801 4196089 8388 608
50 48 187 774 3121 12850 52 429 215405 883012 3629 050 7255013
55 43 168 693 2789 11453 46 604 190 927 780 336 3 197 021 6 391 321
60 39 152 628 2521 10330 41944 171445 699 051 2856912 5711393
65 36 139 574 2300 9408 38131 155 570 633 103 2 582 209 5162 221
70 33 128 528 2115 8637 34 953 142 386 578 525 2 355 700 4 709 394

 

Note: The table contains the number of probes obtained by cutting an optimal RC complete sequence to short segments with overlaps. Left column: probe length; top row: k.

Right column: number of probes needed when using a regular de Bruijn sequence for k = 14.

 

i78

ﬁm'spzumoipmjxo'sopouuoonIq/ﬁdnq

Design of shortest double-stranded DNA sequences covering all k-mers

 

strings can overlap. These graphs were originally conceived by
Kececioglu and Myers (1995) and actually discovered earlier by
Edmonds (1967). Medvedev et al. stated, without proof, that an
Eulerian path can be found in a bidirected graph in the same way
as in a regular de Bruijn graph (Lemma 1), but they did not
consider explicitly the problem of covering all k—mers and
did not make the distinction between even and odd k. In fact,
some vertices in a bidirected graph of odd order (when edges
represent k—mers of even length) are unbalanced, and thus an
Eulerian tour does not exist. Although their method can be
applied to our problem, it is slower than ours: they require
0(kzlog2(|2|)|2|2k), whereas our algorithms requires 0(|2lk)
for odd k and 0(k|2|5k/4log(|2|)) for even k.

Beyond the theoretical interest, our results are applicable to
current (Berger et al., 2006; Fordyce et al., 2010; Smith and
Ahituv, 2012) and future technologies that require complete
coverage of double—stranded DNA k—mers. In PBM, although
it is desirable to have redundancy in covering k—mers, space on
the arrays is limited. By essentially halving the needed sequence
length, space is freed on the array to select additional redundant
probes with desired properties. Similarly, in designing synthetic
enhancer sequences, by using shorter sequences, experiments can
be simpliﬁed.

In current technologies, the de Bruijn (or RC complete) se—
quence is cut into probes of length p with overlap k — 1 (Table 2).
There is no constraint that forces these probes to come from a
single sequence. A variant of the problem we studied is as fol—
lows: what is the minimum number of double—stranded DNA
probe sequences of length p that together cover all k—mers? As
our solution for an RC complete sequence of even k covers, a few
k—mers more than once and direct design of probe sequences of
length p might reduce the number of probes needed to cover all
k—mers.

A heuristic solution to that problem was recently proposed by
Riesenfeld and Pollard (Riesenfeld and Pollard, 2012). They stu—
died the following problem: given k and m, design a set of m
double—stranded DNA probes (of equal or almost equal length,
denoted as Z) that together cover all k—mers. Their algorithm
repeatedly searches for disjoint Z—long paths between unbalanced
vertices. After removal of all such paths, it finds two reverse—
complementary cycles. One cycle is cut into probes (with over—
laps of k— 1) of length Z or Z + 1. If the program terminates, an
optimal set of oligomers is found; however, there is no theoretical
guarantee that it will terminate. In our tests, for k=6, their
program terminates in a few seconds, whereas for k: 8, it
takes >1 h and for k: 10>2 weeks. For some values of m, the
produced probes are not of equal length. A modest reduction in
the number of oligomers is obtainable compared with our design:
for example, for k=6 and probe length 15, the algorithm of
Riesenfeld and Pollard produced 208 oligomers compared with
210 in our design. For greater values of k, the running time was
already prohibitive (for k: 12, it kept running for >1 month),
and thus we could not test the performance for these values. Our
algorithm, on the other hand, produces an output for values of
k g 10 in just a few seconds, whereas for k: 12, the linear algo—
rithm takes <10 min and the optimal <1 h. The time is polyno—
mial (or even linear) in the output sequence size, independent of
probe length or the number of oligomers.

Our study raises several additional open questions. First, fol—
lowing (Philippakis et al., 2008), can one design an optimal RC
complete sequence with improved coverage of gapped k—mers?
Second, it is known that the number of distinct de Bruijn se—
quences is (k!)kH /k". What is the number of different optimal
RC complete sequences? Third, can one construct an optimal RC
complete sequence for even k in linear time? Fourth, is there a
closed formula for the length of an optimal RC complete of even
order?

Funding: This study was supported in part by the Israel Science
Foundation (grant no. 802/08), and by the I—CORE Program of
the Planning and Budgeting Committee and the Israel Science
Foundation (grant no. 41/11). Y.O. was supported in part by a
fellowship from the Edmond J. Safra Center for Bioinformatics
at Tel Aviv University and by a Dan David PhD Fellowship.

Conﬂict of Interest: none declared.

REFERENCES

Berger,M. et al. (2006) Compact, universal DNA microarrays to comprehensively
determine transcription—factor binding site speciﬁcities. Nat. Biotechnol, 24,
142971435.

Chen,X. et al. (2007) Rankmotif—I—+: a motif—search algorithm that accounts for
relative ranks of k—mers in binding transcription factors. Bioinformatics, 23,
i727i79.

Edmonds,J. (1967) An introduction to matching. In: Notes of Engineering Summer
Conference. University of Michigan, Ann Arbor.

Edmonds,J. and J ohnson,E. (1973) Matching, Euler tours and the Chinese postman.
Math. Program., 5, 887124.

Fleischner,H. (1990) Eulerian Graphs and Related Topics. Vol. 1. North—Holland,
Amsterdam and New York.

Fordyce,P. et al. (2010) De novo identiﬁcation and biophysical characterization of
transcription—factor binding sites with microfluidic afﬁnity analysis. Nat.
Biotechnol, 28, 9707975.

Jolma,A. et al. (2013) DNA—binding speciﬁcities of human transcription factors.
Cell, 152, 327.

Kao,M. et al. (1997) All—cavity maximum matchings. Algorithms Comput., 1350,
3643373.

Kececioglu,J. and Myers,E. (1995) Combinatorial algorithms for DNA sequence
assembly. Algoritlmtica, 13, 7751.

Kuhn,H. (2006) The Hungarian method for the assignment problem. Naval Res.
Logist. Q., 2, 83797.

Medvedev,P. and Brudno,M. (2009) Maximum likelihood genome assembly.
J. Comput. Biol, 16, 110171116.

Medvedev,P. et al. (2007) Computability of models for sequence assembly.
Algorithms Bioinform., 28%301.

Mintseris,J. and Eisen,M. (2006) Design of a combinatorial DNA microarray for
protein—DNA interaction studies. BM C Bioinformatics, 7, 429.

Nutiu,R. et al. (2011) Direct measurement of DNA afﬁnity landscapes on a high—
throughput sequencing instrument. Nat. Biotechnol, 29, 659$64.

Orenstein,Y. et al. (2013) Rap: Accurate and fast motif ﬁnding based on protein—
binding microarray data. J. Comput. Biol, [Epub ahead of print, March 6 2013].

Philippakis,A. et al. (2008) Design of compact, universal DNA microarrays for
protein binding microarray experiments. J. Comput. Biol, 15, 655%65.

Riesenfeld,S. and Pollard,K. (2012) Computing MRCC libraries and related types
of DNA oligomer libraries. https://github.com/sriesenfeld/MRCC—Libraries
(1 April 2013, date last accessed).

Smith,R. and Ahituv,N. (2012) Deciphering the vertebrate regulatory code using
short synthetic enhancers in vivo. http://zendev.ucsfedu/projectview.php?pro—
ject=6mer (1 April 2013, date last accessed).

West,D. et al. (2001) Introduction to Graph Theory. Vol. 2. Prentice Hall, Upper
Saddle River, NJ.

 

i79

ﬁre'spzumoiproyo'sopouuowrorq/pdnq

