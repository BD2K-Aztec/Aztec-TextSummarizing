BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

Exploring variation-aware contig graphs

 

Similar to co—assembly of individual genomes, metagenome
assembly involves simultaneous assembly of multiple genomes.
The presence of two closely related genomes in a sample leads to
similar bubbles. The metagenome scaffolder Bambus 2 was
designed to detect these bubbles and collapse them, thereby elon—
gating scaffolds while preserving divergence in the data (Koren
et al., 2011). Bambus 2 ﬁnds bubbles by looking for subgraphs
where multiple paths begin at a source node and collapse to one
sink node. To keep computation tractable, the number of hops
considered is limited to two. Meta—IDBA similarly searches bub—
bles in a de Bruijn graph, but the search is limited to a maximum
of 300 bp (Peng et al., 2011).

Here we set out to detect complex bubbles such as presented in
Figure 2a, i.e. longer than can currently be detected by Bambus 2
and Cortex, typically found when >2 homologous sequences
(closely related genomes) are present in a sample. We overcome
the computational limitations in the aforementioned methods by
developing an efficient way to find genome variation in assembly
graphs, by introducing a graph decomposition into bi— and
triconnected components that allows us to select a subset of
the nodes as source nodes for bubble finding. Identifying bubbles
representing multi—alleles has three applications. First, it can be
used to detect sequence variation, i.e. multiple alleles, between
strains within a single—sample metagenome. Second, co—assem—
bling multiple metagenomes allows the detection of variation
between samples. This latter application is particularly novel
and is set to become more prominent as more metagenomics
datasets will become available over the coming years. Third, al—
though not the main focus in this article, it allows to simplify
assemblies, generating longer scaffolds and contigs by collapsing
bubbles into a single linear sequence instead of breaking into
multiple contigs. Co—assembly has previously been used by
Dutilh et al. (2012) to calculate global distances between meta—
genomes, but here we aim to ﬁnd sequence—level differences.

We demonstrate MARYGOLD, our algorithm to ﬁnd bubbles
and compare them across samples using co—assembly, by com—
paring metagenome samples obtained using 454 technology of
different time points obtained from the stool sample of a prema—
ture infant (Morowitz et al., 2011) and a fermentation process of
the traditional Korean food kimchi (Jung et al., 2011). We also
apply the algorithm on sequencing data of microbial populations
found on acid mine drainage (Denef and Banfleld, 2012), ob—
tained using both 454 and Illumina technologies, and compare
MARYGOLD with Bambus 2. MARYGOLD exports the variation
detected in a format that can be visualized by Circos, allowing
for a rich visual exploration and interpretation of the genomic
variation in metagenomes.

2 ALGORITHM
2.1 Generating a contig graph

De novo assembly of metagenomes relies on the same principles
as that of single genomes. It can be done either by assemblers
based on de Bruijn graphs or overlap—layout—consensus assem—
blers as reviewed by Li et al. (2012). Both of these types of as—
sembler use graphs to merge the millions of short reads into
longer contiguous sequences, with the ultimate goal of recon—
structing full genomes. Although de Bruijn graph and overlap—

layout—consensus assemblers have different ways of building their
graphs, i.e. by means of kmer hashing and pairwise read align—
ment, respectively, both paradigms produce graphs that contain
similar information and have similar limitations. In both, repeats
longer than the read length (or kmer length) will cause branching
in the graph, and unique regions correspond to unambiguously
reconstructable sequences.

The algorithm we propose uses the graphical output of assem—
blers to reconstruct metagenomes. The assembly graphs are
assumed to have nodes representing contigs and edges represent—
ing reads spanning the connected contigs. The graph is bidirected
because it has both contigs coming from the forward strand and
from the reverse strand of the DNA molecule (Kundeti et al.,
2010). From this point onward, we refer to this graph as
the contig graph G = (V, E) that has a set of nodes
V: {v1, v2, ..., vn} and a set of edges E: {(v,~, vi, ol,oz)lv,~,
v, 6 VA 01, 02 e {>, <}}. The set of nodes is created by assigning
each contig c e C to a unique node. A path from v,- to v,- through
the bidirected—contig graph is a sequence of nodes and edges
v,~, e,~] , v,~] , e,~,, ..., vim, em] , V], such that each intermediate node v,~,
in subsequence e,~,, v,~,, em] has matching orientations of its
incoming edge (e,~, = (ViH , v,~,, 01, 02)) and outgoing edge
(em = (v,~,, v,~,+],o/l,o/2)), i.e. 02 = 0/1 (Kundeti et al., 2010). The
DNA sequence corresponding to a node in a path depends on its
traversal. The reverse complement DNA sequence of a node v,~, is
used when either 02 2 <1 or 0/1 2 <1 (Fig. 1: node GGTG).

2.2 Metagenome graph compression

In the contig graph, two contigs can be reliably concatenated,
with or without a gap, if they are connected by a single edge and
no other edge contradicts their concatenation. Ambiguity arises
when multiple edges of a contig link to other contigs. In meta—
genome assemblies where we are dealing with closely related
strains, such branches in the graph can be caused by sequence
divergence between two strains of the same (or closely related)
species in the sample, forming bubbles (Fig. 1). In this work we
try to elongate scaffolds and contigs by identifying these regions
and collapsing them to multi—allelic contigs.

The main challenge tackled here is the detection of complex
bubble structures. We deﬁne a bubble as a subgraph where all
maximally extended paths within the bubble start in a single
source node and end in a single sink node or vice versa (the
source and sink nodes are interchangeable because of the two—
stranded nature of DNA, i.e. they can be swapped by taking the
reverse complement of all nodes in the subgraph).

2.2.1 Finding separation pairs using graph decomposition In
Bambus 2, sourceisink pairs are iteratively found by traversing
all paths leaving a node and checking if these paths all collapse to
a sink node within a certain number of hops. The number of
hops is limited to two to keep this search tractable. Here we set
out to ﬁnd sourceisink pairs efficiently, so that we can detect
source and sink nodes that are >2 hops apart from each other in
31 of the connecting paths. This allows us to detect more com—
plex multi—allelic sites. We achieve this by finding separation
pairs, i.e. pairs of nodes that increase the number of connected
components in a graph when they are removed. All source and
sink pairs are a separation pair (Theorem 1), though the converse

 

2827

ﬁre'spzumofpmﬂo'sopeuuopnorq/pdnq

J.F.Nijkamp et al.

 

ACTGATATGACATTGATTGG
Genomes:

ACTGCACCGACAGGAATTGG
Contig graph:

Collapsed contig graph:

 

| ACTG HATAT/CACCH GAGA HTTGA/GGAAH T'I‘GG |

 

Fig. 1. Two genomes, their contig graph and collapsed contig graph,
where the two simple bubbles have been compressed into multi-allelic
contigs. After compression the original seven contigs are connected by
a simple path without branching, and can be merged into a single contig

does not hold. We can, therefore, first ﬁnd all separation pairs,
and then select the subset of separation pairs that are also
sourceisink pairs.

THEOREM 1. A separation pair is a sourceisink pair of nodes form—
ing a bubble  and only  all paths in the corresponding subgraph
starting in the source node end in the sink node when extended, and
all paths starting in the sink node end in the source node when
extended.

Separation pairs are detected in an undirected version of the
contig graph using graph decomposition methods. An initial set
of separation pairs is found by decomposing each connected
component into its biconnected components, which can be
done in O(| V] + |E|). A biconnected component is a maximal
biconnected subgraph. The cut vertices of a graph are the
nodes, whose removal increases the number of connected com—
ponents. If a biconnected component has exactly two such cut
vertices, then these two are stored as a separation pair. The set of
separation pairs is extended by decomposing each biconnected
component into its triconnected components. The triconnected
components of a biconnected component describe the 2—vertex
cuts in a graph. A 2—vertex cut is a pair if nodes that, if removed,
increase the number of connected components, i.e. a separation
pair.

Battista and Tamassia (1989) developed an algorithm to de—
compose a biconnected undirected graph into its triconnected
components by building an SPQR tree, which was later im—
proved and implemented in time O(|V| + |E|) by Gutwenger
and Mutzel (2001). The SPQR tree represents all triconnected
components of a biconnected graph from which all 2—vertex cuts
can be extracted. Figure 2 shows such an SPQR tree for a toy
graph example; an elaborate description of how to construct the
SPQR tree can be found in Weiskircher (2002). The pairs of
1—vertex cuts obtained from the decomposition in biconnected
components and the 2—vertex cuts obtained from the triconnected
components form the set of separation pairs. These separation
pairs are next validated to be sourceisink pairs using the bubble
search algorithm.

2.2.2 Validating separation pairs as sourceisink pairs The sep—
aration pairs are only source and sink pairs when all maximally
extended paths inside the bubble originate from the source node
and end in the sink node or vice versa. For example, the pair
{1,6} in the biconnected component in Figure 2a is a separation

 

 

(b)

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

Fig. 2. (a) Toy example of a biconnected contig graph. Separation
pairs are hatched, but only valid sourceisink pairs are hatched vertically,
otherwise horizontally. (b) The corresponding SPQR tree describing
the triconnected components. Virtual edges are indicated by dashed
lines; branches in the SPQR tree link shared virtual edges. By merging
these edges, the original graph can be reconstructed. A detailed
description on how to construct an SPQR tree can be found in
Weiskircher (2002)

pair because when it is removed, it increases the number of con—
nected components, but it does not form a valid sourceisink pair
of a bubble. The only valid sourceisink pairs in Figure 2a are
{1,5}, {6,9} and {10,11}.

THEOREM 2. Node v is part of a bubble if and only if all paths
starting at v with a certain orientation 0 end in the source node
when extended and all paths starting with the opposite orientation
end in the sink node when extended.

Valid bubbles are found with a search based on breadth—ﬁrst
search in the bidirected—contig graph, starting from a random
node in the list of nodes that form separation pairs. As a bubble
can be present both upstream and downstream of the contig, the
search is performed in two directions independently. In a normal
breadth—ﬁrst search, all outgoing edges of a node v that has been
visited are queued for visiting. In our bubble search, edges of a
node v,-, with orientation o/l are only queued when all its edges for
which 02 = 0/1 have been visited, as Theorem 2 states that if there
is no path from the source leading to one of these not—visited
edges of v,-,, a valid bubble will never be present and there is no
need for further exploration (Fig. 3).

THEOREM 3. A contig can be the source of at most one bubble and
the sink of at most one other bubble.

To limit computation time, we try to minimize the number of
bubble searches that we have to do by reducing the set of sep—
aration pairs. When a bubble is successfully found, all separation
pairs that have at least one node in this bubble are removed from

 

2828

ﬁlO'SIBHmOprOJXO'SOQBILLIOJLIIOICV/idnq

Exploring variation-aware contig graphs

 

(b)

 

BB?

 

3:133:22 3:15:13: 3:11:33
u." 'v..m..v' EN”

Q = {(1 ,2},4),(1 ,3,>,>)} Q = ((1,3),>),(2,4,<,4)}

'  

 
  

Q = {(2,444)} O =1)

Fig. 3. The bubble search algorithm. Solid edges indicate visited edges. (21) The search starts at node 1, and the queue Q holding the edges to be visited is
initialized with all edges with a given orientation; 01/ = > in this case. (b) Edge (1 , 2, >, <1) is visited. As all edges incident to node 2 with 02 2 <1 have been
visited, all edges of node 2 with 01/ 2 <1 are queued. (c) Edge (1, 3, >, >) is visited, but in this case, not all edges incident to node 3 with 02 = > have been
visited yet, so the edges of node 3 are not queued. (d) The next edge (2, 4, <1, <1) in Q is traversed to target node 4. Again, not all edges incident to node 4
with 02 2 <1 have been visited, so no edges are added to Q. The Q is now empty and the algorithm terminates: node 1 in forward orientation is not a valid

source node

the set. Only the sink node can still be used to start the bubble
search algorithm, if it forms a separation pair with another node
outside the established bubble (Theorem 3). If we failed to find a
bubble from a source node, then all separation pairs that contain
the source node are removed from the set.

2.3 Assembly simpliﬁcation by collapsing multi-allele
bubbles

Scaffold and assembly graphs can be simpliﬁed by collapsing the
bubbles into supercontigs. The inner contigs of the bubble are
replaced in the contig graph by a single supernode (Fig. 1). All
edges to and from the inner nodes are removed and replaced by
two new edges: from source to supernode and from supernode to
sink. Subsequently, a so—called unitigging step is performed,
which is a search for simple paths without branches. The contigs
in the simple paths are then combined into a single supercontig.

These supercontigs represent different alleles between the
source and sink node present in the genomes in the sample.
Any path from source to sink through this supercontig spells a
valid assembly (Myers, 2005) and is a potential allele in one of
the genomes. The native output of MARYGOLD is a graph
describing the multi—allele. Nonetheless, downstream processing
is facilitated by sequence—based tools, as there is also a sequence
output, which is the highest depth path in the multi—allele (with
ties broken arbitrarily).

2.4 Comparative metagenomics: genomic variation
detection between metagenomes by co-assembly

The MARYGOLD algorithm enables variation detection between
metagenome sequencing samples through co—assembly. By keep—
ing track of the sample origin of the reads during assembly, a
read depth per contig per sample can be calculated. Bubbles are
then detected and the potential alleles are enumerated by finding
all maximal paths from source to sink. The number of alleles
corresponds to the number of paths from source to sink, al—
though in reality there may be more possible paths than actual
alleles present in genomes.

The alleles (and their carrying organisms) are present in un—
known relative abundance. The sequencing depth for a single
allele in a complex bubble, reﬂecting its relative abundance, is
not trivial to find, as some nodes will be shared by two or more
paths, e.g. node 5 in Figure 2a is shared by three paths between
nodes 10 and 11. We infer the allele depth from the read depth of
the contigs in its path, by minimizing the difference between the
sum of the depths of the paths j that cross a node i and its read

depth d,- for all node i = {1, .. , n} using a non—negative linear least
squares approach. The residual of node i for paths j = {1, .. ,m}
in a multi—allele a then is

’1': d1 — 2X05} (1)
.i
where X is the design matrix with binary regressors

1 ath 'crosses node i
X111 = { p J (2)

0 otherwise

and ﬂu is an m times 1 vector with the unknown path weights.
The least squares method then ﬁnds path weights ﬂu that min—
imize the sum of the squared residuals

S =  r? (3)
i=1

under the constraint that the allele read depths in B are positive.

2.4.1 Measure of variation between alleles To quantify the
extent of the genomic difference in a bubble, we use a normalized
version of the Levenshtein distance (or edit distance), summariz—
ing the sequence distances of the alleles in a bubble. The average
distance D M is obtained by calculating the Levenshtein distance
lev(s, t) for each pair of alleles s and t in a multi—allele M with N
alleles and normalizing for the maximum length of the two alleles

_ N 71 lev(s, t)
W _ (2) Z maxusl, 111) (4)

S,t,S<t

3 METHODS

Most of the MARYGOLD algorithm is implemented in C++, with some
additional Python scripts. The algorithm interfaces with the AMOS bank,
where Bambus 2 and metAMOS store their assembly and scaffold infor-
mation, using the AMOS library (Treangen et al., 2011). The graph
decomposition in bi- and triconnected components uses the Open
Graph Drawing Framework (Chimani et al., 2007). The multi-allele
search algorithm is parallelized using OpenMP (Dagum and Menon,
1998). The non-negative least squares solver from the SciPy optimization
package is used to obtain sequencing depths for the individual alleles,
which is a wrapper around Fortran code (Lawson and Hanson, 1974).
Two shotgun datasets were simulated with the 454sim v1.04 package
(Lysholm et al., 2011) using default settings from the genomes of three
respectively seven Escherichia coli strains, to illustrate the effect on meta-
genome assembly of multiple closely related genomes. Four real sequen-
cing datasets from the public domain were used to demonstrate the

 

2829

ﬁre'spzumoiproyo'sopnuHOJmorq/pdnq

J.F.Nijkamp et al.

 

comparative metagenomics functionality of MARYGOLD. The ﬁrst was
obtained from the microbiome of a premature infant. Morowitz et al.
(2011) sequenced the genomic DNA of the fecal microbiome, sampled on
days 10, 16, 18 and 21 of the infant’s life. The second dataset was ob-
tained at 10 different time points during the 29-day fermentation process
of kimchi, the traditional Korean food (Jung et al., 2011). Both datasets
are well suited for comparative metagenomics, as we can compare the
metagenomes of the different time points. Finally, two sequencing data-
sets generated from samples obtained from the Richmond mine location
C75 (Denef and Banﬁeld, 2012) were downloaded from the Sequence
Read Archive to compare performance on low coverage, but long 454
reads (SRA:SRR358990, 454 Titanium FLX, 133M bases) versus high
coverage, but shorter Illumina reads (SRR359000, Illumina HiSeq2000
3.6G bases, 100 bp/read).

Assemblies were performed within the metAMOS v1.1 package
(Treangen et al., 2013) using the Newbler v2.6 assembler (Roche,
Branford, CT). Newbler was run with parameters ‘-a 0 -m -ace’.
Additionally, the ‘-large’ parameter was added for the assembly of the
Illumina datasets to speed up the processing of the fragment assembly
graph. Assigning taxonomic attributions was performed using the
Fragment Classiﬁcation Package v1.0 (Parks et al., 2011). Circular
plots were generated with Circos v0.63 (Krzywinski et al., 2009), and
graph layouts were performed with Cytoscape v2.8.3 (Shannon et al.,
2003). The DAVID functional annotation tool (Huang et al., 2009) was
applied on the genes in the kimchi sample that overlapped with the multi-
alleles to ﬁnd enrichment of functions and sequence features. DAVID
was run with default settings, except that all predicted genes in the meta-
genome were used as background.

Performance was analyzed and compared with that of Bambus 2 based
on the contig graphs of the simulated E.coli metagenomes. Ground-truth
variation calls were obtained by aligning the K12 strain to each of the other
strains individually, using nucmer [Mummer (Delcher et al., 2002)].
Subsequently, nucleotide variations were obtained using show-diff.
Gapped alignments (labeled ‘GAP’) represent variation that could poten-
tially lead to bubbles in the contig graph. Results from individual com-
parisons between K12 and all other strains were merged into a single list.
Overlapping variation calls were merged. Next, MARYGOLD variation calls
were related to a position on the K12 genome by aligning the source and
sink node to its genome sequence. Bambus 2 variation calls were generated
in FASTA format by the OutputMotifs program. Regions with the header
‘REPLACE_RANGE’ were extracted and aligned to the K12 genome to
assign a genomic position to the variation call. Sensitivities were calculated
as (100 >< number of Mummer calls that overlap with a MARYGOLD bubble /
number of Mummer calls). Precision was calculated as (100>< number of
MARYGOLD bubbles that overlap with a Mummer call/number of
MARYGOLD bubbles that mapped to the K12 genome). These calculations
were made likewise for the Bambus variation calls.

Performance of MARYGOLD and Bambus 2 was also compared on the
bioﬁlm data. For Bambus 2, the OrientContigs program was run fol-
lowed by OutputMotifs to output all multi-allelic regions. We then
counted the number of bubbles and the number of contigs they contain.
Bubbles were considered to overlap between the two methods if they
shared at least three contigs.

4 RESULTS

4.1 MARYGOLD ﬁnds multi-allelic regions by detecting
bubbles in the contig graph

The bubbles MARYGOLD detects are multi—allelic sites in the

metagenome, meaning that for the genomic regions represented

in the bubble, multiple alleles are present in the sample.

Morowitz et al. (2011) resolved the bubbles in the assembly

graph by manual curation. This was possible because only two

 

Fig. 4. Largest connected components of the contig graphs for two simu-
lated sequencing datasets for (a) three and (b) seven E.coli genomes

Table 1. Assembly statistics for two simulated E.coli and two real meta-
genomics datasets

 

 

Sample Number Number of Number of
of contigs multi-alleles contigs after
simpliﬁcation
Three E.coli strains 3445 387 2185
Seven E.coli strains 12 378 1582 6156
Kimchi fermentation 11 466 133 11 325
Infant microbiome 5686 154 5251

 

Citrobacter strains were present, and therefore only bi—allelic
bubbles had to be resolved. Our simulation experiments conﬁrm
that for a low number of strains, the contig graph is rather simple
and bubbles can be resolved manually (Fig. 4a). If more strains
are present, such as shown in our simulation experiment with
seven E.coli genomes, the graph becomes too complex for
manual curation (Fig. 4b).

MARYGOLD detected 387 and 1582 bubbles in the simulated
sequencing samples with three respectively seven strains (Table
1).The number of bubbles does not increase linearly with the
number of strains, which is expected. If two genomes A and B
differ at a locus, creating a bubble, then a third genome C that is
again different at that locus will not result in an additional
bubble, but just an additional path from source to sink within
the bubble. Only at already present loci where A and B are iden—
tical, but C is different, the addition of genome C will result in an
additional bubble.

In the premature infant datasets, 154 bubbles were found
(Table 1), predominantly in Citrobacter spp. (Fig. 5), as also
described in the original article (Morowitz et al., 2011). In the
original study of the kimchi fermentation, no allele variation
study was performed. Here we show that allele variation is pre—
sent by detecting 133 bubbles in Lactobacillus spp., Leuconostoc
spp. and Weisella spp. (Fig. 6), which are thought to be the key
players in this vegetable fermentation process (Jung et al., 2011).

4.2 Bubble collapsing allows studying genetic variation in
genomic context

In the contig graph, contigs can be reliably concatenated into
longer contiguous sequences, if they are connected by a simple

 

2830

ﬁre'spzumoipmpo'sopeuHOJmorq/pdnq

1
1 111 111111111 111 1 111 11111,,
11 111
1

- I III! a m ,0
’ Ill/[I
l l I I I / I I ’ I, I, I,
111 u ‘ I I I,
11 ‘
,1
M111“
1
111 .
“1
.1
1\\\‘“
11
1\ \

l..-

 
   

 

 

 
 
 

   
  

        

/ a’l/
III,
“"11",”

my

      

H

Um ,,,

Ill

in 11111 11

111111
111 .
1111 11

1111 11

l

-\!‘/,,
1111/1 I

 

'an1
1019”-

f .IOJXO'SOIJBIIIJOJII.

' Burnqp

/810 S[

 

N w“am lulu-w.
\w ‘
10“

 \3 . \ . \e
"40 \‘Y x
 ﬂ!!! \\ \V‘“ 
” Minimum  1

  

/3.IO'S[BIIm0[p.IOJXO'SOIJBIIIJOJIIIOIq/ﬂdnq

Exploring variation-aware contig graphs

 

Table 2. Variation detected by Bambus 2 and MARYGOLD in simulated
metagenomes compared with variation found by alignments of individual
ﬁnished genomes to the E.coli K12 reference genome

 

 

Measure Mummer Bambus 2 MARYGOLD
Three E .coli
Number of calls 250 32 312
Sensitivity 2.0% 16.8%
Precision 15.6% 13.1%
Fl-score 3.5% 14.7%
Seven E.coli
Number of calls 1177 114 1130
Sensitivity 6.7% 28.7%
Precision 30.7% 12.6%
Fl-score 11.0% 17.5%

 

Note: The number of Bambus 2 and MARYGOLD calls is the number of bubbles that
mapped to the K12 genome.

(a) BambusZ MaryGoId (b) BambusZ MaryGoId
104 328
(8) (69/84)

Fig. 7. Comparison of the number of bubbles found by MARYGOLD and
Bambus 2 for two acid mine drainage datasets: (a) the 454 dataset
(SRR358990) and (b) the Illumina dataset (SRR359000). Indicated is
the total number of contigs within the bubbles, with the number of bub-
bles between brackets

31 191 nodes and 9586 edges of the Illumina acid mine drainage
dataset, using an Intel Xeon CPU with four cores and four
threads per core. Finding the set of separation pairs using
graph decomposition took ~37 s (CPU time). The subsequent
bubble search algorithm took ~12.5 min on a single core. Using
two threads, the wall clock time spent by the bubble search al—
gorithm dropped by 42%. The full analysis, from raw reads to
MARYGOLD output, is mostly limited by the assembly step.

5 CONCLUSON

We presented MARYGOLD, a tool to detect and explore genomic
variation within and between metagenomic sequencing samples,
not reliant on reference genomes. MARYGOLD ﬁnds multi—allelic
regions that reﬂect sequence variation and improves the contigu—
ity of assemblies by collapsing these. As input, it expects a contig
graph, which makes it generic and applicable to any type of
sequencing data; we demonstrated the algorithm both on 454
and Illumina data. Here we generated contig graphs using links
from fragment assembly string graphs, but the graphs can be
extended using edges derived from other sources such as
paired—end sequencing data, de Bruijn graphs or even reference
genomes. Multi—allelic regions are efﬁciently detected by search—
ing for bubble structures in the contig graph, enabled by its
decomposition into bi— and triconnected components. Although
MARYGOLD can detect local sequence variation, i.e. multiple
alleles of a genomic locus, it ignores variation that not does

not result in a detectable bubble, such as duplications and trans—
locations, i.e. due to horizontal gene transfer.

Sequence variation in metagenomes and in particular between
metagenomes, i.e. comparative metagenomics, is still a largely
unexplored field. Our algorithm not only finds sequence vari—
ation within a single metagenomic sample but also between sam—
ples, and it allows for convenient visualization and interpretation
of variation of even multiple metagenomic sequencing samples.
The importance of sequence variation detection in metagenomes
was demonstrated by ﬁnding variability in ABC transporters
that are involved in resistance to multiple drugs in the kimchi
sample and variability in bacterial cell surface proteins that bind
to human Ig in the infant’s microbiome. Comparing data
sampled at different time points in the infant’s microbiome
showed varying relative abundance during the early colonization
of its gut, suggesting competition between closely related strains
until a stable composition is reached.

As sequencing gets cheaper, more assembly—grade metage—
nomics sequencing datasets become available. It will soon be
possible to compare cohorts of samples and detect sequence—
level difference in microbiomes or other environmental samples
explaining speciﬁc phenotypes, and link the meta—genotypes to
disease. The development of tools, such as MARYGOLD, that ﬁnd
this sequence variation and allow further analysis and interpret—
ation is essential for effectively mining the metagenomics sequen—
cing data.

Funding: This work was funded by Kluyver Centre for Genomics
of Industrial Fermentation, a subsidiary of the Netherlands
Genomics Initiative. The project was initiated during a visit of
J .F.N. to the laboratory of MP, supported by an EMBO short—
term fellowship.

Conﬂicts of Interest: none declared.

REFERENCES

Battista,G.D. and Tamassia,R. (1989) Incremental planarity testing (extended
abstract). In: 30th International Symposium on Computer Science. Research
Triangle Park, NC, USA, pp. 436441, October 30—November 1, 1989.

Chimani,M. et al. (2007) The open graph drawing framework. In: 15th International
Symposium on Graph Drawing. Sydney, Australia, September 23—26, 2007
(Poster).

Dagum,L. and Menon,R. (1998) OpenMP: an industry standard API for shared—
memory programming. Comput. Sci. Eng. IEEE, 5, 4&55.

Davidson,A.L. et al. (2008) Structure, function, and evolution of bacterial ATP—
binding cassette systems. Microbiol. Mol. Biol. Rev., 72, 3177364. Table of
contents.

Delcher,A.L. et al. (2002) Fast algorithms for large—scale genome alignment and
comparison. Niwleic Acids Res, 30, 247872483.

Denef,V.J. and Banﬁeld,J.F. (2012) In situ evolutionary rate measurements
show ecological success of recently emerged bacterial hybrids. Science, 336,
462466.

Dutilh,B.E. et al. (2012) Reference—independent comparative metagenomics using
cross—assembly: crAss. Bioinﬁ)rmatics, 28, 322573231.

Fasulo,D. et al. (2002) Efﬁciently detecting polymorphisms during the fragment
assembly process. Bioinformatics, 18 (Suppl. 1), SZ9¢S302.

Gutwenger,C. and Mutzel,P. (2001) A linear time implementation of SPQR—trees.
In: Graph Drawing. Springer, pp. 77790.

Hess,M. et al. (2011) Metagenomic discovery of biomass—degrading genes and gen—
omes from cow rumen. Science, 331, 463467.

Huang,D.W. et al. (2009) Systematic and integrative analysis of large gene lists
using david bioinformatics resources. Nat. Protoc., 4, 44ﬁ57.

 

2833

ﬁre'spzumol‘proyo'sopnuHOJmorq/pdnq

J.F.Nijkamp et al.

 

Human Microbiome Project Consortium. (2012) Structure, function and diversity of
the healthy human microbiome. Nature, 486, 2077214.

Iqbal,Z. et al. (2012) De novo assembly and genotyping of variants using colored de
bruijn graphs. Nat. Genet., 44, 22G232.

Jung,J.Y. et al. (2011) Metagenomic analysis of kimchi, a traditional Korean fer—
mented food. Appl. Environ. Microbiol, 77, 226442274.

Koren,S. et al. (2011) Bambus 2: scaffolding metagenomes. Bioinformatics, 27,
2964e2971.

Krzywinski,M. et al. (2009) Circos: an information aesthetic for comparative gen—
omics. Genome Res., 19, 163971645.

Kundeti,V.K. et al. (2010) Efﬁcient parallel and out of core algorithms
for constructing large bi—directed de Bruijn graphs. BMC Bioinformatics, 11,
560.

Lawson,C.L. and Hanson,R.J. (1974) Solving Least Squares Problems. Vol. 161,
Prentice—Hall, Englewood Cliffs, NJ, USA.

Li,Z. et al. (2012) Comparison of the two major classes of assembly algorithms:
overlap—layout—consensus and de—bruijn—graph. Brief. Funct. Genomics, 11,
25737.

Lysholm,F. et al. (2011) An efficient simulator of 454 data using conﬁgurable stat—
istical models. BMC Res. Notes, 4, 449.

Medvedev,P. et al. (2009) Computational methods for discovering structural vari—
ation with next—generation sequencing. Nat. Methods, 6, 5137820.

Morowitz,M.J. et al. (2011) Strain—resolved community genomic analysis of
gut microbial colonization in a premature infant. Proc. Natl Acad. Sci. USA,
108, 112871133.

Myers,E.W. (2005) The fragment assembly string graph. Bioinformatics, 21
(Suppl. 2), ii79<ii85.

Nielsen,R. et al. (2011) Genotype and SNP calling from next—generation sequencing
data. Nat. Rev. Genet., 12, 443451.

Parks,D.H. et al. (2011) Classifying short genomic fragments from novel lineages
using composition and homology. BMC Bioinformatics, 12, 328.

Peng,Y. et al. (2011) Meta—IDBA: a de novo assembler for metagenomic data.
Bioinformatics, 27, 1944101.

Qin,J. et al. (2010) A human gut microbial gene catalogue established by metage—
nomic sequencing. Nature, 464, 5945.

Sacomoto,G.A.T. et al. (2012) Kissplice: de—novo calling alternative splicing events
from RNA—seq data. BMC Bioinformatics, 13 (Suppl. 6), SS.

Sandt,C.H. and Hill,C.W. (2001) Nonimmune binding of human immunoglobulin
A (igA) and igG Fc by distinct sequence segments of the EibF cell surface
protein of Escherichia coli. Infect. Immun., 69, 729377303.

Schloissnig,S. et al. (2013) Genomic variation landscape of the human gut micro—
biome. Nature, 493, 45750.

Shannon,P. et al. (2003) Cytoscape: a software environment for integrated
models of biomolecular interaction networks. Genome Res., 13, 2498r2504.
Treangen,T.J. et al. (2011) Next generation sequence assembly with AMOS. Curr.

Protoc. Bioinformatics, Chapter 11, Unit 11.8.

Treangen,T.J. et al. (2013) MetAMOS: a modular and open source metagenomic
assembly and analysis pipeline. Genome Biol, 14, R2.

Turnbaugh,P.J. et al. (2009) A core gut microbiome in obese and lean twins. Nature,
457, 480—484.

Weiskircher,R. (2002) New applications of SPQR—trees in graph drawing. PhD
thesis, Universitat des Saarlandes, Saarbru'cken, Germany.

Zerbino,D.R. and Birney,E. (2008) Velvet: algorithms for de novo short read
assembly using de bruijn graphs. Genome Res., 18, 8217829.

 

2834

ﬁre'spzumol‘pmjxo'sopauuqurorq/pdnq

