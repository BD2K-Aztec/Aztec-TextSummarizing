Bioinformatics, 32(14), 2016, 2159—2166

doi: 10.1093/bioinformatics/btw223

Advance Access Publication Date: 29 April 2016
Original Paper

 

 

Systems biology

APPAGATO: an APproximate PArallel and
stochastic GrAph querying TOol for biological
networks

Vincenzo Bonnici1, Federico Busato1, Giovanni Micalez,
Nicola Bombieri1, Alfredo Pulvirenti3 and Rosalba Giugno1'3'*

1Department of Computer Science, University of Verona, Strada Le Grazie 15 - 37134, Verona, 2Department of Math
and Computer Science, University of Catania, Viale a. Doria 6 - 95125, Catania and 3Department of Clinical and
Experimental Medicine, University of Catania, via Palermo, 636 - 95122, Catania

*To whom correspondence should be addressed
Associate Editor: Alfonso Valencia

Received on October 20, 2015; revised on March 7, 2016; accepted on April 10, 2016

Abstract

Motivation: Biological network querying is a problem requiring a considerable computational ef—
fort to be solved. Given a target and a query network, it aims to find occurrences of the query in the
target by considering topological and node similarities (i.e. mismatches between nodes, edges, or
node labels). Querying tools that deal with similarities are crucial in biological network analysis be—
cause they provide meaningful results also in case of noisy data. In addition, as the size of available
networks increases steadily, existing algorithms and tools are becoming unsuitable. This is rising
new challenges forthe design of more efficient and accurate solutions.

Results: This paper presents APPAGATO, a stochastic and parallel algorithm to find approximate
occurrences of a query network in biological networks. APPAGATO handles node, edge and node
label mismatches. Thanks to its randomic and parallel nature, it applies to large networks and,
compared with existing tools, it provides higher performance as well as statistically significant
more accurate results. Tests have been performed on protein—protein interaction networks anno—
tated with synthetic and real gene ontology terms. Case studies have been done by querying pro—
tein complexes among different species and tissues.

Availability and implementation: APPAGATO has been developed on top of CUDA—C ++Toolkit
7.0 framework. The software is available online http://profs.sci.univr.it/~bombieri/APPAGATO.
Contact: rosalba.giugno@univr.it

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 IntrOducuon of genes is regulated; (iii) metabolic networks describing biochem—

9103 ‘Og JSanV 110 seleﬁuv soc] ‘BtHJOJtIBQ 30 AJtSJQAtuf] 112 /310'S[BIIJDO[pJOJXO"SOTJBHIJOJIITOlq/ﬂdnq 11101} popcolumoq

Technological advances have led to the inference and the validation
of structured interaction networks involving genes, proteins, drugs,
phenotype and diseases (Barabasi and Oltvai, 2004; Kelley et (11.,
2003; Panni and Rombo, 2015). According to the data type, such
networks are referred to as (i) protein—protein interaction (PPI) net—
works representing either physical or functional interactions among
proteins; (ii) gene regulatory networks that express how the activity

ical reactions between chemical compound of cells; and (iv) signal—
ling networks representing inner/outer cell communications.

A typical example that highlights the advantages and possibilities
of analysing interaction relationships is protein function prediction.
Although sequence homology is commonly used to functionally an—
notate proteins, a great amount of them remained uncharacterized
(Yu et (11., 2013). In this context, different algorithms and tools that

©The Author 2016. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 2159

2160

V. Bon nici et aI.

 

compare biological networks have been applied to predict novel pro—
tein functions (Jiang et al., 2011; Malod—Dognin and Priulj, 2015;
Wang et al., 2013).

In disease studies, genes showing similar phenotypes tend to be
neighbours in protein interaction networks and their aggregation in
connected sub—networks is effective to detect biomarkers (Creixell
et al., 2015; Fortney et al., 2010; Ideker et al., 2002). Also, finding
similar functional and topological sub—networks helps analysing the
conservation among species (Lim et al., 2006). In all these applica—
tions, graphs serve as the underlying structures for representing bio—
logical networks (For the sake of clarity, in this article, we use the
terms graph and network indistinctly.) and graph algorithms solve
problems such as network alignment, network querying, motif ex—
tractions and network perturbation (Ciriello et al., 2012; Ma and
G30, 2012; Malod—Dognin and Priulj, 2015; Panni and Rombo,
2015

In this article we address the problem of approximate network
querying, which finds, in a target network, similar occurrences of a
so—called query network. The notion of similarity takes into account
both the similarities between target nodes and query nodes, and a
cost measuring the differences of nodes and their connections. An
approximate network querying algorithm has to find the query oc—
currences, among all possible, with the maximum combined
similarity.

Querying tools that deal with similarities are effective in biolo—
gical network analysis because they provide results also in case of
noisy data. They are also suitable in the case of partial knowledge of
users when formulating queries. Furthermore, they can be used to
compare data from different species where some fundamental and
functional structures are partially preserved.

Solving approximate network querying implies applying in—
stances of subgraph isomorphism, which is a NP—complete problem
(Dost et al., 2008). In literature, several heuristics have been pro—
posed to solve such a problem in reasonable running time. Examples
include restricting the topology of queries to paths or trees (Dost
et al., 2008; Kelley et al., 2004; Pinter et al., 2005; Shlomi et al.,
2006), applying network alignment strategies (Gulsoy and Kahveci,
2011; Tian et al., 2007, 2008; Yuanyuan and Patel, 2008), dealing
with node similarities and ignoring the query topology (Blin et al.,
2010; Bruckner et al., 2010), fixing the topology and computing dif—
ferences of node labels (Hong et al., 2015). Other methods consist
of building indexes to reduce the query time (Khan et al., 2013;
Zhang et al., 2009); filtering the set of possible similar target data
(Hong et al., 2015; Pienta et al., 2014; Sahraeian and Yoon, 2012);
to find only exact occurrences of the query in the network (Bonnici
and Giugno, 2016; Bonnici et al., 2013; Cordella et al., 2004; Sun
et al., 2012); finding the largest part of the query exactly contained
in the target graph and replace the query edges not present in the tar—
get with paths (Pienta et al., 2014).

We have created APPAGATO, a tool that relies on an iterative
sampling method (Lawrence et al., 1993; Micale et al., 2014), to
compute functional and topological similarities between a query and
a target network. Through a matching probability matrix and a
weighted sampling procedure, it selects a seed from which the
query—target matching starts. Then, by associating a cost to each ap—
proximation, it iteratively extends the match by selecting the ap—
proximations with the lowest possible cost. The algorithm runs K
times and returns a set of K approximate matches. APPA GATO per—
forms approximate network querying by considering the topology
of query, taking into account node and edge deletions together with
differences on node labels.

To speed—up the querying process in large biological networks,
APPAGATO has been implemented to run on graphics processing
units (GPUs). Owing to their low cost, high—performance and easy
integration to any personal computer, GPUs have been increasingly
applied to accelerate bioinformatics problems (Dematté and Prandi,
2010; Vouzis and Sahinidis, 2011; Zhao and Chu, 2014). Our aim
is to handle large biological networks in a reasonable time yielding
accurate results. We compare APPAGATO with RESQUE
(Sahraeian and Yoon, 2012) and NeMa (Khan et al., 2013) because,
to the best of our knowledge, they are the most efficient and stable
tools in literature close to APPAGATO on both the problem they
address and on the approximation concept they assume. We run the
tools with different PPI networks as input and compared nodes by
using similarities of protein sequences and functional gene ontology
annotations. We extensively compare the tools in terms of running
time, costs of returned matches and accuracy in finding protein com—
plexes among different species. The results show that APPAGATO
outperforms the other two tools, yielding more accurate results on
large PPI networks.

2 Materials and methods

2.1 Definitions and notations

A graph G is a pair (V, E), where V is the set of nodes and E
E (V X V) is the set of edges. If (u,v) E E, we say that v is a neigh—
bour of u. G is undirected iffV(u,1/) E E, then (v,u) E E, i.e. u is a
neighbour of v and vice versa. The degree of a node u, Deg(u), is the
number of its neighbours. Given a set of labels A, the function Lab
: V —> A assigns a label to each node of G. We assume that graphs
are undirected and labelled only on nodes.

2.1. 1 Exact SubGraph Isomorphism

Let Q : (V,E) and T : (V’,E’) be two graphs, named query and
target, respectively. The exact SubGrap/o Isomorp/oism (SUBGI)
problem aims to find an injective function, M : V —> V’,
which maps each node in Q to a unique node in T, such that
you») 6 E: (i) (M(u),M(v)) e E’; (ii) Lab(u) : Lab(M(u)); (iii) La
b(v) : Lab(M(1/)). A solution of the SUBGI problem can be repre—
sented as the set m : {(1/1,M(v1)), (U2,M(v2)), . . . , (U(V(,M(U(V())},
called a mate/7 of Q in T. Q may have different maps m,- in T.

2.1.21nexact SubGraph Isomorphism and matching costs

In this article, we deal with the Inexact SubGrap/o Isomorp/oism
(ISUBGI) problem (Here called also approximate subgraph quer—
ying.), which is a variant of the SUBGI problem, and in which we
admit node and edge mismatches. A mismatch occurs when (i) two
nodes with different labels are mapped through a similarity func—
tion, or (ii) a query edge or (iii) a query node is missing in the target
graph. The absence of a node implies mismatches for all its edges. A
cost 6 is associated to each mismatch. For the sake of simplicity, the
same cost 6 : 1 is associated to each of the three types of mismatch.

We denote with C : 26 the total cost of mismatches between
Q and T. The goal of the ISUBGI problem is to find an injective func—
tion M : V —> V’, such that C is minimized. In this case, a solution
for the ISUBGI, m : {(1/1,M(v1)), (U2,M(v2)), . . . , (vk,M(1/k))} with
k S )V), is called an approximate mate/7 with a cost C 2 0.

Let Qm : (Vm,Em) be the subgraph of query Q that has been
mapped in the match m, that is, Vm : {v E V : (U,M(v)) E m} and
Em : {(u,v) E E :  E m(v,M(1/)) E m  E E’}.
We define Vm : V\Vm and Em : E\Em, the nodes and the edges in
Q, respectively, that have not been matched in m. Let Swmw be the

9103 ‘Og JSanV 110 seleﬁuv soc] ‘BIIIJOJIIBD JO AJtSJQAtuf] 112 /310'slcu1n0fp103x0"sotJBuiJOJutotq/ﬁduq 11101} popcolumoq

Parallel and stochastic search

2161

 

label similarities between each node q E Q and t E T. The label simi-
larity values belong to the interval [0, 1]. The computation of S is ap—
plication dependent. In the case of PPI networks, the similarity can be
based on sequences, functional or structural protein similarity.

For example, establishing the conservation of a protein—complex
C0 of the species A within the species B consists of searching the
subgraph QCO, extracted from the PPI of A (named GA), into the
PPI of B (named GB). The two PPIs may have different proteins (i.e.
nodes with different names), but with similar function, detectable by
looking at sequence similarities. An ISUBGI algorithm must search
for occurrences of Qco in G B that minimize sequences and topology
differences. We conclude that CO is conserved in B if we find highly
similar occurrences.

The total matching cost C is obtained by summing all node and
edge costs and by normalizing them over the number of query elem—
ents, as follows:

C = 2(1 -S(q7M(q)) + lVﬁll + lEﬁll)

qEVm

 

M + lEl

2.2 The APPAGATO algorithm

The method consists of the following three main phases.

2.2.1 Phase 1: Computation of matching probability matrix

Before starting the search, APPAGATO computes a matrix P of
matching probabilities between all possible node pairs < q,t >
(q E Q and t E T), by combining (i) the label similarity S(q, t), (ii)
the degree similarity D(q, t) and (iii) the breadth—first similarity
BFSs,m(q, t). The label similarity has been defined in Section 2.1.2.
In APPAGATO, the label similarity matrix, S, may be provided as
input by the user. Alternatively, APPAGATO computes a Boolean
similarity function to compare node labels. It assigns 1 if labels are
identical, 0 otherwise. The degree similarity is a binary function
D(q,t) : 1 if Deg(q) g Deg(t), otherwise it is 0. BFSs,m(q, t) is com—
puted by performing breadth—first visits (BFSs) of the query and tar—
get graphs by starting from q and t and evaluating label and degree
similarities of the visited nodes, level by level. The maximum depth
of the BFS visits is a user—defined parameter lmax, with lmax Z 1.
Given a node x, and a level I S lmax we denote with BFS[(x) the set
of nodes at level I in the BFS tree rooted at x. An edge e : (u,v) in
the BFS tree of q is defined matcbable iff there exists an edge
e’ : (u’, 11’) in the BFS tree of t such that S(u, u’) and S(v, 11’) are not
0 and D(u,u’) : D(v,v’) : 1. We denote with MaxMatcb(BFS[(q),
BFS[(t)) a maximal set of matchable edges in the BFS tree of q at
level I, with respect to the BFS tree of level I rooted in t. The BFS
similarity between q and t assumes values in [0, 1] and is defined as
follows:

[max

Z] X lMaxMatcb(BFSl(q), BFS;(t))l
MSW,» : ’:1 (2)

1m
21x lBFSz(q)l
[:1

 

Matching probability matrix. The three similarity values are lin—
early combined in MScore(q, t) : S(q, t) + D(q, t) + BFSs,m(q, t)
and normalized to get the matching probability:

MScore(q, t)

P(qvt) 2% (3)

ZET

Equation (3) ensures that ZtET P(q, t) : 1. In phase 2, the prob—
ability matrix is used as a transition matrix within an iterative sam—
pling to extract the best possible matches. The upper side of Figure 1
shows an example of such a matrix computation.

2.2.2 Phase 2: Seed selection

APPAGATO searches the first pair of nodes to be matched by ran—
domly selecting q and t according to the probabilities defined in
Equation (3) (see the example of Figure 1).

2.2.3 Phase 3: Extension

Gibbs sampling is used to navigate within a Markov chain, where
each state represents a possible query—target node match. The ini—
tial state corresponds to the seed selected in phase 2. The sampling
method iteratively performs a transition from a state to another,
by replacing the query—target nodes pair with a new one, accord—
ing to a properly defined transition probability. As an example,
Figure 1 shows the first two iterations of the extension phase.
Transition probabilities are defined by starting from similarity
scores, and by taking into account the connections of candidate
nodes with already matched nodes. Let Qm and Tm be the set of
query—target matched nodes at a certain step of the extension pro—
cess. We denote with  (Tmlil) the i—th query (target) node
added to the partial match. Let q be a query node neighbour to at
least one node in Qm and t be a target node neighbour to at least
one node in Tm. We represent the set of connections between q and
the nodes in Qm through a bit vector CP(q) of  elements,
called connection profile of q, where the i—th element is defined as
follows:

CP(q)lil =

1 if , m' E
{ (quzl)E (4)

0 otherwise

v0, v0, v52 W: v“.1
v'o 0.11r 0.2 0.24 0.16 0.26
v" 0.1?r 0.39 0.2-1 0.1: 0.11
v12 0 0.2 0.28 0.12 0.11
Mg 0.115 0.16 0.17 0.2! 0.11
vT‘ 0.21 0 a 0.2-! 0.11

 

W5 0 0.05 0.0? 0.12 0.3
Matching Probability PMWI

 

 

 

= S + D + BFSSM
Query 0 Target T
(random selecting (Gibbs samuling
oloamecrionsl ormcobns; Query Q Target T
(ram sanction} (ammo according :0
PH“! 3 pmbahlﬂias in P}

 

 

 

 

 

 

 

 

(Smut: sath Query 0 Taugeﬂ
of connections}

 

 

 

 

 

 

Fig. 1. The APPAGATO approximate matching algorithm

91oz ‘Og JSanV 110 seleﬁuv 50’] 0211110311123 JO AJtSJQAtuf] 112 /310'slcujnofp103x0"sotJBuiJOJutotq/ﬁduq 11101} popcolumoq

2162

V. Bon nici et aI.

 

We define CP (t) in the same way. The connection profile similar-
ity between q and t is the corresponding number of equal bits in the
connection profiles of q and t:

I l{1 S i S lCP(q)l I CP(q)lil I CP(t)lil}l
lCP(q)l
The overall similarity score is MScoreExt(q, t) :

S(q,t) >< CPs,m(q,t). The result value is normalized to obtain the
final transition probability (Notice that MScore is not used in the ex—

 

CPsrm(q, t) (5 )

tension phase. MScoreExt strongly influences the convergence of the
approach (Lawrence et al., 1993; Micale et al., 2014).):

i MScoreExt(q, t)
Z MScoreEx t(q, z)

ZET

PT(q7t) 

After a number of iterations, n, which is a user—defined param—
eter, the algorithm returns the reached match between the query and
the target node. The quality of such a match is evaluated by sum—
ming the costs of node and edge mismatches between Q and T.
APPAGATO does not require any user—defined threshold for the
maximum allowed cost of a match. In Figure 1, the approximate
match has only a label mismatch, 11;”), whose label C is mapped with
112; having label D, and the cost of the match is C: 0.1, computed
by applying Equation (1). APPAGATO iterates K times phases 2
and 3 and, in each iteration, it starts the sampling procedure from a
different seed. Each run of APPAGATO always returns K solutions
(approximate matches), each one with the corresponding cost.

2.3 The APPAGATO parallel implementation for GPUs
APPAGATO has been implemented to take advantage of massively
parallel GPU architectures. All the processing phases presented in
Section 2.2 have been implemented through different CUDA kernels
(http://www.nvidia.co.uk/object/cuda—parallel—computing—uk.html),
which are invoked by the best CPU. This allows performing the
most compute—intensive tasks of the search algorithm on the GPU
device. As for the parallel implementation paradigm for GPUs, each
kernel is executed in parallel by several blocks of threads. Thread
blocks spread and run concurrently and independently over stream-
ing multiprocessors. Threads of the same block efficiently cooperate
through fast shared memory and by synchronizing their execution
through extremely fast (i.e. HW implemented) barriers. Groups of

 

 

 

 

 

Thread blocks i
ll
1

l

l.
'l
\

l
oonsaaanao‘\)
BAADACBCDA 43'1me-

Sauroedestlnatlon xx
‘,

 

 

 

 

 

 

 

arrayclv‘D
Pat I] 90 D
A B C D m ‘ [H
A u. 1. 1 1 "'---.. K;[md=U15:- K‘irn0=125)
B 1 .0 -1 0 F
C 1 l. G 10 '
D ' - ,1” “no ‘“ l ““2 W3 “’4 Matching Probability PM“, on 1.0 1_8
1- 0 0 0 I DRAM—Globalmem. = s + 9+ apsm 0.1 in») 0...: 2-0
Source-destinaﬁon (‘01) Preﬁx-sum array “043
malrix 0hr"n

Fig. 2. The parallel search of APPAGATO on the GPU device

   
  
 
       

32 threads of the same block are called warps. Each warp executes
one kernel instruction at a time in parallel on different data (i.e. sin—
gle instruction multiple data—SIMD architecture) over the many
stream processors (cores) of the GPU device. A warp scheduler effi—
ciently switches between warps with the aim of hiding the latency of
thread accesses to the memory.

Given the query and the target graphs, Q and T, the three phases
have been implemented as follows (see Figure 2).

2.3.1 Phase 1: Parallel computation of matching probability matrix
Computing the matching probability matrix is one of the most
computation—intensive part of the whole algorithm. It requires )V)
X )V’) computations of Equation (3) and, in particular, O()V) + )V’))
BFSs over Q and T and the corresponding comparisons between the
visited edges (Equation (2)).

APPA GATO implements such a phase through a customized ver—
sion of BFS-4K (Busato and Bombieri, 2015), a parallel implementa—
tion of BFS for GPU architectures. BFS-4K relies on the concept of
frontier (Cormen et al., 2009) (i.e. a FIFO queue that contains the
nodes to be visited at each BFS iteration) to implement the graph
visit. Through the frontier—based visiting, BFS-4K allows Equation
(3) to be performed over two levels of parallelism: Each parallel
warp of a block is mapped to each node of the frontier, and each
parallel thread of a warp is mapped to each outgoing edge from a
frontier node.

APPAGATO extends the BFS visit over a third level of parallel—
ism, by running a total number of )V) + )V’ ) independent BFSs in
parallel, one for each node of Q and T. This is done by allocating
one block of threads per BFS. The block allocation is automatically
done at runtime. A total number of )V) thread blocks perform, in
parallel, )V) BFSs (of depth lmax) for the query graph. The result con—
sists of source—destination matrices, one per node, which are stored
in the global memory (the left—most side of Figure 2 shows an ex—
ample, assuming lmax : 2). Each matrix contains information on the
labels of such edges visited during the BFS from the node along lmax
levels. In the example of Figure 2, the V52 matrix contains informa—
tion on the edges of the first—level BFS (A — B, A — C, A — D) as
well as the edges of the second—level BFS (B — A, B — C, C — A, C — B,
D — A).

Similarly, and concurrently, a total number of )V’) thread blocks
perform the BFSs for the target graph. The result consists of a set of

 

Query 0 Target T

[axianﬁion steps based (extanaian shits based

on Gibbs sampling
ofomnscb'msj

on random selection
atmectlbnsj

 

 

 

 

Probability [0. 1]

 

 

 

 

 

91oz ‘Og JSanV 110 salaﬁuv 50'] 0211110311123 JO AJTSJQAtuf] 112 /310'S[BIIJHO[pJOJXO'SOIJ'BLUJOJIITOlq/ﬂduq 11101} papcolumoq

Parallel and stochastic search

2163

 

source—destination arrays, one per node, which are stored in the de—
vice sbared memory. This allows an extremely fast memory access
for the following comparisons between the generated node struc—
tures. The array data structure has been chosen, as it allows to repre—
sent in a more compact way the source—destination information of T
in the limited shared memory. In contrast, the matrix data structure
has been chosen as it guarantees a faster access to the source—destin—
ation information of Q, to be stored in the larger global memory.

Finally, (V l thread blocks compare, in parallel, their own
source—destination array stored in the local shared memory with all
the source—destination matrices in global memory. Such a data
structure organization over the GPU memory hierarchy allows the
complexity of Equation (3) to be reduced from O()V) >< )V’)) as for
the sequential algorithm, to a parallel complexity of 0(1). The result
of Phase 1 is the matrix PMxM, which is stored in the device global
memory (see centre part of Figure 2).

2.3.2 Phase 2: Parallel seed selection

APPAGATO emulates the Gibbs sampling to select the K seeds for
the successive extension phase. The emulation relies on two parallel
primitives, prefix-sum (Billeter et al., 2009; Harris et al., 2008) and
weighed random number generation (https://developer.nvidia.com/
curand), which are efficiently implemented in the literature for
GPUs. Given the similarity value of each query—target node pair pxy
of P‘V‘X‘VI‘, APPAGATO performs the parallel prefix—sum of such
values through )V) X )V’) threads (i.e. one thread per similarity
value). The result is a prefix—sum array, in which each element is
associated to a thread and the corresponding similarity value. As an
example, Figure 2 shows the prefix—sum array of four threads,
to1, tog, to3 and to4, having similarity value 0.1, 09,08 and 0.2, re—
spectively. The array elements have been depicted through different
sizes to better represent the corresponding similarity values. Then,
all the threads generate a random sequence of K values in the inter—
val [0,pry] (i.e. [0,2] in the example). The parallel primitive for
the random number generation allows the threads to share the gen—
eration seed and, as a consequence, to generate the same sequence of
random values. This allows the threads to concurrently recognize
whether the own boundaries in the prefix—sum array include any
randomly generated value. In the example, the sequence of random
values K1 : 1.25 and K2 : 0.15 leads to the pair of nodes (1109,11?)
and (1109, 11;) associated to threads t03 and t02, respectively, to be se—
lected for the extension phase.

2.3.3 Phase 3: Parallel extension

The extension phase has been implemented through primitives of
BFS, prefix—sum, weighed random number generation over different
levels of parallelism. As a first level, the K query—target nodes se—
lected in phase 2 are mapped to thread blocks (i.e. one pair of
query—target nodes per block). They are concurrently processed as
follows. Given a node pair (e.g. (1109, 11:) in Figure 2) the two nodes
are processed in parallel by two thread warps (second level of paral—
lelism). The two warps perform a one—step parallel BFS (third level
of parallelism) on Q and T, respectively, to visit the neighbour nodes
(i.e. candidate connections) of 1109 and 11;. The result is two frontiers
of neighbours (019, 1129, 11%} and {113, 11?, 11;, 11;} in the example).
One step of extension over Q performs through a random selection
of a node (connection) from the first frontier (1152 in the example).
For such a node, APPAGATO generates the connection profile
through a one—step parallel BFS. Such a connection profile strongly
affects the extension over T, which is performed as follows. Starting

from all the nodes of the second frontier, APPAGATO (i) runs one

step of parallel BFS (one per node), (ii) generates the connection pro—
files of the visited nodes and (iii) generates the connection profile
similarity of each of such nodes with the connection of Q. Through
an emulation of the Gibbs sampling similar to that implemented in
phase 2, APPAGATO selects the new connection for T. The algo—
rithm iterates over the new pair of nodes (i.e. connection of Q and
connection T) for a total number n : )V) iterations.

2.4 Datasets

Pbysical Interaction Networks. We used the PPI networks taken
from the STRING v10.0 databases (Szklarczyk et al., 2011) of three
species: Mus musculus, Homo sapiens and Danio rerio. These net—
works differ significantly in size (number of nodes and edges) and
density (i.e. the average number of neighbours per node). For each
network, we used up to 250 synthetic labels and gene ontologies an—
notation downloaded from BionNet (http://biodbnet.abcc.ncifcrf.
gov). This yielded 12 different PPIs (i.e. three species, each one
labelled in four different ways). We constructed the queries by ran—
domly extracting sets of 100 connected subgraphs, from each net—
work, by varying the size of the queries up to 128 nodes. In this
dataset, the similarities matrix S(V(x(vr((q, t) : 1 if Lab(q) : Lab(t),
otherwise is set to 0.

Functional Interaction Networks. The STRING database re—
ports, among two proteins and beside the direct physical inter—
actions used above, indirect functional relations such as structural
similarity, similarity between the transcript sequences encoding
them and functional correlations. It gives a score, ranging from 0
(namely no relation is known) to 999, which combines physical and
functional (i.e. co—expression data analysis) interactions. We con—
structed a second dataset by taking into account such a combined
score. We extracted four PPI networks related to the species
M.musculus, H.sapiens, D.rerio and Saccbaromyces cerevisiae. We
fixed the interaction score threshold at 998 to get few but highly
functional related interactions within each network. As queries, we
used 10 human protein complexes taken from the CORUM data—
base (Ruepp et al., 2010). Because CORUM only reports the set of
proteins belonging to a given complex, and not their interactions,
we reconstructed the topology of the complex by taking into ac—
count the interactions reported in the full STRING database with re—
spect to the H.sapiens species. Finally, we labelled target and query
nodes with the protein sequences. We computed the query—target
node similarities matrix S(V(X(VI(, by making use of CUDASW (http://
cudasw.sourceforge.net), which implements a parallel version for
GPUs of the Smith—Waterman algorithm for local alignment of se—
quences. We normalized the matrix by row to set to 1 the maximum
similarity of the target and query node. We used this dataset to in—
vestigate the biological significance of the results. The approximate
subgraph matching algorithms were capable to identify functional
conservation of protein complexes among different species. We refer
the reader to Supplementary Section 1 and Tables S1—S2 for more
details.

3 Results and discussion

We compared APPAGATO with NeMA (Khan et al., 2013) and
RESQUE (Sahraeian and Yoon, 2012) on both the physical and
functional datasets described in Section 2.4. All the tools solve
ISubGI by taking into account the query topology. Unless differently
specified, with the term APPA GATO we refer to its implementation
on top of CUDA. In the Supplementary, Section 2, we report details
on the APPAGATO implementation and tuning of parameters

9103 ‘01; JSanV 110 salaﬁuv 50'] 0211110311123 JO AJTSJQAtuf] 112 /310'slcumoip1q1x0"SOTJBuiJOJutotq/ﬁduq 11101} papcolumoq

2164

V. Bon nici et aI.

 

InPMGATO lNeﬂlll pmurocess'ng I NeMa 100k

15 18 Ta a
g .
‘1'
U
V a ‘3 a
g

m
32 64 250

a: 00

"Nine (580}
D- U1

Nb)

LDN
Hm

as

Fig. 3. The running time comparison between APPAGATO and NeMa on the
D.rerio PPI network, randomly labelled with 32, 64 and 250 labels. Chart val-
ues report the average time on 100 queries. Queries are grouped with respect
to the number of nodes, namely 4, 8,16, 32, 64, 128. For each query, the tools
have been run to find 10, 50 and 100 matches

(Supplementary Figs S1—S3), we assess the robustness of
APPAGATO over query construction (Supplementary Figs S4 and
S5) and the efficiency of both sequential and parallel versions of
APPAGATO (Supplementary Figs S6 and S7).

3.1 Performance

For the physical interaction networks, we report the comparison re—
sults only between APPAGATO and NeMA, as RESQ UE does not
support such a large dataset. Figure 3 shows the average running
times of the two tools on the D.rerio network. In the total running
time of NeMa, we distinguish the target preprocessing and the
querying time. Note that APPAGATO does not perform any prepro—
cessing step. The results show that APPAGATO is at least three
times faster than NeMA in case of small queries (i.e. 4, 8, 16 nodes).
The performance difference sensibly increases with larger queries.
The plots clearly show that the APPAGATO running time is almost
constant when increasing the query size and the number of labels.
We do not report the comparison results on M.musculus and
H.sapiens because, in those networks, the running time difference is
even more evident (i.e. NeMa requires >10 000 s for the preprocess—
ing phase and >6000 s for the execution phase, while APPAGATO
always requires around 2 5). Supplementary Figure S8 in Section 3
reports the details on the APPAGATO running time in all the phys—
ical interaction networks, by showing its efficiency varying the num—
ber of labels, query size and network size. Figure 4 reports the
comparison of APPAGATO with RESQ UE on the functional inter—
action networks. For the sake of clarity, we do not include the
NeMa results in the comparison because in this kind of networks,
RESQUE outperforms NeMa. The performance of RESQUE
mainly depends on the size of query and target and on the number
of possible candidates for each query node. RESQ UE requires, as an
input, a similarity matrix between query and target nodes. Such a
matrix can be partially defined and this affects the quality of the re—
sults. If the similarity matrix is fully defined, then the algorithm exe—
cution becomes infeasible (i.e. RESQUE takes hours for a single
query run). Therefore, we run several tests by changing the percent—
age of target nodes that can match to a specific query node. Given a
threshold t, we set all entries in the similarity matrix with values less
than t to 0 (i.e. making them not possible candidates). We then nor—
malized each row by the row maximum value. We chose the per—
centages 10%, 5% and 1% to obtain reasonable RESQ UE running

I APPAGATD l RESQUE
L000

100
10
0 —
1% 5% 10% 100%

Fig. 4. Running times of APPAGATO and RESQUE on the functional inter-
action networks. Results are grouped by the similarity thresholds. The run-
ning time of RESQUE highly depends on the number of target nodes that can
be matched with a query node (i.e. on the similarity threshold t)

11ml (sea) A 10990310

I APPAGATO I NeMa
1
0.9

,llllll llllll 

“wassg vwaasg “waasg

32 64 250

Average oust

DDDDDDDP
l-‘NLIJKUWO'IT-ulm

Fig. 5. Average costs (and their standard deviations) by taking into account
the set of distinct output matches. Analysis have been performed on the
physical interaction PPI of D.rerio. Results are grouped with respect to the
number of target labels and query size

times (i.e. 14, 5 and 1 s, respectively. APPAGATO always requires
around 0.69 s). The RESQUE running time rapidly rises as the t
threshold increases. In contrast, the APPAGATO running times are
always <1 5.

3.2 Quality measurements of matches

Figure 5 shows a comparison of the average response costs of
APPAGATO and NeMA on the D.rerio physical PPI network. We
removed the duplicated matches from the results of APPAGATO to
avoid the bias coming from low—cost matches. Both algorithms are
executed to return the best 10, 50, 100 matches. As expected, both
algorithms are highly dependent on the query size. However, there is
a clear difference in their output quality. The cost of NeMa results
are often close to 1, which means they involve a high number of mis—
matches. In contrast, the averages of the APPAGATO costs range
from 0.1 to 0.55. Supplementary Figures S9 and S10 in Section 3
confirm the accuracy of APPAGATO, also on H.sapiens and M.
musculus. We measured the statistical significance of the differences
between the APPAGATO and NeMa performance. We computed
the P—values with a Wilcoxon rank—sum test together with a false
discovery rate correction for multiple testing. Supplementary Figure
S11 in Section 3 shows that APPAGATO significantly outperforms
NeMa. The number of tested queries having lower P—values in—
creases as the output size becomes larger, particularly when the
number of required output matches increases.

3.3 Querying protein complexes among different
species

We compared APPAGATO and RESQUE using 10 human protein
complexes taken from CORUM and queried on the functional inter—
action dataset composed by M.musculus, H.sapiens, Drosopbila

9103 ‘01; JSanV uo saraﬁuv 50'] 0211110311123 JO AJTSJQAtuf] 112 /310'srcumoip1q1x0'sopcuuqutotq/ﬁduq 11101} popcorn/00g

Parallel and stochastic search

2165

 

I AFFAISAIU 0 RESQUE

S. cerevisiae H. sapiens
l 1’0 o o
0.8 0.3 ’ ° 9 o
3 06.¢9°.°”" 0.5 o ’
H 0.4 11:1
0.2 I 0.2 I
O-IlI-Ill- [II-III."-
BESE" T "l V
“@5003 “EMMEH
1 1
0.0 ’. ° . 0.3 o
3 as . 0.0
gnu 0.4 o
02 .
o'IIl'lIl-Iog.ll.-II...
QSSEE F? 8 08"$““£
"rm§a§0§ $r3§a§§§

Fig. 6. A chart showing the costs of the 10 protein complexes over the
S.cerevisiae and H.sapiens networks. The CORUM ID of the protein com-
plexes is reported on the x-axis. In the top charts, the similarity threshold is
equal to 1%. For those reported in the bottom side the similarity matrix has
not been filtered

melanogaster and S.cere1/isiae networks (see Fig. 6 and
Supplementary Fig. S12). We test RESQUE using two similarity
threshold values, 1% and 100%. RESQUE shows the main per—
formance limitation with a similarity threshold equal to 1% on
every target network, while it provides better performance by
increasing the cut—off. In all cases, APPAGATO outperforms
RES QUE even on the quality of the results. To confirm this, we run
the Wilcoxons rank—sum tests (see Supplementary Fig. S13). For low
similarity thresholds (from 1% to 10%), APPAGATO provides P—
values close to 1 X 10‘”. Better P—values (between 1 X 10_5 and
1 X 10‘6) are shown when we defined the whole similarity matrix.
Nevertheless, this turned out to be unfeasible from the running time
point of view. Supplementary Figure S14 in Section 4 shows the
functional coherence of results with respect to gene ontology. We
computed the average P—value for both algorithms obtained by
querying the 10 protein complexes for each of the four species.
APPAGATO outperforms RESQUE on every type of target net—
works and similarity threshold. We refer the reader to
Supplementary Sections 4 and 5 (Figs S15—S17) for details and fur—
ther application of APPAGATO to compare disease modules over
tissue—specific protein interaction networks.

4 Conclusions

We have developed APPAGATO, a stochastic and parallel algorithm
to find approximate occurrences of a query in biological networks.
APPAGATO deals with node, edge and node label mismatches. It is
implemented for GPUs. The choice of such devices is motivated by
their accessible costs, high—performance and widespread availability
on any personal computer. All above features allow APPAGATO to
compute efficiently functional and topological node similarity to—
gether with fast searching of a large number of query matching within
the target graph. The results show that APPA GATO outperforms the
existing tools in terms of running time and result accuracy and, unlike
competitors, it scales also on large PPI networks.

Acknowledgement

The authors thank S M E Sahraeian and Byung-Jun Yoon for all their help to
use and test their software RESQUE. We thank the authors of NeMA, Arijit
Khan, Yinghui Wu, Charu C. Aggarwal and Xifeng Yan for distributing their
software and their prompt support to evaluate it. We thank Dr Anna Privitera
for her helpful discussion on APPAGATO application.

Conﬂict of Interest: none declared.

References

Barabasi, A.L. and Oltvai, Z.N. (2004) Network biology: understanding the
cell’s functional organization. Nat. Rev. Genet., 5, 101—113.

Billeter, M. et al. (2009) Efﬁcient stream compaction on wide SIMD many-
core architectures. In Proceedings of the Conference on High Performance
Graphics 2009, pp. 15 9—166. New Orleans, Louisiana, USA.

Blin, G. et al. (2010) Querying graphs in protein-protein interactions networks
using feedback vertex set. IEEE/ACM Trans. Comput. Biol. Bioinform., 7,
628—635.

Bonnici, V. and Giugno, R. (2016) On the variable ordering in subgraph iso-
morphism algorithms. IEEE/ACM Trans. Comput. Biol. Bioinform.,
PP(99), 1545—5963.

Bonnici, V. et al. (2013) A subgraph isomorphism algorithm and its applica-
tion to biochemical data. BMC Bioinformatics, 14(Suppl. 7), 513.

Bruckner, S. et al. (2010) Topology-free querying of protein interaction net-
works. ]. Comput. Biol., 17, 23 7—252.

Busato, F. and Bombieri, N. (2015) BFS-4K: an efﬁcient implementation of
BFS for kepler GPU architectures. IEEE Trans. Parallel Distrib. Syst., 26,
1826—1838.

Ciriello, G. et al. (2012) Mutual exclusivity analysis identiﬁes oncogenic net-
work modules. Genome Res., 22, 398—406.

Cordella, LP. et al. (2004) A (sub) graph isomorphism algorithm for matching
large graphs. IEEE Trans. Pattern Anal. Mach. Intell., 26, 1367—1372.

Cormen, T. et al. (2009) Introduction to Algorithms. MIT Press, Cambridge,
Massachusetts.

Creixell, P. et al. (2015) Pathway and network analysis of cancer genomes.
Nat. Methods, 12, 615—621.

Dematte, L. and Prandi, D. (2010) Gpu computing for systems biology. Brief.
Bioinform., 11, 323—333. cited By 56.

Dost, B. et al. (2008) Qnet: a tool for querying protein interaction networks.
]. Comput. Biol., 15, 913—925.

Fortney, K. et al. (2010). Method inferring the functions of longevity genes
with modular subnetwork biomarkers of Caenorhabditis elegans aging.
Genom Biol., 13.

Gulsoy, G. and Kahveci, T. (2011) RINQ: reference-based indexing for net-
work queries. Bioinformatics, 27, i149—i158.

Harris, M. et al. (2008). GPU Gems 3: Parallel Preﬁx Sum (Scan) with
C UDA. Addison Wesley Professional, chapter 3.

Hong, L. et al. (2015) Subgraph matching with set similarity in a large graph
database. IEEE Trans. Knowl. Data Eng., 27, 2507—2521.

Ideker, T. et al. (2002) Discovering regulatory and signalling circuits in mo-
lecular interaction networks. Bioinformatics, 18(Suppl. 1), 5233—5240.

Jiang, X. et al. (2011) Network-based auto-probit modeling for protein func—
tion prediction. Biometrics, 67, 95 8—966.

Kelley, B. et al. (2003) Conserved pathways within bacteria and yeast as re—
vealed by global protein network alignment. PNAS, 100, 11394—11399.

Kelley, B. et al. (2004) PathBLAST: a tool for alignment of protein interaction
networks. Nucleic Acids Res., 1, W83—W88.

Khan, A. et al. (2013). NeMa: fast graph search with label similarity. In
Proceedings of the 39th International Conference on Very Large Data Bases,
PVLDB’13. VLDB Endowment, pp. 181—192. Riva del Garda, Trento,
Italy.

Lawrence, C. et al. (1993) Detecting subtle sequence signals: a gibbs sampling
strategy for multiple alignment. Science, 262, 208—214.

Lim, J. et al. (2006) A protein—protein interaction network for human in—
herited ataxias and disorders of purkinje cell degeneration. Cell, 125,
801—814.

Ma, X. and Gao, L. (2012) Biological network analysis: insights into structure
and functions. Brief. Funct. Genomics, 11, 434—442.

Malod-Dognin, N. and Priulj, N. (2015) L-GRAAL: Lagrangian graphlet-
based network aligner. Bioinformatics, 31, 2182—2189.

Micale, G. et al. (2014) GASOLINE: a greedy and stochastic algorithm for op—
timal local multiple alignment of interaction networks. PLOS ONE, 9,
e98750.

Panni, S. and Rombo, SE. (2015) Searching for repetitions in biological net-
works: methods, resources and tools. Brief. Bioinform., 16, 118—136.

9103 ‘01; isnﬁnv uo saraﬁuv 50'] 0211110311123 JO AJTSJQAtuf] 112 /310'srcu.moip10}x0'sopcuuqutotq/ﬁduq 0101} pQPBOIII/IAOG

2166

V. Bon nici et al.

 

Pienta, R. et al. (2014). MAGE: matching approximate patterns in richly-
attributed graphs. In 2014 IEEE International Conference on Big Data, Big
Data 2014, Washington, DC, October 27—30, pp. 585—590.

Pinter, R.Y. et al. (2005) Alignment of metabolic pathways. Bioinformatics,
21, 3401—3408.

Ruepp, A. et al. (2010) CORUM: the comprehensive resource of mammalian
protein complexes. Nucleic Acids Res., 38(Suppl. 1), D497—D501.

Sahraeian, S.M.E. and Yoon, B]. (2012) RESQUE: Network reduction using
semi—Markov random walk scores for efﬁcient querying of biological net-
works. Bioinformatics, 28, 2129—2136.

Shlomi, T. et al. (2006) QPath: a method for querying pathways in a protein-
protein interaction network. BMC Bioinformatics, 10, 199.

Sun, Z. et al. (2012) Efﬁcient subgraph matching on billion node graphs. Proc.
VLDB Endow., 5, 788—799.

Szklarczyk, D. et al. (2011) The STRING database in 2011: functional inter—
action networks of proteins, globally integrated and scored. Nucleic Acids
Res., 39, D561—D568.

Tian, Y. et al. (2007) SAGA: a subgraph matching tool for biological graphs.
Bioinformatics, 15, 232—239.

Tian, Y. et al. (2008) Periscope/gq: a graph querying toolkit. Proc. VLDB
Endow., 1, 1404—1407.

Vouzis, RD. and Sahinidis, NV. (2011) GPU-BLAST: using graphics
processors to accelerate protein sequence alignment. Bioinformatics, 27,
182—188.

Wang, H. et al. (2013) Function—function correlated multi—label protein
function prediction over interaction networks. I. Comput. Biol., 20,
322—343.

Yu, D. et al. (2013) Review of biological network data and its applications.
Genomics Inform, 11, 200—210.

Yuanyuan, T. and Patel, I. (2008). Tale: a tool for approximate large graph
matching. In Data IEEE 24th International Conference on Engineering,
2008, ICDE 2008, pp. 963—972. Cancun, Mexico.

Zhang, S. et al. (2009). Gaddi: distance index based subgraph matching in bio—
logical networks. In Proceedings of the 12th International Conference on
Extending Database Technology: Advances in Database Technology, EDBT
’09, pp. 192—203. ACM, New York, NY.

Zhao, K. and Chu, X. (2014) G—BLASTN: accelerating nucleotide alignment
by graphics processors. Bioinformatics, 30, 1384—1391.

9103 ‘01; isanV uo so1a§uv 50'] 0211110311123 JO [(1151010qu 112 /310's1cumofp10}x0'sopcuuqutotq/ﬁduq 0101} papeo1umoq

