BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

Snakemake

 

 

Listing 1. Example Snakeﬁle for mapping paired-end reads with BWA.

 

(1) SAMPLES = "100 101 102 103" .split()

(2) REF = "hg19 . fa"

(3) rule all:

(4) input: " {sample} . coverage.pdf" . format (sample = sample)
(5) for sample in SAMPLES

(6) rule fastq_to_sai:

(7) input: ref = REF, reads = " {sample} . {group} . fastq"

(8) output: temp ( " {sample} . {group} . sai")

(9) shell : " bwa aln {input . ref} {input . reads} > {output} "
(10) rule sai_to_bam:

(11) input: REF, " {sample} . 1. sai", " {sample} . 2 . sai",

(12) " {sample} . 1. fastq", " {sample} . 2 . fastq"

(13) output: protected( " {sample} .bam")

(14) shell: "bwa sampe {input} I samtools View esbh e > {output} "
(15) rule remove_duplicates:

(16) input: " {sample} .bam"

(17) output: " {sample} .nodup.bam"

(18) shell: " samtools rmdup {input} {output} "

(19) rule plot_coverage_histogram:

(20) input: " {sample} .nodup.bam"

(21) output: hist = " {sample} .coverage.pdf"

(22) run:

(23) from matplotlib.pyplot import hist, savefig
(24) hist (list (map ( int,

(25) shell ( "samtools mpileup {input} I cut ef4",
(26) iterable=True) ) ))

(27) savefig (output . hist)

 

In the rule sai_to_bam, all input files are accessed at once
through {input} (1. l4). BWAs internal.sai files can be
deleted automatically once the .bam files are created, which
are in turn worth to be write—protected to avoid accidental dele—
tion. Snakemake supports this by marking ﬁles as temp (l. 8)
and protected (1. 13). The rule remove_duplicates removes
polymerase chain reaction—induced duplicate reads from the
.bam files using the ‘samtools’ package (Li et al., 2009).
Finally, the rule plot_coverage creates a coverage histogram
for each position of the reference using Python’s ‘matplotlib’
(Hunter, 2007). This rule illustrates how shell output from sam—
tools is directly iterated over by Python code with Snakemake’s
built—in shell function in a run—block.

When Snakemake is invoked without a speciﬁc target, the first
rule (here the input—only rule all) is executed. It ensures that the
coverage plot and hence all needed intermediate ﬁles are created
for each sample. See http://snakemake.googlecode.com for fur—
ther examples and detailed documentation.

3 SNAKEMAKE ENGINE

Upon invocation, Snakemake creates a directed acyclic graph
(DAG) that represents a plan of rule executions (Fig. l). The
nodes of the DAG are jobs (i.e. the execution of a rule), a dir—
ected edge between job A and B means that the rule underlying
job B needs the output of job A as an input file. A path in the

 

fastq_to_sai faslq_lo_sai fastq_to_sai fastq_m_sai fastq_to_sai fastq_to_sai fasiq_to_sai fastq_to_sai
sample: 101 sample: 101 sample: 102 sample: 102 sample: 100 sample: 100 sample: 103 sample: 103
gloupzz groupzl gloup:2 gloupzl group:2 gloupzl groupzl group:2

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

lremove_duplicates l lremove_duplicates l lremove_duplicates l lremove_dupli<ates l

 

 

lplot_coverage_histogram llplot_coverage_hismglam Ilplot_coverage_histogram Ilplot_coverage_his‘oglam |
all
Fig. 1. DAG of jobs for the example workﬂow

 

DAG represents a sequence of jobs that have to be executed
serially. Importantly, two disjoint paths in the DAG can be
executed independently from each other, i.e. in parallel. Since
individual jobs can use multiple threads themselves,
Snakemake can be instructed to solve a 0/l—knapsack problem
to optimize the usage of CPUs, given a threshold of available
cores. This mechanism allows to scale Snakemake to environ—
ments with a hard limit of used CPU cores, e. g. a shared compute
server. Furthermore, using only as many threads as there are
cores available can be beneficial for performance since it reduces
the amount of context switching.

By default, Snakemake only executes rules if the output files
are not present or the modification time of the input files is
newer. Together with the automatic deletion of output files
from incomplete rule executions (e. g. due to a failing shell com—
mand), this enables Snakemake to avoid duplicate work when
resuming workﬂows.

To analyse the workﬂow, Snakemake provides options to per—
form a dry—run without actual execution of jobs, give the reason
for each executed job and print the DAG to the graphvizdot
format (Gansner and North, 2000) for visualization.

Apart from running on single machines, Snakemake contains
a generic mechanism that allows the execution of jobs on a batch
system or a compute cluster engine that is only constrained by
the availability of a submit command that handles shell scripts
(e. g. qsub) and a shared file system accessible by all cluster nodes.
Hence, a Snakefile scales from single—core workstations over
multi—core servers to compute clusters of different architectures,
without the need to modify the workﬂow.

ACKNOWLEDGEMENTS

The authors thank Tobias Marschall (CW1 Amsterdam) and
Marcel Martin (TU Dortmund) for their tremendously helpful
testing work, feature requests and comments.

Conﬂict of Interest: None declared.

REFERENCES

Gansner,E.R. and North,S.C. (2000) An open graph visualization system and its
applications to software engineering. Software Pruet Exper, 30, 120371233.
Goecks,J. et a]. (2010) Galaxy: a comprehensive approach for supporting accessible,
reproducible, and transparent computational research in the life sciences.
Genome Biol., 11, R86.

Goodstadt,L. (2010) Ruffus: a lightweight Python library for computational pipe—
lines. Bioinformuticx, 26, 277872779.

Halbritter,F. et a]. (2011) GeneProf: analysis of high—throughput sequencing experi—
ments. Nut. Methods, 9, 778.

 

2521

ﬁlO'SIIZLImOprOJXO'SOplZILLIOJLIIOIQ/[idnq

J.K6$ter and S.Rahmann

 

Hoon,S. et a]. (2003) Biopipe: a flexible framework for protocol—based bioinfor—
matics analysis. Genome Res, 13, 190471915.

Hunter,J. (2007) Matplotlib: a 2D graphics environment. Compat. Sci. Eng, 9,
9&95.

Li,H. and Durbin,R. (2009) Fast and accurate short read alignment with Burrowse
Wheeler transform. Bioinformatiex, 25, 17544760.

Li,H. et a]. (2009) The sequence Alignment/Map format and SAMtools.
Bioinformaticx, 25, 207872079.

Meyerson,M. et a]. (2010) Advances in understanding cancer genomes through
second—generation sequencing. Nat. Rev. Genet., 11, 6857696.

Oinn,T. et a]. (2004) Taverna: a tool for the composition and enactment of
bioinformatics workflows. Bioinformatim‘, 20, 304?3054.

Sadedin,S.P. et a]. (2012) Bpipe: a tool for running and managing bioinformatics
pipelines. Bioinformatim‘, 28, 152&1526.

Shah,S.P. et a]. (2004) Pegasys: software for executing and integrating analyses of
biological sequences. BMC Bioinformatiex, 5, 40.

Stallman,R.M. and McGrath,R. (1991) GNU MakeiA Program for Directing
Recompilation. http://wwwgnu.org/software/make/.

Tanaka,M. and Tatebe,O. (2010) Pwrake: a parallel and distributed flexible work—
flow management tool for wide—area data intensive computing. In HPDC '10,
ACM. pp. 3567359. http://dl.acm.org/citation.cfm?id: 1851529.

Taura,K. et a]. (2010) Design and Implementation of {GXP} Make 7 A Workflow
System Based on Make. In IEEE International Conference on eSL'ienL'e, IEEE
Computer Society, pp. 214e22l, Los Alamitos, CA, USA.

 

2522

/310'S[BHmO[pJOJXO'SOIJBLUJOJIIIOIq/ﬂduq

