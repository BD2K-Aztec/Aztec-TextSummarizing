BIOINFORMA TICS

0'so;112u110}u101q//2duq

SIBumoprOJX

£10"

forqs

 

2 DESIGN AND IMPLEMENTATION

forqs begins with a set of founding haplotypes carried by the individuals
in the initial generation. Individuals are diploid and carry a user-speciﬁed
number of chromosome pairs. By assigning a unique identiﬁer to each
founding haplotype, individual haplotype chunks are tracked as they re-
combine over subsequent generations (Fig. 1). For the purposes of simu-
lation, any existing neutral variation on the haplotype chunks can be
ignored, and only those loci with ﬁtness effects need to be tracked.

forqs performs the following actions during a single cycle of the
simulation: (i) generation of new populations, (ii) genotyping, (iii) quan-
titative trait evaluation, (iv) ﬁtness evaluation and (v) reporting. forqs
has a ﬂexible design in which the simulator delegates speciﬁc tasks or
calculations to conﬁgurable modules. The user speciﬁes which modules to
instantiate in a conﬁguration ﬁle.

In addition to the primary modules that are used to specify demog-
raphy, mutation, recombination, quantitative traits, ﬁtness and reported
output, there are several building block modules that provide basic func-
tionality to the primary modules. For example, Trajectory modules
provide a uniﬁed method for specifying values that change over time,
such as population sizes or migration rates. Similarly, Distribution
modules can be used to specify how to draw particular random values
[e.g. quantitative trait loci (QTL) positions or allele frequencies).

As an illustration of forqs conﬁguration, suppose that a user wanted
to simulate populations undergoing neutral admixture. The user would
specify a PopulationConfigGenerator module representing a step-
ping stone or island model with the desired population size and migration
rate trajectories. However, the user would not specify any quantitative
trait modules and would use the default FitnessFunction module
that assigns identical ﬁtness values to all individuals. On the other
hand, to simulate an artiﬁcial selection experiment with truncation selec-
tion on a single quantitative trait, the user would specify the trait with
QTLs and effect sizes, and choose a FitnessFunction module that
selects the desired proportion of individuals to produce the next gener-
ation. Alternatively, the user could indicate that the QTLs and effect sizes
should be drawn randomly from user-speciﬁed distributions.

The representation of chromosomes as haplotype chunks in forqs
makes efﬁcient use of memory, independent of the size of the chromo-
somes. On a typical laptop computer, for a population size of 1 million,
simulations take ~1.5 s/generation for neutral simulations and ~3 s/gen-
eration with selection at a single locus. Decreasing the population size
allows the simulation of a greater number of generations in a reasonable
amount of time: a population size of 10000 takes ~3 s/ 100 generations
(without selection, with a slight increase with selection). However,
forqs’ design comes with the trade-off that memory usage grows lin-
early with the number of generations simulated due to recombination.
Thus, for investigations focusing on mutational input over a large
number of generations (e.g. studies involving demographic changes

(0, 1) (0, 2) '
.— crossover at
position 1234

<— crossover at
position 5678

 

(0, 1)
(1234 2) , Haplotype Chunk: (position, id)
1 Chromosome: array of haplotype chunks

(5678, 1) I

 

Fig. 1. forqs chromosome representation. An individual chromosome
is represented by a list of haplotype chunks. Each haplotype chunk is
represented by two numbers (position, id): the position where it begins
and the identiﬁer of the founding haplotype from which it is derived. This
cartoon depicts a chromosome with three haplotype chunks as the result
of recombination (double crossover) between two founder chromosomes

taking place over thousands of generations), forqs’ design is not as
efﬁcient as array-based implementations (e.g. SLiM or SFS_CODE) that
were designed specifically for these scenarios. Similarly, we recommend
that forqs be used in conjunction with a coalescent simulator to gener-
ate neutral variation, rather than running forqs for a long burn-in
period to reach mutation-drift equilibrium.

forqs has been extensively tested for correctness, both at the level of
individual code units and in its large-scale behavior in comparison with
theoretical predictions from population genetics and quantitative gen-
etics. Validation results, tutorials and documentation can be found in
the Supplementary Information. Conﬁguration ﬁles for all simulations
mentioned in this article are included in the forqs software packages.

ACKNOWLEDGEMENTS

The authors would like to thank Alex Platt, Charleston Chiang,
Eunjung Han and Diego Ortega Del Vecchyo for helpful com—
ments on features, usability and documentation of the software.

Funding: National Institutes of Health (Training Grant in
Genomic Analysis and Interpretation T32 HG002536 to D.K.,
R01 HG007089 to J.N.), the NSF (BF-0928690 to J.N.) and
UCLA (Dissertation Year Fellowship to D.K.).

Conﬂict of Interest: none declared.

REFERENCES

Aberer,A.J. and Stamatakis,A. (2013) Rapid forward—in—time simulation at the
chromosome and genome level. BMC Biotnﬂrmoticx, 14, 216.

Carvajal—Rodriguez,A. (2008) GENOMEPOP: a program to simulate genomes in
populations. BMC Bioinformutim‘, 9, 223.

Chadeau—Hyam,M. et a]. (2008) Fregene: simulation of realistic sequence-level data
in populations and ascertained samples. BMC Bioiiy’ormoticx, 9, 364.

Chen,G.K. et a]. (2009) Fast and ﬂexible simulation of DNA sequence data.
Genome Rein, l9, 13(rl42.

Ewing,G. and Hermisson,J. (2010) MSMS: a coalescent simulation program includ—
ing recombination, demographic structure and selection at a single locus.
Bioinformuticx, 26, 206$2065.

Excoffier,L. and Foll,M. (2011) Fastsimcoal: a continuous—time coalescent simula—
tor of genomic diversity under arbitrarily complex evolutionary scenarios.
Bioinformuticx, 27, 133271334.

Haiminen,N. et a]. (2013) Efﬁcient in A‘ilico chromosomal representation of popu—
lations via indexing ancestral genomes. Algoritlzmx‘, 6, 430—441.

Hernandez,R.D. (2008) A flexible forward simulator for populations subject to
selection and demography. Bioiiy’ormoticx, 24, 278G2787.

Hoban,S. et a]. (201 1) Computer simulations: tools for population and evolutionary
genetics. Nat. Rev. Genet, 13, 11(%122.

Hudson,R.R. (2002) Generating samples under a wright—ﬁsher neutral model of
genetic variation. Bioiiy’ormoticx, 18, 3377338.

Hudson,R.R. and Kaplan,N.L. (1988) The coalescent process in models with selec—
tion and recombination. Genetics, 120, 8317840.

Lambert,B.W. et a]. (2008) ForSim: a tool for exploring the genetic architecture of
complex traits with controlled truth. Biotnﬂrmoticx, 24, 182171822.

Messer,P.W. (2013) SLiM: simulating evolution with selection and linkage.
Genetics, 194, 103771039.

Neuenschwander,S. et a]. (2008) QuantiNemo: an individual—based program to
simulate quantitative traits with explicit genetic architecture in a dynamic meta—
population. Bioiiy’ommticx, 24, 155271553.

O’Fallon,B. (2010) TreesimJ: a flexible, forward time population genetic simulator.
Bioinformuticx, 26, 220(F2201.

Padhukasahasram,B. et a]. (2008) Exploring population genetic models with recom—
bination using efﬁcient forward—time simulations. Genetics, 178, 241772427.
Peng,B. and Kimmel,M. (2005) simuPOP: a forward—time population genetics simu—

lation environment. Bioiiy’ormoticx, 21, 368G3687.

Wegmann,D. et a]. (2011) Recombination rates in admixed individuals identiﬁed by
ancestry—based inference. Nat. Genet, 43, 8474553.

Yuan,X. et a]. (2012) An overview of population genetic data simulation.
J. Comput. Biol, 19, 42754.

 

577

ﬁm'spzumot‘pmﬂo'sopeuuopuotq/ﬁdnq

