Bioinformatics, 31 (16), 2015, 2632—2638
doi:10.1093/bioinformatics/btv211

Advance Access Publication Date: 17 April 2015
Original Paper

 

Sequence analysis

ScaffMatch: scaffolding algorithm based on
maximum weight matching
Igor Mandric and Alex Zelikovsky*

Department of Computer Science, Georgia State University, Atlanta, GA 30303, USA

*To whom correspondence should be addressed.
Associate Editor: John Hancock

Received on November 18, 2014; revised on March 4, 2015; accepted on April 10, 2015

Abstract

Motivation: Next—generation high—throughput sequencing has become a state—of—the—art technique
in genome assembly. Scaffolding is one of the main stages of the assembly pipeline. During this
stage, contigs assembled from the paired—end reads are merged into bigger chains called scaffolds.
Because of a high level of statistical noise, chimeric reads, and genome repeats the problem of
scaffolding is a challenging task. Current scaffolding software packages widely vary in their quality
and are highly dependent on the read data quality and genome complexity. There are no clear win—
ners and multiple opportunities for further improvements ofthe tools still exist.

Results: This article presents an efficient scaffolding algorithm ScaffMatch that is able to handle
reads with both short (<600 bp) and long (>35 000 bp) insert sizes producing high—quality scaffolds.
We evaluate our scaffolding tool with the Fscore and other metrics (N50, corrected N50) on eight
datasets comparing it with the most available packages. Our experiments show that ScaffMatch is
the tool of preference for the most datasets.

Availability and implementation: The source code is available at http://alan.cs.gsu.edu/NGS/

 

?q:conte nt/scaffmatch.
Contact: mandric@cs.gsu.edu

Supplementary information: Supplementary data are available at Bioinformatics online.

 

1 Introduction

Next-generation sequencing (NGS) is a powerful technology as it
can produce millions of short paired-end reads covering whole
genome. The cost of producing reads keeps a trend of decreasing
making it a very attractive tool for genome sequencing and assem-
bly. Genome assembly from short NGS reads is a challenging prob-
lem. Assembled genomes are frequently highly fragmented and
consist of contigs of highly variable length. The connectivity infor-
mation coming from read pairs mapped to contigs can be used to
merge them into a scaffold which is a set of chains of oriented
ordered contigs with estimated gaps between all pairs of adjacent
elements. A recent comprehensive evaluation of available software
tools shows that the scaffolding problem still does not have an ad-
equate solution (Hunt et (11., 2014).

Because of misassemblies in contigs, repeats and chimeric reads,
the information about relative ordering and orientation of two

contigs connected with a set of read pairs can be contradictory and
not reliable. Thus, choosing a wrong subset of read pairs as an evi-
dence of connection between two contigs can result in inferring a
wrong relative ordering and/or orientation as well as the gap estima-
tion between them. Edges that comply with the true orientation of
contigs and the distance between them are usually called concord-
ant, otherwise discordant edges. The scaffolding problem is usually
formulated as an optimization problem on a graph with the vertices
corresponding to the contigs and the edges corresponding to the
bunches of read pairs connecting contigs. In contrast, the optimiza-
tion objectives and the methods to find optimal scaffolding with re-
spect to these objectives significantly vary from one tool to another.
For example, OPERA (Gao et (11., 2011) maximizes the number of
concordant edges using dynamic programming, SCARPA (Donmez
and Brudno, 2013) minimizes the number of discordant edges using
fixed-parameter tractable and bounded algorithm and linear

(C7 The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 2632

/310‘Sjcumo[p10}xo‘sopcuHOJIItotq/ﬁdnq

Lindsa} (7/ LIL, 2014

(him (7/ LIL, 2011

Salmcla

(7/ LIL, 2011
Boctzcr (7/ LIL, 2011
SL1111111(’[L’IL., 2014

11L]Ilt(’[L'IL. (2014)
Salzbcrg (7/ LIL, 2012

Dajarian (7/ LIL, 2010

Luo (7/ LIL, 2012
Hunt (7/ LIL

Simpson and Durbin, 2012
2014

Hunt (7/ LIL (2014)

1

' “All: Li us) 

1—1—r
. I

I .
1—;-

1 If] . .
Strand A  _d(A,B)_j—i+!strand B
i I conti A f ‘ '

i
i
strand 13(6)—

Start(rl)

r;. i
starth‘z)

 

Figure 1

Sahlin (7/ LIL (2012)

PLIllC}bl;111k, 1980

. ontig Bi .
Hﬁtrand B!
4—‘ i

/310'SIBanoprOJxo"sotJBuiJOJutotqﬂ:duq

ﬂ
Econtig B-

-contig A  
b bundles of”, ______________ u,

Edmonds, 1965

read pairs

contig C

 

 

/310'SIBanoprOJxo"sotJBuiJOJutotqﬂ:duq

and Salzbcrg, 2012

(7/ LIL, 2005

Langmcad

Ilagbcrg

Hunt (7/ LIL (2014)

(2014)
2008 Table 1

chzi (7/ LIL, 2012

Salzbcrg (7/ LIL, 2012

11L]Ilt(’lL’IL.

Zcrbino and Burro},

 

Hunt (7/ LIL (2014)

/310'SIBanoprOJxo"sotJBuiJOJutotqﬂ:duq

2636

I.Mandric and A.Zelikovsky

 

Table 2. Performance of different algorithms on the scaffolding datasets from GAGE

 

 

Dataset Scaffolder Correct links Error links Skipped contigs N50 Corr. N5 0 Sensitivity PPV F score
Sameus ScaffMatch 139 14 23 1 476 925 351 546 0.832 0.908 0.869
SSPACE 105 13 13 332 784 261 710 0.629 0.890 0.737
OPERA 112 11 22 1 084 108 686577 0.671 0.911 0.845
SOPRA 40 2 7 112278 112083 0.240 0.952 0.383
MIP 0 0 0 46 221 46 221 0 0 0
SCARPA 77 16 10 112264 112 083 0.461 0.828 0.592
SILP2 121 3 34 645 780 284 980 0.725 0.976 0.832
BESST 112 11 21 1 716 351 335064 0.671 0.911 0.772
SGA 83 1 10 309 286 309 153 0.497 0.988 0.661
SOAPdenovo2 131 12 13 643 384 621 109 0.784 0.916 0.845
R.splaaeroides ScaffMatch 482 18 40 2 547 706 2 528 248 0.845 0.964 0.901
SSPACE 357 7 49 109 776 108 410 0.626 0.981 0.764
OPERA 316 1 23 108 172 108 172 0.554 0.997 0.713
SOPRA 242 15 24 32 232 30 492 0.425 0.942 0.585
MIP 419 37 16 488 095 487941 0.735 0.919 0.817
SCARPA 209 5 23 37 667 37581 0.367 0.977 0.533
SlLP2 425 24 87 471 077 422 445 0.746 0.947 0.834
BESST 367 2 15 1 021 151 1 020 921 0.644 0.995 0.782
SGA 232 1 26 42 825 42 722 0.407 0.996 0.578
SOAPdenovo2 468 8 26 2522 483 2522482 0.821 0.983 0.895
H.5apiens (chr 14) ScaffMatch 12 41 1 252 3480 131 135 80 329 0.622 0.980 0.761
short insert size SSPACE 9566 43 2754 78 552 77 361 0.487 0.986 0.652
OPERA 12291 112 2991 214 972 207047 0.616 0.991 0.760
SOPRA 14 761 381 1441 100 768 96436 0.740 0.975 0.841
MIP 13 899 954 2735 244 064 235 731 0.697 0.936 0.799
SCARPA 9938 162 1829 58 330 55 760 0.498 0.984 0.661
SlLP2 10548 124 4918 126 689 77421 0.529 0.988 0.689
BESST 7970 355 2165 146 749 80218 0.400 0.957 0.564
SGA 9761 6 3214 134 574 133 192 0.490 0.999 0.657
SOAPdenovo2 15 740 390 2378 282 437 234 561 0.790 0.976 0.873
H.5apiens (chr 14) ScaffMatch 5938 443 5198 148 412 42 523 0.298 0.933 0.452
long insert size SSPACE 2750 23 2539 77 832 30 449 0. 138 0.992 0.242
OPERA 3687 677 3226 73 477 20 677 0.185 0.845 0.303
SOPRA 2938 166 2622 79517 34 750 0.147 0.947 0.255
MIP 5898 1092 4861 272 440 49 800 0.296 0.844 0.438
SCARPA 1603 31 1466 43 969 17786 0.080 0.981 0.149
SILP2 3899 65 3732 74 094 38 810 0.196 0.984 0.326
BESST 123 13 98 13 815 8828 0.006 0.904 0.012
SGA 0 0 0 12 21 1 12 21 1 0 0 0
SOAPdenovo2 4516 294 3301 220 644 86679 0.227 0.939 0.365
H.5apiens (chr 14) ScaffMatch 12 658 348 3874 802 755 195 239 0.635 0.973 0.769
combined library SSPACE 9249 36 2677 66 271 65 222 0.464 0.996 0.633
short + long OPERA 12 853 58 3409 1 692 782 1 062 031 0.645 0.996 0.783
insert size SOPRA 10418 238 3322 112239 75 046 0.523 0.978 0.681
MIP 8534 696 3213 44 372 31 148 0.428 0.925 0.585
SCARPA 10712 161 2376 134364 106 654 0.537 0.985 0.695
BESST 8287 286 2347 295 976 114434 0.416 0.967 0.581
SGA 9764 3 3214 134 574 133 192 0.490 0.999 0.657
SOAPdenovo2 15 748 382 2575 561 198 447 849 0.790 0.976 0.873

 

Various quality metrics have been proposed up to date. Rather
than coming up with our own metrics, we have decided to follow
the most recent evaluation paper (Hunt et al., 2014), which besides
N50 and corrected N50 also reports the number of correctly and er—
roneously predicted joins between contigs in the reference genome.
Following Hunt et al. (2014), we do not distinguish between links
connecting long and short contigs and contigs from different
chromosomes. Let P be the number of potential contigs that can be
joined in scaffold which is the number of contigs minus the number
of chromosomes, let TP be the number of correct contig joins in the

output of the scaffolder (true positives) and PP be the number of er—
roneous joins (false positives). We compute the following quality
metrics: TPR 2%), PPV :TIEFP, F score : %’, where TPR is
sensitivity and PPV is positive predictive value.

 

3.3 Evaluation and comparison

ScaffMatch is compared with well—established scaffolders SSPACE,
OPERA, SOPRA, MIP, SCARPA, two recently published scaffolders
SILPZ and BESST (Sahlin et al., 2014) scaffolding modules of SGA
(Simpson and Durbin, 2012) and SOAPdenovo2 (Luo et 41., 2012).

ﬁm'sreumofpquo'sopcuuowtotq/ﬁdnq

ScaffMatch: maximum weight matching scaffolding

2637

 

Table 3. Performance of different algorithms on the scaffolding datasets for P.falciparum. The best values for each dataset are in bold font.

 

 

Dataset Scaffolder Correct links Error links Skipped contigs N50 Corr. N50 Sensitivity PPV F score
Rfalcipamm ScaffMatch 5648 287 37 8626 5872 0.607 0.952 0.741
short insert size SSPACE 5746 127 12 6011 5845 0.612 0.978 0.757
OPERA 3706 116 371 5035 4824 0.398 0.967 0.565
SOPRA 4897 174 34 4954 4632 0.526 0.966 0.681
MIP 5544 359 15 6158 5485 0.596 0.939 0.730
SCARPA 4830 221 38 4912 4628 0.519 0.956 0.673
SILP2 5496 498 48 3109 2601 0.591 0.917 0.719
BESST 2632 462 84 7471 3931 0.283 0.851 0.425
SGA 4940 46 100 5324 5104 0.531 0.991 0.691
SOAPdenovo2 5540 84 47 6234 5981 0.596 0.985 0.742
Rfalcipamm ScaffMatch 6970 260 175 1 41 564 25 380 0.749 0.964 0.843
long insert size SSPACE 4610 21 1235 17 796 15 553 0.496 0.995 0.662
OPERA 6257 97 1339 44667 40 170 0.673 0.985 0.799
SOPRA 7247 181 656 49 671 44 158 0.779 0.976 0.866
MIP 7754 707 731 88 297 78 672 0.834 0.916 0.873
SCARPA 4882 117 714 14 037 9708 0.525 0.977 0.683
SILP2 5996 266 2839 45 407 29 399 0.645 0.957 0.771
BESST 1307 46 327 4133 2813 0.141 0.966 0.245
SGA 2902 2 652 4438 4096 0.312 0.999 0.476
SOAPdenovo2 7659 351 803 167570 83 851 0.635 0.869 0.734
Rfalcipamm ScaffMatch 8223 425 654 78 627 47 662 0.884 0.951 0.916
combined library SSPACE 5889 123 76 6383 5982 0.633 0.980 0.769
Short+ long OPERA 6434 177 1171 42 450 38409 0.692 0.973 0.809
insert size SOPRA 7018 60 171 16366 15511 0.754 0.992 0.857
MIP 8082 513 75 56672 38704 0.869 0.940 0.903
SCARPA 7336 370 251 36 945 23 951 0.789 0.952 0.863
BESST 3929 541 384 25 300 7621 0.422 0.879 0.571
SGA 4910 44 419 6606 6134 0.528 0.991 0.689
SOAPdenovo2 5977 228 254 12 076 10629 0.643 0.963 0.771

 

SSPACE, OPERA and SOPRA used bowtie (Langmead and
Salzberg, 2012) mapping, SOAPdenovo2 used its own mapping and
all other scaffolders used bowtie2 mapping. All software has been
run with the same versions and options as in Hunt et al. (2014)
except SILP2 and BESST for which default parameters were used
from the respective websites. Results for SILP2 are not given for the
combined insert size datasets as it does not have an option to process
datasets with multiple insert size.

For computing the number of correct and erroneous links, we
used scripts provided in Hunt et al. (2014). Note that MIP and SGA
did not give meaningful results, respectively, for the S.aureus and
H .sapiens (long insert size).

We compared three different versions of ScaffMatch: ScaffMatch
(maximum weight matching with insertion), ScaffMatch_G (greedy
matching with insertion) and ScaffMatch_B (maximum weight match—
ing) in the Supplementary Table 51 (see Supplementary Data).
ScafﬂVlatch usually has the best F score among all three versions.
Scafﬂ\/latch_G also can be very different from ScaffMatch since it
may choose to match completely different contigs. ScaffMatch_B has
usually the highest PPV and corrected N50 among all three versions
implying that insertion of skipped contigs might be erroneous.
Unexpectedly, the number of contigs skipped by Scafﬂ\/latch_B
is not much greater than for ScafﬂVlatch showing that the solution
for the scaffolding/MWA2M problem does not skip over many
contigs.

The results for GAGE scaffolding testcases are in Table 2 and re—
sults for Rfalciparum are in Table 3. The entries in the bold font are
the best among all 10 scaffolders with respect to the corresponding
quality metric. ScaffMatch has the top F score for four testcases and

the top corrected N5 0 for two testcases. Additionally, ScaffMatch_B
has the top corrected N5 0 for S.aureus. SOAPdenovo2 has the top F
score for two testcases and the top corrected N50 for three testcases.
MIP is a top performer once for F score and once for corrected N5 0.
Finally, OPERA is the best in corrected N50 for two testcases
(still losing to ScaffMatch_B on Saureus) and SSPACE has the best
F score for one testcase.

The runtime of all compared scaffolders are in Supplementary
Table 52 in Supplementary Data. The runtime growth rate with re—
spect to the dataset size is similar for all scaffolders. The fastest scaf—
folder is SSPACE, and the slowest is SOPRA.

4 Conclusions

In this article, we present a novel stand—alone scaffolding algorithm
ScaffMatch, which is based on representation of the scaffolding
problem as the maximum weight acyclic 2—matching. Our experi—
ments show that, unexpectedly, the number of skipped contigs is not
significant—for many datasets, the results for ScaffMatch_B are
only slightly improved by insertion of skipped contigs in
ScaffMatch. The ScaffMatch software implementation is shown to
be consistently one of the top performers on majority of the scaffold—
ing datasets.

Fu ndi ng
This work is supported in part by the NSF Grant IIS-0916401.

Conﬂict of Interest: none declared.

[310'sp2umofp105xo'sopeuHOJIItotq/ﬁdnq

2638

I.Mandric and A.Zelikovsky

 

References

Boetzer,M. et al. (2011) Scaffolding pre-assembled contigs using sspace.
Bioinformatics, 27, 578—579.

Dayarian,A. et al. (2010) Sopra: scaffolding algorithm for paired reads via
statistical optimization. BMC Bioinformatics, 11, 345.

Donmez,N. and Brudno,M. (2013) Scarpa: scaffolding reads with practical al-
gorithms. Bioinformatics, 29, 428—434.

Edmonds,]. (1965) Paths, trees, and ﬂowers. Can.]. Math, 17, 449—467.

Gao,S. et al. (2011) Opera: reconstructing optimal genomic scaffolds with
high-throughput paired-end sequences. Journal of Computational Biology,
18,1681—1691.

Hagberg,A. et al. (2005) Networkx: Python software for the analysis of net-
works. Technical report, Mathematical Modeling and Analysis. Los Alamos
National Laboratory, 2005. http://networkx.lanl.gov (15 April 2015, date
last accessed).

Hunt,M. et al. (2014) A comprehensive evaluation of assembly scaffolding
tools. Genome Biol, 15, R42.

Langmead,B. and Salzberg,S.L. (2012) Fast gapped-read alignment with
Bowtie 2. Nat. Methods, 9, 357—359.

Lindsay,]. et al. (2014) Ilp-based maximum likelihood genome scaffolding.
BMC Bioinformatics, 15(Suppl 9):S9.

Luo,R. et al. (2012) SoapdenovoZ: an empirically improved memory-efﬁcient
short-read de novo assembler. Gigascience, 1, 18.

Pulleyblank,W.R. (1980) Dual integrity in b-matching problems.
Mathematical Programming Study, 12, 176—186.

Sahlin,K. et al. (2012) Improved gap size estimation for scaffolding algo-
rithms. Bioinformatics, 28, 2215—2222.

Sahlin,K. et al. (2014) Besst-efﬁcient scaffolding of large fragmented assem-
blies. BMC Bioinformatics, 15, 281.

Salmela,L. et al. (2011) Fast scaffolding with small independent mixed integer
programs. Bioinformatics, 27, 3259—3265.

Salzberg,S.L. et al. (2012) Gage: a critical evaluation of genome assemblies
and assembly algorithms. Genome Res., 22, 557—567.

Simpson,].T. and Durbin,R. (2012) Efﬁcient de novo assembly of large gen-
omes using compressed data structures. Genome Res., 22, 549—556.

Vezzi,F. et al. (2012) Feature-by-feature—evaluating de novo sequence assem-
bly. PLOS One, 7, e31002.

Zerbino,D.R. and Birney,E. (2008) Velvet: algorithms for de novo Short read
assembly using de Bruijn graphs. Genome Res., 18, 821—829.

/310'S[BHmOprOJXO'SOIJBLUJOJIIIOIq/ﬂduq

