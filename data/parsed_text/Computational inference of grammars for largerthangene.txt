Motivation: Larger than gene structures (LGS) are DNA segments that include at least one gene and often other segments such as inverted repeats and gene promoters. Mobile genetic elements (MGE) such as integrons are LGS that play an important role in horizontal gene transfer, primarily in Gram-negative organisms. Known LGS have a profound effect on organism virulence, antibiotic resistance and other properties of the organism due to the number of genes involved. Expert-compiled grammars have been shown to be an effective computational representation of LGS, well suited to automating annotation, and supporting de novo gene discovery. However, development of LGS grammars by experts is labour intensive and restricted to known LGS. Objectives: This study uses computational grammar inference methods to automate LGS discovery. We compare the ability of six algorithms to infer LGS grammars from DNA sequences annotated with genes and other short sequences. We compared the predictive power of learned grammars against an expert-developed grammar for gene cassette arrays found in Class 1, 2 and 3 integrons, which are modular LGS containing up to 9 of about 240 cassette types. Results: Using a Bayesian generalization algorithm our inferred grammar was able to predict > 95% of MGE structures in a corpus of 1760 sequences obtained from Genbank (F-score 75%). Even with 100% noise added to the training and test sets, we obtained an F-score of 68%, indicating that the method is robust and has the potential to predict de novo LGS structures when the underlying gene features are known. Availability: http://www2.
INTRODUCTIONThe study of DNA has particularly focused on regions that code RNA (primarily genes) and regions that interact with proteins such as transcription factor binding sites. In 1961, Jacob andpublished the first example of a gene regulation mechanism that exploits the position of genes to simultaneously control the expression of genes that are part of the same metabolic pathway.list 12 classes of larger than gene structures (LGS) that can transfer regions of DNA * To whom correspondence should be addressed. containing one or more genes between DNA molecules in a cell or, through conjugation, between organisms. Many examples of each class of these mobile genetic elements (MGEs) are found in GenBank (). These MGEs have all been discovered after initial observations of unexpected phenomena. Integrons, for example, were first identified when manual observations found a similar sequence pattern (restriction enzyme digestion sites) repeatedly flanking a variety of quite different antibiotic resistance genes (). The development of a systematic method for making such observations would potentially reveal new structures and new mechanisms for gene regulation and transposition. Methods of computational support for MGE discovery typically focus on a subset of MGEs called genomic islands (). These methods include: @BULLET Methods that use sequence similarity, either through wholegenome alignment (), or clusters of genes (). These methods depend on having similar genomes that differ by inserted genomic islands. They cannot discover the structure of the inserted sequence.@BULLET Methods that rely the on similarity of genomic sequence properties of such as GC content () or oligonucleotide frequencies (). These methods can discover insertions with limited accuracy and also do not identify sequence structure.@BULLET Methods based upon the occurrence of direct repeats (DR) and tRNA genes to identify MGE insertions. However, as many MGE are not inserted in tRNA genes nor have DR, this approach is not generalizable (). All of these methods have been designed for bacterial chromosomal DNA and not plasmids. An important class of tools can identify new MGE from known classes of MGE (). These methods require the creation a priori of computational models of MGE structures to permit automatic MGE annotation. We present a method to support de novo discovery of LGS based upon computational grammars. Short sequences (e.g. genes, recurring motifs, DR and inverted repeats) are annotated by other methods. Our method then identifies recurring patterns in these annotations to infer new LGS and represents them as grammatical models. The grammar is then used to provide a second level ofPage: 792 791796
G.Tsafnat et al.annotation that can be used to measure the accuracy of the inference method. Computational grammars have been used to model and predict transcription binding sites (), RNA folding () and genes (). Components of LGS represented with grammars include integrons (), insertion sequences () and gene cassettes (). Expert-developed LGS grammars can be used to generate accurate annotations (). Such automatic grammatical annotations have been used to survey antibiotic resistance bearing gene cassettes in GenBank (). In this article, we automatically construct LGS grammars from DNA sequences that have been annotated for short gene cassettes and integron-specific conserved sequences, but not LGS such as cassette arrays. Automatic grammar inference should improve the efficiency of the grammar development process, and support computational discovery of LGS, a problem for which there are currently no methods. The method we present here is an unsupervised learning method based on the prefix tree acceptor (PTA;) algorithm. This method first constructs a Markov model from a training set () and then merges similar subchains. The resulting grammar is simpler than an ungeneralized hidden Markov model (HMM) and can accept a wider range of inputs than present in the training set.
METHODS
DataWe established a database of 233 gene cassettes found in Class 1, 2 and 3 integrons () as well as 38 sequences found between gene cassettes, which we call non-cassette insertions (NCI) and 12 known conserved sequence (CS) regions of the cassette array called the 5-CS and 3-CS (Class 1) and 5-and 3-regions in Classes 2 and 3. Each entry in this database is called a 'feature' and collectively, all 290 features are called the feature database (FDB). We selected sequences from GenBank's nucleotides database that contained at least one feature from the FDB. We excluded sequences with the terms 'Eukaryota', 'vector' or 'synthetic' in their organism field. RefSeq entries (e.g. with accession numbers starting with 'NC_') were also excluded to reduce duplicates. We collected the resulting 1760 sequences in a sequence database (SDB). We annotated all occurrences of each feature from the FDB found in the SDB and stored the annotations in a relational database as feature name and type and position. This led to annotation of 3593 cassettes, 88 NCI, 2737 regions and 1797 gaps (total 8215 tokens). Regions of sequences that are not annotated by this process are marked with a special gap feature which is also stored with the annotations. The grammar was developed manually using an iterative process. It contains 21 rules and annotates the cassette arrays of Class 1, 2 and 3 integrons in either direction. In a previous study, the grammar was shown to strongly agree ( = 0.972) with a panel of expert microbiologists. The complete grammar is given in).
Grammar inferenceThe PTA algorithm () is an unsupervised relational learner that infers grammars from unlabelled example texts. PTA works by first constructing a deterministic finite-state automaton (DFSA). This stage is similar to an unsupervised HMM learner. Each edge in the DFSA represents an input token (in our case an annotated feature) and the number of times. Each edge is labelled with the semantic type of a token and a count of how many times it was traversed during the construction of the DFSA. Basic probabilities are derived from the DFSA and used to calculate transition probabilities (c). The nodes S 7 and S 5 score 1/1 = 1 and 2/4 = 0.5, respectively, and are thus selected for merging. that edge was traversed when reading multiple sequences.shows a diagram of a DFSA built from seven example annotation sequences. The PTA algorithm next examines the DFSA and iteratively merges states until a minimum similarity threshold is reached. Every iteration calculates the similarity of every pair of states and the most similar pair is merged if it is above the minimum threshold. This step forms loops in the DFSA graph and may also make it non-deterministic. In such cases a simple transformation is used to make it deterministic again. Loops can be thought of as generalized structures in which the sequences that form a loop form the same semantic type. By analogy to English, this allows us to consider 'sofa', 'book' and 'pencil' a single type 'noun'. We calculate the similarity of two states in the DFSA using one of two functions that calculate a score in the rangeby examining the edges of both states:(1) A local scoring function treats the argument edges for each of the compared nodes as an N-dimensional vector: the edge's token is the axis or direction of the vector's component and each count is the magnitude of the vector along that axis. The similarity of the nodes is the cosine of the angle between the vectors. A score of 1.0 means that the feature vectors are identical, 0 means that they are orthonormal to each other, which occurs if the two feature vectors have no common axes. The score W given to each node pair i and j
Computational inference of grammars for LGSwith k semantic types is calculated by the formula:This method generalizes the most similar nodes under the assumption that they represent a similar pattern of tokens. However, it could also be too sensitive to noise as it considers infrequent patterns.(2) A global scoring function that calculates the likelihood that two nodes should be merged given the overall similarities between all the nodes in the graph. The transition probability (p Tx,y ) that a token with a semantic type x is followed by one with type y (i.e. that a given state with an in-edge labelled x, will 'transition' the DFSA to an out-edge labelled y) is calculated using a Bayesian probabilistic model:where p(x) is the probability of a random token in the training set to be of type x; and p(x|y) is the probability of a token to be of type x, given that the token that immediately precedes it is of type y. These probabilities are calculated for the entire DFSA simultaneously such that every node with an in-edge labelled x and an out-edge labelled y contributes to P Tx,y. The highest p Tx,y is called p T-MAX. If p T-MAX is above the threshold and several nodes contribute to p T-MAX (), we merge the two nodes that contribute the most (i.e. have highest x/y values). If only one node contributes to p T-MAX then the we use next highest p Tx,y provided it is too above the threshold. The global method considers only the most common transitions (patterns), and thus ignores incidental similarities between nodes that may be caused by noisy data. We assumed that LGS may occur in either direction in the data and so we tested each scoring method using three sets of arguments: the input edges of the compared states (Prefix), the output edges (Postfix) or both kinds of edges (Context). Hence, we compared six unique generalization methods. In machine learning terms, this algorithm is classified as unsupervised as it attempts to elucidate structures and these structures are not annotated in the training set. We note that while the training set is annotated, it is only annotated with low-level entities, learning of which is not being attempted here.
Structure predictionThe context-free grammars generated from the PTA are expressed in Chomsky Normal Form (CNF;) and hence produce binary parse trees (see lower parse tree in). The generated grammars are used to annotate the test set resulting in a parse tree for each GenBank sequence. Each internal (i.e. non-leaf) node in the parse tree represents a potential LGS, but some represent coincidental and meaningless associations. We predict an important LGS as those that are less likely to occur frequently in the SDB by chance. To distinguish such LGS we calculated the weight W of each symbol s according to the formula:is the number of leaves in the parse tree of a given occurrence i of s. This formula, gives preference for long structures (i.e. with many leaves) that occur frequently in the corpus over short ones that are more likely to have occurred together by chance. Thus, the sequence incontributes 1 to the score W S1 as there is one feature below S1, and 9 to the score W S3 as there are 4 features in the subtree of one S3 symbol and 5 in the other. The two highest scoring symbols are designated as structure-prediction symbols, meaning that the algorithm predicts that the features in their subtrees form an important LGS. We measured the accuracy of predictions compared with existing gold standard cassette array annotations established previously () in two ways. First, we compared the leaf nodes in the parse trees of each of the predicted structures with the leaves of the parse trees in the gold standard (). We also compare whether leaf tokens classified as belonging to a LGS in the gold standard cassette array (CassArray) also belongs to structure predicting symbols (e.g. S4 in). A leaf token appearing in both is labelled a true positive (TP). False positives (FP) are leaf tokens of predicted structures that are not in a subtree of a CassArray. Features of CassArray tokens that are not in structure predicting symbols are false negatives (FN). All other annotated features belong to neither of the groups and are hence true negatives (TN). This method provides an evaluation of how well the method predicts whole structures. It is, in a sense, more stringent than the proportionate method as it only accepts whole structures, but it is more lenient in that it accepts gaps before an after the structure. We also measured structure matches where a structure predicting token matches the position and length (ignoring gaps before or after the structure) of a CassArray in the gold standard (TP). Nested structure predictions (i.e. when a structure predicting symbol occurs in a subtree of another structure predicting symbol) are ignored. All other structure predicting symbols are considered FP even if they overlap a CassArray symbol. Non-structure predicting symbols are counted as FN if they exactly match CassArray symbols or TN otherwise. This evaluation measures prediction of the structure itself, as well as the region it occurs in.
Generalization method comparison and parameter optimizationWe compared the performance of all six generalization methods with an HMM and an algorithm that randomly merges states. We ran each experiment 30 times with different random training sets consisting of 10% (N = 176) of sequences. We varied the minimum similarity threshold between 0 and 1 to find the optimum for each algorithm. We used the optimal threshold to calculate the performance of the best local and global generalization methods, given a training set of between 5 and 50% of the SDB.
Noise toleranceTo see how the method performs with noisy datasets, we gradually added features not normally found in cassette arrays to the anno-annotated SDB. We randomly selected annotations from 101 features associated with antibiotic resistance, which include antibiotic resistance genes (not found in gene cassettes), insertion sequences, Tn3-like transposons and inverted repeats of Class 1, 2 and 3 integrons. To the 8215 gene-cassette annotations used in the experiments above, we added an amount equivalent to between 5% (411) and 100% (8215) of extra annotations and adjusted gap tokens accordingly.
RESULTS
Comparing generalization methodsResults from repeating each experiment 30 times with different randomly selected training sets, are reported in(proportionate) and(whole structure) relative to HMMs and a generalizer that randomly merges DFSA states. All six generalization methods outperform the HMM and random generalizer. The tables report average sensitivity (Sn = TP/(TP + FN)), specificity (Sp = TN/(TN + FP)), F-scores (F = 2SnPPV/(Sn + PPV)), positive predictive value PPV = TP/(TP + FP) and area under the receiver operating curve (TP rate versus FP rate). We measured the performance of each generalization methods for various thresholds (). The global methods performed best with a threshold of 0.3. The local generalization methods did not vary much in performance except between zero and non-zero thresholds. This is because similarities between states using these methods tend to be binary: either two states have very similar in-edges or very dissimilar ones.Each result is based on the best achieved F-score for the algorithm, the threshold used to obtain it and the number of rules it generated and the area under the recipient operating curve (AUC).
Page: 794 791796
G.Tsafnat et al.
Training set sizeWe varied the size of the training set for Local/Prefix and the Global/Context methods between 2.5 and 50%. We used 1.0 and 0.3, respectively, as the minimum similarity thresholds for state merging. We found that in both cases, a 5% training set is sufficient for achieving a very similar F-score to that achieved using a 50% training set ().
Noise toleranceWe measured the performance of the global generalize using 30% transition probability threshold and 10% (N = 176 sequences) training set randomly chosen 30 times (). As expected, added noise reduces the quality of the inferred grammars, but even when half the data is noise, performance is still high with F-score of 0.68.Results are based on matched CassArray symbols in the gold standard with structurepredicting symbols in the generated grammars.
DISCUSSIONThe results indicate that, at least in our domain, inferring grammars for LGS can be achieved with a moderate training set size. Selecting sequences for the SDB from GenBank may have worked in our favour as GenBank's bias is likely to over-represent Class 1 integrons compared with the general bacterial population. This bias is unavoidable and may work against, not for, de novo structure discovery. However, the relatively small training set needed to identify a recurring structure and the high tolerance to noise are encouraging and mean that despite this bias, new structures may yet be found in GenBank. Further experiments are required to test algorithm performance on sequences from natural populations. In this article, we have set a framework for such evaluation. We have used two methods to evaluate the ability of the generated grammars to identify structures correctly. Proportional matching of the grammar accounts for structures that were partially discovered.For example, when a sequence of five tokens (leaves) has a gold standard CassArray annotation but only four were annotated with a structure predicting token. In this case, the annotation itself is not exactly right but the correct region was indeed identified. We have shown that our method outperforms HMMs using this evaluation. We also report a measure based upon whole structure identification. HMMs predict arrays very poorly, in particular when negative predictions are assigned the same weight as positive ones (F-score). A possible explanation to HMMs' poor performance is the small training set (10%) and we have shown that adding generalization improves performance. Among horizontal gene transfer mechanisms, gene cassette arrays are the most modular with the highest variability in the type and number of antibiotic resistance genes. We therefore believe that our algorithm will be able to identify other structures such as transposons and insertion sequences much more accurately. The noise experiments simulate a de novo discovery scenario where not all annotations processed by the system belong to a single structure. In these experiments, we needed to ensure integrons remain the dominant structure for a meaningful comparison with the gold standard. We thus added 'noise' annotations from several other structures to the annotation set ensuring that 'relevant' annotations are always at least 50% of the annotations our system sees leaving integrons as the dominant structure. In a de novo discovery scenario, we expect that annotations of parts of known structures will be removed from the annotations before the system is run so that the remaining most dominant structure is discovered. De novo discovery of LGS using our methods relies on previously known component features (e.g. gene cassettes), but does not require prior knowledge of their relationship in a structure. Existing methods for prediction of component genes (), inverted repeats () and other features can be used in conjunction with our method.
Computational inference of grammars for LGS
CONCLUSIONWe have shown that novel LGS can be discovered in DNA sequences in which relevant features of the structure are annotated even using a relatively small training set (5%) and large amounts of noise (100%). An important aspect of this approach is that the inferred grammar represents a general model that accurately identifies structures without referring to prior knowledge about them. Hence, this method seems promising for de novo discovery even if only a few examples exist in the corpus.
The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
