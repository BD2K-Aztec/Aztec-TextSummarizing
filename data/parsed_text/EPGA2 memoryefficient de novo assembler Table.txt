Motivation: In genome assembly, as coverage of sequencing and genome size growing, most current softwares require a large memory for handling a great deal of sequence data. However, most researchers usually cannot meet the requirements of computing resources which prevent most current softwares from practical applications. Results: In this article, we present an update algorithm called EPGA2, which applies some new modules and can bring about improved assembly results in small memory. For reducing peak memory in genome assembly, EPGA2 adopts memory-efficient DSK to count K-mers and revised BCALM to construct De Bruijn Graph. Moreover, EPGA2 parallels the step of Contigs Merging and adds Errors Correction in its pipeline. Our experiments demonstrate that all these changes in EPGA2 are more useful for genome assembly.
IntroductionGenome assembly is one of the most important tasks in numerous applied fields (). When using one software to reconstruct complete genome sequence from sequence data, researchers not only emphasize assembly results but also memory efficiency. Although many softwares have been developed for genome assembly, their balance between accuracy and memory efficiency are not satisfactory due to complex data structures. We previously published EPGA (), one de novo assembler which can resolve some problems caused by complex repetitive sequence regions. Although EPGA can get satisfactory assembly results, it does not have advantage about peak memory comparing with other popular assemblers. The bottleneck of EPGA's memory efficiency primarily exists in two steps: K-mers Counting and De Bruijn Graph Constructing, because EPGA requires that all reads and K-mers reside in memory. Such storage strategy ends up with the memory consumption growing dramatically as the number of reads is increasing. DSK () is one K-mer counting tool which partitions reads, and each partition is separately loaded in memory. BCALM () is one algorithm for building simple paths in De Bruijn Graph which clusters K-mers and iteratively loads each cluster in memory. For resolving memory problem in EPGA, we present EPGA2, which replaces some components in EPGA with DSK and BCALM. In addition, EPGA2 adds Errors Correction in its pipeline and parallels the step of Contigs Merging. The experimental results demonstrate that EPGA2 can produce more satisfactory contigs and scaffolds using small memory.
MethodsThe EPGA2 pipeline consists of seven steps: (i) Errors Correction: there will usually be some errors in sequencing data, EPGA2 adopts
ExperimentWe evaluate the performance of EPGA2 on four real datasets which include two bacteria (Staphylococcus aureus and Escherichia coli) and two fungi (Schizosaccharomyces pombe and Neurospora crassa) provided by AllPath2 (). Details about these real datasets are shown in Supplementary Table S1. We compare EPGA2 with other popular assemblers: Abyss (), Velvet (), SOAPDenvo2 (), PE-Assembly () and AllPath2. To provide unbiased benchmarks, we use evaluation tool GAGE () which provides corrected analysis. GAGE splits contigs and scaffolds at every error position and provides corrected results. CN50 is N50 of corrected contigs or scaffolds. Assembly results are listed in, and the explicit results are listed in Supplementary Tables S2S5. We can get that EPGA2 offers substantial improvements over the original EPGA. CN50 usually can represent the accuracy of assembly results, EPGA2 gets longer S.CN50 in all real datasets. For coverage, EPGA2 mostly acquires higher coverage than EPGA for contigs and scaffolds. The improvements are caused by adding Errors Correction step which enhances the function of assembly strategies in EPGA. For the four genomes, EPGA2 only requires 0.9G, 1.7 G, 6.1 G and 15 G memory for assembly which are smaller than EPGA and other popular assemblers. This improvement is due to partition strategies of DSK and BCALM which partition reads and K-mers, and each partition is separately loaded in memory. EPGA2 parallels the step of Contigs Merging which can save time, especially for large datasets. Because the first three datasets are relatively small and the decrease of running time in Contigs Merging is smaller than the increase of running time about BLESS, EPGA2 runs longer time than EPGA in the three datasets. Paralleling Contigs Merging can save more time for large datasets, and therefore EPGA2 runs shorter time than EPGA for the last dataset.
ConclusionIn this article, to resolve the memory efficiency problem in EPGA, we present EPGA2, which updates some modules in EPGA. In addition, for reducing running time, EPGA2 parallels Contigs Merging. For improving accuracy of assembly results, EPGA2 adds Errors Correction using BLESS. The experimental results demonstrate the balance between assembly results and memory efficiency of EPGA2 is satisfactory. EPGA2 should be particularly appropriate for researchers with limited computing resources.C.Num, the number of contigs; C.CN50, the CN50 of contigs; C.Cov, the coverage of contigs; S.Num, the number of scaffolds; S.CN50, the CN50 of scaffolds; S.Cov, the coverage of scaffolds; time, running time; PM, peak memory. Last column is the smallest peak memory and corresponding assembler about other popular assemblers.
Funding
EPGA2
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
