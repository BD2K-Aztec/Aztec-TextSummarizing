Motivation: To attain acceptable sample misassignment rates, current approaches to multiplex single-molecule real-time sequencing require upstream quality improvement, which is obtained from multiple passes over the sequenced insert and significantly reduces the effective read length. In order to fully exploit the raw read length on multiplex applications, robust barcodes capable of dealing with the full single-pass error rates are needed. Results: We present a method for designing sequencing barcodes that can withstand a large number of insertion, deletion and substitution errors and are suitable for use in multiplex single-molecule real-time sequencing. The manuscript focuses on the design of barcodes for full-length single-pass reads, impaired by challenging error rates in the order of 11%. The proposed barcodes can multiplex hundreds or thousands of samples while achieving sample misassignment probabilities as low as 10 Ã€7 under the above conditions, and are designed to be compatible with chemical constraints imposed by the sequencing process. Availability and Implementation: Software tools for constructing watermark barcode sets and demultiplexing barcoded reads, together with example sets of barcodes and synthetic barcoded reads, are freely available at www.cifasis-conicet.gov.ar/ezpeleta/NS-watermark.
IntroductionSingle-Molecule Real-Time (SMRT) sequencing, with average read lengths of $10 kbp (), is poised to remarkably simplify genome assembly and targeted sequencing in many applications (). In this new era, DNA reads are considerably longer, but unfortunately corrupted by unusually high rates of sequencing errors. For SMRT sequencing, error rates of $11% (), with a predominance of insertions/deletions (indels) and only $1% substitution errors (), must be considered. Fortunately, in any information transmission process affected by noisein this case SMRT sequencingerrors can be corrected by adding enough redundancy to transmitted informationin this case DNA sequences(). The simplest way to add redundancy is to transmit multiple copies of the information in the hope that it will be possible to recover the original data through some form of consensus. This is, for example, the rationale behind genome oversampling or coverage, which is used across sequencing technologies to obtain virtually error-free sequences from noisy reads. We will see, however, that this approach cannot be directly applied to parallel multiplex () SMRT sequencing without sacrificing the much desirable read length. Multiplex sequencing relies on the use of short oligonucleotides, known as barcodes, to tag DNA fragments belonging to different samples, which provides a means for translating the massive throughput of next-generation sequencing (NGS) technologies into reduced sequencing costs. Barcodes are sequenced and identified to assign each read to a sample, which is known as demultiplexing. A variant of SMRT sequencing called Circular Consensus Sequencing (CCS), which provides more accurate reads, is generally advised for SMRT multiplex applications (). In this variant, SMRT reads of improved quality are generated from intramolecular consensus over subreads obtained from multiple (! 2) polymerase passes along a circularized sequencing template, which follows the repetition approach described above. With CCS, however, the length of native reads is reduced by a factor equal to the number of polymerase passes. To attain Illumina-level quality values, about five passes are needed and the effective read length drops to a few kilobases (). For the longer read length afforded by SMRT sequencing to be fully leveraged, multiplexing would need to work directly with single-pass reads, known as Continuous Long Reads (CLRs). In this scenario, all error correction would depend on redundancy embedded in the barcodes themselves. However, it has been noted that current barcodes for SMRT-CCS reads, with lengths below 20 nt, are not sufficiently robust and that longer barcodes would be needed for this purpose (). This comes as no surprise, since most existing SMRT-CCS barcodes are obtained by imposing a minimum edit distance constraint to sets of random sequences (), a design method known to scale poorly with increasing barcode length (). To overcome the limitations of random barcodes in general multiplex SMRT sequencing applications, systematic barcodes can be alternatively explored. Recently, watermark barcodes, a class of systematic barcodes able to deal with sequencing indels and substitutions, have been proposed by. These are inspired in the design of watermark error correcting codes (), originally developed to deal with synchronization and substitution errors in digital communications. In these applications, synchronization errors are modeled as the random insertion and deletion of symbols (), and are thus assimilable to sequencing indels. Briefly, watermark codes consist of an information-containing carrier sequence imprinted with an arbitrary but fixed sequence of equal length, known as watermark. In the original formulation of watermark codes, the carrier sequence is sparse, meaning it contains a majority of null or 'zero' symbols (i.e. symbols which, when imprinted withor added toanother, will not modify it, much like zero in regular arithmetic). To obtain this carrier sequence, an information message is protected by a tandem of two error correcting codes, known as outer and inner code. Both of these embed redundancy in the form of additional symbols, so that the resulting sequence is considerably longer than the original message. For example, one of a set of 48 DNA samples, which in principle requires only three bases (4 3  64 ! 48), might be represented by a carrier of, say, 16 symbols, most of the null type. When the watermark is imprinted over the carrier, the sparse constraint implies that the resulting sequence will match the watermark at most positions. Since the watermark is known to the decoder, this similarity provides a means to maintain synchronization in the presence of random insertions and deletions. Substitution errors which remain after achieving synchronization are dealt with through regular error correction, making use of available redundancy. Although watermark barcodes appear promising, their practical design for sequencing applications remains an open problem: for SMRT-CLR sequencing error rates, even the best barcodes reported byyield sample misassignment rates in the vicinity of 5%. In this paper, we revisit the design of DNA barcodes around the watermark concept. As opposed to, we consider short low-density parity check (LDPC) codes () as outer codes, which offer the interesting possibility of discarding very noisy reads rather than risk erroneous decoding. In addition, as our main contribution, the key watermarkcarrier imprinting that conveys resilience to challenging insertion and deletion errors is modified so that non-sparse carriers are now allowed. This is accomplished by introducing a non-sparse inner code and an appropriate decoding algorithm adapted from, and is shown to significantly improve multiplexing performance. Further, we propose an algorithm that leverages knowledge about the chemical context where the barcodes are embedded to detect their boundaries. Finally, we show that the number of barcodes which are chemically suitable for use on the sequencing platform can be increased by exploiting the arbitrariness of the watermark. Together, these design enhancements define the flexible class of non-sparse watermark (NS-watermark) barcodes, which offer high multiplexing capacity and are sufficiently robust for use in SMRT-CLR sequencing applications.
ApproachTo allow correct demultiplexing in the presence of errors, redundancy must be added to sequencing barcodes. While this can be done directly in the domain where errors naturally occur, it has been shown that better performance can be achieved by 'packing' lowlevel symbols together and designing codes in higher order finite fields (). A finite field of order q, denoted by F q , is an alphabet of q symbols with special rules for addition, subtraction, multiplication and division. Watermark barcodes, introduced by Kracht and Schober (2015) and revisited here, exploit the above fact and embed redundancy into an information message through a combination of an outer code, defined on a high order finite field F q and an inner code, which operates at the level of nucleotides or quaternary (F 4 ) symbols.
Watermark barcodes based on short LDPC outer codesThe outer code adds redundancy to an information message, which encodes the sample number, to protect it against substitution errors. This message is represented as a sequence x of length k whose elements belong to F q , i.e. x 2 F k q. Redundancy is introduced by a linear error correcting code, which encodes each of the q k possible values of x into an 'outer codeword' d 2 F n q of length n, that carries k informative symbols and m : n  k redundant ones (). In a linear code, redundancy is added in such a way that the elements d i of d satisfy a series of linear constraints (e.g. d 4  3d 1  4d 2 ). In, tabulated linear codes found by exhaustive methods and collected inwere used as outer codes. Instead, we preserve the original formulation of watermark codes relying on powerful LDPC codes (). In particular, we use short quaternary LDPC codes developed byfor DNA barcoding applications affected mainly by substitution errors. These can be easily extended to arbitrary order fields, unlike the codes collected in, currently limited to F 9 .
Watermark barcodes based on non-sparse inner codesGiven an outer codeword d, the inner code expands each symbol d i 2 F q into a quaternary sequence e di of fixed length u, taken from an inner codebook E of size q  u. As a result of this expansion, quaternary carriers c of length l : nu are obtained. Carriers are then imprinted with a known quaternary watermark sequence w of the same length (by simple symbol-wise addition over F 4 ), resulting in imprinted sequences b. Finally, using a fixed mapping from F 4 into the 'nucleotide space' N : fA; C; T; Gg, a set of q k candidate barcode sequences is obtained (). Davey and MacKay (2001), as well as Kracht and, constrain the sequences of E (e 0 through e q1 ) to be sparse. This helps achieve synchronization by introducing relatively few modifications to the watermark. However, it is accomplished at the expense of increased similarity between watermark-imprinted codewords, which may in turn lead to diminished error correction performance. Still, if codewords are sufficiently long (e.g. with hundreds or thousands of symbols, as in communication applications), the blessing face of dimensionality turns such effect unnoticeable. Conversely, if the length of codewords is reduced to the range of tens of symbols, as in the case of DNA barcodes, similarity between codewords may become a major concern, particularly at high levels of noise, as in the case of SMRTCLR sequencing. This may explain the poor performance of watermark barcodes recently proposed byfor this range of error rates. To overcome this problem, we instead select the sequences of E with no constraints other than large pairwise hamming distance (i.e. choosing them to be as different as possible). As a result, the minimum edit distance factor, which is key for the performance of any coding scheme, improves significantly.
Barcode filteringOf the initial M : q k candidate barcode sequences, only a reduced number B will be chemically suitable for the SMRT sequencing platform. Different factors can reduce multiplexing capacity, including GC content, homopolymers, primer dimer formation and compatibility with sequencing adapters. In order to account for these effects and filter out unsuitable barcodes, we consider a filtering stage based on a version of the barcrawl filtering tool () adapted to accept external candidate barcodes. Specifically, barcodes are filtered based on the following criteria: GC content between 35% and 65%, maximum homopolymer length of 5, maximum heteroduplex length of 6 and maximum hairpin length of 6. This filtering stage considers not only the individual barcodes but also their compatibility with one another and with the SMRT sequencing adapter.
On the choice of the watermark sequenceAs long as it is fixed and known, the watermark can be arbitrarily chosen, and a random sequence is the usual choice (). However, random watermarks can perform poorly when it comes to satisfying chemical constraints. To overcome this limitation, we propose a method that exploits the arbitrariness of the watermark string to minimize the loss of multiplexing capacity due to chemical constraints. More precisely, we traverse the watermark from left to right and, at each position, select the base which maximizes the number of surviving barcodes after the barcrawl filtering stage. This process is repeated until no improvement is achieved in an entire pass (indicating a local minimum). At this point, a fixed number of bases are changed at random before traversing the pattern again. In essence, this is an iterated local search () where the number of barcodes lost during the filtering stage is taken as the cost function. For the seven NS-watermark barcode sets discussed later in this paper, this simple heuristic approach yields an average $1.5-fold increase in multiplexing capacity relative to the use of random watermarks, with no apparent degradation in multiplexing performance.
A model for SMRT sequencing errorsIn order to formally describe indels and substitutions introduced by the sequencing process, DNA sequences were modeled as being transmitted over a noisy channel. For this purpose, the Insertion Deletion Substitution (IDS) channel model, defined byand adapted to sequencing by, was considered (). For each incoming base, a random base can be inserted with probability P i (which can happen a maximum of I times), and then the current base is either deleted with probability P d or sequenced ('transmitted') with probability P t. Sequenced bases can themselves be correctly sequenced with probability 1  P s or suffer a substitution error with probability P s. When a substitution occurs, the three possible base replacements are equiprobable.
Demultiplexing NS-watermark barcodesTo demultiplex corrupted watermark barcodes, a two-step decoding process is used. An inner decoder first processes the raw received sequence, affected by indels and substitutions, and produces an outer codeword corrupted only by probabilistic substitution errors. This codeword then enters an outer decoder which recovers the original information, i.e. the sample number.
Inner decodingLet r be the sequence of quaternary symbols obtained by sequencing a NS-watermark barcode and mapping it back from N to F 4. We know that r ultimately comes from an outer codeword d whose symbols d 1. .. d n have been expanded into sequences of size u and watermarked before being sequenced. Based on this, let r i be the subsequence of r that corresponds to d i. If no indels occur, r i  r i1u1. .. r iu   . If we do admit indels and define the drift x i at the start of the transmission of d i as the difference between insertions and deletions up to that point, then r i  r i1u1xi. .. r iux i1 . Since the probability of an indel occurring does not depend on errors made in the past, the Markov property Px i1 jx i. .. x 1   Px i1 jx i  holds for drift variables. Therefore, the process of sequencing expanded and watermarked codeword symbols d i can be modeled as a Hidden Markov Model (HMM) M of the Mealy type (with emissions on transitions), with drifts x i defined in some space X as hidden states and subsequences r i as observables (). Given M, the well-known forwardbackward (FB) algorithm can be applied to calculate the likelihoods Ld i  a : Prjd i  a for i  1. .. n and a  0. .. q  1, which will initialize the outer decoder:where r  : r 1. .. r i1  and r  : r i1. .. r n  . In (1), F i x   and B i1 x   are known as forward and backward quantities, respectively, and can be computed from M using the standard formulation of the FB algorithm, namely:The calculation of forward quantities is made recursively from an initial boundary condition F 1 x (representing a priori knowledge about the initial drift) and is known as a 'forward pass'. Similarly, the recursive calculation of backward quantities from a final boundary condition B n1 x (representing a priori knowledge about the final drift) is known as a 'backward pass'. In (1), (2) and (3), terms of the form Pr s ; x 1 ! x 2 jd s  a represent the probability that drift changes from x 1 to x 2 during the transmission of d s and such transmission results in the reception of r s , given that d s is equal to a. To compute these quantities, let t s be the transmitted substring that would correspond to d s if d s were indeed equal to a (i.e. e a plus the appropriate symbols of w, namely w s1u1. .. w su ). Further, note that the probability of receiving r s and the drift changing from x 1 to x 2 is equal to the probability of receiving r s and the drift changing by Dx : x 2  x 1 , since the probability of new indels does not depend on the current drift. Moreover, the drift change Dx is implicit in the lengths of r s and t s , since Dx  lenr s   lent s . In light of the above, Pr s ; x 1 ! x 2 jd s  a can be simplified to Pr s jt s . To calculate Pr s jt s , we introduce a new HMM H (), which is analogous to M except that hidden variables d 1. .. d u defined in some space D now represent the drift before transmitting each individual nucleotide and observables q 1. .. q u represent (possibly empty) strings received from the transmission of a single nucleotide through the IDS channel model (). Pr s jt s  is then calculated by performing a nucleotide-level forward pass over the u states of H, according to (4) and (5) below:where t y1 is the y  1-th quaternary symbol of t s and Pq y1 jt y1  is the probability of receiving the (possibly empty) stringthe transmission of t y1 , which is calculated according to (6) below. The boundary conditions for (5) are f 1 d  1 for d  0, and f 1 d  0 for any other d, because the local drift before transmitting any symbols is necessarily 0. A nucleotide-level backward pass, needed for the boundary estimation algorithm, is handled analogously to (4). The emission probability Pq  jt   of receiving a substring q  from the transmission of a single quaternary symbol t  can be obtained by inspection of the IDS channel model ():where l : lenq  .The summations on (1), (2) and (3) should in principle iterate over the space of all possible drift values, which is computationally impractical. To reduce complexity, the iteration is limited to an 'outer drift space' X : fx min ; x max g, which equates to considering a maximum drift of x max and a minimum drift of x min throughout the transmission of the current barcode. Similarly, when calculating nucleotide-level passes according to (5), an 'inner drift space' D : fd min ; d max g is considered, which equates to considering a maximum local drift of d max and a minimum local drift of d min during the transmission of a single outer symbol.
Outer decodingBy computing the likelihoods Ld i  (i.e. the likelihood that each symbol of d took each of the q possible values), the inner decoder effectively transforms any combination of indels and substitution errors affecting r into probabilistic substitution errors, for which the outer linear code was specifically designed. Given these likelihoods, generic linear codes can be decoded using Maximum-Likelihood (ML) approaches, which select the codeword that maximizes the probability of receiving r. While this is mathematically optimal, there always exists a codeword which maximizes such probability and, thus, decoding never fails. As noted by, incomplete decoders (i.e. decoders that report a decoding failure when the result is ambiguous) can be used instead to provide a tradeoff between detected errors (read losses) and undetected errors (sample misassignments). In multiplex sequencing applications, it is usually far preferable to discard a read than to assign it to an incorrect sample. Additionally, ML decoding scales poorly (, which becomes prohibitive as we explore longer barcodes and higher multiplexing capacities. In the particular case of LDPC codes, an iterative decoding algorithm known as Belief Propagation (BP) () can be used instead to simultaneously address both issues. Specifically, complexity now scales linearly with n (), while the maximum number of iterations can be used to control the tradeoff between read losses and sample misassignments, as explained below. Although the details are outside the scope of this manuscript, BP can be intuitively understood as a message passing algorithm on a graph like that shown in. The graph includes a set of variable nodes (labeled d 1 through d n ) which represent the n symbols of an outer codeword, a set of constraint nodes (labeled ) and a set of connecting edges. A constraint node is said to be satisfied if the sum of variable nodes connected to it is zero (with addition defined over the corresponding finite field and each variable weighted by an appropriate constant). Connecting edges are drawn so that every constraint is simultaneously satisfied if and only if a set of values for d 1 through d n forms a valid codeword, thus providing a compact graphic representation of the code structure. Decoding begins with an initial guess for the probability distribution of each variable node, given by Ld i  a, as calculated by the inner decoder. If the value with the highest probability is selected for each variable node (which is known as 'hard thresholding') and the resulting set of values satisfies every constraint, a valid codeword has been found and decoding stops. If, however, at least one constraint is not satisfied, the BP algorithm draws progressively close to a valid codeword by iteratively exchanging belief 'messages' between variable and check nodes. After a variable number of iterations, the algorithm is expected to converge to a distribution which, when hard thresholded, satisfies every constraint and thus corresponds to a valid codeword. If this does not occur within a predefined number of iterations, a decoding failure is reported. In our sequencing context, the latter means that the received sequence is too noisy to be confidently decoded and the read is simply discarded. If we admit few iterations, only barcodes with few errors will reach convergence and decoding will be very conservative (few sample misassignments but many discarded reads). Conversely, if we admit many iterations, fewer reads are discarded but more reads are misassigned.
MethodsTo assess their performance in silico, existing watermark barcodes and the proposed NS-watermark alternative were flanked to the left. Illustration of the outer decoding of an LDPC code via Belief Propagation. Edge weights and belief messages are shown only for the first constraint, which is 2d1  3d3  2dn  0 (with Fq arithmetic)Designing robust watermark barcodesand right by appropriate sequences to account for the sequencing adapter, and transmitted through the IDS channel model described previously. The sequenced insert was represented by an indefinitely long random sequence. For codes reported by, the boundary estimation and decoding algorithms reported by the authors were used. Specifically, forward and backward recursions were initialized with a uniform distribution and a soft maximum likelihood linear decoder () was used as outer decoder. For NS-watermark codes, our context-aware boundary estimation algorithm, our inner decoder and a regular BP LDPC decoder with a maximum of 10 iterations were used. The sample misassignment probability P u was then estimated by Monte Carlo simulation. For each set of barcodes, N  5  10 7 barcode sequences were flanked, transmitted through the channel model, passed through the appropriate boundary detection algorithm and decoded. Barcodes were taken in equal numbers from the sets of filtered barcodes. The proportion P u of barcodes for which the decoder output was different from the original sample was computed and taken as an estimate ofwere used instead (). In the case of NS-watermarks, where the BP decoder is incomplete and may report a decoding failure, a similar procedure was used to estimate the read loss probability P e. The theoretical multiplexing capacity M was calculated as q k , while the actual number of barcodes B was obtained by counting the barcodes that were compatible with SMRT chemical sequencing constraints (i.e. that survived filtering). All NS-watermark barcode sets considered in this manuscript are available at www.cifasis-conicet.gov.ar/ezpeleta/NSwatermark.
Multiplexing performance of watermark barcodesSimulation experiments were performed to compare the overall robustness of watermark barcodes recently introduced byand that of the proposed NS-watermark barcoding alternative under different levels of sequencing errors (). For this comparison, we selected the best codes reported byin terms of error performance (q  7, k  2, n  6, u  6) and constructed NS-watermark barcode sets of the same length (l  24) with outer codes defined over F 8 and F 16 (both with k  2, n  6, u  4). For this simulation, mutation probabilities P mut 2 0:01. .. 0:15  were considered, where P mut : P i  P d  P s and P i  P d  P s .
Multiplexing performance of NS-watermark barcodes for SMRT sequencingOn a second simulation, the performance of NS-watermark barcodes of length 24, 48 and 96 with outer codes defined over F 16 was evaluated for particular error probabilities which are representative of the SMRT error profile (). Specifically, we considered P i  0:055; P d  0:055 and P s  0:01. For each barcode length,
J.Ezpeleta et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
.7 Context-aware boundary estimation The forward and backward passes in the inner decoder require boundary conditions given by F 1 x and B n1 x, respectively. If the barcode were sequenced in isolation, then F 1 x would be 1 for x  0 and 0 otherwise (the drift at the start of the barcode would be necessarily 0). Similarly, B n1 x would be 1 for x  lenr  lenb and 0 otherwise (the final drift would be known). In practice, however, a sequencing read includes not only the barcode but also the sequenced insert and certain platform-specific sequences, with no clear boundaries between them. For multiplex SMRT sequencing, a typical experimental setup is known as 'Barcoded Universal Primer' (Pacific Biosciences, 2015), where the insert is capped by a so-called SMRTbell TM adapter (Travers et al., 2010), as shown in Figure 6. In an error-free read, the barcode will be flanked to the left by a 12-nucleotide sequence located immediately after the primer annealing site and to the right by a 30-nucleotide consensus sequence, followed by the insert. If indels occur, barcode boundaries may shift relative to their expected positions, and this must be taken into account for successful decoding. A simple approach to do this is to consider a uniform distribution for F 1 x and B n1 x, as done by Kracht and Schober (2015). However, since the flanking sequences are known, a better result can be obtained by using these as synchronizing markers. Specifically, the left barcode boundary (B) is estimated by performing a nucleotide-level forward pass along the 12-nucleotide left flanking sequence. Because sequencing begins at this point, this forward pass can itself be initialized with a drift of 0 at the start of the left flanking sequence (A). Similarly, the right barcode boundary (C) is estimated by performing a nucleotide-level backward pass along the 30-nucleotide consensus sequence, which is initialized with a uniform distribution at the end of such sequence (D).
Discussion As seen in Figure 7, NS-watermark barcodes consistently outperform the best watermark barcodes reported by Kracht and Schober (2015) for the same barcode length (l  24), while simultaneously increasing multiplexing capacity. Additionally, results show that both the decoding failure probability P e (discarded reads) and the undetected demultiplexing error probability P u (misassigned reads) decrease monotonically with barcode length (Table 1). In connection with this, we note that, although working with CLRs introduces significantly higher error rates than using CCSs, it also makes it possible to use longer barcodes while keeping the relative barcoding overhead within reasonable limits. For example, 96 bp barcodes, which are unfeasible for CCS reads or short read technologies, introduce a relative overhead of less than 1% on the average CLR of around 10 kb. Additionally, the use of scalable design and demultiplexing algorithms makes such longer barcodes feasible from the computational point of view. We further note that, because of the low sample misassignment rates, correctly assigned reads are expected to vastly outnumber misassigned reads for any given sample. Under these conditions, misassigned reads are likely to be 'washed away' by downstream consensus within each sample group and, therefore, the final per-base error due to undetected demultiplexing errors could be several orders of magnitude smaller than the reported sample misassignment rate. A major advantage of the proposed NS-watermark is the flexibility it offers for code construction. Within reasonable ranges, any combination of u, q, n, l, k, m, w and E yields an admissible barcode set. For a given outer code length n, using more information symbols (higher values of k, lower values of m) increases multiplexing capacity but decreases multiplexing performance. For a given multiplexing capacity M and barcode length l, higher order fields (higher values of q) improve the sample misassignment rate, albeit at the expense of higher read losses. For a given l, there is usually also more than once choice for u and n such that l  nu. Of these, those with higher u invest more redundancy in the inner code than in the outer code and may be better suited for error profiles with high rates of insertions and deletions, such as the one considered here. Conversely, those with higher n invest more in resilience to substitution errors and may be appropriate for more traditional error profiles. This increased flexibility, along with the systematic construction method, means new code configurations can be explored virtually effortlessly to adapt to changing requirements, given by admissible rates of read losses and sample misassignments, acceptable coding overhead, number of samples or error profiles. In particular, our design method can be easily extended to other sequencing technologies impaired by high rates of indels and substitution errors, notably the much anticipated Nanopore sequencing (Akeson et al., 1999), by appropriately tuning design-time and decoding-time parameters. Funding This work has been supported by the National Agency for the Advancement of Science and Technology of Argentina through grant PICT 2012-2513. Conflict of Interest: none declared.
