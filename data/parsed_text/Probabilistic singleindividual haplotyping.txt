Motivation: Accurate haplotyping—determining from which parent particular portions of the genome are inherited—is still mostly an un-resolved problem in genomics. This problem has only recently started to become tractable, thanks to the development of new long read sequencing technologies. Here, we introduce ProbHap, a haplotyping algorithm targeted at such technologies. The main algorithmic idea of ProbHap is a new dynamic programming algorithm that exactly optimizes a likelihood function specified by a probabilistic graphical model and which generalizes a popular objective called the minimum error correction. In addition to being accurate, ProbHap also provides confidence scores at phased positions. Results: On a standard benchmark dataset, ProbHap makes 11% fewer errors than current state-of-the-art methods. This accuracy can be further increased by excluding low-confidence positions, at the cost of a small drop in haplotype completeness. Availability: Our source code is freely available at: https://github.com/ kuleshov/ProbHap.
INTRODUCTIONAlthough modern sequencing technology has led to rapid advances in genomics over the past decade, it has largely been unable to resolve an important aspect of human genetics: genomic phase. Each human chromosome comes in two copies: one inherited from the mother, and one inherited from the father. Despite the fact that differences between these copies play an important biological role, until recently, decoding these differences (a process known as haplotyping or genome phasing) has been a major technological challenge. In recent years, however, we have seen an emergence of new long read technologies () that may one day enable routine cost-effective haplotyping. Because a long read comes from a single chromosome copy, it reveals the phase of all heterozygous genomic positions that it covers. By connecting long reads at their overlapping heterozygous positions, it is possible to extend this phase information into haplotype blocks, in a process referred to as single-individual haplotyping (SIH) (). Although from the molecular biology side, routine haplotyping seems close to becoming a reality, dealing with long read data remains non-trivial computationally. Under most formulations of the problem, it is NP-hard to recover the optimal haplotypes from noisy sequencing reads (). This has led to a vast literature on heuristics for dealing with this problem as accurately as possible. Here, we propose a new algorithm, PROBHAP, which offers an 11% improvement in accuracy over the current leading method, REFHAP. Unlike most other algorithms, PROBHAP also provides confidence scores in addition to genomic phase. These scores can be used to prune low-accuracy positions and further improve haplotype quality, at the cost of phasing fewer variants. The main algorithmic ideas of PROBHAP are a new dynamic programming algorithm and a probabilistic graphical model. The dynamic programming algorithm determines the haplotypes that maximize the likelihood function Preadsjtrue haplotypes specified by the probabilistic model as well as the probability that these haplotypes are correct. It can be seen as a special case of the well-known variable elimination algorithm (). From a theoretical point of view, the likelihood function specified by our probabilistic model generalizes a well-known objective called the minimum error correction (MEC). Previously proposed exact dynamic programming algorithms for the MEC can be easily derived as special cases of the general variable elimination algorithm within our model. More interestingly, alternative formulations of this algorithm (corresponding to different variable orderings) result in novel exact algorithms that are significantly faster than previous ones. Thus, our work generalizes several previous approaches and provides a systematic way of deriving new haplotyping algorithms.
RELATED WORKMost phasing algorithms solve a formally defined computational problem called SIH, in which the goal is to minimize an objective called the MEC (see Section 5). This objective is NP-hard (); therefore, most early work on the SIH problem involved simple greedy methods (). More recently, these methods have been superseded by more sophisticated heuristics such as RefHap () or HapCut () that involve solving a Max-Cut problem as a subroutine. There is also an exact dynamic programming solution to the SIH problem; its running time is exponential in the length of the longest read (). Several probabilistic approaches have also been previously proposed, including HASH (), MixSIH () and an algorithm used for reconstructing the diploid genome of Ciona intestinalis (). These methods optimize an objective function similar to that of PROBHAP using heuristics based on Markov chain Monte Carlo (MCMC). They differ in the way in which they implement MCMC. In addition, MixSIH () is to our knowledge the only package that also provides confidence scores at phased positions. Probabilistic graphical models are widely used in the statistical phasing literature to determine haplotypes from a panel of individuals using linkage disequilibrium patterns. However, the vast majority of statistical methods do not use the partial phase information provided by long reads, and are not applicable to our setting. A notable exception is a recent method called Hap-Seq (); without its statistical component it reduces to the well-known exact exponential-time algorithm mentioned above (). Also, there exists an extensive literature on the SIH problem from the perspective of combinatorial optimization (). Research in this field is aimed at optimizing combinatorial objectives such as minimum fragment removal, minimum SNP removal or MEC. This research is of a more theoretical nature and aims at providing a rigorous theoretical understanding of the SIH problem ().
RESULTS
Overview of PROBHAPPROBHAP is based on a new exact dynamic programming solution for the SIH problem, which makes it more accurate than many existing methods. Its main drawback is a higher computational cost: its worst-case running time increases exponentially with the read coverage. Fortunately, modern long read technologies cover the genome at a relatively low depth (), making it possible to apply our algorithm to such data. In cases when the coverage is extremely high, PROBHAP also uses a preprocessing heuristic to merge similar reads (see Section 4). In our experience, PROBHAP handles long read coverages of up to 20; however, it is not appropriate for higher coverage short read datasets. The output of PROBHAP is a set of haplotype blocks in the format of RefHap and HapCut. In addition, PROBHAP also produces at each position three confidence scores that can be used to identify locations where the phasing results are less accurate. The posterior score represents the probability of correctly determining the phase of a SNP with respect to the first SNP in the block. The transition score represents the probability of correctly determining the phase of a SNP with respect to the previous one. Finally, the emission score is often helpful in finding sequencing errors and other issues with the underlying data. Whenever the transition score is too low, we suggest breaking the haplotype block at a position. Whenever the posterior or the emission scores are low, we suggest leaving that position unphased.
Comparison methodologyWe compared PROBHAP to three state-of-the art algorithms RefHap (), FastHare () and DGS () as well as to HapCut (), a historically important phasing package, and to MixSIH (), the only method that we know that produces confidence scores. Previous studies () have identified the above methods as being the current state-of-the-art in single-individual haplotype phasing. Note that we do not compare our method to HapSeq () because this package additionally uses populationbased statistical phasing techniques to improve accuracy. We also do not consider previously proposed exact dynamic programming methods (), as they do not scale to long reads: their running time increases exponentially in the number of variants in a read, and some of the reads in our datasets have 450 variants. The heuristics we consider work as follows. In brief, FastHare sorts the input reads, and then traverses this ordering once, greedily assigning each read to its most probable chromosome given what has been seen so far. The DGS method is equally simple: it iterates until convergence between assigning each fragment to its closest chromosome, and recomputing a set of consensus haplotypes. The RefHap and Hapcut algorithms construct a graph based where each vertex is either associated with a position (HapCut) or with a sequencing read (RefHap); then, the algorithms approximately solve a MaxCut problem on this graph. We test the above methods on a long read dataset from HapMap sample NA12878 that was produced using a fosmidbased technology (). The long reads have an average length of $40 kb and cover the genome at a depth of $3. This dataset is a standard benchmark for SIH algorithms () in part because HapMap sample NA12878 has also been phased multiple times based on the genomes of its parents. In this work, we take the trio-phased variant calls from the GATK resource bundle (); these provide accurate phase at 1 342 091 heterozygous variants that are also present in the long read dataset. We measure performance using the concept of a switch error (). A switch error is said to occur when the true parental provenance of SNPs on a haplotype changes with respect to the previous position. For example, if the true SNP origins of a phased block can be written as MMFF, then we say there is a switch error at the third position. In this analysis, we differentiate between two types of switches: a long switch corresponds to an inversion that lasts for more than one position (e.g. MMFF); a short switch, on the other hand, affects only a single position (e.g. MMFM). Switch accuracy is defined as the number of positions without switch errors, divided by the number of positions at which such errors could be measured. Long switch accuracy is defined accordingly in terms of long switch errors. We also measure accuracy in terms of switches per megabase (Sw./Mb). Finally, a block N50 length of x signifies that at least 50% of all phased SNPs were placed within blocks containing x SNPs or more. The percentage of SNPs phased was defined as the number of SNPs in blocks of length two or more, divided by the total number of SNPs.
ResultsGiven comparable phasing rates and N50 block lengths, PROBHAP produced haplotype blocks with more accurate longrange phase: the long-range switch error of PROBHAP was 11% lower than that of the second best algorithm, RefHap (). In addition, PROBHAP also produced 6% fewer short switch errors than RefHap. Note that long switch accuracy is substantially more important than short switch accuracy, as it drastically changes the global structure of haplotypes. Short switch errors, on the i380
V.Kuleshovother hand, introduce relatively small amounts of noise in the data.
Evaluating confidence scoresIn addition to being more accurate, PROBHAP is also one of the few algorithms which can provide estimates of their accuracy in the form of confidence scores. As an example of how such scores might be used, we pruned phased positions that were deemed by PROBHAP to be uncertain and measured the resulting accuracy. More specifically, we defined thresholds for each of the three confidence scores reported by PROBHAP. Whenever the posterior or emission scores were lower than a threshold, we treated that position as unphased. Whenever the transition probability was below a threshold, we split the phased block into two parts at that position.shows that after pruning, one obtains phased blocks that are 3040% more accurate than the unpruned blocks (recall that we describe them in); the price to pay is a drop of 1025% in N50 and phasing rate. The particular numbers shown inwere achieved by fixing the posterior and transition cutoffs to 0.6 and 10 5 , respectively, and setting the emission cutoff to 10 5 ; 10 4 ; 10 3 ; 10 2 , 0.05, 0.1, 0.4 and 0.99. Next, we compared the pruned regions from PROBHAP to those of MixSIH, the only other package that allows the user to exclude low-confidence positions. We chose thresholds so as to keep either the N50 or the phasing rate constant across both algorithms, and measured how accuracy varied with the remaining non-fixed parameter. We present the results of our experiment in. Overall, we see that given the same level of haplotype completeness, the pruned blocks of PROBHAP contain 2030% fewer switching errors than those from MixSIH.
Running timeWe measured the running times of the algorithms on a laptop computer (). We did not include HapCut in this comparison, as it is several orders of magnitude slower that the other methods (). Although the three heuristics ran faster than PROBHAP and MixSIH, a major reason for their speed was due to not having to compute confidence scores. In fact, PROBHAP spends roughly two-thirds of its running time
METHODS
NotationFormally, an instance of the SIH problem is defined by a pair of n  m matrices M, Q, whose columns correspond to heterozygous positions (indexed by j=1;. .. ; m), and whose rows correspond to reads (indexed by i=1;. .. ; n). We refer to M as the phasing matrix; its entries take values in the set f0; 1; g. These values indicate the allele carried by a read at a given position: for example, M ij = 0 signifies that read i covers position j and carries allele 0 at j. A value of  indicates that read i did not cover position j. Seefor an example of a 2  4 phasing matrix. The n  m matrix Q 2 0; 1 nm is referred to as the q-score matrix; it encodes the probability of observing a sequencing error at a given position in a read. Such scores are available on virtually all sequencing platforms. A solution to an instance of the SIH problem consists of a pair of vectors h 2 f0; 1g m and r 2 f0; 1g n. The former determines the subject's haplotypes: at each genomic position j, it specifies an allele h j 2 f0; 1g. We consider only one haplotype, as the second is always the complement h of the first. The second vector r 2 f0; 1g n indicates the true provenance r i 2 f0; 1g of each read i (i.e. whether i was obtained from the 'maternal' or the 'paternal' copy; because we do not have information to determine which copy comes from which parent, we refer to them as 0, 1). We also useto denote alleles on the haplotype from which read i originated. Next, let Poi=fjjM ij 6  g denote the set of positions covered by read i. Let also H i =fh j jmin Poi j max Poig be the set of haplotype variables spanned by read i and let R j =fr i jmin Poi j max Poig be the set of read provenance variables spanning a position j. We will use this notation to simplify several expressions throughout the article. In particular, if position j is spanned by, say, reads 2, 3, then we will use the notation max
Probabilistic modelWe define the probability Pr; h; o over haplotypes h 2 f0; 1g m , assignments of reads r 2 f0; 1g n and observed data o 2 f0; 1; g nm to be a product of factorswhere( is the probability of observing the allele on the j-th position in read i, and the factors Pr i  and Ph j  are priors that we leave as uniform, except for Ph 1 =0=1. This last choice eliminates the ambiguity stemming from the fact that a solution h can be always replaced with its complement h; it resolves this ambiguity by always choosing the solution with h 1 =0. Finally, note that the r and h variables are hidden, while the o variables are observed; the observed values are defined by the matrix M. The dependency structure of P can be represented in terms of a Bayesian network whose topology mirrors the two-dimensional structure of the matrix M. Seefor the Bayesian network associated with the phasing matrix in, which we gave earlier as an example.
Maximum likelihood haplotypesWe determine maximum-likelihood haplotypes h  =arg max h log Po= Mjh using the belief propagation algorithm, also known as max-sum message passing over a junction tree (). In brief, this algorithm involves groups of variables passing each other information about their most likely assignment; a well-known special case of this method is the Viterbi algorithm for hidden Markov models (HMMs).
Definition of max-sum message passing We start by brieflydefining the max-sum message passing algorithm for graphical models. Readers familiar with the subject may skip this subsection. DEFINITION 1. Let P be a probability over a set of variables X=fx 1 ;. .. ; x n g that is a product of k factors P= Y k i=1 i X i , with each factor i being defined over a subset of variables X i X. A junction tree T over P is a tree whose set of nodes is a family of subsets C=fC 1 ;. .. ; C m g, with C j X and that satisfies the following properties:(1) For each factor i , there is a cluster c(i) such that X i C ci .(2) (Running intersection) If x 2 C i and x 2 C j , then x 2 C k for all C k on the unique path from C i to C j in T.Given this definition, we now define max-sum message passing. We restrict our definition to the case when the junction tree T is a path, which is going to be the case for our model. DEFINITION 2. Let P be a probability distribution as in Definition 1. Let T be a junction tree over clusters C j for j=1;. .. ; m connected into a path and ordered by j, with C m serving as the root. The max-sum message from C j to C j+1 is a function M j defined over the variables in C j \ C j+1 asThe actual assignment that maximizes P can be found by storing the variable assignments that maximize each M j. Unfortunately, proving the correctness of this algorithm is beyond the scope of this article. For a complete discussion that holds for arbitrary junction trees, we refer the reader to a textbook on graphical models ().C j =fr i ; h j ; o ij jmin Poi j max Poig for j=1;. .. ; m connected into a path ordered by j, with C m serving as the root.Each cluster C j contains h j and all the o ij and r i variables associated with reads that span across position j. For an example of one such cluster, seePROOF. It is easy to check that the scope of each factor of P is in a unique cluster. We therefore focus on proving that T has the running intersection property. Let C x , C y be two clusters in T with x y, and let C z be a cluster on the path between C x and C y. Because T is a path, we must have x z y. We need to show that C y \ C x C z. Observe that by construction C y \ C x can only contain r-variables. Let r l 2 C y \ C x be one such variable. We need to show that r l 2 C z , i.e. that min Pol z max Pol. From r l 2 C y \ C x , we have that Pol y x max Pol. Because we also have x z y, our claim follows. Now let R j\j+1 =R j \ R j+1 and R jnj+1 =R j nR j+1. The interested reader may verify that the message from cluster j to cluster j + 1 during a run of max-sum message passing with C m as the root of T equals for j41,. Note that we disregard the priors Pr i ; Ph j  in all messages except the first because they are uniform. Intuitively, MR j\j+1  represents the maximum likelihood of the data at positions 1;. .. ; j assuming that reads spanning both j and j + 1 have provenances specified by R j\j+1. The maximum of P is computed using the recursion max
Running timeThe above algorithm computes one message for each of m. A message specifies a value for each assignment of variables in R j\j+1 ; this value is the maximum over all assignments to h j and to R jnj+1 , and for each such assignment, we need to compute P i:ri2Rj log P o ij jr i ; h j  in OjR j j time. Therefore, computing a message requires jR j j 2  2 jRj\j+1j  2 jRjnj+1j =jR j j2 jRjj+1 iterations. Thus, the total running time of the algorithm is Om2 +1 , where =max j jR j j is the maximal coverage across all the positions.
Confidence scoresNext, we turn our attention to deriving confidence estimates for genomic regions. As an example of why such estimates are useful, we show inthat, somewhat counter-intuitively, two SNPs may be unphased even when they are connected by accurate reads., the data contains sequencing errors at position 3 or 4. If the error occurs at position 3 (in either row), then the two reads come from the same haplotype and the correct solution is h = 00000. If, on the other hand, the error occurs at position 4, then the two reads come from different chromosomes and the true haplotype is h = 00111. If the quality scores are the same at all positions, the four errors are equally likely, and the haplotypes h = 00000, h = 00111 have the same probability. Simple optimization-based algorithms would likely produce a single haplotype in the above example; our probabilistic model, however, would assign a transition probability of 0.5 to position 3.
Motivating example In
Dynamic programming recursionWe again perform probabilistic inference in our model using belief propagation. Our particular implementation of this method is inspired by the sum-product message passing algorithm () over the previously defined junction tree T. In sum-product message passing, clusters of variables pass to each other information about their local probability distribution; after two rounds of message passing (referred to as 'forwards' and 'backwards'), the clusters become calibrated and can be queried for various probabilities. A well-known special case of this method is the forwardsbackwards algorithm for HMMs. More concretely, we compute for each node j two factors, Fh j ; R j  and Bh j ; R j , using the dynamic programming recursions below.The notation R j $R j1 indicates that the r i variables common to both R j and R j1 have been assigned the same value, and PO j jh j ; R j  is shorthand forwhere O k:l =fo ij jk j lg.
Computing confidence probabilities From (4), (5), we can now easily compute confidence scores. One such score is the posterior probability Ph j jO 1:m . It represents the probability that h j was determined correctly with respect to h 1 and can be computed as Ph j jO 1:m = P Rj Ph j ; R j jo 1:m , where Ph j ; R j jO 1:m =PO 1:j ; h j ; R j PO j+1:m jh j ; R j =PO 1:m : Next, the transition probability Ph j jh j1 ; O 1:m  represents the probability of consecutive SNPs being phased correctly; it can be used to detect potential errors like the one shown in. We compute this value using the identity Ph j jh j1 ; O 1:m =Ph j ; h j1 jO 1:m =Ph j1 jO 1:m , where the denominator is the posterior probability and the numerator is computed asAdditionally, we found that the emission probability PO j jh j R j  was useful in detecting errors in the data. Computing this value only involves the expression PO j jh j R j = Q i:j2Poi Po ij jr i ; h j . Finally, note that in general, one can compute any set of probabilities Ph k jh l ; O 1:m  in the model. However, this involves doing potentially up to a full run of message passing.
A merging heuristicThe exact dynamic programming algorithm described above is practical for coverages of up to 1012. For deeper or for highly uneven coverages, we propose a simple preprocessing heuristic. The heuristic consists in reducing the coverage by repeatedly merging reads that are likely to come from the same haplotypes until there are no reads that we can confidently merge. To determine whether to merge reads k, l, we consider the ratiowhere Po kj ; x; y is shorthand for Po k j; r k =x; h j =y. Intuitively, the denominator is associated with the likelihood that the two reads come from the same haplotype and the numerator is associated with the likelihood that the reads' origins are different. Both terms are estimated by a heuristic formula that decomposes over each position. If reads k, l are merged, then position j of the resulting new read is assigned the allele that has the highest q-score in the initial reads k, l (i.e. arg max k;l fQ kj ; Q lj g); the q-score at that position is set to the difference of the initial reads' q-scores (i.e. jQ kj  Q lj j). In practice, one may select a confidence threshold for (6) and only merge reads that are below this threshold. We found empirically a value of 1  10 9 to work well.
A post-processing heuristicIn addition, PROBHAP admits an extra post-processing heuristic for adjusting the optimal haplotypes h . This heuristic was initially proposed for the algorithm RefHap; PROBHAP currently uses it by default, although it can be disabled. The heuristic starts with the optimal read assignments r  and determines at each position j a pair of setsIt then outputs a new haplotype h new defined as h new j = 0 if jS j;0 j4jS j;1 j 1 if jS j;0 j5jS j;1 j  otherwise:We found that this heuristic increases the short switch accuracy of PROBHAP on the NA12878 dataset; the long switch accuracy remains the same. We suggest using this heuristic in settings where the quality scores may not be well calibrated.
DISCUSSION: THEORETICAL ASPECTSInterestingly, the probabilistic framework of PROBHAP generalizes the SIH formalism on which most existing methods are based. This allows us to easily derive well-known exact dynamic programming algorithms as special cases of the variable elimination algorithm for graphical models. More interestingly, the variable elimination algorithm with different variable orderings results in novel exact algorithms that are far more efficient than existing ones.
Generalizing the SIH frameworkIn its standard formulation, the SIH problem consists in finding a haplotype h that minimizes the MEC criterion:where I : fTrue; Falseg ! f0; 1g is the indicator function, and the remaining notation is the same as defined in the Section 4. The MEC measures the total number of positions within all the reads that need to be corrected to make the reads consistent with a haplotype h. It is easy to show that the MEC objective can be recovered as a special case of our framework. Indeed, if we define the factors o ij ; r i ; h j  (which we have previously set to Po ij jr i ; h j ) in a way that o ij ; r i ; h j = exp 1 if o ij 6  h j r i  exp 0 if o ij =h j r i ; ( then log PM; r; h equals MEC(h, M), although P is no longer a probability. Thus, our dynamic programming algorithms can also produce exact solutions to the MEC objective, and just as interestingly, they can produce confidence probabilities associated with the MEC. i384
V.Kuleshov
Rederiving existing SIH algorithmsInterestingly, we can easily recover an existing dynamic programming algorithm () for the MEC as a special case of variable elimination in our graphical model. Indeed, consider the junction tree defined by n variable clusters C i =fr i ; h j ; o ij j j 2 Poig connected into a path ordered by i. If we assume for simplicity that the data have no contained reads, then the message from cluster i  1 to cluster i during a run of max-sum message passing with C n as the junction tree root equals preciselywhere H i\i+1 =H i \ H i+1 and H ini+1 =H i nH i+1. This is essentially the well-known dynamic programming recursion () we were looking to find. Unfortunately, the time to compute the above recursion increases exponentially in the length of the reads, which is precisely the data we want to use for phasing.
Deriving novel SIH algorithmsFortunately, as we have seen, we can derive from our framework exact algorithms that are suitable for long read data. Interestingly, these methods are in a sense dual to equation (7): the structure of the probabilistic model P is entirely symmetric in r, h. If we reverse h and r in Section 4, we obtain recursion (7). Potentially, our framework allows deriving other exact algorithms by defining alternative junction trees for the max-sum message passing algorithm. One way to do this involves using minimizing their tree-width using some well-known heuristics (). Because the running time maxsum message passing is exponential in the tree-width of a junction tree, this would lead to much faster running times.
CONCLUSIONIn summary, we have introduced a new single-individual phasing algorithm, PROBHAP, that offers an 11% improvement in accuracy over the current state-of-the-art method, RefHap. In addition, it is one of the only methods to provide the user with confidence scores at every position; these confidence scores can be used to prune positions whose phase is uncertain and thus substantially increase the overall accuracy. The advances behind PROBHAP are made possible by framing the phasing problem within a probabilistic graphical models framework. This framework makes it particularly easy to reason about the problem; in fact, all our algorithms are special cases of standard procedures for optimizing graphical models. On the theoretical side, this work generalizes the MEC criterion used by existing methods. Our approach allows us to obtain existing algorithms as special cases of well-known optimization procedures, and also easily derive new, more efficient algorithms; it may thus serve as a foundation for further algorithmic insights.
ACKNOWLEDGEMENTWe thank Sivan Berovici for important suggestions regarding the model definition, as well as Dmitry Pushkarev and Michael Kertesz for helpful discussions. This research was partly done at Moleculo Inc.
The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
