Motivation: The application of next-generation sequencing (NGS) technologies to RNAs directly extracted from a community of organisms yields a mixture of fragments characterizing both coding and non-coding types of RNAs. The task to distinguish among these and to further categorize the families of messenger RNAs and ribosomal RNAs (rRNAs) is an important step for examining gene expression patterns of an interactive environment and the phylogenetic classification of the constituting species. Results: We present SortMeRNA, a new software designed to rapidly filter rRNA fragments from metatranscriptomic data. It is capable of handling large sets of reads and sorting out all fragments matching to the rRNA database with high sensitivity and low running time.
INTRODUCTIONThe application of next-generation sequencing (NGS) technologies for metatranscriptomic profiling has been a successful venture in practice. Scientists may now gain access to the full set of coding and non-coding RNA in a community of organisms, which becomes particularly important for samples that cannot be cultivated outside their native environment (). The initial challenge of metatranscriptomic sequenced data analysis is to sort apart the RNA fragments based on their biological significance. Messenger RNAs (mRNAs) cast a universal glimpse on the gene expression patterns between interactive species. Likewise, the ribosomal RNAs (rRNAs) disclose information on the community's structure, evolution and biodiversity, and prevail in classification and phylogenetic analyses. The rRNA can comprise up to 90% of total RNA. Various prior-to-sequencing procedures, such as mRNA amplification kits, can help to enrich the yield of mRNA (). However, these kits are not fully satisfactory, as secondary steps may be required to verify if the resulting material is an accurate representative of the initial samples (). New software has been recently developed to address this issue; this software can identify and isolate rRNA fragments from a set of sequenced reads. The first set of programsMeta-RNA 3 (), SSUALIGN () and rRNASelector ()shares a common algorithmic approach to represent an rRNA family database using a probabilistic model. Both Meta-RNA and rRNASelector use prebuilt Hidden Markov Models (HMM) and consequently sort reads against the database with the HMMER3 package (), whereas SSU-ALIGN uses covariance models to support secondary structure information. An alternative algorithm outside the domain of probabilistic models is riboPicker (), which uses a modified version of the Burrows-Wheeler Aligner (). Lastly, BLASTN () is used in numerous home-made workflows for this problem. With BLASTN, however, reads should be compared with all sequences of an rRNA database to achieve a good sensitivity level. In all cases, computational time is still an issue to handle large collections of reads. In this article, we describe SortMeRNA, an efficient filter requiring only a representative set for an rRNA database and rapidly sorting through millions of reads. The underlying algorithm is analogous to the seeding strategy, focusing on finding many short regions of similarity between an rRNA database and a read. SortMeRNA also takes advantage of redundancy between homolog sequences, as HMMs do, and builds a compressed model of all rRNA sequences. The generated results adhere to the accuracy of the HMM-based programs and are computed in a fraction of the time.
SYSTEM AND METHODS
Algorithm overviewWe assume having a collection of unassembled reads and a database of rRNA sequences, and we want to sort out reads that match to the database. The general principle behind our algorithm is to search for many short similarity regions between each read and the rRNA database. We scan each read with a sliding window, and the accepted reads are those that have more than a threshold number of windows present in the database. For a given read and a given window on the read, we authorize one error (substitution, insertion or deletion) between the window and the rRNA database. To achieve this task in an efficient manner, the rRNA database is stored in a Burst trie coupled with a lookup table that speeds up the access to the Burst trie and takes advantage of conserved regions in the rRNA sequences. For a given read and a given window on the read, we find the set of windows present *To whom correspondence should be addressed.  The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com in Burst trie using the universal Levenshtein automaton. This comparison is done by performing a parallel traversal between the Levenshtein automaton and the Burst trie.globally illustrates this framework. The length s of the sliding window is a parameter of the algorithm, further discussed in Section 2.5. The acceptance of a read depends also on the ratio of matched windows. Let r be this parameter. This choice will also be discussed in Section 2.5.
The Burst trie to store an rRNA databaseThe Burst trie () is a fast and versatile data structure that effectively stores a large number of strings such as an rRNA database. Unlike the standard trie, the binary search tree or other variants, which often adopt an equal rate of memory access among the cache or main memory, the Burst trie can exploit the modern cache architecture by addressing memory closest to the CPU. It is capable of reducing theThis is done with a cyclic traversal between the universal Levenshtein automaton and the Burst trie, which determines whether the subpattern is present in the rRNA database with at most one error. For every letter traversed in the Burst trie, a bitvector is passed to the universal Levenshtein automaton to verify whether the number of encountered errors remains 1. (4) After all windows have been traversed, if the number of accepted windows exceeds a certain threshold (see in Section 2.5), then the read is accepted and classified as rRNA number of trie nodes by 80% while maintaining performance similar to a hash table (). Given a sequence vz, the Burst trie can store the prefix v as a link of trie nodes and the suffix z as an array of characters appended to the last trie node. Normally, subtrees become more sparse in the depth of a trie, and representing them as reduced 'buckets' of contiguous memory preserves space and boosts cache efficiency. When the number of sequences sharing a common prefix v reaches a fixed threshold, the appended bucket of suffixes bursts to form a new trie node and smaller sub-buckets. To optimize memory access during subtree traversal, the threshold size of a bucket should be less than the lower-level cache. A systematic use of this trie can be observed in the fastest sorting algorithm for large sets of strings, the Burstsort (). Following a similar method of an array-structured trie as described in, our Burst trie is assembled exactly on the nucleotide alphabet {a, c, g, u}. As illustrated in, the trie stores every unique (s  1)mer substring in an rRNA database, as we look at windows of length s with at most one error between any two words. The information on whether the (s  1)mer belongs to a forward strand, the reverse complement or both (strand), and its origin (hashid) follows each entry in a bucket. When the exact location of the (s  1)mer needs to be found in an rRNA database, the hashid value serves as an index in a complementary table storing this information. Nearly one-quarter of the 16S rRNA positions are 99100% conserved (), and this moderates the size of the trie, as many identical or closely similar substrings are shared between sequences. We use an additional optimization to improve access into the Burst trie. Because we consider at most one error between the window and the database, we have this simple property: for every two words such that the edit distance between them is bounded by 1, there exists a common substring of length s 2, which is either a prefix or a suffix of the two words. We apply this property to construct a lookup table storing all s 2mers existing in the rRNA database. Note that for s in, transposing the nucleotide alphabet onto a binary equivalent, such that {a, c, g, u}  {00, 01, 10, 11}, we can represent each s 2mer in s bits, which maps to a unique integer value. On completion of the forward and reverse Burst tries, a scan of each trie is performed to record the existence of all s 2mers and, if present, associated pointers to the trie node representing the immediate letter following the prefix. The precomputed lookup table quickly determines whether an exact match of the prefix or suffix exists in the Burst tries, and furthermore it provides us with direct access to the remaining part of the word in the Burst trie. The lookup table also allows us to take into account distribution of s 2mers in the rRNA database. A multiple sequence alignment of an rRNA database can clearly define areas of high nucleotide conservation and emphasize the evolutionary origins shared between organisms. In a similar manner, the lookup table defines highly conserved areas by keeping only frequent s 2mer occurrences in the rRNA database. Before a window is traversed in the Burst trie, its prefix or suffix must exist in the lookup table. This notion enforces that a read matches closely to one region in a database rather than multiple scattered ones leading to a false alignment (see Section 1.1 of the Supplementary File).
The universal Levenshtein automatonThe classical non-deterministic Levenshtein automaton for a pattern p and a number of errors k recognizes the set of strings that are at most edit distance k to p (). This automaton is not suitable for computation because of the presence of multiple active states and epsilon transitions. This may be overcome by transforming the automaton into an equivalent deterministic form. However, the resulting automaton may be exponential in the length of p and likewise dependent on it. In studies by Schulz and Mihov (2002) and Mihov and Schulz (2004), a universal Levenshtein automaton was characterized based on insightful observations of the classical one. The term universal conveys its one-time construction and independency of p. The intuition arises from the symmetry of the non-deterministic automaton, which applies the same set of transition rules to every new input character, and each new set of active states is a subset of a known bounded superset. A set of bitvectors symbolizing the homology of p and a candidate string serve as input to the automaton. In full generality, the size of the automaton is exponential in a function of k (). In our case, as k  1, it remains sufficiently small. The set of bitvectors representing the similarity of two strings is precomputed using the following definition. Definition 2.1. () The characteristic vector ~ w, V of a symbol w 2 P in a word V  v 1. .. v n 2 P  is the bitvector of length n where the ith bit is set to 1 iff w  v i .The technical details of n 2k  2 and the prefix of k symbols of '$' appended to the pattern p can be found in the article byExample 2.1. Let k  1, the input word W  acaga and the pattern p  $acuaga, then 1 a, $acu  0100, 2 c, acua  0100, 3 a, cuag  0010, 4 g, uaga  0010, 5 a, aga  101 are the computed characteristic bitvectors. It follows that f 1 ,. .. , 5 g is the characteristic bitvector array carrying the similarity information of x and p. Beginning from 1 to jsj , the bitvectors are sequentially passed into the universal Levenshtein automaton. Each bitvector leads to a transition between states (in constant time) corresponding to the number of errors encountered thus far. If some i reaches a failure state, greater than k errors exist between s and p, and the strings are rejected. The automaton only recognizes two strings if the input of the last bitvector jsj leads to a final state.
Match of a read with the dynamic bitvector tableAt this point, matching a window w of length s on the read against the rRNA database amounts to first checking whether the prefix or the suffix of length s 2 of w is present in the lookup table, then determining whether the universal Levenshtein automaton for w recognizes some word in the Burst trie. For the second step, we have to implement a rapid traversal of the Levenshtein automaton, which relies on the precomputation of bitvectors for w. At every depth of the Burst trie, we assume that the symbol q in i q, V appears as one of {a, c, g, u} with equal probability. Ultimately during traversal, the bitvector of the actual residing nucleotide is chosen.shows the precomputation of bitvectors for p  $acuaga in Example 2.1. If the string x  acaga existed in the trie, then the highlighted set of bitvectors {0100, 0100, 0010, 0010, 101} would form the bitvector array (see Section 1.2 of the Supplementary File for a graphic example). When the window is shifted by one position, the subsequent pattern p changes simply by the removal of the first character in the prefix and the addition of a new character in the suffix. Hence, rather than recomputing the bitvector table for each new window, a series of bitwise operations is taken to modify it, as demonstrated in. Following a preorder path, the traversal of the Burst trie begins at the root node. Through knowledge of the nucleotide letter and the depth of the node being visited, the coinciding bitvector is accessed in the precomputed bitvector table, indifferent to whether the node is a trie node or a character in the bucket. Subsequently, the bitvector is passed to the universal Levenshtein automaton, which decides whether to continue traversal of the current subtree or backtrack to the first branching point with a non-failure Levenshtein state and recommence traversal of a new substree. In this manner, a complete traversal of the Burst trie remains unlikely, as backtracking occurs each time the edit distance between the pattern and a traversed branch exceeds k. To further speed up Burst trie traversal for every window, a 'backwards dictionary' approach as described in Mihov and Schulz (2004) was implemented. The original algorithm builds two dictionaries, one for the forward strings and the second for their reverse equivalents. In this manner, the same window can be traversed quickly from both ends.
Parameter settingThe algorithm depends on two parameters: the length s of the sliding window, and the minimal proportion r of accepted windows in a read. To find a robust choice for s and r, we ran the algorithm for several values of s and r on several rRNA databases and for several sets of reads. We purposely designed four databases with distinctive features: small 16S and large 23S subunit, varying identity percentage and from distinct phylogeny tree subparts,. Let s  16, the Burst trie below is constructed on the first six 17mers of an rRNA sequence. The 'char flag' describes whether a pointer is set to a trie node '1', a bucket '2' or neither '0'. Additional information on the origin of the 17mer directly follows each element, as shown in the dashed bucketThese databases were constructed by applying the ARB package () and UCLUST () to sequences from SILVA () (see Section 2.1 in the Supplementary File). Next, we constructed datasets of simulated rRNA and non-rRNA reads using the software MetaSim (). We used two sequencing error models, Roche 454 and Illumina, because the errors for Roche 454 mainly originate as indels and for Illumina as substitutions. The length of the reads differs as well: !200 nt for Roche 454 and 100 nt for Illumina technology. To test the sensitivity on Sets 1 and 3, we constructed 300 000 Roche 454 reads and 1 million Illumina reads on the entire SILVA database minus the sequences used for the representative rRNA database. To measure the sensitivity for discovering new species with Sets 2 and 4, the same number of reads was simulated only on the truncated sections of the bacteria phylogeny tree. To test the selectivity, the non-rRNA reads were simulated using the NCBI bacterial genomes library with rRNAs masked (see Section 2.2 in the Supplementary File). The parameter values were varied as: s 2 14, 20 and r 2 0, 1. The main conclusion is that s  18, r  0.15 for Roche 454 reads and s  18, r  0.25 for Illumina reads give best sensitivity/selectivity balance for all rRNA databases. Moreover, varying r within short ranges does not significantly affect the results (see Section 2.3 of the Supplementary File). We use these values as default settings in all subsequent analyses.
IMPLEMENTATIONSortMeRNA is implemented in C and freely distributed under the GNU general public license. It can be downloaded from http://bioinfo.lifl.fr/RNA/sortmerna. The software uses OpenMP functions to parallelize filtering of the reads. The input criteria are a fasta/fastq file of letter space reads produced by Roche 454 or Illumina technologies, and a fasta file of rRNA sequences. There are eight rRNA databases included in the software package covering the small (16S/18S), large (23S/28S) and 5/5.8S ribosomal subunit rRNAs, which were all derived from the SILVA and RFAM databases. Additionally, the user can work with his or her own RNA databases.
EXPERIMENTAL EVALUATIONThe performance of SortMeRNA was measured in terms of sensitivity, selectivity and real-data analysis compared with the software SSU-ALIGN (), Meta-RNA (), rRNASelector (), riboPicker () and BLASTN (). All tests were performed on an Intel(R) Xeon(R) CPU W3520 2.67 GHz machine with 8 GB of RAM, L1 cache size of 32 KB, L2 cache size of 256 KB and L3 cache size of 8192 KB. Because riboPicker and SSU-ALIGN do not provide a direct option for multithreading, all tests were carried out using one thread.
rRNA databasesWe created two new representative databases: 16S rRNA with 85% identity (7659 sequences) and 23S rRNA with 98% identity (2811 sequences) (see Section 3.2 of the Supplementary File). The 16S rRNA database was used by SortMeRNA, riboPicker, BLASTN and SSU-ALIGN, and the 23S rRNA database was used by SortMeRNA, riboPicker and BLASTN. SSU-ALIGN was written for aligning small ribosomal subunits and does not provide models for 23S rRNA. riboPicker was also tested with a more comprehensive database made available from their web site: all 16S and 23S rRNA sequences taken from SILVA, RDP-II, Greengenes, NCBI archaeal and bacterial genomes and HMP (3 232 371 16S and 1 960 223S unique sequences). The results for this larger database are indicated by riboPicker* in all subsequent tables. For Meta-RNA and rRNASelector, we used the HMMs provided with the software.
Simulated reads
Sensitivity for 16S rRNAIn all, 300 000 Roche 454 and 1 million Illumina 16S rRNA reads were simulated in the same manner as described in Section 2.5. The performance results can be viewed in. All software programs except riboPicker and SSU-ALIGN have a sensitivity level 497%, and 499% for BLASTN and SortMeRNA. The sensitivity for riboPicker is low (56%) because BWA-SW works well with error rates 23% for 100200 nt reads, and loses sensitivity for new species. As expected, the sensitivity increases with a larger database (indicated riboPicker*). Considering the computation time, SortMeRNA runs in 52 min, or 72 faster than the next fastest tool with proportionate sensitivity (Meta-RNA). Note also that BLASTN executes at a slow speed (several hours) because reads should be compared with all sequences in the representative database.The appended bit is set to '1' in the bitvector corresponding to the newly appended character; otherwise, it is set to 0. Column 4 of p 2 is equal to column 3 of p 2 , although the MSB is not considered. The same rule applies to column 5 of p 2 , where the two MSBs of the column 3 bitvectors are not considered same manner as described in Section 2.5. The performance results can be viewed in. All programs have a selectivity level 499.98%. The number of false positives for the HMM-based programs remains comparable with SortMeRNA for both Illumina and Roche 454 reads. The difference in the simulated data results between Meta-RNA and rRNASelector can be attributed to the number of bacteria versus archaea rRNA sequences used in the construction of the HMMs, as well as additional parameter settings in rRNASelector. riboPicker* and BLASTN show the lowest selectivity. Concerning the running time, the order of the fastest programs is rRNASelector, Meta-RNA and SortMeRNA. Both rRNASelector and Meta-RNA use the HMMER3 package, which applies a prefilter to quickly reject sequences that would score very low in the HMM. This acceleration heuristic gives these programs a competitive advantage on the artificial dataset for selectivity where all sequences are negative. Results for 23S rRNAs are analogous in terms of accuracy and running time. They can be found in
Selectivity for 16S rRNA One million Roche 454 and 1 million Illumina non-16S rRNA reads were simulated in the
Real dataThe metatranscriptomic datasets SRR106861 of a photosynthetic microbial community and SRR013513 of a tidal salt marsh creek from 454 sequencing were downloaded from the NCBI Sequence Read Archive. The results for 16S and 23S can be viewed in Tables 3 and 4, respectively, and the overlap of the results between tools in Figures 6 and 7. The results obtained with SortMeRNA are close to the ones obtained with HMM-based methods. riboPicker finds only a fraction of all potential rRNAs, which confirms its low sensitivity for small databases. The majority of 16S reads found only by riboPicker* (1298) map to mRNA. For 23S analysis inand, $99% of the excess reads of Meta-RNA (12 112) and rRNASelector likewise map to 28S, along with 83% of the (624) reads found only by BLASTN and Meta-RNA. The (537) reads found only by BLASTN map to mRNA, 16S rRNA and other non-coding RNA.
DISCUSSIONSortMeRNA has shown to be a rapid and efficient filter that can sort a large set of metatranscriptomic reads with high accuracy comparable with the HMM-based programs. SortMeRNA implements seeds with errors (substitution and indel), and this important characteristic renders the algorithm robust to errors of different types of sequencers while providing the ability to discover new rRNA sequences from unknown species. The method used by the algorithm is universal and flexible. The database can be constructed on any family of sequences provided by the user. Moreover, the algorithm does not require a multiple sequence alignment file to build the database, as HMM-based programs do, and this is an advantage when sequences are hard to align or only partial sequences are available. Another advantage of SortMeRNA is the small number ofparameter settings required by the program (see Section 2 of the Supplementary Data).
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
E.Kopylova et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
SortMeRNA at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
