Motivation: Classifying biological data into different groups is a central task of bioinformatics: for instance, to predict the function of a gene or protein, the disease state of a patient or the phenotype of an individual based on its genotype. Support Vector Machines are a wide spread approach for classifying biological data, due to their high accuracy, their ability to deal with structured data such as strings, and the ease to integrate various types of data. However, it is unclear how to correct for confounding factors such as population structure, age or gender or experimental conditions in Support Vector Machine classification. Results: In this article, we present a Support Vector Machine classifier that can correct the prediction for observed confounding factors. This is achieved by minimizing the statistical dependence between the classifier and the confounding factors. We prove that this formulation can be transformed into a standard Support Vector Machine with rescaled input data. In our experiments, our confounder correcting SVM (ccSVM) improves tumor diagnosis based on samples from different labs, tuberculosis diagnosis in patients of varying age, ethnicity and gender, and phenotype prediction in the presence of population structure and outperforms state-of-the-art methods in terms of prediction accuracy. Availability: A ccSVM-implementation in MATLAB is available from
INTRODUCTIONSeveral of the most intensively studied problems in computational biology are classification tasks: for instance, predicting the function of a gene, the disease state of a patient, the reaction of a patient to a therapy and the phenotype of an individual based on its genotype. The abstract task is to predict the class y of an biological subject based on its features x. Emerging and existing high-throughput technologies allow us to measure the features of genes, proteins and individuals at an unprecedented resolution and scale, and the hope is that this rich knowledge will lead to ever more accurate data classification. One of the most prominent and most successful classification algorithms are Support Vector Machines (SVMs) (). They are based on the idea to separate objects from two classes by means of a hyperplane; new test objects are then predicted to belong to one of these two classes depending on which half-space they are * To whom correspondence should be addressed. located in. Their popularity is due to several reasons: first, SVMs have shown excellent prediction accuracy in many studies (). Second, SVMs can be directly applied to structured data, such as strings () or graphs (), which are abundant in bioinformatics. Third, SVMs allow for straightforward data integration of several data types (). However, SVMs suffer from one limitation: it is unclear how to correct for confounding variables in SVM predictions. According to Meinert (), a confounder is defined as a variable which is related to two factors of interest, and which falsely obscures or accentuates the relationship between them. In this article, we present an SVM which can correct for observed confounding variables. The detrimental effects of confounders are observable in many classification tasks in molecular biology, as illustrated by the following two examples: one may want to predict the phenotypes of plants based on their genotype, typically represented by single nucleotide polymorphisms that represent sequence variation in an individual. In this task, population structure, that is systematic ancestry differences between plants with different phenotypes, may have a confounding effect on the prediction (). For instance, if there is a correlation between population structure and phenotype, the classifier may rely on SNPs that correlate with population structure, and subsequently, its predictions may be wrong on datasets from different geographic origins where the phenotypepopulation correlation is less pronounced or not present. Another example is drug treatment response in patients from gene expression profiles. Confounding factors may be the age, the gender or the ethnicity of the patients, each of which may correlate with the treatment response and the expression levels of certain genes (). When predicting on patients with different age, sex or ethnic background, the learnt classifier may poorly generalize. Our goal in this article is to define a confounder-correcting Support Vector Machine (ccSVM) that removes the confounding side information to the largest extent possible. To achieve this, we strive to make the classifier base its prediction on features that do not correlate with the confounding variable. The remainder of this article is structured as follows. In Section 2, we present the ccSVM (Section 2.3), and the classifier (Section 2.1) and the statistical dependence measure (Section 2.2) it is based upon. We prove that the ccSVM can be computed highly efficiently with existing software packages in Section 2.4. In Section 3, we show that our method improves upon several state-of-the-art classifiers in tumor diagnosis (Section 3.3), tuberculosis diagnosis (Section 3.4)Page: i343 i342i348
ccSVMand plant phenotype prediction (Section 3.5). In Section 4, we summarize our findings and give an outlook to future work.
ccSVM APPROACHWe first introduce the SVM (Section 2.1) and the Hilbert-Schmidt Independence Criterion (HSIC) (Section 2.2), that is the measure of statistical dependence that we use to then define our confoundercorrecting SVM (Section 2.3). In Section 2.4, we show how to efficiently solve the ccSVM optimization problem.
SVMsSVMs are supervised learning methods () that are widely used in molecular biology (). The SVM takes a set of input data with corresponding class labels, and predicts to which class a new input belongs. Suppose we are given the data, where x i is an observation and y i is its class label (+1 or 1). The original SVM assumes the data are separable by a hyperplane and obtains this hyperplane by maximizing the margin, that is the minimum distance between the hyperplane and points from each class. Once the hyperplane is learnt from the training data, it can be used to predict the class label of new test points. Suppose the hyperplane is in the form of f (x) = w T x+b, then the model is as follows: min wR n ,bRsubject to y i (w,x i +b)  1By considering the case when data are non-separable, a soft margin SVM was proposed to punish the training errors as follows ():where C determines the trade-off between margin maximization and training errors minimization, and  i is the term by which the object x i violates the inequality (2). Once w and b are obtained, one can predict the class label for a new observation x by the decision function: sgn(w T x+b). The dual problem of (3) isunder the constraints of m i=0 y i  i = 0,The KarushKuhnTucker conditions () imply that w =Thus, after we obtain  i by solving (5), the decision function will be sgnThe kernel trick is to replace x T i x j by k(x i ,x j ) = (x i ) T (x j ) in (5), where k(x,x ) is a kernel function such that its discretization K ij = k(x i ,x j ) is a positive definite matrix. The decision function can then be represented as sgn,x)+b .
HSICThe HSIC is a measure of statistical independence (). Intuitively, HSIC can be thought of as a squared correlation coefficient between two random variables x and z computed in feature spaces F and G. In more detail, let x be a random variable from the domain X and z a random variable from the domain Z. Let F and G be feature spaces on X and Z with associated kernels k : X X  R and l : Z Z  R. If we draw pairs of samples (x,z) and (x ,z ) from x and z according to a joint probability distribution p (x,z) , then the HSIC can be computed in terms of kernel functions via:where E is the expectation operator. The empirical estimator of HSIC for a finite sample of points X and Z from x and z with p (x,z) was shown into be HSIC((X,Z),F,G)  tr(KHLH),where tr is the trace of the products of the matrices, H is a centering matrixare the kernel matrices on the two random variables of size mm and m is the number of observations. The larger HSIC, the more likely it is that X and Z are not independent from each other.
The ccSVMVia HSIC we can now define an SVM that can use side information to avoid confounding. Suppose m samples with their feature vectors (x 1 ,...,x m ), class labels (y 1 ,...,y m ) and side information (z 1 ,...,z m ) are given. x i is a n-dimensional column vector representing the features of sample i, y i {1,+1} is the class label for x i and z i is the some kind of side information on object i, e.g. region, country, age, gender, lab membership or population structure. L  R mm is a predefined kernel matrix which is generated based on a kernel l on the side information, that is L ij = l(z i ,z j ). We call L the side information kernel matrix. We propose to obtain a classifier by minimizing the following objective function: minwhere represents the element-wise product of two vectors. The objective function includes two terms. To minimize the first term is to maximize the classifier margin, as in a standard SVM. The second term tr(KHLH) is the HSIC, which measures the independence between two kernels, the reweighted kernel matrix K and side information kernel matrix L. Here the reweighted kernel K is the kernel after reweighting each feature by its weight in w. To minimize HSIC is to make the dependence between the reweighted kernel matrix and the side information kernel matrix as small as possible. In other words, besides maximizing the margin, the ccSVM also tries to weaken the effect of the side information on the weight vector w of the classifier. It rewards solutions in which the input dataafter being reweighted by weight vector ware as independent as possible from the side information, thereby favoring a solution that does not rely on the side information. A constant >0 determines the trade-off between margin maximization and dependence minimization. Note that in practice, a separating hyperplane may not exist. A possible soft margin classifier can be obtained by minimizing the following objective function:Two constants C and  determine the trade-off among margin maximization, dependence minimization and training error minimization.
Transformation into SVM problem with rescaled inputNext, we show how to solve the ccSVM optimization problem (12) by rescaling the input of a standard SVM. For this purpose, we denote HLH byLby byL, and we defineThen HSIC in (12) can be written asThus, the objective function in (12) becomesfor k = 1,...,n. DenotewDenoteThen the optimization problem (12) becomes:Interestingly, the optimization problem (17) with the constraints in (18) is the standard SVM, which can be solved using libsvm () or other SVM software. Thus, in order to solve the ccSVM problem (12), one only needs to first rescale each feature according to the formula (16) and then solve a standard SVM problem (17). Note that Equation (17) uses a linear kernelXkernel kernelX T  X, whereXwhere whereX = ( x 1 ,.
..,
EXPERIMENTSIn our experiments, we examine three different applications of the ccSVM in bioinformatics: microarray cross-platform comparability on a simulated dataset, disease outcome prediction with correction for various kinds of side information and phenotype prediction with population structure correction.
Parameter selectionThere are two parameters in the ccSVM model (12):  and C. We choose the parameters based on cross-validation on the training dataset only. We split all the training data into several (for example, 5) folds, and each time we take 1-fold as test set and the others as training set. We first set  = 0 and select the C by which we can get the best average area under curve (AUC) using a standard SVM. C can take one of the values inThen we fix C in the ccSVM, and select the  such that it gives the best average AUC in the ccSVM.  is chosen from the values {10 8 ,10 4 ,10 2 ,1,10 2 ,10 4 ,10 8 }. This parameter selection is performed on the training dataset only.
Comparison partnersWe compare the ccSVM to the following comparison partners:@BULLET Standard SVM: we use linear kernel K SVM = X T X in the standard SVM,@BULLET (K+L)SVM: we integrate the side information with the original features by simply concatenating X and L. Thus, the number of features are n+m, where n is the number of original features,@BULLET Confounder correcting logistic regression (ccLR): we consider the following logistic modelwhere p is the probability of a sample being in one class (e.g. the positive class),  i and u i are parameters, x i are the original features and l i are the side features included in L.applied a related mixed-model approach to correct for population structure in genome-wide association studies. In contrast to our approach, they are interested in quantitative phenotypes. In our experiments, besides standard logistic regression with maximum likelihood, a sparse Bayesian logistic regression model BLogReg () is also used to estimate the parameters  i and u i. ccLR with these two parameter estimation methods are denoted as ccLR(ML) and ccLR(BR), respectively.
Microarray cross-platform comparabilityIn this experiment, we compared the sensitivity of the ccSVM to a standard SVM on a microarray dataset which consists of samples from two different labs. A synthetic dataset was also generated to compare the ccSVM and standard SVM. Data: P.compared two studies on acute myeloid leukemia (AML):. The dataset Bullinger consists of 52 patients, and the dataset Valk of 97 patients. Both datasets share gene expression levels for n = 7102 genes. The prediction task is to differentiate between cancerous and normal tissue. The experiments ofwere carried out on a cDNA platform while Valk et al. used oligonucleotide microarrays. Besides the real data, we also generated a synthetic dataset based on Bullinger and Valk: we picked randomly half of the genes and centered them to zero mean for each gene and each dataset separately, and kept the other half genes uncentered. The centered genes have no correlation with the lab membership while many of the uncentered genes have a strong correlation. Hence, difference in mean expression level seems to distinguish the expression values from these two labs. We defined the side information matrix L  R mm by the lab membership. L ij = 1 if patient i and patient j belong to the same lab, and L ij = 0 if the two patients belong to different labs. Experimental setting: we first did 50 times 5-fold random crossvalidation on the real data using the ccSVM and SVM, and report their average AUCs, standard errors and t-test P-values. For the ccSVM, we split the data randomly into 5-folds. We used 4-foldsfor training and 1-fold for testing. Then we fixed the parameters  and C as explained in Section 3.1 with 4-fold cross-validation. With the obtained parameters, we trained the ccSVM on the training set and predicted on the test objects. The experiment was repeated five times until each fold served as test dataset once. For standard SVM and pcaSVM, we used the same experimental protocol, but we only needed to train C from the training data. We then explored how the ccSVM corrects the normalized weight vector based on the synthetic data. We trained on a subset of the pooled Bullinger and Valk dataset. We determined the parameter C according to the experimental protocol outlined in Section 3.1 and fixed  = 1. Therefore, we split the training set into 3-folds. With these optimized parameters, we trained our ccSVM jointly over all training objects and predicted on the test dataset. For training the standard SVM, we used the same experimental protocol. Results: for the real data, we obtain an average AUC value of 0.911  0.002 for the ccSVM and an AUC value of 0.822  0.003 for the standard SVM. The P-value of the t-test is 4.8e-40. This result shows that our method is superior to the standard SVM. For the synthetic data, we can see fromthat the ccSVM assigns large weights to genes that weakly correlate with the lab membership while the standard SVM assigns the weights without paying attention to the correlation to the lab membership.
Disease outcome prediction with various confounding factorsIn this experiment, we analyzed the ability of the ccSVM to predict active tuberculosis based on blood transcriptional profiles. We used ethnicity, age and gender as confounding information. Data: we obtained the dataset from. It includes 103 blood samples from patients with active tuberculosis and 40 blood samples from healthy controls. The transcriptional signature of the blood samples were measured in a subsequent microarray experiment with n = 48 803 gene expression levels. We used three different confounding factors: ethnicity, gender and age. For ethnicity, we defined the information matrix as i345follows: L ij = 1 if the patient i and j belong to the same ethnic group, L ij = 0 if they do not. For gender, we defined L similarly: L ij = 1 if the patient i and j have the same gender, L ij = 0 if the patients have different gender. We used a Gaussian kernel for age as side information. Experimental setting: for the ccSVM, standard SVM, pcaSVM and (K+L)SVM, we used the same experimental setting as described in Section 3.3. We again utilized the same experimental design for ccLR, but instead of setting the parameters (,C), we determined the parameters  0 ,..., n and u 1 ,...,u m. We ran 50 times random 5-fold cross-validation for standard SVM, pcaSVM,(K+L)SVM and ccSVM, and reported their corresponding average AUCs and standard errors. We also performed a t-test between the 50 AUCs of competing partners and 50 AUCs of ccSVM, and recorded the P-values. As ccLR and BLogReg did not work well, we performed logistic regression with maximum likelihood estimation in 10 times 5-fold cross-validation and reported the averaged AUC. Results:shows the prediction results for random cross-validation. Regarding the AUC values, ccSVMs with side information of ethnicity and age are slightly better than the other SVM approaches, while ccSVM with gender as side information works similar with the other SVMs. The logistic regression approach is not able to classify the data correctly regardless of which side information is used. Weight vector analysis: we examined the weight vector of the ccSVM to get a further understanding for its improved performance. Specifically, we trained on four ethnic groups and then used it to predict on a fifth. In, we plot the averaged absolute correlation coefficients between membership in one ethnicity (African) and the expression levels of the 10 000 top ranked genes. We can observe that the ccSVM assigns the largest weights to genes that do not correlate with the confounder, while the standard SVM is unaware of the confounder and puts large weight on the features that correlate with the confounding variable.
L.Li et al.
Phenotype prediction with population structure correctionIn this experiment, we assessed the performance of the ccSVM in comparison to the standard SVM, (K+L)SVM, pcaSVM and ccLR on phenotype prediction from SNP data in Arabidopsis thaliana. Data : we used data from the genome-wide association study in A.thaliana conducted by. The dataset consists of m = 177 samples and n = 216 130 single nucleotide polymorphisms (SNPs). An SNP is a fixed position in the genome which exists in two different variations between individuals. We examined five binary phenotypes, namely the presence and absence of chlorosis at 22 @BULLET C (PID:169), of anthocyanin at 16 @BULLET C (PID:171)and at 22 @BULLET C (PID:172) and of leaf roll at 10 @BULLET C (PID:176) and at 22 @BULLET C (PID:178). We used population structure as side information and computed a side information kernel matrix L  R mm. Population structure is defined by the different allele frequencies between subpopulations. If the phenotype prevalence also differs between these subpopulations, it can lead to spurious associations between the phenotype and SNPs that are associated with a subpopulation in which one phenotype is prevalent (). Each entry L ij is here defined as the number of common SNPs between sample i and sample j. Experimental setting: for this experiment, we used the same experimental setting as described in Subsection 3.4. Results: prediction results are reported in. For all the phenotypes except leaf roll at 22 @BULLET C (PID:178), ccSVM yields better AUC values than the state-of-the-art competitors. Regarding the P-values, we see that the improvement of our method against standard SVM, pcaSVM and (K+L)SVM is significant for the phenotypes chlorosis at 22 @BULLET C (PID:169), anthocyanin at 16 @BULLET C (PID:171), anthocyanin at 22 @BULLET C (PID:172) and leaf roll at 10 @BULLET C (PID:176). Weight vector analysis: in, we compare the normalized weight vectors obtained by ccSVM and standard SVM for two phenotypes by looking at one representative each. We first pick up the top 100 features selected by standard SVM, and then see how the ccSVM corrects the weights of these features. When the ccSVM curve is lower than the standard SVM curve (negative peak),Chlorosis at 22C standard SVM ccSVMit means that the corresponding SNPs are likely to be correlated with the confounder and ccSVM weights them down for classification. The SNPs whose weights are scaled up (positive peaks) are less correlated with the confounding side information. We can see from the figure that both parameter  and the number of negative peaks increases from the top to the bottom. This implies the confounding information increases from top to bottom. For the phenotype anthocyanin at 16 @BULLET C (PID:171), the top figure shows that there are almost no large negative peaks in the ccSVM curve. This implies there are few spurious associations for the ccSVM to correct. For the phenotype chlorosis at 22 @BULLET C (PID:169), we can see that ccSVM scales all SNPs down which the standard SVM assigns large weights to. It is likely that they are all correlated with the confounding variable. Functional investigation: we did further analysis for the phenotype chlorosis at 22 @BULLET C (PID:169). In order to do this, we used the complete dataset as training set and determined  and C via cross-validation as described in Section 3.1. First, we selected the top 500 SNPs from the weight vector of ccSVM; these are the SNPs that correspond to the 500 largest absolute entries in the weight vector. After normalizing these entries in both weight vectors, we selected all SNPs which were upscaled. Summary of ccSVM results for the presence or absence of chlorosis at 22 @BULLET C (PID:169)
i346
ccSVM
L.Li et al.The results are shown in. pen-3-1 mutants show a chlorosis response after being attacked by Erysiphe cichoracearum. It is assumed that the gene PEN3 contributes to defense at the cell wall and intracellularly (). The mos6 mutants suppress snc1 resistance and hence exhibit enhanced disease susceptibility to virulent pathogens (). The gene CDR1 is known to be involved in disease resistance signaling (), and ahg2-1 mutants have an elevated resistance to bacterial pathogens (). In total, 9 of the 217 upscaled SNPs are close to candidate genes. Out of 216 130 genome-wide SNPs, 3959 are in close proximity to candidate genes. Hence, SNPs near candidate genes are significantly enriched among the SNPs upscaled by the ccSVM (P = 0.020,  = 0.05, Binomial n = 217,p = 3959 216130 ).
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from [20:21 6/6/2011 Bioinformatics-btr204.tex] Page: i344 i342i348
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from [20:21 6/6/2011 Bioinformatics-btr204.tex] Page: i346 i342i348
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Page: i347 i342i348
DISCUSSION In this article, we have defined the ccSVM, an SVM with correction for confounding side information. In our experiments, it outperforms several state-of-the-art classifiers with confounder correcting schemes for disease diagnosis in humans and for phenotype prediction in A.thaliana. Our work extends the advantages of SVMs in data integration: while there is lot of work on SVMs for optimally combining several informative sources of data for a joint prediction (Lanckriet et al., 2004), there was no approach for correcting SVMs for observed confounding factors so far. The ccSVM closes this gap. This is of particular importance for bioinformatics, as side information on confounders is abundant in most classification tasks on biological data. It remains to be discovered if SVMs can be corrected for hidden, unobserved confounders as well, as these tend to frequently occur in gene expression phenotypes. Correcting for these hidden confounders may be one way to further improve the accuracy of our predictions. On the biological level, our work will focus on applications of the ccSVM to binary phenotype prediction in plant genetics and in personalized medicine. The latter includes improved disease diagnosis, prognosis and therapy outcome prediction for human patients. One challenge we will tackle here is how to optimally account for several confounding factors, that is learning their weights relative to each other to further improve phenotype prediction.
i348 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
