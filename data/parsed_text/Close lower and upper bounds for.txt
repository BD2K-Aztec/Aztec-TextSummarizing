Motivation: Reticulate network is a model for displaying and quantifying the effects of complex reticulate processes on the evolutionary history of species undergoing reticulate evolution. A central computational problem on reticulate networks is: given a set of phylogenetic trees (each for some region of the genomes), reconstruct the most parsimonious reticulate network (called the minimum reticulate network) that combines the topological information contained in the given trees. This problem is well-known to be NP-hard. Thus, existing approaches for this problem either work with only two input trees or make simplifying topological assumptions. Results: We present novel results on the minimum reticulate network problem. Unlike existing approaches, we address the fully general problem: there is no restriction on the number of trees that are input, and there is no restriction on the form of the allowed reticulate network. We present lower and upper bounds on the minimum number of reticulation events in the minimum reticulate network (and infer an approximately parsimonious reticulate network). A program called PIRN implements these methods, which also outputs a graphical representation of the inferred network. Empirical results on simulated and biological data show that our methods are practical for a wide range of data. More importantly, the lower and upper bounds match for many datasets (especially when the number of trees is small or reticulation level is low), and this allows us to solve the minimum reticulate network problem exactly for these datasets.
INTRODUCTIONReticulate evolution, a form of evolution with hybridization and genetic exchanges between two species, are common in many organisms: bacteria, plants, fish, amphibians and many others. For better understanding of reticulate evolution, several reticulate evolutionary models have been proposed and actively studied to address various reticulate processes, such as hybrid speciation, lateral gene transfer and recombination. Since most of these models are in the forms of networks, we call them reticulate networks 1. We refer the readers to () for surveys of different reticulate network models. The key computational problem related to these models is the inference of reticulate networks. Depending on the types of biological processes involved, data for network inference may be in different forms, such as phylogenetic trees for some short genomic regions (called genes in this article) or aligned DNA sequences. In this article, we focus on inferring reticulate networks from a set of correlated phylogenetic trees. Here is the biological motivation for our problem. Suppose multiple phylogenetic trees (called gene trees in this article) are reconstructed, each from some gene for these species. Due to reticulate evolution, different genomic regions (say genes) may be inherited from different ancestral genomes and their evolutionary histories may not be the same (but are still related). Thus, these trees are correlated but not identical. No single phylogenetic tree can faithfully model the evolution of the species, and a more complex network model (i.e. reticulate network as studied in e.g.) is needed. Imagine we are given a set of 'true' gene trees and a 'true' reticulate network that models the evolutionary history of these genes. The network can be considered as a compact representation of these gene trees in the sense that one should be able to 'trace' a gene tree within the network. We say such a gene tree is displayed in the network. This motivates a natural problem, which is called 'the holy grail of reticulate evolution' in (): given a set of gene trees, reconstruct a reticulate network that displays every given gene tree. Such an inferred network reveals important correlation of evolutionary history of multiple genes. Since there exists many such networks, a common formulation is to find the one with the fewest reticulation events. Such a network is called the minimum reticulate network. The central computational problem on reticulate networks, the minimum reticulate network problem, is: given a set of gene trees, reconstruct the minimum reticulate network that displays these gene trees. This formulation may be reasonable when reticulation is believed to be rare. In general, this problem is computationally challenging: even the case with only two gene trees is known to be NP-complete (). There are several existing approaches for reconstructing the exact minimum reticulate networks when there are only two gene trees (). Clearly restricting to just two gene trees is a big limitation: more gene trees will be more informative to phylogenetic inference, and DNA sequences of many genes are available. Alternatively, there are also a number of approaches making simplifications to the reticulate network model, e.g. by imposing additional topological constraints on reticulatePage: i141 i140i148
Close lower and upper bounds for the minimum reticulate networknetworks () or working with small-scale tree topological features (). Such simplification often leads to significantly faster approaches. However, it is sometimes unclear how biologically meaningful these added topological constraints are. Even in the case where additional simplifications are reasonable, one may still want to compare with the unconstrained minimum reticulate networks. Contributions: In this article, we present new approaches for the minimum reticulate network problem with three or more gene trees for unconstrained, general, reticulate networks (e.g. without needing to assume that the network has some restricted form, such as being a galled-tree or galled network). Thus our work is more general than some previous approaches (). In particular, we develop a lower bound (the RH bound) and an upper bound (the SIT bound) for the minimum reticulate network problem with multiple gene trees. We show the correctness of the bounds. We give a closed-form formula for the RH bound for the case of three gene trees. We also show how to compute these bounds efficiently in practice using integer linear programming (ILP). Practical results on simulated and real biological data show that the bounds can be computed for wide range of data. Moreover, the lower and upper bounds are often close, especially when the number of trees is small or reticulation level is relatively low. In fact, for many simulated datasets of this type, the lower and upper bounds often match, which means our methods can reconstruct the exact minimum reticulate networks for these datasets. We also show the RH bound clearly outperforms a simple bound.
DEFINITIONS AND BACKGROUNDThroughout this article, we assume trees are rooted. A phylogenetic tree is rooted and leaf-labeled by a set of species (called taxa). A leaf of a phylogenetic tree corresponds to an extant species. An internal vertex corresponds to a speciation event. In-degrees of all vertices (also called nodes), except the root, in a tree are one, while out-degrees are zero for leaves and at least two for internal nodes. A binary phylogenetic tree requires out-degrees of internal nodes to be two. A non-binary phylogenetic tree contains nodes with out-degree of three or more. Many existing phylogenetic methods assume binary phylogenetic trees, although sometimes only non-binary trees can be reconstructed in practice. Our definition of reticulate networks is similar to that in () (). A reticulate network (sometimes simply network) is a directed acyclic graph with vertex set V and edge set E, where some nodes in V are labeled by taxa. V can be partitioned into V T (called tree nodes) and V R (called reticulation nodes). E can be partitioned into E T (called tree edges) and E R (called reticulation edges). Moreover,(1) No nodes with total (in and out) degree of two is allowed. Except the root, each node must have at least one incoming edge.(2) V R contains nodes whose in-degrees are two or more. V T contains nodes whose in-degrees are one.. An illustration of a reticulate network with three reticulation events for three trees. Each tree is displayed in the network: the tree can be obtained by keeping one incoming edge at each reticulation node.(3) E R contains edges that go into some reticulation nodes. E T contains edges that go into some tree nodes.(4) A node is labeled by some taxon iff its out-degree is zero. This helps to ensure labeled nodes correspond to extant species and remove some redundancy in the network.In addition, we have one more restriction: R 1 For a reticulate network N , when only one of the incoming edges of each reticulation node is kept and the rest are deleted, we always derive a tree T. We first consider the derived tree T (that is embedded in N ) as in restriction R 1. When we recursively remove non-labeled leaves and contract edges to remove degree-two nodes of T (called cleanup), we obtain a phylogenetic tree T (for the same set of species as in N ). Now suppose we are given a phylogenetic tree T. We say T is displayed in N when we can obtain an induced tree T from N by properly choosing a single edge to keep at each reticulation node so that T is topologically equivalent to T after cleanup. We denote the induced T (if exists) as T N. Seefor an illustration. Note restriction R 1 implies the network is acyclic. Biologically, reticulate networks often forbid cycles. This is because many reticulation events need to be properly time-ordered. Thus, we focus on acyclic reticulate networks in this paper. That is, when we refer to a reticulate network, we mean an acyclic reticulate network (unless otherwise stated). There are subtle issues related to networks with nodes whose out-degrees are more than two (called non-binary nodes). See the Supplementary Materials for more discussion. Note that we do not require that in-degrees of reticulation nodes are precisely two as what was imposed in (). We also assume the root of each input tree T i is attached to an outgroup species o. The root of a reticulate network for these trees is also attached to o. We define the reticulation number of a reticulation node as its in-degree minus one. For a reticulate network N , we define the reticulation number (denoted as R N ) as the summation of the reticulation number of each reticulation node in the network. Sometimes R N is also called the number of reticulation events in N. For the reticulate network in, the reticulation node 2 has three entering edges, and the other reticulation node 1 has two entering edges. Thus, R N = (31)+(21) = 3. Our definition of reticulation number is similar to that of the hybridization number in (). Suppose we are given a set of K gene trees T 1 ,T 2 ,...,T K (for the same set of species). The minimum reticulate network N min for T 1 ,T 2 ,...,T K is a reticulate network N that displays each T i and R N is minimized among all possible N. We call R N min the reticulation number of T 1 ,...,T K , which is denoted as R(T 1 ,T 2 ,...,T K ).
i141
Y.WuFor the special case of K = 2, we call D T i ,T j = R(T i ,T j ) the reticulation distance between two trees T i and T j. Now we formulate the central problem in this article. The general minimum reticulate network (GMRN) problem: Given a set of phylogenetic trees T ={T 1 ,...,T K }, reconstruct the minimum reticulate network N min for T 1 ,T 2 ,...,T K. This formulation is based on parsimony, and may be justified when reticulation is relatively rare in the evolutionary history. One should note that the GMRN problem can be further specified by the type of input trees. There are two types of input phylogenetic trees: binary or non-binary. For a non-binary tree T , we say T is displayed in N if some refinement of T (i.e. splitting the non-binary nodes in T in some way to make T binary) is displayed in N. When input trees are binary, network reconstruction may be easier. For simplicity, in this following, the input trees are assumed to be binary, unless otherwise stated. We remark that some of our results are applicable to non-binary input trees: the RH bound in Section 3 clearly works for non-binary trees too, and the high-level approach of the SIT bound may also be applicable to non-binary trees. Previous work on the GMRN problem: There is an exact method for the K = 2 case of the minimum reticulate network problem (), although this special case is known to be NP-complete (). It is useful to note that when we allow cycles in the network, the minimum reticulate network problem is equivalent to the rooted subtree prune and regraft (rSPR) distance problem. The rSPR distance problem, another NP-complete problem (), is well known to be closely related to reticulate evolution. Previously, we showed that the rSPR distance can often be practically computed for many moderately sized trees (). We give more background to the rSPR distance problem in the Supplementary Material. It was shown in () that the reticulation number (called hybridization number in ()) for trees T 1 and T 2 is closely related to the rSPR distance between T 1 and T 2 , although the two values are not always equal. The main difference between the rSPR distance and the reticulation number is that the latter forbids cycles and thus can be more realistic biologically. Recently, we have extended our previous approach in () to allow computing the pairwise reticulation distance between two rooted binary trees (). Although the worst case running time of the practical methods in () are exponential, these methods may work reasonably well in practice. As shown in (), exact reticulation number (with or without cycles) can be computed for two quite different trees with 20 or more leaves. Thus, although intractable theoretically, the two-tree minimum reticulate network problem can be solved in practice if the size of two trees is moderate or the two trees are not very different topologically. It becomes more computationally challenging when there are three or more gene trees. There is currently no known practical methods for either computing the reticulation number R(T 1 ,...,T K ) or reconstructing N min for trees T 1 ,...,T K when K  3. Often approximation is made. A common approach is to impose structural constraints to limit the complexity of the network (). Although these approaches are theoretically interesting and have been shown to work for some biological data, it is still very desirable to explore the reconstruction of reticulated networks displaying multiple complete gene trees without additional structural constraints.
A LOWER BOUNDWe now focus on developing a lower bound on R(T 1 ,...,T K ). The lower bound helps to better quantify the range of R(T 1 ,...,T K ). Recall that several exact methods (; Wu and) exist for computing the pairwise reticulation distance D T i ,T j for two trees T i ,T j , which are practical for many pairs of trees of moderate sizes. Now suppose that we compute D T i ,T j for each pair of trees T i and T j , using the methods (). We store these pairwise distances in a matrixAdmittingly, computing Dfor all T i and T j can be slow when K and/or the size of trees are large (unless T i and T j are very similar). One should note that the GMRN problem is much more complex, and thus, calculation of Dis justifiable computationally. This leads to the following question: can we use the pairwise reticulation distances D to estimate R(T 1 ,...,T K ) when K  3? Clearly, the largest value D[i 0 ,j 0 ] in D is necessarily a lower bound of R(T 1 ,...,T K ) when K  3: a reticulate network displaying all trees certainly also displays trees T i 0 and T j 0 and thus is a reticulate network for T i 0 and T j 0. We now show a stronger lower bound (called RH bound) based on D values. Here is the high-level idea. The pairwise distance D T i ,T j specifies how similar trees T i and T j are: the larger D T i ,T j is, the more different T i and T j are. Recall that if tree T i is displayed in a network N , we should be able to derive T i by keeping only one incoming edge at each reticulation node and performing cleanup. The choice (called display choice for T i ) of keeping which incoming edge at each reticulation node for a tree T i may not be unique. However, clearly if one makes the same display choices for T i and T j when displaying T i and T j in N , then T i and T j will be identical. More generally, the more similar the display choices for trees T i and T j , the closer T i and T j will be. Thus, to allow an N for trees with pairwise distances D=D T i ,T j , we need to make display choices for the trees different enough: if the display choices for T i and T j are too similar, it will lead to contradiction when Dsuggests T i and T j are more different. In the following, a rigorous analysis based on this idea allows us to decide whether an N with a specific number (say r) of reticulation events is feasible. To fix ideas, we first consider the situation where each reticulation node in N has in-degree of two. We will remove this assumption in a moment. Suppose that N has r reticulation nodes (each with two incoming edges). For each reticulation node, we arbitrarily call one incoming edge the left edge and the right edge for the other. We encode the left edge as 0 and the right edge as 1, and call these two edges 0-edge and 1-edge. Recall that to display a tree, we need to keep exactly one of these two edges. Since a tree T i is displayed in N , we create a binary vector v ito represent which incoming edge T i is kept at each reticulation node V j in N. Here, v iis 0Page: i143 i140i148
Close lower and upper bounds for the minimum reticulate networkif T i keeps the 0-edge at reticulation node V j , and 1 if T i keeps the 1-edge at V j. We call v i the display vector for T i. For example, in, consider the reticulation node labeled as 1, and we assign the left/right edges as shown. T 1 and T 3 keep the left edge at this node, while T 2 keeps the right edge. Thus, v 1 and v 3 have value 0, and v 2 has value 1 at the node. For a given T i and a network N , v i can always be constructed (at least conceptually) based on how T i is displayed in N. Note that if there are multiple choices to display T i , we simply pick an arbitrary one and this does not affect our solution. We define D h [v i ,v j ] as the Hamming distance between two display vectors v i and v j. Here, v i and v j (and thus D h) depend on N. To simplify notations, we do not explicitly include N in their definitions. Lemma 3.1 is crucial to our lower bound.. Thus T i and T j make different choices at less than Dreticulation nodes of N. Imagine we remove from N those incoming edges at reticulation nodes that are not kept by both T i and T j. This produces a network with less than Dreticulation nodes. This is because all reticulation nodes where v i and v j match (and thus T i and T j keep the same incoming edges) have only one incoming edge and are no longer reticulation nodes in the reduced network. This contradicts the fact that Dis the reticulation distance between T i and T j. Lemma 3.1 implies that if a network N with r reticulation events exists, then we should be able to find binary vectors v i (of length r) for each tree T i , and D h [v i ,v j ]Dfor any two such vectors v i and v j. On the other hand, if such vectors do not exist, we know that at least r +1 reticulation events are needed (and the value r +1 is a lower bound on R(T 1 ,...,T K )). We can illustrate this formulation more intuitively using a binary hypercube. On a hypercube with r binary bits per node, we want to know whether we can pick K points v 1 ...v K that are far apart enough such that the Hamming distance between v i and v j is at least Dfor each i and j. One should note this is not always feasible due to the limited size of the hypercube. Formally,The binary hypercube point placement problem: Can we choose K nodes v 1 ,...,v K from a r-dimensional binary hypercube so thatA lower bound on R(T 1 ,...,T K ) based on the Hypercube Point Placement problem is to find (possibly in a binary search style) the smallest integer r such that the hypercube point placement problem has a solution. Such r is necessarily a lower bound on R(T 1 ,...,T K ). We call this lower bound reticulation on hypercube bound (or RH bound). We do not know a polynomial-time algorithm for the binary hypercube point placement problem with more than three trees. When K = 3, however, the RH bound has a simple analytical form (see Section 3.2). To develop a practical method for the general case, we use integer linear programming (ILP) to solve this problem. We create a binary variable V i,k to represent the coordinates for point v i. That is, the coordinates of v i on the hypercube are specified by V i,1 ...V i,r. Without loss of generality, we set V 1,k = 0 for all 1  k  r. We create a binary variable M i,j,k for each v i , v j and position k (1  k  r) to indicate whether two vectors v i and v j match at position k. M i,j,k = 1 if V i,k = V j,k , and 0 otherwise. Now, we have the following formulation. Optimization goal: none (since this is a feasibility problem)For each 1  i  K and 1  k  r, there is a binary variable V i,k .For each 1  i < j  K, and 1  k  r, there is a binary variableConstraint 1 says if both V i,k and V j,k are 0, M i,j,k is 1 (i.e. matched). Similarly, constraint 2 says if both V i,k and V j,k are 1, M i,j,k is 1 (i.e. matched). Constraint 3 imposes the pairwise Hamming distance requirement. Our experience shows that the ILP is practical to solve for all datasets we simulated (see Section 5).
Networks with in-degree of three or moreWe now resolve the remaining issue where some reticulation nodes have in-degree of three or more. In this section, we call a reticulation node 'refined' if its in-degree is two, and 'unrefined' if its in-degree is at least three. Here, we can no longer represent a reticulation node as binary value, as done previously. So we extend our definitions of display vectors v i to allow v i to be non-binary. That is, if there are d incoming edges at a reticulation node, we allow v i to be from 0 to d 1, where the value indicates which one of the d branches T i is kept at this node. The incoming edges are numbered starting from zero on the left and to the right with increment of one. We still let D hbe the Hamming distance between vectors v i and v j. In this general case, Lemma 3.1 still holds for non-binary vectors v i and v j. To see this, we prune any incoming edge at reticulation nodes if it is not chosen by T i and T j. Then each remaining reticulation node has only two incoming edges (since we only have two trees). Thus, there arereticulation events in this reduced network, and the rest of proof for Lemma 3.1 follows. We now show that it is not necessary to consider unrefined reticulation nodes in the sense that if a network N with unrefined reticulation nodes satisfies pairwise distances D, then there exists another network N that has only refined reticulation nodes and gives the binary vectors v i satisfying the pairwise distance constraints of D. That is, if we can not find a network with only refined reticulation nodes, we also can not find a network with unrefined reticulation nodes and the same reticulation number. To see this property, we consider a network N with one reticulation node q with d  3 incoming edges. Then we transform N to N by replacing q with q 1 ,...,q d1 , where each q i is a reticulation node with in-degree of two. Note that we do not have to ensure N and N are equivalent: we only need to show N gives a solution to the Binary Hypercube Point Placement problem. Clearly, N and N have the same reticulation number (although vectors for N are i143
Y.Wulonger). Now, suppose tree T i keeps edge j at q (where 0  j  d 1), we then keep edge 1 at q j in N if j  1 (and 0 if j = 0), and keep edge 0 for all other q j (where j = j). In other words, we create a mapping of the display vectors v i from N to N for each T i. Note that such mapping ensures that if two trees keep the same edge at q, they will keep the same edges at q 1 ,...,q d1 in N ; otherwise, they will keep at least one different incoming edge at q 1 ,...,q d1 in N. In either case, if the pairwise distance constraints are satisfied in N , they are also satisfied in N. So, if we can not find display vectors N for networks with refined reticulation nodes only, we also can not find display vectors for networks allowing unrefined reticulation nodes. In other words, the RH bound holds for networks with unrefined nodes. Remark. The RH lower bound is still applicable when the input trees are non-binary, as long as the pairwise reticulation distances are obtained for the non-binary trees. These are easy to verify and we omit the details due to the lack of space. Remark. A commonly used concept in reticulate networks is the so-called maximum agreement forest (MAF). A brief description on MAF is given in the Supplementary Material. Also see e.g. in () for more details. It is easy to see that the size of a MAF of multiple trees is a lower bound on R(T 1 ,...,T K ). However, experience show that the RH bound is often higher than the MAF bound (see Section 5).
Special case of three treesTheProof. We first consider the case d 2 +d 3 > d 1. Clearly, the RH bound is at least d 1 , which is the minimum size of the hypercube. Now we investigate whether there exists a reticulate network with d 1 +e reticulation nodes for these three trees. Without loss of generality, let T 1 be the input tree wherethe display vector v 1 (for T 1 ) is fixed to be all-0. Then, the display vector v 2 for T 2 must have at least d 1 positions with value 1 (and thus v 2 has no more than e positions with value 0). Similarly, the display vector v 3 must have at least d 2 positions with value 1 (and thus v 3 has no more than d 1 +ed 2 positions with value 0). Note that D h
AN UPPER BOUNDWe now present an upper bound on R(T 1 ,...,T K ). The combination of the RH lower bound and the upper bound quantifies the range of R(T 1 ,...,T K ). In the best scenario, if the upper bound matches the RH bound, these bounds would actually determine the exact value of R(T 1 ,...,T K ) (and also reconstruct N min ). On the high level, the upper bound performs stepwise insertion of trees into a reticulate network (and thus is called the SIT bound). The SIT bound is very accurate and also computable in practice for many datasets. The basic idea of the SIT bound is to reconstruct a reticulate network N in a step-by-step way: 'insert' the given gene trees one by one into N in some fixed order. When we say a tree T is inserted into N , we mean adding reticulation edges into N such that T is displayed in the updated network N. Note that addition of new reticulation edges increases R N. Thus, every time we insert a new tree, we seek to add as few new reticulation edges as possible by reusing existing reticulation edges. At the same time, we also ensure no cycles exists in N. Often, it is unclear which order of inserting trees gives the best result. For now, we assume that K is relatively small so that we can enumerate all possible orders of insertion to find the best result. See Section 4.2 for ways to handle larger K. Thus, we can assume the order of tree insertion is fixed to T 1 ,T 2 ,...,T K. The general procedure of the SIT bound (for a fixed order) is as follows.1. Initialize N to be T 1 .
for i = 2 to K3. Insert T i into N by adding the smallest number of new reticulation edges. Note that we only add reticulation edges in N and do not delete any existing edges. Thus, any tree already displayed in N is still displayed in the updated N by choosing the original reticulation edges when the tree is first inserted for their display vectors in N. This ensures that each of the input trees is displayed in the final N. Obviously, step 3 is most critical, which we will discuss next.
Inserting tree T into NWe consider the 'min-cost tree insertion problem', where we want to update N by adding the fewest reticulation edges to N so that a given i144tree T is displayed in the updated N , and N remains acyclic. Note that the min-cost tree insertion problem is NP-complete because it contains the two-tree minimum reticulate network problem (an NP-complete problem) as a sub-problem. That is, constructing the minimum reticulate network for trees T 1 and T 2 can be solved by inserting T 2 into T 1 with the minimum cost. In the following, we develop a practical method to solve the min-cost tree insertion problem. Each node of the reconstructed network here has one or two incoming edges (except the root), and one or two outgoing edges (except the leaves). After inserting T (and some new reticulation edges are added), T is displayed in the updated network N. Suppose we remove all the new reticulation edges in N. The edge removals break tree T (N ) (the tree created by keeping edges in N according to a display vector of T ) into a forest F(T (N )). Thus, the number of newly added reticulation edges is exactly the number of trees in F(T (N )) minus one. To minimize the number of needed new reticulation events, we need to minimize the number of trees in F(T (N )). A useful observation is that the problem of finding F(T (N )) with the fewest subtrees is closely related to the maximum agreement forest problem (see the Supplementary Material) as follows. Imagine that we choose a tree T that is displayed in N so that the display vector of T agrees with that of T for N at each reticulation node of N. Recall that N may contain a number of new reticulation nodes that are not in N. Also note T is not necessarily one of the input trees T i. We claim that F(T (N )
Close lower and upper bounds for the minimum reticulate network) is an agreement forest for T and T. To see this, we note that the display choices made by T are identical to T except those at the new reticulation nodes (where T follows the original edge and T (N ) follows the new edge). So the subtrees in F(T (N )) must also be subtrees of T. So, we have: Lemma 4.1. The forest induced by removing newly added reticulation edges of T (N ) is an agreement forest between T and some tree T that is displayed in the original N .Lemma 4.1 implies that to find the best tree insertion, we can find some tree T displayed in N s.t. the number of trees in the maximum agreement forest between T and T is minimized.shows an example of tree insertion. The dashed lines in the tree (left) divide the tree into a forest, which also appears in the existing network (middle, thick lines). Inserting the tree into the network is to add new reticulation edges (right, thick lines) into the networks so that the subtrees in the forests are properly connected to match the given tree. When the number of reticulation nodes in N is small, we may simply enumerate all trees T displayed in N and then find which T gives the smallest agreement forest with T. This quickly becomesinfeasible as the number of reticulation nodes in N grows: when there are r reticulation nodes in N , there may exist 2 r trees T displayed in N. To develop a practical method, we develop an integer linear programming (ILP) formulation to solve the tree insertion problem in an optimal way (without explicit enumeration). The output of the ILP formulation includes the display choices of T as well as the associated agreement forest formed by cutting edges in T. See the Supplementary Material for detailed description of the formulation. Updating N : after tree T and the associated agreement forest are found, we update N as follows. We add new reticulation edges in N to connect subtrees of T in the found agreement forest to make T displayed in the updated network N. First, we determine the order of subtree connection with an approach similar to the algorithm building two-tree hybridization networks in (). The subtree with the special outgroup taxon o acts as the base. Then we repeatedly pick the subtree not intersecting any already connected subtree as the next to connect. Now, for each tree connection:(1) Find the root r of the next subtree (in N ) to attach.(2) Find the node v in the existing network as the attaching point to accept this subtree.Create a new reticulation node in N to connect the subtree. This operation depends on the types of r and v. Two cases are shown in. The other cases are similar. In all the cases, only a single new reticulation edge is created to connect a subtree. Cycles: a remaining issue is that cycles can be introduced when connecting subtrees in N. There are two sources of cycles. First, the found agreement forest may induce cycles (see (). Enhancing the ILP formulation to avoid cycles may significantly complicate the formulation and slow the ILP solving. A practical observation is that cycles in an agreement forest are often caused by two pairs of leaves a,b and c,d so that the a/b pair is ancestral to c/d pair in T and the c/d pair is ancestral to a/b pair in T. Here, we say a pair of leaves a and b is ancestral to a pair of leaves c and d if the the MRCA of a and b is ancestral to the MRCA of c and d. MRCA stands for the most recent common ancestor, and node a is ancestral to node b in tree T if a is on the path from b to the root of T. To forbid this type of simple cycles, we enhance the ILP formulation: for such pairs a/b and c/d, we require either a and b are not in the same subtree, or c and d are not in the same subtree of the resulting forest. Although this does not guarantee to remove all cycles, we found that cycles in the agreement forest are rare after this change. This observation is also useful for the method of computing pairwise reticulation distances in (). Second, cycles can appear in other parts of the network when subtrees in the agreement forest are connected. In practice, however,
i145
Y.Wuwe find this happens relatively rare. When this type of cycles does occur, we simply start over and try another order of tree insertion. This works well in practice: in Section 5, we build acyclic networks successfully for all (thousands of) simulated datasets.
Handling larger datasetsWhen the size and the number of trees grow, the running time increases. To handle larger datasets, we make several simplifications. (i) Instead of enumerating all possible orders of tree insertion, we start with an arbitrary tree. At each step, we pick a tree with the smallest reticulation distance to one of the already inserted trees. (ii) Solving the min-cost tree insertion problem optimally becomes more difficult when data grows. So instead of considering all possible T displayed in N when inserting T , we randomly choose a fixed number (say 10) of trees T displayed in N (in addition to all the inserted gene trees) and find the best way of inserting T based on one of the chosen T. This heuristic is called the coarse mode (and the original approach is called the full mode). Our experience shows that the coarse mode works reasonably well in practice (see Section 5).
EXPERIMENTAL RESULTSWe have implemented a software tool called PIRN (which stands for Parsimonious Inference of Reticulate Network) to compute the RH and SIT bounds. Program PIRN is available for download from: http://www.engr.uconn.edu/ywu/. The tool is written in C++ and uses either CPLEX (a commercial ILP solver) or GNU GLPK ILP solver (mainly a demo of the functionalities for users without a CPLEX license). In computing the SIT bound, PIRN can run full mode (slower but can give better results) or coarse mode (faster but less accurate). We test our methods for both simulated and biological data on a 3192 MHz Intel Xeon workstation.
Simulation dataWe generate simulation data using a two-stage approach: first simulate reticulate networks, and then generate a fixed number of trees displayed in the networks according to randomly generated display vectors. We simulate reticulate networks using a scheme similar to the coalescent simulation implemented in program ms (). For a given number of taxa (denoted as n), we start with n isolated lineages and simulate reticulation backwards in time. At each step, there are two possible events: (i) lineage merging, which occurs at rate 1; (ii) lineage splitting, which occurs at rate r. We choose the next event according to relative probabilities of all feasible events. Lineage merging generates speciation events, while lineage splitting generates reticulation events. To speedup the simulation, lineage splitting is disabled when the number of current lineages is no more than three. The parameter r dictates the level of reticulation in the simulated network: larger r will lead to more reticulation events in simulation. Full mode of the SIT bound: to test the performance of the bounds, we generate data with varying number of trees K, number of taxa n and level of reticulation r. For each settings of these three parameters, we simulate 100 datasets. We report the percentage of datasets where optimal solution is found (i.e. lower bound matches upper bound) in. To show how close the lower and upper bounds are, we report the average gap (the difference between the upper and the lower bounds, divided by the lower bound)in. We also report the average lower bound in, which somewhat reflects how complex the simulated networks are. We also give the average running time for each setting in. For five larger datasets, there are a small number of test cases that are too slow to run the full mode, and are excluded. The percentage of unfinished computation is usually one or two out of 100 datasets, except the cases with n = 30/r = 3.0/K = 5 (18% unfinished) and n = 30/r = 5.0/K = 4 (6% unfinished). This suggests the current practical range of the full mode of the SIT bound.Page: i147 i140i148As shown in, PIRN performs very well when the number of trees K = 3 or reticulation level r is small: optimal solution can be found for at least 80% of simulated datasets when r = 1.0 and K = 5. Even with higher reticulation level (r = 3.0) and larger number of taxa (say 50), still about 60% of datasets can be solved exactly when K = 3. As expected, as the number of taxa, reticulation level and the number of trees grow, fewer datasets can be solved to exact, and correspondingly,shows gaps between the RH and SIT bounds increase.shows the complexity of networks increases too. Nevertheless, the gaps are still relatively small in these cases. For the more difficult settings simulated (i.e. 30 taxa, high reticulation level and five trees as input), the gap is about 25%. Running time depends on the complexity of the networks.shows that PIRN is practical for data of medium size. Coarse mode of the SIT bound: we also test the coarse mode of our methods for larger data, as described in Section 4.2. The results are shown in. The figure on the left shows the effects (on accuracy and running time) of increasing the number of taxa n. The figure on the right shows the effects of having more trees (i.e. increasing K from three to nine) for 10 taxa and reticulation level 5.0. There is clear trade-off between the accuracy of solutions and efficiency. The coarse mode under-performs in terms of the quality of solutions, but is more scalable, especially when K increases. When the number of taxa increases, the coarse mode is likely to run faster than the full mode, but the difference is less significant. GLPK: the CPLEX solver is used in the simulation. The GLPK version in general is less robust and can handle smaller data than the CPLEX version. Our experience shows that the GLPK solver can often solve for five trees with 30 taxa when reticulation level is low and fewer number of taxa when reticulation level is higher. The RH bound: we now compare the performance of the RH bound with the MAF bound. We note that the MAF bound is not easy to compute: finding the MAF of only two trees is known to be NPhard. When data is small, the MAF bound can be computed (e.g. using ILP similar to that in (). In, we compare the RH bound and the MAF bound for 100 datasets. Each data has 10 or 20 taxa and contain three to seven correlated trees. The trees are selected from the local trees for recombining sequences generated by a coalescent simulator, program ms ().shows that the RH bound outperforms the MAF bound in a majority of the simulated datasets and only very rarely the RH bound is lower than the MAF bound. In general, as the number ofBoth RH and SIT bounds are shown, as well as the running time. n: the number of taxa. D: pairwise distances. trees increases, the RH bound tends to outperform the MAF bound in both accuracy and running time. For example, for a dataset with 20 sequences and six input trees, CPLEX runs for over 11 h without reporting a solution (it found a solution of 11, but did not validate its optimality). In contrast, it only takes less than 1 minute to compute the RH bound of value 12 (higher than the MAF result).
i146
Close lower and upper bounds for the minimum reticulate network
Biological dataTo evaluate how well our bounds work for real biological data, we test our methods on a Poaceae dataset. The dataset was originally from the Grass Phylogeny Working Group (Grass Phylogeny Working). The dataset contains sequences for six loci: internal transcribed spacer of ribosomal DNA (ITS); NADH dehydrogenase, subunit F (ndhF); phytochrome B (phyB); ribulose 1,5-biphosphate carboxylase/oxygenase, large subunit (rbcL); RNA polymerase II, subunit  (rpoC2); and granule bound starch synthase I (waxy). The Poaceae dataset was previously analyzed and rooted binary trees were inferred for these loci (). Pairwise comparison were performed in (). Here, we provide inour results on estimating the reticulation number using multiple (three to five) trees. Only shared taxa of a set of trees are kept. Thus, the pairwise distances reported here are different from those in (). As shown in, PIRN finds optimal solutions for both datasets with three trees, and computes lower and upper bounds that are close for the dataset with five trees.shows the reconstructed reticulate network for these five trees. See Supplementary Material for a graphical display of the five grass trees. The network contains 13 reticulation events, and the lower bound is 11. Although the network may not be optimal, the gap between the lower and upper bounds is relatively small.Remark: the following lists several aspects on the performance of PIRN.
i147
Y.Wu(i) Simulation shows that PIRN is often able to find the exact reticulation number when K or r is small, even when the number of taxa increases to medium size (say 50). Moreover, PIRN can compute the RH and SIT bounds for a wide range of data, despite the fact that we do not currently have polynomial-time algorithms for computing the bounds. We achieve this with the help of integer linear programming. (ii) Computing the RH bound is often much faster and more scalable than the SIT bound. Experience shows that the ILP formulation for computing the RH bound is often very fast to solve and computing the pairwise reticulation distances usually takes less time than finding a good upper bound for all trees. The RH bound computation will also benefit from future improvements in computing the pairwise reticulate distances. The simulation results in this section are based on an earlier version of the method in () and speedup may be possible with the latest methods. (iii) The number of trees K and the similarity of tree topologies have impact on PIRN 's optimality and running time. Using more powerful ILP solver (e.g. CPLEX) and/or more powerful machines may also help for more difficult cases. (iv) Finally, our general approaches can be applied to larger data by using efficient computable lower bounds of pairwise rSPR distances in computing the RH bound, and faster but less accurate heuristics to insert trees into a network.
ACKNOWLEDGEMENTI thank Simone Linz for useful discussions and for sharing the grass tree dataset.
Other terms have been used in literature, such as phylogenetic networks and hybridization networks
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
It is not known whether pairwise reticulation distance satisfies the triangle inequality, although it clearly does when cycles are allowed. In practice, pairwise reticulation distances often obey the triangle inequality: we have not found a counter-example from many simulation datasets. i142 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
i148 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
