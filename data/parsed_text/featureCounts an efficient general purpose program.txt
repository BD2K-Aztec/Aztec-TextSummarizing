Motivation: Next-generation sequencing technologies generate millions of short sequence reads, which are usually aligned to a reference genome. In many applications, the key information required for downstream analysis is the number of reads mapping to each genomic feature, for example to each exon or each gene. The process of counting reads is called read summarization. Read summarization is required for a great variety of genomic analyses but has so far received relatively little attention in the literature. Results: We present featureCounts, a read summarization program suitable for counting reads generated from either RNA or gen-omic DNA sequencing experiments. featureCounts implements highly efficient chromosome hashing and feature blocking techniques. It is considerably faster than existing methods (by an order of magnitude for gene-level summarization) and requires far less computer memory. It works with either single or paired-end reads and provides a wide range of options appropriate for different sequencing applications.
INTRODUCTIONNext-generation (next-gen) sequencing technologies are revolutionizing biology by providing the ability to sequence DNA at unprecedented speed (). The computational problem of mapping short sequence reads to a reference genome has received enormous attention in the past few years (), and the rapid development of fast and reliable aligners is one of the success stories of bioinformatics. Raw aligner output, however, is not usually sufficient for biological interpretation. Read mapping results have to be summarized in terms of read coverage for genomic features of interest before they can be interpreted biologically. One of the most ubiquitous operations that forms part of many next-gen analysis pipelines is to count the number of reads overlapping predetermined genomic features of interest. Depending on the next-gen application, the genomic features might be exons, genes, promotor regions, gene bodies or other genomic intervals. Read counts are required for a wide range of count-based statistical methods for differential expression or differential binding analysis (). Despite its importance in genomic research, the read counting problem has received little specific attention in the literature. The problem may appear superficially simple but in practice has many subtleties. Read count programs need to accommodate both DNA and RNA sequencing as well as single and pairedend reads. The reads or paired-end fragments to be counted may incorporate insertions, deletions or fusions relative to the reference genome, and these complications need to be accounted for when comparing the location of each read or fragment to each possible target genomic feature. When the number of features is large, the computational cost of read counting can be comparable with that of the read alignment step. DNA sequence reads arise from a variety of technologies including ChIP-seq for transcription factor binding sites (), ChIP-seq for histone marks () and assays that detect DNA methylation (). The genomic features of interest for DNA reads can usually be specified in terms of simple genomic intervals. For example,counted reads associated with histone marks by gene promotor regions and by whole gene bodies. Rosscounted reads overlapping with intervals identified by a peak caller (). Counting RNA-seq reads is somewhat more complex because of the need to accommodate exon splicing. One way is to count reads overlapping each annotated exon, an approach that can be used to test for alternative splicing between experimental conditions (). Another common approach is to summarize counts at the gene level, by counting all reads that overlap any exon for each gene (). Gene annotation from RefSeq () or Ensembl () is often used for this purpose. Read counts provide an overall summary of the coverage for the genomic feature of interest. In particular, gene-level counts from RNA-seq provide an overall summary of the expression level of the gene but do not distinguish between isoforms when *To whom correspondence should be addressed.  The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com multiple transcripts are being expressed from the same gene. Reads can generally be assigned to genes with good confidence, but estimating the expression levels of individual isoforms is intrinsically more difficult because different isoforms of the gene typically have a high proportion of genomic overlap. A number of model-based methods have been developed that attempt to deconvolve the expression levels of individual transcripts for each gene from RNA-seq data, essentially by leveraging information from reads unambiguously assigned to regions where isoforms differ (). This article concentrates on the read count problem, which is generally applicable even when the sequencing depth is not sufficient to make transcript level analysis reliable. Many statistical analysis methods have been developed to detect differential expression or differential binding on the basis of read counts (). Recent comparisons have concluded that the read count methods perform well relative to model-based methods for the purposes of gene-level differential expression () or detection of splice variation (). Only a handful of general purpose read count software tools are currently available. The software packages GenomicRanges () and IRanges (), developed by the core team of the Bioconductor project (), include functions for counting reads that overlap genomic features. The countOverlaps function of IRanges is designed for counting reads overlapping exons or other simple genomic regions, whereas the summarizeOverlaps function of GenomicRanges is designed for counting reads at the gene level. Another tool is the htseq-count script distributed with the HT-Seq Python framework for processing RNA-seq or DNA-seq data (). All of these are popular and welltested software tools, but all make extensive use of programming in the interpreted computer languages R or Python and none are fully optimized for efficiency and speed. BEDTools is a popular tool for finding overlaps between genomic features that can be used to count overlaps between reads and features (). It is fully implemented in the compiled language C, making it faster than the aforementioned tools. It is, however, not specifically designed for RNA-seq data, so can count reads for exons or interval features only, similar to countOverlaps. This article presents a highly optimized read count program called featureCounts. featureCounts can be used to quantify reads generated from either RNA or DNA sequencing technologies in terms of any type of genomic feature. It implements chromosome hashing, feature blocking and other strategies to assign reads to features with high efficiency. It supports multithreading, which provides further speed improvements on large data problems. It is available either as a Unix command or as a function in the R package Rsubread. In either case, all the core functionality is written in the C programming language. The R function is a wrapper for the compiled C code that provides the convenience of the R programming environment without sacrificing any of the efficiency of the C implementation.
DATA FORMATS AND INPUTS
Input dataThe data input to featureCounts consists of (i) one or more files of aligned reads in either Sequence Alignment/Map (SAM) or Binary Alignment/Map (BAM) format () and (ii) a list of genomic features in either general feature format (GFF) (Wellcome Trust Sanger Institute, 2013) or simplified annotation format (SAF) (). The read input format (SAM or BAM) is automatically detected and so does not need to be specified by the user. Both the read alignment and the feature annotation should correspond to the same reference genome, which is a set of reference sequences representing chromosomes or contigs. For each read, the SAM or BAM file gives the name of the reference chromosome or contig to which the read mapped, the start position of the read on the chromosome or contig and the so-called Concise Idiosyncratic Gapped Alignment Report (CIGAR) string giving the detailed alignment information including insertions and deletions and so on relative to the start position. The genomic features can be specified in either GFF or SAF format. The SAF format is the simpler and includes only five required columns for each feature: feature identifier, chromosome name, start position, end position and strand. These five columns provide the minimal sufficient information for read quantification purposes. In either format, the feature identifiers are assumed to be unique, in accordance with commonly used Gene Transfer Format (GTF) refinement of GFF (). The number of reference sequences may be small or large depending on the application. For well-established genomes, the number of reference sequences is equal or close to the number of chromosomes. The number of reference sequences can be, however, much larger for genomes with incomplete or lowquality assemblies because each contig becomes a reference sequence. RNA-seq reads are sometimes aligned to the transcriptome instead of to the genome. In this case, there may be hundreds of thousands of transcripts and each transcript becomes a reference sequence. featureCounts supports strand-specific read counting if strandspecific information is provided. Read mapping results usually include mapping quality scores for mapped reads. Users can optionally specify a minimum mapping quality score that the assigned reads must satisfy.
Single and paired-end readsReads may be paired or unpaired. If paired reads are used, then each pair of reads defines a DNA or RNA fragment bookended by the two reads. In this case, featureCounts will count fragments rather than reads. featureCounts automatically sorts reads by name if paired reads are not in consecutive positions in the SAM or BAM file.
Features and meta-featuresEach feature is an interval (range of positions) on one of the reference sequences. We also define a meta-feature to be a set of features representing a biological construct of interest. For example, features often correspond to exons and meta-features to genes. Features sharing the same feature identifier in the GFF or SAF annotation are taken to belong to the same meta-feature. featureCounts can summarize reads at either the feature or metafeature levels.
ALGORITHM
Overlap of reads with featuresfeatureCounts performs precise read assignment by comparing mapping location of every base in the read or fragment with the genomic region spanned by each feature. It takes account of any gaps (insertions, deletions, exonexon junctions or fusions) that are found in the read. It calls a hit if any overlap (1 bp or more) is found between the read or fragment and a feature. A hit is called for a meta-feature if the read or fragment overlaps any component feature of the meta-feature.
Multiple overlapsA multi-overlap read or fragment is one that overlaps more than one feature, or more than one meta-feature when summarizing at the meta-feature level. featureCounts provides users with the option to either exclude multi-overlap reads or to count them for each feature that is overlapped. The decision whether to count these reads is often determined by the experiment type. We recommend that reads or fragments overlapping more than one gene are not counted for RNA-seq experiments because any single fragment must originate from only one of the target genes but the identity of the true target gene cannot be confidently determined. On the other hand, we recommend that multioverlap reads or fragments are counted for most ChIP-seq experiments because epigenetic modifications inferred from these reads may regulate the biological functions of all their overlapping genes (). Note that, when counting at the meta-feature level, reads that overlap multiple features of the same meta-feature are always counted exactly once for that meta-feature, provided there is no overlap with any other meta-feature. For example, an exonspanning read will be counted only once for the corresponding gene even if it overlaps with more than one exon.
Chromosome hashingThe first step of the featureCounts algorithm is to generate a hash table for the reference sequence names. This allows the reference sequence names found in the SAM files and GFF annotation to be matched quickly. This is particularly useful when there is a large number of reference sequences. After matching reads and features by reference sequence, subsequent analysis can proceed for each reference sequence separately.
Genome bins and feature blocksAfter hashing the reference sequence names, the features in each reference sequence are sorted by their start positions (leftmost base positions). A two-level hierarchy is then created for each reference sequence. First, the reference sequence is divided into non-overlapping 128 kb bins and features are assigned to bins according to their start positions. Within each bin, equal numbers of consecutive features are grouped into blocks (). The number of blocks in a bin is the square root of number of features in that bin (rounded up to the next whole number). This ensures that the number of features in a block is nearly equal to the number of blocks in a bin, an optimal setting for a hierarchical search. The use of a hierarchical data structure (features within blocks within bins) is a key component of the featureCounts algorithm. It facilitates rapid read assignment by quickly narrowing down the genomic region that could contain features overlapping with the query read. The query read is compared first with genomics bins, then with feature blocks within any overlapping bins and then with features in any overlapping blocks. Instead of using multiple levels of bins (), the algorithm uses only one level of bins in combination with the feature blocks. Finally, the algorithm decides how to assign the read according to which level of summarization is being performed (feature level or meta-feature level) and whether the read is allowed to overlap with more than one target at that level.
IMPLEMENTATIONThe featureCounts command in the Subread package for Unix is written entirely in the C programming language. The memory footprint is minimized by holding in memory only thefeature annotation data required at each stage of the computation. The C code supports multithreading, and the user can specify the number of threads to be used. One thread is the default. The R function featureCounts in the Rsubread package for R is a wrapper for the same compiled C code as for the Unix command line. The R function provides the convenience of the R programming environment without sacrificing any of the efficiency of the C implementation. It produces a data object in R that can be input directly into R-based statistical analysis software such as edgeR () or limma () that are designed to analyze next-gen read counts.
PERFORMANCE ON RNA-SEQ DATA
Data and annotationFirst we compare the performance of featureCounts with existing software tools for counting RNA-seq reads at the gene level. As an example case study, we use RNA-seq data that were generated as part of the SEQC (SEquencing Quality Control) project, the third stage of the MicroArray Quality Control (MAQC) project (). These data consist of 6.8 million pairs of 101 bp reads generated by sequencing a sample of Universal Human Reference RNA on an Illumina HiSeq 2000. The SEQC RNA-seq dataset was aligned to the human genome GRCh37 using the Subjunc aligner included in the Subread package (). We used Subjunc for this analysis because it explicitly identifies exonexon junctions and outputs the mapping location of every base of every read including those that span multiple exons. This allowed us to examine rigorously the ability of the read count programs to count reads spanning multiple exons as well as reads falling within exons. Genes and exons were defined as in the NCBI human RefSeq annotation build 37.2. This included 25 702 genes and 225 071 exons. Counts were summarized at the gene level. That is, exons were defined to be features, genes were defined as meta-features and quantification was at the meta-feature level. As this is RNA-seq data, reads or fragments that overlapped multiple genes should be excluded from the counts.
Comparative performance when counting readsTo demonstrate featureCounts on single-end reads, the first evaluation uses only the first read from each read pair.compares the performance of featureCounts to that of the summarizeOverlaps function of the GenomicRanges package and to the htseq-count script. featureCounts and summarizeOverlaps yielded identical counts for every gene (, column 2). htseq-count counted slightly fewer reads than featureCounts and summarizeOverlaps. We had a close look at the summarization results for each read given by htseq-count and featureCounts and found that only a small number of reads were assigned to different genes by the two methods (). By comparing the features regions with the regions these reads were mapped to, we identified the reason causing this discrepancy. htseq-count takes the right-most base position of each feature as an open position and excludes it from read summarization, whereas featureCounts and summarizeOverlaps take it as a closed position and includes it in their summarizations. The GFF specification states that the start and end positions of features are inclusive (Wellcome Trust), so the interpretation of featureCounts and summarizeOverlaps appears to be correct. GFF is the only annotation format supported by htseq-count. We modified the annotation file provided to htseq-count by adding one to the right-most position of each exon to let htseq-count include these positions. After this modification, htseq-count yielded identical counts to featureCounts and summarizeOverlaps. Here and all subsequent comparisons, the software tools were tested on a HP Blade supercomputer with 64 AMD OpteronNote: Results are given for genewise counts of either single-end reads or paired-end fragments. featureCounts yields the same read counts as summarizeOverlaps but is much faster and memory efficient. summarizeOverlaps counts fewer fragments because it excludes read pairs with only one end successfully mapped. htseq-count counts slightly fewer reads or fragments than featureCounts because it interprets GFF annotation differently and calls more ambiguously assigned fragments. The table gives the total number of reads counted when using single-end reads and the total number of fragments counted when using paired-end reads. Running time and memory usage are for fragment summarization. featureCounts was set to exclude reads or fragments overlapping multiple genes. summarizeOverlaps and htseq-count were run in 'union' mode. Results are shown for countOverlaps (i) when run on the whole genome at once and (ii) when run chromosome by chromosome.(b). Concordance between featureCounts and htseq-count regarding assignment of reads (a) or fragments (b) to genes. The dataset is the same as for
Comparative performance when counting fragmentsWe went on to compare the same methods for counting pairedend fragments, using the full SEQC paired-end data. Summarize Overlaps counted far fewer fragments than featureCounts and htseq-count (, column 3). The main reason for this discrepancy is that summarizeOverlaps requires fragments to have both end reads successfully mapped before assigning them to genes, whereas featureCounts and htseq-count do not have such a requirement, i.e. they can assign fragments just one end mapped. With a read length of 101 bp, fragments with only one end mapped can still have relatively high mapping confidence. Counting such fragments seems likely to benefit downstream analyses. Many aligners report fragments that have only one end mapped, including Subread, Subjunc (), Bowtie () and TopHat (). Almost all (92%) of fragments counted by featureCounts but not by summarizeOverlaps were assigned to genes that also had at least 100 assigned fragments with both ends mapped. This shows that the fragments were assigned to genuinely expressed genes, giving confidence that the extra fragments have been assigned correctly. Only 0.1% of extra fragments counts by featureCounts were assigned to genes not supported by any fragment with both ends mapped. htseq-count also counts fewer fragments than featureCounts in this evaluation (). Running htseq-count in 'IntersectionStrict' or 'IntersectionNotEmpty' modes instead of 'Union' mode did not cause it count more fragments. featureCounts can distinguish those features that overlap with different numbers of reads from the same fragment. For example, if two genes were found to both overlap with a fragment but one gene was found to overlap with only one read and the other with both reads from that fragment, featureCounts will assign that fragment to the gene overlapping with both reads. However, htseq-count will take this fragment as ambiguous and will not assign it to any gene. This is the main reason why featureCounts counted slightly more fragments than htseqcount. featureCounts uses the size of overlap (in terms of reads) to recover those 'ambiguous' fragments. For this dataset, 486% of fragments assigned by featureCounts but not by htseq-count were assigned to genes that already had at least 100 unambiguous fragments assigned by both methods. Only 0.2% of extra fragments assigned by featureCounts were not supported by commonly assigned fragments. This again shows that the extra fragments are being assigned to genuinely expressed genes, suggesting that the extra fragments are likely to have been correctly assigned.(columns 4 and 5) shows that featureCounts was considerably faster (410-folds) and more memory efficient than the other programs. summarizeOverlaps was also run chromosome by chromosome to save memory. That is, reads were split into groups according to the chromosomes they were mapped to and each group of reads was summarized separately. But it still used 20 times as much memory as featureCounts.
PERFORMANCE ON CHIP-SEQ DATA
Data and annotationNow we compare the performance of featureCounts with existing software tools for counting gDNA-seq reads at the feature level. As an example case study, we use a ChIP-seq dataset that was generated as part of a study of global changes in the mammary stem cell epigenome under hormone perturbation (). Specifically the dataset was generated to find genomic regions associated with the H3K27me3 epigenetic histone mark (tri-methylation of the histone H3 lysine 27) in mouse mammary stem cells. This dataset consists of 15 million pairs of 35 bp DNA reads generated by an Illumina Genome Analyzer IIx. The study analyzed the total number of fragments mapped to the broad region of each gene, where the broad region is defined to be the entire gene body from first to last base plus the 3 kb region immediately upstream from the transcription start of the gene representing the putative promotor region (). The read mapping and annotation used here follows the original study. Reads were mapped to the mouse genome (mm9) using the Subread aligner (). Fragments were included in the evaluation only if both paired reads were successfully mapped to the genome and if the fragment defined by the end reads was between 50 and 500 bp long. The transcription start and end positions for each gene were obtained from the NCBI mouse RefSeq annotation (build 37.2).
Comparative performanceWe summarized paired-end fragments at the feature level, where the features represented the broad regions of all annotated genes. In this application, a fragment should be counted multiple times if it overlaps multiple genes.compares the performance of featureCounts to that of the countOverlaps function of the IRanges package, the htseqcount script and the coverageBED program in the BEDTools software suite. countOverlaps was used for this comparison instead of summarizeOverlaps because it allows multi-overlap reads to be assigned to multiple features. featureCounts and countOverlaps yielded identical counts for every gene, but featureCounts was considerably faster and more memory efficient. countOverlaps was also run chromosome by chromosome to save memory. This reduced the peak memory usage, although it remained more than a hundred times that used by featureCounts. Note that featureCounts, unlike countOverlaps, can count fragments with only one end successfully mapped, but such fragments were not included in this evaluation to ensure that the timings and memory use for featureCounts and countOverlaps were for identical operations. coverageBED assigned slightly fewer fragments than featureCounts. We found this was because coverageBED used only the first read of each fragment to assign the whole fragment to features. htseq-count counted 78% fewer fragments, presumably because it does not count multi-overlap fragments. htseqcount was run in 'intersection-nonempty' mode as well as in 'union' mode so as to count more fragments, but this did not make up much of the shortfall. Columns 3 and 4 ofshow that featureCounts was about five times faster and used about 10 times less memory than the next most efficient tool.
PERFORMANCE WHEN THE NUMBER OF REFERENCE SEQUENCES IS LARGE
Simulated dataDatasets with large numbers of reference sequences are challenging because the read count software must match the contig names of features to those of reads in an efficient manner. To examine performance under these conditions, we simulated reads from an incompletely assembled genome with relatively large number of scaffolds. We used an assembly of the budgerigar genome generated in the Assemblathon 2 project (). For this assembly there are 16 204 annotated genes with 153 724 exons located on 2850 scaffolds. Eight million 100 bp single-end reads were randomly extracted from the annotated exonic regions in the assembled scaffolds. The simulated reads were entered into a SAM file. Read mapping information was filled according to the locations from where the reads were extracted.
Comparative performanceThe simulated reads were then summarized at the gene level.compares featureCounts to summarizeOverlaps and htseq-count for this dataset. As seen before on the RNA-seq data, summarizeOverlaps yields the same counts as featureCounts, whereas htseq-count yields slightly fewer. featureCounts maintained its efficiency advantage over the other methods in this evaluation, increasing its speed advantage over summarizeOverlaps in this context.
THEORETICAL ANALYSIS OF ALGORITHMIC COMPLEXITYThis section gives a theoretical analysis of the computational time and memory storage required by featureCounts and the other algorithms. The actual time and memory consumed by a computer program depends on the computer hardware, operating system and other factors as well as on the mathematical efficiency of the algorithm used. However, we can derive theoretical expressions for the rate at which time and memory used by any specific algorithm should increase with the number of reads, the number of features and the density of features in the genome. The time complexity of the featureCounts algorithm can be derived as Of log f  r ffiffiffiffiffi k 1 p , where f is the number of features, r is the number of reads and k 1 is the number of features included in a genomic bin. This means that the number of elementary computations used by the algorithm increases linearly with the number of reads, independently of the number of features and somewhat faster than linearly with the number of features. The space complexity of the featureCounts algorithm is Of  b 1 , meaning that memory used increases linearly with the number of features plus the number of bins b 1. Time and space complexities for all the algorithms are given in. The number of reads is typically large, so rate of increase with r is especially important. The featureCounts algorithm has the lowest time complexity of the algorithms being compared. The red-black tree search algorithm used by htsesq-count has higher complexity because log f is typically larger than the square root of the number of features per bin used by featureCounts. The hierarchical search within bins used by featureCounts is more efficient than the sequential search carried out by coverageBED because most reads overlap multiple levels of bins with coverageBED causing k 2 to be typically greater than k 1. countOverlaps and summarizeOverlaps sort reads according to their mapped locations and then use an interval tree to find features overlapping with reads. The sort step is especially expensive and introduces r log r terms. The htseq-count algorithm has the best theoretical space complexity, but featureCounts is not far behind because the number of bins b 1 is usually small compared with f. BEDTools has a higher space complexity than featureCounts because it usesNote: featureCounts is the fastest method and uses least memory. It counts the same number of fragments as countOverlaps but more than htseq-count or coverageBED.the total number of fragments counted, time taken and peak memory used. featureCounts was set to count multi-overlap fragments. Results are shown for countOverlaps (i) when run on the whole genome at once and (ii) when run chromosome by chromosome. Running by chromosome conserves memory but takes longer. Results are shown for htseq-count in two possible counting modes. For coverageBED, the BAM input file was converted to a BED file for summarization using bamToBed with options '-bedpe' and '-split'.more bins. CountOverlaps and summarizeOverlaps have higher space complexities that depend on the number of reads as well as on the number of features. In practice, the running time and memory usage of a software program are determined not just by the inherent time and space complexities of the algorithm it adopts but also by the efficiency of the software implementation. The practical timings show that featureCounts achieves further efficiency gains from high performance C programming and direct memory manipulation.
DISCUSSIONRead summarization is an important step in many next-gen sequencing data analyses. In this study, we developed a new read summarization program called featureCounts and compared it with existing methods in terms of efficiency and accuracy. Our results showed a high concordance between alternative methods in summarization accuracy. However, there was a large difference observed in their computational cost. The featureCounts method was found to be an order of magnitude faster on average and far more memory efficient than other methods. The high computational efficiency of featureCounts is due to its ultrafast feature search algorithm and its highly efficient implementation entirely using the C programming language. All results presented in this article were produced using a single thread, but featuresCounts also supports multithreaded processing, making it particularly useful for summarizing data generated in large sequencing studies. It is the only existing read count method that supports multithreading. This program provides a wide range of options to allow users to fully control how their read data can be best summarized. Users can choose whether they should count the reads that overlap with more than one feature or meta-feature. This choice is often determined by the experiment type. Reads overlapping with more than one gene (a meta-feature) should not be counted in a RNA-seq experiment because such reads can only originate from one gene, but usually they should be counted in a gDNA-seq experiment such as a histone ChIP-seq experiment. This program also allows users to filter out reads before summarization using a number of metrics such as mapping quality scores, fragment mappability (whether two ends from the same fragment are both successfully mapped or not), fragment length, strandness, chimerism and so on. It can automatically detect either SAM or BAM format read input and sort reads by name if paired reads are not in consecutive positions in the input. It also allows users to specify whether those reads that were reported with more than one mapping location (multi-mapping) should be counted or not. Many of these useful features are not supported by other programs. The featureCounts program has been implemented in both SourceForge Subread package () and Bioconductor Rsubread package (). The R function provides users with an R interface so that they can access this program from their familiar R environment. It calls the underlying compiled C program to perform all the read summarization operations, and hence has the same speed and memory usage as that of the SourceForge Subread package, which is written entirely in C. The implementation of featureCounts in R enables complete pipelines to be established for analyzing next-gen sequencing data using Bioconductor software programs. For example, functions included in Bioconductor packages Rsubread, limma and edgeR can be used to perform complete RNA-seq and histone ChIP-seq analyses, starting from read mapping, to read summarization and finally to differential expression analyses or differential histone modification analyses. Owing to its high efficiency and accuracy, we believe the featureCounts program will be a useful tool in the bioinformatics toolbox for analyzing next-gen sequencing data.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Y.Liao et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
featureCounts at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
