Motivation: Aligning and comparing protein structures is important for understanding their evolutionary and functional relationships. With the rapid growth of protein structure databases in recent years, the need to align, superpose and compare protein structures rapidly and accurately has never been greater. Many structural alignment algorithms have been described in the past 20 years. However, achieving an algorithm that is both accurate and fast remains a considerable challenge. Results: We have developed a novel protein structure alignment algorithm called 'Kpax', which exploits the highly predictable covalent geometry of C atoms to define multiple local coordinate frames in which backbone peptide fragments may be oriented and compared using sensitive Gaussian overlap scoring functions. A global alignment and hence a structural superposition may then be found rapidly using dynamic programming with secondary structure-specific gap penalties. When superposing pairs of structures, Kpax tends to give tighter secondary structure overlays than several popular structure alignment algorithms. When searching the CATH database, Kpax is faster and more accurate than the very efficient Yakusa algorithm, and it gives almost the same high level of fold recognition as TM-Align while being more than 100 times faster. Availability and implementation: http://kpax.loria.fr/.
INTRODUCTIONAligning and comparing protein structures is important for understanding their evolutionary and functional relationships (). By quoting Lewis Carrol's Red Queen character (it takes all the running you can do, to keep in the same place),recently alluded to the computational challenge of searching increasingly large protein structure databases. Today, 4 years later, with some 80 000 protein structures in the Protein Databank and with the number of new structures being solved growing exponentially (), the need to compare the 3D structures of protein molecules rapidly and reliably has never been greater. Efficient pattern matching algorithms such as FASTA () and BLAST () are now standard tools for searching nucleotide and amino acid sequence databases. Dynamic programming (DP) algorithms provide a rapid way to find the optimal global () or local () alignments of pairs sequences. However, there is still no generally accepted standard for how to align and compare two similar protein structures (). This discrepancy arises because the additional complexity of working in 3D space makes structure alignment considerably more difficult than sequence alignment. For example, two common and closely related measures of structural similarity are the number of residue equivalences and the root mean squared deviation (RMSD) between the corresponding C atoms. However, while it is often possible to improve one at the expense of the other, it is difficult to optimize these two quantities simultaneously (). Furthermore, because RMSD values tend to be dominated by long-distance pairs, it can be useful to restrict RMSD-based similarity measures to selected 'core' residues (). But this then raises the question of precisely which residues should be considered as core residues. Consequently, different similarity scoring schemes can assign different sets of 'optimal' residue equivalences (). Despite such difficulties, many practical structural alignment algorithms have been described (), and the number of recent publications is growing rapidly (). These algorithms can often be classified according to how they use the internal geometries of proteins to calculate interatomic distances (;) or cliques of distances (), interatomic C vectors (), or triplets of C atoms (), torsion angles (), or combinations of distances and angles (). Geometric-hashing () and Voronoi tessellation techniques have also been used to calculate pose-invariant measures of structural similarity (). Different algorithms may also be distinguished according to whether and how they use secondary structure elements (SSEs) in the similarity scoring function or whether they match SSEs as *To whom correspondence should be addressed structural units (). For example, Sheba finds an initial superposition using a DP scoring matrix that combines sequence homology, secondary structure similarity, solvent accessibility and polarity to obtain an initial superposition which is then optimized using DP to maximize the number of close C C distances. The method of Jung and Lee (2000), ProSup () and TM-Align () identify short seed fragments to give initial superpositions which are then optimized in similar ways. Yet other approaches define and match higher-order structural alphabets () or fragments that might subsequently be re-assembled (). Most algorithms treat proteins as rigid-body objects, but a few can take into account structural flexibility (), permutations of structural motifs (;) and even composite alignments involving multiple chains (). However, almost all of these approaches are prohibitively expensive if the aim is to search large protein structure databases. As well as the diverse geometric and symbolic representations listed above, algorithms based on sophisticated algebraic approaches have also been described, including Lagrangian contact map optimization (), eigenvector analysis () and Fourier correlation techniques (). Recent improvements to the contact map optimization approach using integer linear programming () can now find provably optimal structural alignments in favourable cases. However, as before, such techniques are currently too expensive to search large structural databases. Here, our aim is to meet the need for a general purpose structural alignment algorithm that is sufficiently fast to support ad hoc queries against large structural databases while also being sufficiently sensitive to provide high quality (but not necessarily optimal) pair-wise alignments. Our overall approach is motivated by the basic observation that the four covalent bonds of each C atom have a highly predictable tetrahedral geometry, which could be used to superpose arbitrary pairs of C atoms and their covalent partner atoms using least-squares fitting. Thus, armed with the corresponding 3D fitting matrix, the relative positions of neighbouring up-stream and down-stream residues could easily be compared and scored. However, rather than using explicit least-squares fitting, which is a computationally expensive operation and which requires the coordinates of two sets of atoms, we note that a similar (but not strictly identical) transformation can be achieved by individually translating each C atom to the coordinate origin and by aligning two of its covalent bonds with the coordinate axes. In other words, applying such a transformation will allow the backbone peptide fragment associated with each C position to be placed in a standard, or canonical, orientation. In the context of database search, this is clearly advantageous because it allows each structure to be pre-processed separately in linear time.From this starting point, we calculate a similarity score for putative pairs of backbone fragments using a sum of products of Gaussian functions centred on the C positions within each fragment and on a small number of further 'virtual' atom positions that encode the apparent centre of mass (COM) of each protein, as described below. We then use these Gaussian overlap scores to construct a DP scoring matrix with SSE-dependent gap penalties which allows an optimal set (according to our scoring function) of equivalent residues to be found and superposed efficiently. A particular feature of a scoring function based on sums of Gaussians is that it implicitly favours close contacts without necessarily needing to exclude long-range pairs. Although we implemented SSE-dependent gap penalties initially to improve database retrieval performance, we find that using such penalties together with our Gaussian scoring function tends to produce alignments with smaller numbers of aligned residues but with somewhat tighter 3D overlays of SSEs than the other alignment algorithms studied here. It should be noted that Taylor and Orengo (1989) first demonstrated the utility of using local coordinate systems. They constructed a local coordinate frame for each residue using N-C and C-H bond vectors, but crucially they used it only to compare patterns of intra-molecular vectors rather than inter-molecular distances. Although later approaches that use internal torsion angles such as Yakusa () and SABIC () share a similar insight to our approach, the inter-molecular scoring functions in these algorithms can only compare one angle or one distance for each pair of residues. In contrast, for each position along a backbone, our Gaussian scoring function can be used to score the similarity of two local backbone fragments by comparing the positions of up to three residues in each direction along the chain. Hence, we also use Gaussian overlap scores to define the secondary structure of each residue according to its similarity to a model-helix or-sheet. On a contemporary workstation, our multi-threaded algorithm can calculate thousands of structural alignments per second. Hence we named it 'Kpax' (being short for 'thousands of protein alignments by canonical C coordinate centres per second').
METHODSThe Kpax similarity score for a pair of residues i and j has the form:where each K is a normalized score with a value between zero and one, and each w is a weight factor in the same range and normalized such that w l  w s  w b  1:0. The first term gives a measure of the local similarity of a pair of residues when calculated in a common coordinate frame. The second term measures their spatial similarity with respect to the relative position of the COM of a protein (also calculated in the same frame). These two terms are described in more detail below. The final term is the Blosum62 amino acid similarity score, in which each pair-wise score has been scaled onto the above range. Here, we set w b  0 in order to consider only structure-based alignments.
Constructing local C coordinate framesHere, we set up a local 3D coordinate system for each amino acid residue by using the coordinates of its C , C and N backbone atoms to construct a 3D transformation matrix, K, defined as a sequence of transformations consisting of (i) a translation that locates the C atom at the origin, (ii) a rotation that places the C atom on the negative z axis, and (iii) a further rotation about the z axis that places the N atom in the xz plane with a positive x coordinate. For the 19 common non-glycine L-amino acid residues, applying K will place the C and H atoms on the positive and negative y sides of the xz plane, respectively. For glycine, applying K will locate the H and H symmetrically on either side of the xz plane. However, none of the above backbone atoms play any subsequent role in our scoring function because their local-frame coordinates are almost invariant.shows how fragments of a theoretical-helix and-strand from the CCP4 fragment library () may be located in a canonical orientation at the origin using the K-transform. Using a different residue to calculate the K-transform would shift each fragment by the corresponding number of peptide units along its principal secondary structure axis. For an infinitely repeating polyalanine-helix or-strand, applying the K-transform for each residue would give an indistinguishable result. On the other hand, given a suitable scoring function, it is natural to suppose that near the coordinate origin, similar but non-identical SSEs could be brought into close register by applying a suitable local frame shift of one structure relative to the other.
The local frame fragment similarity scoreTo calculate the similarity of two backbone fragments using a smooth scoring function, we represent the fragment centred on residue i as a product of normalized Gaussian density functions located on n downstream and n up-stream C atoms:Each individual Gaussian function has the formwhere r k is the distance from the k th C atom, k is a scale factor and k is the Gaussian width of the k'th density function. N k is a normalization factor such thatWe then transform each of the 2 n C atom coordinates of a pair of fragments, i and j, into a common local coordinate frame using K i and K j , and we calculate the local similarity score between two fragments as a multi-term overlap integralThe overall scheme is illustrated in. Assuming there is no overlap between density functions belonging to different C atoms and that equivalent C atom positions may be assigned the same Gaussian parameters, it can be shown () that the above integral may be simplified to givewhere R ik, jk is the distance between the C atoms at positions i  k and j  k on chains A and B, respectively, and k is a scale factor which we currently set to unity. The summation excludes k  0 because R i0, j0  0 by construction. In other words, the local similarity between residues i and j is calculated as a Gaussian sum of the squared distances between pairs of up-stream and down-stream C atoms. To obtain suitable values for the parameters k , we treat each as the standard deviation (SD) of a normal Gaussian distribution, and by considering each residue in turn of each domain in the CATH database (), we calculated the mean and SDs of all residues at relative positions AE1 to AE3 with respect to the residue under consideration to obtain the values: 1  1.46, 1  1.03, 2  3.72, 2  3.54, 3  5.52 and 3  5.74. To apply the above scoring function to residues near the N and C termini of one or both chains, we use a simple wrapping scheme in order to maintain the total number of terms in Equation (6). For example, when i  1, there are no residues with negative offsets, and so the contribution from ' 1are calculated using Equation (6), but the contribution from ' 2 i to ' n i is doubled, and so on. A similar scheme is used for the C-terminal residues.
The spatial similarity scoreIf two protein domains which share a similar fold are superposed, their COMs will often be close together. Thus, if a protein's COM is transformed into the local frame of each residue, it follows that residues which are well aligned will 'see' the COM in similar positions in space (although consecutive residues will see the COM in quite different positions). In particular, the COM will appear in approximately the same location only for every fourth residue of an-helix, and every second residue of a-sheet. To exploit this property in a similar way to the local frame fragment scoring function, we transform the COM into the local frame of each residue, and we place a virtual atom (VA) at a distance of 2 A  from the origin on the direction vector of the transformed COM. This is illustrated in. Thus, each VA represents and encodes the local frame spatial direction of a protein's COM. Then, in analogy to Equation (6), the spatial similarity score is calculated as a product of Gaussian overlap integralsFig. 2. Calculating local pair-wise similarity scores. The local-frame distribution of all C coordinates from the CATH database (left) is used to calculate the Gaussian width, k , for each up-stream and down-stream residue position. For a given pair of residues, i and j, the 'K-score' is calculated as a product of Gaussian overlap integrals (Equation 6) using the local frame pair-wise C distances (right). Constructing a local coordinate frame about a tetrahedral C coordinate centre. The C atom is placed at the origin, the C atom on the negative z axis, and the N atom in the positive x region of the xz plane where R ik, jk is the distance between the VAs at positions i  k and j  k, and the summation excludes k  0 as before. Each k is considered as the SD of a Gaussian distribution of the VA coordinates. Hence, VAs were placed on all of the residues of the CATH database and the SDs were calculated from the resulting distributions to give 1  2.43, 1  2.17, 2  4.13, 2  3.93, 3  5.74 and 3  5.58.
Assigning secondary structure elementsBy placing the centre residue of a theoretical model of an-helix and a-strand at the local coordinate origin, Equation (6) provides a straight-forward way to detect the SSE type of a given residue by calculating its local-frame similarity to each model fragment. Here, we use the five-residue template files theor-helix-5.pdb and theor-strand-5.pdb from the CCP4 fragment library (), and for each residue in a given structure we assign type to residue i if K i, 3 4K i, 3 40:1, we assign if K i, 3 4K i, 3 40:1, and we assign (i.e. loop or coil) otherwise. Any singleton or residues within a region are re-assigned to .
Dynamic programming structural alignmentsThe optimal 'pose-invariant' alignment for two chains, A and B, of length N A and N B is calculated by first initializing a DP matrix of dimension N A  1  N B  1 using D 0, j  D i, 0  0:0, and by filling the remaining elements usingwhere K ij is the similarity score for residues i and j (Equation 1) and P i is the penalty for introducing a gap between residues i and i1. Since a typical C C distance is about 3.8 A  , we set   1  1 =2  1.245 A  and we calculate the gap penalty unit, , using  e 3:8 2 =41:245 2 ' 0:1: In other words, the gap penalty is derived directly from the physical length scale of one peptide unit. To penalize alignment gaps within regular secondary structures and to encourage gaps in loop regions, we set P i  2 if positions i and i1 were both called as , P i  for both , P i  /2 for both , and P i  otherwise. No gap extension penalty is used here, nor is any penalty applied for overhangs at the start or end of a chain. However, if a chain contains any physical breaks (we assume a chain break exists if the distance between consecutive C atoms exceeds 1.5  3.8 A  ), we set the gap opening penalty to zero for the two residues that border each break. Because the local Gaussian scoring function automatically generates low similarity scores for any residues near a physical break, this is sufficient to ensure that chains with missing segments are handled gracefully. By tracing through the DP matrix in the usual way, we obtain a global alignment in which each diagonal step corresponds to a matched pair of residues. An overall 'K-score' is then calculated aswhere ij  1 if residues i and j are matched, and ij  0 otherwise. Despite being a global structural similarity score, it is worth noting that this penalty-free score is 'pose-invariant' in that it does not depend on the orientations of the given proteins, and that for two perfectly matching backbones it will be numerically equal to the number of aligned residues. It is also worth noting that this score does not depend on the order in which the chains are given, and it does not involve any least-squares fitting calculations. Indeed, our technique of placing backbone peptide fragments in a canonical orientation at the coordinate origin costs only O(N) operations per protein. Populating the DP scoring matrix still requires ON 2  operations, although the form of Equations (6) and(7) allows this cost to be reduced to essentially just two exponential function calls per matrix element. For typical protein domains, we find that K local ij and K spatial ij are almost equally effective scoring functions. Therefore, by default, we use a combination of both scores with weights w l  0.5, w s  0.5. When superposing similar domains, the best path through the DP matrix is often near the main diagonal. Hence, in principle, many pair-wise similarity scores never need to be calculated. However, because the overall algorithm is so fast, we find that the main rate limiting step comes from reading the coordinate data into computer memory. Therefore, we currently do not apply any banding or lazy evaluation techniques to accelerate the DP calculation.
Calculating and optimizing 3D superpositionsGiven an alignment from the DP matrix, an initial 3D structural superposition is calculated by least-squares fitting () in which the pair-wise K-scores are used as fitting weights. This is then refined by one further cycle of fitting with uniform weights in which the weight for any pair of residues is set to zero if the distance between their C atoms exceeds 8 A . This often produces a visually acceptable superposition. We then optimize this initial superposition by applying further rounds of DP and fitting using a pose-dependent Gaussian score based on pairs of C distances:where a Cartesian grid is used to find residue pairs within the above distance threshold, and where no gap penalty is used in the DP matrix. This procedure allows some additional residue pairs (e.g. in loop regions) to be found and added to the alignment. In analogy to Equation (9), we then define a pose-dependent Gaussian superposition score asWhen using pose  1.4 A  , a gap penalty of  0.1, and uniform fitting weights, we find that applying just two rounds of Gaussian optimization is normally sufficient to give a satisfactory superposition with a low C RMSD. Sippl and Wiederstein (2012) recently described a similar Gaussian sum expression to rank alignments generated by their TopMatch algorithm.
Searching structural domain databasesTo allow efficient queries against structural databases such as CATH or SCOP (), we first pre-calculate and store the up-stream and down-stream fragment coordinates for every database residue (i.e. 6 C and 6 VA coordinates per residue). This allows a database to be searched rapidly using a single round of DP to calculate the K-score similarity between the query and each member of the database.In particular, " K AB  1 and " G AB  1 represent the perfect alignment and superposition of two identical backbones, respectively. Except for queries involving highly populated domain families such as the immunoglobulins, often only a relatively small number of database structures will superpose well onto the query. Hence, Kpax calculates 3D superpositions and G-scores only for the top 300 structures with the best K-scores.
Implementation details and availabilityKpax has been implemented in the C programming language using thread-safe programming techniques. Hence all database searches are multi-threaded by default. The program and some command scripts for building CATH and SCOP databases on Linux systems are available at http://kpax.loria.fr/. Databases of user-defined collections of PDB files may be built in a similar way. However, Kpax currently assumes that each PDB file contains just one chain, and it only considers the first model of any multi-model structures. PDB files of the structures used in the following sections are also available from the above address.shows an example of the SSE assignments obtained using the Kpax template-matching procedure (Section 2.4) in comparison with the SSEs calculated by DSSP () and Stride (). Supplementaryshows a colour version of this figure along with a further nine examples. These figures show that our algorithm often assigns quite similar and SSEs to Stride and DSSP, although there are often some small differences around the start and end positions of each SSE. Also, as expected, Kpax does not distinguish specific types of turn from random coil regions. Nonetheless, because the main aim here is to provide SSE-dependent alignment gap penalties, the above procedure allows the secondary structure environment of each residue to be estimated rather well and very rapidly without requiring external software.
RESULTS AND DISCUSSION
Comparing SSE assignments with Stride and DSSP
Comparison with CE, Sheba and TM-AlignAs a first test of the Kpax alignment algorithm, we compared its performance with CE, Sheba and TM-Align using the 10 'difficult' pairs of structures fromthat were first used as a reference benchmark by Shindyalov and Bourne (1998) and later by several other groups ().indicates that all of these algorithms can calculate good alignments for these structures, although the variation in some of the numbers of aligned residues and RMSDs suggests that these examples still appear to be difficult to align consistently. On the other hand, Supplementaryconfirms graphically that each algorithm gives rather similar 3D superpositions for each pair of folds. This demonstrates the difficulty of trying to compare different structure alignment algorithms directly using such raw numerical measures. Nonetheless, it is worth noting that the Kpax superpositions have RMSDs that are lower than CE and TM-Align in all cases, and which are generally comparable with, but slightly worse than, those of Sheba. Furthermore, the final column of(column 'Kpax-K')shows that using just one round of DP with the pose-invariant K-scores provides a fast way to calculate a good initial superposition. This shows that the K-score is identifying many equivalent residues for each pair of structures without requiring any iteration or least-squares fitting. To understand better the differences between the selected alignment methods, Supplementaryshows the TM-Align and Kpax overlays for this case. A large colour version of this image is shown in Supplementary. Visual inspection of these figures shows that Kpax produces a tighter overlay of the main-helix and the three large-strands in this pair than TM-Align.
Comparing the local and spatial scoring functionsTo investigate the strengths and weaknesses of the Kpax scoring functions, we compared the performance of Kpax's local, spatial and local-plus-spatial scores with TM-Align using six low sequence identity pairs of domains identified previously by Sippl and Wiederstein (2008) and six further pairs from Gerstein and Levitt (1998).shows that both TM-Align and the combined Kpax scoring function find full-length superpositions in all twelve cases (see Supplementary Figs S4 and S5 for images of the 3D superpositions). As in, Kpax produces alignments with lower RMSDs but also with lower numbers of aligned residues than TM-Align for the majority of cases. In terms of trading between RMSD and number of aligned residues, these results reaffirm the tendency for Kpax to produceStride, DSSP and Kpax for ubiquitin (PDB code: 1ubq). Supplementaryshows nine further examples superpositions towards the low RMSD, or 'tight', end of the number/RMSD performance metric. On the other hand,also shows that the individual local and spatial functions (tabulated 'Kpax-L' and 'Kpax-S', respectively) both fail to find the full alignment for the pair d1mtyb_/ d1ryta1, and the spatial function fails for one further pair (d1lt3a_/d1efya2). The first of these cases involves correctly matching the 4-helix bundle of rubrerythrin (d1ryta1) within the larger 9-helix bundle of the methyl monooxygenase hydroxylase (d1mtyb_). This is clearly difficult for both scoring functions because locally all helices will look the same, and because spatially the COMs of these different-sized domains will not closely coincide in a good overlay. Similarly, for the second pair, the different positions of their COMs with respect to their correctly aligned-barrels probably explains why the spatial scoring functions fails in this case. Nonetheless (and somewhat surprisingly for the helix bundle case, d1mtyb_/d1ryta1), these examples show that using the combined Kpax score appears to overcome the weaknesses in the individual scoring functions.The last column ofshows that, as before, Kpax generally gives quite similar overlays to TM-Align. However, the final example involving a pair of-propellers (SCOP codes: d4aaha_/d1gofa3) has a large RMSD difference of 11.6 A  between the Kpax and TM-Align superpositions.shows these superpositions graphically, and Supplementaryprovides a large colour version of the sameFrom close visual inspection of these figures, we believe the tighter Kpax alignment to be superior despite the smaller calculated number of aligned residues.
CATH database search comparisonAs a final and more demanding test, we compared the ability of Kpax, TM-Align and Yakusa to retrieve structural homologues from CATH using a diverse set of structural queries. We chose TM-Align because in our opinion (based on a preliminary comparison of several structural aligners) it is one of the best structure aligners available, and we chose Yakusa because it was specifically designed for rapid database searching. For this test,we selected 213 CATH families for which each family has at least 10 members, and we used CATH's representative structure for each family as the query. These families have an average of 30.7 members, and the query structures have an average of 160 residues. Here, we treat any structure having the same four-digit CATH code as the query as a 'positive' instance, and all other structures as 'negative' instances. We then measured the ability of each algorithm to retrieve structures having the same CATH code as the query by plotting the rate of true positives against the rate of false positives as the ranked list of matching structures is traversed. The area under the curve (AUC) of such receiveroperator-characteristic (ROC) plots may be used as a single objective measure of performance ().shows the aggregate ROC curves obtained for each algorithm by vertically averaging each set of 213 ROC curves. This figure shows that TM-Align gives the best overall performance, with an average AUC of 0.976, closely followed by Kpax with an AUC of 0.966. Yakusa gives an average AUC of 0.915. Closer examination of the individual curves (not shown here) indicated that the slightly better performance of TM-Align in this test comes from its ability to superpose more distantly related structures. For example, TM-Align achieves AUC 40.99 for 140 of the queries, compared with 102 for Kpax, and just 56 for Yakusa. On the other hand, Kpax is extremely efficient compared with existing structural alignment algorithms. For example, on a 2.8-GHz quad-core workstation, the above calculations took 46 h using TM-Align compared with 2.2 h for Yakusa, and just 22.5 min for Kpax. Furthermore, using only the pose-invariant K-scores without calculating superpositions takes just 13.5 min and gives an almost indistinguishable ROC curve to the superposition search. This corresponds to an average rate of 2980 structural alignments per second. In contrast, from the timing results of a previous study (see Table IV of), we estimate that performing the above database searches using CE, SSM, Dali and our own 3D-Blast algorithm would require approximately 286, 454, 1322 and 2012 CPU-hours, respectively. Thus, Kpax offers a useful way to keep ahead of the Red Queen. Although Kpax allows large domain structure databases such as CATH and SCOP to be searched rapidly, only a single global alignment and superposition is reported for each pair of compared structures. In the future, we would like to use Kpax to search the entire PDB directly. However, if the aim is to detect sub-structure matches e.g. when comparing a single small domain with large multi-domain structures, we expect that the spatial scoring function will be less useful than the local similarity score. Additionally, it will require further work to be able to handle arbitrary PDB files, which might contain multiple structures and conformations, and which would therefore require additional processing to collect and report multiple possible structural alignments.
CONCLUSIONWe have presented Kpax, a novel protein structure alignment and superposition algorithm that uses multiple C coordinate systems and a Gaussian peptide fragment scoring scheme to provide a sensitive structural similarity score. For the pairs of structures studied here, Kpax gives similar alignment statistics to Sheba, and it generally calls fewer aligned residues with lower RMSDs than CE and TM-Align. However, this does not imply low alignment quality. We have shown that the superpositions produced by Kpax resemble more closely those produced by TM-Align than those of CE and Sheba, and we have demonstrated that Kpax produces tighter superpositions of SSEs than TM-Align in several cases. We have also shown that Kpax may be used to perform fast and sensitive structural database searches. In our comparison with Yakusa and TM-Align using the CATH database, we showed that Kpax is faster and more accurate than the very efficient Yakusa algorithm, and it gives almost the same high level of fold recognition as TM-Align while being more than 100 times faster. Our timing estimates for CE, SSM and Dali predict even greater speed-ups with respect to these algorithms. These results demonstrate that Kpax is both fast and respectably accurate in comparison with the current state of the art. However, it still has some caveats. For example, it produces only a single rigid global alignment for each pair of compared structures, it cannot handle permutations or multi-structure PDB files, and its spatial scoring function is not well suited for comparing protein domains that differ significantly in size. Nonetheless, with the number of solved protein structures growing ever more rapidly, we believe the publicly available Kpax program will provide a useful tool for high throughput comparisons of 3D protein structures.
ACKNOWLEDGEMENTSWe thank the Associate Editor and three anonymous referees for several suggestions for improvements to the presentation of this article.
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
D.W.Ritchie et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Fast protein structure alignment at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
