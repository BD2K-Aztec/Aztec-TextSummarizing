Motivation: Haplotypes, defined as the sequence of alleles on one chromosome, are crucial for many genetic analyses. As experimental determination of haplotypes is extremely expensive, haplotypes are traditionally inferred using computational approaches from genotype data, i.e. the mixture of the genetic information from both haplotypes. Best performing approaches for haplotype inference rely on Hidden Markov Models, with the underlying assumption that the haplotypes of a given individual can be represented as a mosaic of segments from other haplotypes in the same population. Such algorithms use this model to predict the most likely haplotypes that explain the observed genotype data conditional on reference panel of haplotypes. With rapid advances in short read sequencing technologies, sequencing is quickly establishing as a powerful approach for collecting genetic variation information. As opposed to traditional genotyping-array technologies that independently call genotypes at polymorphic sites, short read sequencing often collects haplotypic information; a read spanning more than one polymorphic locus (multi-single nucleotide poly-morphic read) contains information on the haplotype from which the read originates. However, this information is generally ignored in existing approaches for haplotype phasing and genotype-calling from short read data. Results: In this article, we propose a novel framework for haplotype inference from short read sequencing that leverages multi-single nucleotide polymorphic reads together with a reference panel of haplo-types. The basis of our approach is a new probabilistic model that finds the most likely haplotype segments from the reference panel to explain the short read sequencing data for a given individual. We devised an efficient sampling method within a probabilistic model to achieve superior performance than existing methods. Using simulated sequencing reads from real individual genotypes in the HapMap data and the 1000 Genomes projects, we show that our method is highly accurate and computationally efficient. Our haplotype predictions improve accuracy over the basic haplotype copying model by $20% with comparable computational time, and over another recently proposed approach Hap-SeqX by $10% with significantly reduced computational time and memory usage.
INTRODUCTIONHumans are diploid organisms with two copies of each chromosome, one inherited from the father and the other from the mother. The two copies are similar to each other and only differ at a small fraction ($ 0:1%) of sites. Most of the variation is contained at single nucleotide polymorphic (SNP) sites. The sequence of alleles on each chromosome is referred to as the haplotype. Haplotype information is centrally important for a wide variety of applications, including association studies and ancestry inference (). Unfortunately, standard methods for probing genetic variation are able to collect only genotype information but not haplotypes. A large number of computational methods, referred to as haplotype phasing approaches, have been proposed to infer haplotypes from genotypes. The most successful methods use a set of reference haplotypes to build a probabilistic model of the haplotypes in the population (). Using a population genetics model for the haplotype distribution, these models predict the most likely haplotype data that can explain the observed genotypes. Rapid advances in high-throughput sequencing (HTS) technologies provide new opportunities for haplotype phasing methods. HTS yields short segments of the DNA (reads) where each read originates from one of the pair of chromosomes. Therefore, all the alleles in this read are from the same haplotype. Although reads that cover multiple SNPs (multi-SNP reads) could be used to improve haplotype inference, existing methods generally ignore this information, partially owing to computational difficulty associated with modeling such reads. Several methods have been proposed to predict haplotypes directly from the reads. These methods, referred to as haplotype assembly methods, use overlapping reads to construct the haplotype (). The most commonly used objective function for haplotype *To whom correspondence should be addressed. assembly is the minimum error correction (MEC). The MEC objective function aims at finding the minimum number of edits such that the reads can be partitioned into two disjoint sets, and each set of reads originates from one of the haplotypes. However, as these methods do not use the information in the reference haplotype panel, they significantly underperform standard phasing methods that ignore read information but use reference panel (). Recently, one of these methods has been extended to use the reference (). Unfortunately, this method has prohibitive memory and time requirements, thus making it unfeasible for moderate to large datasets. Here, we propose a novel approach called Haplotyping with Reference and Sequencing technology (HARSH) for haplotype phasing. We use a probabilistic model to incorporate the multiSNP read information together with a reference panel of haplotypes. We use an efficient Gibbs sampling method to find sample from the posterior distribution. This algorithm has the advantages of being computationally efficient, scalable in memory usage and accurate in genotyping and phasing prediction. We evaluate our method on simulations from real haplotypes from the HapMap project. At 1 coverage, HARSH gives $10% improvement in terms of total error rate compared with standard phasing approaches that do not use the multi-SNP read information, thus showing the benefits of modeling multi-SNP reads. We also evaluate HARSH and the basic model for varying coverage and read length, showing the benefits of our approach in higher coverage and longer read length. Additionally, we test our method on simulations starting from real sequencing data of 1000 Genomes project, where the density of SNPs is much higher than that in HapMap data. Through extensive simulations we show that the gain in performance of our approach over existing models extends to realistic read lengths (e.g. 100400 bp), making our approach readily applicable to existing sequencing datasets. With recent works showing that short read sequencing can dramatically increase association power in genome-wide association study over genotyping arrays (), we expect our approaches to further increase power in genome-wide association study by increasing accuracy in genotype calling and phasing from short read data.
METHODSThe best performing approaches for haplotype inference rely on Hidden Markov Models (HMMs) for describing the distribution of haplotypes in the population. These approaches generally ignore multi-SNP information in the reads, thus implementing the model as a linear chain graph. The model structure becomes complicated when we are considering multiSNP information, as it is not trivial to perform standard operations (e.g. Viterbi decoding) to a non-linear chain graph. Previous methods [e.g. Hap-SeqX ()] have attempted to extend the Viterbi algorithm to the complex graph induced by multi-SNP reads and reference haplotypes, but the approach is expensive in both time and memory usage. As opposed to previous approaches, in this work, we use a Gibbs samplerbased method for fast inference. The main advantage of this approach is that the computations are efficient and it can achieve the optimal or close to optimal solution in a feasible amount of time. However, all other current methods are either not optimal or not practical in terms of computational time or memory usage.
Gibbs sampler preliminariesA Gibbs sampler serves as the basis for our method. We first introduce the general idea of Gibbs sampling before we use it to solve the haplotype problem. Consider the following distribution typically used to perform optimization in graphical models:where X  x 1 , x 2 ,  sx d  is a d-dimensional vector and Z is a normalization factor. The function specifies the edge potential for two variables with an edge between them. We would like to collect samples of X based on this distribution P(X). Gibbs sampler is a special case of Monte Carlo Markov Chain method (), which is guaranteed to converge to the equilibrium distribution after sufficient burn-in rounds. In each round, it randomly samples one variable x i based on the conditional probability Px i jx i  when all other variables x i  x 1 ,. .. , x i1 , x i1 ,. .. , x d  are fixed. Formally, this conditional probability can be written as follows:A more complete treatment of Monte Carlo Markov Chain is available in ().
Haplotype assembly with sequencing dataSequencing technologies provide us with a set of reads, each of which is a short fragment from one of the chromosomes. Haplotype assembly aims to assemble the entire haplotype based on only read information. An illustrative example is given in. We can formalize this problem as follows. Suppose that we only consider L biallelic SNPs and M reads. Each read is represented by X j  f1, 1, 0g L , where 0 stands for unobserved SNP in jth read, 1 and 1 stand for observed minor and major alleles, respectively.. An illustration of haplotype inference problems. The two chromosomes for an individual are unknown to us at first. Sequencing technology produces a set of reads, each of which originates from one of the two chromosomes. We also have a set of reference haplotypes, which are from the same population as the donor. Haplotype assembly aims to assemble the two donor haplotypes by only using the read information. Haplotype phasing problem aims to phase the two haplotypes by mosaic copies from the reference haplotypes. However, our approach HARSH takes into account both read information and reference panel for more accurate haplotype inference Because the homozygous site does not affect the haplotype phasing, we only consider heterozygous sites. Therefore, the objective is to find a sequence of haplotype and its complementary fh, hg where h   h 2 f1, 1g L , to minimize the total number of flipped loci within reads, such that every read can be perfectly assigned to one of the haplotypes. Another necessary variable for the model is the read origin indicator r j 2 f1, 1g. If r j  1, the jth read is assumed to have been generated from haplotype h, and if r j  1, the jth read is from the complementary haplotype h. We assume the read generation process is as follows. First, we randomly pick one of the haplotypes (h, h) with equal probability, and then sample the read starting position from one of the L possible positions in the genome. If we consider the read generation processing is error free, then we have x ij  h i r j. However, if the read generation process is error-prone and " indicates the rate of sequencing error then with probability 1  ", we have x ij  h i r j , and with probability ", we have x ij  h i r j. An illustrative example is given in. We can formalize the connection between the haplotypes and read origin variables into the following probabilistic distribution. For each possible values of the haplotypes and read origin variables, we can calculate its probability as follows:PR, H; Xand the variables R  r j  M j1 , H  h i  L i1 and X  x ij  ij are vectors and matrix composed of scalar variables r, h and x. The variable Z is a normalization constant to ensure P R, H PR, H; X  1. The functions and specify edge potentials that favor h and r to be of equal values and opposite values, respectively. The model parameter controls the 'heat' of the probabilistic model. Generally speaking, the probability distribution is smoother when is small and sharper when is large. LEMMA 1. The maximum a posteriori (MAP) assignment of (2) corresponds to the MEC haplotype for any 50:5. PROOF. We can prove by constructing the MEC haplotype from MAP assignment. Let H  and R  denote the MAP assignment of our probabilistic model, and the corresponding probability calculated from(2) will bewhere n is the number of edges getting potential ln1   and m is the number of edges getting potential ln based on the configuration H  and R . As ln1  "4 ln " for 50:5 and the number of edges is fixed, this MAP assignment H  and R  is actually minimizing the number of edges getting potential ln. We can use this haplotype H  and flip every read bit corresponding to the edge getting potential ln ". The resulting MEC score for H  will be m, which is minimized. Suppose that there exists another haplotype H 0 with MEC score m 0 5m. It suggests that we can flip only m 0 read bit then all the reads will be perfectly assigned to one of the haplotypes. We keep those assignments into the variable R 0. Thus, we should haveBy definition, m 0 5m; thus, PH 0 , R 0 ; X4PH  , R  ; X, which contradicts the fact that H  and R  is the MAP assignment maximizing the configuration probability. By this contradiction, we can conclude that there does not exist H 0 and R 0 with MEC score m 0 5m.
Haplotype phasing with sequencing data and referencePH, R, S; Xwhere we have four edge potential functions. The functions and are defined similarly as in (2) except that there would be no penalty if the read is assigned by r to the other haplotype.The edge potential function specifies the 'haplotype copying', which is motivated that the predicted haplotype is a mosaic of referencef1,  1g stands for the haplotype. The variable r 2 f1,  1g stands for whether the read is from haplotype h or the complementary h haplotypes with a small number of differences. In this case, the predicted haplotypes are similar to reference haplotype s 1 and s 2 at position i.where G ij stands for the jth allele in ith reference haplotype. Thus, G s 1 i , i stands for the ith allele in s 1 i th reference haplotype. Moreover, we use the following function to model the transition probability in haplotype copying model ().where i  4N e r i and r i is the per generation genetic distance between site i and site i  1, and N e is a constant. This probabilistic model provides us a disciplined way to infer the most probable haplotype given a set of reads and a set of reference haplotypes. It extends the haplotype copying model () from genotype input to sequencing data input. It also extends the haplotype assembly problem in previous section to a more general case where the reference panel can be used to improve the phasing. We are then able to design efficient sampling approach to find the most possible configurations of H, R and S that maximize the probability given in Equation (3).
Efficient samplingHaplotype assembly without reference. The bipartite structure insuggests an efficient procedure for sampling. For fixed one layer of the bipartite graph, the variables in the other layer will be independent on each other. Thus, the conditional probability in Equation (1) of Gibbs sampler can be significantly reduced. Formally, following the standard procedure of Gibbs sampling, we can sample haplotype from the conditional probability for fixed read origins. The sampling ratio i  Ph i  1jR can be calculated as follows:Similarly, we can also do a similar Gibbs sampling step for read origin for fixed haplotype. The sampling ratio j  Pr j  1jH can be calculated as follows:The complete sampling algorithm for haplotype assembly is shown in Algorithm 1. As default, we use 10 000 rounds for sampling. Haplotype phasing with reference. The sampling for haplotype phasing with both sequencing data and reference from the graph inis more challenging. However, we can still take advantages of the special structure of the graph and perform efficient sampling procedure. Following the idea of Gibbs sampler, we will alternatively (i) sample read origin R for fixed haplotype H and reference assignment S; (ii) sample S for fixed R and H; (iii) sample H for fixed R and S. The step (i) is similar with that in haplotype assembly. Formally, the sampling ratio Pr j  1jH, S for read origin can be calculated byAlgorithm 1 Sampling Algorithm for Haplotype Assembly 1: Randomly initialize haplotype H. 2: For fixed haplotype H, sample read origin R. For probability j , we get r j  1, and for probability 1  j , we get r j  1, where the ratio can be calculated as in (5).3: For fixed read origin R, sample haplotype H. For probability i , we get h i  1, and for probability 1  i , we get h i  1, where the ratio can be calculated as in (4). 4: Repeat steps 2 and 3 for sufficient rounds until equilibrium. 5: Collect samples by repeating steps 2 and 3, and output the one with highest probability. The step (iii), sampling of haplotype H for fixed read origin R and reference assignment S is a straightforward extension from Equation (4). The modification is based on the extra edge between reference penal variables S and haplotype H. Formally, the sampling ratio Ph 1 i  1jR, S for the first haplotype can be calculated byThe sampling ratio Ph 2 i  1jR, S is similar with Ph 1 i  1jR, S. Similarly, we can obtain the sampling ratio for the second haplotype as follows: 2 i  1 1  1 8. A graphical model for haplotype phasing with reference. The variables h 1 and h 2 stand for the first and second haplotypes. The variables r i  f1, 1g specify whether the read comes from the first haplotype or second haplotype. The variable s 1 and s 2 specify which haplotype in the reference is generating the haplotype h 1 and h 2 , respectively whereThe step (ii), sampling for the haplotype reference panel variables S for fixed read origin R and haplotype H is challenging. The difficulty comes from the dependency between the variables s i and s i1 , and the large number of possible values for each s i. Note that unlike the binary variables h and r, the variable s i 2 f1, 2,. .. , Ng, where N is the number of reference haplotypes. Thus, straightforward Gibbs sampler would be inefficient in this case. To tackle this computational challenge, we resort to the following Markov chain sampling procedure (). The joint distribution over all variables in S can be written as follows:Sampling directly from PSjH is still tedious. However, we can convert the PSjH to multiplication series of probability functions as follows:Thus, we can compute the normalization factor Z  P sL2S V L1 s L  efficiently using dynamic programming, and then we can compute the marginal probability Ps L , H  V L1 s L =Z. Moreover, we can backward compute Ps i js i1 , H similarly. Note that a naive implementation of this step would result in a complexity of quadratic in the number of reference haplotypes. We take advantage of the symmetry in the haplotype coping model to reuse computation to achieve runtime linear in the number of reference haplotypes. An outline of the sampling algorithm for haplotype phasing with sequencing data and a reference panel is given in Algorithm 2. As default, we use 10 000 rounds of sampling.Algorithm 2 Sampling Algorithm for Haplotype Phasing 1: Randomly initialize haplotype H 2: For fixed haplotype H, sample read origin R using sampling ratio j in (6). 3: For fixed haplotype H sample haplotype reference S following Markov chain sampling procedure described after (9). 4: For fixed read origin R, and haplotype reference S, sample haplotype H using sampling ratio i in (7). 5: Repeat steps 2, 3 and 4 for sufficient rounds until equilibrium. 6: Collect samples by repeating steps 2, 3 and 4. Output samples with highest probability.
EXPERIMENTAL RESULTS
Datasets and experimental settingsWeWe evaluate our method using a leave-one-out procedure. In each round, we infer the haplotype for one individual using simulated sequencing data and the haplotypes of the other 59 individuals as reference panel. This procedure is repeated 60 times and all the evaluation metrics are averaged. The reads are simulated uniformly across chromosome 22 for a given coverage. The read length in each end of a pair-end read is fixed but the gap between the two ends follow a normal distribution with fixed mean and standard deviation. Errors are inserted in the read at a rate ". We evaluate our method HARSH using the standard metric for genotyping and phasing accuracy: genotyping error rate and switching error rate. The genotyping error rate is the proportion of wrongly predicted genotypes, and the switching error is the proportion of switches in the inferred haplotypes to recover the correct phase in an individual. The total error rate is the sum of genotyping error rate and switching error rate. We also use percentage improvement when comparing two methods. The percentage improvement is computed as the error rate difference between two methods normalized by the error rate of baseline method. For example, suppose that HARSH has error rate x and baseline method has error rate y, the improvement of HARSH over the baseline method would be y  x=y. We fixed the parameters  1, !  0:002 and  0:01 for all our experiments. From our experience, the performance of the proposed method is not sensitive to parameter tuning. Using from 1 to 10 and ! from 0.001 to 0.005 does not affect the performance significantly. The sequencing error  0:01 is standard sequencing error rate. All experiments are performed in a cluster machine where each node has 816 cores 3.0 GHz CPU and 116 GB memory. Jobs are submitted in a parallel manner but each job uses only one node.
HapMap simulationsWe use HapMap dataset to evaluate our method HARSH. We compare our method with three other state-of-the-art methods: the HMM at the core of the IMPUTE method (), BEAGLE () and HapSeqX (). Because IMPUTE does not support haplotype phasing for uncovered SNPs, for a fair comparison, we re-implemented the basic HMM model of the IMPUTE v1.0, which uses the pre-defined genetic map information for transition probability. We will refer to our implementation of the HMM model in IMPUTE method as IMPUTE*. In our modified version, we use the read count for each SNP as input to IMPUTE* method. The likelihood of read count from genotype is used as the emission probability for the HMM model. Then the Viterbi algorithm is used to decode two paths from the reference panel, which are most likely to generate the read counts in each SNP. The two paths in reference panel also give the two predicted haplotypes. Because the latest implementation of IMPUTE () is not able to phase, we also compared our approach with BEAGLE 3.3.2 (), a widely used approach for haplotype phasing and imputation. We first use the HapMap dataset to show that haplotype assembly without a reference panel will underperform haplotype phasing with a reference panel. The main reason is that there are not enough long reads covering all continuous heterozygous SNPs. Thus, haplotype assembly cannot do more than random guess between two continuous heterozygous SNPs if there is no read spanning them. We can compute a lower bound of the number of switches for haplotype assembly as K=2 where K is the number of those gaps, assuming the MEC score to be zero. For pair-end reads with fixed length 1000 bp mean and 100 bp standard deviation, we evaluate our method using six levels of sequencing coverages: 1, 2, 4, 6, 8 and 10. As shown in, higher coverage does not help haplotype assembly to achieve similar performance than haplotype phasing methods. At fixed coverage 4, we simulated pair-end reads with 1000, 2000, 3000 and 4000 bp in each end. As shown in, we can observe that the lower bound of haplotype assembly achieves similar performance as haplotype phasing only under the unrealistic read length 4000 bp. Also, at 4 coverage, we can observe that our method can improve $44% over BEAGLE and $37% over IMPUTE in terms of numbers of switches. For simulated pair-end reads with 1000 bp for each end at 1 coverage, only 32% reads contain one SNP and $26% of the reads contain more than three SNPs. On average, every read contains around 2.8 SNPs. Following the procedure similar to that of He and Eskin (2013), we divide the chromosome into overlapping chunks containing 1200 SNPs each and run our method on each chunk independently. The final haplotypes are then constructed by stitching together the haplotypes from each chunk. Chromosome 22 is divided into 36 chunks. The total error rate for both IMPUTE* and HARSH are shown in. We can observe from the figure that HARSH consistently performs better than IMPUTE* across all 36 chunks. The average improvement over IMPUTE* is 7.6%. We then concatenated those haplotype chunks by minimizing the mismatches in the overlap region between two adjacent chunks. After concatenation, the overall error rate for HARSH is 4.01% for chromosome 22, compared with 4.42% for IMPUTE*. The overall improvement is 9.3% over IMPUTE*. We compare HARSH with a previous method for combining multi-SNP reads with a reference panel, Hap-SeqX (). Hap-SeqX is an approximation to the dynamic programming approach of the Hap-Seq method (), which optimizes a similar objective function to HARSH. Hap-SeqX only searches a fraction of the search space compared with Hap-Seq by only storing the top values at each state. However, Hap-SeqX is still an expensive method in both time and memory usage. In this experiment, we use the default parameters of Hap-SeqX, where t  0:01 specifies that the algorithm saves the top 1% of values for each state. On addition, Hap-Seq and Hap-SeqX, unlike HARSH, can only handle up to three SNPs in a read and split reads containing more SNPs into multiple reads. The performance comparisons are shown in. HARSH and IMPUTE* have similar running time. HARSH takes $10 min compared with IMPUTE* 5 min on chromosome 22. Both these methods compare favorably with Hap-SeqX, which takes 5 h for the same dataset. Cross validation of 60 individuals would be prohibitive for Hap-SeqX. Thus, we compare all these three methods using only the first individual in HapMap dataset. The results averaged more than 36 chunks. We can see that Hap-SeqX improves by $12.53% from the baseline method IMPUTE*, and HARSH significantly improves by 21.34% from IMPUTE*. We conducted significance test (paired-sample t-test) on the improvement of HARSH over Hap-SeqX and IMPUTE*. The test results show that HARSH significantly outperforms both Hap-SeqX and IMPUTE* with P51  10 3 and P51  10 7 , respectively. Overall, the comparison shows that HARSH is the most accurate and practical method among existing methods. To fully evaluate the performance of our method, we apply our method to cases with different coverages and read lengths. For pair-end reads with fixed length 1000 bp mean and 100 bp standard deviation, we evaluate our method using six levels of sequencing coverages: 1, 2, 4, 6, 8 and 10. The result is shown in. As expected, the performance improvement of HARSH over BEAGLE and IMPUTE* becomes more significant when the coverage increases. The reason we expect this is that the higher the coverage, the larger number of reads that, we show the genotyping and switching error rate of HARSH and IMPUTE* method for different coverages. It can be observed that both genotyping error and switching error are significantly reduced by HARSH over BEAGLE and IMPUTE*. It is also worth mentioning that 4 seems to be the best choice in terms of the compromise between the cost of coverage and achieved accuracy. The coverage 4 gives 0.28% genotyping error and 0.62% switching error. However, the improvement of higher coverage than 4 is limited. We also evaluate HARSH with different read lengths. At fixed coverage 4, we simulated pair-end reads with 1000, 2000, 3000 and 4000 bp in each end. The results are shown in. It is not immediately intuitive why the genotyping error rates for BEAGLE, IMPUTE* and HARSH increase when the read length increases. A possible reason is that longer reads for a fixed coverage result in fewer total reads and larger gaps without any coverage. In other words, longer reads result in less random read bits across the chromosome. An extreme example is that the gap will be half of the genome on average if the read length is equal to the genome size and coverage is 1. Sequentially, larger gap where no reads cover will potentially harm the imputation and haplotype phasing accuracy. However, we can still see that the performance gap between BEAGLE or IMPUTE* and HARSH is enlarged while the read length increases. This is attributed to the ability of HARSH to leverage the multi-SNP information in longer reads. In, we show the improvement of HARSH over BEAGLE and IMPUTE*. The improvement is basically from the reduced switching error, which is reduced from 0.62 to 0.48% by HARSH but not by IMPUTE*. The genotyping error for both methods increases at the same pace because of the larger gaps caused by longer reads. The error rates for BEAGLE, IMPUTE* and HARSH increase from 0.59 to 0.79%, from 0.56 to 0.85% and from 0.28 to 0.48%, respectively, when the read length increases from 1000 to 4000 bp. But HARSH consistently performs better than BEAGLE and IMPUTE even while the genotyping error rate is increasing.
1000 Genomes simulationsThe 1000 Genomes project is an ongoing project that uses HTS technology to collect the genetic variant data across many individuals with the goal of characterizing rare variants, which are not present in HapMap. This provides us the opportunity to evaluate our method using simulations that will realistically capture the distributions of rare variants and more accurately reflect a tubal performance. We simulate realistic paired end reads, which have 100 bp for each end, and a gap size following a normal distribution with 100 bp mean and standard deviation of 10 bp. Only 22% reads contain only one SNP and $55% reads contain more than three SNPs. On average, every read covers around 3.1 SNPs. Following the same settings as what we did for HapMap data, we test HARSH for different coverages and read lengths. The results for coverage 1, 2, 4, 8, 16 and 32 are shown in. We observe that the error rate does not further drop after coverage 8. At coverage 8, the improvement of HARSH over IMPUTE* is 29% from 0.021 to 0.015 in terms of error rate. Thus, for fixed coverage 8, we simulate pair-end reads with 100, 200, 300 and 400 bp in each end. The results are shown in. We observe that, HARSH, unlike IMPUTE*, benefits from using longer reads, as it contains more multi-SNP reads than shorter reads. Thus, as expected, the performance gap between IMPUTE* and HARSH increases as the read length increases. However, in, we do not see that the error rate increases when the read length increases as in. A possible reason is that the SNPs are much denser in 1000 Genomes data than HapMap data, and we simulated much shorter reads for 1000 Genomes data. Thus, the gap caused by 400 bp read length would be much shorter than previous 4000 bp read length for HapMap dataset. The reference haplotype panel could well take advantage of Linkage Disequilibrium effect to recover those gaps. Therefore, the error rate for IMPUTE* keeps almost the same for different read lengths but our method HARSH reduces the error rate by incorporating more multi-SNP read information when the read length increases.Note: Read length is fixed to be 1000 bp.Haplotype phasing plays an important role in a wide variety of genetic applications. Although it is possible to determine haplotypes using laboratory-based experimental techniques, these approaches are expensive and time-consuming. Recently,were able to generate the complete phased sequence of a Gujarati individual using a Fosmid library. Unfortunately, this method is not easily scalable to phasing more than one individual. Thus, the need for a practical computational method for haplotype phasing remains. We have presented HARSH, an efficient method that combines multi-SNP read information with reference panels of haplotypes for improved genotype and haplotype inference in sequencing data. Unlike previous phasing methods that use read counts at each SNP as input, our method takes into account the information from reads spanning multiple SNPs. HARSH is able to efficiently find the likely haplotypes in terms of the marginal probability over the genotype data. Using simulations from HapMap and 1000 Genomes data, we show that our method achieves superior accuracy than existing approaches with decreased computational requirements. In addition, we evaluate our method as function of coverage and read length, showing that our method continues to improve as read length and coverage increases.Note: Coverage is fixed to be 4.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
W.-Y.Yang et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Current haplotype assembly methods mainly focus on de novo assembly, which uses short reads as the only information source. This is partially owing to the complexity of extending the method to the scenario of assembly using reference. On the other hand, current haplotype phasing methods only use the reference panel and genotype likelihood in each SNP but ignore the multi-SNP information in the reads. We aim to use both the reference panel and sequencing data to perform haplotype phasing as shown in Figure 1. Formally, suppose that we are only considering L biallelic SNPs, M reads and N reference haplotypes. Each read is represented by X j  f1, 1, 0g L , where 0 stands for unobserved SNP in jth read. The objective is to find two haplotypes, H  fh 1 , h 2 g, where h 1 , h 2 2 f1, 1g L. We want to find the two haplotypes with small number of inconsistent loci with reads, as well as more consistent with reference haplotypes. We use another set of variables, S  fs 1 , s 2 g, where s 1 , s 2 2 f1, 2,. .. , Ng L , to stand for the assignment of each loci to reference haplotypes. We also need a set of variables R  fr 1 , r 2 ,. .. , r M g, where r i 2 f1, 1g stands for the haplotype that each read originates from. An illustrative example of the graph structure is given in Figure 3. Similar to the previous section, we can formalize the connection between the three variables H, R and S into the following probabilistic distribution. For each possible values of H, R and S, we can calculate its probability as follows:
Leveraging multi-SNP reads from sequencing data at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
