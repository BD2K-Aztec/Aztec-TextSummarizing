Motivation: Mass spectrometry allows sensitive, automated and high-throughput analysis of small molecules such as metabolites. One major bottleneck in metabolomics is the identification of 'unknown' small molecules not in any database. Recently, fragmentation tree alignments have been introduced for the automated comparison of the fragmentation patterns of small molecules. Fragmentation pattern similarities are strongly correlated with the chemical similarity of the molecules, and allow us to cluster compounds based solely on their fragmentation patterns. Results: Aligning fragmentation trees is computationally hard. Nevertheless, we present three exact algorithms for the problem: a dynamic programming (DP) algorithm, a sparse variant of the DP, and an Integer Linear Program (ILP). Evaluation of our methods on three different datasets showed that thousands of alignments can be computed in a matter of minutes using DP, even for 'challenging' instances. Running times of the sparse DP were an order of magnitude better than for the classical DP. The ILP was clearly outperformed by both DP approaches. We also found that for both DP algorithms, computing the 1% slowest alignments required as much time as computing the 99% fastest.
INTRODUCTIONMetabolomics deals with the identification and quantification of small compounds below 1000 Da, and has received increasing interest during the last years (). All organisms, especially plants, fungi and bacteria, synthesize many different metabolites and a large portion of them is still unknown (). The genome sequence usually does not reveal information about metabolite structure, as it does for protein structure. Newly identified metabolites often serve as leads in drug design (), in particular for antibiotics. For a high-throughput analysis of metabolites and other small molecules, mass spectrometry (MS) is the predominant technology (). Nuclear magnetic resonance reveals more information about the analyte, but is inapplicable for high-throughput analysis due to its low sensitivity. MS can be coupled with a separation method (gas chromatography, liquid chromatography or capillary electrophoresis) to analyze complex mixtures like cell extracts (). To obtain information beyond the compound mass, the analyte is usually fragmented, and fragment masses are recorded. Typically, collision-induced dissociation is combined with liquid chromatographyMS, whereas gas chromatographyMS uses electron impact fragmentation. The first attempt to develop computational methods for analyzing fragmentation spectra of * To whom correspondence should be addressed. metabolites has been the DENDRAL project in 1965 (). But the project was stopped after it became clear that automated structure elucidation using MS data could not be achieved at that time. Today, data analysis is still the major bottleneck in metabolomics (). Manual data analysis requires time and deep knowledge of the underlying chemistry (). Due to the limited reproducibility of the data, even library searches are difficult (). Additionally, spectral libraries are vastly incomplete. Methods for de novo sequencing of non-ribosomal peptides have recently been developed. But these methods rely on the fact that the analytes are structurally restricted polymers with predictable fragmentation. When manually analyzing tandem MS spectra, chemists try to annotate fragmentation peaks and identify relations between fragments, resulting in fragmentation pathways. This approach has been automated by. They calculate hypothetical fragmentation trees solely based on the MS data. Fragmentation tree nodes are annotated with the molecular formula of the fragments, whereas edges represent losses. To find a fragmentation tree that shows maximum agreement with the measured data, we search for a tree of maximum edge weight, comparable to prize-collecting Steiner trees (). Only lists of common and implausible losses are required as expert knowledge about fragmentation mechanisms. In, experts evaluated the calculated fragmentation trees and confirmed their excellent quality. Recently, methods to calculate fragmentation trees from multiple MS and gas chromatography MS data have been developed (). MS analysis of similar compounds results in similar fragmentation trees.proposed local tree alignments for the automated comparison of fragmentation trees and showed that this method is superior to spectral comparison. Fragmentation tree alignments even allow for inter-dataset comparisons for datasets measured on different instruments (). A tree alignment may contain matches, mismatches, insertions and deletions, but respects the structure of the two trees. Fragmentation tree similarity is defined via edges (representing losses) and nodes (representing fragments). A local tree alignment contains those parts of the two trees where similar fragmentation cascades occurred. Tree alignments were introduced byand can be applied for RNA secondary structure comparison (). RNA structure trees are ordered, that is, the children of any node have a fixed order. In contrast, fragmentation trees are unordered, as there cannot exist any sensible ordering for the sub fragments of some fragment. In this respect, fragmentation trees are more similar to phylogenetic trees than to RNA structure trees. Whereas efficient, polynomial-time algorithms exist for the alignment of ordered trees, the alignment of unordered trees is computationally hard, namely MAX SNP-hard (). This implies that there exists no). In case both trees have fixed maximum out degree, an optimum alignment can be computed via dynamic programming (DP) in polynomial time (). In comparison, computing the edit distance between two unordered trees remains MAX SNP hard even for bounded degrees (). An informal algorithm for aligning fragmentation trees was presented by, and join nodes were introduced to account for missing nodes in one of the trees compared. Missing nodes result from missing peaks in one of the spectra.do not give a correctness proof or running time analysis for the algorithm. As related work, we mention the TreeConstrained Bipartite Matching problem where either a node or any of its descendants may be part of the matching; this problem is also APX-hard (). Our contribution: we modify the tree alignment algorithm fromfor edge similarities and local alignments, and analyze its running time. We then show how to integrate join nodes without increasing the worst-case running time. Next, we modify the algorithm to allow for sparse DP, a technique common in RNA folding (). This does not only decrease the practical memory requirements of the method but, more importantly, also severely decreases running times in practice. Furthermore, we present an Integer Linear Program (ILP) for the fragmentation tree alignment problem, as ILPs often solve NP-hard problems swiftly in practice. We then evaluate all methods on real-world data, and find that the sparse DP approach dominates the classical DP, resulting in an 11-fold speed-up for one dataset. Somewhat unexpectedly, the ILP is clearly outperformed by both DP approaches.
ALIGNING FRAGMENTATION TREESLet T = (V ,E) be a tree; the elements of V are called nodes. In the following, we assume all trees to be arboreal, that is, all edges in E are directed away from some root node. By uv, we denote a directed edge from node u to node v. Let p(v) be the parent node of some node v. A fragmentation tree is a tree T = (V ,E) together with an edge labeling : E  L. In more detail, nodes V correspond to fragments of a compound, whereas the labels L are (neutral or radical) losses: that is, both are molecular formulas over some fixed alphabet of elements (). Formally, molecular formulas are compomers or multi sets. The children of any node of a fragmentation tree are intrinsically unordered, as there is no sensible way to order the sub fragments of some fragment. In our presentation, we will not consider the molecular formulas of fragments, and concentrate on comparing losses only. As we will see below, comparing fragments instead or comparing both simultaneously requires only minor modifications. Seefor two examples of fragmentation trees. We introduce some notation used throughout this article: Letbe the two trees we want to align. We sometimes call T 1 the left tree and T 2 the right tree. Let C(v) denote the children (nodes) of any node v in T 1 or T 2. In the following, we usually assume that u is a node of T 1 , and v a node of T 2. For i = 1,2, let n i := |V i | be the number of nodes in T i , and let d i be the maximum out degree in T i. These maximum out degrees will be of particular interest to us, as the running time of our DP grows exponentially in d 1 ,d 2. Let  = min{d 1 ,d 2 } and = max{d 1 ,d 2 }.introduce a similarity function  : LL  R for pairs of losses (molecular formulas). We do not repeat the details here, but note that this implies a similarity function  : E 1 E 2  R between edges of the two trees T 1 ,). They also introduce a similarity function for fragment molecular formulas, which induces a similarity function between nodes of the two trees. Furthermore, they also extend the definition of tree alignments by introducing a join operator [see(In the left tree, the fragment after loosing H 3 N is missing (dashed edges and node), whereas the fragment after further loss of C 2 H 2 is observed. To account for missing fragments, we introduce the join operation. It allows to align the two successive losses H 3 N and C 2 H 2 in the right tree to a single loss C 2 H 5 N in the left tree (dotted edges). Fragments may be missing because the corresponding peak was not detected, for example p 1 by adding the corresponding losses (
Fast alignment of fragmentation treesThis means taking the sum of the respective compomers or the additive union of the corresponding multisets. We then assign a similarity between p 1 and any edge e 2 of). Analogously, we can define a similarity for paths of length two in T 2. Obviously, this can be generalized to paths of arbitrary lengths but here, we will limit ourselves to paths of length two. For joining nodes in the alignment, we assume homogeneous join costs: The penalty for joining a node is  join  0, independent of the node or edge that we want to join. Formally, this allows us to focus on the important aspects of our algorithms, and omit some technical details. Practically, we currently see no biologically reasonable way to assign different scores to different join nodes, as these usually correspond to the non-detection of a peak in one of the mass spectra. Let T 1 ,T 2 be two trees. We define a global alignment A of T 1 ,T 2 as follows (): A is a tree where nodes are labeled with pairs from (V 1 {})(V 2 {}). Here, '' is the gap symbol [see(a)]. If we restrict labels of A to the first coordinate and contract all edges that end in a node labeled '', we end up with the tree T 1 ; if we do the same for the second coordinate, we end up with the tree T 2. (In fact, we have to replace the nodes of the restricted trees by their labels, we omit the simple technical details.) We say that A is a local alignment if the trees originating from contracting gap edges are induced subtrees of T 1 and T 2 , respectively. Different from, we want to score an alignment based on the edges of the two trees. To this end, for any node a of A but the root, let e 1 (a) be the unique edge in T 1 that ends in the first coordinate of the label of a, and let e 2 (a) be the unique edge in T 2 that ends in the second coordinate of the label of a. In case no such edge exists, we assume e 1 (a) = '' or e 2 (a) = '', respectively. Now, we define the score of A as non-root node a of AWe define  (T 1 ,T 2 ) as the maximum score of a local alignment of T 1 and T 2. Scoring node pairs and scoring edge pairs are closely related: We can push an edge score into its end node, or we can pull a node score into its unique incoming edge. The only difference is that the root node is not considered when scoring edge pairs. The two scorings can be combined by introducing a particular root scoring  * : V 1  V 2  R for the root nodes of the alignment. In the following, we omit the simple but somewhat tedious details, and simply note that all algorithms presented here work both with node scoring, edge scoring, as well as a combination thereof. A local fragmentation tree alignment for two compounds from the Orbitrap dataset (see Section 6) can be found in.is the best score of matching edge ua on edge vb, such that maximally the children A of u and B of v are used. (b) deleteL u,vis the best score for deleting edge ua, such that maximally the children A of u and B of v are used. A subset B  B of the children of v can now be matched to the children of a non-empty sets A  C(u) and B  C(v) we set,deleteR u,vwhere we defineHere,  (ua,vb) denotes the score of the losses attached to arcs ua and vb, and  (ua,), (,vb) accordingly. Recurrence (2) is the obvious modification of the recurrence presented infor global alignments and node similarities. Merging two losses in T 1 or T 2 requires two additional symmetric cases, namely join left and join right for merging in tree T 1 or T 2 , respectively. To speed up computations, we add an additional prejoin case for nodes that will be joined in the alignment. We setwhere we define, in addition to (2),(4)Here,  (p(u)a,vb) is the score for the combined losses on the path from p(u) to a with the loss of edge vb. Recall that  join  0 is the penalty for joining a node. Again, we initialize joinL u,v [A,] = joinL u,v=0 for all A,B. Analogously to (4), we can define recurrences for prejoinR u,vand joinR u,v. For bottom-up DP (), we have to find an order in which the entries of the DP tables can be filled. Computation of match u,v, deleteL u,vand deleteR u,vonly accesses entries S u ,v, such that u {u}C(u) and v {v}C(v). By processing nodes in postorder, we ensure that all S u ,vare previously computed for (u ,v ) = (u,v). For the remaining case, we iterate |A|+|B|=0,1,...,|C(u)|+|C(v)|. Similar arguments hold for the computation of join and prejoin nodes.be two trees,  : E 1 {}E 2 {}R a scoring function between edge pairs, and  join  R the penalty for joining a node. For i = 1,2 set n i := |V i |, and let d i be the maximum out degree in T i. The maximum score  (T 1 ,T 2 ) of a local alignment of T 1 ,T 2 can be computedThe proof of the theorem is based on the following lemma:See the Supplementary Material for proofs of Lemma 1 and Theorem 1. Similarly to Theorem 1, we can show that any pairwise tree alignment that does not take joining nodes into account, can also be computed in this time. We leave out the straightforward details.
Fast alignment of fragmentation trees
SPARSE DYNAMIC PROGRAMMINGApplying the above algorithm to real-world instances of aligning fragmentation trees, one can see that S(u,v) = 0 holds for many node pairs u,v. This can be attributed to two factors: First, we are computing local alignments, so we can always choose to end the alignment subtrees in the nodes u,v. Second, there are many different labels found at the edges (or nodes) of a fragmentation tree. A reasonable scoring scheme will assign negative scores to most non-matching edge (or node) labels, so it is rather the exception than the rule that we can find two nodes u,v with S(u,v) > 0. The idea is to 'sparsify' our DP tables by storing only those table entries with positive values. Thereby, we face the following fact: If S u,vSo, as soon as we have one non-zero entry in the table, then an exponentially large part of the table will be filled with non-zero entries, too. To negate this rather unfortunate effect, we modify our DP as follows: for A  C(u) and B  C(v), we define S u,v [A,B] to be the score of an optimum local alignment with subtrees rooted in u and v, respectively, such that exactly the children A of u and B of v are used in the local alignment. If no such alignment exists, we set S u,vfor the maximum over all subsets of C(v) or C(u), respectively. For non-empty sets A  C(u) and B  C(v) we setwhich, compared to (3), misses the lower bound 0 and uses the definitions:To summarize, the central point is that we do not have to store any entries with S u,v [A,B]0: such entries will never lead to an optimal alignment, as we are better off removing all nodes A,B, plus everything below these nodes from the alignment. The only exception to this rule is that we store the entry S u,v [,] = 0. Furthermore, we do not have to store entries S u,vif there exist subsets A  A, B  B with (A ,B ) = (A,B) such that S u,v [A,B] S u,v. In this case, we can replace an alignment that uses children A,B of u,v, by an alignment that uses only children A ,B and has better or equal score. We say that an entry S u,v [A,B] is dominated by entry S u,v. For a scoring scheme that assigns negative scores for non-matching edge (or node) labels, large parts of the tables have negative scores or are dominated by another entry. We do not actually have to forbid that dominated entries are stored, as they do not interfere with our computations; rather, we are free to leave out dominated entries when we encounter them. The resulting tables S u,v are sparsely populated, and for many vertices u,v, there are no entries with S u,v [A,B] > 0. We can reduce the memory consumption of the method using hash maps instead of arrays. Hash map implementations like Cuckoo hashing () or Hopscotch hashing () can carry out all operations in constant (amortized) time. In practice, we find that memory consumption is usually not prohibitive. In this case, we can use lazy arrays that are not allocated until a first entry is stored. Resolving the recurrences: Now, it is time for our final trick: instead of computing the scores using recurrence (68), we apply a successive approximation procedure similar to Dijkstra's Algorithm for shortest paths (). That is, instead of 'pulling' scores from previously calculated entries, we 'push' scores from entries that have been finalized. For example, assume that we have finalized the computation of some entry0. Then, recurrence (7) tells us that we can update other entries of the table accordingly:(which we assume to be incompletely calculated so far) then. Regarding the recurrence for match , we iterate over all a  C(u)\A
F.Hufsky et al.match u,vthen the entry match u,vis dominated and we can remove it from the hash map. For all other cases, similar updates can be performed, which we only sketch here: For deleteL we iterate over all) then update it accordingly. Updates have to be performed as soon as an entry is finalized, that is, it cannot be changed by any future modifications. Finding finalized entries is similar to the order of computations in the previous section; we omit the technical details. The above algorithm has exactly the same worst-case running time complexity as the initial recurrence from Section 3. But in practice, we can get even faster, at least in cases where the arrays are very sparse: to this end, finalizing some entry deleteL u,vtriggers updates for all subsets B  C(v)\B. But only those B can lead to relevant updates where S a,v [ * ,B ] > 0 holds. Otherwise, the updated entry will be dominated by S a,v= 0. If we iterate over the hash map for those B with S a,v> 0 then the worst-case running time increases to O 4 2  n 1 n 2 , assuming constant time access to the hash map. However, in practice, running time decreases if the DP tables are sparsely populated. We stress that the sparse DP still guarantees to find the optimal solution.
INTEGER LINEAR PROGRAMMINGILPs are a classical approach for finding exact solutions of computationally hard problems. We now present an ILP for computing a pairwise unordered tree alignment. Again, letbe the input trees with V 1 V 2 =. As the ILP is edge based, we have to introduce some additional notation: Let e  E i , i {1,2}, be any edge in one of the two given trees. We denote by D(e) the set of edges in the subtree rooted at the head of e, and by N (e) := E i \({e}D(e)) the non-descendant edges of e. For an edge e, we define p(e) to be the parent edge, and p * (e) := {p(e),p(p(e)),...} all of its ancestor edges. Finally, F (e) := D(p(e))N (e) is the 'extended family' of e, that is, all descendants of e's parent edge, except for e and its descendants. We start with the ILP without considering the join operation (ILP 1) and use the following binary variables: Iff an edge e  (E 1 E 2 ) appears in the aligned subtree, we have z e = 1; iff this edge is aligned to a gap, we have y e = 1. Finally, iff an edge e  E 1 is aligned to an edge f  E 2 , we have x {e,f } = 1. The constraints (10) ensure for each edge that we decide whether this edge is used in the alignment and if, how it is aligned. The inequalities (11) ensure that the subgraphs of T 1 (and T 2 ) are proper trees. Finally, (12) ensure that the obtained alignments are consistent: assume an alignment e,f then we cannot also align a descendant of e with a nondescendant of f and vice versa. The conditional term following the universal quantifier simply avoids redundancy. Based thereon, we can construct an ILP allowing join operations (ILP 2). Therefore, we require additional binary variables x, which are 1 iff the joined edges (p(e),e) are aligned with f. Technically, we also require x {e,f } = 1 in such a case. Note that this amount of additional variables is necessary to compose a linear objective function, when the join costs cannot be computed only based on align-and gap costs. Furthermore, we introduce binary variables  e , e  (E 1 E 2 ), which are 1 iff the edge e is used as a parent edge withinFragmentation trees were computed for all compounds. Only non-empty trees were considered for tree alignment. The maximum out degree of a single tree is denoted by out degree max. Number of alignments is given without self-alignments.{e,f } variable is 1). We use the shorthandsin the objective function. Constraints (15)(17) are analogous to the former ILP. While (18) guarantees that joins are always separated from each other within an input tree, (19) ensures that at most one joined alignment may occur for any edge.(22) make sure that a parent edge e is only marked as a joined parent iff all its aligned children are joined with e. Finally, (23) guarantees that we do not align two joined edges with each other.
EXPERIMENTAL RESULTSTo evaluate our work, we used three different test datasets (). The Orbitrap dataset () contains 97 compounds, measured on a Thermo Scientific Orbitrap XL instrument. The
Fast alignment of fragmentation treesILP 1: The ILP for pairwise unordered tree alignment without join operations max{e,f } +xFor the Orbitrap and the MassBank dataset, we found that for over 98% of the instances, the running time was in the range of microseconds for both DP algorithms. For these datasets, we only evaluate total running times for all alignments. For MassBank, the classical DP (Section 3) finished in 4.2 s for an all-againstall alignment of 343 trees, whereas sparse DP (Section 4) only required 1.8 s. For Orbitrap, the classical DP finished in 5.4 s for the all-against-all alignment of 93 trees, whereas sparse DP required 0.6 s, a 9-fold speed-up. In contrast, the ILP needed 9.6 min for all alignments in the MassBank datasets and 14.5 min for all alignments in the Orbitrap dataset. The Hill dataset contains trees with much higher maximum out degree, so we performed a more detailed running time analysis. Classical DP required 13.9 min and sparse DP finished in 1.3 min, an 11-fold speed-up. Running times of the ILP could only be measured without allowing join operations. For 1241 instances, computations run into the memory limitation of 2 GB. For the remaining alignments, the ILP finished in 11.24 h. Hence, we excluded the ILP from our detailed analysis. To get an overview of the differences in the running times between hard and easy alignments, we sorted the instances by their running times in increasing order. This was done separately for each algorithm. See(top) and. For both algorithms, we found that the 99% fastest alignments need nearly as much computing time as the remaining 1% slowest alignments. We further sorted all instances by the running time of the classical DP (see again). We found that for every instance, sparse DP requires less time than the classical DP.(b)(a) Total running times when instances are sorted by individual running times. For any fraction x%, we calculate the total running time of the x%, instances for which the alignment was computed faster than for any of the remaining instances. For example at 50% one can find the running time that was needed to compute the 50% fastest instances. For each algorithm, instances were sorted separately. Note the logarithmic y-axis. (b) Individual running times for the 200 slowest instances of the classical DP algorithm. Instances are sorted by their running time for the classical DP algorithm. One can see that running times of the classical DP are outperformed by that of the sparse DP a large database requires tree alignments to be executed extremely fast. In this article, we have presented three exact algorithms for the alignment of fragmentation trees. We find that the sparse DP approach dominates the classical DP, resulting in an 11-fold speedup for one dataset. ILPs have an excellent record of providing fast algorithms for NP-hard problems. Thus, it is rather unexpected that, for the problem discussed here, the ILP is usually clearly outperformed by both DP approaches; still, it has the potential to solve those instances that are 'hard' for DP-based algorithms. Also, in such cases we may use the ILP as a heuristic, solving only its LP relaxation and applying some integer rounding algorithm, many of which are standard in state-of-the-art ILP solvers.When larger datasets become available, we expect the total running time of an all-against-all alignment to increase more than quadratic with dataset size: We have shown above that a large fraction of the total running time stems from a few 'hard' alignments which, in turn, correspond to a few trees in the dataset that are large and, in particular, have high out degrees. We conjecture that for larger datasets, the running time spent on computing the 99% fastest alignments will be significantly smaller than the running time spent on the 1% slowest alignments. Here, even faster methods for computing fragmentation tree alignments are sought. We will evaluate whether our ILP is capable of solving these 'hard' instances faster than a DP-based approach, as its running time is not directly dependent on the out degree of the trees. We have put particular focus on fragmentation trees that are hard to align, namely large trees with high out degrees. Small trees with low out degree seem to be less interesting since they often belong to small compounds (<300 Da). Often, these compounds are 'knowns' (that is, reference measurements of the compound can be found in a spectral library) and can be identified by spectral comparison. Also, small fragmentation trees contain less information for, say, classifying an unknown compound. Nevertheless, we believe that we can also speed up alignments when one of the fragmentation trees is relatively small: this may be achieved using some preprocessing for small trees with, say, less than four losses. We conjecture that running time of the DP (Theorems 1 and 2) can be improved tousing the Mbius transform (), but this appears to be of theoretical interest only. In our evaluations, we have used a scoring function similar to the one by. Both scorings lack any statistical explanation and should be refined in the future using, say, log odds scores. Also, the effect of merging two or possibly even more nodes has to be investigated. Both questions were beyond the scope of this work. Another interesting question is whether polynomial-time methods for tree alignment of unordered trees, such as the constrained tree edit distance (), can be used for aligning fragmentation trees: whereas the restrictions imposed byhave no sensible interpretation in the context of fragmentation trees, quality of results may still be sufficient for certain applications. Aligning fragmentation trees allows for an automated classification of unknown compounds into compound classes. Thus, large-scale compound screens can easily be searched for compounds of interest. This may be useful in the search for signaling molecules, biomarkers, or novel drugs and the identification of illegal drugs or toxins. In conjunction with other methods from i272
Fast alignment of fragmentation treessystems biology, the concept can help to identify new metabolic pathways based on tandem MS experiments.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
DYNAMIC PROGRAMMING We now present an algorithm to compute optimum fragmentation tree alignments that has reasonable running time in practice. Our algorithm is a modification of an algorithm by Jiang et al. (1995) for computing global alignments of unordered trees. The reason for these algorithms to be swift in practice is that fragmentation trees usually have comparatively small out degree: fragments rarely have more than, say, five child fragments. We can limit the inevitable exponential part of the running time to this out degree. We use DP to compute the maximal score  (T 1 ,T 2 ) of a local alignment between two trees T 1 ,T 2. Let S(u,v) be the maximal score of a local alignment of two subtrees of T 1 ,T 2 , where the subtree of T 1 is rooted in u, and the subtree of T 2 is rooted in v. For A  C(u) and B  C(v), we define S u,v [A,B] to be the score of an optimal local alignment of subtrees rooted in u and v, respectively, such that maximally the children A of u and B of v are used in the alignment. Clearly, S(u,v) = S u,v [C(u),C(v)]. Furthermore, we have S u,v [A,] = S u,v [,B]=0 for all A,B. When all S(u,v) are known, we can compute the maximal score of a local alignment of T 1 ,T 2 as  (T 1 ,T 2 ) = max uT 1 ,vT 2 S(u,v). (1) We present a recurrence for the computation of S u,v [A,B]. We initialize S u,v [A,B]=0 for A = or B =. Recall that T 1 is the left tree and T 2 is the right tree. In the recurrence, we distinguish three cases, namely match (including mismatches), deletion left or deletion right, where the latter two are symmetric (Figure 3). For i267 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Theorem 2. A pairwise unordered tree alignment (global or local, scoring nodes or edges or both, with similarities or costs) of rooted trees T 1 ,T 2 can be computed in O 3 2  n 1 n 2 time. Here, n i is the number of nodes in tree T i , and d i is the maximum out degree in T i , for i = 1,2; furthermore, := max{d 1 ,d 2 } and  := min{d 1 ,d 2 }. i268 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
MassBank dataset (Horai et al., 2010) consists of 370 compounds measured on a Waters Q-Tof Premier spectrometer. The Hill dataset consists of 102 compounds measured on a Micromass Q-Tof, published by Hill et al. (2008). We omit the experimental details. Fragmentation trees were computed using ILP as described in Rauf et al. (2012). Self-alignments were excluded from the analysis. For our evaluations, we use a scoring function very similar to the one from (Rasche et al., 2012), evaluating pairs of losses and pairs of fragments. For losses nl 1 , nl 2 , we distinguish between size-dependent positive match scores  (nl,nl) := 5 + number of non-hydrogen atoms and size-dependent negative mismatch scores  (nl 1 ,nl 2 ) := 5 number of different non-hydrogen atoms. For fragments f 1 , f 2 , we use size-dependent positive match scores  (f ,f ) := 5 + number of non-hydrogen atoms and sizeindependent negative mismatch scores  (f 1 ,f 2 ) := 3. We allow insertion/deletions, as well as joining two subsequent losses, both without penalty. The idea behind this ad hoc scoring is to reward or penalize large losses stronger than small losses, whereas nonmatching fragments are penalized independent of size. See Rasche et al. (2012) for details. We implemented the DP algorithms in Java 1.6. For the sparse DP, we used lazy arrays to store the DP tables. We solved the ILP via branch and cut using CPLEX 12.1 in its default settings. Computation was done on two different but comparable computers, namely on a quad-core 2.2 GHz AMD Opteron processor with 5 GB of main memory for the DP algorithms, and on a quad-core Intel Xeon E5520 with 2.27 GHz in 32-bit mode for the ILP, using 2 GB RAM per job. For the DP algorithms, we repeated computations five times, reporting the minimum running time for each instance. i270 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
CONCLUSION Fragmentation trees are a tool to overcome the limitations of spectral library search, as they, for the first time, enable us to retrieve not only exact hits, but also similar compounds from a spectral database. But performing the workflows proposed by Rasche et al. (2012) on i271 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
