Motivation: Segmental duplications >1 kb in length with â‰¥ 90% sequence identity between copies comprise nearly 5% of the human genome. They are frequently found in large, contiguous regions known as duplication blocks that can contain mosaic patterns of thousands of segmental duplications. Reconstructing the evolutionary history of these complex genomic regions is a non-trivial, but important task. Results: We introduce parsimony and likelihood techniques to analyze the evolutionary relationships between duplication blocks. Both techniques rely on a generic model of duplication in which long, contiguous substrings are copied and reinserted over large physical distances, allowing for a duplication block to be constructed by aggregating substrings of other blocks. For the likelihood method, we give an efficient dynamic programming algorithm to compute the weighted ensemble of all duplication scenarios that account for the construction of a duplication block. Using this ensemble, we derive the probabilities of various duplication scenarios. We formalize the task of reconstructing the evolutionary history of segmental duplications as an optimization problem on the space of directed acyclic graphs. We use a simulated annealing heuristic to solve the problem for a set of segmental duplications in the human genome in both parsimony and likelihood settings. Availability: Supplementary information is available at
INTRODUCTIONA striking feature of mammalian genomes is the prevalence of segmental duplications or low-copy repeats. Approximately 5% of the human genome consists of segmental duplications >1 kb in length with 90% sequence identity between copies (). Segmental duplications account for a significant fraction of the differences between humans and other primate genomes, and are enriched for genes that are differentially expressed between the species (). Segmental duplications remain an extreme challenge for evolutionary reconstruction, as they are the 'most structurally complex and dynamic regions of the human genome' (). Human segmental duplications are frequently found within complicated mosaics of duplicated fragments ().produced a comprehensive annotation of this mosaic organization; they derived an 'alphabet' of approximately 11 000 duplicated segments, or duplicons, and delimited 437 duplication blocks or 'strings' of at least 10 (and * To whom correspondence should be addressed.typically dozens) different duplicons found contiguously on a chromosome. However, the relationships between these annotated duplication blocks are complex and straightforward analysis does not immediately reveal the evolutionary relationships between blocks. Numerous authors have considered the problem of analyzing relationships between genome sequences that contain duplicated segments. This work falls into roughly two categories. The first focus is the problem of computing genome rearrangement distances, like reversal distance, in the presence of duplicated genes or synteny blocks (, for example). However, such rearrangement distances do not model the creation of new duplicates and thus are not well-suited to describe the evolutionary history of segmental duplications in the genome. The second focus is to analyze regions with duplications under 'local' operations like tandem duplications (, for example). While tandem duplication is undoubtedly important in the generation of duplication blocks, there is strong evidence that an important characteristic of the history of segmental duplications is the frequent duplication and transposition of long segments over large physical distances; as many as 5060% of segmental duplications were transposed interchromosomally (). Several general models of rearrangement that allowed for both local operations and duplicationtranspositionlike operations between different strings were studied by, but the generality of those models meant that the distances were NP-hard to compute and only approximation algorithms were given. Here, we present a novel formulation of the problem of computing an evolutionary history for a set of segmental duplications that are organized in duplication blocks. We represent evolutionary relationships between a set of duplication blocks as a directed acyclic graph (DAG), and we formalize the evolutionary reconstruction problem as an optimization over the space of DAGs. We present two different methods for scoring a DAG: one based on parsimony and one based on likelihood. The parsimony score for a DAG is a straightforward extension of 'duplication distance', a measure introduced by some of us () that describes the most parsimonious sequence of duplicate operations needed to construct a given target string. The likelihood score for a DAG is the product of the likelihood scores for each of the duplication blocks, where a duplication block's likelihood is derived by computing the weighted ensemble of all possible duplication scenarios that could have generated it. We describe how to compute the partition function of the ensemble efficiently using a dynamic program that generalizes the duplication distance (i.e. parsimony score) recurrence. Deriving a probabilistic model from a dynamic program this way is analogous to the
Reconstruction of segmental duplicationsapproach of McCaskill (1990) who applied dynamic programming to RNA folding to compute the partition function of all secondary structures and to assign probabilities to certain substructures.. Finally, we solve these evolutionary reconstruction problems on the set of duplication blocks identified byusing a local search technique based on simulated annealing. We compare these reconstructions to the analysis of. Our evolutionary reconstruction recapitulates some of the properties of earlier analysis but also reveals additional and more subtle relationships between segmental duplications.
METHODSHere, we present two methods for determining the optimality of an evolutionary relationship between a pair of duplication blocksone based on a parsimony criterion and one based on a likelihood criterion. In Sections 2.1 and 2.2, we describe the parsimony-based model of segmental duplication that is based on duplication distance, introduced in Kahn and). Next, we present a novel probabilistic model of segmental duplication that we use to compute the likelihood score for an evolutionary relationship between a pair of duplication blocks.
A model of segmental duplicationAs noted above, an important characteristic of segmental duplications that distinguishes them from other types of repeats is that they are frequently transposed across large genomic distances from their respective ancestral loci. In), we modeled the process in which a duplication block, a composite of many duplicons, is built by copying strings of duplicons from other duplication blocks. In particular, we define the basic 'copypaste' operation as follows.A subsequence is distinguished from a substring because the characters of a subsequence need not be contiguous. Given a string X, a subsequence S of X can be expressed as an increasing list of indices of X. For example, for X = abcdefg, the subsequence S = (1,3,5) is the string ace.of a string X overlap if either (i) there exist indices i : 1  i < l s and j : 1  j < l t such that i = j, or (ii) there exist indices i,i : 1  i < i < l s and a j,j : 1  j < j < l t such that either i < j < i < j or j < i < j < i .Given a source/target pair X,Y , any sequence of duplicate operations of thethat generates Y from X uniquely partitions the characters of Y into non-overlapping subsequences corresponding to characters that were copied conjointly from X.is a sequence of substrings of X.See. A sequence of k duplicate operations that constructs Y from X uniquely defines a feasible generator X with length k whose elements correspond, respectively, to substrings of X that are duplicated conjointly in a single operation.Page: i448 i446i452
Parsimony
C.L.Kahn et al.X. In particular, we can express the probability as:where | X | denotes the length of the generator. The likelihood of a target string Y then can be expressed as L(Y |F,X,k) = Pr(F|Y ,X,k). The score of a generator, ( X ), can be defined according to various biological models. Although different functions  may require different algorithms for computing the value Pr, we found that functions of the form (the sum of the lengths of the elements of X , admit particularly efficient algorithms for computing Equation (1). We discuss the score function further in Supplementary Section 1.2. Now, we give an algorithm to compute the partition function, Z), each length-k generator whose elements have lengths that sum to l are scored the same, namely (k,l). Therefore, in order to compute Z
..x |X| be a source string and let k and l be positive integers. The function C(k) X (l) satisfies the following recurrence.(l )(|X|(l l )+1). For a source string X and integers k,l, if we are given CX (l), we can compute ZX efficiently by summing CX (l) over all relevant lengths l, weighting each feasible generator appropriately according to the function (k,l).
..x |X| be a source string and k be a positive integer.The partition function ZNote that the elements of a length-k list of substrings of X can have lengths that sum to at least k and at most |X|k. The recurrence in Lemma 2.6 can be computed in O(|X|k) time, so Zcan be computed in O(|X| 2 k 2 ) time according to Theorem 2.7. We omit a proof of correctness due to space considerations.
Restricted partition functionIn this section, we present the final ingredient necessary to compute the probability Pr, namely the sum in Equation (1) that we define as QX (Y ). We refer to the value QX (Y ) as the restricted partition function of feasible generators, and it is equal to the weighted ensemble of all length-k generators X that are feasible for Y. Hence QIn order to compute this value, we generalize the recurrence presented infor computing duplication distance from source string X to target string Y to count the number of length-k generators that are feasible for Y .
The value C(k) X (l) is related to the well-known integer partition function p(n) and corresponding Young tableaux. If P(l,k) is the set of partitions of the integer l into k parts, we can express CHere, the term Nthe number of feasible generators X with length k given that the character y 1 is generated by a substring of X starting at x i. We compute the restricted partition function QX (Y ) efficiently by first counting the number of relevant feasible generators, namely N, and scoring each generator appropriately by (k,|Y |).
..,y |Y | be a source/target string pair and let k be a positive integer. The restricted partition function QThe recurrence given in Lemma 2.8 can be computed in time) is the maximum multiplicity of any character that appears in Y (resp. X), so computing QX (Y ) takes the same time. We include a proof of correctness in Supplementary Section 1.1.
ALGORITHMHere, we formalize the problem of computing a segmental duplication evolutionary history for a set of duplication blocks in the human genome with respect to either a parsimony or likelihood criterion.
Maximum parsimony and maximum likelihood evolutionary historiesThe input to our problem is the set of duplication blocks found in the human genome, each represented as a signed string on the alphabet of duplicons. Our goal is to compute a putative duplication history that accounts for the construction of all of the duplication blocks. We assume that the ancestral genome is devoid of segmental duplications. A duplication history is a sequence of duplicate events that first builds up a set of seed duplication blocks by duplicating and aggregating duplicons from their ancestral loci and then successively constructs the remaining duplication blocks by duplicating substrings of previously constructed blocks. We observed in Kahn and Raphael (2008) strong evidence that many of the duplication blocks identified byhad been constructed through the duplication and aggregation of substrings of duplicons from several other blocks. Therefore, a tree cannot aptly represent an evolutionary history; a more appropriate representation of the evolutionary relationships between duplication blocks is a DAG in which the vertices represent duplication blocks and an edge directed from a vertex X to a vertex Y indicates that i448Page: i449 i446i452
Reconstruction of segmental duplicationssubstrings of X were duplicated in the construction of Y. A vertex with multiple incoming edges and, therefore, multiple parents, is constructed using substrings of all of the parent blocks. Specifically, given a DAG G = (D,E), for Y  D, we define P G (Y ), the parent string of Y , by P G (Y ) = X 1 X 2 X p where X i {D|(X i ,Y )  E} and indicates the concatenation of two strings with a dummy character inserted in between. We make two simplifying assumptions. First, we assume that only duplicate events occur and that there are no deletions, inversions, or other types of rearrangements within a duplication block. Second, we assume that a duplication block is not copied and used to make another duplication block until after it has been fully constructed, ensuring the evolutionary relationships cannot contain cycles. We acknowledge that our two simplifying assumptions restrict the evolutionary history reconstruction problem significantly, but admit an efficient and consistent method of scoring a solution. Similar assumptions were made, for example, byto derive the evolutionary tree for Alu repeat elements. We can define the optimal DAG with respect to a parsimony criterion using duplication distance (Definition 2.2).
Definition 3.1. Given a set of duplication blocks D, the maximum parsimony evolutionary history is the DAG GWe can also define the optimal DAG with respect to a likelihood criterion. In phylogenetic tree reconstruction, a max likelihood solution is a tree that maximizes the probability of generating the characters at the leaf nodes over all possible tree topologies, branch lengths, and assignments of ancestral states to the internal nodes. Typically, the evolutionary process is assumed to be a Markov process so that the probabilities along different branches are independent. We similarly define the maximum likelihood DAG using the probabilistic model derived in Section 2. We maximize the likelihood of the solution over all DAG topologies andinstead of branch lengthsthe numbers of operations permitted to construct each node. Definition 3.2. Given a set of duplication blocks D, the maximum likelihood evolutionary history is theare the partition function and restricted partition functions, respectively.
IMPLEMENTATIONWe analyzed a set of 391 duplication blocks identified by) that were represented as signed strings on an alphabet of 11 000 duplicons. We computed the maximum parsimony evolutionary history (Definition 3.1) for the entire set of blocks (). The DAG exhibited multiple connected components. For comparison, we then computed the maximum likelihood evolutionary histories (Definition 3.2) for several of the subgraphs induced by connected components of the parsimony solution. We scored generators according to (k,|Y |) = 1 |Y | k (see Supplementary Section 1.2). We used a simulated annealing strategy to find a maximum parsimony DAG for the entire set of duplication blocks and to find maximum likelihood DAGs for several subgraphs 4 (see Supplementary Section 1.3 for details). For each input, we ran our local search 300 times. We started the search an equal number of times at each of three different types of initial graphs: (i) the empty graph with no edges; (ii) the directed minimum spanning tree (MST); and (iii) a randomly chosen DAG (chosen independently for each trial). Finally, to focus the search on the most important block relationships, we considered only edges between blocks whose longest common subsequence (LCS) contained at least 20 duplicons.
Maximum parsimony reconstructionThe maximum parsimony DAG contains 391 nodes and 479 edges. There are nine connected components with at least four duplication blocks, and nearly 40% of the blocks appear in the largest connected component.shows a moderately-sized connected component. The graph also contains a total of 105 singleton nodes for which we did not infer any evolutionary relations with other duplication blocks, 97 of which did not exhibit an LCS of length 20 with any other block. The maximum parsimony DAG represents a scenario in which all 391 duplication blocks could have been constructed in a sequence of 17 431 total duplicate operations. As a baseline comparison, a minimum spanning tree, with respect to duplication distance, on the set of duplication blocks has a total parsimony score of 28 852 and by definition, contains 390 edges.performed an initial analysis of the duplication blocks. They defined 24 clades, or groups of duplication blocks derived from a common ancestor block, by performing hierarchical clustering on a matrix representing the shared presence or absence of duplicons for every pair of blocks. For a given clade they defined a core duplicon as one that appears in at least 67% of the constituent duplication blocks. They posited that clades represent families of evolutionarily related duplication blocks and that core duplicons 'may have driven the evolution of the duplication blocks' in a clade. After construction, we colored the nodes of our DAG according to the clades described in. We found a strong correspondence between Jiang et al.'s clades and connected subgraphs in our DAG; five of the nine connected components with at least four blocks were comprised of duplication blocks belonging to a single clade and seven of the nine components were comprised of blocks belonging to no more than two clades. For example, see Figures 4a and 5a. In larger components, nodes from a single clade frequently induce a connected subgraph. For example, see. Our DAG also reveals which duplication blocks may have seeded many other blocks (i.e. those with high out-degree). For example, in, block 399 exhibits eight children and is an inflection point for the component. Moreover, the edge from block 399 to 405Page: i450 i446i452to a node v if the most-parsimonious duplication scenario includes duplication events that copy substrings of u in the construction of v.partitioned the duplication blocks into a set of 24 clades (plus one 's' group of duplication blocks found in subtelomeric regions) that we indicate here with 25 colors on nodes. The 3 sets of colored edges represent inheritance networks for 3 conserved subsequences of duplicons. These inheritance networks are almost entirely confined to a single clade each. The green edges represent the inheritance of the duplicon sequencein clade 'M1', the red edges represent the inheritance ofin clade 'M2', and the blue edges represent the inheritance ofin clade 'chr16.'links blocks from the the 'M1' and 'chr7_2' clades. Even though the blocks 399 and 405 belong to different clades, 405 is very 'close' to 399 in duplication distance: block 405 contains only 71 duplicons, but it shares a subsequence of 29 duplicons with block 399. This link suggests that the entirety of clade 'chr7_2' was descended from clade 'M1' in an optimal duplication history. Also implicit in the DAG is information about which duplicons are duplicated from one block to another in an optimal duplication history. We define the inheritance network for each duplicon as the subgraph induced on the edges on which that duplicon is passed from parent to child. Interestingly, a comparison of the inheritance networks for core and non-core duplicons revealed that many noncore duplicons exhibit larger inheritance networks within subgraphsinduced by a clade than core duplicons. For example, non-core duplicon 6970 appeared on 36 of the 63 total edges in the subgraph induced by clade 'M1' (shown in blue in) and does not appear on any other edge in the graph. In contrast, the maximum size of the inheritance network of a core duplicon was only 17. We propose 6970 as a new core duplicon for this clade and suggest that others like it should also be categorized as core duplicons. Moreover, we found inheritance networks for many conserved subsequences of duplicons that were nearly as prominent as those for individual core duplicons. For example, the subsequenceof duplicons appears on 23 of the edges in the subgraph induced by 'M1' clade nodes (shown as green edges in). Similarly, the sequenceexhibits a connected inheritance network of 7 edges within the subgraph induced on clade 'M2', andexhibits an inheritance network of seven edges within the subgraph induced on clade 'chr16' that includes an inheritance path of length 5 (). By delineating the inheritance networks of duplicon subsequences that are conserved across duplication blocks, we can learn about which duplicons were duplicated and transposed conjointly. This type of analysis was impossible using only the clade annotations of).
Clades and core duplicons
C.L.Kahn et al.
Clade
i450
Reconstruction of segmental duplications
Maximum likelihood reconstructionWe computed the maximum likelihood DAGs (Definition 3.2) for the sets of duplication blocks appearing within moderately sized connected components of the maximum parsimony DAG in order to compare the two methods. We chose the components comprised of blocks from clades 'chr16' and 'chr10', respectively (). The maximum likelihood subgraphs for these subproblems are shown in Figures 4b and 5b. The two DAGs for the 'chr16' component inshare some characteristics. For example, node 121 is a common ancestor of every other block and block 276 exhibits high out-degree in both solutions. Both solutions are similarly 'good' with respect to the parsimony objective: the solution in (a) exhibits an optimal parsimony score of 397, and the one in (b) exhibits a score of 401.
i451
C.L.Kahn et al.However, the likelihood score for the parsimony solution in (a) was nearly zero. One difference that accounts for this discrepancy is the higher average in-degree for blocks in the parsimony solution (2.2) as compared to the likelihood solution (1.3). Also, the parsimony solution exhibits a path with ten edges, whereas the longest path in the likelihood solution has six. Some of these differences are due to the fact that the parsimony criterion does not penalize edges that do not directly improve the score. For example, block 291 has two parents (276 and 25) in the parsimony DAG but only one parent (276) in the likelihood DAG. However, the duplication distance with source 276 25 and target 291 is the same as the duplication distance with source 276 and target 291. Therefore, the edge from 25 to 291 does not improve the parsimony score, underscoring that there are multiple optimal parsimony solutions. In contrast, the likelihood of a target block generally increases as the sum of the lengths of its parent blocks decreases, so the max likelihood DAG will not include edges that do not directly improve the score.
DISCUSSIONOur maximum parsimony and maximum likelihood reconstructions show some differences, both from each other and from the analysis of. In particular, we identify non-core duplicons and subsequences that are arguably as promiscuous within a clade as core duplicons. There are several directions for future work. From a theoretical perspective, one can incorporate other types of operations into the probabilistic model, such as deletions and inversions which we have described in the parsimony setting (), as well as single nucleotide mutations. Also, our method could be used to sample over the space of DAGs using a Markov Chain Monte Carlo strategy. From the perspective of applications, a more comprehensive analysis of genes or other elements in the newly identified core duplicons and core subsequences from our reconstruction is warranted, as is a further refinement of the clade annotation by analyzing the clade-induced subgraphs of the DAGs. Funding: Career Award at the Scientific Interface from the Burroughs Wellcome Fund (to B.J.R.).
Conflict of Interest: none declared.
In (Kahn and Raphael, 2008, 2009), we also considered duplicate reversals in which the copied substring is inverted before being inserted into the target. We note that all of our definitions and algorithms presented here can be similarly augmented but we omit the details. 2 We note that the duplication distance between a pair of strings is not formally a distance as it is asymmetric.
In Kahn et al. (2010), we describe a polynomial-time algorithm to compute the duplication distance from X to Y. We use duplication distance to measure the similarity between a pair of duplication blocks by counting the number of operations needed to generate Y from X in a simplest or most-parsimonious scenario. While the parsimony assumption is attractive from a theoretical perspective and can produce useful biological insight, it might be overly restrictive, particularly when there are many different optimal or nearly optimal solutions. Consider, for example, the strings X ='a', 'b', 'c', 'd', 'e', 'f', and 'g', hijkl, and Y = agdbhecifdajebkfclg. The duplication distance, d(X,Y ), is 13 and there is a single feasible generator with this optimum length. However, there are 989 possible feasible generators for Y , 119 of which have length 14, just slightly suboptimal. Because the space of all possible feasible generators is very large, a probabilistic model might give very low probability to an optimal parsimony solution. Thus, in the next section, we present a probabilistic model of segmental duplication that considers the weighted ensemble of all feasible generators for a source/target string pair. 2.3 The partition function For a given source string X and positive integer k, we consider the space of all length-k generators X. We define a probability distribution on the collection of generators by defining Pr[ X ]( X ) where ( X ) is the 'score', or weight, assigned to a generator, and we compute the partition function Z (k) X of the weighted ensemble of all possible length-k generators X. Given a source string X and a target string Y , we define the event F to be the event of choosing a length-k generator that is feasible for Y from the space of length-k generators. We define a probabilistic model for segmental duplications that, given a target string Y , assigns a probability to F: Pr[F|Y ,X,k]. For a fixed target string Y , the probability, Pr[F|Y ,X,k], is the weighted ensemble of all possible length-k generators that are feasible for Y , normalized by the i447 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Both the max parsimony and max likelihood versions of the problem can be shown to be NP-hard by a reduction from the problem of Learning Bayesian Networks. i449 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
