Motivation: Exact-match overlap graphs have been broadly used in the context of DNA assembly and the shortest super string problem where the number of strings n ranges from thousands to billions. The length of the strings is from 25 to 1000, depending on the DNA sequencing technologies. However, many DNA assemblers using overlap graphs suffer from the need for too much time and space in constructing the graphs. It is nearly impossible for these DNA assemblers to handle the huge amount of data produced by the next-generation sequencing technologies where the number n of strings could be several billions. If the overlap graph is explicitly stored, it would require (n 2) memory, which could be prohibitive in practice when n is greater than a hundred million. In this article, we propose a novel data structure using which the overlap graph can be compactly stored. This data structure requires only linear time to construct and and linear memory to store. Results: For a given set of input strings (also called reads), we can informally define an exact-match overlap graph as follows. Each read is represented as a node in the graph and there is an edge between two nodes if the corresponding reads overlap sufficiently. A formal description follows. The maximal exact-match overlap of two strings x and y, denoted by ov max (x,y), is the longest string which is a suffix of x and a prefix of y. The exact-match overlap graph of n given strings of length is an edge-weighted graph in which each vertex is associated with a string and there is an edge (x, y) of weight ω = −|ov max (x,y)| if and only if ω ≤ λ, where |ov max (x,y)| is the length of ov max (x,y) and λ is a given threshold. In this article, we show that the exact-match overlap graphs can be represented by a compact data structure that can be stored using at most (2λ−1)(2logn++logλ)n bits with a guarantee that the basic operation of accessing an edge takes O(logλ) time. We also propose two algorithms for constructing the data structure for the exact-match overlap graph. The first algorithm runs in O(λλnlogn) worse-case time and requires O(λ) extra memory. The second one runs in O(λλn) time and requires O(n) extra memory. Our experimental results on a huge amount of simulated data from sequence assembly show that the data structure can be constructed efficiently in time and memory. Availability: Our DNA sequence assembler that incorporates the data structure is freely available on the web at
INTRODUCTIONAn exact-match overlap graph of n given strings of length each is an edge-weighted graph defined as follows. Each vertex is associated with a string and there is an edge (x,y) of weight  = |ov max (x,y)| if and only if   , where  is a given threshold and |ov max (x,y)| is the length of the maximal exact-match overlap of two strings x and y.  =  |ov max (x,y)| is called the overlap threshold. The formal definition of the exact-match overlap graph is given in Section 2. Storing the exact-match overlap graphs efficiently in term of memory becomes essential when the number of strings is very large. In the literature, there are two common data structures to store a general graph G = (V ,E). The first data structure uses a 2D array of size |V ||V |. We refer to this as an array-based data structure. One of its advantages is that the time for accessing a given edge is O(1). However, it requires (|V | 2 ) memory. The second data structure stores the set of edges E. We refer to this as an edge-based data structure. It requires (|V |+|E|) memory and the time for accessing a given edge is O(log), where is the degree of the graph. Both these data structures require (|E|) memory. If the exact-match overlap graphs are stored using these two data structures, we will need (|E|) memory. Even this much of memory may not be feasible in cases when the number of strings is over a hundred million. In this article, we focus on data structures for the exact-match overlap graphs that will call for much less memory than |E|.
Our contributionsWe show that there is a compact data structure representing the exact-match overlap graph that needs much less memory than |E| with a guarantee that the basic operation of accessing an edge takes O(log) time, which is almost a constant in the context of DNA assembly. The data structure can be constructed efficiently in time and memory as well. In particular, we show that @BULLET The data structure takes no more than (21)(2logn+ log)n bits. @BULLET The data structure can be constructed in O(n) time.As a result, any algorithm that uses overlap graphs and runs in time T can be simulated using our compact data structure. In this case, the memory needed is no more than (21)(2logn++log)n bits (for storing the overlap graph) and the time needed is O(T log).
H.Dinh and S.RajasekaranIf  is a constant or much smaller than n, our data structure will be a perfect solution for any application that does not have enough memory for storing the overlap graph in a traditional way. Our claim may sound contradictory because in some exact-match overlap graphs the number of edges can be (n 2 ) and it seems like it will require (n 2 ) time and memory to construct them. Fortunately, because of some special properties of the exact-match overlap graphs, we can construct and store them efficiently. In Section 3.1, we will describe these special properties in detail. Briefly, the idea of storing the overlap graph compactly is from the following simple observation. If the strings are sorted in the lexicographic order, then for any string x the lexicographic orders of the strings that contain x as a prefix are in a certain integer range or integer interval. Therefore, the information about out-neighborhood of a vertex can be described using at most  intervals. Such intervals have a nice property that they are either disjoint or contain each other. This property allows us to describe the out-neighborhood of a vertex by at most 21 disjoint intervals. Each interval costs 2logn++log bits, where 2logn bits are for storing its two bounds and log bits are for storing the weight. We have n vertices so the amount of memory required by our data structure is no more than (21)(2logn++log)n bits. Note that this is just an upper bound. In practice, the amount of memory may be much less than that.
Application: DNA assemblyThe main motivation for the exact-match overlap graphs comes from their use in implementing fast approximation algorithms for the shortest super string problem which is the very first problem formulation for DNA assembly. The exact-match overlap graphs can be used for other problem formulations for DNA assembly as well. Exact-match overlap graphs have been broadly used in the context of DNA assembly and the shortest super string problem where the number n of strings ranges from thousands to billions. The length of the strings is from 25 to 1000, depending on the DNA sequencing technology used. However, many DNA assemblers using overlap graphs are time and memory intensive. If an overlap graph is explicitly stored, it would require (n 2 ) memory which could be prohibitive in practice. In this article, we present a data structure for representing overlap graphs that requires only linear time and linear memory. Experimental results have shown that our preliminary DNA sequence assembler that uses this data structure can handle a large number of strings. In particular, it takes about 2.4 days and 62.4 GB memory to process a set of 660 million DNA strings of length 100 each. The set of DNA strings is drawn uniformly at random from a reference human genome of size of 3.3 billion base pairs.consider the all-pairs suffix-prefix problem which is actually a special case of computing the exact-match overlap graphs when  =. They devised an O(n+ n 2 ) time algorithm for solving the all-pairs suffix-prefix problem. In this case, the exact-match overlap graph is a complete graph. So the run time of the algorithm is optimal if the exact-match overlap graph is stored in a traditional way. Although the run time of the algorithm byis theoretically optimal in that setting, it uses the generalized suffix tree which has two disadvantages in practice. The first disadvantage is that the space consumption of the suffix tree is quite large (). The second disadvantage is that the suffix tree usually suffers from a poor locality of memory references (). Fortunately,have proposed a suffix tree simulation framework that allows any algorithm using the suffix tree to be simulated by enhanced suffix arrays. Ohlebusch and Gog (2010) have made use of properties of the enhanced suffix arrays to devise an algorithm for solving the all-pairs suffix-prefix problem directly without using the suffix tree simulation framework. The run time of the algorithm by Ohlebusch and Gog is also O(n+n 2 ). Please note that our data structure and algorithm can be used to solve the suffix-prefix problem in O(n) time. In the context of DNA assembly,  is typically much smaller than n and hence our algorithm will be faster than the algorithms of Gusfield (1997) and Ohlebusch and Gog (2010). Exact-match overlap graphs should be distinguished from approximate-match overlap graphs which is considered in) and Pop (2009). In the approximatematch overlap graph, there is an edge between two strings x and y if and only if there is a prefix of x, say x , and there is a suffix of y, say y , such that the edit distance between x and y is no more than a certain threshold.
Related work
BACKGROUNDLet be the alphabet. The size of is a constant. In the context of DNA assembly, ={A,C,G,T }. The length of a string x on , denoted by |x|, is the number of symbols in x. Let xbe the i-th symbol of string x, and xbe the substring of x between the i-th and the j positions. A prefix of string x is the substring xfor some i. A suffix of string x is the substring xfor some i. Given two strings x and y on , an exact-match overlap between x and y, denoted by ov(x,y), is a string which is a suffix of x and a prefix of y (notice that this definition is not symmetric). The maximal exact-match overlap between x and y, denoted by ov max (x,y), is the longest exact-match overlap between x and y. Exact-match overlap graphs: informally, an exact-match overlap graph is nothing but a graph where there is a node for each read and two nodes are connected by an edge if there is a sufficient overlap between the corresponding reads. To be more precise, given n strings s 1 ,s 2 ,...,s n and a threshold , the exact-match overlap graph is an edge-weighted directed graph G = (V ,E) in which there is a vertex v i  V associated with the string s i , for 1  i  n. There is an edge (v i ,v j )  E if and only if |s i ||ov max (s i ,s j )|. The weight of the edge (v i ,v j ), denoted by (v i ,v j ), is |s i ||ov max (s i ,s j )|. See. If all the n input strings have the same length , then  =  is called the overlap threshold. If there is an edge (v i ,v j ) in the graph, it implies that the overlap between s i and s j is at least . The set of out-neighbors of a vertex v is denoted by OutNeigh(v). The size of the set of out-neighbors of v, |OutNeigh(v)|, is called the out-degree of v. We denote the out-degree of v as deg out (v) = |OutNeigh(v)|. For simplicity, we assume that all the strings s 1 ,s 2 ,...,s n have the same length. Otherwise, let be the length of the longest string and all else works. The operation of accessing an edge given its two endpoints: given any two vertices v i and v j , the operation of accessing the edge (v i ,v j )is the task of returning (v i ,v j ) if (v i ,v j ) is actually an edge of the graph, and returning NULL if (v i ,v j ) is not.
Memory-efficient overlap graph
METHODS
A memory-efficient data structure representing an exact-match overlap graphIn this section, we present a memory-efficient data structure to store an exactmatch overlap graph. It only requires at most (21)(2logn++log)n bits. It guarantees that the time for accessing an edge, given two end points of the edge, is O(log). This may sound like a contradictory claim because in some exact-match overlap graphs the number of edges can be (n 2 ) and it seems like it should require at least (n 2 ) time and space to construct them. Fortunately, because of some special properties of the exact-match overlap graphs, we can construct and store them efficiently. In the following paragraphs, we will describe these special properties. The graph representation we envision is one where we store the neighbors of each node. The difference between the standard adjacency lists representation of a graph and ours lies in the fact that we only use O() memory to store the neighbors of any node. We are able to do this since we sort the input strings in lexicographic order and employ a data structure called PREFIX defined below. Another crucial idea we employ is the following: let x be any string and let the input reads be sorted in lexicographic order. If we are interested in identifying all the input strings in which x is a prefix, then these strings will be contiguous in the sorted list. If we use the sorted position of each read as its identifier, then the neighbors of any node can be specified with O() intervals (as we show next). Without loss of generality, we assume that the n input strings s 1 ,s 2 ,...,s n are sorted in lexicographic order. We can assume this because if they are not sorted, we can sort them by using the radix sort algorithm which runs in O(n/w) time, where w is the word length of the machine used, assuming that the size of the alphabet is a constant. If the alphabet is not of size O(1), the sorting time will be O(nlog(||)/w). We associate an identification number with each string s i and its corresponding vertex v i in the exact-match overlap graph. This identification number is nothing but the string's lexicographic order i. We will access an input string using its identification number. Therefore, the identification number and the vertex of an input string are used interchangeably. Also, it is not hard to see that we need logn bits to store an identification number. We have the following properties. Given an arbitrary string x, let PREFIX(x) be the set of identification numbers of all the input strings for which x is a prefix. Formally, PREFIX(x) ={i|x is a prefix of s i }. PREFIX enables us to specify the neighbors list of any node in the graph compactly. In PROPERTY 3.1, PROPERTY 3.2, PROPERTY 3.3, and Lemma 3.1, we prove certain properties of PREFIX and finally show that we can represent the neighbors list of any node as 21 intervals. Property 3.1. If PREFIX(x) =, then PREFIX(x) =, whereis some integer interval containing integers a,a+1,Proof. Let a = min iPREFIX(x) i and b = max iPREFIX(x) i. Clearly, PREFIX(x) . On the other hand, we will show thatPREFIX(x). Let i be any identification number in the interval. Since the input strings are in lexicographically sorted order, s a s i s b. Since a  PREFIX(x) and b  PREFIX(x), s a= s b. Thus, s a= s i= s b. Therefore, x is a prefix of s i. Hence,For example, letIf x = AC, then PREFIX(x) =. Similarly, if x = ACCC, then PREFIX(x) =. Property 3.1 tells us that PREFIX(x) can be expressed by an interval which is determined by its lower bound and its upper bound. So we only need 2logn bits to store PREFIX(x). In the rest of this article, we will refer to PREFIX(x) as an interval. Also, given an identification number i, checking whether i is in PREFIX(x) can be done inProof. Let v j be a vertex in OutNeigh(v i ). By the definition of the exactmatch overlap graph, 1 |s i ||ov max (s i ,. This implies that v j  PREFIX(s i [ +1,|s i). On the other hand, let v j be any vertex in PREFIX(s i [ +1,|s i), it is easy to check that v j  OutNeigh(v i ). Hence, OutNeigh). From Property 3.2, it follows that we can represent OutNeigh(v i ) by at most  non-empty intervals, which need at most 2logn bits to store. Therefore, it takes at most 2nlogn bits to store the exact-match overlap graph. However, given two vertices v i and v j , it takes O() time to retrieve (v i ,v j ) because we have to sequentially check if v j is in). But if OutNeigh(v i ) can be represented by k disjoint intervals then the task of retrieving (v i ,v j ) can be done in O(logk) time by using binary search. In Lemma 3.1, we show that OutNeigh(v i ) is the union of at most 21 disjoint intervals.Proof. There are only two possible cases that can happen to x and y.
H.Dinh and S.RajasekaranProof. We say interval. By the construction of I i , it is trivial to see that. Conversely, it is enough to show thatfor any 1  i  . This can be proved by induction on vertices in each tree of the forest. For the base case, obviously each leaf interval, assume that all of its child intervals are subsets ofis a union of all of the intervals in I i and all of its child intervals. Therefore,. Secondly, we show that the intervals in A are pairwise disjoint. It is sufficient to show that any interval in I i is disjoint with every interval in I j for i = j. Obviously, the statement is true if=. Let us consider the case where one contains the other. Without loss of generality, we assume that. Consider two cases:is the parent of. By the construction of I i , any interval in I i is disjoint from. By the construction of I j , any interval in I j is contained in. Therefore, they are disjoint.From the result in Case 1, any interval in I it is disjoint fromfor 1  t  h. So any interval in I i is disjoint from. We already know that any interval in I j is contained in. Thus, they are disjoint. Finally, we show that the number of intervals in A is no more than 21. Clearly, |A|=  i=1 |I i |. It is easy to see that the number of intervals in I i is no more than the number of children ofplus one, which is equal to the degree of the vertex associated withif the vertex is not a root of a tree in the forest, and equal to the degree of the vertex plus one if the vertex is a root. Let q be the number of trees in the forest. Then,2|E|+p, where d i is the degree of the vertex associated withand E is the set of the edges of the forest. We know that in a tree the number of edges is equal to the number of vertices minus one. Thus, |E|=q. Therefore, |A|2q  21. This completes our proof.The above proof yields an algorithm for computing the disjoint intervals starting from the forest of intervals. Once the forest is built, outputting the disjoint intervals can be done easily at each vertex. However, designing a fast algorithm for constructing the forest is not trivial. In the Subsection 3.2.2, we will discuss an O(log)-time algorithm for constructing the forest. Thereby, there is an O(log)-time algorithm for computing the disjoint intervalsTheorem 3.1 suggests a way of storing OutNeigh(v i ) by at most (21) disjoint intervals. Each interval takes 2logn bits to store its lower bound and its upper bound, and log bits to store the weight. Thus, we need 2logn++log to store each interval. Therefore, it takes at most (21)(2logn++log) bits to store each OutNeigh(v i ). Overall, we need (21)(2logn++log)n bits to store the exact-match overlap graph. Of course, the disjoint intervals of each OutNeigh(v i ) are stored in sorted order of their lower bounds. Therefore, the operation of accessing an edge (v i ,v j ) can be easily done in O(log) time by using binary search.
Algorithms for constructing the compact data structureIn this section, we describe two algorithms for constructing the data structure representing the exact-match overlap graph. The run time of the first algorithm is O(nlogn) and it only uses O() extra memory, besides nlog||| bits used to store the n input strings. The second algorithm runs in O(n) time and requires O(n) extra memory. As shown in Section 3.1, the algorithms need two routines. The first routine computes PREFIX(x) and the second one computes the disjoint intervals described in Lemma 3.1.
Computing interval PREFIX(x)In this subsection, we consider the problem of computing the interval PREFIX(x), given a string x and n input strings s 1 ,s 2 ,...,s n of the same length in lexicographical order. We describe two algorithms for this problem. The first algorithm takes O(|x|logn) time and O(1) extra memory. The second algorithm runs in O(|x|) time and requires O(n) extra memory. The first algorithm runs in phases. In each phase, it considers one of the symbols in x. In the first phase, it considers xand obtains a list of input strings for which the first symbol is x. Since the input strings are in sorted order, this list can be represented as an interval. Followed by this, in the second phase the algorithm considers x. From out of the strings in the interval, it identifies strings whose second symbol is. These strings will form an interval; and so on. The interval that results at the end of the k-th phase (where k =|x|) is PREFIX(x). In each phase, binary search is used to figure out the right interval. In the second algorithm, a trie is built for all the input strings. Each node in the trie corresponds to a string u and the node will store the interval for this string (i.e. the node will store a list of input strings for which u is a prefix). For any given x, we walk through the trie tracing the symbols in x. The last node visited in this traversal will have PREFIX(x) (if indeed x is a string that can be traced in the trie).
Memory-efficient overlap graphA binary search based algorithm: let [a i ,b i ]=PREFIX(x) for 1  i |x|. It is easy to see that PREFIX(x) =are in lexicographical order for 1  i |x|. Another observation is thatis the interval where the symbol xappears consecutively in stringis determined by searching for the symbol xin the string Col i. This can be done easily by first using the binary search to find a position in the string Col iwhere the symbol xappears. If the symbol xis not found, we return the empty interval and stop. If the symbol xis found at position c i , then a i (respectively b i ) can be determined by using the double search routine in string) as follows. We consider the symbols in the stringis the symbol xbut the symbol Col i [c i 2 j+1 ] is not. Finally, a i is determined by using binary search in string Col i. Similarly, b i is determined. The pseudo-code is given as follows.. Analysis: as we discussed above, it is easy to see the correctness of the algorithm. Let us analyze the memory and time complexity of the algorithm. Since the algorithm only uses binary search and double search, it needs O(1) extra memory. For time complexity, it is easy to see that computing the intervaltime because both binary search and double search take O(log(b i1 a i1 )) time. Overall, the algorithm takes O(|x|logn) time because there are at most |x| steps.
A trie-based algorithm: as we have seen in Subsection 3.2.1, to compute the intervalfor symbol x, we use binary search to find the symbol xin the interval. The binary search takes O(log(b i1 a i1 )) = O(logn) time. We can reduce the O(logn) factor to O(1) in computing the intervalby pre-computing all the intervals for each symbol in the alphabet and storing them in a trie. Given the symbol x, to find the intervalwe just retrieve it from the trie, which takes O(1) time. The trie is defined as follows (). At each node in the trie, we store a symboland its interval. Observe that we do not have to store the nodes that have only one child. These nodes form chains in the trie. We will remove such chains and store their lengths in each remaining node. As a result, each internal node in the trie has at least two children. Because each internal node has at least two children, the number of nodes in the trie is no more than twice the number of leaves, which is equal to 2n. Therefore, we need O(n) memory to store the trie. Also, it is well known that the trie can be constructed recursively in O(n) time. It is easy to see that once the trie is constructed, the task of finding the intervalfor each symbol xtakes O(1) time. Therefore, computing PREFIX(x) will take O(|x|) time.
Computing the disjoint intervalsIn this subsection, we consider the problem of computing the maximal disjoint intervals, given k intervalswhich either are pairwise disjoint or contain each other. As discussed in Section 3.1, it is sufficient to build the forest of the k input intervals. Once the forest is built, outputting the maximal disjoint intervals can be done easily at each vertex of the forest. The algorithm works as follows. First, we sort the input intervals in non-decreasing order of their lower bounds a i. Among those intervals whose lower bounds are equal, we sort them in decreasing order of their upper bounds b i. So after this step, we have (i)Since the input intervals are either pairwise disjoint or contain each other, for any two intervalscan be found by binary search, which takes at most O(logk) time. Furthermore, assume thatis the smallest ancestor, then the set of ancestors ofBased on these observations, the algorithm can be described by the following pseudo-code. 1. Sort the input intervals [a i ,b i ] as described above. 2. Initialize A =. /* A is the set of ancestors of current interval
H.Dinh and S.Rajasekaran11. Assume that the smallest interval is: as we argued above, the algorithm is correct. Let us analyze the run time of the algorithm. Sorting the input intervals takes O(k logk) time by using any optimal comparison sorting algorithm. It is easy to see that finding the smallest interval from the set A dominates the running time at each step of the loop, which takes O(logk) time. Obviously, there are k steps so the run time of the algorithm is O(k logk) overall. Notice that the sorted list of the intervals is actually a pre-order traversal of the forest. So the time complexity of the algorithm after sorting the intervals can be improved to O(k). However, the improvement does not change the overall time complexity of the algorithm since sorting the intervals takes O(k logk) time.
Algorithms for constructing the compact data structureIn this subsection, we describe two complete algorithms for constructing the data structure. The algorithms will use the routines in Subsections 3.2.1 and 3.2.2. The only difference between these two algorithms is the way of computing PREFIX. The first algorithm uses the routine based on binary search to compute PREFIX and the second one uses the trie-based routine. The following pseudo code describes the first algorithm. 1. for i = 1 to n do 2.),...,PREFIX(s i) by using the routine in Subsection 3.2.2. 6. end for An analysis of the time and memory complexity of the first algorithm follows. Each computation of PREFIX in line 3 takes O(logn) time and O(1) extra memory. So the loop of line 2 takes O(logn) time and O() extra memory. Computing the disjoint intervals in line 5 takes O(log) time and O() extra memory. Since   , the run time of loop 2 dominates the run time of each step of loop 1. Therefore, the algorithm takes O(nlogn) time and O() extra memory in total. The second algorithm is described by the same pseudo code above except for line 3 where the routine of Subsection 3.2.1 for computing PREFIX(s i) is replaced by the trie-based routine of Subsection 3.2.1. Let us analyze the second algorithm. Computing PREFIX in line 3 takes O() time instead of O(logn) as in the first algorithm. With a similar analysis to that of the first algorithm, the loop of line 2 takes O() time and O() extra memory. Constructing the trie in line 1 takes O(n) time. Therefore, the algorithm runs in O(n) time. We also need O(n) extra memory to store the trie. In many cases, n is much larger than . So the algorithm takes O(n) extra memory. It is possible to develop a third algorithm by revising the step in line 2 to line 4 in the pseudo code that computes the set of intervals of the suffixes of each input string s i. The revision is based on suffix trees and the binary search-based algorithm given in Subsection 3.2.1. The idea is to build a suffix tree for every input string s i. Note that every leaf in the suffix tree corresponds to a suffix of the input string s i. After building the suffix tree, we populate every leaf in the suffix tree with the corresponding interval by traversing the suffix tree and computing the interval for each node in the suffix tree given the interval for its parent. Finally, we output the intervals for those suffixes whose lengths are no less than the overlap threshold  = . It is easy to see that the time needed to determine the interval for any node in the suffix tree is O(logn) given the interval for its parent. Because the suffix tree has O() nodes, it takes O(logn) time to compute intervals. In addition, it takes O() time to build the suffix tree and O(log) time to find the disjoint intervals. Since    n, we will spend O(logn) time for each input string s i. As a result, the entire algorithm will run in time O(nlogn). Also, the entire algorithm will take O() extra memory because each of the suffix trees takes O() memory. In practice, logn is smaller than  and hence this algorithm could also be of interest.
RESULTSWe have implemented a DNA sequence assembler named Largescale Efficient DNA Assembly Program (LEAP) that incorporates our data structure for the overlap graphs. The assembler has three stages: preprocess input DNA sequences, construct overlap graph and assemble. In the context of DNA sequence assembly, the input DNA sequences are called reads. In the first stage, we add the reverse complement strings of the reads. Then we sort them and remove contained reads. The second stage is the main focus of our article, constructing the data structure of the overlap graph. The last stage basically analyzes the overlap graph, then retrieves unambiguous paths and outputs the contigs accordingly. We tested our assembler on simulated data as follows. First, we simulated a genome G. Then each read of length is drawn from a random location in either G or the reverse complement of G. Reads drawn from the genome are error-free reads. The number n of the drawn reads is determined by the coverage depth, c, by the equation n = c |G| . We considered three datasets with the same read length = 100, the same coverage depth c = 20 and different genome sizes: 238 Mb, 1 GB and 3.3 GB. The number of reads in the datasets is 47.6 million, 200 million and 660 million, respectively. The size of the first genome is approximately the size of human chromosome 2. The size of the third genome is approximately the whole human genome size. For the first and the second dataset, we have run our assembler with varying values of the overlap threshold : 30, 40, 50, 60 or 70. We only tried the overlap threshold  = 30 for the last dataset because the run time was quite long, about 2.4 days. To assess the quality of the contigs, we aligned them to the reference genome and found that all the contigs appeared in the reference genome. We have run our assembler on a Ubuntu Linux machine of 2.4 GHz CPU and 130 GB RAM. To save memory usage, we choose the binary search-based algorithm to construct the overlap graph in the second stage. The details are provided in Tables 1 and 2. The DNA sequence assembler developed by Simpson and Durbin (2010) also employs the overlap graph approach. Their assembler, named String Graph Assembler (SGA), uses the suffix array and FM-index for the entire read set to construct the overlap graph. This article reported that the bottleneck in terms of time and memory usage was in constructing the suffix array and FM-index that required 8.5 h and about 55 GB of memory on the first dataset. The total processing time was 15.2 h. On the third dataset, they estimated by extrapolation that the step of constructing the suffix array and FM-index would require about 4.5 days and 700 GB of memory. The total processing time on the third dataset would be more than that. However, SGA has been improved in terms of memory efficiency since its first version was released. Unfortunately, while the second version of SGA improves memory usage, its run time increases. We were able to run the latest version of SGA on the same machine on the datasets. The source code of the latest version of SGA can be foundprovides the time and memory comparison between the assemblers. For all of the datasets, we have run the two assemblers with the same overlap threshold  = 30. The contigs output by the two assemblers were almost the same.
Memory-efficient overlap graph
CONCLUSIONWe have described a memory-efficient data structure that represents the exact-match overlap graph. We have shown that this data structure needs at most (21)(2logn++log)n bits, which is a surprising result because the number of edges in the graph can be (n 2 ). Also, it takes O(log) time to access an edge through the data structure. We have proposed two fast algorithms to construct the data structure. The first algorithm is based on binary search and runs in O(nlogn) time and takes O() extra memory. The second algorithm, based on the trie, runs in O(n) time, which is slightly faster than the first algorithm, but it takes O(n) extra memory to store the trie. The nice thing about the first algorithm is that the memory it uses is mostly for the input strings. This feature is very crucial for building an efficient DNA assembler. We are also developing our assembler LEAP that incorporates the data structure for the overlap graph. The experimental results show that our assembler can efficiently handle datasets of size equal to that of the whole human genome. Currently, our assembler works for error-free reads. In reality, reads usually have errors. If the error rate is high, our assembler may not work well. However, with improving accuracy in sequencing technology, the error rate has been reduced. If the error rate is low enough, we will have many error-free reads, which means that our assembler will still work in this case. Also, an alternative way to use our assembler is to first correct the reads before feeding them to our assembler. In future, we would like to adapt our assembler to handle reads with errors as well.
The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
