Motivation: Advances in Next-Generation Sequencing technologies and sample preparation recently enabled generation of high-quality jumping libraries that have a potential to significantly improve short read assemblies. However, assembly algorithms have to catch up with experimental innovations to benefit from them and to produce high-quality assemblies. Results: We present a new algorithm that extends recently described EXSPANDER universal repeat resolution approach to enable its applications to several challenging data types, including jumping libraries generated by the recently developed Illumina Nextera Mate Pair protocol. We demonstrate that, with these improvements, bacterial genomes often can be assembled in a few contigs using only a single Nextera Mate Pair library of short reads. Availability and implementation: Described algorithms are implemented in Cþþ as a part of SPAdes genome assembler, which is freely available at bioinf.spbau.ru/en/spades.
IntroductionIn an article titled 'De novo fragment assembly with short matepaired reads: Does the read length matter?',argued that availability of paired reads with long and accurate insert sizes (rather than the increase in the read length) is the most important factor for improving the quality of short read assemblies. However, while paired reads with long insert sizes have been extensively used in many assembly projects, robust generation of readpairs with accurate insert sizes proved to be difficult and have only been achieved recently. The recently emerged sample preparation technologies open new opportunities for genome assembly from short reads. For example, Illumina Nextera Mate Pair protocol generates long inserts (3 kb and longer) that feature rather tight insert size distribution and small rate of non-circularized fragments that result in read-pairs with abnormal distances. As discussed in, such read-pair libraries may enable assemblies approaching the quality of assemblies from long reads of length equal to the insert size. Moreover, they can potentially substitute the existing assembly approaches based on a combination of short paired-end libraries (with insert size less than 1 kb) and long jumping libraries (with insert sizes typically longer than 1 kb) by a pipeline based on a single Nextera Mate Pair library. However, even though the popular assembly algorithms perform well with the previously proposed approaches to sample preparation, they have not kept up with recent experimental innovations. To catch up, bioinfomaticians either need to design novel tools for every technology improvement or to develop a universal assembler that can be easily modified to support new data types. For example, Ray () and SPAdes () is based on the path extension framework that was proposed by the authors of the Ray assembler () and later implemented in the Telescoper () and PERGA () assemblers. Given a path P in the assembly graph (), EXSPANDER iteratively attempts to grow it by choosing one of its extension edges (all edges starting at the terminal vertex of the path P). The assembly graph is defined as simplified de Bruijn graph () of k-mers in reads after removal of bulges, tips and chimeric edges. To extend a path P, EXSPANDER computes the scoring function Score P e for each extension edge e using read-pairs with one read mapping to P and another read mapping to e (further referred to as (P, e)-connecting read-pairs). Afterward, EXSPANDER decides whether to select the top-scoring extension edge or to stop growing P. It iteratively repeats the path extension procedure starting with single-edge paths until every edge in the assembly graph is covered by at least one path and no path can be extended further. To generate equivalent contigs on both strands, EXSPANDER is implemented as a bidirectional approach that can extend a path in both directions. While the scoring function Score P e described in Prjibelski et al.(2014) works well with short libraries, it appears to be rather inefficient when using jumping libraries. The key limitation of the previously defined scoring function is that it analyses only (P, e)connecting read-pairs (where e is an extension edge of path P) and ignores read-pairs that connect path P with other edges. When an edge e is short and the variations in the insert sizes are large, there is a danger that no (P, e)-connecting read-pairs exist and thus ScoreP; e  0 even if e is the correct extension edge (). Thus, the decision rule may stop extending path P or even select an incorrect extension edge. Additionally, the approach described inis inapplicable for scaffolding procedure, since it is unable to jump over coverage gaps. In this article, we extend the EXSPANDER approach to scaffolding. This extension is important since scaffolding with jumping libraries may dramatically improve the assembly quality. We describe several algorithms that address these bottlenecks based on the following idea. Consider a set of extension paths E [rather than extension edges as in] that contain all sufficiently long paths (longer than the insert size) starting from the extension edges of the path P. Once the set E is constructed, we choose the best-scoring path E in E and extend path P by the first edge of E. Our analysis has shown that such conservative extension (by the first edge of the best-scoring extension path rather than by the entire path) provides more accurate assemblies. To perform scaffolding procedure, we allow extension paths to 'jump' over coverage gaps in the assembly graph. This intuitive approach, while appealing, is often impractical since the assembly graph is usually tangled, resulting in a prohibitively large number of extension paths. To reduce the running time, we have implemented the new algorithm based on the observation that, instead of the exhaustive search through the set of all extension paths, one can significantly prune this set using single reads and paired-end libraries (if available). We demonstrate that the new algorithm enables assemblies of nearly complete genomes from a single Nextera Mate Pair library. We also show that SPAdes, coupled with the improved EXSPANDER algorithm, outperforms other popular assemblers, such as ABySS (), IDBA-UD (), Ray (), SOAPdenovo () and Velvet () on various types of datasets.
Methods
The exSPAnder framework
RectanglesEXSPANDER utilizes the concept of the rectangle graph introduced byand further developed in (). Let e and e 0 be edges in the assembly graph (see () for the construction of the assembly graph) separated by a known distance D and r; r 0  be a read-pair, such that read r maps to e at position x 0 and read r 0 maps to e 0 at position y 0 (). We note that while D is not known a priori, EXSPANDER only considers edges that are connected by a previously constructed path, which unambiguously defines distance D.shows the read-pair r; r 0  represented as a point (x 0 , y 0 ) within the rectangle formed by the edges e and e 0. We further refer to this rectangle simply as e; e 0 . Because of variations in the insert sizes, real read-pairs connecting edges e and e 0 typically correspond to the points that are scattered in the confidence stripa strip between the 45 lines y  x  d min and y  x  d max within the rectangle e; e 0  (), whereHere, I min ; I max  is the confidence interval of the insert size distribution defined as the smallest insert size interval that contains at least 80% of read-pairs. Since reads may have variable lengths (e.g. after quality trimming or error correction), we set ReadLength as the maximal read length across all reads in the current library.
The decision ruleThe decision rule relies on the scoring function that will be described in the next section. To extend a path P, we score all extension edges e 1 ;. .. ; e n and select e i as a correct extension if the following conditions are met: 1. Score P e i  > C  Score P e j  for all j 6  i 2. Score P e i  > H Here, C and H are the EXSPANDER parameters described in (). If no extension edge meets these conditions, the algorithm stops growing path P.
Assembling jumping librariesIn the case of multiple read-pair libraries, we process them in the order of increasing insert sizes until a certain library provides an extension edge satisfying the decision rule. We stop growing path P if no library provides an extension edge satisfying this rule. Processing libraries in a step-by-step fashion (rather than incorporating all libraries at once) has proven to result in more accurate and continuous assemblies.
Scoring functionGiven a path P  p 1 ; p 2 ;. .. ; p n  and its extension path E  e 1 ; e 2 ; .. . ; e m , the composite rectangle for paths P and E is formed by n  m simple rectangles (p i , e j ) (). The distance D ij between a pair of edges p i and e j according to the paths P and E is equal toWe define the following variablesThus, EXSPANDER ignores rectangles with a density lower than a pre-defined threshold W. While this approach worked well for short libraries, our benchmarking revealed that it deteriorates for long jumping libraries that typically have a higher rate of read-pairs with abnormal insert sizes (referred to as chimeric read-pairs). We thus define a new support function that evaluates whether a simple rectangle (p i , e j ) within the composite rectangle (P, E) can be considered as trusted and used for calculating the scoring function: Support Dij p i ; e j   1; Observed Dij p i ; e j  > g 0; otherwise (where g is a user-controlled parameter with very conservative default value g  30. While it is not clear how to select optimal g, our analysis of the distribution of the number of chimeric points within all rectangles across a wide range of bacterial genomes revealed that hardly any rectangles contain more than 30 chimeric points. We note that by setting the parameter g, one essentially ignores the contribution from small rectangles containing less than g points. While it may appear that we unfairly ignore small rectangles, our benchmarking revealed that this approach actually improves the assembly quality. Moreover, the users can change the parameter g in the case of assembly projects with unusually low or high coverage. When the extension path contains a single edge e, EXSPANDER uses the following path-edge scoring function:In this article, we generalize this path-edge scoring function to a pathpath scoring function as follows:Given a confidence interval I min ;I max  of the insert size distribution, we call a path long if its length exceeds I max and short otherwise. The algorithm that we describe below limits attention to the long extension paths e 1 ; e 2 ;. .. ; e m  whose prefix e 1 ; e 2 ;. .. ; e m1  is short. Given a path P, for each extension edge e i of P, we construct a set of extension paths E. A top-scored path E in E is called a representative path for edge e (). The score of the extension edge e is now defined as the score of its representative path, i.e. Score P e  Score P E. The new approach to define Score P e can be applied to the libraries with both short and long insert sizes. While the resulting improvements are significant for long insert sizes, they appear to be minor for the libraries with small insert sizes. Thus, in the default EXSPANDER mode, the new scoring function is used only for the jumping libraries.(d)
Constructing extension pathsIn the case of long libraries, the Depth-First Search (DFS) algorithm for exploring all paths and selecting representative paths becomes rather slow, e.g. the number of extension paths can reach millions even for a bacterial genome. To decrease the number of extension paths, we developed the ExtensionSearch algorithm that uses a set of pre-constructed paths S that are generated by the previous EXSPANDER algorithm () using single reads and short paired-end libraries if they are available. We use the notation Suffix(E, l)As the result, we obtain a set of extension paths that 'comply' with the set of pre-constructed paths S with length at least I max (d). ExtensionSearch greatly reduces the number of the extension paths when compared with the DFS algorithm. However, in the tangled regions of the assembly graph with many bulges (corresponding to variations in repeats) and loops (corresponding to tandem duplications), the number of paths is still high (). For example, each bulge potentially doubles the number of extension paths explored by the EXSPANDER algorithm (e.g. ExtensionSearch can select either of edges e 1 and e 2 in). Each loop potentially multiples the number of extension paths by the (unknown) multiplicity of the loop (i.e. the number of times the loop traverses the edge e 2 in). In the ExtensionSearch, we focus only on simple bulges () and simple loops () since they represent the majority of all cases that may trigger the increase in the running time of the algorithm. To limit the explosion of the extension paths, we add the following constrains to the ExtensionSearch algorithm: @BULLET For each bulge formed by two edges, only the top-scoring edge is used as an extension edge. @BULLET Each simple loop is traversed as a fixed number of times equal to the estimated multiplicity of the loop. The loop multiplicity is estimated as the closest integer to C loop =C local , where C loop is the average read coverage of the loop edges, and C local is the read coverage in the vicinity of the loop, i.e. the average read coverage of the last ReadLength nucleotides of edge e and first ReadLength nucleotides of edge e 0 ().Our benchmarking has demonstrated that the described modifications reduce the running time by an order of magnitude.
Scaffolding
Jumping over the coverage gapsExisting genome assemblers are often complemented by scaffolding tools such as Bambus (), Opera (), SCARPA (), SOPRA () and SSPACE () to improve the contiguity of the resulting assemblies. However, most of these scaffolding tools work with contigs rather than the assembly graphs and none of them uses the rectangle framework that EXSPANDER utilizes. We thus added a rectangle-based scaffolder to EXSPANDER and evaluated its performance. Jumping from an out-tip to an in-tip. A coverage gap typically creates a pair of tips in the assembly graphformed by an out-tip (an edge that ends in a vertex with out-degree 0) and an in-tip (an edge that starts in a vertex with in-degree 0). We further refer to these tips as paired tips. Since coverage gaps are usually short, read-pairs from the jumping libraries often span them. Below we describe how ExtensionSearch finds pairs of tips and uses them for scaffolding. Let E be an extension path for a path P, such that E ends with an out-tip e and LengthE < I max (). To further extend path E, we search for an in-tip paired with e by considering a set of P-supported edges, i.e. all edges e 0 that have P; e 0 -connecting. At each step, the ExtensionSearch algorithm grows an extension path E (that is shorter than I max ) using only E-consistent extension edges (with respect to S)Assembling jumping librariesread-pairs. Since the set of P-supported edges typically contains many false short edges (due to high rate of chimeric read-pairs in the jumping libraries), we filter out all P-supported edges shorter than a certain threshold (default value is 500 bp).presents a simple example when there is only one Psupported edge e 0 and this edge is an in-tip. We then consider e and e 0 as paired tips and extend the path E by edge e 0 with a gap (). Since the size of a gap is difficult to estimate using a jumping library with large insert size variation, we assign a fixed length to each gap (100 bp by default). Once we extended the path E with an edge, we continue growing E using ExtensionSearch until its length exceeds I max. Jumping from an out-tip to an internal edge. A more difficult (and more common) case is illustrated in, where there exists only one P-supported edge e 0 and this edge is not an in-tip. Such situations arise when the in-tip paired with e is either not P-supported or is shorter than 500 bp (and thus ignored). To grow the path E in such cases, we consider all in-tips in the assembly graph and extend them further using ExtensionSearch limiting the path length to I max  LengthE. Afterward, we select only paths that contain edge e 0 and use them as potential extensions for E (). When assembling real datasets, we often encounter several P-supported edges longer than 500 bp. In this case, we apply the strategy described above, i.e. extend the paths starting from every in-tip and choose paths containing at least one P-supported edge. If some of the extension paths remain shorter than I max , we continue growing them with the ExtensionSearch algorithm. However, growing paths from every in-tip can be extremely time-consuming, especially for single-cell datasets that often contain thousands of coverage gaps. To address this issue, we implement the described approach the other way around: instead of starting a path from every in-tip, we start growing paths from P-supported edges in the reverse direction and select only those that reach an in-tip. Since the number of long P-supported edges is typically much smaller than the number of all in-tips in the assembly graph in the case of singlecell assemblies, this implementation greatly reduces the running time of EXSPANDER.
Jumping over complex subgraphsEven after applying the described heuristics for run-time reduction, there are cases when the number of extension paths remains huge. Such cases are often associated with complex subgraphs of the assembly graph (typically formed by short repeats with high multiplicities). To keep the running time under control, EXSPANDER stops growing a path if the number of its extension paths exceeds a threshold. The threshold is automatically calculated based on the number of edges in the assembly graph (e.g. the threshold value is set to 50 for graphs with > 10 000 edges). A better approach is to use jumping libraries and to 'jump over' complex subgraphs in the assembly graph (instead of generating all extension paths traversing these complex subgraphs). If the 'size' of a complex subgraph is smaller than the insert size, a path P may start on 'one side' of this subgraph and be connected with edges on the 'other side' of this subgraph, thus allowing us to jump over the entire subgraph and to continue growing P. The question is how to identify such complex subgraphs and jump over them. To jump over complex subgraphs, we first identify a path P with unusually large number of extension paths. Afterward, we find all P-supported edges and order them using the rule: an edge e 0 follows an edge e if e 0 can be reached by ExtensionSearch within a certain distance starting from e. If all P-supported edges can be ordered into a single list, we extend path P by the first edge in this list (with a gap).
ResultsTo evaluate how availability of Nextera Mate Pair libraries affects the quality of assembly, we assembled several bacterial genomes using multicell datasets provided by Illumina (Nextera Mate Pair libraries only). In this article, we describe benchmarking (using seven different assemblers and three scaffolders) on Meiothermus ruber str. 21T () Nextera Mate Pair library and additionally, on Escherichia coli st. K12 subst. MG1655 () single-cell dataset that contains both a short paired-end library and a long jumping library. Results for other Nextera Mate Pair libraries are presented in the Supplementary Material. Since the assemblers we used for comparison were not designed for assembling Nextera Mate Pair libraries, we have conducted. Jumping over coverage gaps in the assembly graph from an out-tip to an in-tip: (a) an extension path E (marked red) ending with an out-tip e; (b) the only P-supported edge e 0 is an in-tip (marked green); (c) the path E is extended by an edge e 0 with a gap (red line). Jumping over coverage gaps in the assembly graph from an out-tip to an internal edge: (d) the only P-supported edge e 0 is not an in-tip (marked green) and (e) paths E 1 and E 2 that start with in-tips and contain P-supported edge e 0 , both paths are considered as possible extensions for E (shown by red lines) additional optimization and selected the optimal k-mer sizes (with respect to N50) to ensure fair benchmarking with these assemblers. We ran ABySS 1.3.6 (), Ray 2.0.0 (), SOAPdenovo 2.0.4 (), Velvet 1.2.10 () and Velvet-SC () (based on Velvet 0.7.62, released on March 11, 2011) with the kmer sizes 59, 57, 71, 99 and 105, respectively. Iterative de Bruijn graph assemblers IDBA-UD 1.1.1 (), SPAdes 3.0.0 (with the previous version of EXSPANDER (and SPAdes 3.5.0 (that implements the new algorithm described in this article) were run with the default parameters. In addition to scaffolds, we also provide information about contigs generated by SPAdes 3.5 (referred to as SPAdes 3.5 ctg). We have also included results for such popular scaffolders as Opera 2.0 (), SCARPA 0.241 () and SSPACE 3.0 (). To perform a fair comparison, we ran all scaffolders on the contigs that were assembled by SPAdes 3.5.0 using all data as single-end reads (discarding read-pair information). The resulting assemblies were evaluated with QUAST 2.3 () using standard metrics: NGA50 (NG50 corrected for assembly errors), the total number of scaffolds in the assembly, the size of the largest scaffold, the number of misassemblies, the fraction of genome covered and the number of uncalled bases (N) in the assembly.benchmarks various assemblers on M.ruber Nextera Mate Pair library (mean insert size 3.6 kb). Some of the assemblers used in the comparison produce rather inaccurate assemblies (e.g. 95 misassemblies for Ray and 244 misassemblies for SOAPdenovo). Also, some assemblers generate very large number of unspecified symbols N (ABySS, Ray, SOAPdenovo and Velvet). Interestingly, most assemblers showed rather unstable behavior with Nextera Mate Pair libraries with exception of IDBA-UD and SPAdes (originally developed as single-cell assemblers). SPAdes  EXSPANDER assembles an almost complete M.ruber genome with less than 0.03% of unspecified nucleotides and the largest scaffold capturing more than 93% of the genome. SPAdes generates similar high-quality assemblies on all Nextera Mate Pair libraries (see Supplementary Material) and often results in assemblies of very few contigs with the quality that approaches the quality of the assemblies from long Pacific Biosciences reads (). Thus, Nextera Mate Pair libraries provide a valuable low-cost trade-off when compared with the assemblies that use Pacific Biosciences reads. In Table 2, we also present a comparison between selected tools on E.coli single-cell dataset with paired-end and jumping libraries. In addition, we ran ALLPATHS-LG () (build 47561, released on September 15, 2013) with the default parameters using both libraries together. As
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
