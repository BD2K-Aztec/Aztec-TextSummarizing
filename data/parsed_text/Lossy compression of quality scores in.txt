Motivation: Next-generation sequencing technologies are revolutionizing medicine. Data from sequencing technologies are typically represented as a string of bases, an associated sequence of per-base quality scores and other metadata, and in aggregate can require a large amount of space. The quality scores show how accurate the bases are with respect to the sequencing process, that is, how confident the sequencer is of having called them correctly, and are the largest component in datasets in which they are retained. Previous research has examined how to store sequences of bases effectively; here we add to that knowledge by examining methods for compressing quality scores. The quality values originate in a continuous domain, and so if a fidelity criterion is introduced, it is possible to introduce flexibility in the way these values are represented, allowing lossy compression over the quality score data. Results: We present existing compression options for quality score data, and then introduce two new lossy techniques. Experiments measuring the trade-off between compression ratio and information loss are reported, including quantifying the effect of lossy representations on a downstream application that carries out single nucleotide poly-morphism and insert/deletion detection. The new methods are dem-onstrably superior to other techniques when assessed against the spectrum of possible trade-offs between storage required and fidelity of representation. Availability and implementation: An implementation of the methods described here is available at https://github.com/rcanovas/
INTRODUCTIONGenome sequencing methods have evolved at the same astonishing rate as computing technology. Next-generation devices parallelize the process, producing billions of sequences (reads) () and generating file sizes potentially in the terabyte range, at costs that are decreasing on a yearly basis. Each read is a fragment of data extracted from the processing of a single genome, represented as a string of bases. As well, a number of metadata fields are associated with each read. Some of these fields are more expensive to store than the sequence of bases.The mechanics of effectively storing and querying this information are fundamental to the field of bioinformatics (). Several standard formats to store genome data have been adopted, each aiming to be easy to manipulate and parse using text-processing tools such as Perl and Python. The most common are the FASTA and FASTQ formats () and the SAM/BAM formats ().
Quality scoresWe consider the problem of effectively representing the quality scores of a genome sequence. Quality scores are typically stored as a Phred-scaled base error probability (), calculated as 10  log 10 Prfbase is wrongg   . These are then typically scaled (Phred  33 or Phred  64) so that they can be represented as printable ASCII characters.shows examples for Phred  33, the scheme assumed in examples in this article. The probability that a base in a given position is wrong can be computed in different ways, and depends on the hardware and software that are used in the sequencer.shows an example of a short sequence of bases together with the corresponding quantized quality assessments. The higher the quality value, the lower the probability that the base at that position has been incorrectly called. For example, in, the first nucleotide of the sequence has a quality value equal to 70 (the symbol 'F' in the ASCII alphabet), which means that there is an estimated probability of approximately 10 7033=10 % 0:02% that the corresponding 'A' has been incorrectly sequenced.
CompressionWe consider two different compression modalities: lossless and lossy. Each has advantages and disadvantages, depending on the importance of the information that is stored and on the eventual use of the data. Lossless compression is the most common approach. It ensures that the decompressed data are exactly the same as the original, meaning that the compressed version must contain sufficient information for the decompresser to generate a byte stream identical to the one that was input to the compressor. Lossy compression mechanisms store an approximate representation of the input, trading loss in fidelity of reproduction for enhanced compression effectiveness. Lossy compression is typically only applied to signals that were originally continuous, for which the digital form of the signal already incorporates an element of quantization-generated approximation, such as image and sound data.If lossy compression is being considered, the maximum degree of information loss that can be tolerated needs to be specified as an input to the compressor. That requirement presupposes that a measure of loss has been defined, taking as its inputs two data sequences of the type being represented and providing (using some meaningful unit) a numeric score that summarizes the degree to which they differ.shows some of the measures that can be applied to pairs of '-element strictly positive sequences (). In all of them, if the two sequences are identical, the score is low (0, or, in the case of Max:Min Distance, 1); when the two sequences are different, the measure is higher. For example, for the two '  6-element sequences X  h70, 69, 70, 71, 69, 73i and Y  h70, 70, 70, 70, 70, 73i, the Mean Manhattan Distance is 0.5. The measures shown inwill be used in Sections 3 and 4 to evaluate, and in some cases control, the accuracy of lossy compression regimens for quality score sequences.
Bit encodingsOnce the set of symbols to be coded has been determined, the compressor encodes each symbol into a bit sequence. A fixedlength binary code or variable-length prefix-free code is used to represent the symbols contained in the data, with the choice dependent on the probability distribution that arises over the set of symbols. The simplest variable-length code is Unary, which represents a non-negative number x as x 1-bits, followed by a 0-bit. Unary has the advantage of being able to represent arbitrarily large values, but requires as many bits as the value being coded. The Elias Gamma code is more complex, but also more effective, with a value x represented as the concatenation of the length of the binary representation of x in Unary, and the binary representation of x  1, omitting its most significant bit (). The Golomb code also consists of a Unary/ Binary combination, but makes use of a parameter b, with the unary component storing the quotient q  x=b   , and a minimallength binary component storing the remainder r  x  bq. The parameter b is chosen according to the characteristics of the set of x values to be stored.shows examples of these codes, covering the first six integers. Note that the 3-bit Binary code is limited to inputs 0 x58 and assumes that all of the symbols have equal probability; the Unary, Gamma and Golomb codes assume that the symbol probabilities are non-increasing and place no upper limit on the values x that can be represented. If the symbol probabilities are not non-increasing as the distance from the origin increases, a permutation table can be used so that monotonicity can be maintained. Moffat anddescribe all of these mechanisms in detail.
Subsequent applicationsOne use of sequence data is to identify locations of variation from a specified reference sequence. These variations can assist with the determination of the genotype for each individual at each site, allowing, for example, the study of diseases (). The process of finding variations is known as single nucleotide polymorphism (SNP) and insert/deletion (indel) detection. The normal output of this process is a set of SNPs and indels, stored in a standard format such as variant call format (VCF) (). Each line in a VCF file represents a different variation, storing its position and allele in the reference genome, plus the bases related to the variation, a computed quality score and extra information about the variation. We use comparisons between generated VCF files as an applied evaluation of the effect that lossy compression of quality scores has on sequence data use.
PREVIOUS APPROACHESThe SLIMGENE tool presented bywas one of the first methods for independent compression of qualityMax : Min DistanceX, Y maxobserved that the quality sequences were quasi-random with mild dependence on score position, that some sequences finish with several '#' characters and also that there can be strong local correlations within individual records. In their proposal, a bit flag is stored per sequence to indicate whether the sequence is prefixed by a string of hashes. The hash prefix is removed and the rest of the sequence is stored using a Huffman code. They also proposed storing a modified version of the quality sequence, where equal consecutive values are stored as runs. For example, the sequence 'FFEGGGGGFHHFFFDE' shown inwould be transformed to 'FEGFHFDE', plus a list 1,0,4,0,1,2,0,0 of run-lengths. The new sequence and the vector of run-lengths are then stored using Huffman codes.examine several compression methods for compressing the quality field, and propose a new mechanism in which quality scores are transformed into a bin number, with each bin representing an interval. They present three lossy transformations: UniBinning, Truncating and LogBinning. The UniBinning approach creates uniform splits across the error probability distribution, that is, if the parameter is four (and two-bit Binary codes will be used), the first bin spans all quality values corresponding to error probabilities between 0 and 25%. The Truncating transformation separates all the quality values independently, creating a special bin for the l largest values, with l being a user-defined parameter. The LogBinning transformation is similar to UniBinning, but with the bins formed according to the logarithms of the probabilities, by constructing equal-sized segments according to quality values. After applying a binning transformation, Wan et al. form groups of k mapped quality values into a block, and prefix the block with a header containing some local information, depending on the lossless method used. Their MinShifting transformation stores the minimum quality value q min of each block, and the k values q of the block are each replaced by q  q min before being coded. The FreqOrdering transformation permutes all the quality values in each block according to their frequency, so that the most commonly occurring values are assigned the shortest codes when Gamma or Golomb are used. The third option considered byall the values of a block are changed to the difference-values presented by Kozanitis et al. Finally, after a lossy transformation and then a lossless mapping, Wan et al. use one of the coding regimens summarized in Section 1.3.describe the QualComp tool, which compresses quality scores based on the assumption that they are drawn from a Gaussian distribution () parameterized by the position of the quality value in the quality read, assuming that there is a mean and standard deviation for each position i 2 1, ' in the read. The mean and covariance matrix of the quality scores are extracted from the entire input, and singular value decomposition is applied to the covariance matrix to recover standard deviations to be used as parameters of the Gaussian. Once those parameters are decided, they are stored for use by the decoder, and used to derive the number of bits used to encode each quality value, by minimizing the mean square error of a rate distortion problem. This optimization problem is parameterized by a user input, which is the total number of output bits the quality scores can consume, expressed as a rate r. The solution to the problem specifies, for position i in a read, the number of bits, i , that should be used to encode the quality value in position i. For each quality value, if it is to be coded in i bits, the Gaussian for that position is split into 2 i regions of equal probability, and a bit pattern selected to indicate the region in which the quality value lies. The decoder reads in the Gaussian parameters and r, performs the optimization to recover the i values and then emits a representative corresponding to the region specified by each code word. Other approaches compress the quality scores depending on information of the read sequences.describe a simple lossless compression technique over the sequence and the quality fields, combining all distinct pairs of genomic base and respective quality value, and then using a Huffman code. That is, the DNA sequence and quality scores of an alignment are represented by a joint sequence of code words, one per each hbase, qualityi pair.present a lossy compression scheme based on the premise that, if a base in a read can be predicted by the context of the read, then the base and the respective quality need not be stored. To compute predictions, they use the BurrowsWheeler transform () and a longest common prefix array, together with a userdefined minimum context length. We also consider CRAM format files (). These files are generated using CRAMTOOLS, a suite of Java programs and interfaces that compress DNA sequence and quality data stored in SAM/BAM format, making use of an external reference genome. Sequences are stored as a difference relative to the external reference, and hence the external reference genome must be provided each time compression or decompression is undertaken. Several lossy options for storing quality scores are provided in the CRAMTOOLS suite. We explored three combinations: Preserve, Bin-Preserve and Match-Bin-Preserve. The Preserve mode only stores quality scores for reads whose mapping quality scores are higher than a user-defined threshold. The other two approaches are variations of Preserve, in which the prefix Bin means that the quality scores are stored using eight bins like Wan
ALGORITHMWe now present a lossy compression approach based on localized properties of the quality scores, following the lead established by. The new algorithms represent quality scores by separating them into blocks of variable size, where all the values contained in each block comply with a chosen parameter p according to some measure criterion. For each block, we store its length and a representative value. The representative value also depends on which measure is used. For example, if Mean Manhattan Distance () is used as the fidelity measure, blocks must be formed such that none of the values in each block are more than p from the corresponding representative value. That is, one possible configuration allows blocks to span a range of up to 2p  1 different quality scores, with the midpoint of each block's range taken as the representative value. Generalizing from this starting point, the use of other measures, or other values of p, results in different blocks being formed and hence different amounts of space being required for the set of quality scores, with different degrees of approximation to the original values.1: Representatives   2: RunLengths   3: block   4: block len 0 5: for i  0 ! '  1 do 6: if FulfillCriteriablock  qualityi, p then 7: block block  qualityi 8: block len block len  1 9: else 10:Algorithm 1 describes the proposed process, with '' used to represent the empty list, and with the '' operator used to append a single value to a list of the same type of object. To determine the block boundaries, a left-to-right greedy search is undertaken, seeking to make each block as long as possible, consistent with the constraints imposed by the chosen fidelity criterion and the chosen fidelity limit p. Method FulfillCriteria determines whether it is possible to include the next quality value in the current block, or whether it is necessary to start a new block; method CalculateRepresentative computes the best representative value for a given block, given that at least one valid representative exists. For example, if the measurement metric being used is Mean Manhattan Distance, then FulfillCriteriaqvals, p is implemented by computingwhere the range of i is 0 i5jqvalsj. Within a set that meets this criterion, the value rep  max i qvalsi  min i qvalsi 2 guarantees that the Mean Manhattan Distance for the whole sequence will be not greater than p. For any given block, there may also be other integer values rep0 for whichand in that case, method CalculateRepresentative is free to use a secondary criterion, such as minimizing the average distance between the selected representative and the block's values. We call this optionin which Mean Manhattan Distance is used in both FulfillCriteria and CalculateRepresentativethe P-Block mechanism and control it with the parameter p.illustrates the application of P-Block to the example sequence. As a second example of how Algorithm 1 might be instantiated, if a given upper bound r must be guaranteed using the Max:Min Distance metric, then FulfillCriteria qvals, r needs to check if an integral rep exists such that max i qvalsi=rep5r and rep=min i qvalsi5r. This R-Block approach, parameterized by a maximum ratio r, recognizes that it may be preferable to be more precise in representing low quality scores (when the base is assessed as being more likely to be in error) than high ones. After either of these transforms has been applied to an alignment, the k elements in the Representatives array are stored as a minimum and maximum, followed by k values relative to that range, using a Binary code of log 2 max k Representativesk  min k Representativesk  1 AE  bits per value. The k values in the RunLengths array are stored using the Gamma code. When p or r is sufficiently large, only one value is stored for each read, covering every quality value in that alignment. In related work, we have examined compression techniques for the other components of SAM/BAM-format files (Canovas), including the bases, and added a small index thatallows decoding to commence at every 500th read. The space used to store the index information is a small fraction of the total space required, and the functionality that it offers is not part of the experimentation that is reported here.
IMPLEMENTATIONWe compare the quality scores of the original file against the quality scores in a reconstructed file using different approaches and a range of fidelity measures (). The fidelity of a mechanism is computed by averaging all of the per-read scores generated for that measure. The quality scores associated with a version of the NA12878 genome are the primary test file used. In particular, we work with reads that were associated with chromosome 20 (That is, we extracted the quality score fields from the file NA12878.Hi.WGS.bwa.cleaned.recal.hg19.20.bam fetched from https://usegalaxy.org/library_common/browse_library?show_deletedFalse&cntrllerlibrary&use_panelsFalse &idf9ba60baa2e6ba6d.). To further validate our results, we also take genome HG01477 from the 1000 Genomes Project (ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/), using the reads that were aligned with chromosome 11; those results are presented in the Supplementary Material.gives details of two files of sequence quality values. As part of the processing pipeline used in the experimentation, we also made use of reference chromosomes chr11 and chr20 (Accessed from ftp://ftp.ncbi.nlm.nih.gov/sra/ reports/Assembly/GRCh37-HG19_Broad_variant/). The implementations explored include Wan et al.'s LogBinning and UniBinning, the QualComp mechanisms and our P-Block and R-Block approaches. We also include the CRAMTOOLS lossy models, in recognition of their extensive use in data repositories such as the 1000 Genomes Project. To establish a benchmark for lossless compression, results for GZip 9 are also included.shows the various trade-offs measured when fidelity is assessed using Mean Manhattan Distance;shows the same trade-off, but with the vertical scale changed to Max:Min Distance; andlikewise, but with fidelity measured using Mean Squared Error. Each of the implementations provides a trade-off 'knob' that adjusts the balance between fidelity and compression rate. The graphs are plotted using QualComp rates r  {0,0.5,1,2}; P-Block parameters p  {1,2,4,8,16,32}; R-Block ratios r  1  {0.05,0.1,0.2,0.4,0.8,1.6,3.2,6.4}; UniBinning thresholds b  {80,100}; and LogBinning thresholds b  {5,10,20,30,40,60}. For CRAM, lower bound mapping qualities of 40, 50 and 60 were used with the Preserve, Bin-Preserve and MatchBin-Preserve modes. The three components ofshow that the QualComp, P-Block and R-Block approaches outperform the other methods. The new approaches are particularly well suited to the Max:MinNote: The columns show the size of the sequence of extracted quality scores as ASCII bytes, the number of reads, the length of each read and the entropy (H 0 , in bits per quality score) of the quality sequence. Distance, as was the intention, while Ochoa et al.'s QualComp offers good performance when fidelity is quantified using Mean Squared Error. Worth noting is that QualComp offers a further modality, allowing the quality file to be separated into c clusters and QualComp applied to each cluster separately. The results obtained via this approach did not result in any appreciable difference in performance. We also analyze the effect of lossy compression of quality scores on a downstream application. For each lossy file generated, we compute its VCF (see Section 1.4) and compare it with the VCF generated from the original file. To compare two VCF files, we use the methodology ofand define a true positive (TP) as a variation that is found in both VCF files, a true negative as a location at which neither file records a variation, a false negative as a variation that is only found in the VCF of the lossless file and a false positive (FP) as a variation that is found only in the VCF of the lossy file. The TP values are further separated into half and equal TP, where equality is registered if the same variation is found in both VCF files, and half is registered if a variation is found in the same position in both files, but the type of variation is not exactly the same. In all our experiments the amount of 'half TP' was no higher than 0.004% of the total TP value, and they were included in the FP count without affecting the results. From these values the precision and recall of the processed sequence can be computed, given by Precision  TP=TP  FP and Recall  TP=TP  FN, respectively; they in turn can be combined into a single statistic known as an F-Score by combining them as F-Score  2PrecisionRecall=Precision  Recall.provides precision and recall scores for a selected range of methods applied to NA12878.chr20.qual, together with the F-Scores computed from them;plots F-Score as a function of compressed size, clearly illustrating the superiority of the new approaches. Similar results were obtained using the HG01477.chr11.qual file, included in the Supplementary Material. Asandillustrate, our two approaches outperform other techniques, that is, for a given level of precision or recall, the P-Block and R-Block methods allow more compact storage of quality values than do other mechanisms. For example, if 99.0% in both precision and recall is regarded as being a minimum threshold for having high-confidence in the outcomes, then of the methods compared, P-Block with p  4 generates the most compact representation. The 563 MB required for the quality values in that configuration is less than one-third of the space required by the lossless GZip approach.andalso include an additional point, labeled OneQual, showing what would happen if no quality scores at all were stored, and every quality value was assumed to be the average quality score from the input sequence. Note that the different methods all have comparable encoding and decoding speeds, and we do not compare them on that basis.
DISCUSSIONWe have described and measured the performance of a range of lossy compression techniques for quality scores. The QualComp approach, and our two new methods, offer superior trade-off options when fidelity is assessed according to the measures in. Our new approaches outperformed QualComp in the Max:Min Distance criteriona measure that is well-suited, we believe, to bioinformatics applications. Our experiments also quantified the extent to which use of lossy compression affected the performance of a typical downstream application of genetic data, and demonstrate that variation detection can still be reliably carried out, even with relatively compact storage of the quality scores.The approaches described here make use of sequentially greedy generation of blocks. One interesting question that we have not yet examined is whether mechanisms for globally optimal block construction will make a measurable difference in overall outcomes. Another area that we have not yet fully explored is the coding mechanisms used for the block representatives and for the block lengths; it may be that tailored codes (rather than Binary and Gamma) can offer further space savings once the particular characteristics of the data streams are taken into account. We are also interested in quantifying the effect that lossy compression has on other downstream applications of genetic sequencing data.
ACKNOWLEDGMENTSThe authors thank Idoia Ochoa-Alvarez for her assistance with QualComp; Vadim Zalunin for helping with the CRAMTOOLS usage; and Wei Shi and Jan SchroderSchroder for sharing their knowledge of the area. Finally, we thank the anonymous referees for their careful input.
The Author 2014. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
i ' maxXi, Yi minXi, Yi Mean Squared ErrorX, Y 1 ' P ' i1 X i  Y i  2 Chebyshev DistanceX, Y max 1 i ' jX i  Y i j Soergel DistanceX, Y P ' i1 jXiYij P ' i1 maxXi, Yi Lorentzian DistanceX, Y P ' i1 log 2 1  jX i  Y i j Note: Scores of zero indicate that X and Y are identical except for the Max:Min measure, where one is the minimum value.
Lossy compression of quality scores at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
R.C novas et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
