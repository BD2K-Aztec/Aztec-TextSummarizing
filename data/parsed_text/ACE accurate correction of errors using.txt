The quality of high-throughput next-generation sequencing data significantly influences the performance and memory consumption of assembly and mapping algorithms. The most ubiquitous platform, Illumina, mainly suffers from substitution errors. We have developed a tool, ACE, based on K-mer tries to correct such errors. On real MiSeq and HiSeq Illumina archives, ACE yields higher gains in terms of coverage depth, outperforming state-of-the-art competitors in the majority of cases. Availability and implementation: ACE is licensed under the GPL license and can be freely obtained at https://github.com/sheikhizadeh/ACE/. The program is implemented in Cþþ and runs on most Unix-derived operating systems.
IntroductionGenome sequencing involves reading thousands or millions of genome fragments and reconstructing the original genome, either by assembling these reads in de novo assembly projects, or aligning them to a known reference genome in re-sequencing studies. Over the last decade, next-generation sequencing (NGS) technology dramatically increased the ease with which material can be sequenced, yielding millions of short reads in a short time. The lower quality of the data (compared to Sanger sequencing) however significantly influences performance and memory consumption of assemblers and alignment algorithms; as a result, there has been a growing interest in correcting errors in short-read archives. Sequencing errors can result in substitutions, insertions, deletions and unconfirmed nucleotides represented by 'N' symbols. The most ubiquitous platform, Illumina, mostly suffers from substitution errors while for others, like 454 and Ion Torrent, insertions and deletions are most abundant. As an error at a specific genomic position occurs infrequently and randomly, an erroneous base can be detected and corrected taking advantage of the high frequency of the reads that cover that position. This is the idea behind all count-based error correction methods which count K-mers using various data structures. For example, SHREC () constructs a generalized suffix trie while HiTEC () uses a suffix array. Built upon SHREC, Hybrid-SHREC () captures InDel errors as well as substitutions. SGA () performs error-correction using the FM-index derived from the compressed Burrows-Wheeler transform. BLESS () employs a bloom-filter and RACER () organizes 2-bit-encoded K-mers as 64-bit integers and stores them in a hash table. Fiona, based on partial suffix array, is also able to deal with InDel errors (). Alternatively, K-spectrum based error correction methods, like Quake () and Musket () collect all K-mers appearing in the set of reads, and align those with a small Hamming distance from each other to achieve the correct consensus. Finally, MSA-based methods, like Coral (), apply multiple sequence alignment between reads that share K-mers to detect errors. A recent survey provides a comprehensive review of error-correction methods, and establishes a common set of benchmark data and evaluation criteria (). Here we present ACE, a new K-mer count-based algorithm. We employ the K-mer trie, a data structure more time/space-efficient than the suffix trees employed in SHREC. K-mer tries have been effective in solving some bioinformatics problems ().
MethodsACE is the C implementation of our algorithm, equipped with Open-MP directives to scale with the number of available processors. It organizes the K-mers of short reads (and their reverse-complement) in a K-mer trie. A K-mer trie of a sequence s (or set of sequences) is a trie of depth K which contains all K-mers of the sequence. Each edge has a label from the alphabet R; the concatenation of edge labels along the path from root to a node is called the spelled string of that node. Each leaf corresponds to one or more K-mers of s, and each node can contain the number of times that its spelled string appears in the sequence. A K-mer trie gives constant-time access to all patterns of length at most K, useful for counting and storing K-mers, detecting zygosity, determining ploidy and genome assembly. To cope with large datasets, ACE constructs K-mer sub-tries one by one () by applying a prefix-based classification on K-mers and shortening them to k-mers where k  K  p and p is the prefix length, determined based on the amount of available memory and the size of the input data. As the K-mer trie is very dense in the top levels, ACE further reduces memory consumption (and the size of search space) by building a root array instead of constructing the top triangle of the trie. Moreover, to efficiently organize billions of K-mers in the trie ACE applies another prefix-based division to allow parallel construction of the branches of each subtrie. In, a branch has been divided into four sub-branches to be constructed and scanned for errors by four independent parallel threads. Branches are divided into 16, 64 or more sub-branches if more cores are available. More details on the algorithm, including a pseudo-code description, can be found in the Supplementary Material.
ResultsWe experimentally compared the performance of ACE in increasing the coverage depth/breadth of reads/K-mers to those of seven stateof-the-art tools, using the benchmark data and following the same evaluation procedure as presented in a recent survey (). To be consistent with the result of. The gain of ACE in increasing the depth/breadth of reads/K-mers, compared to that of the best tool inDepthNote: Highlights indicate the level of improvement.compares the gain of ACE to that of its best competitor among seven state-of-the-art read cleaners: BLESS, Coral, HiTEC, Musket, RACER, SGA and SHREC; more detailed results can be found in Supplementary Tables S3S11. In these evaluations, Depth of coverage indicates the average number of times each base is covered by reads/K-mers and Breadth of coverage indicates the proportion of the genome covered by reads/K-mers (). The first criterion is useful for quantitative applications and overlap-layout-consensus assembly, while the second is more applicable for de Bruijn graph-based genome assembly. ACE outperforms most other tools in terms of coverage depth gain, improving on the best competitor on 18 resp. 22 out of 22 datasets for reads resp. K-mers. In particular for MiSeq data, which contains more errors, the improvements can be significant. For coverage breadth, the picture is less clear: ACE outperforms the best alternative tool on 13 datasets on read coverage breadth gain, whereas K-mer coverage breadth gain was generally worse. However, all tools actually yield low read coverage breadth on most MiSeq data (as low as 0.25%) and decrease K-mer coverage breadth compared to the raw data (see Supplementary Tables S5S6, S9 S10).compares the time and memory consumption of ACE to those of the three competitors which were able to successfully correct all datasets. While for most datasets memory consumption is reasonable, ACE has higher computational cost than most other tools, trading speed for accuracy.
ACE
ConclusionWe developed ACE, a command-line tool to accurately correct substitution errors in Illumina short-read archives. ACE generally outperforms the best among seven state-of-the-art read cleaners in terms of coverage depth, at higher computational cost. This makes it a useful tool for small to medium-sized datasets or applications where accuracy requirements warrant the investment in computational resources. In future work, we aim to lower the runtime of ACE by updating the K-mer trie instead of rebuilding it for each round of execution. This future version should also be able to handle InDel errors to extend its application to all sequencing platforms.Note: Time is given in seconds and memory in megabytes, both per input mega base pair.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
S.Sheikhizadeh and D.de Ridder at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
