Motivation: DNA segmentation, i.e. the partitioning of DNA in com-positionally homogeneous segments, is a basic task in bioinformatics. Different algorithms have been proposed for various partitioning criteria such as Guanine/Cytosine (GC) content, local ancestry in population genetics or copy number variation. A critical component of any such method is the choice of an appropriate number of segments. Some methods use model selection criteria and do not provide a suitable error control. Other methods that are based on simulating a statistic under a null model provide suitable error control only if the correct null model is chosen. Results: Here, we focus on partitioning with respect to GC content and propose a new approach that provides statistical error control: as in statistical hypothesis testing, it guarantees with a user-specified probability 1 Ã€ that the number of identified segments does not exceed the number of actually present segments. The method is based on a statistical multiscale criterion, rendering this as a segmen-tation method that searches segments of any length (on all scales) simultaneously. It is also accurate in localizing segments: under benchmark scenarios, our approach leads to a segmentation that is more accurate than the approaches discussed in the comparative review of Elhaik et al. In our real data examples, we find segments that often correspond well to features taken from standard University of California at Santa Cruz (UCSC) genome annotation tracks. Availability and implementation: Our method is implemented in function smuceR of the R-package stepR available at
INTRODUCTIONIt has been observed a long time ago () that DNA sequences are not composed homogeneously and that bases fluctuate in their frequency. These inhomogeneities often have an evolutionary or a functional interpretation, and can be relevant for the subsequent analysis of sequence data. Because it correlates with many features of interest, the GC content, i.e. the relative frequency of the bases G and C, is one of the most commonly studied sequence properties. Large-scale regions, typically 300 kb (), of approximately homogeneous GC content have been called isochores. In view of the somewhat vague notion of 'approximate homogeneity' and conceptual criticism in studies such asor, there is less interest in isochores nowadays. However, there is no doubt about variation in GC content along genomes, and search is done instead for domains of any length exhibiting distinct local GC content; see, for instance, Elhaik et al. (2010b). Several factors can influence the GC content of a region. At larger scales, it correlates with the density of genes, with gene-rich regions typically exhibiting an elevated GC content compared with regions of low gene density. At smaller scales, there is fluctuation in the GC content, for instance, because of repetitive elements and GpC islands. The GC content is also known to vary between exons and introns. Especially for long introns, their lower GC content seems to play a role in splice site recognition (). There is also a correlation between the GC content and the local recombination rate (). For a further discussion of features correlated to the GC content, see. In gene expression studies, regions of homogeneous GC content are of interest because the GC content of a region affects the number of reads mapped to this region. For DNA and RNA-seq experiments with the Illumina Genome Analyzer platform, this has been, for instance, investigated in Benjamini and Speed (2012) and. Segmentation algorithms aim to partition a given DNA sequence into stretches that are homogeneous in their composition but differ from neighboring segments. The classical approach of using moving windows is simple and available, for instance, as an option with the UCSC and Ensembl genome browsers. However, it has some disadvantages. For instance, the choice of the window size is difficult because it defines implicitly a fixed scale at which segments primarily will be detected. Further, the involved smoothing blurs abrupt changes. Without additional statistical criteria, the method also does not tell us whether differences between neighboring windows are statistically significant. Therefore, several more sophisticated approaches have been proposed. These methods include hidden Markov models () and walking Markov models (). There are also change-point methods available; see, for instance,. A Bayesian approach *To whom correspondence should be addressed. that relies on the Gibbs sampler has been proposed by. An older approach based on information criteria can be found in. Furthermore, recently developed methods based on entropy criteria have been shown to perform particularly well; see Elhaik et al. (2010a) and Elhaik et al. (2010b). A review of segmentation methods can be found in the article by Braun and Muler (1998), and for a more recent comparative evaluation of the more popular approaches, see. In this paper, we focus on binary segmentation, where the four-letter alphabet of a DNA sequence is converted into a two-letter code. For GC content, we set the response to be '1' for G or C at a position and 0 for A/T; we use Y i to denote the response at position i and summarize the responses for a sequence of length n by Y  Y 1 , Y 2 ,. .. , Y n : 1We model the responses Y i to be independent and Bernoulli Bin1, i  distributed, and also assume that there is a partition 0  0 5 1 5    5 K  n into an unknown number K of segments on which the i are piecewise constant, i.e. i  p j for i 2 I j. Here, I j :  j1 , j  denotes the j'th segment with response probability p j for 1 j K. A segmentation algorithm provides estimates ^ K for the number of segments, for the internal segment boundaries,and for the response probabilities, ^ p j , on the estimated segmentsIn the following, we will identify a segmentation with p, I, where p  p 1 ,. .. , p K  and I  I 1 ,. .. , I K . Our proposed algorithm provides a parsimonious estimate ^ K for K: ^ K will not exceed the actual number of segments K, except for a small user-specified error probability ; as a default value, we suggest  5%, the error probability also chosen in our simulations and data analyses. Relaxing this significance level to a larger value, say  20%, will typically lead to more identified segments but at the cost of statistical accuracy.
METHODOur proposed multiscale segmentation provides estimates for the number of segments and their boundaries at the same time. We use a certain multiscale statistic that will ensure that the estimator fits the data well on all segments simultaneously, i.e. the number of segments is not underestimated with high probability. This estimator is based onwho proposed a general statistical multiscale change-point estimator (SMUCE) for exponential family models. Exponential families include many classes of well-known distributions, such as the Gaussian (normal) class, the Poisson class or the Bernoulli class, which is of particular interest for this article. In the Gaussian setting, a related estimator has also been suggested in. Forerunners of SMUCE are based on a penalized likelihood with a penality that depends on the number of jumps; see, e.g.and the introduction infor a brief survey. The underlying multiscale statistic is based on the work of; see also. For a general description of the approach underlying the present work, its statistical interpretation, statistical optimality and theoretical results, we again refer to. To ease the understanding, in the following, we elaborate in greater details on the case of binary Bernoulli observations with success probabilities given as piecewise constant segments, as this model underlies the methodology for the segmentation problem at hand. In contrast to other approaches such as hidden Markov models, we require neither explicit nor implicit distributional assumptions on the segments and their lengths. Let 'Y i , i  denote the likelihood of Y i under the parameter i , i.e. 'Y i , i   i if Y i  1 and 'Y i , i   1  i else. We then define for a fixed interval i, j with 0 i5j n the local likelihood ratio statistic T i, j p 0   log max ~ p020, 1Roughly, this statistic indicates how well the data on the subinterval i, j are described by the constant response probability p 0 2 0, 1 of some segment under consideration as opposed to choosing some ~ p 0 2 0, 1 freely for that subinterval. As a goodness-of-fit measure for the segmentation p, I, we consider the scale-calibrated multiresolution statistic(Here 'e' denotes Euler's number.) This statistic may be interpreted as follows: for all segments I l in I, the response probability is assumed to be constant, and for every interval i, j within such a segment, T n p, I measures whether the data are well described by the constant response probability p l on that interval. It thus checks the quality of fit on all scales simultaneously, hence the name. Note that the log-penalty term depends on the length j  i of the interval that is currently checked for deviations from the model. It takes the number of disjoint intervals of the considered length into account, thereby adjusting for multiple testing. For our final estimate, we determine
Details of the algorithmWe follow Frick et al. (2014) and use a pruned version of dynamic programming to compute our estimated segmentation ^ I and levels ^ p. This is possible because our multiresolution statistic T n considers only subintervals of the candidate segments of constant response probability. For related ideas, where dynamic programming has been used for other segmentation estimators, see,,and, in particular for pruning,. To describe the algorithm for computing B-SMUCE, we need the following notation, identifying a segmentation with p, I again: for an interval i, j, we define the local costs of a response probability p 0 2 0, 1 asLet c  i, j  min p020, 1 c i, j p 0  denote the minimal costs on i, j for a constant response probability under the multiresolution constraint, whereas p i, j  argmin p020, 1 c i, j p 0  denotes the corresponding optimal estimate. Let us, for the moment only, consider the observations Y 1 ,. .. , Y i for fixed 1 i n, and denote by c  i, K , the optimal overall costs on 0, i using K segments, i.e.cf. (5), where C K, i denotes the set of segmentations of 0, i with K segments; if no segmentation p, I 2 C K, i fulfills the multiresolution constraint T i p, I q, we let c  i, K  1. The algorithm for B-SMUCE is then based on the observation that for K40In dynamic programming, this is called the Bellman equation; it is the main ingredient for an efficient implementation; see line 11 in Algorithm 1.Algorithm 1: dynamic programming algorithm for B-SMUCE 1: ^ K 0, ^ I 0 ;, ^ p 0 ;, i 1 2: while i n do 3: if ^ K  0 then 4:6: else 7: for l  i  1,. .. , 1 do 8: if c l, i  1 then 9: goto 14 10: else 11:l, i 12: end if 13: end for 14:Note that we introduced two rules that permit for early stopping of loops: if c  l, i  1, i.e. if the hypothesis of constancy on l, i is rejected, then consequently, this also happens on any larger interval, i.e. for any smaller l; this justifies lines 89. Similarly, if K segments are insufficient to fulfill the multiresolution constraint on 0, i, then a fortiori so for any larger i, whence lines 1720. To the best of our knowledge, these shortcuts that are possible because of the specific structure of the multiscale constraint have not been used so far. Additional improvements were used in our implementation; these, however, are rather technical and thus omitted from the present article.
RESULTSWe evaluated our segmentation approach both on simulated data and on data taken from the human genome and the longknown-phage. In our simulations, we used the benchmark scenarios proposed in. Because an extensive comparison of popular DNA segmentation algorithms under these benchmark scenarios is already available in Elhaik et al.(2010a), we provide a comparison of our approach with the method that performed best in, namely, the one based on the JensenShannon divergence. This recursive approach (called D JS ) splits one of the current segments in each step. This is done by adding a new break point such that the improvement in JensenShannon divergence is maximized. The algorithm stops when the improvement does not reach a threshold value obtained via simulations. Here, we used the Matlab implementation Djsegmentation.m of the algorithm, which is publicly available as part of ISOPLOTTER 2.4 (http://code. google.com/p/isoplotter/). There, 5:8  10 5 is taken as a threshold, a value obtained from simulating long (1 Mb) homogeneous sequences. Although this value seems to work well for the considered benchmark scenarios and might also be useful to prevent false-positive findings when searching for long homogeneous sequences, it might be less suitable for balancing false-positives and false-negatives under other scenarios. Therefore, a modified version (called ISOPLOTTER) of D JS has been proposed briefly after () that uses critical values dependent both on the segment length and the standard deviation of the GC content. Therefore, we also report on the performance of ISOPLOTTER 2.4 (again under the default parameter settings) and provide detailed results in the Supplementary Material. To facilitate the comparison and to accelerate the computations for longer sequences, we binned the data and applied our algorithm to the resulting binomial frequencies. We choose the bin size equal to 32, which is the default value with the D JS and IsoPlotter software and has also been used in
Performance measuresWe measured performance both by a qualitative criterion proposed byand by a new quantitative criterion. For the qualitative criterion, we classify an identified segment as true-positive if both segment boundaries are identified correctly within an error margin of 5000 bases or 5% of the segment length, whichever is smaller. Thus, an identified segment is considered to be a false-positive, unless both detected boundaries were within 5000 bases (or 5%) from the boundaries of a true segment. Similarly, actual segments were taken as false-negative findings if they were not detected correctly within the permitted tolerance. Let now tp, fp and fn denote the number of true-positives, false-positives and falsenegatives, respectively. Following, we define a sensitivity rate as r s : tp tp  fn , 11 and a precision rate as r p : tp tp  fp : 12 We investigate the performance of our proposed approach based on these criteria. Furthermore, we defined two quantitative criteria that better reflect the accuracy of detecting segment boundaries. We denote them by false-negative sensitive localization error (FNSLE) and false-positive sensitive localization error (FPSLE). To introduce the FNSLE, consider a true segment I j :  j1 , j , and let m j Analogously, the FPSLE can be defined by measuring how closely an estimated segment matches to one of the true segments. By starting with an estimated segment ^ I l and its midpoint ^ m l , we look for the true segment satisfying ^ m l 2 I j. With analogously defined errors e FPSL l , we callthe overall FPSLE. These measures for the error may be interpreted as follows: assume that the estimated segmentation agrees with the true segmentation in the number of segments, and that all boundaries have been determined with an error smaller than half the length of each neighboring segment. Then, FPSLE and FNSLE agree: they essentially give the average distance between true and estimated boundaries. These error measures behave differently, however, if the numbers of true and detected segments do not coincide: assume that the estimated segmentation is the true segmentation except that it has incorrectly split one true segment into two estimated segments. Then, the FNSLE increases by the length of that true segment minus the length of the longer estimated segment divided by 2K, i.e. a spurious split is treated like an error in localizing that boundary. The FPSLE, however, will get rather large, as the length of that true segment divided by 2 ^ K gets added. Similarly, if a true boundary is not detected, the FNSLE will be larger.
Simulations3.2.1 Segments of equal length We first implemented Scenario I of. Thus, we simulated sequences that consist of 10 segments of equal length. We considered the following eight different segment lengths: 10kb, 50kb, 100kb, 200kb, 300kb, 500 kb, 1Mb and 5Mb. Thus, the longest sequences had total length 50Mb. For each sequence, we selected a global probability p t for the response '1' at a position according to a uniform distribution on. Then, we randomly modified this probability for each sequence segment j by takingHere Z j denotes a standard normal random number, and was chosen from f0, 0:025, 0:05, 0:075, 0:1g. The p j were conditioned to lie within, i.e. if p j did not turn out to be a proper probability, a new random number was generated. The individual observations Y i within a given segment I j were then chosen as independent Bernoulli random variables with expected value p j .We simulated 100 sequences for each combination of segment length and heterogeneity of the segment-specific response probabilities. In, a detection threshold was introduced, and neighboring true segments for which the value of p j differed by less than this threshold have been merged and considered as a single segment in the subsequent performance analysis. We did not use such a threshold, however, as we did not want to penalize high sensitivity. A correct detection of two neighboring segments with unequal but too similar levels of p j would be counted as an error if such a detection threshold was used. The average sensitivity and precision rates of B-SMUCE and the method based on the JensenShannon entropy (D JS ) are displayed inand 2, respectively. Especially for shorter segments, B-SMUCE performs better than D JS , with higher sensitivity and precision. IsoPlotter performed worse than D JS under the considered scenarios and gave up to 40 segments on average for the long sequences. B-SMUCE is able to detect also short segments, while controlling the number of spuriously detected segments. However, notice that in the case of a homogeneous sequence without partitioning into segments (  0), D JS always obtained the correct answer, whereas B-SMUCE sometimes introduced spurious segment boundaries. This is to be expected, as the error of introducing spurious boundaries has been set to  5% under such a model. Furthermore, under all scenarios, too many boundaries were estimated by B-SMUCE in 55% of the simulations, as predicted. We consider the ability to control this error to be a particular strength of our approach. Figures 3 and 4 show the average FNSLE (14) and FPSLEs (15) that measure the accuracy of the segment detection. For these quantitative criteria, we only consider sequences that are non-homogeneous (40). Again, B-SMUCE shows better performance, leading to smaller errors on average. With increasing heterogeneity , there will be typically larger differences between neighboring segments and thus smaller errors. The graphs also seem to indicate that both FPSLE and FNSLE tend to get larger with increasing sequence lengths. A closer inspection reveals that this is mostly caused by outliers, as the median accuracy of detection stays nearly the same for all segment lengths. These outliers occur when a segment is either missed or detected incorrectly, and such events lead to larger errors when the segments are longer.
Segments according to power lawIn our second simulation setup, we generated 100 sequences consisting of segments. Notice that the minimal segment length x 0  10 000 was introduced to avoid short segments that are difficult to detect. The total sequence length was taken to be n  10 6. For even numbered segments, we selected the response probability p j according to a uniform distribution on, whereas for odd segments, we took p j uniformly from p j 2 0, 0:4. Qualitatively, it turns out that B-SMUCE performs better than the JensenShannon entropy criterion D JS both in terms of sensitivity and precision rate; see. B-SMUCE detected 90% of all true segments within the desired margin of error. Furthermore, 94% of all detected segments were correct, again, within the desired level of accuracy. Because we used B-SMUCE with a type I error probability of 5% for including too many segments, this implies that almost all of the detected jumps were detected within the required level of accuracy. Furthermore, when incorrect, our method usually detected not more than one spurious segment boundary. We also tried IsoPlotter on the simulated sequences and got 85.23 detected segments on average. Given an mean number of 27.51 true segments (see), more than three times the true number of segments has been detected on average. More detailed results on ISOPLOTTER can be found in the Supplementary Material. B-SMUCE also leads to good results in terms of the FPSLE and FNSLE; see. Thus, on average, detected segments and true segments match more closely with B-SMUCE than with the D JS criterion.
Real dataWe applied our segmentation algorithm to three data sets. The first two examples, phage and human major histocompatibility (MHC) complex, have previously been studied in the context of segmentation algorithms. As a further example, a 10 Mb sequence chunk (hg19, chr1:50000002-60000000) has been arbitrarily chosen from human chromosome 1. The genome of bacteriophage consists of 48 502 bases and was one of the first completely sequenced genomes. Our segmentation led to six segments with boundaries 1, 22501, 27829, 33186, 39172, 46367 and 48502. Notice that the same number of segments, although with a bit different boundaries, has been reported as the outcome of a segmentation using hidden Markov models in Chapter 4 of Cristianini and Hahn (2007). We next investigate human genome data from chromosome 6p21.3 and 6p22.1 (hg19, chr6:29 677 95233 289 874). This segment harbors the much studied human MHC complex. We found a number of segments even larger than that in, contradicting once again the concept of homogeneous isochores (from the UCSC browser for this example.) We recoded G,C as '1' and A,T as 0 and applied B-SMUCE and both D JS and IsoPlotter to these data. With D JS , we found 182 segments. With B-SMUCE and a type I error probability of  0:05, we identified 640 segments. (With  0:01, 528 segments were obtained, and choosing  0:1 led to 716 segments.) A natural question is whether the number of 640 or 182 segments is more appropriate. To address this issue, notice that theNote. Long and short segments were generated under a power-law distribution, and the total sequence length was n  10 6. The results are averages (and standard errors) over 100 simulation runs. The error rates were standardized according to the average segment length. statistical error control associated with the multiresolution criterion suggests that there are (except for a small error probability) at least 640 segments. To check whether this finding is also compatible with the D JS segmentation, we simulated the segmentation with 640 segments obtained with B-SMUCE as our null model. We simulated 100 datasets from this null model, and for 80% of all datasets, D JS led to a segmentation with the number of segments at most 182. With the number of segments taken as test statistic, this amounts to an estimated p-value of 0.80. Thus, the segmentation based on the JensenShannon (D JS ) criterion does not contradict the assumption of 640 segments, whereas the hypothesis of 182 segments is rejected by the multiscale criterion underlying B-SMUCE as not being compatible with the data. We also applied IsoPlotter 2.4 to the data. With its adaptive detection threshold, 227 segments were identified. The homogeneity test (one-sided F-test) provided with the IsoPlotter software confirmed for 180 of these 227 segments that they are significantly more homogeneous than the entire considered DNA sequence. Although this observation does not give us the number of segments actually present, it seems interesting that the number of sufficiently homogeneous segments found by IsoPlottor is almost the same as the number of segments identified with the D JS criterion. Finally, we considered the region between 50 and 60 Mb on the human chromosome 1. Here, we tried bins both of size 10 and 32. It turned out that with the finer partition slightly more segments were detected than with the larger bins of size 32, although the difference (1096 versus 1041) was not large. It seems plausible that fine-scale variation can be detected more easily with shorter bins. To illustrate the run-time behavior of the B-SMUCE algorithm with our default significance threshold  0:05, we considered several shorter sequences taken from the aforementioned 10 Mb DNA sequence.gives the run times of our algorithm (in s) in dependence of the sequence length. To give an idea about the run times of D JS and IsoPlotter, we applied them on the same sequence pieces. With the standard options (bin size: 32, shortest detectable domain size: 3008), the run times for the longest sequence (10 7 bases) were 6.2 s (D JS ) and 9.6 s (IsoPlotter). However, notice that B-SMUCE is designed to detect segments of any length, and the shortest segment detected by B-SMUCE in the context of our run time analysis was 80 bases long. Therefore, we also recorded the run times for D JS and IsoPlotter with the minimum segment length changed from 3008 to 80. For a bin width of 32 and a sequence length ofNote. The computations were carried out on a single cluster core with 2.6 GHz and 8 GB RAM. The results are reported for  0:05 and for bins of lengths 32 and 10. For  0:01, similar run times have been obtained.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
(1) the minimal number of segments ^ K, such that there exists a segmentation  ^ p, ^ I with ^ K segments satisfying the multiresolution constraint T n  ^ p, ^ I q for some predetermined significance threshold q, and (2) the segmentation  ^ p, ^ I with maximal likelihood among all segmentations having ^ K segments and satisfying the multiresolution constraint. To be more precise, let C K denote the set of segmentations with K segments. Then, our estimate in the second step is  ^ p, ^ I  argmax p, I2C ^ K , Tnp, I q 'Y; p, I, 5 where argmax denotes a position  ^ p, ^ I at which the maximum is obtained, and 'Y; p, I denotes the likelihood of all data if the segmentation p, I with ^ K segments were true, i.e. 'Y; p, I  Y 1 l ^ K Y i2Il 'Y i , p l : 6 Following Frick et al. (2014), the general class of such estimators in exponential families has been denoted as SMUCE. We adopt this terminology and will denote the estimator in (5) for the Bernoulli and binomial case as B-SMUCE. The threshold parameter q determines the parsimony of the estimator; the larger q, the fewer segments will be included into B-SMUCE. Hence, the choice of q is crucial. A statistically attractive feature of B-SMUCE is that q can be chosen as the 1   quantile of the distribution of T n p, I under the hypothesis that p, I is the true model. In Frick et al. (2014), it has been proven that this choice ensures that the number of segments is not overestimated with probability at least 1  .
A.Futschik et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from To be more precise, in Frick et al. (2014), Theorem 2.1 was shown under some mild technical assumptions that for any p, I the asymptotic distribution of the multiresolution statistic T n p, I can be bounded by the asymptotic distribution of the statistic for a signal with only one segment. Moreover, the latter distribution converges to the limit distribution of (4) for the case of i.i.d. (independent and identically distributed) zero-mean Gaussian observations. Therefore, we may (and we do in the following) simply use Monte Carlo simulations with i.i.d. zero-mean Gaussian data to determine bounds on the quantiles of the distribution of T n p, I. In simulations, we found the approximate quantiles thus obtained to be rather conservative (i.e. the preassigned error probability was not exceeded) even for small sample sizes. This adds support to the basic inequality P ^ K4K PT n p, I4q 7 in Section 1.2. of Frick et al., 2014, which renders SMUCE to be a method that statistically controls the error to overestimate the number of segments in the binary case, i.e. it provides the statistical validity of BSMUCE in the above sense (7). The other way around, Theorem 2.2 in Frick et al. (2014) provides an exponential deviation bound for the error to underestimate the true number of segments, which explicitly depends on the smallest segment length and signal strength. Under prior information on these quantities, these two inequalities together even allow to give a guarantee for the probability P ^ K  K of specifying the number of segments correctly. Moreover, in the Gaussian case, it can be shown that SMUCE attains optimal detection rates (and even constants) over a large range of segment lengths; see Frick et al. (2014), Theorems 2.6 and 2.7. Our simulations suggest a similar performance in the binary/binomial case, although we do not have a rigorous proof of this statement.
Multiscale DNA partitioning at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
A.Futschik et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
7 , the run time for D JS remained unchanged, whereas the run time for IsoPlotter increased to 329.1 s. For the human genome data considered here, a cross-check with the genome annotation revealed that several segments have an interpretation in terms of genes/exons, repetitive elements or CpG islands. Because the GC content may depend on several functional and evolutionary factors, we do not expect simple explanations for many of the identified segments. Nevertheless, we explore the overlap of the identified segments with available annotation in the Supplementary Material. 4 CONCLUSION We introduced a new method (B-SMUCE) for the segmentation of biological sequences. The segmentation is with respect to a binary response; here, we have considered GC content, but it might be interesting to apply the method to other applications involving binary responses (such as ancestral/derived state of alleles in population genetic applications). Our approach provides precise statistical error control and will produce a parsimonious segmentation that does not contain more segments than there actually are with a user-specified preassigned probability of 1 . A comparison under the benchmark scenarios taken from Elhaik et al. (2010a) suggests that the proposed method B-SMUCE is more accurate than previously proposed approaches. Interestingly, the difference to the popular JensenShannon criterion in terms of the number of detected segments has been particularly large for the human data.
