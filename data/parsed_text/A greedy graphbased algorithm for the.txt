Motivation: Many comparative genomics studies rely on the correct identification of homologous genomic regions using accurate alignment tools. In such case, the alphabet of the input sequences consists of complete genes, rather than nucleotides or amino acids. As optimal multiple sequence alignment is computationally impractical, a progressive alignment strategy is often employed. However, such an approach is susceptible to the propagation of alignment errors in early pairwise alignment steps, especially when dealing with strongly diverged genomic regions. In this article, we present a novel accurate and efficient greedy, graph-based algorithm for the alignment of multiple homologous genomic segments, represented as ordered gene lists. Results: Based on provable properties of the graph structure, several heuristics are developed to resolve local alignment conflicts that occur due to gene duplication and/or rearrangement events on the different genomic segments. The performance of the algorithm is assessed by comparing the alignment results of homologous genomic segments in Arabidopsis thaliana to those obtained by using both a progressive alignment method and an earlier graph-based implementation. Especially for datasets that contain strongly diverged segments, the proposed method achieves a substantially higher alignment accuracy, and proves to be sufficiently fast for large datasets including a few dozens of eukaryotic genomes. Availability: http://bioinformatics.psb.ugent.be/software. The algorithm is implemented as a part of the i-ADHoRe 3.0 package.
INTRODUCTIONIn the past decades, considerable effort has been devoted to the development of algorithms for the alignment of biological sequences at the nucleotide or amino acid level. Using dynamic programming techniques, optimal pairwise global () and local () alignments can be obtained in O(l 2 ) time, where l denotes the length of the sequences. A straightforward extension of these algorithms to N > 2 sequences results in a computational complexity of O(l N ), which renders the handling of sequences of realistic length impractical. Therefore, most multiple sequence alignment (MSA) tools are based on progressive alignment, in which N sequences are aligned through N 1 applications of a pairwise alignment algorithm, usually guided by a tree that determines the order in which the sequences are combined. Many MSA tools that build on this principle have been implemented such as the well-known programs CLUSTAL(W) (), T-COFFEE (), MUSCLE () and MAFFT (). Almost without exception, MSA tools target the alignment of amino acid or nucleotide sequences. In this article, we focus on the alignment of multiple, mutually homologous (i.e. derived from a common ancestor) genomic segments, represented as gene lists. This means that the alphabet of the input sequences consists of individual genes, rather than nucleotides or amino acids. Similarly to MSA at the nucleotide or amino acid level, the goal is to align homologous genes, i.e. place genes that belong to the same gene family in the same column. The homology relationships between the individual genes have been established in a preprocessing step using sequence similarity searches and protein clustering (). Whereas ancestral gene order reconstruction (see e.g.) starts from homologous genomic segments to infer ancestral genome states and quantify genome dynamics, the objective of our graph-based approach is to create accurate alignments of homologous segments, in order to facilitate the detection of additional homologous genomic segments. The multiple sequence alignment of gene lists differs significantly from the alignment of sequences at the nucleotide or amino acid level. First, the size of the alphabet of different nucleotides (4) or amino acids (20) is much smaller than the typical number of different gene families that occur in the genome of an organism. This means that a certain gene only has a very limited number of homologous genes in other gene lists. Second, through evolution, nucleotide and amino acid sequences mainly undergo character substitutions, whereas chromosomes mainly undergo gene loss/insertion, inversion and other types of rearrangements (e.g. reciprocal translocation). These two major differences allow for the development of a graph-based alignment approach, which will be demonstrated to have a higher accuracy than a progressive approach, in terms of the number of correctly aligned homologous genes. We propose an algorithm similar to the so-called segment-based alignment approach that is used in e.g. DIALIGN (). The first step in DIALIGN consists of the identification of corresponding gap-free local alignments or 'fragments' between pairs of sequences. The alignment of some of these fragments can prohibit the alignment of others. Finding the largest (weighted) subset of fragments that can be incorporated into a multiple alignment is a difficult task, often referred to as the consistency problem (). In the context of the gene list alignment problem, the 'fragments' correspond to homologous genes. The consistency problem then is to find the maximal number of homologous genes that can be included in a multiple alignment. Optimal solution methods to this consistency problem exist (), but are NP-hard and therefore in general computationally impractical. Here, fast heuristic methods are developed to remove inconsistent or conflicting homology relationships between genes, from a graph-theoretic perspective. Similar ideas have been developed by. The proposed alignment algorithm is part of the iterative automatic detection of homologous regions (i-ADHoRe) software (), a map-based method to detect homologous genomic segments within or between the genomes of related organisms. Rather than identifying primary sequence similarity, map-based methods look for statistically significant conservation of gene content and gene order (collinearity). One of the key features of i-ADHoRe is the capability to uncover segmental homology, even between highly diverged segments. When two homologous segments have been identified, a so-called profile is constructed by aligning both segments, hence combining the gene order and content of both homologous segments. This genomic profile can then be used by i-ADHoRe as a more sensitive probe to scan the genome, in order to identify additional homologous segments (). This iterative process of alignment and detection continues, until no additional statistically significant genomic segments can be found. It is clear that a high-quality alignment of the homologous gene lists within a profile is imperative for a sensitive detection of additional homologous genomic segments within the i-ADHoRe software. The original i-ADHoRe () implementation relied on profile construction using a progressive application of the NeedlemanWunsch (pNW) aligner. Especially when dealing with strongly diverged segments, one of the biggest problems with the pNW method is that erroneous alignment decisions in early pairwise steps propagate to the final alignment, causing the alignment quality to degrade significantly when more segments are added. This problem was already partially addressed in i-ADHoRe 2.0, through the introduction of a greedy, graphbased (GG) aligner (). Rather than relying on a progressive adding of segments, the GG-aligner considers the N segments 'simultaneously'. Although this GG-aligner has its merits compared with the pNW-aligner (e.g. it avoids the 'once a gap, always a gap' problem), it was unable to outperform the latter in terms of the number of correctly aligned genes. This article introduces a new greedy, graph-based algorithm (called GG2) that builds on the original GG-aligner. First, the basic graphbased alignment algorithm will be explained, followed by the development of a heuristic to resolve consistency problems in this graph, so-called conflicts. In later sections, we demonstrate that the new GG2-aligner outperforms both the pNW method and the original GG-aligner in terms of alignment accuracy. The new GG2aligner has been implemented in the latest 3.0 version of i-ADHoRe and its C++ source code can be downloaded for academic purposes (http://bioinformatics.psb.ugent.be/software).
ALGORITHM
Graph structureConsider a set of N unaligned genomic segments that are known to be mutually homologous. Each of the segments is represented by an ordered list that contains the genes in the same order as they appear on the corresponding segment. The number of genes in the i-th list is denoted by l i. Every gene in a list is homologous to zero or more genes in other lists. Although tandem duplicated genes on a genomic segment are largely filtered from the input by i-ADHoRe (see Section 3.1), their presence within the unaligned segments does not interfere with the alignment procedure. The gene lists can be represented together as a single graph G(V ,E,w) as follows. First, the genes are represented by vertices (or nodes) V. The j-th node (j = 1...l i ) on the i-th gene list (i = 1...N) is referred to by n i,j. The functions seg(.) and ind(.) return the gene list and the position index of a node, respectively, i.e. seg(n i,j ) = i and ind(n i,j ) = j. Second, consecutive genes on a segment (i.e. n i,j and n i,j+1 ) are connected through a directed arc or so-called edge pointed toward the gene with the highest index (the right-most gene). These directed edges simply connect the genes on a segment in a linear fashion. Finally, homologous genes located on different segments are connected through an undirected arc or so-called link. No links are created between homologous genes on the same segment (tandem duplicates). A weight w can be attributed to each link. The higher this weight is taken, the more likely it is that the two nodes connected by this link, will show up in the same column in the final alignment. This will be explained in later sections. The graph corresponds to the 'extended alignment graph' as introduced by, although a slightly different terminology has been adopted here.
Basic alignment procedureThe basic workflow of the alignment algorithm is illustrated in.depicts three simple unaligned gene lists. The undirected links are represented by a solid line, and the directed edges by a dashed line. At any time, the basic alignment algorithm considers a set of N nodes, one node from each segment. These nodes are referred to as active nodes. For each segment i, the index a i refers to the active node n i,a i. At any time, all nodes on segment i, located to the left of the active node n i,a i have already been aligned, the nodes n i,j with an index j  a i still have to be processed. Links that are incident to active nodes are called active links. The algorithm starts by considering the leftmost node from each segment, i.e. nodes {n 1,1 ,...,n N,1 }. If, among the N active nodes, a minimal set of nodes S = {n k,a k } can be found, for which each node in S is linked only to other nodes within S, this set can be aligned. We say that S is alignable. Note that S can be a singleton, and that more than one (disjoint) set can be found at a given time. The term minimal therefore refers to the fact that S should not be the union of two other alignable sets. Hence, all nodes within a minimal, alignable set S, correspond to genes that are homologous to each other. The next set of active nodes is obtained by incrementing the index a i for each segment i that has a node contained within one of the detected alignable sets. In other words, on those segments, the subsequent node is considered. At the corresponding position of all other segments, a gap is introduced. This is illustrated inand b. This process continues until either the end of all segments is reached or a so-called conflict is encountered. A conflict is immediately detected when no alignable set S can be found among the activePage: 751 749756nodes, as illustrated in. Conflicts can only be resolved by removing one or more links (). This procedure will be explained in Sections (2.3 2.6). Once a conflict has been resolved, the basic alignment procedure can be resumed (). Note that aligning all segments 'simultaneously' differs conceptually from progressive alignment, where first two complete segments are aligned before considering a third one, and so on. Finally, the resulting alignment is obtained as shown in.
Alignment of multiple homologous gene lists
Conflicts and cycles in GThe basic alignment procedure described above is straightforward, as long as no alignment conflicts are encountered. We define a conflict as a set of links that cannot be aligned, i.e. the alignment of some links in the set prohibits the alignment of other links. By the expression 'alignment of a link', we mean the alignment of the two nodes connected by the link. Sources for alignment conflicts are gene duplications, local inversions, translocations and false positive homology assignment between genes. In Section 2.5, we will be prove that if no alignable set S can be found among the active nodes, such a conflict is always present. Conflicts can only be resolved by removing one or more links that contribute to the conflict. This means that certain homologous genes will not be placed in the same column in the final alignment. Because the goal of the algorithm is to minimize this number of misaligned (taking the weight w of the links into account), it is imperative to carefully select which links are removed. The presence of links and edges induces an ordering of the nodes in the graph G. Consider two nodes u and v, for which a path P in G exists from u to v. In general, such a path consists of both links and edges. The latter can only be traversed in the sense indicated by their arrow, i.e. from left to right. If a path from vertex u to vertex v contains at least one edge, then the order relationship u  v holds. This means that, if all links in P were to be aligned (suppose that this is possible), node u would necessarily end up in a column left to the column containing node v in the final result. We call such a path a blocking path P B with respect to to the nodes u and v, as opposed to a direct path P D , that contains only links and hence implies that nodes u and v should be aligned. This is indicated by u  v. A path from node u to node v imposes a direction on the links that are part of that path. In this context, the functions tail(.) and head(.) return the initial and terminal vertex of a such a link, respectively. This directional property of links exists only in the context of the specified path. A path P from node u to node v can unambiguously be described by only listing the linksand not the directed edges (if any)in the order of appearanceis a blocking path from u to v; however, the path is not elementary since both links L 3 and L 5 originate from nodes on the same segment. Indeed, even though C C = {L 1 P B } is a blocking cycle in G, the removal of e.g. L 1 does not resolve the conflict. The cycleon the other hand is an elementary blocking cycle. Removing either one of the two links in C C resolves the conflict. in the path, i.e. P = {L i } (i = 1...p), where seg(u) = seg(tail(L 1 )), ind(u)  ind(tail(L 1 )), seg(head(L i )) = seg(tail(L i+1 )), ind(head(L i ))  ind(tail(L i+1 )), i = 1...p1, seg(v) = seg(head(L p )) and ind(head(L p ))  ind(v). Given a link L 1 between nodes u and v, an alignment conflict occurs, when there is at least one blocking path P B = {L i } (i = 2...p) from u to v. Indeed, the presence of L 1 implies that u  v, whereas the presence of P B implies that u  v, a contradiction. Clearly, it is impossible to align all links in the set {L i } (i = 1...p), hence they generate a conflict. The union C C = {L 1 P B } is a so-called conflicting cycle in the graph G. We define a conflicting cycle as a closed path in G that contains at least one (directed) edge. By this reasoning, one can immediately see that alignment conflicts correspond to conflicting cycles in G and vice versa. We define the number of links p in the cycle C C as the degree of the conflict. Clearly, the degree is at least two. Also, note that the link L 1 does not play a special role in the conflict. Indeed, if we consider an arbitrary link L i (i = 1...p) in C C , the links {L i+1 ,...,L p ,L 1 ,...,L i1 } also define a blocking path from node head(L i ) to node tail(L i ). As mentioned before, a conflict can only be resolved by removing one or more links that contribute to the conflict. If the removal of any link L i (i = 1...p) from its corresponding cycle C C resolves all conflicts between the remaining links (i.e. there are no conflicting cycles left in C C \{L i }), we say that the conflict is minimal. For any given cycle in the graph G, the number of links that terminate in nodes on a certain segment s is equal to the number of links that originate from nodes on the same segment s. If at most one link in the cycle originates from each segment, we call it elementary. The maximum number of links in an elementary cycle is therefore given by N. Similarly, an elementary path is defined as a path where at most one link originates from each segment. The maximum number of links in such a path is N 1.As an immediate consequence, the maximum degree of a minimal conflict is given by the number of segments N. The importance of the concept of minimal conflicts stems from the fact that such conflicts can be resolved by removing any link involved in the conflict. This is not the case for conflicts associated with non-elementary blocking cycles (compare the examples in). Also, from the proof of Proposition 1, it follows that any non-elementary conflicting cycle C C Page: 752 749756
J.Fostier et al.corresponds to one or more minimal conflicts, either by removing superfluous links from C C or by decomposing C C into several elementary conflicting cycles. Therefore, in what follows, we only consider elementary paths, elementary cycles and minimal conflicts, without explicitly mentioning the terms elementary and minimal.
Conflict detection and resolutionIf the basic alignment procedure is stalled because of conflicts (i.e. no alignable set can be found among the active nodes), we want to determine which links are involved in these conflicts and which links are to be removed from G. For now, we only consider the active links as candidates for removal. In the next section, we will prove that this approach is indeed a valid one. Consider an active link between nodes n i,a i and n j,k , with i = j and k  a j (with a j the index of the active node n j,a j ). For the simplicity of notation, these nodes are referred to as s and t, respectively, and the active link is denoted by L st. The link L st contributes to a conflict, if there is a blocking path P B between s and t or vice versa, between t and s. Indeed, the alignment of the link L st (or any other direct path P D between s and t) implies the ordering s  t. A blocking path P B from s to t implies s  t, and similarly, a blocking path from t and s implies s t. We refer to these conflicts as st-conflicts and ts-conflicts, respectively. To quantitatively investigate the number of conflicts that L st is involved in, we want to assess to which degree s and t are connected through blocking paths. In graph theory, such problems can be addressed by solving the wellknown maximum flow problem. For a formal definition of the maximum flow problem, we refer to. Intuitively, the maximum flow is the largest amount of 'flow' (e.g. fluid or current) that can be transported between two given nodes, called source and sink, respectively. Let f st be the maximum flow from node s to node t acting as the source and sink, respectively. As an extra restriction, it is imposed that a valid flow can only pass through elementary paths (either blocking or direct) from s to t. The edges have unlimited flow capacity; however, the flow can only pass in the sense indicated by the direction of the edge (from left to right). The links have a capacity equal to their weight w, but impose no direction on the flow. There exist many polynomial algorithms for the solution of the maximum flow problem. This is more thoroughly discussed in the Supplementary Material. Similarly, let f D st be the maximum flow from s to t through direct elementary paths. Note that this includes the flow through the link L st. Then clearly, f C st = f st f D st is the maximum flow from s to t through elementary blocking paths. As a consequence of the max-flow, min-cut theorem (), f C st is the minimum link capacity that has to be removed from G to disconnect s and t through elementary blocking st-paths, i.e. to resolve all st-conflicts. Similarly, f C ts can be calculated as the maximum flow through elementary blocking paths from t to s. We then use the following score to evaluate link L st :) capacity will need to be removed from G, regardless whether or not s and t are aligned. The term |f C st f C ts | therefore denotes the minimal, net capacity that will need to be removed from G if s and t are aligned. Similarly, f D st denotes the minimal capacity that will need to be removed from G if s and t will not be aligned. Clearly, a positive score for S Lst indicates that it is probably best to align s and t, whereas a negative score for S Lst indicates that it is probably best to remove the link L st from the graph. Note that if there are multiple st-paths, then these paths might be in mutual conflict. This fact is not taken into account by the link score S Lst. In other words, there is no guarantee that the capacity |f C st f C ts | will effectively be aligned, even if s and t are disconnected through direct paths. The algorithm for conflict resolution can now be described as follows. If, during the basic alignment procedure, described in Section 2.2, no alignable set S can be found among the active nodes, all active links are considered. For each of these links L, the score S L is calculated, and the link with the lowest scoreis repeated, until an alignable set S can be found among the active nodes.presents a simple example.
Active conflictsIn this section, a refinement to the conflict resolution algorithm is developed. Consider a conflict situation in the graph G(V ,E) (i.e. no alignable set S can be found among the N active nodes in G). Next, consider the subgraph G (V ,E )  G(V ,E) that only contains the active links (i.e. the links incident to the active nodes). We show that even in the reduced graph G (V ,E ), no alignable set can be found among the active nodes.Proposition 2. If, during the basic alignment procedure, no alignable set can be found among the N active nodes in the graph G(V ,E), at least one conflict is present among the active links. Furthermore, no alignable set can be found among the same active nodes in the subgraph G (V ,E ).
Proof. see Supplementary Material.Proposition 2 provides a more fundamental understanding of alignment conflicts. First, it shows that active links are indeed good candidates for removal. Indeed, even the removal of all non-active links would still not allow for the alignment of any of the active nodes. Second, it shows that if the basic alignment procedure is stalled, at least one conflict, consisting of active links, is present. Such a conflict is called an active conflict. None of the active nodes that are incident to a link in an active conflict can be aligned, as long as this conflict exists. Active conflicts are, therefore, high priority conflicts that need to be resolved instantaneously. In the case of conflicts, the active links can therefore be grouped into three categories: active links involved in at least one active conflict, active links involved in non-active conflicts and active links that are not involved in a conflict. The conflict resolution algorithm is, therefore, modified as follows. For each of the links L involved in at least one active conflict, calculate the score S L. The link with the lowest score is removed from G. It is easily determined whether or not an active link is involved in an active conflict,
Faster heuristics for conflict resolutionThe calculation of the maximum flow between two nodes in the graph is computationally expensive. However, upper bounds to the maximum flow can easily be derived. Given an active link L st between source node s = n i,a i and sink node t = n j,k , one can immediately notice that the final link in a blocking st-path necessarily ends in a node n j,k with k  k. Therefore, an upper bound to f C st,UB can be found by summing the weights w(L) of all links incident to these nodes:with j =seg(t) and k =ind(t). Similarly, blocking ts-paths necessarily end in the source node s and an upper bound f C ts,UB can therefore be established by summing the weights of the links L = L st incident to s.Finally, a lower bound to the direct flow f D st is simply given by f D st,LB = w(L st ). Therefore, a lower bound to the link score is given bySelecting the active link L with the lowest lower bound score S L,LB yields a much faster heuristic. Indeed, the calculation of S L,LB requires no maximum flow problems to be solved. Even though this lower bound estimation may be significantly underestimating the actual score S Lst , it still provides a powerful method to select a link for removal, if we assume that the link with the lowest lower bound score is also the link with the lowest score. Taking this reasoning even a step further, the heuristic can even be further simplified, if one assumes that the sum of the weights of the links, incident to a node, is constant for all nodes, i.e. that the links are evenly distributed among the nodes. Given a link L st between source node s = n i,a i and sink node t = n j,k , this means that f C st,UB is proportional to (k a j ), while f C ts,UB and f C st,LB are constant. This is clearly a rather rough approximation; however, it leads to the very simple and fast heuristic: select the active link incident to node n j,k for which the 'length' of the link (k a j ) is maximal (the 'longest' link). Such a link has the most possibilities for conflicting st-paths, and is hence a good candidate for removal. We now summarize the heuristics for conflict resolution and introduce three random methods. These random methods are not of any particular interest, but it is always interesting to compare the more mathematically supported methods to random methods. Select, in the case of a conflict, among the active links, the following link for removal: @BULLET RA (RAndom): a random link. @BULLET RC (Random Conflict): a random link that is involved in at least one (active or non-active) conflict. @BULLET RAC (Random Active Conflict): a random link that is involved in at least one active conflict. @BULLET LL (Longest Link): the link L, involved in at least one active conflict, incident to node n j,k for which (k a j ) is maximum. @BULLET LLBS (Lowest Lower Bound Score): the link L, involved in at least one active conflict, with the lowest lower bound score S L,LB. @BULLET LS (Lowest Score): the link L, involved in at least one active conflict, with the lowest score S L .
RESULTS AND DISCUSSION
DatasetsTo test the performance of multiple sequence alignment tools, a number of benchmarks have been introduced for both protein sequences [such as BALiBASE (), OXBench (), PREFAB () and SMART (and DNA sequences (). Because no similar benchmark exists to test the performance of gene list alignment tools, two ad hoc input datasets were generated by running the i-ADHoRe tool on the Arabidopsis thaliana (The Arabidopsis Genome Initiative, 2000) genome separately (Dataset I) and on the A.thaliana, Populus trichocarpa () and Vitis vinifera () genomes (Dataset II). Arabidopsis thaliana is a good candidate to validate the aligners and heuristics, since its genome contains both strongly diverged and more closely related homologous chromosomal regions (). Using the profile searches (), the i-ADHoRe algorithm produces 921 and 7821 sets of homologous genomic segments for Datasets I and II, respectively. The number of genomic segments N in these sets varies from 2 to 11 (Dataset I) and from 2 to 15 (Dataset II). For both datasets, the i-ADHoRe settings were gap size = 30, cluster gap = 35, q = 0.75 and p = 0.01. Tandem duplicates within a distance of gap size/2 were remapped onto the representative gene with the lowest index.
Alignment accuracyTo detect homologous segments, i-ADHoRe looks for statistically significant conservation of gene content and order. When two homologous segments are visualized in a dot plot, their collinearity shows up as a 'diagonal'. The homologous gene pairs between the two segments that are used by i-ADHoRe to detect these 'diagonals' are called anchors. These anchors are a subset of all homologous gene pairs between the two segments. By giving a higher weight to the links associated with anchors, they can effectively be used asPage: 754 749756N Number of input sets an alignment guide to improve the overall alignment quality. In all simulations, the weight w of the links corresponding to anchors was set to 1, whereas the weight of the other links was set to 0.1. These other links correspond to homologous genes that are further offdiagonal, and therefore less likely to be aligned in the final result. Note that more complex weight schemes could be incorporated, possibly improving alignment results. For example, the link weights could represent the probability that two genes are truly homologous. In this work, such schemes were not investigated. The proposed greedy, graph-based aligner (GG2) is compared to both a progressive application of the NeedlemanWunsch method (pNW) and the original greedy, graph-based aligner (GG). The pNW-aligner first performs a pairwise alignment of the two genomic segments that share the most anchor points, i.e. the two most closely related segments. Subsequently, a third segment is added to this intermediate result and so on. It should be noted that more advanced improvements to this basic progressive approach have been implemented, e.g. by using a guide tree to determine the order in which the segments are added () or by incorporating consistency-objective functions (). The original graph-based GG-aligner relies on the same 'basic alignment procedure' as the GG2-aligner; however, conflicts are handled in a more primitive fashion. In short, based on the number of links and their lengths (cf. Section 2.6), the GG-aligner calculates a score for each active node (as opposed to for each active link in the GG2-aligner). Instead of removing a single link, the GG-aligners removes all links incident to the active node with the lowest score. In the GG-aligner's heuristic, no thorough analysis of conflicting paths or links is conducted. In, the number of correctly aligned homologous genes for the profiles generated by the different aligners are compared for Dataset I. We consider two homologous genes to be correctly aligned if they are placed in the same column in the final result. This omits the need for a reference alignment. The numbers in, therefore, correspond to the sum-of-pairs metric. Each row shows the accumulated sum-of-pairs scores for all input sets with a specified number of segments N (N = 2...11). The final row represents the sum-of-pairs over all profiles, and can therefore be seen as a quality benchmark for the complete dataset. First, it is immediately clear that all random methods perform significantly worse than the more mathematically supported heuristics. The score of the RA-aligner is an indication of the number of homologous genes that can be aligned 'for free' by the basic alignment procedure. The fact that this score is rather high means that a fairly large number of links is not involved in any conflict. Indeed, if for example all input segments were identical (perfect collinearity and hence no conflicts), all methods would produce identical (and optimal) results. When comparing the numbers of the other aligners, it is important to keep this consideration in mind. The RC-aligner improves the RA score, by making sure that no active links are removed that do not contribute to any conflict. Interestingly, the alignment score is again significantly improved by using the RAC-aligner, which selects a random active link, involved in at least one active conflict. This provides experimental evidence for the observations made in Section 2.5, i.e. that active conflicts are highpriority conflicts. Note that in the case of a conflict for N = 2, all active links are necessarily involved in an active conflict. Therefore, the RA, RC and RAC heuristics perform equally well for N = 2. The LL, LLBS and LS heuristics strongly outperform both the random methods and the original GG-aligner, and, albeit to a somewhat lesser extent, also the pNW-method. Unsurprisingly, the pNW-aligner is best for N = 2, since it produces optimal results. The LL, LLBS and LS methods, however, also obtain close to optimal results. For larger N, the relative difference in score between pNW on the one hand and LL, LLBS and LS one the other hand increases. This is to be expected: erroneous alignment decisions in early pairwise steps of the pNW-aligner propagate when more segments are added. The graph-based methods are more robust in the sense that they take the links on all segments into consideration. For higher N, the difference in score between LS and pNW is larger than 10%. In total, the LS-method is able to align 846 (4.
J.Fostier et al.
4%) morePage: 755 749756. The difference in alignment quality among the LL, LLBS and LS heuristics is rather modest; however, it can be observed that LL < LLBS < LS, for nearly all N. Despite the simplicity of the LL heuristic, this method still performs remarkably well, and even outperforms the pNW method on this dataset. The biggest difference between these methods lies in the alignment speed. This will be discussed in more detail in the next section. It is important to mention that the relative difference in alignment quality between the pNW on the one hand and the LL, LLBS and LS heuristics associated with the GG2-aligner on the other hand decreases for datasets that consist of genomic segments that are less diverged. For instance,lists the alignment scores for Dataset II. Even though the ranking of the different alignment methods remains the same, the relative difference in alignment score is smaller. This is due to the fact that relatively fewer alignment conflicts exists in this dataset, which can be seen from the high score of the random aligners.
Alignment of multiple homologous gene lists
Program runtimeA comparison for the alignment times of the different heuristic methods can be found infor the larger Dataset II. Except for the LS heuristic, the total alignment times are very low. The unfavorable time complexity of the LS heuristic prohibits the alignment of sequences with larger N. In practice, when N > 10, the CPU time for the LS method rapidly increases. In i-ADHoRe, we therefore offer the LLBS heuristic by default. Experiments on an extremely large dataset consisting of dozens of eukaryotic species () have shown that this method can easily handle N=50, enough for most practical problems. A detailed analysis of the computational complexity of the algorithm is given in Supplementary Material.
Comparison of i-ADHoRe to related toolsThe GG2-aligner is an important component of i-ADHoRe, which detects evolutionary-related genomic regions within or between related species through sensitive iterative profile searches. In contrast to this approach, CYNTENATOR () and the method described bycompute multiple gene order alignments progressively using initial pairwise alignments and a guide tree. DRIMM-Synteny () detects non-overlapping synteny blocks to perform rearrangement analysis in duplicated genomes and reconstruct ancestral genomes. Although our method does not infer likely evolutionary paths of genome evolution events, the application of the profile search on the Arabidopsis genome (Dataset I) identifies a much larger fraction of the genome in duplicated blocks, compared with DRIMM. Pham and Pevzner report fractions of 66 and 8% in duplicated blocks with a multiplicity of at least two and at least four, respectively, whereas i-ADHoRe detects 90.3 and 25.8%, respectively. In agreement with the yeast results reported by DRIMM, including a more ancestral genome lacking a recent wholegenome duplication (e.g. Vitis in Dataset II) serves as a reference backbone to identify and align highly diverged Arabidopsis genomic segments (Van de).
CONCLUSIONWe have developed a greedy, graph-based algorithm for the alignment of multiple, homologous gene lists. Several properties of conflicts within the alignment graph have been derived and proved. Three heuristics for conflict resolution were developed on these theoretical grounds, and have been demonstrated to be able to outperform an older graph-based algorithm and a progressive approach in terms of alignment accuracy. As is often the case, a tradeoff between computational requirements and alignment accuracy can be observed. The algorithm has been implemented in the latest version of i-ADHore 3.0.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
