Motivation: Alignment-free methods for sequence comparison are increasingly used for genome analysis and phylogeny reconstruction; they circumvent various difficulties of traditional alignment-based approaches. In particular, alignment-free methods are much faster than pairwise or multiple alignments. They are, however, less accurate than methods based on sequence alignment. Most alignment-free approaches work by comparing the word composition of sequences. A well-known problem with these methods is that neighbouring word matches are far from independent. Results: To reduce the statistical dependency between adjacent word matches, we propose to use 'spaced words', defined by patterns of 'match' and 'don't care' positions, for alignment-free sequence comparison. We describe a fast implementation of this approach using recursive hashing and bit operations, and we show that further improvements can be achieved by using multiple patterns instead of single patterns. To evaluate our approach, we use spaced-word frequencies as a basis for fast phylogeny reconstruction. Using real-world and simulated sequence data, we demonstrate that our multiple-pattern approach produces better phylogenies than approaches relying on contiguous words. Availability and implementation: Our program is freely available at
INTRODUCTIONTraditional methods for comparative sequence analysis and phylogeny reconstruction rely on pairwise and multiple sequence alignments (). A major problem with these methods is that they are relatively slow because aligning two sequences takes time proportional to the product of their lengths. With the huge amount of sequence data that are produced by new sequencing technologies, faster methods for sequence comparison are required. Alignment-free methods became popular in recent years, as their runtime is usually proportional to the total sequence length; see Vinga and Almeida (2003) for a review. Alignment-free methods are increasingly used for genome comparison, in particular for genome-based phylogeny reconstruction (), but also for fast protein clustering (). These approaches are not only much faster than conventional alignment-based methods, but they also overcome some notorious difficulties in phylogenomics, such as finding ortholog genes () or aligning large genomic sequences (). Other advantages of alignment-free genome comparison are that they can work with unassembled reads () and are not affected by genome rearrangements. Alignment-free methods are also used to construct guide trees for progressive multiple alignment (). This could crucially improve the runtime of multiple-alignment algorithms, as calculating guide trees becomes the most timeconsuming step in progressive alignment if the number of sequences grows. Most alignment-free methods are based on word frequencies. For a fixed word length k, they calculate a (relative) wordfrequency vector for each of the input sequences. Various distance measures on vector spaces can be used to calculate a pairwise distance matrix from these word-frequency vectors (). Phylogenetic trees can then be calculated from these distance matrices with standard methods such as UPGMA () or NeighbourJoining (). Other alignment-free approaches define the local context of sequence positions in terms of overlapping words containing a position (). Some methods do not rely on a fixed word length k but allow for matches of variable length (). A common feature of all these methods is, however, that they are based on exact word matches between the input sequences. Database searching is another traditional application of word matching in sequence analysis. Fast local alignment programs such as BLAST () originally relied on identifying word matches of a fixed length, so-called seeds. Rapid indexing methods can be used to identify such 'seeds', *To whom correspondence should be addressed.  The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/3.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited. while, in a second phase of the algorithm, seeds are extended into both directions to find statistically relevant high-scoring segment pairs. In a pioneering paper,proposed to use spaced seeds instead of contiguous-word matches as a first step in homology searching. Here, a fixed pattern or 'mask' of match and don't care positions is defined, and two words of the corresponding length are considered to match if they coincide at the specified match positions, while mismatches are allowed at the don't care positions. An obvious advantage of this approach is that word matches at nearby positions are statistically less dependent on each other than contiguous-word matches are. Also spaced seeds are better able to identify homologue sequence regions in the presence of mismatches. Ma et al. showed that spaced seeds are superior to contiguous-word matches in terms of sensitivity and speed; see also Brown (2008) for an overview. Recently, we proposed to use spaced words, defined by patterns of match and don't care positions, as a basis for alignment-free sequence comparison (). Instead of using spaced-word matches to trigger local alignments, we compare the spaced-word composition of sequences to define a measure of global similarity between them. In the present article, we describe an efficient algorithm based on recursive hashing and bit operations to calculate and compare spaced-word frequencies and we extend our approach to distance measures defined by multiple patterns. We use these distance measures to construct phylogenetic trees for real-world and simulated DNA and protein sequence families, and we compare our method to established alignment-free methods using contiguous-word frequencies, as well as to a traditional alignment-based approach. Our results show that, for phylogeny reconstruction, spaced words based on multiple patterns are superior to existing alignment-free methods that rely on contiguous words. A user-friendly web interface for our program is described by).
CALCULATING SPACED-WORD FREQUENCIESAs usual, for an alphabet AE and ' 2 N, AE ' denotes the set of all sequences over AE with length '. For a sequence S 2 AE ' and i ', Si denotes the i-th character of S. Instead of 'sequence', we also use the term 'word' or 'contiguous word' to distinguish them from the spaced words that we are going to define. In our context, the alphabet AE represents the set of nucleotides or amino acids, respectively. In analogy to the terminology introduced by, we define for integers k ' a spaced word w of length ' and weight k as a pair w 0 , P where w 0 2 AE k is a 'contiguous word' of length k and P 2 f0, 1g ' is a sequence of '0' and '1' characters of length ', such that there are exactly k positions i in P with Pi  1. We call P the underlying pattern of w. In addition, we require that P1  P'  1 holds, i.e. the first and the last characters in P must be '1'. The '1' positions in the pattern P denote match positions, while the '0' positions are the don't care positions. Let w  w 0 , P be a spaced word with weight k and length ' such that p 1 5. .. 5p k are the positions of the '1' characters in P. We say that w occurs in a sequence S at position i if Si  p j  1  w 0 j for all 1 j k. For example, the spaced word w  w 0 , P with w 0  AGT and P  11001 occurs in the sequence S  GGAGCTTCAGGATCC at positions 3 and 9. To define a distance function on a set of input sequences S 1 ,. .. , S N over AE, we first consider a single fixed pattern P with weight k. For each sequence S i , we calculate the relative frequencies of all possible spaced words with respect to our pattern P (relative to the sequence length) and, similar as in other alignment-free approaches, each sequence S i is represented by the jAEj k-dimensional vector of these relative frequencies. It is then straightforward to define a distance d P S i , S j  between two sequences S i and S j as the distance between these frequency vectors, using some standard distance metric on vector spaces. This approach can be generalized by considering a whole set P  fP 1 ,. .. , P m g of patterns instead of a single pattern PWe call this extension the multiple-pattern version of our spaced-word approach.
IMPLEMENTATIONTo calculate the frequencies of spaced words in a sequence with respect to a pattern P, we implemented a hash function that maps each spaced word to an integer in 0, 2 64 . We first consider contiguous words of length k and define the i-th word of sequence S as w i  SiSi  1. .. Si  k  1. A fast way to hash successive words is by using a hash function h for which the value hw i1  can be calculated in constant time from the previous value h(w i ) by removing the value of the i-th character and adding the value of the new character at i  k. Such hash functions are called recursive or rolling (). In practice, we used recursive hashing by cyclic polynomials (), which is also known as Buzhashing (). While this approach is fast, it is possible, in principle, that collisions occur, i.e. that two different words are mapped to the same hash value. We do not correct such collisions but, instead, we define our hash function in such a way that the probability of such collisions is minimized. To this end, we use a hash function that provides a good uniformity for arbitrary input strings. First, we define a constant table rtab containing 256 values of 64-bit, assigning to each character of the alphabet AE an integer in the interval 0, 2 64 . According to, a uniform distribution of the resulting hash values is ensured by defining this array such that every vertical bit position has exactly 128 zeros and 128 ones. With this definition, collisions are extremely unlikely. In all test runs that we performed, we did not observe a single collision. Next, we define the function s as the barrel shift that rotates the bits by one position to the left, e.g. we have s1100  1001.  is denoted as the bitwise exclusive or operator. With these definitions, we define the hash value for a word w i asOnce h(w 1 ) is calculated with this formula, the values hw i , i ! 2, can be calculated recursively as hw i1   shw i   s k rtabSi  rtabSi  k 3Note that, with this recursion, all hash values h(w i ) can be calculated for a sequence S of length n in On time, independently of the word length k. The advantage of using bit operationscompared with recursive hashing with multiplications and divisionsis that rotating bits is much faster than these algebraic operations. So far, we only considered contiguous words. The above recursive formula (3) can be easily adapted to spaced words as long as the number of don't care positions in the underlying pattern is small. To do this, we first calculate the hash value for words of length ', and we then remove the terms corresponding to the don't care positions in the underlying pattern. This corresponds to removing single characters from a word when a sliding window is moved to the next position. For example, if there is a single don't care at position p in the pattern, we calculate s kp rtabSi  p  1 and apply the  operator to erase the term corresponding to the character Si  p  1 to calculate the hash value hw i  for the spaced word starting at position i. Consequently, the time complexity of this approach is O'  k  n where k is the weight of the pattern P. However, if the number of don't care positions in P is greater than the number k of match positions, i.e. if k5 ' 2 , the recursive calculation is slower than the naive non-recursive approach, which calculates the hash values based on the match positions in the underlying pattern. In this case, the hash value h(w i ) must be explicitly calculated for each spaced word w i leading to an On  k algorithm. To store the frequencies of all spaced words in a sequence, we implemented a simple hash table. To determine an appropriate size of our hash table, we first calculate the maximum number of distinct (spaced) words. Clearly, for a sequence S and a pattern P of weight k and length ', the maximum number of distinct spaced words in S is given by minjAEj k , n  '  1 where n is the length of S. According to this observation, we choose as hash table size the smallest integer b such that 2 b 4minjAEj k , n  '  1. We then keep the b most significant bits of our 64-bit hash value, which is achieved by shifting the bits 64  b times to the right. These b bits are used as index in the hash table, resulting in a complexity of O1 on average for the common operations such as search or insert. We handle collisions by sequentially searching the hash table for a free location, which is known as open addressing. This method led to a better performance in our tests than an alternative approach using linked lists. Once the word frequencies are determined for our input sequences, we can easily compare them for different sequences, as a basis to calculate pairwise distances values. To do so, we iterate over both hash tables and for each key we search the equivalent key in the other hash table, which can be accomplished in O1 as mentioned above. If the key is not found in a hash table, then the corresponding spaced word does not occur in the other corresponding sequence. In our multiple-pattern approach, we need to calculate spacedword frequencies for a large number of patterns. To do this efficiently, we implemented multithreading in our program to increase the speed. Both steps, counting word frequencies and calculating pairwise distances are easily parallelizable. We are using threads to determine the word frequencies as well as for the computation of pairwise distances. The JS metric was also used byfor their Feature Frequency Profile (FFP) approach. In addition, we applied the Euclidean distance to the relative-frequency vectors obtained with our multiple-pattern approach. Finally, we applied the NeighbourJoining program () from the PHYLIP package () to calculate unrooted trees from these distance matrices. As a comparison, we applied three state-of-the-art alignment-free approaches, Average Common Substring (ACS) (), K r () and FFP (), as well as a traditional approach to phylogeny reconstruction using Clustal W () and Maximum Likelihood (). For ACS, we used our own implementation () because the original software is not publicly available. For FFP, we used the word length that gave the best results for a given category of benchmark sequences. To evaluate these different methods, we compared for each sequence set the resulting trees with the corresponding reference tree using the RobinsonFoulds (RF) metric (). As test data for genomic sequence comparison, we used a set of 27 primate mitochondrial genomes that have been previously used byto benchmark alignment-free methods. For these sequences, a reliable phylogenetic tree is known that is based on multiple sequence alignment and 1993
Spaced wordsMaximum Likelihood. Further, we used a set of 13 fully sequenced flowering-plant genomes from the Malvidae clade plus the grape vine genome as outgroup. As a reference tree for these 14 genomes, we used a tree based on a multiple sequence alignment of manually assembled CAP and Arp2/3 protein sequences as published by Hatje and Kollmar (2012). To benchmark our approach on protein sequences, we used BAliBASE 3.0, a standard benchmark database for multiple alignment (). BAliBASE consists of 218 sets of related protein sequences together with reference multiple alignments based on 3D superposition that are considered to be reliable. As BAliBASE contains no information about the underlying phylogenetic trees, we constructed a reference tree for each sequence set by applying the standard Maximum Likelihood method () to the corresponding reference multiple alignment. In addition to these real-world benchmark sequences, we generated a large number of simulated genomic and protein sequence sets using the program Rose (). This program mimics molecular evolution by producing a set of sequences along an evolutionary tree, starting with a common ancestral sequence at the root. Substitutions, insertions and deletions are randomly incorporated according to a pre-defined stochastic model of molecular evolution. As a result, sets of 'evolutionarily' related sequences are produced, together with known phylogenetic trees that we used as reference trees in our study. A parameter called relatedness determines the average evolutionary distance between the produced sequences, measured in PAM units (). For DNA sequence comparison, we created a set of 50 sequences of 16 000 nt length each using Rose with a relatedness value of 70. To obtain simulated protein benchmark data, we generated a set of 125 protein sequences with a length of 300 aa each. Here, we used a relatedness value of 480. Except for the relatedness values, Rose was run with default values. For all of these benchmark sequence sets, except for the 14 plant genomes, we first calculated trees based on contiguousword frequencies, and we identified the word length k that produces the best results for the respective category of sequence sets, i.e. the trees with the smallest RF distances to the respective reference trees. For this value of k, we then generated patterns with weight k, i.e. with k match positions, and with up to 30 don't care positions, i.e. with a length ' between k  1 and k  30. For each ', we randomly selected a set P ' of 100 patterns of length ' and weight k. For small values of ' where5100 patterns are possible, we defined P ' as the set of all possible patterns. For each ' and each pattern P 2 P ' , we applied our singlepattern approach and then calculated the average RF distances of the obtained trees to the respective reference trees. In addition, we applied our multiple-pattern approach by calculating the pairwise distance values d P' S i , S j  for each sequence set using all patterns P 2 P ' according to Equation (1). Moreover, we generated pattern sets P with 100 randomly selected patterns of weight k and with varying length ' for the multiple-pattern approach. We repeated these test runs using different sets of random patterns and calculated the standard deviations of the obtained RD distances to the reference trees. Note that this re-sampling is only possible if ' is large enough because for a short pattern length ', the number of possible patterns is too small.
TEST RESULTS
Genomic sequencesFor the primate mitochondrial genomes, the approach with contiguous words produced best results with a word length of k  9, leading to a phylogeny with a RF distance of 4 to the reference tree. Thus, we generated patterns P with weight k  9 and length ' between 9 and 39, i.e. with 9 'match' positions and up to 30 'don't care' positions. The results are shown in. For each pattern length '4k, spaced words outperformed the standard contiguous words ('  k). For practically all values of ', the multiple-pattern approach with the JS distance led to better results than the singlepattern approach with the same pattern length '. For some values of ', the RF distance to the reference tree was 0, so here the tree topology reconstructed by our approach precisely coincides with the reference topology. For values '519, the multiple-pattern approach with the Euclidean distance performed worse than with the JS distance and even worse than the single-pattern approach. For longer patterns, however, the Euclidean distance performed better; for '420, multiple patterns with the Euclidean distance produced perfect tree topologies, i.e. the RF distance was 0. The established alignment-free approaches K r and ACS performed worse than spaced words with single or multiple patterns for all '410. FFP performed better than these two approaches, but was outperformed by multiple spaced words with the Euclidean distance for all pattern lengths '418 and by multiple spaced words with the JS distance for most values '413. The test results for our plant genomes are shown in. Here, we used a set of 60 patterns of weight 14 and variable length. For our simulated DNA sequences, we found that contiguous words with length k  8 gave the best results, with an average RF distance of 50 to the respective reference trees. We therefore generated patterns with weight k  8 and with length ' between 8 and 38. The results of these test runs are summarized in. As can be seen, spaced words with single patterns and one or several don't care positions ('4k) performed better than the usual approach with contiguous words (k  0), as long as the number of don't care positions is small. The relative improvement in the quality of trees is modest, however, and if the number of don't care positions is increased, the tree quality deteriorates. By contrast, a substantial improvement could be achieved by using our multiple-pattern approach. Here, increasing the pattern length 'i.e. increasing the number of don't care positionsfurther improved the resulting trees, leading to average RF distances of around 16 between the constructed trees and the reference trees. On these sequences, the difference between JS and Euclidean distance was small. The three competing alignment-free methods were clearly outperformed by our multiplepattern approach. A classical approach using multiple sequence alignment and maximum likelihood led to slightly better results than our multiple-pattern program.
Protein sequencesOverall, our test results on proteins were similar to the results on DNA. On BAliBASE, a word length of k  4 produced best results for contiguous-word frequencies. Thus, we used patterns with weight k  4 and lengths ' between 4 and 34.shows the results of these test runs. Again, the spaced-words approach with single patterns gives better results than with contiguous words, but only for word lengths ' up to 7; a further increase in word length by using more don't care positions led to deteriorated results, with RF distances to the reference trees larger than for contiguous-word frequencies. By contrast, the results of our multiple spaced-word approach led to better trees, and the quality of the trees further improved when the number of don't care positions was increased. On these benchmark data, the results of our multiple-pattern approach were best when patterns of varying length were combined. Finally, the results of our test runs on simulated protein families are shown in. Again, using distances based on single patterns improved the quality of the resulting trees compared with distances based on contiguous-word frequencies, but the improvement was relatively small and could only be achieved for small numbers of don't care positions. Using distance measures combining different patterns led to far better results. As with the real-world protein sequence sets, the multiple-pattern approach with varying pattern lengths gave the best results. On our simulated protein families, this approach led to even better results than the classical approach based on multiple alignment and likelihood.
The number of patterns and program runtimeIn the above test runs, we applied the multiple-pattern version of our approach with sets of m  100 randomly selected patterns (m  60 for the plant genomes) or used all possible patterns where fewer than m patterns are possible. The multiple-pattern option improved the performance of our method but is more expensive in terms of program runtime compared with the single-pattern version. To study the influence of the number m of patterns on the resulting trees, we used a set of 50 simulated DNA sequences of. Test results on a set of mitochondrial genomes from 27 different primates; see Sections 4 and 5 for details. For a fixed pattern weight of k  9, we generated patterns of length ' between 9 and 39, i.e. with 9 match positions and up to 30 don't care positions. For each length ', we randomly generated a set P ' of 100 patternseach pattern with k  9 match positions and '  9 don't care positionsand calculated pairwise distances (i) using all single patterns P 2 P ' and (ii) using our multiple-pattern option where one distance value is calculated for a sequence pair using all patterns from P '. In addition, we used a set P ' consisting of patterns with weight of k  9, and with a variable number of don't care positions (''  var.'). We measured the average RF distances between the generated trees and the respective reference trees; the smaller these distances are, the better are the trees produced by a method. Where no green or yellow bar is visible, the RF distance is zero, i.e. here the tree topology calculated with the multiple-pattern approach exactly coincides with the reference topology. For the multiple-pattern approach, we repeated the test runs with 100 randomly selected sets of 100 patterns each and calculated the standard deviations of the resulting RF distances. For the single-pattern approach, we calculated the standard deviation for the 100 test runs with different patterns. Standard deviations are shown as error bars. Note that for '  k, only one single pattern exists so here no standard deviations could be calculated. For small values of ',5100 patterns are possible, so only a single set P exists and standard deviations cannot be calculated for the multiple-pattern approachlength 16 000 nt and a set of 125 simulated protein sequences of length 300 aa. We applied our multiple-pattern method to these datasets using different values of k and ' and pattern sets P of different size m. The results of these tests are shown in Figures 6 and 7. As can be seen, the quality of the resulting trees improves if the number m of patterns is increased to 60 or 70, but a further increase in m does not lead to a significant improvement of tree quality. To compare the runtime of our approach with other methods, we used two benchmark sets: a set of 50 simulated DNA sequences of 16 000 nt each and our test set of 14 plant genomes. In addition to the aforementioned programs for sequence comparison, we used Clustal (). All programs were run on an Intel Core i7 4820 k overclocked to 4.75 GHz. This CPU supports up to eight threads, which were fully used by our multithreading implementation. The results of these test runs are shown in Tables 1 and 2, respectively. Clustal W and Clustal are omitted inbecause they cannot be meaningfully applied to the whole genomes that we used.with word length  14 and multiple spaced words (F) with weight k  14 using a set of m  60 patterns. RF distances to the reference tree are ACS: 6, FFS: 10, K r : 18, contiguous words: 10, multiple spaced words: 6. Test results on BAliBASE; the spaced-word approach was used with a pattern weight of k  4. Notation as in. For the multiple-pattern approach, 20 sets P of patterns were generated, each set consisting of (up to) 100 patterns. Standard deviations of the RF distances for these 20 different pattern sets are shown as error bars for each value of '. For the single-pattern version, 100 program runs with different patterns were performed and the standard deviation calculated. For the multiple-pattern option, standard deviations are so small that most error bars are not visible
Variation of sequence distances calculated with spaced wordsAs mentioned, a main advantage of spaced-word frequencies is that occurrences of spaced words at different sequence positions are statistically less dependent on each other. Distance measures using spaced words can therefore be expected to be more stable. To study this point in detail, we generated 100 pairs of DNA sequences of length 16 000 nt with Rose and applied single and multiple spaced words to these sequences with w  7 and ' between 7 and 37. We then calculated the variation coefficients of the resulting distance values. The results are summarized in. As can be seen, the variation coefficients of the spaced-word distances are lower than for the standard exactword approach (k  0), and lower for the multiple-pattern option than for the single-pattern option.
DISCUSSIONAlignment-free methods are regularly used to estimate evolutionary distances between DNA and protein sequences and to construct phylogenetic trees. Most of these methods are based on word frequencies. Such approaches are usually less accurate than traditional phylogeny approaches that are based on multiple sequence alignments, but they are much faster. While aligning two sequences takes time proportional to the product of their lengths (), word frequencies can be calculated in linear time. A certain disadvantage of word-based methods is the fact that word occurrences at neighbouring sequence positions are far from independent. For this reason, some authors proposed to correct word statistics by taking overlapping word matches into account (Goke). In database searching, word matches have been replaced by so-called spaced seeds where string matches according to a nonperiodic pattern P of match and don't care positions are used (). Motivated by this approach, we proposed to use spaced words instead of the traditionally used contiguous words to estimate distances between sequences and to construct phylogenetic trees. While, under an i.i.d. sequence model, the expected number of occurrences of a spaced word is approximately the same as for the corresponding contiguous word (obtained by removing the don't care positions), spaced-word. Test results on simulated protein sequences; the spaced-word approach was used with a pattern weight of k  4. Notation as inFig. 7. Influence of the number of patterns on the results of Spaced words applied to a set of 125 simulated protein sequences of length 300 aa, generated with Rose. Sets P of patterns generated as in. Note that for short pattern lengths ', the set of all possible patterns is limited, so for '  9 and 14, only small values of m could be tested. Influence of the number of patterns on the results of our multiplepattern approach. The program was run on a set of 50 simulated DNA sequences of length 16 000 nt each, generated with Rose. For k  8, different values of ' and m  10,20,. .. ,150, we generated 100 sets P of patterns each, every set P containing m patterns. The quality of the produced trees, measured as the average RF distance of the 100 trees to the respective reference trees, is plotted against m
1997Spaced words matches at neighbouring sequence positions are less dependent on each other if a non-periodic pattern P is used. In the first version of this spaced-word approach, we used a tree structure to find matching spaced words (). Herein, we described an efficient algorithm and implementation based on recursive hashing and fast bitwise operations. While in general, algorithms using suffix-trees have the same linear time complexity as hashing algorithms, tree-based pattern searching is more difficult in our approach where patterns contain don't care positions. Furthermore, the bitwise operations that we are using are much faster than operations on characters. The efficiency of our new approach enabled us to introduce a multi-pattern version where spaced-word frequencies with respect to an entire set P of patterns are used instead of a single pattern P. Our test results show that spaced-word frequencies based on a single pattern with a small number of don't care positions lead to better phylogenetic trees than contiguous-word frequencies, although the improvement that we could achieve with this first approach was limited; see also. By contrast, we obtained a significant improvement by using our multiplepattern approach. Here not only the resulting phylogenetic trees are superior to trees constructed with contiguous-word frequencies or single-pattern spaced words, but also the results are less sensitive to the number of don't care positions. On simulated DNA and protein sequences, the multiple-pattern approach led to results not much worseand sometimes even betterthan the classical alignment-based approach to phylogeny reconstruction. While the results of the single-pattern method strongly depend on the underlying pattern P (), our new multiple-pattern approach led to high-quality results with randomly selected sets P of patterns and the resulting trees are statistically more stable. However, the runtime of this approach is longer than if a single pattern is used, it is roughly proportional to the number of patterns in P. The single-pattern version of our approach is faster than all other programs that we tested, but the multiple-pattern version is slower than some state-of-the-art alignment-free methods. A program run on a set of 14 fulllength plant genomes that cannot be handled by multiple-alignment methods took $4 min with the single-pattern version and about five and a half hours with the multiple-pattern version using a set P of 60 patterns. A crucial parameter in our approach is the weight k of the patterns, i.e. the number of match positions. Clearly, optimal values for k depend on the length of the input sequences. In our study, we experimentally determined for a given group of sequences the optimal weight k for contiguous patterns and used this same value for our spaced patterns. First test results indicate that the optimal weight for contiguous-word matches also works best for spaced words (data not shown). There is no guarantee, however, that this is always the case, so further research is necessary to find suitable weights for k depending on the input sequences. Another open question is which size m of the set of P of patterns should be used.demonstrate that increasing m generally increases the quality of the resulting trees. For m460 or 70, however, no significant further improvement could be achieved in our test examples. It would be desirable to have a general rule to find a suitable number m of patterns in the multiple-pattern approach, depending on the input sequences. Finally, it is not clear which distance measure on the spacedword frequency vectors is most suitable in our approach. In this study, we used the JS and Euclidean distance measures, but other distances may be more suitable to estimate. Variation coefficients of distance values calculated with spacedand contiguous-word frequencies using single patterns (upper curve) and multiple patterns (lower curve) on 100 pairs of simulated DNA sequences; see subsection 5.4 for details. Note that for 0 don't care positions, the spaced-word approach coincides with the contiguous-word approach (and the multi-pattern version coincides with the single-pattern version, as only one single pattern is possible for a given number k of match positions). Thus, for 0 don't care positions, our graphic shows the variation coefficient for the classical contiguous-word approachNote: Contiguous and spaced words were run with k  8 match positions. The multiple-pattern option was used with sets P of 100 randomly selected patterns of varying length.Note: Contiguous and spaced words were run with k  14 match positions. Multiplepattern was run with 60 patterns of varying length. phylogenetic distances between DNA or protein sequences based on their spaced-word frequencies. To answer these questions, the statistical properties of spacedword frequencies need to be analysed in detail, as has been done for the hit probabilities of spaced seeds in database searching (). Results on the probability of word occurrences () may help to better understand the behaviour of our method theoretically, to optimize its parameters and to further improve its performance.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
BENCHMARK SET-UP To evaluate our approach and to compare it with other sequence-comparison methods, we used benchmark sequence sets from different sources: for DNA and protein sequence comparison, respectively, we used real-world as well as simulated sequence sets. Each sequence set consists of a number of evolutionarily related sequences together with a reference tree that we consider to be reliable. For all sequences, we calculated the relative frequencies of contiguous as well as spaced words using the above-described single-pattern and multiple-pattern approaches. To obtain distance matrices for these sequence sets, we applied the Jensen Shannon (JS) distance metric (Lin, 1991) to the obtained relative-frequency vectors. The JS distance between two frequency vectors P and Q is defined as JSP, Q  1 2 KLP, M  1 2 KLQ, M
C.-A.Leimeister et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
