Motivation: The development of high-throughput sequencing technologies has enabled novel methods for detecting structural variants (SVs). Current methods are typically based on depth of coverage or pair-end mapping clusters. However, most of these only report an approximate location for each SV, rather than exact breakpoints. Results: We have developed pair-read informed split mapping (PRISM), a method that identifies SVs and their precise breakpoints from whole-genome resequencing data. PRISM uses a split-alignment approach informed by the mapping of paired-end reads, hence enabling breakpoint identification of multiple SV types, including arbitrary-sized inversions, deletions and tandem duplications. Comparisons to previous datasets and simulation experiments illustrate PRISM's high sensitivity, while PCR validations of PRISM results, including previously uncharacterized variants, indicate an overall precision of $90%. Availability: PRISM is freely available at
INTRODUCTIONThe development of high-throughput sequencing (HTS) technologies has enabled novel methods for detecting structural variants (SVs). Current methods, which are usually based on depth of coverage (), pair-end mapping clusters () or a combination of these (), have been successful in quantifying structural variation in individual genomes and populations (). However, most of these only report an approximate location for each SV, rather than exact breakpoints. Accurate mapping of split reads (reads that span across a breakpoint of an SV) is evidence for the linking relationship of the segments that are adjacent in the sequenced genome (donor) but not in the reference human genome. Split-read based methods, such as Pindel (), Splitread () and SVseq (), while able to identify these breakpoints, have been limited in their ability to identify large-scale 'structural' variants. These tools take the approach of aligning the split read only in the immediate vicinity of the read's pair and thus limit the maximum discoverable variant size. Pindel and Splitread take a user-specified maximum indel size as a parameter, while SVseq uses a fixed constant. Typically, the running times and accuracies of the programs heavily depend on this parameter, as alignment of a small portion of the read to a large segment of the human genome is computationally intensive and error-prone. Several recent approaches () combine the split-mapping signature with additional information: the depth of coverage and discordant paired ends, respectively. However, the Nord et al. method can only be used with capture data rather than whole genomes, and the Zhang et al. method (SVseq2) only handles indels and not other SVs. The recent CREST method () takes an alternative approach for assembling the unaligned clipped ends of reads and mapping these to the genome. We have developed pair-read informed split mapping (PRISM), a method that makes use of discordant pair-end clusters to direct split-read mapping. The use of discordant clusters allows us to substantially reduce the search space for split mapping, leading to faster run times and significantly higher accuracy at identifying large deletions and other structural variants. PRISM also uses a modification of the Needleman-Wunsch (NW) algorithm for the base-level alignment of the split read to enable high accuracy in the presence of SNPs, small indels and sequencing errors proximal to the SV.
METHODS
OverviewThe PRISM method relies on a thorough analysis of hanging read pairs (where only one of the two mates has a reliable mapping). PRISM uses clusters of discordant read pairs (pairs which have abnormal mapping distance, orientation or order) as signals for the possible existence of large deletions, inversions and tandem duplications (). If the unmapped read could not be mapped because it spans the breakpoint of an SV, it should be split mappable to the two sides of the breakpoint (). A detailed description of the discordant pairs and split reads can be found in the review (). PRISM has two different strategies to select database and query *To whom correspondence should be addressed. sequences for SVs with and without discordant clusters. First, to identify small indels, each unmapped read of a hanging pair is aligned to the region approximately one insert size away from the location of the mapped one, while allowing for an unpenalized insertion or deletion in the alignment. Such indels may have been missed by the initial alignment due to a large gap penalty or insufficient sensitivity of the mapping program. If the hanging pair is located near a cluster of discordant pairs, PRISM attempts to align the unmapped read partially to the sequence near the mapped read and partially to the segment around the distal side of the cluster. The two segments are selected for full dynamic programming alignment, where an arbitrary 'jump' is allowed, so that the read aligns partially to one side of the breakpoint, and partially to the other. In the following sections, we present a thorough description of PRISM.
DefinitionsIn this section, we will define terms useful for presenting the PRISM method. All of these terms are illustrated in.(1) and are the mean and the standard deviation of the insert size, respectively.(2) Mapped pair: given a read pair P that consists of reads r1 and r2, if r1 and r2 are both mapped, P is a mapped pair.(3) Discordant pair: given a mapped pair P that consists of reads r1 and r2, if (i) the mapping distance between r1 and r2 is larger than  3 (we take the value  3 as a threshold for a discordant pair, though this can be set by the user) or (ii) the mapping orientation of r1 or r2 is different from sequencing orientation, read pair P is a discordant pair.(4) Concordant pair: if a mapped pair P is not a discordant pair, P is a concordant pair.(5) Anchor read and hanging read: given a read pair P that consists of reads r1 and r2, if r1 is mapped and r2 is not mapped, mapped with one or more indels, or has an unaligned section (soft clipping), r1 is an anchor read and r2 is a hanging read.(6) Hanging pair: if read pair P consists of an anchor read and a hanging read, P is a hanging pair.(7) Neighbor: given pair P consists of r1 and r2 and Q consists of s1 and s2. Assume without loss of generality that r1 is mapped to pos1 and s1 is mapped to pos2. If jpos1 pos2j 6, r1 and s1 are neighbor reads, while P and Q are neighbor pairs.(8) Concordant region: given a hanging pair P that consists of reads r1 and r2, where r1 is the anchor read mapped to pos1 and assume pos2 is pos1  insert size. Given an interval d (the value depends on in what region the breakpoint of the SV is expected to be, usually about 3), the region [pos2  d, pos2  d] is a concordant region for P. We call the region [pos2  d, pos2  d] a concordant region when there is no ambiguity.(9) Discordant region: given a discordant pair P that consists of read r1 and r2, r1 is mapped to pos1 and r2 is mapped to pos2. Given another read pair Q that consists of read s1 and s2, s1 is an anchor read mapped to pos3 and s2 is a hanging read. If r1 is a neighbor read of s1, given an interval d (the value depends on in what region the breakpoint of the SV is expected to be, usually smaller than ), we call region [pos2  d, pos2  d] a discordant region for Q from P. We simply call region [pos2  d, pos2  d] a discordant region when there is no ambiguity. In practice, we use clusters of discordant pairs to identify discordant regions: each cluster has two feet corresponding to the two ends of a pair.
PRISM workflowRunning PRISM consists of five stages: mapping reads, preprocessing mapping result files, clustering discordant pairs, split mapping and calling SVs. PRISM typically deals with one chromosome in each execution, though it is also possible to combine the chromosomes to detect translocation events (see Supplementary Section S4.5).Stage 1: Mapping reads We map the reads using BWA (version 0.5.9rc1;) with default settings. A series of SAM () files are generated and processed in the subsequent stages.Stage 3: Clustering We identify all discordant pairs and cluster these with the paired read clustering tool used in CNVer (). This program uses a greedy algorithm that clusters together pairs with similar mapping distance and orientation. The details of this algorithm can be found in the original article. The generated discordant clusters are used together with hanging pairs in the next stage.Stage 4: Split mapping This stage is the core of PRISM. It scans the hanging pairs generated in Stage 2, trying several split mappings. First, for each hanging read PRISM tries to align it in the concordant region, allowing for one insertion or deletion with a fixed penalty (regardless its size). Additionally, if there are discordant clusters located within the concordant region, the hanging read is also aligned in a way that allows part of it to map to the concordant region and the other part to the discordant region. PRISM uses a modified NW algorithm for split mapping, described in Section 2.3. PRISM generates read alignments in the SAM format. If the variant is an inversion or a duplication, PRISM modifies the original read sequence so that it can map linearly to the genome and stores the modification in an additional SAM field (see description of 'ST Field' in README file for details).Stage 5: Filtration and calling SVs After the alignment, PRISM calls the SV loci from the SAM files. PRISM filters the initial list of variants based on the number of supporting reads and the alignment score. The users can set these thresholds to tradeoff between sensitivity and specificity. In this manuscript, we require each variant to be supported by at least five reads, of which at least one has a score equal to 870 (for a 100 bp read the maximum score is 1000) for analysis of simulation data and of the NA18507 genome. Because of the lower coverage in the NA12878 dataset, we also allow variants to be supported by only two reads as long as one of them has a minimum score of 925.
Algorithm for split mapping2.3.1 Modified NW algorithm To perform alignment of the split-mapped reads to the reference genome, we use a modified NW algorithm. For deletions, the query is the read sequence, and the database are two segments of the reference, where we expect the beginning and the end to map (the selection of these two segments, called region1 and region2, is described in Section 2.3.2). Note that the two regions may be the same. We build two dynamic programming matrices for read  region1 (matrix1) and read  region2 (matrix2). Each cell in matrix1 is computed as in the traditional NW (with affine gap penalties). For matrix2 we calculate one additional recurrence, which uses the max score of all cells of the immediately previous line in matrix1. (This is illustrated in). We use this score to allow the alignment to 'jump' from matrix2 to matrix1 by introducing a large gap that corresponds to the split in the read. The penalty for this gap is a constant not related to its length. For insertions the algorithm is similar, except we align a single region of the genome to two copies of the read. The algorithm for alignment is identical, except that the 'jump' is now between two copies of the read. The modified NW matrix for deletions is built using the following recurrences (also see illustration in Supplementary). where db is built by two fragments of reference sequence as described in Section 2.3.2. The lengths of these two fragments are m 1 and m 2 ; qr is the read sequence; l is the length of qr; M(i, j), I qr (i, j) and I db (i, j) are the maximum similarity scores given that qris aligned to db(match/mismatch), qrto a gap (insertion) or dbto a gap (deletion), respectively; gap open is the penalty for opening a gap in the alignment; gap ext is the penalty for extending a gap in the alignment; w(a, b) is a scoring function that is positive when a  b and negative otherwise; jump qr is penalty for a jump from matrix2 to matrix1 (from cell Cur to cell NW-MAX, see) and j max is the db index of cell NW-MAX, i.e. if cell Cur's coordinate is (i, j) cell NW-MAX's should be (i  1, j max ) (see).for a, b and c: 1 i l,Note that the jump score is not calculated for I qr and I db because a deletion cannot be followed directly by an insertion, while a deletion followed directly by a jump can be included in the jump. The same algorithm is used for split mapping of inversions and tandem duplications as deletions, as illustrated in Section 2.3.2. The algorithm for insertions is similar, except that the read, rather than the reference segment is duplicated, and is presented in the Supplementary Material (Section 2). Finally, to optimize the performance of the dynamic programming step, we use an anchored alignment approach, which is also presented in the Supplementary Material (Section 3).
Selectionof query and database for modified NW matrix For SVs of different types and sizes, PRISM has different strategies to select query and database sequences for the modified NW algorithm. The database can consist of the sequence in the concordant region, the discordant region or their reverse complements. The query is the read sequence or the doubled read sequence (for insertions). Split mapping within the concordant region: For each anchor read, the hanging read may be unmapped due to spanning across a small indel that is not big enough to generate discordant pairs. In this case, the indel will be within the concordant region. This case is illustrated in(for deletions) and B (for insertions). In the deletion case, the two regions to which the read is mapped are identical. Similarly, in the case of an insertion, the read is duplicated and aligned to a single copy of the genomic) is duplicated to be the query. The split mappings we expect to find are shown in both subfigures (blue line). In (CE), purple arrows are concordant pairs and orange arrows are discordant pairs. Hanging pairs are in blue. All these SVs can share the same split-mapping algorithm. The only difference is the selection of a database sequence. (C) The illustration of alignment for a long deletion (supported by clusters) with NW algorithm details. The presence of the deleted segment (green line) in the reference (red line) generates a group of discordant pairs (in orange). The breakpoints of the deletion are likely to fall close to the two end points of the cluster. PRISM picks the two regions surrounding the two end points and uses them for split mapping of all hanging reads (in blue) in proximity of the cluster. To map the read, we modify the standard NW algorithm matrix to allow for a large, unpenalized gap that spans the breakpoint between the two regions. D: Inversion (green arrow), the anchor read is outside the inversion. The database is the concatenation of the concordant region and the reverse complement of the discordant region. E: Duplication (green arrow). The database is the concatenation of the discordant and concordant regions region. We attempt both the insertion and deletion split alignments for each hanging read. Split mapping between the concordant and the discordant regions: For each hanging pair, if there are neighbor reads that are members of a discordant cluster, the hanging read may be unmapped because it spans across the breakpoints of a large deletion, an inversion or a duplication (depending on the type of cluster). The cluster allows us to identify the discordant region, and the difference between the split mappings of these three types of SVs is only in the selection of the discordant region, as the alignment only needs to allow for a large 'jump' from the concordant to the discordant region.(CE) illustrates the selection of the databases and queries for these SVs.
Simulation datasetTo estimate both the sensitivity and specificity of PRISM on a realistic dataset with a known ground truth, we implanted known human indels () into chromosome 1 of the human genome and simulated 100 bp paired reads with Gaussian-distributed inserts (500 bp mean, 30 bp SD). The sequencing error model followed real Illumina data (1% overall error rate).
RESULTSTo evaluate our method, we conducted simulation experiments and analyzed two recently sequenced genomes.
Simulation resultsWe ran PRISM, Pindel, SVseq, Splitread, BreakDancer (), CNVnator () and CREST on our simulation dataset, with the results summarized in Supplementary Table S1. PRISM achieved recall ! 95% for small variants (insertions and deletions 110 bp and 1150 bp), with precision ! 94%. For medium-size deletions (51100 bp), the recall was 63% with precision 77%. For deletions of 1011000 bp, PRISM achieved recall of 80% at 95% precision, while for deletions41 kb the recall was 80% and precision was 95%. Pindel and SVseq performed the best of the remaining tools, followed by Splitread and CREST. CREST is designed for somatic rather than germline variants, so we decided to exclude it from the comparisons on real genomes. Splitread and SVseq were also not run on whole genomes due to inappropriateness of the method for our experiments, or due to technical issues, as discussed in the Supplementary Material.
Results on real dataTo evaluate PRISM on real data, we used two recent wholegenome paired-end datasets generated with Illumina Genome Analyzer II: Yoruban HapMap individual NA18507 (NCBI SRA id: SRA010896) with 47  sequencing coverage, insert size 500 bp, PCR duplicate reads 7.4% and the CEU HapMap individual NA12878 (SRA id: ERX012406) sequenced at 15  coverage, 300 bp insert size, PCR duplicate reads 3.6%. We used the hg18 reference genome. The characterization of these genomes in multiple previous studies () allows us to compare PRISM results to both predicted and validated variants, as well as to identify novel variants that could not be discovered with previous methods. We compared PRISM with the latest (unpublished) version of Pindel (2.0) that is able to identify tandem duplications and inversions, as well as small insertions and large deletions. Inwe present a comparison to variants that have been detected using Sanger sequencing, PCR or array studies, as well as the study () for inversions. Comparison to additional HTS-based analyses is in Supplementary Table S3. To evaluate various tools, we consider a previously reported set of variants as a gold standard, and compute precisionthe fraction of true positives over all predictions, and recallthe fraction of true positives over all variants in the dataset. Note that because the gold standard datasets are not complete we do not expect the precision to be close to one for most datasets. In particular, the datasets (), which did not utilize high-coverage whole-genome sequencing, are likely missing true variants. Similarly, only a fraction of all variants are identifiable through a split-read approach. A thorough discussion of the causes of false negatives is presented in the Supplementary Material. For the NA18507 genome, PRISM detected 784 319 indels of 1100 bp, of which 145 944 (19%) were previously identified in. PRISM was able to identify 65% of the variants known from the study (). This compares favorably with Pindel, which identified fewer total variants, of which a smaller percentage was previously known. We also compared PRISM with GATK (), a standard method for identifying small indels, and found that the two methods were comparable for indels 120 bp, PRISM showed better sensitivity at detecting larger variants: GATK did not detect any indels larger than 50 bp. We also analyzed the CEU NA12878 genome, where we identified an overall smaller number of indels (592 373 1100 bp, 2042 1015000 bp, 16045 kb). PRISM showed a significant advantage at identifying larger variants due to its use of paired-end analysis to identify likely locations of breakpoints. Compared to several datasets of validated deletions (), PRISM achieved significantly higher recall and somewhat lower precision for variants 50200 bp, and higher precision and recall for deletions4200 bp (and Supplementary). When comparing to large deletions (45 kb) identified via Sanger sequencing () in the NA18507 individual, the same trend held: despite reporting 82% fewer variants than Pindel, PRISM identified a higher number of known deletions, thus achieving better precision and recall. The results of PRISM were nearly on par with BreakDancer, a tool that only utilizes pair-end data, and cannot identify the precise breakpoints of variants. We also used the NA18507 genome to analyze performance on inversions and duplications. For these variants, breakpoints are often in repetitive regions, making them especially difficult to identify with the split-read approach. PRISM identified 172 inversion breakpoints in this genome. Of these, 36 (21%) were among the 83 inversion variants previously identified with a paired-end approach (). We also found 407 split reads displaying the duplication signature and compared these with the copy counts previously reported by, who used array-CGH to identify genomic regions with a significant difference in intensity of 270 individuals (90 Yoruban and 180 Eurasian). Following the method of, we identified 26 genomic regions in which NA18507 likely has higher copy counts than the reference. We found 7/407 of our duplication calls agree with these 26 regions, compared with 3/427 duplications reported by Pindel. Finally, to directly measure PRISM's false-positive rate and to validate the novel variants identified by our method, we conducted PCR experiments on 58 variants. These were chosen from various size ranges, with $10 variants selected from each of the following categories: insertions 1050 bp, deletions 1050, 50100, 1001000, 10005000 and 45000 bp. To allow for the evaluation of the overall accuracy of PRISM, we randomly selected five variants from each category. To characterize PRISM's ability to identify novel genomic variants inaccessible to previous tools, we attempted to select five additional variants from within each size set that did not intersect with previously known indels or SVs (from the Database of Genomic Variants; http://projects.tcag.ca/variation/) and which were not reported by Pindel. The novel variants were also visually inspected (seeE) to exclude regions with multiple overlapping events. Overall, in 2/58 cases, the primers did not work, and in 4/58, neither of the two alleles matched in size either the reference genome or the predicted variant, likely indicating mispriming or a misassembly in the reference genome. Of the remaining experiments, 47/52 (90%) validated PRISM predictions, while 2/52 (4%) indicated no variation. The final 3/52 (6%) revealed a variant at the genomic region that was different from the one predicted by PRISM. Venn diagrams illustrating the concordance of PRISM and Pindel deletion calls of various lengths in the NA12878 individual with variants annotated at nucleotide resolution by the Yale group (YL_SR) based on 454 read data and validated with PCR (). Two calls are considered to overlap if they have exactly the same size and their locations deviate by5100 bp (See Supplementary). Of the randomly chosen variants, 30/33 (91%) were validated, with 2/33 (6%) not validating, and 1/33 (3%) showing alternate variants. Similarly, 17/19 (89%) selected novel variants validated, with the remaining two regions showing alternate genomic variation. We also indirectly measured PRISM's accuracy by analyzing the fraction and length of indel variants within coding regions of the genome. The fractions of such indels reported by the three tools are very close (373/784 319  0.05% for PRISM, 364/682 434  0.05% for Pindel and 373/783 801  0.05% for GATK), while a higher fraction of PRISM coding indels had lengths that are a multiple of three (155/373  41.6% for PRISM, 143/364  39.3% for Pindel and 144/373  38.6% for GATK).
CONCLUSIONPRISM has several advantages over previous methods for detection of SVs from HTS data, including combining paired read analysis and split mapping for detection of the exact breakpoints for variants of arbitrary size. The sensitive-alignment algorithm used in PRISM accurately identifies breakpoints even proximal to other variants or sequencing errors. One such example is shown in, where a large deletion predicted by PRISM (and validated by PCR) is immediately followed by a small deletion, making the alignment of reads that span the deletion especially challenging. The PCR validations confirm not only the overall high accuracy of PRISM results but also its ability to identify novel variants inaccessible to previous methods.
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
PRISM: Pair Read Informed Split Mapping at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Y.Jiang et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
