Motivation: In genome assembly, the primary issue is how to determine upstream and downstream sequence regions of sequence seeds for constructing long contigs or scaffolds. When extending one sequence seed, repetitive regions in the genome always cause multiple feasible extension candidates which increase the difficulty of genome assembly. The universally accepted solution is choosing one based on read overlaps and paired-end (mate-pair) reads. However, this solution faces difficulties with regard to some complex repetitive regions. In addition, sequencing errors may produce false repetitive regions and uneven sequencing depth leads some sequence regions to have too few or too many reads. All the aforementioned problems prohibit existing as-semblers from getting satisfactory assembly results. Results: In this article, we develop an algorithm, called extract paths for genome assembly (EPGA), which extracts paths from De Bruijn graph for genome assembly. EPGA uses a new score function to evaluate extension candidates based on the distributions of reads and insert size. The distribution of reads can solve problems caused by sequencing errors and short repetitive regions. Through assessing the variation of the distribution of insert size, EPGA can solve problems introduced by some complex repetitive regions. For solving uneven sequencing depth, EPGA uses relative mapping to evaluate extension candidates. On real datasets, we compare the performance of EPGA and other popular assemblers. The experimental results demonstrate that EPGA can effectively obtain longer and more accurate contigs and scaffolds.
IntroductionKnowledge of genome sequences has become indispensable in numerous applied fields such as diagnostics, biotechnology, forensic biology and systems biology. The next generation sequencing (NGS) technologies, also known as high-throughput sequencing, including Illumina, 454 Life Sciences and SOLiD, can provide short sequence fragments named reads, much more quickly and cheaply than previously used Sanger sequencing, but at the sacrifice of read length (). A number of genome assemblers have been proposed using a great deal of short reads produced by NGStechnologies for reconstructing complete genome sequence (). The primary issue of these assemblers is how to determine upstream and downstream sequence regions of sequence seeds for constructing contigs or scaffolds. As the length of reads decreases, the number of repetitive regions in one genome will dramatically increase. When extending one seed sequence, repetitive regions can cause multiple feasible candidate regions which increase the difficulty of genome assembly. So, the repetitive regions especially longer than the read length in one genome become one of the most challenges in genome assembly (). The earlier assemblers generally employ read overlaps to extend one sequence seed. When there are multiple feasible extension candidates caused by repetitive regions, the assemblers usually select one with the maximum overlap or the highest consensus to extend (). The length of read overlap is important to identify extension candidates and choose the correct one among them. Because sequencing errors often result in erroneous read overlaps and low-depth regions miss some read overlaps, so read overlaps usually compromise between continuity and error rate (). De Bruijn graph is a useful data structure which can store read overlaps (). There are some improved De Bruijn graphs used for assembly (). However, the information about read overlaps has no effect on repetitive regions longer than the read length. Most recent assemblers make use of paired-end (mate-pair) reads which can be produced by NGS technologies for resolving repetitive region problems. One paired-end read is referred to a pair of short reads sequenced from two ends of one long sequence fragment and the sequence fragment length (the distance between paired-end reads) is usually called insert size which is a random variable with mean l is and SD d is. The insert size is frequently assumed to have a normal distribution N(l is , d is ). For every paired-end read, its two reads are called the mates of each other. In recent years, there have been numerous assemblers presented for biologists (). Velvet () uses paired-end reads to mark nodes, and finds a correct path through marked nodes to connect two long nodes based on De Bruijn graph. However, some nodes shorter than the read length cannot be marked, so it tends to contain more errors at short repetitive regions. Abyss () adopts a method similar to Velvet's. When extending one sequence seed or filling one gap region, PE-Assembly () tries to identify feasible extensions from local read sets produced from paired-end reads. IDBA () and IDBA-UD () iterately change k-mer (k consecutive bases in one read) length and uses paired-end reads to eliminate branches in De Bruijn graph. Telescoper () first constructs read-overlap graph based on reads whose mate reads can map to sequence seeds, and it develops a statistical framework using penalty function to choose paths for constructing contigs. SOAPDenovo () and SOAPDenovo2 () directly use nodes in De Bruijn graph as contigs which are usually short. ALLPATHS-LG () has specific requirements in read length and insert size, which differ from common read libraries. In the following part, let r denote the read length and s denote a sequence. sis the i-th base in s. sis the sub-region of s from i-to j-th base. L(s) is the length of s and R(s) is the set of reads in s. RE(s) is the set of reads in R(s) which exist in the read library. RML(s) is the set of reads in RE(s) which have left mate reads and MRL(s) is one set which includes the corresponding left mate reads. RMLM(s i , s j ) is the set of reads in RML(s j ) whose one left mate read can be mapped to s i and the distance between the mapped pairedend reads must be in the interval l is  3  d is ; l is  3  d is ; DLs i ; s j  is the set including the corresponding distances. RMR(s), MRR(s), RMRM(s i , s j ) and DR(s i , s j ) all can be obtained from right mate reads of the sequences. jTj is cardinality of one set T. The information contained in paired-end reads can facilitate genome assembly (). Because paired-end reads can span repetitive regions shorter than insert size, for one sequence seed s s and one downstream extension candidate s, we can estimate the correctness of s through its MRL(s). When the reads in MRL(s) can be mapped to s s , we consider s as the correct one, as illustrated in. Although paired-end reads are widely applied to resolve problems caused by repetitive regions in genome assembly, the performance of most assemblers is not satisfactory. There are three major problems which prevent most assemblers from identifying correct extension candidates by using paired-end reads: 1. Adjacent repetitive regions and paired repetitive regions: For two same regions B, if the separation distance between the two regions in genome is small, we say that it is adjacent repetitive region, shown in. For two regions (A, C), if the length between A and C is closed to insert size and the two regions appear in genome repeatedly, we say that it is paired repetitive region, shown in. The upstream or downstream regions of adjacent and paired repetitive regions are difficult to determine, because the most reads in MRL or MRR of extension candidates can be mapped to the sequence seed. 2. Sequencing errors: sequencing errors always bring about incorrect reads which probably lead to false repetitive regions and false extension candidates. 3. Uneven sequencing depths: sequencing depth of one sequence region depends on the average number of reads in the read library which can be mapped to the region. Because sequencing depths of different regions in a genome are universally highly uneven (), there are no or fewer reads which can be mapped to low-depth regions, but high-depth regions have too many mapped reads. Uneven sequencing depths aggravate the problems caused by (1) and (2). In, for the sequence seed AB, which is merged by A and B, and the extension candidate C, the distances in DL(AB, C) should follow the distribution Nl is ; d is . D is the correct extension candidate of ABCB and the difference between the length of AB and the length of ABCB is LC  LB. When D is regarded as the extension candidate of AB, the distances in DL(AB, D) will follow Nl is  LB  LC; d is . In, the distances in DL(ABC, D) will follow Nl is ; d is . Because H is the correct extension. Paired-end reads using in extending sequence seed. The graph G is constructed based on sequence s (ABC. .. DBE). When extending downstream region of AB, it has two extension candidates C and E. If no sequencing errors, reads in MRL(C) can be mapped to AB, but reads in MRL(E) can not be mapped to AB. So, C is the correct extension candidate candidate of AEC and the difference between the length of ABC and the length of AEC is LE  LB, the distances in DL(ABC, H) will follow Nl is  LE  LB; d is . It is clear that we can identify which extension candidate is correct by assessing whether the distances in DL follow Nl is ; d is . To our knowledge, PE-Assembly is the only tool which considers the variation of the distribution of insert size in filling gap step. For one fixed length sequence s, R(s) includes L(s)r  1 reads. Due to sequencing depth, some reads in R(s) probably do not appear in the read library. jREsj is usually smaller than jRsj. Every read is sequenced randomly, jREj is a random variable whose distribution is called the distribution of reads. jREsj is a particular value of the random variable which should be within a reasonable range. The probability P is one read can be sequenced, if P is the same for every read in genome reference, the distribution of reads approximately follows binomial distribution. The reasonable range can be determined by binomial distribution. If jREsj goes beyond this range, we consider s including false bases. If sequencing depth is even and sequencing coverage is large enough without sequencing errors, genome sequence is corresponding to one path contained in De Bruijn graph. However, due to the uneven sequencing depth and sequencing errors, the path is inevitably segmented into many noncontiguous sub paths. So, the target of de novo assembly becomes to analyze De Bruijn graph for seeking out accurate sub paths corresponding to sub regions of genome. We develop a novel assembler, called EPGA (extract paths for genome assembly), to improve genome assembly (see the flowchart of EPGA in Supplementary). EPGA selects some nodes in De Bruijn graph as sequence seeds. The precursor nodes and successor nodes of sequence seeds are treated as its upstream and downstream extension candidates. EPGA processes each extension candidate to form an evaluating region which is evaluated based on a new score function. Using the new score function, EPGA iteratively extends sequence seeds on both sides to extract long paths which are contigs. For one sequence seed s s , its downstream extension candidate s and evaluating region s e , EPGA uses the following three new strategies which make novel use of paired-end reads: To resolve problem (1), EPGA adopts the coefficient of determination (CD) to evaluate whether the distances in DLs s ; s e  follow Nl is ; d is . The CD provides a measure of how well the distances are replicated by Nl is ; d is , as the proportion of total variation of the distances is explained by Nl is ; d is . To resolve problem (2), based on the distribution of reads, EPGA determines a reasonable range of jREs e j to identify whether s is a false extension candidate. The probability that jREs e j is within the range should be large enough. To resolve problem (3), EPGA designs a new index named relative mapping (RM) to evaluate extension candidates. The relative mapping is the ratio of RMLMs s ; s e  to RMLs e . So, relative mapping can guarantee that correct extension candidates are given high score no matter sequencing depth is. In EPGA, we mainly incorporate two new ideas for genome assembly: (i) we consider the distribution of reads to identify whether one extension candidate includes sequencing errors, rather than only using k-mer frequency; (ii) based on the distribution of insert size, we develop a new score function to overcome complex repetitive regions. The performance of EPGA and other popular assemblers are compared on real datasets. The results demonstrate that EPGA can get more continuous and correct genome sequences.
Sequence seeds and extension candidatesSequence seeds are used as the start points to extend their upstream and downstream regions for constructing longer contigs.The graph G 1 is constructed based on sequence s 1 (ABCBD). B is one adjacent repetitive region and the length of C is short. If extending downstream region of AB, there are two extension candidates C and D. Most reads in MRL(C) and MRL(D) can be mapped to AB. In this case, it is difficult to choose the correct candidate. (b) The graph G 2 is constructed based on sequence s 2 (ABCD. .. ABCH). (A, C) is one paired repetitive region. When extending downstream of ABC, there are two extension candidates D and H. Most reads in MRL(D) and MRL(H) can be mapped to ABC. In this case, it is also a problem to determine the correct candidate EPGA selects nodes longer than insert size as sequence seeds in De Bruijn graph. The downstream extension candidates are nodes that are directed by the last node of sequence seed. The nodes that direct to the first node of sequence seed are upstream extension candidates. The length of extension candidates should be longer than the minimum length (len min ) which is 2 * k as default, so that an extension candidate includes enough reads and mate reads to evaluate themselves. When the length of one extension candidate is shorter than len min , EPGA will take the extension candidate as origin node and adopt deep first search (DFS) to get paths longer than len min based on De Bruijn graph. When one path is longer than len min or search deep is greater than the max deep threshold, this search will stop. The DFS usually produces many paths referred to secondary extension candidates. We will evaluate each secondary extension candidates and select the top score as the final score for the extension candidate.
Evaluating extension candidatesIn this step, we develop one new score function based on the distributions of reads and insert size for identifying correct extension candidate. By using the new score function, the ambiguities caused by adjacent and paired repetitive regions can be resolved in the process of extending sequence seed. For a given sequence seed (s s )and its one downstream extension candidate (s), they have overlap with k  1 bases. The last r  1 bases of s s are merged to the extension candidate. Then the first r k  len min bases of the extension candidate is considered as its evaluating region s e. An extension candidate corresponds to an evaluating region. Then, EPGA can get REs e ; RMLs e , RMLM and DLs s ; s e . There is an example in. EPGA uses RM in Equation (1) to evaluate the correctness of extension candidates. RM is always in. When a correct extension candidate is in high-depth region or low-depth region, its jRMLs e j and jRMLMs s ; s e j will simultaneously increase or decrease. So, RM can guarantee that correct extension candidates are given high score no matter sequencing depth is. Therefore, as long as RM of one extension candidate is high, EPGA considers it as correct.Moreover, the distance set DLs s ; s e  is employed to overcome problems introduced by adjacent and paired repetitive regions. EPGA uses CD in Equation (2) to measure whether distances in DLs s ; s e  fits Nl is ; d is . For computing CD, EPGA partitions some intervals in 1; 1. If EPGA sets too many intervals, DLs s ; s e  should include more distances and s e must be one high-depth region. If EPGA sets too few intervals, CD cannot correctly evaluate fitness between two distributions. For balancing sequencing depth and accuracy, EPGA sets six intervals: 1; l is  2  d is ; l is  2  d is ; l is  d is ; l is  d is ; l is ; l is ; l is  d is ; l is  d is ; l is  2  d is  and l is  2  d is ; 1. In Equation (2), x is the size of the distance set. n is six and x i is the number of distances within i-th interval. P i is the probability of i-th interval of Nl is ; d is . y i is x  P i .In addition, EPGA uses jREs e j to identify false extension candidate. For each evaluating region, jREs e j is a particular value of a random variable X which approximately follows the binomial distribution Blen min  k  1; P. P is the probability that one read can be sequenced, which is estimated as the ratio of REs n  to Rs n , s n is the longest sequence seed. For one evaluating region, there are len min k  1 reads. The expectation value of X is len min  k  1  P, denoted by l r , the SD of X is ffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffiffi len min  k  1  P  1  P p , denoted by d r. If jREj of one evaluating region is beyond interval l r  b  d r ; l r  b  d r , denoted by D r , EPGA gives it a penalty score (PS) computed in Equation (3). In default, the probability that jREs e j is beyond D r should be smaller than 5%, so b  4.In Equation (4), AKF s is the average frequency of k-mers in an extension candidate (U 1 in). AKF is the average frequency of k-mers in the entire read library. In Equation (5), d weights the deviation from normal span of jREj. The final score S of each extension candidate is calculated by Equation (6). When there are multiple read libraries, EPGA will use all of them to score extension candidates, rather than using long insert size libraries only during scaffolding or filling gap regions. Once the sequence seed achieves a length longer than the insert size of one read library, the library will be considered in the evaluating extension candidates. For one sequence seed, if there is only one extension candidate, the extension candidate is directly appended to the sequence seed. If there are multiple extension candidates, EPGA scores each extension candidate by Equation (6) and chooses extension candidates s 1 and s 2 with top two scores(s 1 is with the maximum score). If scores of s 1 and s 2 are similar or high, the extending process is terminated. Otherwise, s 1 is appended to sequence seed and the process continues. Upstream extension can be carried out using the same strategy. The reasons why the extension process stops include: (i) Sequence errors not only lead to false nodes or false edges in De Bruijn graph but also causes missing some mate reads of evaluating regions. (ii) In some low-depth regions, there are probably no extension candidates. After extending all sequence seeds from both upstream and downstream, EPGA gets one contig set consisting of some long contigs. The contig set is kept to be used in the following steps.of A and D can be mapped to s s. The left mate read of E cannot be mapped to s s. So, RMLse is {A, D, E}, RMLMss; se is {A, D}
Merging contigsThis step is to delete redundant contig and reduce contig number which can enhance the efficiency of the following steps. Rather than using the ends of the two contigs as a whole to judge whether they can be merged, we divide the ends of the two contigs to some short sub-regions. This new way can extract un-repetitive regions from the ends of the two contigs, and eliminate ambiguities caused by repetitive regions. In this step, EPGA discovers overlaps between contigs and identifies whether contigs can be merged together. When one short contig is included in another long contig, then the short contig is removed from the contig set. Once two contigs C l and C r have overlap C ol of len ol bases, EPGA temporarily merges them together to form a new contig C new. C new consists of three regions C ll , C ol and C rr. After C l deletes C ol , the rest region is C ll. After C r cuts off C ol , the rest region is C rr. Then, EPGA extracts the first l is-len ol bases of C rr and the last l is-len ol bases of C ll as two test regions. The test regions are divided into some short sub-regions. And, each sub-region is regarded as extension candidates, EPGA computes their RM by Equation (1). If all RMs are bigger than the minimum value a, C new retains, C l and C r are removed, else EPGA deletes C new and leaves C l and C r alone. An example is shown in. When the len ol is longer than all insert sizes of multiple read libraries, the two contigs will be merged directly. The reason why contigs can be merged in this step but not linked in extending sequence seed step is that, it maybe harder to choose a correct extension candidate from one extending direction; however, it is probably easy to determine in another extending direction.
ScaffoldingIn this step, according to the contig set constructed from previous steps, EPGA will build a scaffold graph in which each node is one contig and each edge represents that two connected nodes are the closest neighbors in actual genome sequence. In the process of scaffolding step, the first step is to determine the left neighbor and the right neighbor of every contig. EPGA assumes every contig has only one left neighbor and only one right neighbor. For two contigs u and v, the gap distance len gap is estimated by paired-end reads whose mate reads are separately mapped to u and v. EPGA extracts last l is-len gap bases from u and first l is-len gap bases from v as test regions. For the sake of eliminating ambiguities caused by repetitive regions, the test regions are divided into some short sub-regions which will be used to score the linkage between u and v. Each sub-region of u is treated as a candidate sequence, and v as a sequence seed, if any RM of sub-regions is lower than the minimum value a, the process will be terminated and there is no linkage between u and v. Otherwise, EPGA computes the average RM of all sub-regions. After getting all average scores between u and other contigs, EPGA chooses the contig with the top score as its right neighbor and an edge will be linked between u and its right neighbor. Iteratively, the scaffold graph will be built. The second step is to remove erroneous edges in the scaffold graph. If the right neighbor of u is v; however, the left neighbor of v is not u, then the edge (u, v) is one erroneous edge and will be deleted. Finally, this step gets the explicit ordering relation between contigs based on the constructed scaffold graph.
Filling gapThe gap regions between connected nodes in scaffold graph are usually low-depth regions or more complicated regions, which are the reasons why nodes are separated. If the gap region is in low-depth region, the contigs cannot be connected through one path in De Bruijn graph. If the gap region is more complicated region, it is difficult to decide the accurate extension candidates to connect two nodes. For filling one gap, EPGA will iteratively change k-mer length to construct sub De Bruijn graphs. When the value of k becomes larger, there will be less branches in sub De Bruijn graph and eliminate some repetitive regions. When k becomes smaller, the connectivity of sub De Bruijn graph will get larger and low depth regions will be connected. For two nodes C l and C r in a scaffold graph, EPGA will first collect a local read set whose mate reads can be mapped to the end of C l and C r. Then, EPGA iteratively changes k-mer from k-max to kmin based on the local read set to create sub De Bruijn graph. In default, k-max equals to k  4, k-min equals to k  4. In sub De Bruijn graph, EPGA firstly finds two nodes node 1 and node 2. node 1 is referred to the right end of C l , node 2 is referred to the left end of C r. Starting from node 1 , EPGA takes the DFS method to find all possible paths which can connect node 1 and node 2. In the process of search, C l is regarded as original sequence seed. When extending the sequence seed, EPGA not only computes S between extension candidates and the sequence seed, but also computes RM between extension candidates and C r. If the score of one extension candidate is smaller than the minimum value a, or the extending length is bigger than the gap distance, or the extension candidate is v, then this path search will terminate. Finally, if there is only one path connecting C l and C r , then the gap will be filled by the path. If there are multiple paths, the gap will be filled by 'N'. When there are no paths found, then EPGA constructs new sub De Bruijn graph based on smaller kmer. The process is illustrated in.The region U 1 and U 2 are test regions which are all divided into sub-regions. R is one sub-region as extension candidate, R r is its sequence seed. Then RM of R and R r can be computed by Equation (1)De novo assembly using the distributions of reads and insert size
ExperimentFor evaluating the performance of EPGA, our experiments are carried out on real datasets with different properties. Real sequencing datasets include two bacteria (Staphylococcus aureus and Escherichia coli) and two fungi (Schizosaccharomyces pombe and Neurospora crassa) using the Illumina platform provided by AllPath2 (). All genome references are also provided by AllPath2 and used for validation. Details about real sequencing data are showed. Each genome includes one short insert size library and one long insert size library. The read lengths are short and from 26 to 36. We benchmark five assemblers on four real datasets. The assemblers include Velvet, PE-Assembly, SOAPDenovo2, Abyss and EPGA. To provide unbiased benchmarking, we use the assembly evaluation tool GAGE (). All benchmarkings were done on a computer with 24 cores (Intel Xeon E5-2620 2.00 GHz). For one real genome reference gr, SR is one set which consists of all sub-regions of length len in gr, len  r  k. Each sub-region s sr in SR has one corresponding sequence seed s srs , which is its upstream region of length l is  3 * d is  1, except for some sub-regions which come from gr[0, l is  3 * d is  1]. It is clear that s sr and s srs have overlap with r  1 bases. In the process of assembly, for all extension candidates of one sequence seed, the previous r  1 bases of their evaluating regions are the same and the r-th base is different. For all sub-regions in SR, we randomly change their r-th base to create false sub-regions which are included in one set FSR. For one sub-region in SR, its corresponding sub-region in FSR is treated as one false extension candidate for its corresponding sequence seed.
Distribution of readsThe distribution of reads is tested based on SR and FSR of genome references. The probability P that one read can be sequenced is the ratio of jREgrj to jRgrj. In EPFA, the probability P is estimated by the ratio of jREs n j to jRs n j (denoted by P n ) since we do not have the genome reference, where s n is the longest node in De Bruijn graph. As shown in, P n is very close to P which illuminates the effectiveness of our estimating method. Assuming the distribution of reads follows binomial distribution, the probability that jREs sr j is beyond the interval l r. For testing whether jREj of sub-regions in SR is within D r , jREj of every sub-region in SR is calculated, and the percentage of sub-regions whose jREj are within D r (denoted by P c ) is listed in. In addition, jREj of every sub-region in FSR is also calculated, and the percentage of sub-regions whose jREj are within D r (denoted by P f ) is also listed in. For all genome references, the smallest value of P c is 0.9567 and the largest value of P f is 0.0036. So, the correctness of one sub-region s sr can be evaluated by using jREs sr j and D r .
Relative mapping and CDThe effectiveness of RM and CD to distinguish correct extension candidates from false extension candidates is tested based on SR and FSR of genome references. For sub-regions in SR and FSR whoseregions in SR, we can find that the smallest l rm is 0.8650 and the smallest l cd is 0.4781. For sub-regions in FSR, the biggest l rm is 0.0430 and the biggest l cd is 0.0188. In addition, S 2 rm and S 2 cd are small. So, RM and CD can be used as two significant characteristicsDe novo assembly using the distributions of reads and insert sizeto distinguish correct extensions candidates from false extension candidates.
Assembly resultsWe adopt several metrics provided by GAGE for measuring the continuity and completeness of assembly results. The continuity is judged by the number of contigs (or scaffods), N50 and the length of longest contig (or scaffold). N50 is the length of the longest contig (or scaffold) such that all the contigs longer than this contig cover at least half of the genome being assembled (). The completeness is estimated by two coverages (Cov-R and Cov-O) which are the proportion of the genome reference being covered by output contigs (or scaffolds) and the proportion of the output contigs (or scaffolds) being covered by genome reference. GAGE includes corrected analysis. For corrected analysis, misjoin and indel longer than 5 bases are viewed as errors. GAGE splits contigs at every error position and provides revised results. GAGE tallies three types of misjoins: (i) inversions, where part of a contig or scaffold is reversed with respect to the true genome; (ii) relocations, or rearrangements that move a contig or scaffold within a chromosome; and (iii) translocations, or rearrangements between chromosomes. The statistics of the assembly results of different assemblers are summarized in Tables 58 and the best results are in bold.
De novo assembly of S.aureusThe genome of S.aureus is not too long and it is usually used as a sequencing object. The assembly results about S.aureus are shown in, EPGA and AllPath2 still have few contigs and scaffolds. Although AllPath2 has the longest scaffold, the corrected N50 of EPGA is longer than AllPath2. EPGA has the best coverages for contigs and the best Cov-R for scaffolds. SOAPDenovo2 has the fewest errors for contigs but too many errors for scaffolds.
De novo assembly of S.pombeThis genome reference is long and relatively more repetitive. In Table 7, we can find that all assemblers are inclined to produce more errors and worse results. EPGA creates the fewest contigs and scaffolds than other assemblers. Corrected N50 for contigs and scaffolds are the longest among all assemblers. Abyss has the most errors for contigs while SOAPDenovo2 has the most errors for scaffolds.
De novo assembly of N.crassaFor the relatively larger N.crassa genome, the assembly result is shown in. The assembly results of N.crassa cannot be obtained by AllPath2, because there are too many reads in libraries which exceed the read number limit of AllPath2. EPGA leads in terms of the number and N50 for contigs. For scaffolds, Abyss is of significant N50 in comparison with other assemblies. The errors of contigs and scaffolds for Abyss are high. Note that, although the Cov-R of Abyss is high, the Cov-O is too low, which means Abyss produces too much redundant contigs. Also note that N.crassa reference genome is unfinished and it consists of many chromosomes which influence the evaluation of assembly results.
Running time and peak memoryThe running time and peak memory of EPGA are $15 min and 9 G for S.aureus, 40 min and 28 G for E.coli, 261 min and 97 G for S.pombe, 2830 min and 198 G for N.crassa. AllPath2 needs much more running time and peak memory than EPGA, 72 min and 40 G for S.aureus, 156 min and 74 G for E.coli, 982 min and 464 G for S.pombe. The efficiency of Velvet, SOAPDenovo2, Abyss and PEAssembly are better than EPGA, this is because EPGA needs more memory to store mapping information between sequence seeds and extension candidates to score. In addition, EPGA executes strict detection program to determine contigs merging and scaffolding which consume some time. However, EPGA gets more satisfactory results, which is worth of more time and peak memory.
ConclusionEPGA extends sequence seeds by iteratively evaluating extension candidates and choosing correct one between them to construct contig set. Because there exists sequencing errors and uneven sequencing depth in read libraries, we present new ideas to avoid problems produced by them. For adjacent repetitive regions and paired repetitive regions, we use CD to distinguish correct extension candidates from false ones. The performance of EPGA is validated on real datasets from two bacteria and two fungi using the Illumina platform. In our experiments, we included some popular algorithms with available implementation. We considered several standard metrics for comparing assemblies. For all four datasets, EPGA produced more satisfactory results than the other assemblers considered. EPGA has been demonstrated that it is possible to obtain complete and highly accurate de novo genome assemblies. As one direction of future work, we would study how to reduce peak memory and running time for better performance. Funding: This work was supported in part by the National Natural Science Foundation of Chinaand the Program for New Century Excellent Talents in University. Conflict of Interest: none declared.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Methods 2.1 De Bruijn graph In original De Bruijn graph, each node represents a k-mer (k consecutive bases in one read), there will be a directed arc between two nodes if they have overlap with k  1 bases and continuously emerge in one read. A read with the length of r can be divided into r  k  1 overlapping k-mers. The value of k is important for constructing De Bruijn graph. Larger k will remove some short repetitive regions while reducing the number of nodes in De Bruijn graph, but will give rise to more unconnected sub-graphs which means that the number of gap regions increases. The small value of k will reduce some gap regions while increase the connectivity of De Bruijn graph, but will add more nodes and increase short repetitive regions. Therefore, the value of k cannot be too large or too small. For balancing the conflict, it is generally %r  2=3. To ensure that each k-mer cannot be its own reverse complement, k must be an odd number. Many existing assemblers perform error correction/detection step prior to the assembly. Although it is generally effective in detecting and fixing random sequencing errors, it may result in overcorrecting the reads coming from low-depth regions. EPGA takes a simple strategy for avoiding overcorrecting. If the frequency of one k-mer is over one, the k-mer will be considered in constructing De Bruijn graph; otherwise, the k-mer will be thought of including erroneous bases and will be removed. After obtaining the original De Bruijn graph, it is usually possible to optimize the graph based on its topological structure. First, if nodes in one path have only one outgoing arc except end node and only one ingoing arc except start node, the path will be named simple path and can be merged into one node. After merging simple paths, some tips (nodes whose out-degree plus in-degree is one) shorter than 2 * k can be removed. Tips are usually produced by erroneous bases in reads and gap regions. Third, there are some simple cycles (two nodes direct each other) which can be simplified to one path (see Supplementary Figure S2). Some assemblers usually merge one bubble to one path which can simplify De Bruijn graph. However, some bubbles may be caused by single-nucleotide polymorphism or similar sequences, so we do not remove bubbles. After these optimization, one final De Bruijn graph has been constructed and will be used for following steps.
J.Luo et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
read library 1; 2 read library 2.
read library 1; 2 read library 2.
