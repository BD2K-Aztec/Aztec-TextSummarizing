Recent years have witnessed an increase in research activity for the detection of structural variants (SVs) and their association to human disease. The advent of next-generation sequencing technologies make it possible to extend the scope of structural variation studies to a point previously unimaginable as exemplified by the 1000 Genomes Project. Although various computational methods have been described for the detection of SVs, no such algorithm is yet fully capable of discovering transposon insertions, a very important class of SVs to the study of human evolution and disease. In this article, we provide a complete and novel formulation to discover both loci and classes of transposons inserted into genomes sequenced with high-throughput sequencing technologies. In addition, we also present 'conflict resolution' improvements to our earlier combinatorial SV detection algorithm (VariationHunter) by taking the diploid nature of the human genome into consideration. We test our algorithms with simulated data from the Venter genome (HuRef) and are able to discover >85% of transposon insertion events with precision of >90%. We also demonstrate that our conflict resolution algorithm (denoted as VariationHunter-CR) outperforms current state of the art (such as original VariationHunter, BreakDancer and MoDIL) algorithms when tested on the genome of the Yoruba African individual (NA18507). Availability: The implementation of algorithm is available at
INTRODUCTIONHuman genetic variation can be defined in various size ranges. The smallest type of variation, termed single nucleotide polymorphisms (SNPs), are those at the single base pair level. The International HapMap Project genotyped 270 human individuals for 3.1 million SNPs, and recently the 1000 Genomes Project (http://www.1000genomes.org) was initiated to characterize human genetic variation with lower minor allele frequency by sequencing more than 1000 human genomes. More recently, it was shown that structural variation events significantly contribute to human genome diversity (). Many structural variants (SVs) are associated with genetic diseases such as psoriasis () and Crohn's disease (), prompting an increased interest in structural variation studies (; Chen * To whom correspondence should be addressed). Recently, it was shown that the SV reconstruction is harder than de novo assembly of small genomes and introduced an extensive framework for optimal genome re-sequencing (). Recently, we developed a set of combinatorial algorithms to detect structural variation using high-throughput sequencing data with improved sensitivity through interrogating the repeat and duplication rich segments of the human genome. In, the maximum parsimony structural variation (MPSV) discovery problem was introduced. This MPSV problem asks to compute unique mapping for each discordant paired-end read in the reference genome such that total number of implied (SVs) is minimized. We also previously presented a computational analysis of read depth to characterize segmental duplications and predict absolute copy number and content of duplicated genes (). See the review fromfor the details and strengths of different structural variation discovery methods. One type of structural variation excluded from this analysis is the mobile element transposition. Mobile elements, or transposons, are repetitive elements in the genome that occupy  44% of the human genome, including Alu, L1 and SVA elements (). Most of the transposons are fixed in the human lineage; however, around 0.05% of the transposons are still active, and the copy number and loci of these active transposons vary in the genomes of different individuals. Many studies have demonstrated that the mobile elements contribute to genome evolution and human genetic diversity. An interesting case was shown by: insertions of an Alu element were posited to cause pseudogenization of the IRGM gene at the split of New World and Old World monkey lineages 3540 million years ago (mya) by disrupting the open reading frame (ORF). A second transposon integration (ERV9) restored the ORF 24 mya in the common ancestor of apes and humans, demonstrating the first report on a 'resurrected' gene. The human IRGM gene plays an important role in the immune system () and is associated with Crohn's disease (). Mobile element transpositions are associated with the expansion of interspersed segmental duplications () and can promote both the creation of segmental duplication in human genomes () and the alteration of gene transcription by gene trapping and exonization. Another aspect that most structural variation algorithms ignore is the diploid nature of the human genome) and GASV (. Each chromosome has exactly two copies; therefore, all loci in the genome (w.l.o.g., except segmental duplications) are
Next-generation VariationHunterrepresented twice. This means that there cannot be more than two SVs including the 'normal' variant signature observed by 'concordant' paired-end mapping () at the same locus. However, due to the mapping artifacts in the repetitive segments of the human genome, most algorithms might call multiallelic SVs within overlapping intervals. In fact, the limitation of two variants per locus information can be used both to reduce false discovery rates and also genotype SVs (homozygous versus hemizygous). In this article, we present two extensions/improvements to the combinatorial formulation of our original VariationHunter algorithm () to detect structural variation using high-throughput sequencing technology. The main contributions of this article are (i) the first mathematically complete formulation and algorithm to identify transposition events (especially mobile element transpositions) and (ii) to remove ambiguity in variation discovery through 'conflict resolution' (enforcing at most two variants per locus). We first show that our method for discovery of mobile element transpositions has high accuracy and precision. In a full-scale simulation, we produce short reads from the genome of J. Craig Venter (very similar to what an Illumina platform would produce). Our method is able to find  85% of the known transposon insertions with a precision of >90%. We also demonstrate that our new algorithm (denoted as VariationHunter-CR) has a higher accuracy in comparison with VariationHunter (), BreakDancer () and MoDIL () when tested on a whole-genome shotgun sequence dataset generated from the genome of the Yoruba African individual (NA18507) using the Illumina platform.
DEFINITIONS AND THE FORMULATION OF TRANSPOSITION EVENTSIn, a general framework for detecting structural variation using long paired-end reads was introduced. This framework is based on aligning the paired-end reads to the reference genome and observing the end-reads 1 with discordant mapping. The pairedend reads with discordant mapping suggest either deletion insertion or inversion events. For example, an inversion event can be deduced when one of the two end reads of a paired-end read has a different mapping orientation than expected. In the standard library construction of the Illumina platform, in the case of no inversions or duplications, the read that maps to the proximal location is expected to be in the + strand, where its mate should be mapped to a distal location in the  strand. However, if the read pair spans an inversion breakpoint, the mapping orientations of the reads will be observed as either ++ or  [See the Supplementary Material infor a full case study]. As per, we denote a read pair as pe i and the distance between the end coordinate of the proximal read and the start coordinate of the distal read as the GapSize (i.e. the insert-size minus the total length of the reads). An alignment of a read pair to the reference genome is denoted as concordant () if the distance between the aligned end reads is in the rangeand the alignment orientation is +. The rangeis empirically calculated by analyzing the mapping span size distribution of the read pairs. The set of discordant paired-end reads is represented as R = {pe 1 ,pe 2 ,...,pe n }. Each discordant paired-end read pe i may be mapped to 1 The two ends of a read pair is referred as end reads.multiple locations in the reference genome. The set of all alignments of pe i is then defined as Align (pe i ) ={a 1 pe i ,a 2 pe i ,...,a j pe i }. Note that each alignment of pe i to the reference genome (a j pe i ) is a 5-tuple that represents the map locations of the end reads and their alignment orientation. More formally,where the pair (L (pe i ),L r (pe i )) represents the map location (i.e. both start and end loci) of the left end read of pe i , (R (pe i ),R r (pe i )) is the mapping location of the right end read of pe i , and or(pe i ) represents the map orientation of both ends. Note that or(pe i )  {+,++,,+}. In, a SV event is defined as SV SV (t,Pos L ,Pos R ,Ran min ,Ran max ). SV represents a of SV type t  {Ins,Del,Inv} 2 located between Pos L and Pos R in the reference genome, and with size estimated between Ran min and Ran max. Another important type of structural variation is the transposition event where a segment of the genome (formally, a transposon) is copied to another location with a small divergence. In the remainder of this article we call such types of SVs as copy events. Examples of common copy events include transpositions of Alu, SVA and L1 elements. Unfortunately, none of the available methods designed to detect structural variation events (e.g.) considered these copy events, and their focus was mainly on the discovery of deletions, insertions and inversions. A more recent algorithm, HYDRA, includes simple heuristics to detect transposon insertions (). Interestingly, even if the goal of a method is to identify only insertions, deletions and inversions in a sequenced genome, the presence of the common copy events will cause many false negative deletion and inversion predictions.clearly demonstrates a common scenario where a copy event is mistakenly identified as a large deletion. In what follows, we study two classes of copy events and present the set of conditions based on the map locations and orientations of the pairedend alignments that imply a copy event within each of these classes. First, we consider those copy events in which the transposed segment is in direct orientation, and present the set of conditions for all of the four different cases of this class (denoted as Class I). Next, we study the cases for Class II, where the transposon is copied in inverted orientation.Page: i352 i350i357)
F.Hormozdiari et al.
Pos
MAXIMAL VALID CLUSTERS AND COPY EVENT DETECTIONA set of discordant paired-end read alignments that support the same potential SV event is called a 'valid cluster' and denoted byAs per, a 'maximal valid cluster' is defined as a valid cluster where no additional paired-end read alignments can be added such that the cluster remains valid. Note that all paired-end read alignments in maximal valid clusters suggest the same potential structural variation. It was shown that it is sufficient to calculate all maximal valid clusters to solve the MPSV problem. This can be done in polynomial time (with respect to the number of paired-end alignments), where the computation of all valid clusters is unnecessary, and exponential in run time. In
i352
Next-generation VariationHunter(2009) and, efficient algorithms to find the maximal valid clusters are presented to predict insertion, deletion and inversion events. To find all maximal valid clusters for copy events, a nave method would investigate all O(n 3 ) possibilities of potential copy events, for each of the locations Pos Br , Pos L and Pos R between 1 and n, where n is the genome length. This can be done by first creating a cluster for each possible values of Pos Br ,Pos L and Pos R , and then adding those paired-end reads that satisfy the conditions given in Section 2 to the appropriate cluster. Finally, a set of maximal clusters would be selected. The above method guarantees to find all the maximal valid clusters but it would be time consuming in practice. In what follows, we will present a more efficient method to find all the maximal valid clusters provided that the potential positions of copied segments or copied sequences are known.} as the set of (nonoverlapping) segments that can be copied to other locations ( can represent the annotated transposons in the reference genome assembly). Note that  i  t,  i is the start location of the i-th segment and  ir is the end location. The coordinates for the intervals are referred to as 'end-points' in the rest of the article for simplicity. For each paired-end read mapping ape with exactly one end-read mapped to a transposon e.g., there exists a range of locations, or 'breakpoint intervals', where ape supports a copy ofto any location within Br i ape in the reference genome. Note that for a given ape and a segment  i = ( i , ir ), the breakpoint interval Br i ape can easily be computed using the set of conditions given in Section 2. Now we present an efficient algorithm 3 to find the maximal valid clusters supporting copy of segment  i = ( i , ir ) to any location in genome (the algorithm can trivially be extended for other segments in ). Without loss of generality, we assume that there are total of m i discordant mappings with exactly one end mapped to  i (Please note that m = t i=1 m i , where total number of segments is t). We denote the set of such discordant paired-end read mappings as ape i ={ape i 1 ,ape i 2 ,.
..,ape i m i}. In addition the set of breakpoint intervals for the paired-end read alignments in set ape i is denoted as)}. It is trivial to see that finding maximal valid clusters for all copies of segment  i = ( i , ir ) into any position in the genome is equivalent to finding all maximal intersecting breakpoint intervals for all paired-end read mappings ape i. Thus, we are interested in finding all maximal intersections of the breakpoint intervals Br i. In what follows, we present an O(m i logm i +s i ) algorithm that outputs all the maximal intersecting intervals (of Br i ), where s i is the size of the output. This algorithm is the optimal solution to the problem. Please note that an algorithm that finds maximal valid clusters supporting copy of a given segment  i with running time of O(m i logm i +s i ) will yield an O(mlogm+S) algorithm for finding maximal valid clusters for all the segments in when
Algorithm for finding all maximal intersecting intervalsGiven a set of intervals (with cardinality of m i ), we want to find all the maximal intersecting intervals. We first sort all end points of m i intervals (2m i coordinates) in ascending order based on their values. We call this sorted list of intervals L where each interval appears twice in the list L. We then scan the sorted list from left to right: @BULLET If we observe a point that is at the left end-point of an interval, we insert the interval to a minimum heap data structure, denoted as heap.The priority value of the heap is the right end point of the inserted interval. After each insertion of a new interval to heap, we set a flag newIns = true.3 In fact the algorithm is optimal with respect to the running time. @BULLET If we observe a point that is at the right end point of an interval, we first check the flag newIns. If it is set to true, we output all the elements in the heap as one maximal cluster and set newIns = false. We then remove the interval from heap since it is guaranteed that the value of the right end point of the interval removed from the heap is the same as the right end point of the interval reached in scanned list L. We continue removing intervals from heap until the priority value of the head element of the heap remains unchanged.The above algorithm outputs all maximal intersecting intervals that are equivalent to the maximal valid clusters.
ComplexityIt can be shown that the running time of the above algorithm is O(m i logm i +s), where s is the size of the output. The sorting procedure in the first step of the algorithm takes O(m i logm i ). In the worst case, since each removal/insertion operation in the heap takes O(logm i ) time, the total run time for the second step is also O(m i logm i ). It takes O(s) time to write the output. In addition, it was previously proven that finding the maximum clique in an interval graph has a lower bound of (m i logm i ) (). Thus, our algorithm gives the optimal solution for finding all maximal clusters.
Detection of transposon insertion events from maximal valid clustersEach maximal valid cluster for different SV types (i.e. insertion, inversion, deletion or copy) only suggests a potential structural variation. The fact that each paired-end read can be mapped to multiple locations that are included in multiple maximal valid clusters proves that some of these implied potential variants are incorrect. We previously presented a combinatorial method to select the minimum number of these clusters (equivalent to selecting minimum number of SVs), such that each paired-end read has a map location in at most one selected valid cluster (). This problem was called MPSV, and an approximation algorithm was given. The same algorithm presented can be used to find transposon insertion events from the maximal valid clusters using the algorithms presented in the previous section. In the next section, we introduce an extension to MPSV problem and provide an efficient method to solve it. We show that our new method outperforms our previous algorithm in.
MPSV WITH CONFLICT RESOLUTIONAs mentioned before, the possibility of multiple map locations for each paired-end read raises the question of resolving which SVs implied by the maximal valid clusters are correct. The MPSV problem () aims to compute a unique mapping for each discordant paired-end read in the reference genome such that the total number of implied SV is minimized (in this section we consider all classes of SV). In, MPSV was modeled as a combinatorial optimization problem and shown to be NP-complete. An approximation algorithm (denoted as VariationHunter) based on the setcover problem with O(logn) approximation factor was given. However, the modeling of the MPSV problem imposed no limits on the number of 'overlapping' SV predictions. A considerable amount of the predicated calls overlap with each other and a post-processing heuristic to filter some of those overlapping predicted SVs was given [see the Results section of. In this section, we mathematically formulate these 'conflicts' and model the structural variation discovery problem as a novel combinatorial optimization problem.
Conflicting SV clusters in haploid and diploid genome sequencesWe motivate the 'conflict resolution' for structural variation using a simple example. Given paired-end reads from a haploid genome,a structural variation detection algorithm (such as VariationHunter, MoDIL or BreakDancer) might construct two or more sets of valid clusters that imply multiple conflicting deletion calls (). Assuming the genome is haploid, it is not possible that both valid clusters incan be 'correct'. We first formalize the MPSV with Conflict Resolution (MPSV-CR) for both haploid and diploid genomes, and then we analyze the complexity of the MPSV-CR problem. Finally, we provide a heuristic solution for MPSV-CR. We call this solution as VariationHunter with Conflict Resolution (VariationHunter-CR). Assuming a haploid genome, two valid clusters Vclu 1 and Vclu 2 of pairedend reads are conflicting if and only if there exists a potential scenario of SVs implied by the two valid clusters, such that the existence of one of the events makes the other valid cluster incoherent (). In the Supplementary Material, we present the set of rules to determine whether two valid clusters are in conflict in a haploid genome. Through the conflict rules we can model the conflict representation of all clusters using a graph denoted as conflict graph. Each cluster is represented a node, and there exists an edge between two nodes if and only if the two corresponding clusters are in conflict with each other. It is not difficult to see that a valid set of SVs is a set of nodes/clusters in which no two nodes within the subset are connected. In another words, the valid solution (without any conflicts) is an independent set of the conflict graph. One can easily generalize the definition of conflicting clusters to diploid genome sequences. Let Vclu 1 and Vclu 2 be two conflicting clusters in a haploid genome. However, provided that the genome is diploid, both Vclu 1 and Vclu 2 might imply a correct SV in different haplotypes. Now consider a third SV cluster, Vclu 3 that is in conflict with both Vclu 1 and Vclu 2. It is trivial that, based on the pigeon hole principle, Vclu 1 , Vclu 2 and Vclu 3 cannot simultaneously occur in a diploid genome. In other words, the presence of three different SV clusters that are conflicting pairwise in a haploid genome 4 will be a conflict in a diploid genome. The concept of the conflict graphs for haploid genomes can be replaced with conflict hypergraphs for diploid genomes. In the conflict hypergraph each hyperedge connects three nodes, if these three nodes are in conflict with each other. Now, we define the MPSV-CR problem that does not only aim to minimize the total number of implied SVs, but also guarantees that no pairwise conflicting triplet of the implied SVs exists. Note that this new version of the MPSV problem does not select any conflicting SVs and thus may not always be able to assign every paired-end read to a particular SV. Thus, the optimization function for MPSV-CR not only tries to minimize the number of SVs predicted, but also maximizes the number of paired-ends that can be assigned to a location in genome. In what follows, we present the concept of conflicting SV clusters in more detail and give a formal definition of the MPSV-CR problem. 4 According to our definition of conflicts in a haploid genomes.
i353
F.Hormozdiari et al.
Formal definition of the MPSV-CR problemIn this section, we formally define the MPSV-CR problem. Let MC ={VClu 1 ,VClu 2 ,...,VClu n } be the set of SV clusters and R = {pe 1 ,pe 2 ,...,pe m } be the collection of discordant paired-end reads. These discordant read pairs can be mapped to multiple locations in the genome,In order to formulate the constraints, we define the conflict hypergraph CG as a hypergraph with vertex set V (CG) = MC and a hyperedge set E(CG) as follows. Between every three distinct SV clusters that are pairwise in conflict, there exists a hyperedge in E(CG):VClu k are pairwise in conflict} Note that for the case when we only deal with a haploid genome (rather than a diploid genome), the hypergraph is nothing else than a simple graph (denoted by G) where each e  E(G) represents a pair of conflicting SV cluster. A subset SC  MC is satisfiable under the constraint hypergraph CG,in the case of a haploid genome a subset SC  MC satisfiable under the constraint graph G, ifFor each satisfiable subset SC and each paired-end read pe i , we define the indicator variable (SC,pe i ) as follows:
otherwiseIntuitively, (SC,pe i ) is the penalty for not assigning the pair-end read pe i to a cluster in the satisfiable subset SC. The MPSV-CR problem aims to find the satisfiable set SC such that f (SC ) =|SC |+ peR (SC ,pe) is minimized (i.e. to find a trade-off between the number of SV clusters in a satisfiable set and the number of paired-end reads that are not assigned to any SV clusters.).
Computational complexity of MPSV-CRHere we prove that MPSVCR is NP hard, independent from the weights on the cardinality of SC and the penalty for unmapped reads [i.e. minimizing the function g(SC ) = k |SC |+l  peR (SC ,pe) for any k > 0 and l > 0 is. The NP hardness proof follows a reduction from the minimum set cover problem (See the Supplementary Materials for the detailed proof). In addition, we show an inapproximability result for MPSV-CR problem even when the genome is assumed to be haploid.
An efficient solution to the MPSV-CR problemIn this section, we present a heuristic solution for a special case of the MPSV-CR problem where both k and l (the coefficients in the optimization function g) are set as k = 1,l = 1. This heuristic, named as Max_Assigned_Reads, consists of two phases. In the first phase, we form a maximal satisfiable set of SV clusters (denoted by MS) in a greedy fashion. Note that a satisfiable set of SV clusters, SC (as noted in the previous section), is called maximal if no other SV cluster VClu can be added to SC such that VClu together with two existing SV clusters in SC form a hyperedge in the conflict hypergraph CG. We start with MS = and then iteratively add the SV cluster that covers the most number of pairedend reads 5 to MS until MS becomes a maximal satisfiable set. Note that we
Next-generation VariationHunteradd an SV cluster SV k to MS in an iteration even if SV k does not cover any new discordant paired-end read (provided that MS remains satisfiable). We denote MR as the set of all paired-end reads covered by the SV clusters in MS. In the second phase of Max_Assigned_Reads, the aim is to select the minimum number of SV clusters from MS that cover all paired-end reads in MR. For this phase, we use a set cover approach similar to. In what follows, we give a lower bound on the cardinality of MR.The analysis of the second phase of Max_Assigned_Reads is similar to. Let m be the total number of discordant pairedend reads, and let neighbors(VClu) ={VClu |e  E(CG),VClu,VClu  e}, deg(VClu) =|neighbors(VClu)| and = max{deg(VClu)|VClu  MC}, i.e. the maximum degree of a vertex in the conflict graph CG.Proof. Let k be number of iterations of Max_Assigned_Reads. For each i (1  i  k), we denote VClu i as the cluster that is selected at the i-th iteration. We also denote MR i as the set of paired-end reads that are covered by VClu i for the first time. Furthermore, we define UR i as the set of paired-end reads that are not covered by any of the SV clusters VClu 1 through VClu i and also is not able to be covered later (as the result of selecting VClu i ) in the remaining k i iterations. At the i-th iteration, the maximum number of reads that could be covered for all neighbors of VClu i is at most |MR i |, thus |UR i ||MR i |. Moreover, we have k i=1 (UR i +MR i ) = m and |MR|= k i=1 MR i. Hence m/(+1)  |MR|.
EXPERIMENTAL RESULTS
ImplementationIt is established that there are a large number of mobile elements in the human genome (). For example, the reference human genome assembly annotation includes 1 million copies of the Alu element. Considering all known mobile elements (segments in genome) as potential transposon sequences for our algorithm would be very time consuming, and in fact, unnecessary. The consensus sequences for all mobile elements are well studied, and available at the RepBase database (). We used the consensus sequences of these mobile element families as representative sequences to facilitate faster experimentation. To this end, we create a new sequence, denoted as chrN: we first append a poly-N sequence to each consensus sequence, and then concatenated them, generating chrN. In this article, we considered only Alu and SVA elements in our experiments. For read mapping, we use mrsFAST (F.unpublished data), a cache-oblivious short read mapper recently developed as an extension of mrFAST (). mrsFAST maps the paired-end reads to all locations with Hamming distance less than a user-defined threshold . In this experiment we set  = 2. Given paired-end whole-genome shotgun sequence library R = {pe 1 ,pe 2 ,...pe n }, we follow the following steps to obtain the reads (and mapping information) for transposon discovery: @BULLET We first map all paired-end reads to chrN using mrsFAST and discard such paired-end reads that cannot be mapped to chrN. We keep the read pairs where one end read is mapped to chrN. @BULLET Next, we map the reads we determine in the previous step to the reference genome, and discard all paired end reads with at least one concordant mapping.@BULLET Finally we remap the reads from Step 2 to both chrN and the reference genome. As a post-processing step, we select the paired-end alignments where one end is mapped to chrN and the other end is mapped to the reference genome.
Mobile element insertion discovery in the Venter genomeA list of mobile element insertions in the Venter genome assembly (HuRef) () in comparison to reference human genome assembly (NCBI build 36) genome was recently published (). We used the available HuRef genome to produce short paired-end reads, similar to reads generated by the Illumina technology (simulating an Illumina sequencing of the Venter genome) to benchmark the sensitivity and specificity of our algorithms. To our knowledge, this is the only dataset for mobile element insertion annotations from the genome of a single individual. We created paired-end reads from the HuRef genome with a read length of 36 bp, and obtained 10-fold sequence coverage. The fragment insert sizes for paired-end reads were chosen randomly that follows a normal distribution very similar to the fragment size distribution in the NA18507 shotgun sequence library generated using the Illumina platform (). We used our mobile element insertion discovery algorithm to discover transposons in the autosomes of HuRef (from chr1 to chr22). In our experiments, we focused on Alu, NCAI (Non-classical Alu Insertion) 6 and SVA insertions. The results of our experiment are summarized in, our method was able to find most of the known/validated mobile element insertions (recall rate is >85%), while the number of invalidated predictions is very low (precision rate 90%). Interestingly, most of the Alu insertions missed by our algorithm were truncated insertions (significantly smaller than the consensus sequences).summarizes the true positive/false negative results with respect to the length of Alu insertion.
Next-generation VariationHunteralgorithms are still at their infancy. In this article, we presented the 'Next-Generation' of our structural variation discovery algorithm VariationHunter that aims to improve both the sensitivity and specificity of SV detection. VariationHunter is now capable of resolving incompatible SV calls through a conflict resolution mechanism that no longer requires post-processing heuristics. Furthermore, we described additional algorithms to discover mobile element insertions that are of known importance to genome evolution and genomic variation. These enhancements provide a much needed step toward a highly reliable and comprehensive structural variation discovery algorithm, which, in turn will enable genomics researchers to better understand the variations in the genomes of newly sequenced human individuals, as well as the genome structures of non-human species.
ACKNOWLEDGMENTS
Referring to an insertion, deletion and inversion event, respectively. i351 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from [09:08 2/6/2010 Bioinformatics-btq216.tex] Page: i354 i350i357
We count the paired-end reads that were not previously covered by any SVs in MS. i354 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Alu insertions that only contain the internal fragment of Alu are called non-classical Alu insertions (NCAI; Xing et al., 2009). i355 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
CONCLUSIONS Despite recent advances in algorithm design for the detection of structural variation, due to the difficulty in discovering complex variants in regions of the genome with high plasticity the existing i356 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
i357 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
