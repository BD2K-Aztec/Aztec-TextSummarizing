Multiple sequence alignment is an important tool in bioinformatics. Although efficient heuristic algorithms exist for this problem, the exponential growth of biological data demands an even higher throughput. The recent emergence of multi-core technologies has made it possible to achieve a highly improved execution time for many bioinformatics applications. In this article, we introduce an implementation that accelerates the distance matrix computation on x86 and Cell Broadband Engine, a homogeneous and heterogeneous multi-core system, respectively. By taking advantage of multiple processors as well as Single Instruction Multiple Data vectorization, we were able to achieve speed-ups of two orders of magnitude compared to the publicly available implementation utilized in ClustalW. Availability and Implementation: Source codes in C are publicly available at https://sourceforge.net/projects/distmatcomp/
INTRODUCTIONMultiple sequence alignment (MSA) of many nucleotides or amino acids is an important tool in bioinformatics. It can identify patterns or motifs to characterize protein families, and is therefore utilized to detect homology between sequences as well as to perform phylogenetic analysis. Many MSA heuristics have been proposed to reduce the exponential complexity of computing optimal MSAs. Heuristic MSA implementations include MSA (), ClustalW (), T-Coffee (), MUSCLE () and PRALINE (). ClustalW is considered to be one of the most popular MSA tools. It is based on the progressive alignment method. Although not optimal, this method can produce reasonably good alignments at a good efficiency. However, the exponential growth of biological data demands an even higher throughput. Thus, software approaches to improve the performance of ClustalW have been introduced, including caching () and parallel processing (). Recent usage of easily accessible accelerator technologies to improve the ClustalW algorithm include FPGAs () and GPUs (). Profiling of ClustalW reveals that the distance matrix computation is the most time-consuming phase and takes typically >90% of thePage: 1369 13681369
Cell/BE and x86/SSE2 architecturesprofile computation is done in the power processor element (PPE) and is distributed to the respective SPEs using direct memory access (DMA) transfer. For the SSE2 implementation, each thread contains its respective query profile information needed to complete the computation. Our Cell/BE implementation utilizes the additional instructions of the PPE relating to control of the SPEs to implement the multi-threading. Unlike SPEs, the PPE can read and write the main memory and the local memories of SPEs through the standard load/store instructions. The PPE reads the input dataset, pre-processes it and divides the dataset into equal size blocks for each SPEs to process. Since the blocks are independent of each other, no thread synchronization is necessary during the calculations. The mailbox functions spe_in_mbox_write and spu_read_in_mbox are used to ensure that all the SPEs obtain their respective contexts in their local memory. Using the context data, each SPE then transfers any required information and necessary sequences. To improve transfer efficiency, the database sequences in main memory and in the local storage are aligned within the cache line and data structures are initialized during the transfer of the sequence. Our SSE2 implementation uses pthreads to implement the multi-threading. The input dataset are pre-processed and sorted according to length. Each thread contains a copy of the database sequence, query sequence and its respective query profile. Since the datasets are sorted, the datasets are divided into roughly equal size workload for each thread to process. Cell/BE does not support saturation arithmetic that are needed in the calculations to anticipate overflow problems. Hence, we utilized several SPU intrinsics, i.e. spu_sel, spu_splats, spu_rlmaska, spu_nor and spu_and in conjunction with the existing spu_add and spu_sub to handle saturated additions and saturated subtractions, respectively. Unlike Cell/BE, Intel's SSE2 instructions support saturation arithmetic. Hence, saturated subtraction and addition functions, _mm_subs_epu16 and _mm_adds_epu16, respectively, are utilized to ensure that the values of the vector are within valid range.
RESULTSA set of performance evaluation experiments have been conducted using six protein sequence datasets consisting of sequences selected from the human immunodeficiency virus (HIV) dataset downloaded from NCBI. The experimental datasets represent datasets of small number of long sequences, medium number of medium-length sequences and large number of short sequences, respectively. Our Cell/BE implementation is benchmarked on a standalone PlayStation3 (PS3) with Fedora Core 9.0 and the Cell Software Development Kit (SDK) 3.1. Our SSE2 implementation is benchmarked on an Intel Quad-Core i7-920 2.66GHz CPU, 12 GB RAM running Linux Fedora 10. The sequential ClustalW application, available online at http://www.bii.a-star.edu. sg/achievements/applications/clustalw/, was benchmarked on an Intel Quad-Core i7-920 2.66GHz CPU, 12 GB RAM running Linux Fedora 10.shows the performance evaluation of our implementations using the above-mentioned datasets on different architectures. The Cell/BE implementation shows a better performance for datasets with fewer but longer sequences, while the SSE2 implementation shows a better performance for datasets with more but shorter sequences. This is due to the overhead for the PS3, which involved DMA transfers of required data and sequences between the PPE and the SPEs. Since the first stage of several other MSA tools, e.g. T-Coffee () and MUSCLE () is also based
* To whom correspondence should be addressed. overall runtime. Therefore, accelerating this phase would greatly improve the performance as a whole. Implementations through the use of Single Instruction Multiple Data (SIMD) parallelism can achieve increased performances by performing operations on multiple values in parallel. The recent emergence of multi-core technologies, either homogeneous or heterogeneous, makes it possible to achieve an improvement in execution time for many bioinformatics applications (Szalkowski et al., 2008; Wirawan et al., 2008). In this article, we introduce our implementation that accelerates the distance matrix computation on the Cell Broadband Engine (Cell/BE) and the commonly used Intel x86 architecture. By taking advantage of multiple processors as well as SIMD vectorization, we were able to achieve significant speed-ups of two orders of magnitude compared to the distance matrix computation used in ClustalW. 2 METHODS Our Cell/BE implementation takes advantage of the 128-bit SIMD vector registers of each synergistic processing elements (SPE) and uses half-word values (16 bits) for the computation, which is the smallest element supported by the Cell/BE instruction set. This allows eight cells to be processed per vector register. SPU intrinsics (IBM, 2007) are used to improve the efficiency of the program. The SSE2 instructions support 8-and 16-bit elements in the vector registers. Our implementation utilizes 16-bit elements, allowing eight cells to be processed per vector register. Since all elements in the same minor diagonal of the dynamic programming (DP) matrix can be computed independent of each other in parallel, the computation is done in minor diagonal order. In our implementation, distance values d(S i ,S j ) are computed without computation of the actual traceback using DP. Since all elements in the same minor diagonal of the DP matrix can be computed independent of each other in parallel, the computation is done in minor diagonal order. Given are sequences S i and S j of lengths l 1 and l 2 , respectively and vector registers vH, vE, vF, vN A , vN E and vN F containing the values H A , E, F, N A , N E and N F , respectively. For each iteration c 1  c  l 1 +l 2 1 , the values of H A (i,j), E(i,j), F(i,j), N A (i,j), N E (i,j) and N F (i,j) are computed for all 1  i  l 1 and 1  i  l 2. Vector masks are computed during the calculations of the vE, vF and vH vectors, which are then used to determine the value of the corresponding vN E , vN F and vN A vectors, respectively. The nid score is extracted as N A (i max , j max ), where (i max , j max ) denotes the coordinates of the maximum value in the corresponding matrix H A. The algorithm used in our implementations is described in more detail in Wirawan et al. (2009). To speed-up the computation, a query profile is pre-computed. The query profile is indexed by the query sequence position and the database sequence symbol and is stored in a column-based manner. Therefore, random accesses to the substitution matrix due to table look up are replaced with sequential ones to the query. For the Cell/BE implementation, the query
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Table 1. Comparison of run-times (in seconds) of our Cell/BE
