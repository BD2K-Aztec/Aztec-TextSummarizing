Next-generation sequencing (NGS) technologies have raised a challenging de novo genome assembly problem that is further amplified in recently emerged single-cell sequencing projects. While various NGS assemblers can use information from several libraries of read-pairs, most of them were originally developed for a single library and do not fully benefit from multiple libraries. Moreover, most assemblers assume uniform read coverage, condition that does not hold for single-cell projects where utilization of read-pairs is even more challenging. We have developed an exSPAnder algorithm that accurately resolves repeats in the case of both single and multiple libraries of read-pairs in both standard and single-cell assembly projects. Availability and implementation: http://bioinf.spbau.ru/en/spades Contact: ap@bioinf.spbau.ru
INTRODUCTIONMost of existing next-generation sequencing (NGS) platforms generate read-pairspairs of reads (called mates) that are sequenced from different ends of a genomic fragment with approximately known length (called the insert size). Because the insert size usually exceeds the length of a single read, readpairs may match up unique regions surrounding repeats that are longer than the read length. A combination of several libraries of read-pairs with different insert sizes is often used to produce high-quality assemblies (). Paired-end libraries usually have insert size 51 kb and are used for resolving relatively short repeats. Jumping libraries are characterized by an average insert size of anywhere from 1 to 20 kb and are helpful in resolving longer repeats and contig scaffolding (inferring the order of contigs in the genome). However, because of a high insert size variation, information from jumping libraries is rather difficult to use for the purpose of assembly. The problem of using multiple read-pair libraries was previously addressed by ALLPATHS-LG (), Ray (), Velvet () and some other assemblers. However, these tools are designed for standard (mutlicell) assemblies and do not perform well on single-cell datasets. On the other hand, the single-cell assemblers ESC (), IDBA-UD () and SPAdes () are designed for a single read-pair library. In addition, the recently proposed Paired de Bruijn Graph algorithms for repeat resolution () also focus on a single library and it remains unclear how to extend them to multiple libraries. We present EXSPANDER algorithm that works with both single and multiple libraries in standard and single-cell assembly projects. EXSPANDER uses a simple path extension approach for repeat resolution that was originally proposed in the Ray assembler [and later used in Telescoper (and combines it with some ideas from the Rectangle Graph approach (). Given a set of paths in the assembly graph () (i.e. simplified de Bruijn graph () of k-mers in reads after removal of bulges, tips and chimeric edges), EXSPANDER attempts to extend each path with the goal to generate longer paths. For a path P ending in a vertex v, we consider all edges starting at v (referred to as extension edges) and compute Score P (e) for each extension edge. To compute Score P (e) we analyze all reads that map to path P and whose mates map to e. Thus, Score P (e) reflects our confidence that an extension of the path P by the edge e is correct. We note that to properly map read-pairs and calculate Score P (e), the total length of path P and edge e should be longer than the insert size. In addition to function Score P (e), EXSPANDER uses a decision rule Extend(P) that either chooses one of the extension edges to extend the path P or makes the decision to stop growing this path beyond the ending vertex of P. The procedure is iterated over all the paths until no path can be further extended. To initiate this algorithm one can start with a set of single-edge paths formed by all sufficiently long edges in the assembly graph. The resulting paths are output as contigs after removing the paths that are contained within other paths as well as removing non-informative overlaps (i.e. suffixes of paths that represent prefixes of other paths). This simple approach is merely a framework and, depending on the specifics of the scoring function and the decision rule, it can be either efficient (like in the Ray assembler) or disastrous. The authors of Telescoper made an attempt to improve on Ray's scoring function and to substantiate it with rigorous statistical analysis. However, scoring functions in both Ray and Telescoper are not universal, e.g. they assume the uniform genome coverage by reads, condition that does not hold for single-cell data. We demonstrate that EXSPANDER works well on single-cell datasets with multiple libraries. We also show that EXSPANDER *To whom correspondence should be addressed.
yThe authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors.  The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com [implemented as a part of SPAdes (] improves on existing assemblers on standard bacterial datasets and outperforms such popular assemblers as ABySS (), Ray (), SOAPdenovo () and Velvet (). ALLPATHS-LG () is an excellent assembler whose applications, however, are limited to specially constructed read-pair libraries. On such libraries EXSPANDER and ALLPATHS-LG generate comparable results (EXSPANDER generates longer contigs but ALLPATHS-LG generates longer scaffolds).
ANALYSIS OF READ-PAIR LIBRARIESAs we mentioned in the introduction, jumping libraries present additional challenges for genome assembly owing to their high variations in the insert size. Additionally, jumping libraries have high rate of chimeric read-pairsread-pairs that either have abnormal insert size or incorrect orientation. Chimeric read-pairs further complicate utilization of such libraries while resolving repeats. Below we present analysis of the insert size distributions for the following data: Brachybacterium faecium isolate dataset (read length 150 bp) and Staphylococcus aureus single-cell dataset (read length 101 bp). Both datasets contain one paired-end and one jumping library. To analyze read-pair libraries we aligned reads to the B.faecium and S.aureus reference genomes using Bowtie 2 () and computed the chimeric readpair rates and insert size distributions. Asanddemonstrate, both isolate and singlecell paired-end libraries have small variations of the insert size. In contrast, the jumping library from the B.faecium dataset has a much higher variation in the insert size and higher rate of chimeric read-pairs (). At the same time, in addition to the large insert size variations, S.aureus jumping library contains only 22% of all read-pairs aligned with the proper reverse forward orientation. Thirty-six percent of all read-pairs have incorrect forwardreverse orientation (correspond to the left peak in) and 14% are classified as chimeric read-pairs of other types. Forwardreverse read-pairs in jumping libraries represent an artifact of the sample preparation and are common for datasets of different types. Despite the fact that various artifacts of jumping libraries make it difficult to incorporate them into existing assembly tools, EXSPANDER uses jumping libraries to generate high-quality assemblies.
EXSPANDER ALGORITHMEXSPANDER uses an assembly graph constructed by SPAdes () and a set of read-pair libraries. For each library, we map read-pairs to the long edges of the assembly graph and estimate the average insert size along with its confidence intervala shortest insert size interval that contains at least 80% of properly aligned read-pairs. These estimates are used as parameters of the scoring function and the decision rule.
The decision rule
Single libraryGiven a path P, we define a winner as an edge e with the maximal score Score P (e) among all extension edges for P. Similarly, a contender is defined as an extension edge with the second best score. The winner edge is called the strong winner if (i) Score P (winner) 4 and (ii) Score P (winner)4C  Score P (contender), where  and C are parameters of the algorithm, which are discussed below. If the path P has a single extension edge (which is obviously the winner), only the first condition is used. The decision rule is defined as follows:ExtendP= e; if edge e is the strong winner for path P ;; if there is no strong winner for path P (
Multiple librariesThe decision rule described above can be generalized for several read-pair libraries. Consider M readpair libraries, which are sorted in the order of increasing insert. Plots of the insert size distributions for B.faecium isolate (a) paired-end and (b) jumping library, and S.aureus single-cell dataset with (c) paired-end and (d) jumping library. The distributions were computed by mapping reads to the B.faecium str. DSM4810 () and S. aureus str. USA300 substr. FPR3757 () reference genomes, respectively. All plots are in the logarithmic scalesizes and the associated decision rules Extend i (P) for 1 i M. We process the libraries in this order because our analysis revealed that the smaller is the insert size of a library (and its variation), the more reliable is the decision rule for this individual library. We thus select the library with the smallest index i that has the strong winner and define the decision rule for multiple libraries Extend(P) as simply Extend i (P). If neither library has a strong winner, we define ExtendP=;.
The scoring function3.2.1 The support function We first consider an idealized case when the genome defines a genomic path in the assembly graph. We say that an edge e 0 follows edge e at a distance D if the distance between starts of these edges in the genomic path is D. We define a boolean function Support D (e,e 0 ) that reflects our confidence that edge e 0 follows edge e in the genome at distance D. Below we describe how to calculate Support D (e,e 0 ). Let I and [I min ,I max ] be the mean and the confidence interval of the insert size for a read-pair library formed by reads of length ReadLength. Consider consecutive edges e and e 0 in the assembly graph and a read-pair (r,r 0 ) such that read r maps to e at position x 0 and read r 0 maps to e 0 in position y 0 (). We say that the read-pair (r,r 0 ) connects edges e and e 0 .shows a rectangle formed by the edges e and e 0Thus all 'ideal read-pairs' mapping to edges e and e 0 form a set of integer points on the 45 line y = x d within the rectangle (). Because the read-pairs from the real sequencing data have variations in the insert size, their corresponding points are typically scattered in the strip between the 45 lines y = x  d min and y = x  d max , where d min =Lengthe  I min +ReadLength;This strip in the rectangle is further referred to as the confidence strip (). Let F(x) be the empirical distribution of the insert size and S be a set of all integer points within the confidence strip in the rectangle (e,e 0 ). We define the expected number of read-pairs within the confidence strip (under the assumption of the uniform coverage) aswhere Ix; y=Lengthe  x+y+ReadLength represents the insert size of a read-pair that corresponds to the point (x, y). We also define Points(e,e 0 ) as the total number of read-pairs (from the real dataset) that correspond to the points within the confidence strip. The notion of density is defined asDensitye; e 0 = Pointse; e 0  Expectede; e 0  :We set Density(e,e 0 ) = 0, if Expected(e,e 0 ) = 0. The points outside the confidence strip may represent read-pairs with somewhat larger deviations from the mean insert sizes or chimeric readpairs. Our analysis revealed that being conservative (e.g. limiting analysis to the confidence strip) allows one to avoid most of the assembly errors caused by chimeric read-pairs, particularly in single-cell projects. We distinguish between notions of genome-consecutive and graph-consecutive edges and emphasize that graph-consecutive edges are not necessarily genome-consecutive. The decision about which graph-consecutive edges are genome-consecutive is an important part of any assembler.and e illustrate how rectangles help us to make such decisions: both rectangles correspond to graph-consecutive edges, but only rectangle inwhere  is a parameter of the algorithm, which is automatically computed for each read-pair library based on the chimeric readpair rate (see below). For the standard isolate datasets this parameter corresponds to the coverage cutoff for read-pairs. For single-cell datasets this parameter is usually set to be very low to retain the regions with low coverage, which are typical for single-cell projects. If Support D (e,e 0 ) = 1, we say that the rectangle (e,e 0 ) is supported by the read-pairs.
The naive scoring functionTo explain the intuition behind EXSPANDER, we first introduce the naive scoring function. We further modify the naive scoring function to arrive to the advanced scoring function used in the real EXSPANDER implementation. A path P = (p 1 ,. .. ,p m ) and its extension edge e can be represented as a composite rectangle formed by m simple rectangles (p j ,e) containing points that correspond to read-pairs connecting edges of P and e.e 2  be the true (but unknown) genomic paths.shows the composite rectangle for path P and its correct extension e 1 , in which points within the confidence strip are rather evenly distributed resulting inBecause the defined scoring function does not linearly depend on read coverage, it is well suitable for both single-cell and standard sequencing projects. At the same time, considering only readpairs with insert size in [I min ,I max ] (which correspond to points within the confidence strip) allows one to filter out most of the chimeric read-pairs (common for single-cell datasets) and to minimize their influence on the scoring function.
The advanced scoring functionThe naive scoring function Score P (e) described above works well in many cases but may be too conservative when the path P contains repetitive edges (edges that are visited more than once by the genomic traversal).be a path we aim to extend. We first calculate scores of all extension edges using the composite rectangles (c) and form a set of active edges A=fe 1 ; e 2 ; e 3 g based on their scores (marked red in). Because Support D3 p 3 ; e i =1 for i = 1, 2, 3, edge p 3 is classified as repetitive and is removed from further consideration (). We now recalculate scores for the extension edges in A ignoring repetitive edge p 3 (h) and remove non-active edge e 3 from A (). Using the updated set A=fe 1 ; e 2 g we again proceed to the repeat detection step and mark edge p 2 as repetitive because Su pport D2 p 2 ; e i =1 for i = 1, 2 (). Finally, we once again recalculate scores of the extension edges in A (m) and remove e 2 as non-active (). The extension edge e 1 remains the only active edge in and is used to extend path P. Extensive tests of the advanced scoring function revealed that it works well across diverse datasets including single-cell jumping libraries with high variations in the insert size, extremely nonuniform coverage and large number of chimeric reads and chimeric read-pairs (see Section 4).
ScaffoldingAfter all paths are constructed, we consider all pairs of paths that form composite rectangles with non-zero number of points (). For each such pair of paths P and P 0 we can check whether points in the corresponding composite rectangle are scattered around a certain 45 line using SPAdes distance estimation procedure (). When SPAdes provides the estimated distance D between P and P 0 , we use EXSPANDER to verify the conjecture that P 0 follows P at distance D. If this conjecture is supported and does not contradict to any other conjectures about these paths, we extend the path P by P 0 (the scaffolding step). We estimate the gap length between the paths as D  LengthP and insert the appropriate number of 'N' symbols (unspecified nucleotide) between end of P and start of P 0. If paths P and P 0 overlap, we construct their overlap alignment to correct distance D.
Choice of the parameters3.4.1 The scoring function We select the parameter  as a threshold for the density of the read-pairs within the confidence strip. We therefore assume that rectangles with the density below  contain mostly chimeric read-pairs and should be ignored while calculating the score of an extension edge. To select  for a particular read-pair library, we estimate the distribution of the densities for rectangles that contain only chimeric readpairs (false rectangles) and for rectangles that contain only nonchimeric read-pairs (true rectangles). To partition all read-pairs into chimeric and non-chimeric, one needs the complete genome that is unavailable. To get around this, we identify a subset of chimeric reads using the long edges in the assembly graph (e.g. edges longer than N50) that can beis a false edge-pair, D * defines a confidence strip S trip D  e 1 ; e 2  with the maximum number of chimeric read-pairs. To compute the threshold , we assume this worst-case scenario for all pairs of uni-edges (within the same long edge) by using distance D * (rather than the known genomic distance) for calculating the densities Density D  e 1 ; e 2 . For a certain value of  we define false positives (false negatives) as the false (true) edge-pairs that have density higher (lower) than  0. Figures 8a and b illustrate how false-positive rate (green) and false-negative rate (blue) depend on the parameter . EXSPANDER selects  that corresponds to the intersection point of the false-positive and false-negative plots. Our benchmarking revealed that such choice of the parameter  allows one to filter out the rectangles containing only chimeric reads-pairs based on their densities. Additional analysis revealed that estimating the parameter  is an important step in the EXSPANDER algorithm because varying this parameter may significantly affect the assembly quality (see Section 3 in Appendix).
The decision ruleOur analysis revealed that varying parameters C and  within specified ranges (see Section 3 of the Appendix) hardly affects the quality of the resulting assemblies. However, selecting inappropriate C and  may result in a deteriorated performance of EXSPANDER. Thus, we arbitrarily select these parameters within the ranges specified in Section 3 of Appendix (analysis of diverse sequencing datasets supports the default values C = 1.5 and  = 0.5).
RESULTS
Datasets We have compared EXSPANDER (coupled withSPAdes assembler) with several popular assemblers on the B.faecium isolate dataset (genome size 3.6 Mb) and the S.aureus single-cell dataset (genome size 2.9 Mb). For each dataset we have generated assemblies of (i) only paired-end library and (ii) both paired-end and jumping libraries. Section 1 of Appendix provides a detailed description of both datasets.
Benchmarking assembliesABySS 1.3.6, Ray 2.0.0, Velvet, Velvet-SC and SOAPdenovo 2.0.4 were run with k-mer size 55. IDBA-UD 1.1.1 was run in its default iterative mode. The authors of () released this new version of IDBA-UD that is capable of using several paired-end libraries, but there is no manuscript yet covering this new development. ALLPATHS-LG was run with the default parameters; however, we down-sampled jumping library for the B.faecium dataset to generate 100 coverage required by ALLPATHS-LG. SPAdes 2.4 (previous version of SPAdes that did not include EXSPANDER and did not support multiple libraries) was run in its default iterative mode with k = 21, 33, 55, 77 for the B.faecium dataset and k = 21, 33, 55 for the S.aureus dataset. EXSPANDER (coupled with SPAdes) was run using the default parameters. To analyze the resulting assemblies we used QUAST 2.2 () that reports various parameters including NG50 (similar to N50, but is calculated with respect to the reference genome size), the total number of contigs/scaffolds, the length of the longest assembled contig/scaffold, the number of misassemblies and the fraction of genome mapped. QUAST defines a misassembly breakpoint as a position in the contig/ scaffold, such that its left and right flanking sequences either align to the reference genome over 1 kb away from each other, or overlap by41 kb, or align on opposite strands or different chromosomes (). To compare assemblers we used both contigs and scaffolds of length exceeding 500 bp.ExSPAnder
Tables 2 and 3 show the benchmarking results forthe B.faecium isolate dataset. Interestingly, the single-cell assemblers (IDBA-UD and EXSPANDER coupled with SPAdes) as well as ABySS performed well on the B.faecium isolate dataset and produced contigs with the largest NG50 in the case of a single library. While AbySS generated the assembly with the maximal genome fraction, manual inspection revealed that it reflects the specifics of ABySS and QUAST reporting (mapping each repeat to a single position in the genome) rather than real superiority of ABySS by this metric. In the case of two libraries, EXSPANDER produced the best contigs while ALLPATHS-LG produced the best scaffolds. The complexity of using jumping libraries is reflected in a deteriorated performance of ABySS and Ray (reduction in NG50) as well as Velvet and Velvet-SC (dramatic increase in the number of misassemblies). Tables 4 and 5 compare various assemblers on the S.aureus single-cell dataset. This comparison highlights the complexity of both (i) assembling single-cell datasets and (ii) using jumping libraries. For example, SOAPdenovo produced assemblies of poor quality for single-cell data (we decided not to include it in Tables 4 and 5). Similarly, ABySS produced assemblies with high number of misassemblies for the single-cell data. Velvet and Velvet-SC are not included in the benchmark experiment for jumping libraries testing because they also produce low-quality assemblies when both paired-end and jumping libraries are used simultaneously. IDBA-UD performed well on a single pairedend library, but produced an assembly of lower quality when both libraries were provided (decreased NG50). EXSPANDER produced assemblies with the highest NG50 and largest assembled contig/scaffold. Using only paired-end library IDBA-UD, SPAdes 2.4 and EXSPANDER recovered the largest fraction of the genome (498.5%). However, the highest genome fraction of the assemblyNote: NG50 is given in kb; number of scaffolds is the total number of scaffolds 4500 bp; largest stands for the length (in kb) of the longest scaffold assembled; number of mis is the number of misassemblies; GF stands for the fraction of genome mapped given in percent. In each column, the best value is indicated in bold.
generated by SPAdes 2.4 reflects the specifics of SPAdes 2.4 andQUAST reporting (some artifacts with reporting of repetitive regions) rather than real advantage of SPAdes 2.4 with respect to this parameter. When using both libraries simultaneously, EXSPANDER produced assemblies with the highest genome fraction exceeding 99%, the largest genome fraction we saw across dozens of single-cell datasets assembled with SPAdes in the past 2 years. Moreover, Tables 4 and 5 show that EXSPANDER successfully deals with the high rate of the chimeric read-pairs and relatively high variations in the insert size.
CONCLUSIONWe have presented EXSPANDER algorithm for resolving repeats using either a single or multiple read-pair libraries with different insert sizes, which is applicable for both single-cell and isolate bacterial datasets. Benchmarks across eight popular assemblers demonstrate that EXSPANDER produces high-quality assemblies for datasets of different types. Additionally, as illustrated by recent integration of Illumina and PacBio reads in SPAdes 3.0, EXSPANDER is a flexible approach that can be easily modified to work with diverse types of sequencing data.Note: NG50 is given in kb; number of scaffolds is the total number of scaffolds 4500 bp; largest stands for the length (in kb) of the longest scaffold assembled; number of mis is the number of misassemblies; GF stands for the fraction of genome mapped given in percent. In each column, the best value is indicated in bold.
i301ExSPAnder
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
