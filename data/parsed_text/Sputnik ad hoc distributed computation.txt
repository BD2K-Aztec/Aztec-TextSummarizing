Motivation: In bioinformatic applications, computationally demanding algorithms are often paral-lelized to speed up computation. Nevertheless, setting up computational environments for distributed computation is often tedious. Aim of this project were the lightweight ad hoc set up and fault-tolerant computation requiring only a Java runtime, no administrator rights, while utilizing all CPU cores most effectively. Results: The Sputnik framework provides ad hoc distributed computation on the Java Virtual Machine which uses all supplied CPU cores fully. It provides a graphical user interface for deployment setup and a web user interface displaying the current status of current computation jobs. Neither a permanent setup nor administrator privileges are required. We demonstrate the utility of our approach on feature selection of microarray data.
IntroductionWe introduce the Sputnik framework that manages parallelization of computational expensive algorithms to distributed inhomogeneous clusters of computing nodes. A task that is increasingly important in bioinformatic applications not only with large data sets but also with the post-processing and interpretation of the primary measurements. This framework is especially intended for parallelization of CPU-intensive computations. Sputnik accomplishes hereby two major goals: the actual fault-tolerant distributed computation and the lightweight ad hoc deployment of programs and data.illustrates the distributed computation with Sputnik. A program on the client creates a job consisting of many tasks and sends it to the server. The server schedules the tasks to the workers which execute them and send back the results. If a worker crashes, the server reschedules its assigned tasks to the other workers. The intended usage scenario of Sputnik does not involve huge amounts of input data unlike the default scenario of applications using Hadoop (hadoop.apache.org). Also unlike the JPPF framework (www.jppf.org) Sputnik achieves a full utilization of all available CPU cores during job execution through its batch-wise task distribution to the worker. This is achieved via task scheduling strategies that assign new tasks to workers upon completion of previous tasks almost immediately. Due to its minimal requirements (a Java runtime and no administrator privileges) Sputnik can be easily deployed to heterogeneous groups of machines with respect to hardware and software. We implemented a feature selection based on a genetic algorithm (GA) to show the applicability of Sputnik.
FunctionalityOur parallelization framework Sputnik is implemented in Clojure (www.clojure.org), a Lisp dialect based on the Java Virtual Machine (JVM). Clojure has a strong functional orientation and a built-in
Distributed computationThe implementation of Sputnik is divided into three parts one for each role (client, worker and server, see in). The communication between these programs is implemented on top of Java Remote Method Invocation and uses the Kryo library (github.com/ EsotericSoftware/kryo) for data serialization. Custom serializers are added for the common data structures of Clojure. Optionally, data compression can be activated. Secure Socket Layer (SSL) encryption can be configured for secure communication. Authentication is implemented via SSL client certificates. Sputnik has a client implementation that provides the basic operations: connecting to the server, job submission and asynchronous task completion notification. The client implementation of Sputnik works asynchronously and thus allows other local computations to take place while the tasks are computed remotely. The Sputnik server manages all jobs and dynamically assigns their tasks to the worker nodes. Each worker node w has a maximum of tasks T max w that it processes in parallel. Hence, the server only assigns a number of tasks proportional to T max w at a time to a worker w. This dynamic scheduling of tasks results in a superior performance than dividing all tasks among the connected workers instantly on job submission as the slowest worker is not able to claim a large number of tasks. It also enables dynamic addition and removal of worker nodes. Additionally, in the final phase of the computation when all tasks are assigned and workers start to run out of tasks, the Sputnik server may start to assign tasks multiply to idle workers to reduce the overall runtime. For a given worker w 2 W the tasks c 2 C with the lowest number of assignments to other workers are then selected first. Among these the tasks c  with the latest estimated minimal completion time are assigned first:N prev w; c is the number of tasks that are assigned to worker w previously or at the same time as task c. vw is the average computation speed of worker w. The first result for a task that was assigned to multiple workers is accepted, the others are discarded. Distributed computation via Sputnik is fault-tolerant with respect to severe failures at the worker nodes because in that case the Sputnik server will reassign tasks of the crashed worker node to other worker nodes.
Lightweight installation and deploymentThe deployment of the server and worker nodes requires only a regular user account (accessible via SSH) on the remote machines. No administrator rights are needed to deploy Sputnik nodes. In case there is no Java installed on the remote machines, Sputnik supports local installations of the Java Runtime in the home directory of the user. Sputnik uses the Pallet library (palletops.com) to distribute all needed files to the remote machines and to start the server and workers. The settings for a Sputnik setup are specified in configuration files. The mandatory settings for a remote machine are the node name, a user account name and its IP address. There are optional parameters that allow customization, e.g. non-standard SSH ports and custom JVM installations. Sputnik offers a graphical user interface for deployment (see) that allows easy configuration and launching of the server and the workers. The role of a node is specified similarly either as server or worker with corresponding settings. The deployment process of Sputnik creates a directory on the remote machine which contains a configuration file with the runtime settings for the node, the additional files that are needed for the computation and a startup script for the node. Hence, in case a severe failure occurs in a task and shuts down the worker (despite the worker being able to handle common exception scenarios) the worker can be manually restarted by the user. Based on the configuration, Sputnik deploys all needed files automatically to the remote machines.
Server user interfaceThe server node offers a web user interface which provides summary information about the performance of running worker nodes and the progress of the running jobs. After logging in with the configured user name and password more detailed information is displayed and the number of parallel computations on each worker node can be changed. A progress report for the running jobs and an estimation of their completion time is shown. Exceptions that occurred during the computations are also accessible in the web user interface.
Application: signature identificationWe demonstrate the usage of Sputnik by the parallelization of a population-based feature selection algorithm for a nearest neighbor classifier (1-NN, see also). A detailed description of the experimental setup can be found in the supplementary information. The method is based on A Bwhere k is the total number of features, r cf s the average featureclass correlation and r ff s the average feature-feature intercorrelation of the feature combination s. Fitness evaluation is the most time-consuming part of the algorithm and is parallelized. As can be observed from, the classification results on the reduced data match those of utilizing all gene expression markers, while generating a substantially reduced signature (up to 99.78%). Also the calculation of the Merit measure scales well with the number of workers and cores used, see.
ComparisonIn the following we compare Sputnik to other parallelization frameworks that are available for the Java platform: JPPF and Hadoop. We compare these frameworks with respect to the parallelization paradigm and the required setup procedure. Finally, we report results of an experimental comparison between Sputnik and JPPF.
Parallelization paradigmThe main parallelization principle differs between these three frameworks: Sputnik and JPPF employ task parallelism, whereas Hadoop uses data parallelism. As illustrated infor Sputnik and JPPF computational problems need to be structured into smaller tasks. In JPPF tasks need to be derived from the JPPF Task class such that for different computation tasks one class for each task is needed. Tasks in Sputnik are represented as pure data (function name and argument data). The data representation of tasks provides the flexibility to the client program to decide at runtime which function evaluations will be parallelized. Hadoop uses the map-reduce paradigm to parallelize computations usually on very large data collections. The data for the computation are distributed among the computers of a Hadoop cluster. A computational task to be solved by Hadoop requires a Java class implementing the map step and a Java class implementing the reduce step. Similarly to JPPF, different computations each need their own class, but for certain problems it might be possible to reuse existing map or reduce classes. Also the coding and setup effort to parallelize a sequential algorithm is quite different for the different paradigms (see). When compared with JPPF, Sputnik needs no additional task classes whereas Hadoop needs aFor 10 independent runs, the following properties of the best individuals are reported: accuracies for 1-NN classifier with and without gene selection (using identical folds) as well as the selected number (mean 6 SD) and percentage of features used. degree of required modifications. Comparison of Sputnik, JPPF and Hadoop: For each framework, the necessary steps to setup the server and the workers are shown. The gears mark steps where the user is supported with automatic assistance by the tools of the framework. The padlock symbol marks steps that need administrator privileges. The second part of the graphic summarizes the necessary modifications to parallelize a computational intensive sequential algorithm with each framework. The background of the graphic visualizes the needed degree of required modifications to parallelize an existing sequential algorithm substantial change in the code of the algorithm and also is more suited for processing distributed data. In the experimental evaluation we therefore focused on Sputnik and JPPF.
Setup and runtime comparisonThe required setup steps for the three frameworks are summarized in(upper partrequired infrastructure). The permanent Hadoop setup must completely be done by an administrator. JPPF can be set up either permanently or ad hoc. All these steps have to be performed manually. Sputnik is intended for ad hoc setup and provides tool support for every step. For Sputnik, configuration files and SSL keystores are generated from the graphical user interface which also offers automatic deployment and automatic startup on the server and on the workers. Sputnik and JPPF do not need administrator privileges, a user account is sufficient. The basic principles of the scheduling strategies of Sputnik and JPPF are quite different. Sputnik uses a continuous streaming of tasks, whereas JPPF distributes tasks in batches. Sputnik schedules the tasks of a computation job such that the CPU utilization of the workers is maximized. The scheduling strategy of Sputnik tries to have 2n task at a worker that performs n computations in parallel. For each finished task a new pending task is sent to the worker as soon as possible. All JPPF scheduling strategies send batches of tasks (bundles in JPPF terminology) to each worker. Task results are only sent back from the workers when all tasks of the batch are completed. This can cause situations where only one processor core of the worker is working and n  1 cores are idling. The impact of these idle times increases when tasks have quite different runtimes. We performed experiments with our parallel feature selection algorithm to compare Sputnik and JPPF. The runtime of the tasks of the feature selection algorithm does not vary much. For the experiment we modified the calculation runtimes of the tasks to create a scenario with two types of tasks. The first task type performs its regular calculation in runtime t. The second task type delays the regular calculation by an additional duration D. In the experiment every fifth task is of the second type using t  D total runtime on average. The experiments use the same configuration as in the previous experiment. The average task runtime is t % 600 ms. Using D  200 ms the feature selection algorithm using JPPF needs 14% more runtime compared with the algorithm using Sputnik. For D  400 ms this increases to 23%. Even when D  0 ms is used the JPPF scenario needs 8% more runtime than the Sputnik scenario.
ConclusionWe devised and implemented a lightweight tool for code parallelization in shared and distributed memory. The tool support of Sputnik enables ad hoc on demand parallelization with a user interface for ease of configuration. The task as data paradigm of Sputnik allows decisions on parallelization at runtime. In our simulation experiments, we could successfully utilize the framework for biomarker selection. Furthermore, Sputnik also compares well both in setup and runtime to other frameworks. This supports the feasibility of our approach for applications in bioinformatics and systems biology that are demanding a high computational power and ease of setup.
FundingThe research leading to these results has received funding from the European Community's Seventh Framework Programme
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
G.V lkel et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
