We present a new method to incrementally construct the FM-index for both short and long sequence reads, up to the size of a genome. It is the first algorithm that can build the index while implicitly sorting the sequences in the reverse (complement) lexicographical order without a separate sorting step. The implementation is among the fastest for indexing short reads and the only one that practically works for reads of averaged kilobases in length. Availability and implementation: https://github.com/
INTRODUCTIONFM-index plays an important role in DNA sequence alignment, de novo assembly () and compression (). Fast and lightweight construction of FMindex for a large dataset is the key to these applications. In this context, a few algorithms () have been developed that substantially outperform earlier algorithms. However, they are only efficient for short reads. A fast and practical algorithm for long sequence reads is still lacking. This work aims to fill this gap.
METHODSLet S=fA; C; G; T; Ng be the alphabet of DNA with a lexicographical order A5C5G5T5N. Each element in S is called a symbol and a sequence of symbols called a string over S. Given a string P, jPj is its length and Pi the symbol at position i. A sentinel $ is smaller than all the other symbols. For simplicity, we let P1=PjPj=$. We also introduce ~ P as the reverse of P and P as the reverse complement of P. Given a list of strings over S, P i  0 i5m , let T = P 0 $ 0. .. P m  1 $ m  1 with $ 0 5    5$ m1 5A5C5G5T5N. The suffix array of T is an integer array S such that S(i), 0 i5jTj, is the starting position of the i-th smallest suffix in the collection T. The Burrows-Wheeler Transform, or BWT, of T can be computed as Bi=TSi  1. For the description of the algorithm, we segment B into B=B $ B A B C B G B T B N , where B a i=Bi +Ca with Ca=jfj : Tj5agj being the array of accumulative counts. By the definition of suffix array and BWT, B a consists of all the symbols with their next symbol in T being a. The above defines BWT for an ordered list of strings. We next seek to define BWT for an unordered set of strings C by imposing an arbitrary sorting order on C. We say list P i  i is in the reverse lexicographical order or RLO, if ~ P i ~ P j for any i5j; say it is in the reverse-complement lexicographical order or RCLO, if P i P j for any i5j. The RLO-BWT of C, denoted by B RLO C, is constructed by sorting strings in C in RLO and then applying the procedure in the previous paragraph on the sorted list. RCLO-BWT B RCLO C can be constructed in a similar way.
RESULTS AND DISCUSSIONWe implemented the algorithm in ropeBWT2 and evaluated its performance together with BEETL (http://bit.ly/beetlGH), the original on-disk implementation of BCR and BCRext, ropeBWT-BCR (https://github.com/lh3/ropebwt), an inmemory reimplementation of BCR by us, and NVBio (http:// bit.ly/nvbioio), a GPU-based algorithm inspired by CX1 ().shows that for $100 bp reads, ropeBWT2 has comparable performance to others. For the $875 bp Venter dataset, NVBio aborted due to insufficient memory under various settings. We did not apply BCR because it is not designed for long reads of unequal lengths. Only ropeBWT2 works with this data set and the even longer moleculo reads.
In B RCLO fP i g i [ fP j g j , the k-th smallest sequence is the reverse complement of the k-th sequence in the FM-index. This property removes the necessity of keeping an extra array to link the rank and the position of a sequence in the FM-index, and thus helps to reduce the memory of some FM-indexbased algorithms (Simpson and Durbin, 2012). For short reads, RLO/RCLO-BWT is also more compressible (Cox et al., 2012). As a preparation, we further define two string operations: rankc; k; B and insertc; k; B, where rankc; k; B=jfi5k : Bi=cgj gives the number of symbols c before the position k in B, and insertc; k; B inserts symbol c after k symbols in B with all the symbols after position k shifted to make room for c. We implemented the two operations by representing each B c in a B+-tree in memory, where a leaf keeps a run-length encoded string and an internal node keeps the count of each symbol in the leaves descended from the node. Algorithm 1 appends a string to an existing index by inserting each of its symbol from the end of P. It was first described by Chan et al. (2004). Algorithm 2 constructs RLO/RCLO-BWT in a similar manner to Algorithm 1 except that it inserts Pi to l; u, the suffix array interval of P's suffix starting at i + 1, and that BWT symbols in this interval are already sorted. This process implicitly applies a radix sort from the end of P, sorting it into the existing strings in the BWT in RLO/RCLO. Note that if we change line 1 to " l u jfi : Bi=$gj " , Algorithm 2 will be turned into Algorithm 1. Recall that the BCR algorithm (Bauer et al., 2013) is, to some extent, the multi-string version of Algorithm 1. Following similar reasoning, we can extend Algorithm 2 so as to insert multiple strings at the same time, which gives Algorithm 3. We use an array A(j) to keep the state of the j-th sequence after inserting its d-long suffix. At line 2, Aj:c is the previously inserted symbol and Aj:l; Aj :u is the interval to which the new symbol is inserted. In implementation, we may speed up the sorting mode by inserting multiple symbols at line 3. When B is represented by a balanced tree structure, the time complexity of all three algorithms is On log n, where n is the total number of symbols in the input. However, we will see later that for short strings, Algorithm 3 is substantially faster than the first two algorithms, due to the locality of memory accesses, the possibility of cached B+-tree update and the parallelization of the 'for' loop at line 1. These techniques are more effective for a larger batch of shorter strings. Disregarding RLO/RCLO, Algorithm 3 is similar to BCR except that BCR keeps B in monolithic arrays. As a result, the time complexity of BCR is O(nl), where l is the maximum length of reads, not scaling well to l.
The Author 2014. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Fast construction of FM-index at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
