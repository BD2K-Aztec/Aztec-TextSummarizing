Motivation: Bacterial and viral genomes are often affected by horizontal gene transfer observable as abrupt switching in local homology. In addition to the resulting mosaic genome structure, they frequently contain regions not found in close relatives, which may play a role in virulence mechanisms. Due to this connection to medical microbiology, there are numerous methods available to detect horizontal gene transfer. However, these are usually aimed at individual genes and viral genomes rather than the much larger bacterial genomes. Here, we propose an efficient alignment-free approach to describe the mosaic structure of viral and bacterial genomes, including their unique regions. Results: Our method is based on the lengths of exact matches between pairs of sequences. Long matches indicate close homology, short matches more distant homology or none at all. These exact match lengths can be looked up efficiently using an enhanced suffix array. Our program implementing this approach, alfy (ALignment-Free local homologY), efficiently and accurately detects the recombination break points in simulated DNA sequences and among recombinant HIV-1 strains. We also apply alfy to Escherichia coli genomes where we detect new evidence for the hypothesis that strains pathogenic in poultry can infect humans.
INTRODUCTIONIn contrast to most eukaryotes, viruses and bacteria reproduce asexually. Nevertheless, their genomes are littered with evidence of occasional and localized recombination, usually referred to as 'horizontal gene transfer'. Horizontal gene transfer is observable as an abrupt change in homology along an alignment of two or more sequences. The importance of horizontal gene transfer for the evolution of immune evasion and antibiotic resistance of pathogenic * To whom correspondence should be addressed. microbes has been known for decades (). Correspondingly, there has been and still is a lot of interest in devising computer programs to automate the detection of mosaic gene or genome structure (). Most of the current methods for annotating mosaic genome structure are based on alignments and target viral genomes or individual bacterial genes (). These methods are highly accurate but tend to be too slow for the analysis of whole bacterial genomes. Recently,expanded their original Monte Carlo Markov Chain method for inferring recombination rates () by also localizing the recombination events in alignments of whole bacterial genomes. However, even given such an alignment, the computational burden of their, again, highly accurate coalescent-based method is considerable. If speed is of concern, dramatic improvements are possible by simplifying or eliminating altogether any explicit model under which inference is made, and in addition by not basing the analysis on a full multiple sequence alignment.provide a web-based genotyping tool for viral genomes hosted by the NCBI. Their algorithm essentially consists of sliding a window across the query sequence and blasting the windows against the set of subject sequences to determine the closest homologs across the query. An even more radical departure from model-and alignmentbased treatment of mosaic genome structure is the alignment-free method for HIV typing proposed by. Alignmentfree methods of sequence comparison tend to be very fast, albeit less accurate than alignment-based sequence comparison (). Best known among the alignmentfree approaches are those based on k-word composition, which is also whathave used. Here all substrings of length k are counted in the two sequences compared and a distance between the vectors of word counts is defined. Unfortunately, it is difficult to convert distances between word count vectors to true evolutionary distances. We have recently developed two methods that start from the lengths of exact matches between pairs of sequences and convert these to substitutions per site (). The advantage of this approach is that exact match lengths can be looked up efficiently using suffix trees implemented as their more recent abstractions known as enhanced suffix arrays () and compressed suffix arrays (). In this article, we use exact match lengths between a query and a potentially large set of subject sequences to solve a specialized,Page: 1467 14661472
Sequence similaritybut frequently occurring problem in sequence analysis: at each position in the query sequence, we wish to determine which subject sequenceif anyis most closely related to the query. This closest neighbors problem is common in microbiology and correspondingly we apply our method to the genomes of HIV and Escherichia coli. The most prevalent form of HIV is the M group of HIV-1, which is divided into eight subtypes (A, B, C, D, F, G, H, J) based on the sequence of their 9 and 10 kb genomes. However, recombination between these subtypes in multiply infected individuals leads to the emergence of new forms of the virus. Accurate detection of the origin of individual HIV-1 genome segments has clinical implications and the development of software to automate this procedure has received corresponding attention (). Closely related strains of bacteria form 'pan-genomes' consisting of a common core and a variable part that is horizontally mobile (). One example for such a group is E.coli, which has a genome size ranging from 4.6 to 5.7 MB. This taxon comprises commensal strains as well as strains that are pathogenic in humans and homeothermic animals. An important question concerning E.coli is to what extend strains that are pathogens of live stock might cause infections in humans (). In the following sections, we first describe our alignment-free method for determining local homology. We test this method through simulations and then use it to classify HIV-1 recombinant strains and to compare E.coli genomes. When comparing the E.coli genomes, we not only look for switches in local homology indicative of horizontal gene transfer, but also for regions with no close homolog among the subject sequences. Investigation of these 'private' genomic regions leads us to the detection of new evidence for the long-held suspicion that animal E.coli pathogens can also infect humans ().
METHODSGiven a query DNA sequence, Q, and a set of subject DNA sequences, S ={S 1 ,...,S n }, we wish to determine the subject sequences that Q is most closely related to at every position p in Q. For instance, inQ=TA matches S 3and Qmatches S 2. We therefore say that Qis most closely related to S 3 and Qis most closely related to S 2. In this section, we describe a simplified version of our algorithm to locally annotate Q. The algorithm we actually implemented is detailed in Algorithm S1 of the Supplementary Material. When comparing Q to a specific subject, S i , we denote by h i,p the length of the shortest prefix of the query suffix Qthat starts at position p and is absent from S i. We follow our previous convention of calling these shortest absent prefixes shustrings for SHortest Unique subSTRINGS (). The length of the longest shustring starting at Qwhen compared to all subject sequences is H p = max 1in h i,p. Notice that H p is bounded by the query length: H p |Q|p+1. For our example sequences inh 1,1 =|T|=1; h 2,1 =|T|=1; h 3,1 =|TAG|=3; and H 1 = max{1,1,3}=3. The set of subject sequences that induce the longest shustring at Qis. For our example, sequences inS 1 ={S 3 }. To determine which segment of Q is most closely related to which subject sequence, we compute all values of H p and S p. This is done by constructing a generalized suffix tree consisting of the query and all subject sequences (). We assume that at every branch node v i of this tree we can look up the length of the concatenated labels along the path from the root to v i , that is, the string depth of v i. For example, the string depth of v 3 inis 2. This generalized suffix tree is traversed once, and whenever a leaf node w = (Q,p) is encountered, H p is computed as one plus the string depth ofthe lowest common ancestor node of w and any leaf node referring to a subject sequence (). Moreover, S p is the set of subject sequences in the subtree rooted on that lowest common ancestor. Given the table of H p and S p values in, we next cover Q with contiguous intervals of closest neighbors. Such closest neighbors intervals have the form (,S ,h), where lb and rb are the left and right borders, S = S lb , and h = H lb. The intervals are constructed by traversing the array H 1 ,H 2 ,...,H |Q| and whenever H p > H p1 , we do two things:
A(1) close the current closest neighbors interval by setting rb  p1 and S  S lb ;(2) open a new closest neighbors interval with lb  p and h  H p .For our example in, this procedure results in the detection of the two closest neighbors intervals (,{S 3 },3) and (,{S 2 },3). Finally, the closest neighbors intervals are summarized into larger regions of similarity. This is done using a sliding window approach: for each subject sequence referred to by the closest neighbors intervals within a window, the shustring lengths are summed and the one or more subject sequences with the greatest sum are designated the closest neighbors of Q at the given position.derived the null distribution of shustring lengths as a function of the number of mismatches between pairs of sequences. In the limit of 0.75 mismatches per site this corresponds to the distribution of shustring lengths expected by chance alone. We can therefore also identify query regions without close homologs among the subject set. Such regions are characterized as having an average shustring length that is less than the maximal shustring length expected by chance alone.
ImplementationThe procedure for finding closest neighbors intervals can easily be generalized to more than one query sequence and this is the version that we have implemented. However, when dealing with large datasets the auxiliary table of H p and S p values would impose a substantial memory overhead. So instead of explicitly constructing this table, we directly build the set of closest
M.Domazet-Loo and B.Hauboldneighbors intervals during suffix tree traversal. This yields a much more memory efficient implementation, and by keeping the closest neighbors as an ordered binary tree the concomitant cost in runtime is minimal (Algorithm S1). The final program is called alfy for ALignment-Free local homologY and is written in standard C. The suffix tree was implemented as an enhanced suffix array () using the suffix array library distributed by Manzini and Ferragina (2002).
Runtime analysisalfy determines closest homologs in three phases: it begins by constructing an enhanced suffix array of all m query and n subject sequences. This array is then traversed to compute the list of closest neighbors intervals. Finally, the list of closest neighbors intervals is subjected to sliding window analysis to produce the desired annotation of the query. Suffix array construction for m query and n subject sequences of length L ideally takes time O((m+n)L). Insertion of a single interval node in an interval tree takes O(logL); the construction of one tree per query sequence thus takes a total of O(mLlogL) time. Traversal of m interval trees takes time O(mL). Therefore, the whole procedure takes time O((m+n)L +mLlogL +mL). Notice that if a single query is compared to a large number of subjects, that is, m = 1 and n logL, the run time approaches O(nL).
Phylogeny reconstructionPairwise substitution rates were estimated from whole E.coli genomes using the program kr (Domazet). The substitution rates were clustered using the neighbor joining algorithm implemented in the program neighbor, which is part of the software package PHYLIP (). Trees were midpoint-rooted using retree and drawn using drawgram, which are also part of PHYLIP.
RESULTSIn the following sections, we first apply alfy to simulated and then to empirical data to explore the efficiency and accuracy of the program.
Runtime and memory consumptionWe simulated sequence samples consisting of one query and 10 or 100 subject sequences with 0.13 or 0.006 segregating sites/nucleotide, respectively, between the query and its closest neighbor using the program Dawg ().shows the runtime on a single AMD Opteron 2.3 GHz processor as a function of sequence length. The runtime grows approximately linearly in the sample size and the sequence length, as expected from the analysis in Section 2.2. Similarly, the memory requirement is linear in the amount of sequence data, as expected for a suffix array-based procedure ().
Accuracy of homology detectionTo test the accuracy of local homology detection by alfy, we simulated samples of three pure subject sequences and one recombinant query again using Dawg (). As shown in, this was done by generating sequences with distance 2s between Q and S 1 or between Q and S 2. Five such segments were generated, each segment evolving either along genealogy G 1 or along genealogy G 2. Detection accuracy was scored as the fraction of nucleotides correctly assigned to S 1 or S 2. For segments of length 2 kb, the detection accuracy increased with distance up to s  0.05, while it A Bdecreased significantly for distances greater than s  0.1 (). Short segments were generally more difficult to locate correctly than long segments and as a resultwith fragment length 2 kb displays a lower overall accuracy thanwhile for intermediate s the detection accuracy is less sensitive to window length.
Application to genome dataWe applied our homology detection method to viral and bacterial genomes in order to solve two common tasks: genotyping of circulating recombinant forms of HIV-1, and detection of horizontal gene transfer and unique segments among E.coli genomes.
Detection of circulating recombinant forms of HIV-1 Westarted the analysis by comparing alfy to two fast HIV-1-subtyping tools: the NCBI genotyping tool (), and the k-word-based clustering method by. These programs and alfy were applied to two published HIV-1 datasets using the approach outlined by, who considered the top two closest sequences as valid annotations. The first dataset consisted of 91 circulating recombinant forms (CRFs, query) compared to 42 pure subtype strains (subject) (). The accuracy of alfy was 93.4%, whilereported the accuracy of the NCBI tool as 73.4%, and that of their own tool as 87.3%. The window size for alfy was 300, the same as that used in the NCBI tool.The second dataset consisted of a query set of 266 HIV-1 CRFs compared to a subject set consisting of 42 pure subtype strains and 65 recombinant strains of known subtype (). Here, alfy subtyped 263 strains correctly, the NCBI tool 264 andannotated 242 strains correctly. In addition to these two fast typing methods, we compared alfy to SCUEAL. This is a phylogeny-based HIV-1 subtyping software that relies on a genetic algorithm to pick the most likely recombinant pattern given a query sequence and an alignment of subject sequences (). Its authors report that it detects < 1% false positives on simulated data and we used it to type a single HIV-1 strain (A_DQ083238) against our standard 42 pure strains. This query was originally annotated as a pure A strain, but we have previously noted that it is an A/C recombinant (Domazet). Correspondingly, SCUEAL and alfy report the transfer of two large C fragments amounting to 24.3% (SCUEAL) and 25.1% (alfy) of the genome (). The location of the two C-segments determined by SCUEAL (, top) is similar to the annotation by alfy (, bottom). We also used the comparison between strain A_QD083238 and the 42 reference strains to benchmark the resource requirements of alfy, the NCBI tool, thetool and SCUEAL.shows that alfy took 0.4 s for this analysis. Unfortunately, the timing of the NCBI tool is not straight forward since this is only available as a web service. To get a rough estimate, we repeatedly ran BLAST with a 300 bp query taken from the query strain against the 42 reference strains. 97 such calls would cover the query in 100 bp steps and this took 1.4 s, which is presumably an upper bound on the true runtime. The Java program bytook 3.5 min, while SCUEAL took 6.9 h. As to memory requirements, BLAST used much less memory than alfy (2.2 KB versus 9 MB;). This is expected for a method that indexes the short query (BLAST) as opposed to indexing the long subject (alfy).required the most memory (2.2 GB), while SCUEAL still used over 17 times more memory than alfy (160 MB).
Investigating genomes of pathogenic E.coliTo test the hypothesis that E.coli strains pathogenic in birds might also infect humans,sequenced a strain of avian pathogenic E.coli (APEC_O1) and compared it to the genomes of four fully sequenced E.coli strains, three of which cause urinary tract infection in humans (). Consistent with their hypothesis, they found that APEC_O1 is very similar to the human uropathogenic strain UTI89.shows the comparison between APEC_O1 as query and the remaining four E.coli strains as subject using alfy with a window Page: 1470 14661472shows the phylogeny of these strains with the five taxa investigated by) () marked in bold. The analysis of the 151.8 MB that make up these genomes plus APEC_01 took alfy 744 s and occupied 5.8 GB of memory. The private fraction of the genome shrank from 3.0% to 0.7% andshows the 10 unique regions of length 1000 bp or greater that we identified. The longest private region was located between 2 190 501 and 2 196 650. We used megablast to comparebased on distances calculated using kr (Domazet). The three uropathogenic strains are italicized. these 6150 bp against the full nucleotide database (nr) and found a single hit that spanned the entire query. This hit comprised part of the gene cluster that specifies the O1-antigen of E.coli serogroup O1. It is filed under Accession GU299791 and was recently sequenced from E.coli strain G1632 that was isolated from a patient with urinary tract infection (). An optimal local alignment between all 10 301 bp of the O1-antigen gene cluster and the genome of APEC_O1 resulted in an alignment comprising 10 300 bp with 11 mismatches and 3 single nucleotide indels. This high similarity between the O1-antigen region of a clinical isolate and an avian pathogenic E.coli is strong additional evidence that avian pathogenic E.coli can cause urinary tract infections in humans.
M.Domazet-Loo and B.Haubold
DISCUSSIONThe 'conversion of data to knowledge' is perhaps the greatest challenge in the field of genomics (). This conversion depends on the availability of computational tools that match the
The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
