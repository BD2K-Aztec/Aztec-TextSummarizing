Motivation: Single Molecule Real-Time (SMRT) sequencing has been widely applied in cutting-edge genomic studies. However, it is still an expensive task to align the noisy long SMRT reads to reference genome by state-of-the-art aligners, which is becoming a bottleneck in applications with SMRT sequencing. Novel approach is on demand for improving the efficiency and effectiveness of SMRT read alignment. Results: We propose Regional Hashing-based Alignment Tool (rHAT), a seed-and-extension-based read alignment approach specifically designed for noisy long reads. rHAT indexes reference genome by regional hash table (RHT), a hash table-based index which describes the short tokens within local windows of reference genome. In the seeding phase, rHAT utilizes RHT for efficiently calculating the occurrences of short token matches between partial read and local genomic windows to find highly possible candidate sites. In the extension phase, a sparse dynamic programming-based heuristic approach is used for reducing the cost of aligning read to the candidate sites. By benchmarking on the real and simulated datasets from various prokaryote and eukaryote genomes, we demonstrated that rHAT can effectively align SMRT reads with outstanding throughput. Availability and implementation: rHAT is implemented in Cþþ; the source code is available at https://github.com/HIT-Bioinformatics/rHAT.
IntroductionSingle Molecule Real-Time (SMRT) sequencing has been widely applied since its emergence in 2009 (). With the superior read length and less systematic bias respect to next generation sequencing (NGS) (), SMRT sequencing performed well in various cutting-edge genomics studies (). However, its higher sequencing error rate () affects various critical steps of SMRT data analysis. One of them is read alignment. Read alignment is to recover the likely genomic origins of reads by aligning them against reference genome. As one of the most fundamental and computing-intensive steps in genome re-sequencing studies (), efficient read alignment is on widely demand. However, due to the higher error rate, the speed of SMRT read alignment is not as fast as that of NGS reads (), which has become a bottleneck of SMRT data application. Many efforts have been made to read alignment (), however, most of them are designed for NGS reads which are less adaptive to noisy SMRT reads. Previous studies () also indicated that long sequence alignment approaches () can sensitively align SMRT reads, but at the expense of efficiency.Three state-of-the-art SMRT read aligners are BWA-SW (), BLASR () and BWA-MEM (), with no exception on the basis of seedand-extension. Mainly, they match partial reads ('seeds') to reference genome at first, and extend the matches ('hits') to compose full alignments. The major difference is in the way of seeding. BWA-SW aligns substrings of read to reference genome by suffix trie traversing, to find approximate matches with few positions as hits. BLASR and BWA-MEM use exact matches of short tokens between read and reference genome. BLASR formulated a probability model to depict the relationship between the error rate and the number of seeds. This model finds all the short token matches longer than a pre-defined threshold as hits. BWA-MEM finds all the maximal exact matches (MEMs) as hits, and also refers to the model of BLASR to tune its parameters for SMRT reads. Efforts have also been made to improve the efficiency of extension, i.e. BWA-SW and BWA-MEM utilized banded Smith-Waterman algorithm, and BLASR used a sparse dynamic programming (SDP)-based heuristic (). One of the major bottlenecks of the state-of-the-art aligners is the efficiency of seeding. To be robust to the high error rate, all the three aligners densely employed the substrings starting from all the offsets of the read as seeds. However, for BLASR and BWA-MEM, due to the repetitiveness of genomes, there could be a great amount of hits generated by the dense short seeds along the whole read, which is expensive to merge and prioritize. For BWA-SW, the cost could be also huge to align many substrings of the noisy long read to reference genome. Moreover, as all the three aligners used Burrows-Wheeler Transformation (BWT) () for indexing reference genome, there is additional cost to perform LF-mapping () to locate the precise genomic positions of the hits. Thus, for BWA-MEM and BLASR, the overhead of retrieving all the hits of short seeds is also nonneglectable. Herein, we propose an efficient noisy long read alignment approach, Regional Hashing-based Alignment Tool (rHAT), for SMRT read alignment. rHAT aligns SMRT reads with specifically designed seed-and-extension strategy. In the seeding phase, rHAT selects a substring of the read as 'seeding region', and partitions reference genome into a series of windows, to find the windows having most k-mer matches with the seeding region as candidate sites for extension. This operation is implemented with small overhead through a hash table-based index, Regional Hash Table (RHT). In the extension phase, a SDP-based heuristic is designed for efficiently aligning the read to the candidate sites. There are aligners () based on q-gram filter () which also utilizes the occurrences of short tokens matches within local genomic regions for seeding. However, despite of various implementations, they were mainly designed for shorter reads (from several tens to hundreds of bp) with lower error rates (around several percent), i.e. the NGS reads. This design may be not practical to SMRT read alignment. For rHAT, the characteristics of SMRT reads are fully considered in the design of genome indexing and read alignment modules for improving the performance. We benchmarked rHAT on real and simulated SMRT datasets from various prokaryote and eukaryote genomes. The experimental results demonstrated that rHAT can effectively align SMRT reads with a considerable improvement on throughput. Moreover, it has superior ability in terms of end-to-end alignment which can produce consecutive alignments for most of the reads.
Methods
Overview of rHATrHAT organizes the reference genome by a series of windows, and builds RHT for indexing the k-mers within each of the windows in advance. In the seeding phase, a long substring of the read is employed as the 'seeding region'. All the matches of the k-mers within the seeding region are retrieved through RHT. These matches are subsequently used for calculating the occurrences of k-mer matches in various windows, and windows with most k-mer matches are employed as candidate sites for extension. This strategy is motivated by previous study (), which suggested that, the occurrence of short token matches within local regions can be used as robust signal for seeding. It also refers to the study of BLASR () which demonstrated that, for a long query string (e.g. >1000 bp) with moderate error rate, it has a high probability that many short token matches occur at its actual site. Considering these two issues and the superior length of SMRT reads, a long enough substring could be informative enough for seeding while it can directly reduce the number of short tokens to be handled. Moreover, rHAT utilizes the matches of short k-mers instead of variable length seeds, as k-mers can be retrieved more efficiently through hash-table-based index. In the extension phase, rHAT utilizes a SDP-based heuristic from local short token matches for further reducing the cost. Moreover, a constraint on the distance between neighboring matches is introduced into this heuristic for preventing ill-defined alignments. Furthermore, if it fails in finding suitable end-to-end alignment, rHAT can also perform split alignment for the read, which is useful for handling structure variations as well as the potential errors in the seeding phase. rHAT mainly consists of four modules, i.e. (i) index construction; (ii) seed generation and prioritization; (iii) extension at candidate sites; (iv) spilt alignment for chimeric reads. Some details are as following.
Index constructionThe reference genome is partitioned into a series of windows for describing the k-mers within the local genomic regions. The windows are L bp long, each overlapping with its neighbors by L=2 bp (). The L=2 bp overlapping between neighboring windows is necessary, since it guarantees that a L=2 bp long substring of the read can be fully accommodated by a specific window for seeding (see more details in Section 2.3). Otherwise, all the windows could at most overlap with a part of the substring, which may affect the calculation of the occurrences of k-mer matches. L is selected as 2048 bp for guaranteeing high number of k-mer matches. For each of the k-mers of reference genome, rHAT records all the windows it occurred to build RHT index. RHT mainly consists of two main data structures (1. 'PointerList' with 4 k cells directly records the pointers to the corresponding lists of windows for all the possible k-mers. The parameter k is typically configured as 1115 bp, considering the error rate of SMRT reads. 2. 'WindowList' records all the window lists. For each k-mer, all the windows it occurred are pre-sorted and recorded in ascending order in its own list, which occupies a set of continuous cells of WindowList.With the two data structures, an ordered list of all the hits of a certain k-mer can be directly retrieved with small overhead. It is also worthnoting that, due to the overlapping between neighboring windows, a certain position one k-mer occurs can be involved in two windows. In practice, RHT only records the downstream one, and recovers the upstream one on-the-fly.
Seed generation and prioritizationrHAT finds the windows with most k-mer matches in four steps as following (1. rHAT extracts the L=2 bp substring centered at the read as seeding region. For reads shorter than L=2 bp, the whole read will be employed. 2. rHAT retrieves the window lists of the k-mers within the seeding region through RHT.1. A lookup table is built for indexing all the l-mers of the read (l  11 bp in default), and rHAT scans S cw from upstream to downstream to capture all the ! l bp matches between S cw and the read through the lookup table. Each of the matches can be denoted as a triplet (VR i , VS i , VL i ), where VR i and VS i are respectively the offsets of V i on the read and S cw , and VL i is the length of the match. 2. rHAT builds a direct acyclic graph (DAG) to compose the skeleton of the alignment (Supplementary). The vertices of the DAG consist of all the recorded matches, V i , plus two auxiliary vertices, V start (0,0,0) and V end L R  1; L S  1; 0, where L R and L S are respectively the lengths of the read and S cw. The two auxiliary vertices represent the start and the end of the alignment. The edges of the DAG consist of the links between the pairs of vertices V i ! V j which meets the following conditions, VR i  V L i VR j VR i  VL i  T wait and VS i  VL i VS j , where T wait is a constraint parameter for modeling the error rate of the read. 3. rHAT finds the optimal path connecting V start and V end which maximizes the total number of matched bases as the skeleton of alignment. This is implemented by scoring the vertices with the following recurrence equation.where V j denotes a vertex except V start , and V i is a precursor of V j. 4. The skeleton partitions the read and S cw into a series of paired segments (Supplementary). rHAT separately aligns eachThe parameter T wait describes the maximum allowed distance on the read between two vertices connected by an edge. This setting is motivated by that, given a certain error rate, the waiting length, i.e. the distance between two error-free tokens on the read can be modeled by geometric distribution (). In rHAT, this property is utilized for considering the error rate of the read and preventing ill-defined alignment. If the read is aligned to a false positive candidate site, or there is large variation event (e.g. structure variation) within the read, there could be much fewer local matches for some parts of the read. Under this circumstance, the threshold T wait may trigger a failure for building the skeleton due to that some vertices are lack of precursors. The failed candidate will be discarded to avoid potential errors. For SMRT reads, we assume the error rate is 15%, and set T wait with large enough values according to the minimum length of local matches. With the setting of T wait , it has very low probability (about 10-8 ) that the distance between two neighboring true positive !l bp matches can be over T wait. In practice, to prevent failures caused by extraordinary sequencing errors and improve the consecutiveness of the alignment, for a read which all its candidates failed in end-to-end alignment, rHAT can also dynamically double the threshold for composing more sensitive alignment. However, such alignments would be assigned lower mapping qualities, as it could introduce more uncertainty.
Chimeric read alignmentrHAT treats a read failed in end-to-end alignment as chimeric read, and deals with it in a split alignment strategy. The read would be split into a series of non-overlapping segments at first. Each of the segments is L=2 bp long only except for the last one which could be at most L bp. rHAT treats each of the segments as an individual read, and separately finds candidate sites for them with the seeding strategy mentioned above. rHAT further chains the neighboring segments whose candidate sites are also consecutively placed in the reference genome. After the chaining, a set of merged segments with specific candidate sites is generated, and rHAT separately aligns each of them to the corresponding candidate sites with the SDPbased approach. This strategy can provide split alignments for the reads with large scale events, such as structure variations. Moreover, as the failure of the end-to-end alignment may be also caused by the false positive candidate sites, this strategy is helpful for correcting such errors as well, i.e. the re-seeding of the segments could re-align the segments to their actual sites.
ResultsSeven real and simulated SMRT datasets from various genomes (Supplementary) were used for benchmarking rHAT and three state-of-the-art aligners, BLASR (version 1.3.1), BWA-MEM (version 0.7.12) and BWA-SW (version 0.7.12). rHAT were run with a variety of configurations on the parameters; BLASR was run in its default setting with two kinds of indices, i.e. BWT and suffix array (SA), respectively; BWA-SW was run with parameters (b5 q2 r1 z20) referring to previous study (); and BWA-MEM was run with the SMRT optimized parameters (x pacbio). More details of the implementation of the benchmarking are in Supplementary Protocol.
Benchmarking on real dataTwo SMRT P5/C3 release datasets respectively from H. sapiens and D. melanogaster genomes were used for evaluating rHAT on real SMRT data. The reads were respectively aligned to the reference genomes of H. sapiens (build GRCh37/hg19) and D. melanogaster (build DM5). Mainly, three issues were observed from the results (and Supplementary). Firstly, rHAT can provide outstanding throughput (, b). With the default setting (l 11, w 1000, m 5, k 13), rHAT is several folds faster than other aligners, only except for BWA-MEM on the H. Sapiens dataset where rHAT still outperforms but they are comparable. With other settings (Supplementary), rHAT could be even faster with similar sensitivity. For example, it is much faster than BWA-MEM on the H. Sapiens dataset with (l 11, w 1000, m 5, k 15). This throughput is beneficial for improving the overall efficiency of SMRT data analysis. Secondly, rHAT can provide sensitive alignments (, b). For these two datasets, rHAT had the least unaligned reads, while the other three aligners are also comparable to that of rHAT, indicating that all of them can be tolerant to the sequencing errors (Supplementary). We further assessed the proportion of aligned bases as a metric of base-level sensitivity. This metric is also important to long read alignment, since it could still be lack of information for downstream analysis if reads are only partially aligned. rHAT aligned most bases, indicating that it also achieved the best base-level sensitivity. We further inspected the details of the alignments, and found that, more reads had a large proportion of bases being clipped by the other three aligners. However, rHAT aligned fewer reads with large clippings, which is the main reason of the higher base-level sensitivity of rHAT.Thirdly, rHAT can provide consecutive alignments (, d). Since structure variation is relatively rare in genome, most reads are SV-free and they should be consecutively aligned in essence. Moreover, as some of SV detection approaches use soft-clippings as signal (), if too many SV-free reads were split aligned, the downstream analysis could be also affected in practice. For assessing the consecutiveness of the alignments, we set four thresholds, i.e. p aln 1  80%, p aln 2  85%, p aln 3  90%, and p aln 4  95%, and investigated the proportions of the reads which have at least one alignment covering at least p aln i i  1; 2; 3; 4 of its bases. The result indicates that rHAT consecutively aligned more reads than those of the other three aligners. Moreover, it is worthnoting that BWA-SW generated consecutive alignments for only a small portion of reads.
Benchmarking on simulated dataFor further assessing the sensitivity, accuracy, throughput of rHAT, as well as its scalability to genomes in various sizes, we benchmarked rHAT with the simulated datasets from five various genomes, i.e. E. coli (the 536 strain), S. cerevisiae (build sacCer3), D. melanogaster (build DM3), A. thaliana (build TAIR10) and H. sapiens (build GRCh37/hg19). For each genome, a 1 x coverage dataset was generated by PBSim (Verison 1.0.3) (). The average read length was configured as 8000 bp for mimicking the P5/C3 or above release of SMRT sequencing, and 15% sequencing errors (12% insertions, 2% deletions and 1% substitutions) were introduced referring to previous study (). Mainly, the following four issues were observed from the results (and Supplementary). Firstly, similar to that of real data, rHAT significantly outperformed other aligners in speed for all the datasets, indicating its good efficiency as well as scalability to various sizes of reference genomes. Secondly, all the aligners generated sensitive alignments for almost all the reads, while rHAT marginally aligned more bases than the other three aligners. Thirdly, rHAT correctly aligned the reads. As it is important to simultaneously recover the correct positions and produce consecutive alignments for long reads, we considered a read is correctly aligned only if there is an alignment whose leftmost position is within 50 bp of the grand truth deducting the clipped parts, meanwhile, it can cover at least 80% of the bases of the read. With default setting, rHAT correctly aligned more reads than other competitors for the S. cerevisiae, A. thaliana and H.sapiens datasets. For the E. coli and D. melanogaster datasets, BWA-MEM was most accurate and rHAT was the best runner-up. Overall, rHAT achieved the best average correctness for the five datasets (99.15%). It is also worthnoting that BWA-SW cannot generate consecutive alignment for almost all the reads, so that its correctness is hard to assess by this metric. Fourthly, we investigated the proportion of bases covered by the position-correct alignments for further assessing the correctness of the alignments. Here, an alignment is considered as position-correct only if its leftmost position is within 50 bp of the grand truth deducting the clipped parts, regardless of the number of bases being covered. Although it does not consider the consecutiveness of the alignments, this metric describes the usability of the alignments without the bias against tools using clipping, and it can also fully consider all the split alignments for a given read. On this metric, the trend was similar. rHAT is still the winner on the S. cerevisiae, A. thaliana and H. Sapiens datasets, and achieves highest average on the five datasets (99.31%), while BWA-MEM is more accurate on the E. coli and D. melanogaster datasets. Moreover, BWA-SW also correctly aligned comparable proportions of bases to those of other aligners, indicating that the alignment of BWA-SW is also accurate, although it is usually not consecutive. Because of the wide application of human genome re-sequencing, we further inspected the reads of the H. sapiens dataset which were incorrectly aligned by rHAT, and found that the errors were mainly caused by three issues as following. i. False positive local matches could mislead the skeleton of the alignment. Due to the repetitiveness of local genomic sequence, some of the vertices of the SDP graph could be false positive matches. These matches may be mistakenly involved in the skeleton, since it could increase the total number of matched bases. The mistakenly involved local matches were usually the matches of the short tokens near the ends of the reads, since the SDP heuristic is more effective to prune the false positive matches of the short tokens within the inner part of the read by considering the total number of matched bases (Supplementary). Moreover, as the error usually happens near the ends of the read, the bases of the inner part of the read can still be appropriately aligned. We tuned the threshold on the length of local matches and found that longer local matches worked better for reducing such errors since they are less false positive. Considering both of the accuracy and the sensitivity of the alignment, we choose l  11 bp as default value. With this setting, 1776 reads (0.50%) of the simulated H. sapiens dataset were consecutively aligned to incorrect positions due to this issue. The results of other settings on this parameter are in Section 3.3. We also investigated its influence on real data, as this is the issue mostly affected the accuracy. The influence is difficult to assess due to lack of grand truth. However, in most cases, the false positive local matches could cause large indels around the beginning part of the alignment, which misleads the read to a wrong position. Thus, for each of the reads, we consider that it is potentially affected if there is a >50 bp indel in the primary alignment of its leftmost 300 bp (for a read aligned to the reverse strand, we checked the primary alignment of its rightmost 300 bp). 9861 reads (3.39%) of real H. sapiens dataset meet this condition. This ratio is higher than that of the simulated dataset. However, it is also worthnoting that this could be an overestimation of the influence, i.e. the actual number of the reads being affected should be lower, since such indels may'Aligned bases%' indicates the proportion of bases which are covered by at least one alignment of the corresponding reads. 'Correctly aligned reads%' indicates the proportion of reads which are correctly aligned. It is also worthnoting that the BWA-SW has a very low ratio of correctly aligned read mainly due to that it cannot align most of the reads consecutively. 'Correctly aligned bases%' indicates the proportion of bases which are covered by positioncorrect alignments. 'Running time' indicates the wall time of the alignment, measured in seconds. Each line also corresponds to a line of the 'H. sapienssim dataset' part of Supplementary. In this case, there is a 144 bp deletion near leftmost part of the alignments, which coincides with a recent study of SV on the same human sample (). BLASR also produced a similar alignment for this read. However, both of BWA-MEM and BWA-SW clipped the corresponding part of the read, which may be less informative to downstream SV analysis. Except the 9861 reads, there are 258 070 reads consecutively aligned by rHAT with more confidence that they were not influenced by the false positive matches. This number is still higher than those of the reads consecutively aligned by the other three aligners. ii. The repetitiveness of reference genome could also cause incorrect alignment. Since rHAT only aligns a given read to the top M candidates considering the tradeoff between the effectiveness and efficiency, the true site may be missed if the read is from a long repetitive region. In such cases, the read could be end-to-end aligned to incorrect positions if the whole read is not long enough to span the repetitive region. However, due to the large read length, only 100 reads (0.03%) of the simulated H. sapiens dataset were consecutively aligned to incorrect positions due to this issue. Moreover, when the read was aligned to long repetitive regions, rHAT could still find it hard to confidently align the read, and assign the read a lower mapping quality score. Furthermore, the results of the various settings on the number of candidates (see in Section 3.3) indicated that employing more candidates could reduce such errors, but at the expense of speed. iii. 804 reads (0.23%) of the simulated H. sapiens dataset were resulted as incorrectly aligned due to that rHAT failed in aligning them consecutively. Most of them were considered as chimeric read and handled by the split alignment strategy. Similar to those of consecutively aligned reads, some bases of these split aligned reads were also mistakenly handled, also mainly due to the two issues mentioned above. To measure the errors, we assessed the number of bases misaligned by split alignment. In total, 2 442 179 bases (0.09%) of simulated H. sapiens dataset were incorrectly aligned by split alignment.
Results of rHAT with various parameter settingsOther than the default setting, we also tuned five parameters most related to the performance of rHAT to investigate their effects, i.e. the minimum length of the local matches used for SDP (l), the maximum allowed window hits per k-mer (w), the number of candidates for extension (m), the size of the k-mer (k), and the number of threads (t). The minimum length of the local matches used for SDP (l) could influence the sensitivity and the correctness of the alignments (Supplementary Tables S4 and S5). Smaller local matches (e.g. l  8 bp) may have slightly better sensitivity, however, there could also be more false positive matches which may mislead the skeleton of the alignment and affect the accuracy. Thus, it is better to use higher threshold, e.g. l  11 bp, to simultaneously achieve good sensitivity and correctness. The maximum allowed window hits per k-mer (w) marginally affected the alignment (Supplementary Tables S4 and S6). With various configurations, similar sensitivities and correctness were obtained. Moreover, higher allowed number (e.g. w  2000) could be at the expense of throughput, mainly due to the increasing cost of merging window lists. The number of candidates for extension (m) also influences the throughput (Supplementary Tables S4 and S7) since it is expensive to align the noisy long read to many candidate sites. However, employing too few candidates, e.g. m  1 or 2, could speed up at the expense of correctness, since for some reads, the actual sites may not be prioritized as the top candidates due to the repetitiveness of the genome. Employing more candidates could enable rHAT to miss less actual sites and improve the sensitivity and correctness. Considering the tradeoff between effectiveness and efficiency, m  5 was used as the default setting. Moreover, it is also good to tune this parameter for various application scenarios. The k-mer size (k) also has effect on the throughput (Supplementary Tables S4 and S8), mainly due to that, smaller kmer size may have lower selectivity, i.e. the k-mers may hit more windows, which may also increase the cost of merging. Moreover, too small k-mer size may make many k-mers be ignored by rHAT due to that they hit too many windows, which exceeds the limitation on the number of windows per seed. An example is setting k  10 for the simulated H. sapiens dataset (Supplementary). In this case, rHAT ignored many k-mers as they hit more than 1000 windows, resulted in poor sensitivity and accuracy. However, too large k-mer size may also affect the sensitivity since there would be fewer k-mer matches due to the high error rate. Furthermore, k-mer size is also critical to the memory footprint, since it partially determines the size of RHT. There are 4 k and jGjk  1 cells for the PointerList and WindowList, respectively, where jGj is the size of the reference genome. Each of the cells occupies 32 bits to support genome upto 4 Tbp, as it needs log(2jGj L) bits to record a window ID. With this implementation, the RAM usage may be not practical for too large k-mer size. In practice, with some additional data structures, the peak memory footprints of rHAT were 13.70 (k  13) and 17.40 gigabytes (k  15) for the real H. Sapiens dataset, and 1.01 (k  13) and 4.15 (k  15) gigabytes for the real D. melanogaster dataset. This requirement can fit the configurations of most modern servers and workstations, meanwhile, k  1315 can also produce good results. Since parallelization is also very important to read alignment tasks, we also benchmarked the throughput of rHAT in multiple threads. The three relatively large simulated datasets, D. melanoganster, A. thaliana and H. sapiens, were employed. rHAT and the other three aligners were run on a server with 8 cores (Supplementary Protocol). Each of the aligners was run in 2, 4 and 8 threads (Supplementary). The results suggested that rHAT was also faster than the competitors with the same number of threads.
DiscussionWe propose rHAT, a novel seed-and-extension based approach for noisy long read alignment. Mainly, there are three key features of rHAT. (i) rHAT utilizes the occurrences of k-mer matches between a substring of the read and the reference genome for seeding, which directly reduces the short tokens that need to be handled without loss of effectiveness. (ii) With the help of RHT, the seeding can be efficiently implemented by multi-way merging. Furthermore, it also has a small overhead for retrieving k-mer matches. (iii) The SDPbased heuristic approach also reduces the cost of aligning the noisy long read to local genomic sites. Moreover, this heuristic approach also helps in preventing ill-defined alignment by the constraint on the distance between local matches. rHAT was benchmarked on real and simulated datasets from various genomes. The experimental results demonstrated that rHAT can be robust to the high error rate and provide effective alignments for SMRT reads. Comparing to other state-of-the-art aligners, there are two other major contributions made by rHAT. First, rHAT has an outstanding throughput which could be beneficial for breaking the bottleneck of the application on SMRT data. Second, rHAT can more consecutively align SMRT reads, which could also facilitate downstream analysis. A major drawback of rHAT is that the SDP-based heuristic could be affected by the false positive local matches. This issue could make rHAT misalign a proportion of bases and map the read to an incorrect position nearby the correct one. In downstream analysis, two methods could be useful for reducing this affection. One is to directly clip the alignments which have large indels within their beginning parts. The other one is to correct the potential errors by local re-alignment which is based on the multiple sequence alignment (MSA) of the reads aligned to the same local genomic region. Considering its sensitivity, correctness, consecutiveness and throughput, rHAT is overall an effective and efficient tool for SMRT read alignment. With the explosive increase of sequencing data, the improvement made by rHAT is profitable to various applications of SMRT sequencing. It could be a good choice to incorporate rHAT into the developing computational biology pipelines to leverage cutting-edge genomic studies. Future works will focus on two aspects. Firstly, the sequencing quality scores are still not taken into account. In the future, we will develop novel method to incorporate the quality scores into extension phase for further improving the quality of alignment. For example, the quality scores may be useful for more effectively recognizing false positive local matches which is beneficial for mitigating their affection on the building of skeleton. Secondly, the memory footprint of rHAT is relatively high, and the k-mer size is also limited by the data structures of RHT. Considering larger k-mer size could be also helpful for aligning noisy long reads (), we will also focus on developing novel succinct data structures which can support larger k-mer size for seeding and further reduce the memory footprint.
B.Liu et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
. rHAT performs a multi-way merging on the pre-sorted window lists to calculate the occurrences of k-mer matches of various windows. 4. rHAT subsequently performs a heapsort to prioritize the windows, and selects the top M windows as candidates. rHAT further extends the M candidate windows. For a candidate window whose offset is G cw , assuming the lengths of the regions flanking the seeding region on the read are respectively L ru (upstream) and L rd (downstream), the window is extended to a local region, G cw  L ru ; G cw  L rd  L, and the corresponding genomic sequence within the region (denoted as S cw ) is used for extension. As the extension for noisy long read could be expensive, the choice of the parameter M is critical to the throughput. Since the windows are long and sparsely placed along the reference genome, most of the local sequences within various windows are non-repetitive. Thus, for most reads, it is enough to use only a few top windows to cover its actual site, which is beneficial for reducing the cost of extension. Various settings on the M parameter were considered in the benchmarking for investigating its effect (shown in the Section 3). If the seeding region of the read comes from a repetitive region longer than L=2 bp, the actual site could be not involved in the top M candidates, and an error may occur. However, due to the large read length, it is also possible that the whole read spans the repeat and rHAT can find that the read is very divergent from the candidate site. In such cases, rHAT will fail in end-to-end alignment, and the chimeric read alignment strategy will be triggered to realign the read, which may rescue the errors. But if the read is from a very long repetitive region which it cannot span, it is still possible to be endto-end aligned to a false site. This problem is hard to solve in theory (Treangen and Salzberg, 2011), however, the benchmarks on the datasets from various genomes indicated that, for most reads analogous to the P5/C3 or above release of SMRT sequencing, their lengths are large enough to span the repeats in practice, and such errors are relatively rare. 2.4 Extension at candidate sites rHAT aligns the read to each of the local sequences with the SDPbased heuristic approach, and prioritizes the alignments by their scores. Given a certain S cw , it is mainly implemented in four steps as following.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
