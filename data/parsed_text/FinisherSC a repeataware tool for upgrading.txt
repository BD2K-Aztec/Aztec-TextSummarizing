We introduce FinisherSC, a repeat-aware and scalable tool for upgrading de novo assembly using long reads. Experiments with real data suggest that FinisherSC can provide longer and higher quality contigs than existing tools while maintaining high concordance. Availability and implementation: The tool and data are available and will be maintained at
IntroductionIn de novo assembly pipelines for long reads, reads are often trimmed or thrown away. Moreover, there is no evidence that stateof-the-art assembly pipelines are data-efficient. In this work, we ask whether state-of-the-art assembly pipelines for long reads have already used up all the available information from raw reads to construct assembly of the highest possible quality. To answer this question, we first collect output contigs from the HGAP () pipeline and the associated raw reads. Then, we pass them into our tool FinisherSC to see if higher quality assemblies can be consistently obtained after post-processing.
Methods
Usage and pipelineFinisherSC is designed to upgrade de novo assembly using long reads (e.g. PacBio reads). It is especially suitable for data consisting of a single long reads library. Input to FinisherSC are contigs (contigs.fasta) constructed by an assembler and all the raw reads with adaptors removed (raw_reads.fasta). Output of FinisherSC are upgraded contigs (improved3.fasta) which are expected to be of higher quality than its input (e.g. longer N50, longer longest contigs, fewer number of contigs, high percentage match with reference, high-genome fraction, etc). In, we show an example pipeline in which FinisherSC can fit. As shown in, FinisherSC can be readily incorporated into state-of-the-art assembly pipelines (e.g. PacBio HGAP).
Algorithm and featuresThe algorithm of FinisherSC is summarized in Algorithm 1. Detailed description of the algorithm is in the supplementary materials. We summarize the key features of FinisherSC as follows.@BULLET Repeat-aware: FinisherSC uses a repeat-aware rule to define overlap. It uses string graphs to capture overlap information and to handle repeats so that FinisherSC can robustly merge contigs.There is an optional component, X-phaser (), that can resolve long approximate repeats with two copies by using the polymorphisms between them. There is also an optional component, T-solver that can resolve tandem repeat by using the copy count information. @BULLET Data-efficient: FinisherSC utilizes all the raw reads to perform re-layout. This can fill gaps and improve robustness in handling repeats. @BULLET Scalable: FinisherSC streams raw reads to identify relevant reads for re-layout and refined analysis. MUMMER (MUMMER is single threaded, we provide an option to segment the files and run multiple MUMMER jobs in parallel. These techniques allow FinisherSC to be easily scalable to high volume of data.Algorithm 1. Main flow of FinisherSC Input: contigs.fasta, raw_reads.fasta Output: improved3.fasta 1. Filter completely embedded contigs 2. Form a string graph with the BEST successors/predecessors as edges 3. Condense the string graph by contracting edges with both in-degree and out-degree being 1 4. Use raw reads to declare potential successors/predecessors of dangling contigs 5. Merge contigs (with gaps filled by reads) when they respectively only have 1 successor/1 predecessor 6. Form a string graph with ALL successors/predecessors as edges 7. Merge contigs with only 1 predecessor or 1 successor and each has no more than two competing edges
Results and discussion
Experimental evaluation on bacterial genomesWe evaluated the performance of FinisherSC as follows. Raw reads were processed according to the pipeline in. They were first error corrected and then assembled into contigs by an existing pipeline (i.e. HGAP). Contigs were upgraded using FinisherSC and evaluated for quality with Quast (). The data used for assessment are real PacBio reads. These include data recently produced at JGI and data available online supporting the HGAP publication. We compared the assembly quality of the contigs coming out from the Celera assembler () of HGAP pipeline, the upgraded contigs by FinisherSC and the upgraded contigs by PBJelly (). A summary of the evaluation is shown in. More details can be found in the supplementary materials. We find that FinisherSC can upgrade the assembly from HGAP without sacrifice on accuracy on these test cases. Moreover, the upgraded contigs by FinisherSC are generally of higher quality than those upgraded by PBJelly. This suggests that there is extra information from the reads that is not fully utilized by state-of-the-art assembly pipelines for long reads.
Experiments on scalabilityWe tested the scalability of FinisherSC by applying it to handle larger genomes. The data used are the benchmark data available on PacBio Devnet. We run FinisherSC with the option of using 20 threads (-par 20) on a server computer. The server computer is equipped with 64 cores of CPU at clock rate of 2.43.3 GHz and 512 GB of RAM. The running time is tabulated in.
DiscussionAlthough FinisherSC was originally designed to improve de novo assembly by long reads, it can also be used to scaffold long contigs (formed by short reads) using long reads. For that use case, we note that the contigs formed by short reads can sometimes have length shorter than the average length of long reads. Therefore, we suggest users to filter out those short contigs before passing them into FinisherSC.
FundingThe authors K.K.L and D.T. are partially supported by the Center for Science of Information (CSoI), an NSF Science and Technology Center, under grant
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
K.-K.Lam et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
