Motivation: The development of computational tools to enable testing and analysis of high-throughput–sequencing data is essential to modern genomics research. However, although multiple frameworks have been developed to facilitate access to these tools, comparatively little effort has been made at implementing low-level programming libraries to increase the speed and ease of their development. Results: We propose NGSþþ, a programming library in Cþþ11 specialized in manipulating both next-generation sequencing (NGS) data-sets and genomic information files. This library allows easy integration of new formats and rapid prototyping of new functionalities with a focus on the analysis of genomic regions and features. It offers a powerful, yet versatile and easily extensible interface to read, write and manipulate multiple genomic file formats. By standardizing the internal data structures and presenting a common interface to the data parser, NGSþþ offers an effective framework for epigenomics tool development. Availability: NGSþþ was written in Cþþ using the Cþþ11 standard. It requires minimal efforts to build and is well-documented via a complete docXygen guide, online documentation and tutorials. Source code, tests, code examples and documentation are available via the website at http://www.ngsplusplus.ca and the github repository at https://github.com/NGS-lib/NGSplusplus.
INTRODUCTIONPrevious years have witnessed an explosion in the amount of data produced using next-generation sequencing (NGS) technologies, as exemplified by the ENCODE project (ENCODE Project). However, analysis of these enormous datasets (easily 4100 GB) requires the use of a new generation of computational tools. As the quantity of data produced by NGS machines increases, so will the time spent on developing new tools. Although substantial efforts have been made at integrating them into user-friendly frameworks such as Galaxy () or GeneSpace (Genome Space), relatively little effort has gone into providing the groundwork needed to increase the productivity of NGS developers, such as libraries and using standardized formats. Improvement in these areas would allow developers to greatly accelerate the speed at which they design and deploy new analysis software. Although certain tool suites, such as BEDtools () and BAMtools (), offer a library or API to assist developers, these are generally aimed at giving access to the existing tool functionality rather than facilitating development of new ones. As such they are highly specialized. The SeqAn library () offers functionality for the developmental of future tools, but it specializes in sequence analysis rather than genomic regions and features. Our proposed library, NGS, aims to fill this gap by offering a powerful set of generic and flexible options to accelerate development and prototyping of epigenomics analysis tools.
APPROACHIt is impossible to predict the entirety of future needs for NGS data analysis. As such, NGS focuses on being a customizable and generic library that facilitates the prototyping and implementation of new functionalities via a transparent data interface. In this section, we summarize the three main components of NGS: (i) file format management, (ii) data manipulation and (iii) functional operators. Dealing with the wealth of existing file formats is a time consuming task. NGS offers a simple interface to parse and write in many frequently used genomics file formats (BED, GFF/ GTF, Sam, Wig, bedGraph) using a generic data structure named Tokens that contain a number of standard features of genomic data entries (eg: Start/End positions, position value and mapping quality). Additionally, the user can define 'onthe-fly' custom formats to deal with the plethora of datasets that do not respect format specifications, and BAM format is supported via integration of the BamTools API. The conversion between most supported formats is a trivial task:*To whom correspondence should be addressed.
yThe authors wish it to be known that, in their opinion, the first two authors should be regarded as joint First Authors.The internal structure of the library is divided into a three-tiers hierarchy separating a genomic dataset by unique scaffolds with each of them containing any number of contigs. This hierarchy is represented in (), and each level offers a number of functions that can be extended via inheritance for specialized data manipulation. Loading datasets is done through integration with our Parser class and allows the user to easily load data:NGS offers a powerful set of generic functions to compare, sort, merge and modify the previously loaded data. These include typical operations such as overlapping, merging and comparing that allows the user to easily filter his data as needed. The following would return tags overlapping a BED file: auto fExpTagExp.getOverlapping(RegionExp); Additionally, the majority of these operators can be used on any given feature of the data objects, including features added by the user via inheritance. This example sorts and counts a subset based on a new object feature: RegionExp.sortSites((uRegion item1, uRegion item2){return item1.Score 5 item2.Score}, & uRegion::getScore, &uRegion::getScore) int count  RegionExp.getSubsetCount(0.5,0.8);As shown earlier in the text, this is greatly facilitated by the inclusion of anonymous lambda functions in the C11 standard. Using these flexible operators allows the experienced developer to implement powerful modifications, whereas the default genomic interval operators are easily usable by all. Finally, to accommodate specific analysis needs, NGS offers an interface to run developer defined functions and transformations on the selected data. This allows the developer to concentrate on the function he wishes to implement without having to spend time on the underlying structure that will support it. Borrowing heavily from the functional programming paradigm, this allows for rapid prototyping and implementation. In the following we define and execute a function that allows us to trivially generate a histogram of contig sizes: map5int,int4 sizeOfContigs; uTagsExp.applyOnSites((uTag Elem){sizeOfContigs;});Additional functional operators exist, allowing a variety of different operations on the dataset. This interface wraps many of the STL algorithms, enabling rapid parallelism via the OpenMP standard ().
IMPLEMENTATIONNGS is written in C using the C11 standard. It offers a complete exception handling interface using the Boost exception class. A complete test suite is implemented using the Google test platform. It has been designed for a Linux environment using a C11 compatible gcc compiler. Complete user guide, tutorial and discussion are available on the web page. Source code is hosted on GitHub.
CONCLUSIONProgress in the development of advanced bioinformatics analysis tools has undoubtedly been hindered by the lack of available programming frameworks. Our library aims to assist in filling this gap for the community of C epigenomic developers by giving them access to robust building blocks, thus reducing the time spent on development significantly. Our efforts are now focused on including additional genomic formats and on increasing the breath of our tutorials. Future developments will include the integration of mid-level reusable functions, such as similarity functions and normalization methods. The website provides a list of tutorials and commented working code examples, to assist developers in getting started with the library. Finally, theParsing interface then filtered as needed. User-defined functions are executed via our operators, and the transformed data are stored via our Writer interface
The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
A.N.Markovits et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
