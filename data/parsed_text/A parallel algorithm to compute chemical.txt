Analysing genome-scale in silico models with stoichiometry-based methods is computationally demanding. The current algorithms to compute chemical organizations in chemical reaction networks are limited to small-scale networks, prohibiting a thorough analysis of large models. Here, we introduce a parallelized version of the constructive algorithm to determine chemical organizations. The algorithm is implemented in the Standard C programming language and parallelized using the message passing interface (MPI) protocol. The resulting code can be executed on computer clusters making use of an arbitrary number of processors. The algorithm is parallelized in an embarrassing parallel manner, providing good scalability. Availability: An implementation of the algorithm including source code can be obtained from
INTRODUCTIONStoichiometry-based network analysis methods like flux balance analysis (), elementary mode analysis () and chemical organization analysis () have proven useful in gaining a better understanding of the functioning of biochemical systems at the systems level (). With the ongoing efforts to elucidate more and more biochemical details, genome-scale metabolic networks have become available for an increasing number of organisms (). Analysis of such networks with species and reaction numbers ranging in the thousands pose a new computational challange (). To meet this challange, we introduce a parallelized version of the constructive algorithm to determine chemical organizations. A chemical organization is a set of network species constituting a subsystem of the whole network, that fulfills two properties: (i) algebraic closure and (ii) self-maintenance. The first property ensures that the species of an organization cannot generate a species that is not already contained in that set, while the second property ensures that a flux vector
IMPLEMENTATION AND PERFORMANCEThe constructive algorithm was implemented in the Standard C programming language, and parallelization was realized using the message passing interface (MPI) protocol (Message Passing Interface Forum, 1994). The program reads a reaction network model in SBML format () using libSBML () and can compute organizations as well as connected organizations (). For solving linear programming problems, either the lpsolve library () or GLPK () can be used. To avoid processing the same set of species twice when trying to expand a semi-organization, a hash structure is used to keep track of already processed species sets. This hash structure is, however, kept local at the client CPUs to avoid excessive communication between processors. The drawback is that the effectiveness of the hash facility decreases if using many CPUs, as the same species set might then be processed by more than one client CPU. The code can be configured to write restart files and terminate after a predefined execution time for cluster systems where runtime is restricted. To assess the performance of the parallelized algorithm, we record the runtime to compute the first 100 organizations of a genome-scale reaction network model of Escherichia coli () using 116 CPUs. The speedup is almost ideal for up to about ten client CPUs, but slows down for higher numbers of processors as communication demand increases and efficiency of the hash facility decreases (). Nevertheless, absolute runtime stays close to ideal parallelization, even for large numbers of CPUs (), indicating good scalability.
CONCLUSIONThe computational time required to compute the organizations for a given reaction network model does not solely depend on the network size, but also its structure (). Being NP-hard, the computation of all organizations will remain unfeasable for certain networks, even when using the parallelized version of the algorithm on a computer cluster. Nevertheless, the parallelized version reduces runtime to practical limits for large models, especially if many CPUsare available. For example, all connected organizations of three previously not tractable networks () could be determined using the parallelized algorithm.
* To whom correspondence should be addressed. exists such that all species of the organization are produced at a sufficient rate for their survival. Hence, organizations represent species combinations that are likely to persist over time; novel species cannot occur due to the closure property and species do not vanish due the self-maintenance property. Every organization is also a semi-organization, a closed set that is semi-self-maintaining. Semi-self-maintenance is a weaker condition than self-maintenance. It merely requires that for each species of the set for which a reaction exists in which it is consumend, a reaction also exists in which it is produced. The set of organizations forms a hierarchy that can be visualized in a Hasse diagram. Organizations are vertically arranged according to size, with the organization containing the fewest species at the bottom. Links are drawn between two organizations, if the upper organization contains all species of the bottom organization and there is no other organization between them. Formal definitions of these concepts can be found in Dittrich and Speroni di Fenizio (2007). 2 METHODS The constructive algorithm to compute chemical organizations (Centler et al., 2008) consists of two steps. In the first step, all semi-organizations of the reaction network are determined in a bottom-up fashion. The central function of the algorithm determines, given a semi-organization, the smallest semiorganizations that contain this semi-organization. This is done by adding new species to the semi-organization to form a larger semi-organization. The newly found semi-organizations are added to a list of semi-organizations which still need to be processed. The algorithm starts by initializing this list with the smallest semi-organization of the reaction network. In each iteration of the algorithm, the smallest semi-organization is taken from this list and the semi-organizations above it are determined. This is repeated until the list of semi-organizations to be processed is empty. In the second step, every computed semi-organization is tested for the property of selfmaintenance. This involves the processing of a linear programming problem for each semi-organization. The parallelization of both steps of the algorithm follows an inverted clientserver model. In the first step, the server keeps track of the list of semi-organizations which still needs processing, and distributes the task of determining larger semi-organizations for one semiorganization of that list to the client CPUs as they become available. In the second step, the server evenly distributes the linear programming problems to the available client CPUs. Both the computation of larger semi-organizations, and the computation of the linear programming problem can be executed in isolation, not requiring any communication with other CPUs. This allows for a parallelization in an embarrassingly parallel fashion with good scalability and an expected linear speedup. 1788  The Author 2010. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oxfordjournals.org at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
