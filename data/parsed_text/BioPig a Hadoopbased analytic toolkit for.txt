Motivation: The recent revolution in sequencing technologies has led to an exponential growth of sequence data. As a result, most of the current bioinformatics tools become obsolete as they fail to scale with data. To tackle this 'data deluge', here we introduce the BioPig sequence analysis toolkit as one of the solutions that scale to data and computation. Results: We built BioPig on the Apache's Hadoop MapReduce system and the Pig data flow language. Compared with traditional serial and MPI-based algorithms, BioPig has three major advantages: first, BioPig's programmability greatly reduces development time for parallel bioinformatics applications; second, testing BioPig with up to 500 Gb sequences demonstrates that it scales automatically with size of data; and finally, BioPig can be ported without modification on many Hadoop infrastructures, as tested with Magellan system at National Energy Research Scientific Computing Center and the Amazon Elastic Compute Cloud. In summary, BioPig represents a novel program framework with the potential to greatly accelerate data-intensive bioinformatics analysis. Availability and implementation: BioPig is released as open-source software under the BSD license at https://sites.google.com/a/lbl.gov/ biopig/ Contact: ZhongWang@lbl.gov
INTRODUCTIONAdvances in DNA sequencing technologies are enabling new applications ranging from personalized medicine to biofuel development to environmental sampling. Historically, the bottleneck for such applications has been the cost of sequencingthe estimated cost of sequencing the first human genome (3 GB) completed a decade ago is estimated at $2.7 billion (http:// www.genome.gov/11006943). Current next-generation sequencing technologies () have extraordinary throughput at a much lower cost, thereby greatly reducing the cost of sequencing a human genome to 5$10 000 (http://www.genome. gov/sequencingcosts/, accessed December 2012). The price hit $5495 by the end of 2012 (http://dnadtc.com/products.aspx, accessed December 2012). With the cost of sequencing rapidly dropping, extremely large-scale sequencing projects are emerging, such as the 1000 Genomes Project that aims to study the genomic variation among large populations of humans (1000 Genomes), and the cow rumen deep metagenomes project that aims to discover new biomass degrading enzymes encoded by complex microbial community (). As a result, the rate of growth of sequence data is now outpacing the underlying advances in storage technologies and compute technologies (Moore's law). Taking metagenomic studies as an example, data have grown from 70 Mb (million bases) from termite hindgut () and 800 Mb Tamar wallaby (), to 268 Gb (billion bases) from cow rumen microbiome () within the past 4 years. The recently published DOE Joint Genome Institute's (JGI) sequencing productivity showed that 30 Tb (trillion bases) of sequences were generated in 2011 alone (http://1.usa.gov/JGI-Progress-2011). Data analysis at terabase scales requires state-of-the-art parallel computing strategies that are capable of distributing the analysis across thousands of computing elements to achieve scalability and performance. Most of the current bioinformatics analysis tools, however, do not support parallelization. As a result, this exponential data growth has made most of the current bioinformatics analytic tools obsolete because they fail to scale with data, either by taking too much time or too much memory. For example, it would take 80 CPU years to BLAST the 268 Gb cow rumen metagenome data () against NCBI non-redundant database. De novo assembly of the full dataset by a short read assembler, such as Velvet (), would require computers with 41 TB RAM and take several weeks to complete. Re-engineering the current bioinformatics tools to fit into parallel programming models requires software engineers with expertise in high-performance computing, and parallel algorithms take significantly longer time to develop than serial algorithms (). In addition, at this scale of computing hardware failures become more frequent, and most bioinformatics software lack robustness so that once they fail they have to be restarted manually. All these challenges contribute to the bottleneck in large-scale sequencing analysis. Cloud computing has emerged recently as an effective technology to process petabytes of data per day at large Internet companies. MapReduce is a data-parallel framework popularized by Google Inc. to process petabytes of data using large numbers of commodity servers and disks (). Hadoop is an open-source implementation of the MapReduce framework and is available through the Apache Software Foundation (http://wiki.apache.org/hadoop). Hadoop uses a *To whom correspondence should be addressed. y Present address: Amazon Web Services, New York, NY 10019, USA distributed file system (HDFS) that brings computation to the data as opposed to moving the data to the computation as is done in traditional computing paradigms. In Hadoop, node-tonode data transfers are minimized, as Hadoop tries its best to perform automatic co-location of data and program on the same node. Furthermore, Hadoop provides robustness through a job handling system that can automatically restart failed jobs. Because of these advantages, Hadoop has been explored by the bioinformatics community () in several areas including BLAST (), SNP discovery (), short read alignment () and transcriptome analysis (). In addition, there are solutions that reduce the hurdle to run Hadoop-based sequence analysis applications (). Using Hadoop requires a good understanding of this framework; however, to break up programs into map and reduce steps, skills in programming languages, such as Java or C, are also required. To overcome the programmability limitations of Hadoop, several strategies have been developed. For example, Cascading is an application framework for Java developers by Concurrent Inc. (http://www.cascading.org/), which simplifies the processes to build data flows on Hadoop. Apache's Pig data flow language was developed to enable non-programmer data analysts to develop and run Hadoop programs (http://pig.apache.org/). Somewhat similar in nature to SQL, the Pig language provides primitives for loading, filtering and performing basic calculations over datasets. Pig's infrastructure layer consists of a compiler on the user's client machine that turns the user's Pig Latin programs into sequences of MapReduce programs that run in parallel on the nodes of the Hadoop cluster in a similar fashion to how a database engine generates a logical and physical execution plan for SQL queries. In this article, we describe BioPig, a set of extensions to the Pig language to support large sequence analysis tasks. We will discuss the design principles, give examples on use of this toolkit for specific sequence analysis tasks and compare its performance with alternative solutions on different platforms. There is a similar framework, SeqPig (http://seqpig.sourceforge.net/), developed in parallel to BioPig, which is also based on Hadoop and Pig. We provide a detailed comparison of the two in Section 3.4.
METHODSUsing the BioPig modules, we provide a set of scripts that showcase the functionality provided by the framework, as well being useful bioinformatics tools in their own right.
pigKmerGiven a set of sequences, the pigKmer module computes the frequencies of each kmer and outputs a histogram of the kmer counts. The kmer histogram task is ideally suited for MapReduce, as each kmer count can be generated in parallel without global knowledge of all kmers. The data file is partitioned into a number of blocks and each map task operates on a single block at a time. The grouping operation is naturally implemented in the reduce step where the kmers are sorted and partitioned across the available reducers. Each reducer then counts the number of items in its group. The histogram of the counts is generated in a second MapReduce iteration. Code Listing 1 shows the BioPig script for this calculation. The script first registers the BioPig functions defined in the jar file on line 1. On line 2, the dataset is read and identified as table named A with four columns: id (sequence id from the header of the FASTA), direction (0 if combined or not paired, 1 or 2 otherwise), sequence (the characters of the read sequence itself) and header (any additional data on theA number of variations of kmer counting are available: count only the number of unique reads that contain the kmer or group kmers within one or two hamming distance ().
pigDusterpigDuster searches a set of query sequences against a database of known sequences for near exact matches. This application is useful to screen sequence datasets for contaminants or to perform pathogen detection from human sequence data. The application uses shared kmers to find matches to sequences in the dataset. The kmer indices of the known sequences and query sequences are compared by the join function with detect matches.
pigDereplicatorRaw sequence data often contain reads derived from PCR () amplification. But due to small error rates introduced in the sequencing process, the same DNA sequence may not produce identical reads. To remove these artifacts, the dereplication application builds a kmer index by joining the beginning 16 bases of each read of a mate pair. Because the error rate increases as a function of sequencing length in many short read technologies, the first 16 bases typically contain fewer errors. The 32mer is then used to identify near identical read pairs. Code Listing 2 shows the BioPig code for dereplicating a dataset of reads. For brevity, the comments and headers have been left out. Lines 10 and 11 generate the hash from the first 16 and last 16 characters. Finally, the hash is grouped and all the sequences with a given hash are combined using the CONSENSUS function (for each base position in the sequence, the majority value determined).load the target sequences 9 READS = load '$reads' using gov.jgi.meta.pig.storage.FastaStorage as (id: chararray, d: int, seq: bytearray, header: chararray);-group the read pairs together by id and filter out any reads that-do not have a matching pair.-then combine the mate pairs into a single sequence10 GROUPEDREADS = group READS by id parallel $p; 11 MERGEDREADS = foreach GROUPEDREADS generate flatten(PAIRMERGE(READS)) as (id: chararray, d: int, seq: bytearray);-generate the hash 12 HASH = foreach MERGEDREADS generate IDENTITYHASH(UNPACK(seq)) as hash, UNPACK(seq) as seq; 13 HASHNEIGHBORS = foreach HASH generate flatten(HAMMINGDISTANCE($0, $distance)) as hash, '0', $1 as seq;-now merge all similar reads together 15 E = group HASHNEIGHBORS by $0 parallel $p; 16 F = foreach E generate $0, count($1), CONSENSUS($1);-return output 17 store E into '$output'; Most of the work in the script is done in the various functions defined in the BioPig library. PAIRMERGE() takes a set of sequences and merges them together into a single sequence; IDENTITYHASH() takes a sequence and returns the hash from the first 16 bases and the last 16 bases; and CONSENSUS() takes a set of sequences and calculates the majority base at each position and returns a new sequence. The sequence data loader used in line 2 also is defined in the BioPig library and supports reading and parsing FASTA-formatted sequence files.
RESULTS
The BioPig framework and its design principlesThe ideal analysis solution should address the three main challenges in data-intensive sequence analysis: (i) scalability: it should scale with data size; (ii) programmability: it should leverage a high-level data flow language that provides abstraction of parallelism details, which enables bioinformatics analysts to focus on analysis over large data sizes without concerns as to parallelization, synchronization or low-level message passing; and (iii) portability: it should be portable without extensive modification to various IT infrastructure. With these design principles in mind, we developed the BioPig data analytic toolkit on top of Apache Hadoop and Pig (). The resulting BioPig toolkit has both the scalability and robustness offered by Apache Hadoop, which uses the data-parallel methodology of MapReduce to parallelize analysis over many computing cores without significant loss in computing performance, and the programmability and parallel data flow control offered by Pig. In addition, as both Hadoop and Pig are implemented in Java, BioPig inherits their portability. The BioPig modular implementation consists of a set of libraries, which add an abstraction layer for processing sequence data. Within BioPig's open extensible framework, functions and libraries can be updated and added easily. The first release of BioPig contains three core functional modules. The BioPigIO module reads and writes sequence files in FASTA or FASTQ format. It enables Hadoop to split sequence files automatically and distribute them across many compute nodes. The BioPigAggregation module is a wrapper for common bioinformatics programs, such as BLAST, CAP3, kmerMatch and Velvet. Finally, there is a set of utilities that make working with nucleotide sequences more efficient by using compression and encoding.lists the functions provided by the current version of BioPig.
A simple BioPig application demonstrates scalability, programmability and portabilityTo systematically evaluate the scalability, programmability and portability of the BioPig framework, we implemented a kmerThe size of the dataset we used ranges from the 100 Mb to 500 Gb from the cow rumen metagenomic data (). Kmer counting is an essential component of many bioinformatics methods, such as genome and transcriptome assembly. Even though it is simple to compute, serial programs using kmer counting quickly run out of memory as the size of sequence data increases (). For simplicity, we fixed the size of kmer to 20 (K  20) and compared the scalability of the BioPig kmer counting program, KmerGenerator, to a serial version, Tallymer () and an open-source MPI-version (https://github. com/JGI-Bioinformatics/Kmernator). As shown in, when run on the Magellan Hadoop cluster (NERSC) using 1000 mappers and reducers, respectively, BioPig KmerGenerator scales well from 1 to 500 Gb of input sequences. In contrast, Tallymer ran out of memory on a single node with 48 GB RAM with 1 Gb dataset, and our straightforward implementation of the MPI-version ran out of memory at 50 GB on the same machines tested. We noticed that when the size of the datasets is small (1, 5 and 10 Gb), the KmerGenerator takes about the same time to finish, possibly due to the overhead of the MapReduce framework that BioPig based on. As data sizes reach 10 Gb and higher, however, KmerGenerator scales well with data. To investigate whether or not other applications based on BioPig also scale with data, we tested ContigExtention and GenerateContig on increasing data sizes (10, 50 and 100 Gb). ContigExtention script (Code Listing 3) iteratively searches for short reads that map to the ends of a long sequence (contig) based on kmer matching and assembles the matching reads with the long sequence to extend it. The algorithm is linear, and we observed near linear performance with data (). GenerateContig script consists of two steps: it starts by running BLAST to find short reads matching a long sequence, and subsequently assembles them into contigs by calling Velvet. The first step is linear in relation to input size, whereas the second assembly step is not. As a result, the overall performance of the script over data displays a nonlinear scaling pattern ().KmerGenerator does kmer counting with just eight lines of code (Code Listing 1). To achieve the same task, Tallymer and the MPI-version use thousands of lines of code. This suggests BioPig has excellent programmability and can greatly reduce the amount of software development time. This programmability feature is particularly attractive to next-generation sequencing data analysis, as the sequencing technology rapidly changes and software constantly needs to be updated. To test the portability of BioPig, we evaluated KmerGenerator function on Amazon Elastic Compute Cloud (Amazon EC2). Porting BioPig to Amazon was simply a matter of uploading the BioPig core JAR (Java ARchive) file, along with the bioinformatics tools called from BioPig code. Without any change to the underlying code, KmerGenerator was successfully run on both platforms, demonstrating the portability of the BioPig framework. Furthermore, we observed scalability on EC2 similarly as on the Magellan system with various sizes of sequence datasets ().
Embedding BioPig into other programming languagesBioPig has the flexibility to be embedded into other languages, such as Python or JavaScript, to achieve the types of control flows such as loops and branches that are not currently available in the Pig language. This flexibility greatly extends the usefulness of the BioPig toolkit. Code Listing 3 illustrates a Python script with BioPig embedded. This contig extension algorithm greedily extends by iteratively searching for reads that can extend the contig followed by extending the contigs via assembling the reads at each end. In each iteration, the Cap3 assembler is used to extend the contigs, of which only those contigs being extended go into the next iteration. The loop will stop when there are no contigs left to be extended or when it reaches a predefined number of steps.
BioPig and related MapReduce-based frameworksSeveral computational frameworks have been recently developed for bioinformatics. Despite that they all aim to scale analysis to big data by implementing existing algorithms onto MapReduce/ Hadoop, they differ significantly on the specific algorithms implemented (). Therefore, it is not straightforward to compare the performance of BioPig with these frameworks. The only exception is SeqPig (http://seqpig.sourceforge.net/). SeqPig and BioPig are two independent projects, and they share some similarities. First, they both extend Pig, and therefore have the same programming syntax. Second, there are a few similar functions (such as sequence import and export). Because they are based on the same framework (Hadoop and Pig), when run in the same hardware environment, they are expected to have similar run time performance. The difference between the two projects lies in their user-defined functions. BioPig includes several kmerbased applications that are not available in SeqPig (). It also provides wrappers to run many frequently used bioinformatics applications such as BLAST, Velvet and CAP3. In contrast, SeqPig mainly implements functions of Picard (http:// picard.sourceforge.net) and SamTools (). SeqPig and BioPig can be installed side-by-side on the same Hadoop and Pig cluster. From the same Pig script, it is straightforward to call both BioPig and SeqPig functions.provides a comparison of BioPig with these related frameworks.
DISCUSSIONIn this work, we present a solution for improved processing of large sequence datasets in many bioinformatics applications. Using only a few core modules, we believe we have demonstrated the usefulness of this toolkit, while its modular design should enable many similar applications that fit in the MapReduce framework. BioPig has several advantages over alternative parallel programming paradigm: it is easy to program; it is scalable to process large datasets (with 500 Gb being the largest one tested); and it is generically portable to several examples of Hadoop infrastructure, including Amazon EC2, without modification. We also noticed several limitations of BioPig, most of which likely derived from Hadoop itself. For example, it is slower than handcrafted MPI solutions. This is due to both the latency of Hadoop's initialization and the fact that generic MapReduce algorithms are not optimized for specific problems. For big datasets this limitation may not be a problem, as the time spent on data analysis far exceeds the cost for the start-up latency. Recently, the Hadoop community has started to address this problem. Certain commercial implementations of MapReduce, such as IBM's Symphony product, have been developed to reduce Hadoop's start-up latency. Another promising solution is SPARK, which can speed up Hadoop applications 100 times by using a low latency, in memory cluster computing (). Another issue is computing resource demand. When dealing with huge datasets, BioPig shifts the need from expensive resources such as large memory (1TB RAM) machines and/or parallel programming expertise, to large disk space on commodity hardware. For example, a kmer/read index in BioPig needs
Published by Oxford University Press. 2013. This work is written by US Government employees and is in the public domain in the US. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
BioPig at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
H.Nordberg et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
H.Nordberg et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from lots of disk space, with the largest index taking up 15 TB of disk space for the 500 Gb dataset. This trade-off is usually a favored option, as RAM is more expensive than hard disk. Therefore, processing large datasets with BioPig requires a stable Hadoop environment with fast interconnects and plentiful disk space. One might reduce the requirement by keeping fewer copies of the files in the HDFS system, which is a trade-off for redundancy. BioPig is built on MapReduce and Hadoop, so algorithms that do not run well on MapReduce will not run well with BioPig either. For example, large short read assembly algorithms involve large graph processing. Currently, they require messagepassing and have not yet been implemented on MapReduce.
