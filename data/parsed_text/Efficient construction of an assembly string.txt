Motivation: Sequence assembly is a difficult problem whose importance has grown again recently as the cost of sequencing has dramatically dropped. Most new sequence assembly software has started by building a de Bruijn graph, avoiding the overlap-based methods used previously because of the computational cost and complexity of these with very large numbers of short reads. Here, we show how to use suffix array-based methods that have formed the basis of recent very fast sequence mapping algorithms to find overlaps and generate assembly string graphs asymptotically faster than previously described algorithms. Results: Standard overlap assembly methods have time complexity O(N 2), where N is the sum of the lengths of the reads. We use the Ferragina–Manzini index (FM-index) derived from the Burrows– Wheeler transform to find overlaps of length at least τ among a set of reads. As well as an approach that finds all overlaps then implements transitive reduction to produce a string graph, we show how to output directly only the irreducible overlaps, significantly shrinking memory requirements and reducing compute time to O(N), independent of depth. Overlap-based assembly methods naturally handle mixed length read sets, including capillary reads or long reads promised by the third generation sequencing technologies. The algorithms we present here pave the way for overlap-based assembly approaches to be developed that scale to whole vertebrate genome de novo assembly.
INTRODUCTIONThe sequence assembly problem is one of the most important and difficult problems in bioinformatics. Most genomes, particularly eukaryotic genomes, are highly repetitive that complicates their assembly by obscuring true relationships between reads with many false options. To help disambiguate the true relationships between the reads from those induced by different copies of repeats, it is useful to construct a graph where all the copies of a repeat are collapsed into a single segment. Such a graph is commonly referred to as a repeat graph. This structure is a natural consequence of the de Bruijn graph method of sequence assembly as the deconstruction of the sequence reads into k-mers (short subsequences of the reads of length k) collapses repeats that share the same k-mer into a single vertex (). An alternative formulation was proposed by Gene Myers and is called the string graph (). The string graph is built by first constructing a graph of the pairwise overlaps between sequence reads and transforming it into a string graph by removing transitive edges. The string graph shares with the de Bruijn graph the property that repeats are * To whom correspondence should be addressed. collapsed to a single unit without the need to first deconstruct the reads into k-mers. Because it is based on maximal overlaps, which are typically longer than de Bruijn k-mers, it also disambiguates shorter repeats that de Bruijn methods would only resolve in later processing steps (if at all). The string graph is much more expensive to construct, however, as the set of all pairwise, inexact overlaps between sequence reads must be found. For this reason, the majority of assemblers of short read sequence data have been based on the de Bruijn approach (). A notable exception is the Edena assembler () that uses a suffix array to compute exact overlaps between reads that are then used to construct the string graph. We address the construction of a string graph with a related approach by indexing the set of sequence reads using the BurrowsWheeler transform(BWT)/Ferragina Manzini(FM)-index, which has recently been used for the short read alignment problem (). We show how to efficiently compute the set of overlaps needed to construct the string graph from the FMindex. Furthermore, we show that the string graph can be constructed directly using the FM-index without the need for explicitly finding all overlaps and a subsequent transitive removal step, yielding a space and time efficient construction algorithm.
BACKGROUND
Definitions and notationLet X be a string of symbols a 1 ,...,a l from an alphabet. The length of X is denoted |X|. We consider all strings to be terminated by a sentinel symbol $ that is not in and is lexographically lower than all the symbols in. X=a i is the i-th symbol of X and Xis the substring a i ,...,a j. A substring Xis a suffix of X and a substring Xis a prefix of X. Let X = a l ,a li ,...,a 1 denote the reverse of X.
Genomes and sequence readsWe define a genome to be a long string from the alphabet {A,C,G,T } representing the complete DNA sequence of an individual, for simplicity ignoring potential subdivisions into chromosomes. A sequence read is a short substring from a genome. DNA is a double stranded molecule and sequence reads can originate from either strand. We use the notation X for the reverse-complement of a read X. In a shotgun sequencing experiment, a set of sequence reads, which we denote by the indexed set R, is randomly sampled from a genome with an unknown sequence. The sequence assembly problem is to reconstruct the sequence of the genome given R. We say that two reads X and Y overlap if a prefix of X is equal to a suffix of Y or vice versa. If X and Y originate from opposite strands, they overlap if the reverse complement of one of them
J.T.Simpson and R.Durbinoverlaps the other. To help distinguish true overlaps from spurious overlaps, we set a threshold of  on the minimum acceptable overlap length. We assume for the moment that sequence reads are perfect representations of the genomethere are no sequencing errors. We discuss how to relax this constraint in the discussion at the end of this article.
Overlap and string graphsTo help reconstruct the source genome from R, we can build a graph of the relationships between sequence reads. One such graph is the overlap graph. In the overlap graph, each sequence read in R is a vertex and two vertices are joined by an edge if their corresponding reads overlap. Myers' string graph is a refinement of such a graph. In the string graph, reads that are contained within some other read, that is they are a substring of (or perhaps identical to) another read, are considered to be redundant and are not vertices in the graph. Each edge in a string graph is bidirectional to model the double-stranded nature of DNA and labelled with the unmatched substrings of the sequence reads. More formally, let X and Y be two reads wherethe entirety of X is matched by Y and X is said to be contained by Y. If Y is also contained by X (s yx = 1 and e yx =|Y |), X and Y are identical. In this case, we break the tie by saying the read with the higher index in R is contained within the read with the lower index. If neither X nor Y are contained and Xis a prefix of X (s xy = 1) and Y [s yx ,e yx ] is a suffix of Y (e yx =|Y |), or vice versa, we say the overlap between X and Y is proper. If X and Y are reads from opposite strands of the genome they can still form an overlap. In this case, Xmust be prefixes or both must be suffixes. All non-contained reads are vertices in the string graph. For each proper overlap between two reads, we add a bidirected edge to the graph X  Y. The bidirected edge describes the nature of the overlap between the reads and has two labels, one for each of the unmatched substring of the reads. We denote the tuple of data for each edge as (type xy ,type yx ,label xy ,label yx ). We define the type xy property (respectively, type yx ) as:In other words, type xy is B if the matched portion of X is a prefix of X, otherwise the matched portion of X must be a suffix and type xy is E. Note that since the graph does not have contained reads these cases are mutually exclusive. The label xy property isRestated, label xy is the unmatched suffix of Y if the matched portion of Y is a prefix and vice versa. The concatenation of X and label xy is an assembly of reads X and Y  the resulting string contains both the sequence of X and Y. If the overlap between X and Y is reverse complemented, i.e. Xin the case of an edge built from a reverse-complement overlap, type xy is necessarily the same as type yx. To perform a walk in the string graph, if one enters a vertex on an edge of type B then an edge of A Btype E must be used to exit and vice versa.depicts a simple string graph built from three overlapping reads. The initial graph built from the overlaps between reads is not a string graph yet. Consider a read X that overlaps reads Y and Z, which mutually overlap. The initial string graph will contain the edges X  Y , X  Z and Y  Z. If Y and Z overlap the same end of X, i.e type xy = type xz , then Y and Z must share a common substring of X which is a prefix or suffix of one of Y or Z. This implies that there is a valid path that visits each of the three reads in succession. Let X  Y  Z be such a path. The string corresponding to this path is a valid assembly of the three reads which is identical to the string corresponding to the path X  Z. In this case, we say that the edge X  Z is transitive. We will refer to non-transitive edges as irreducible. The transitive edges can be removed from the graph without losing any informationthe transitive edges (and their corresponding overlaps) could be inferred from the irreducible edges. We can determine useful properties of transitive and irreducible edges. As the graph does not have contained reads, the length of the overlap between X  Y is necessarily larger than the overlap between X  Z. Equivalently, the length of label xy is shorter than label xz , and label xz can be seen as the concatenation of label xy and label yz. In other words, label xy of the irreducible edge is a prefix of label xz of the transitive edge.
The suffix array, BWT and FM-indexThe suffix array data structure was introduced by Manber and Myers (1990) as a succinct representation of the lexographic ordering of the suffixes of a string. The suffix array of a string X, denoted SA X , is a permutation of the integers {1,2,...,|X|} such that SA X=j iff Xis the i-th lexographically lowest suffix of X. For example, if X =AAGTA$ then SA X =. Since the suffix array is a sorted data structure, the start positions of all the instances of a pattern Q in X will occur in an interval in SA X. We refer to such an interval as a suffix array interval and associate with it a pair of integersdenoting the first and last index in SA X that correspond to a position in X of an instance of Q. Using SA X and the original string X, l and u can be efficiently found with a binary search for Q. Ferragina and Manzini developed a related method of indexing text, called the FM-index, which requires considerably less memory than a suffix array and can compute l and u in O(|Q|) time, independent i368Page: i369 i367i373
String graph constructionof the size of the text being searched. Central to the FM-index is the BWT. Originally developed for text compression () the BWT of X, denoted B X , is a permutation of the symbols of X such thatRestated, B Xis the symbol preceding the first symbol of the suffix starting at position SA X. Ferragina and Manzini (2000) extended the BWT representation of a string by adding two additional data structures to create a structure known as the FM-index. Let C X (a) be the number of symbols in X that are lexographically lower than the symbol a and Occ X (a,i) be the number of occurrences of the symbol a in B X. We note that C X and Occ X include counts for the sentinel symbol, $. Using these two arrays, Ferragina and Manzini provided an algorithm to search for a string Q in X (). Let S be a string whose suffix array interval is known to be. The interval for the string aS can be calculated fromusing C X and Occ X by the following:We encapsulate Equations (1)and(2) in the following algorithm, updateBackward.To search for a string Q, we need to first calculate the interval for the last symbol in Q then use Equations (1) and (2) to iteratively calculate the interval for the remainder of Q. The interval for a single symbol is simply calculated from C X. The backwardsSearch algorithm presents the searching procedure in detail. If backwardsSearch returns an interval where l > u, Q is not contained in X otherwise SA Xis the position in X of each occurrence of Q for l  i  u.The backwardsSearch algorithm requires updating the suffix array interval |Q| times. As each update is a constant-time operation, the complexity of backwardsSearch is O(|Q|). To save memory Occ X (a,i) is stored only for i divisible by d (typically d is around 128). The remaining values of Occ X can be calculated as needed using the sampled values and B X .
The generalized suffix arrayWe can easily expand the definition of a suffix array to include multiple strings. Let T be an indexed set of strings and T i be element T. We define SA T=(j,k) iff T j [k,|T j |] is the i-th lowest suffix in T. In the generalized suffix array, unlike the suffix array of a single string, two suffixes can be lexographically equal. We break ties in this case by comparing the indices of the strings. In other words, we treat each string in T as if it was terminated by a unique sentinel character $ i where $ i < $ j when i < j. We extend the definition of the BWT to collections of strings as follows. Let SA T=(j,k) thenLike the BWT of a single string, B T is a permutation of the symbols in T ; therefore, the definitions of the auxiliary data structures for the FM-index, C T (a) and Occ T (a,i), do not change.
METHODSThe construction of the string graph occurs in two stages. First, the complete set of overlaps of length at least  is computed for all elements of R. The initial overlap graph is then built as described in Section 2.3 and transformed into the string graph using the linear expected time transitive reduction algorithm of Myers (2005). The first step in this process is the computational bottleneck. The all-pairs maximal overlap problem can be optimally solved in O(N +k 2 ) time using a generalized suffix tree where N = |R| i=1 |R i | and k =|R| (). It is straightforward to restrict this algorithm to only find overlaps of length at least  at a lower computational cost; however, the amount of memory required for a suffix tree makes this algorithm impractical for large datasets. Myers' proposed the use of a q-gram filter to find the complete set of overlaps. This requires O(N 2 /D) time where D is a timespace tradeoff factor dependent on the amount of memory available. We will show that by using the FM-index of R the set of overlaps can be computed in O(N +C) time for error-free reads where C is the total number of overlaps found. We then provide an algorithm that detects only the overlaps for irreducible edgesremoving the need for the transitive reduction algorithm and allowing the direct construction of the string graph.
Building an FM-index from a set of sequence readsTo build the FM-index of R, we must first compute the generalized suffix array of R. We could do this by creating a string that is the concatenation of all members of R,then use one of the well-known efficient suffix array construction algorithms to compute SA S (). We have adopted a different strategy and have modified the inducedcopying suffix array construction algorithm () to handle an indexed set of strings R where each suffix array entry is a pair (j,k) as described in Section 2.5. This suffix array construction algorithm is similar to the KoAluru algorithm (). A set of substrings of the text (termed LMS substrings for leftmost S-type, see) is sorted from which the ordering of all the suffixes in the text is induced. Our algorithm differs from the NongZhangChan algorithm as we directly sort the LMS substrings using multikey quicksort () instead of sorting them recursively. This method of construction is very fast in practice as typically only 3040% of the substrings must be directly sorted. Once SA R has been constructed, the BWT of R, and hence the FM-index is easily computed as described above. We also compute the FM-index for the set of reversed reads, denoted R , which is necessary to compute overlaps between reverse complemented reads. We also output the lexographic index of R, which is a permutation of the indices {1,2,...,|R|} of R sorted by the lexographic order of the strings. This can be found directly from SA R and is used to determine the identities of the reads in R from the suffix array interval positions once an overlap has been found.Page: i370 i367i373
i369
J.T.Simpson and R.Durbin
Overlap detection using the FM-indexWe now consider the problem of constructing the set of overlaps between reads in R. Consider two reads X and Y. If a suffix of X matches a prefix of Y an edge of type (E,B) will be created in the initial overlap graph. We will describe a procedure to detect overlaps of this type from the FM-index of R. Let X be an arbitrary read in R. If we perform the backwardsSearch procedure on the string X, after k steps we have calculated the intervalfor the suffix of length k of X. The reads indicated by the suffix array entries in, therefore, have a substring that matches a suffix of X. Our task is to determine which of these substrings are prefixes of the reads. Recall that if a given element in the suffix array, SA R, is a prefix then B R=$ by definition. Therefore, if we know the suffix array interval for a string P, the interval for the strings beginning with P can be determined by calculating the interval for the string $P using Equations (1) and (2). This interval,, indicates that the reads with prefix P are the l $-th to u $-th lexographically lowest strings in R. We can, therefore, recover the indices in R of the reads overlapping X using lexographic index of R. The algorithm is presented below in findOverlaps.Algorithm 3 findOverlaps(X, )-determine the reads in R that overlap X by at least  symbols) end if end ifupdateBackward(,X) i  i1 end while if l  u then outputContained(X,) end ifThe findOverlaps algorithm is similar to the backwards search procedure presented in Section 2.4. It begins by initializingto the interval containing all suffixes that begin with the last symbol of X. The intervalis then iteratively updated for longer suffixes of X. When the length of the suffix is at least the minimum overlap size, , we determine the interval for the reads that have a prefix matching the suffix of X and output an overlap record for each entry (using the subroutine outputOverlaps). When the update loop terminates,holds the interval corresponding to the full length of X. The outputContained procedure writes a containment record for X if X is contained by any read inbased on the rules described in Section 2.3. The overlaps detected by findOverlaps correspond to edges of type (E,B). We must also calculate the overlaps for edges of type (E,E) and (B,B), which arise from overlapping reads originating from opposite strands. To calculate edges of type (E,E), we use findOverlaps on the complement of X (not reversed) and the FM-index of R. Similarly, to calculate edges of type (B,B), we use findOverlaps on X (the reverse complement of X) and the FM-index of R. The overlap records created by outputOverlaps are constructed in constant time as they only require a lookup in the lexographic index of R. Let c i be the number of overlaps for read R i. The findOverlaps algorithm makes at most |R i | calls to updateBackwards and a total of c i iterations in outputOverlaps for a total complexity of O(|R i |+c i ). For the entire set R, the complexity is O(N +C) where C = |R| i=1 c i. Note that the majority of these edges are transitive and subsequently removed. We can, therefore, improve this algorithm by only outputting the set of irreducible edges, allowing the direct construction of the string graph. We address this in Section 3.3. In rare cases, multiple valid overlaps may occur between a pair of reads. In this case, the intervals detected during findOverlaps will contain intersecting or duplicated intervals. To handle this, we can modify findOverlaps to first collect the entire set of found intervals. This interval set could then be sorted and duplicated or intersecting intervals that represent sub-maximal overlaps can be removed. The outputOverlaps procedure can be called on the entire reduced interval set to output the set of maximal overlaps.
Detecting irreducible overlapsTo directly construct the string graph, we must only output irreducible edges. Recall from Section 2.3 that the labels of the irreducible edges for a given read are prefixes of the labels of transitive edges. We use this fact to differentiate between irreducible and transitive edges during the overlap computation. Consider a read X and the set of reads that overlap a suffix of X, O. We could devise an algorithm to find the subset consisting only of irreducible edges by calculating the edge-labels of all members of O and filtering out the members whose label is the extension of the label of some other read. This would require iterating over all members of O, which can be quite large for repetitive reads. We will now show that the labels of the irreducible edges can be constructed directly from the suffix array intervals using the FM-index. Consider a substring S that occurs in R and its suffix array interval. Let a left extension of S be a string of length |S|+1 of the form aS. We can use B Rto determine the set of left extensions of S. Let B be the set of symbols that appear in the substring B R. The left extensions of S are the strings aS such that a  B. Note that we do not have to iterate over the range B Rto determine B. Since Occ R (a,i) is defined to be the number of times symbol a occurs in B Rwe can count the number of occurances of a in B R(and hence aS in R) in constant time by taking the difference Occ R (a,u)Occ R (a,l 1). If the $ symbol occurs in B Rwe say that S is left terminal, in other words one of the elements of R has S as a prefix. We similarly define a right extension of S as a string of length |S|+1 of the form Sa. While we cannot build the right extensions of S directly from the FM-index, the right extensions of S are equivalent to left extensions of S (the reverse of S) in R. Let S be right terminal if $ exists in B R', in other words S is a suffix of some string in R. The procedure to find all the irreducible edges of a read X and construct their labels is to find all the intervals containing the prefixes of reads that overlap a suffix of X, then iteratively extend them rightwards until a rightterminal extension is found. The terminated read forms an irreducible edge with X and the label of the edge is the sequence of bases that were used during the right-extension. All non-terminated strings with the same sequence of extensions are transitive and, therefore, not considered further. The algorithm requires searching the FM-index in two directions, first backwards to determine the intervals of overlapping prefixes and then forwards to extend those prefixes and build the irreducible labels. Naively this would require first determining the intervalsfor each matching prefix, P, and then reversing the prefix and performing a backwards search on the FM-index of R to find the intervalfor P. The intervalswould then be used in the extension stage to determine the labels of the irreducible edges. We can do better, however, by noting that the intervalcan be calculated directly during the backwards search without using the FM-index of R. We define OccLT R (a,i) to be the number of symbols that are lexographically lower than a in B R. Let S = Xbe a suffix of X and [l i ,u i ] its suffix array interval. Suppose we know the intervalThe interval for Xis identical to that of X, since B R and B R' are both permutations of symbols in R, therefore, C R = C R'. We can, therefore,
i370
String graph constructioninitialize the intervalto the same initial value ofand perform a forward search of X simulatenously while performing a backward search of X using only the FM-index of R. This does not require any additional storage as the OccLT R array can easily be computed from Occ R by summing the values for symbols less than a. This procedure is similar to the 2wayBWT search recently proposed by. The updateFwdBwd algorithm implements Equations (3) and (4) along with updateBackward to calculate the pair of intervals. The F parameter to updateFwdBwd indicates the FM-index used  that of R or R .We now give the full algorithm for detecting the irreducible overlaps for a read X. The algorithm is performed in two stages, first a backwards search on X is performed to collect the set of interval pairs, denoted I, for prefixes that match a suffix of X. This algorithm is presented in findIntervals below and is conceptually similar to findOverlaps.The interval set found by findIntervals is processed by extractIrreducible to find the intervals corresponding to the irreducible edges of X. This algorithm has two parts. First, the set of intervals is tested to see if some read in the interval set is right terminal. If so, the intervals corresponding to the right terminal reads form irreducible edges with X and are returned. If no interval has terminated, we create a subset of intervals for each right extension of I and recursively call extractIrreducible on each subset. The algorithm above assumes that there are no reads that are strict substrings of other reads (in other words, all the containments are between identical reads). If this is not the case, a slight modification must be made. If the set of reads overlapping X includes a read that is a proper substring of some other read it is possible that the first right terminal extension found is not that of an irreducible edge but of the contained read. It is straightforward to handle this case by observing that such a read will have an overlap which is strictly shorter than that of the irreducible edge. In other words, the only acceptable right terminal extension is to the reads in I that have the longest overlap with X. We can similarly modify extractIrreducible to handle overlaps for reads from opposite strands. To do this, we use findIntervals to determine the intervals for overlaps for the same strand as X and overlaps from the opposite strand of X (using the complement of X as in the previous section). When extending an interval that was found by the complement of X, we extendby the complement of a. In other words, if we are extending same-strand intervals by A, we extend opposite strand intervals by T and so on. We now offer a sketch of the complexity of the irreducible overlap algorithm. Let L i be the label of irreducible edge i. During the construction of L i at most k i intervals must be updated, corresponding to the number of reads that have an edge-label containing L i. The sum over all irreducible edges, E = i (|L i |k i ), is the total number of interval updates performed by extractIrreducible. Note that each read in R is represented by a path through the string graph. The total number of times edge i is used in the set of paths spelling all the reads in R is k i and the amount of sequence in R contributed by edge i is |L i |k i. This implies E can be no larger than N, the total amount of sequence in R, and extractIrreducible is O(N). As findIntervals is also O(N), the entire irreducible overlap detection algorithm is O(N).
RESULTSAs a proof of concept, we implemented the above algorithms. The program is broken into three stages: index, overlap and assemble. The index stage constructs the suffix array and FM-index for a set of sequence reads, the overlap stage computes the set of overlaps between the reads and the assemble stage builds the string graph, performs transitive reduction if necessary, then compacts unambiguous paths in the graph and writes out a set of contigs. We tested the performance of the algorithms with two sets of simulations. In both sets of simulations, we compared the exhaustive overlap algorithm (which constructs the set of all overlaps) and the direct construction algorithm (which only outputs overlaps for irreducible edges). First, we simulated Escherichia coli read data with mean sequence depth from 5 to 100 to investigate the computational complexity of the overlap algorithms as a function of depth. After constructing the index for each dataset, we ran the overlap step in exhaustive and direct mode with  = 27. The running times of these simulations are shown in. As expected,Overlap (exhaustive) Overlap (direct). The running time of the direct and exhaustive overlap algorithms for simulated E. coli data with sequence depth from 5 to 100. The direct overlap algorithm scales linearly with sequence depth. As the number of overlaps grows quadratically with sequence depth, the exhaustive overlap algorithm exhibits above-linear scaling. the direct overlap algorithm scales linearly with sequence depth. The exhaustive overlap algorithm exhibits the expected abovelinear scaling as the number of overlaps for a given read grows quadratically with sequence depth. To assess the quality of the resulting assembly, we assembled the data using the direct overlap algorithm and compared the contigs to the reference. For each level of coverage, we selected  to maximize the assembly N50 value. The N50 values ranged from 1.7 kbp (5 data,  = 17) to 80 kbp (100 data,  = 85). We aligned the contigs to the reference genome with bwa-sw () and found that no contigs were misassembled. We also simulated data from human chromosomes 22, 15, 7 and 2 to assess how the algorithms scale with the size of the genome. We pre-processed the chromosome sequences to remove sequence gaps then generated 100 bp error-free reads randomly at an average coverage of 20 for each chromosome. The results of the simulations are summarized in. The running time of the exhaustive and direct overlap algorithms are comparable. As the sequence depth is fixed at 20, both overlap algorithms scale linearly with the size of the input data. The final stage of the algorithm, building the string graph and constructing contigs, is much shorter for the direct algorithm as the transitive reduction step does not need to be performed. In addition, this step requires considerably less memory as the initial graph constructed by the direct algorithm only contains irreducible edges. The bottleneck in terms of both computation time and memory usage is the indexing step, which builds the suffix array and FMindex for the entire read set. This required 8.5 h and 55 GB of memory for chromosome 2. Extrapolating to the size of the human genome indicates it would require 4.5 days and 700 GB of memory to index 20 sequence data. While the computational time is tractable, the amount of memory required is not practical for the routine assembly of human genomes. We address ways to reduce the computational requirements in Section 5.For the overlap and assemble rows,-e and-d indicate the exhaustive and direct algorithms, respectively. The last column is the ratio between chromosome 2 and 22.
String graph constructionlower the amount of memory required by exploiting the redundancy present in a set of sequencing reads by using a compressed index. The compressed suffix array is one such index and a method was recently developed to merge two compressed suffix arrays that possibly allows a distributed construction algorithm (). Additionally, efficient external memory (disk-based) BWT construction algorithms have been developed that allow the construction of the FM-index for very large datasets while using a limited amount of main memory (). It is worth investigating the equivalency of the de Bruijn graph and string graph formulations (). This has been studied in terms of the computational complexity of reconstructing the complete sequence of the genome and both formulations have been shown to be NP-hard (). We would like to know the equivalence in terms of the information contained in the graph. Consider the case where all sequence reads are of length l and every l-mer in the genome has been sampled once. In this case, the de Bruijn graph and string graph constructions (using parameters k = l 1 and  = l 1 respectively) are equivalent. In the realistic case where the genome is unevenly sampled, the relationship is not clear. In the original paper on the EULER assembler Pevzner presents an algorithm to recover the information lost during the deconstruction of reads into k-mers by finding consistent read-paths through the k-mer graph (). It is conceivable that if this procedure is able to perfectly reconstruct the information lost the resulting graph would be equivalent to Myers' string graph. This is not clear, however, and the equivalency of these formulations is a question we would like to address.
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Page: i371 i367i373
DISCUSSION We have described an efficient method of constructing a string graph from a set of sequence reads using the FM-index. This work is the first step in the construction of a new, general purpose sequence assembler that will be effective for both short reads of the current generation of sequence technology and the longer reads of the sequencing instruments on the horizon. Unlike the de Bruijn graph formulation, the string graph is particularly well-suited for the assembly of mixed length read data. While the primary algorithms are in place, a considerable amount of work remains. Most pressing is the issue of adapting the assembler to handle real sequence data that contains base-calling errors. This amounts to adapting the algorithms to handle inexact overlaps. The BWA, Bowtie and SOAP2 aligners implement a number of strategies and heuristics for dealing with base mismatches and small insertion/deletions (Langmead et al., 2009; Li and Durbin, 2009; Li et al., 2009). These strategies directly translate to finding overlaps. Let be the maximum allowed difference between two overlapping reads. When performing the backwards search to find overlaps, we can allow the search to proceed to mismatched bases or gaps while ensuring that the bound is respected. We can similarly modify the irreducible overlap detection algorithm by allowing the right-extension phase to extend to mismatch bases or gaps. Here, we would only consider an interval to be transitive with respect to one of the irreducible intervals if the inferred difference between the intervals is less than. Our intention is to build an assembler that can handle genomes up to several gigabases in size, such as for human or other vertebrate genomes and our initial results indicate that our algorithms scale well. The introduction of sequencing errors will increase the complexity of the irreducible overlap identification step but this step is straightforward to parallelize if necessary because it is carried out for each non-contained read. The construction of the suffix array is currently the computational bottleneck; however, there are a number of established ways to improve this. We can i372 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
i373 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
