Motivation: The double cut and join operation (abbreviated as DCJ) has been extensively used for genomic rearrangement. Although the DCJ distance between signed genomes with both linear and circular (uni-and multi-) chromosomes is well studied, the only known result for the NP-complete unsigned DCJ distance problem is an approximation algorithm for unsigned linear unichromosomal genomes. In this article, we study the problem of computing the DCJ distance on two unsigned linear multichromosomal genomes (abbreviated as UDCJ). Results: We devise a 1.5-approximation algorithm for UDCJ by exploiting the distance formula for signed genomes. In addition, we show that UDCJ admits a weak kernel of size 2k and hence an FPT algorithm running in O(2 2k n) time. Contact:
INTRODUCTIONComputing genomic distance on gene order is a fundamental problem in computational biology. In the last two decades, a variety of biological operations, such as reversals, translocations, fusions, fissions, transpositions and block-interchanges, have been proposed to handle gene order. The double cut and join operation, introduced by, unifies all the classical operations. In the past, the rearrangement distance for signed genomes is well studied for single operations, like reversals (), combinations of operations (reversals, translocations, fusions and fissions) () and universal operations (double cut and join) (). Unfortunately, as for unsigned genomes, most of these problems seem to be NP-hard. Then it is natural to devise relevant approximation algorithms. A 1.5-approximation algorithm was devised for sorting by unsigned reversals (), and the approximation factor was improved to 1.375 byThe problem of sorting by unsigned translocations was investigated by, and an algorithm with an approximation factor of 1.5+ was proposed. Transposition, though occurring much less than reversal and translocation, is an indispensable operation in the evolutionary events. The problem of sorting by transpositions was first studied by, who devised a * To whom correspondence should be addressed. 1.5-approximation algorithm running in quadratic time. Later, the approximation factor was improved to 1.375 by. The problem of sorting by short block-moves, a special but more practical case of transpositions, was studied by Jiang and Zhu, 2011, and they obtained an 14/11-approximation algorithm. The design of FPT algorithms for genome rearrangement problems was started very recently, with the help of weak kernels. (Intuitively, an FPT algorithm is an exact algorithm which runs in polynomial time when the problem solution size, like the number of unsigned reversals to sort a sequence, is bounded by a constant. The relevant formal definitions will be given in the next section.) Both sorting by unsigned reversals and sorting by unsigned translocations admit small weak kernels, hence are in FTP (). As far as we know, the only known positive result for sorting unsigned genomes by minimum DCJ operations (or interchangeably, the unsigned DCJ distance problem) is a factor-1.416 approximation for the case of linear unichromosomal genomes (). Of course, even in this case the problem involves computing a maximum alternating-cycle decomposition (MAX-ACD) of the breakpoint graph, which is NP-complete (); therefore, it is not surprising that the unsigned DCJ distance problem is NP-complete, even for linear unichromosomal genomes (). Prior to our current work, there has been no FPT algorithm known for the unsigned DCJ distance problem.Our contributions: In this article, we introduce DCJ operations on unsigned linear multichromosomal genomes to compute the corresponding genomic distance. We devise a 1.5-approximation algorithm for linear multichromosomal genomes in Section 3. In Section 4, we obtain a weak kernel of size 2k for UDCJ; moreover, we present an FPT algorithm running in O(2 2k n) time.
PRELIMINARIESGene, chromosome and genome: An unsigned gene is a sequence of DNA, usually denoted by a positive integer. A chromosome can be viewed as a sequence of genes and denoted by a permutation, while a genome is a set of chromosomes. A gene that lies at the end of some linear chromosome is called an end-gene. Gene i and j form an adjacency if they are consecutive in some chromosome. An adjacency (g i ,g i+1 ) is perfect if it satisfies |g i+1 g i |=1. A chromosome is perfect if every adjacency is perfect. A genome is perfect if all its chromosomes are perfect. As a convention, we always list the genes in a perfect genome in increasing order. For instance, a perfect genome with 3 chromosomes and 10 genes can be listed as (1, 2, 3, 4), (5, 6, 7) and (8, 9, 10). We study unsigned linearBreakpoint graph: Above all, we recall the well-known tool for computing the genomic rearrangement distance, the Breakpoint Graph (). Given two unsigned genomes A and B on the same set of n genes, the Breakpoint Graph BG(A,B) = (V ,E b E g ), where |V |=n and each vertex in V corresponds to a gene, every adjacency in A forms a black edge belonging to E b and every adjacency in B forms a gray edge belonging to E g. It is known that in this case computing a maximum alternating-cycle decomposition in BG(A,B) is NP-complete (). As for signed genomes F and H, the breakpoint graph BG s (F,H) is a bit different. Due to the sign, each gene has one head and one tail corresponding to two vertices in the breakpoint graph. Consequently, the head has only one adjacency in F and H respectively, so does the tail. Then each vertex in the breakpoint graph has degree at most two, which means that the breakpoint graph is composed of cycles and paths, and the black edges and gray edges appear alternatively in the cycles or paths. So the maximum alternating-cycle decomposition is easy in this case. A cycle that contains l black edges is called an l-cycle.The double cut and join operations: The Double Cut and Join operation (abbreviated as DCJ) unifies all the traditional genome rearrangement operations such as reversal, translocation, fusion, fission, transposition and block interchange, as well as excision, integration, circularization and linearization. The formal definition of a DCJ operation on the breakpoint graph is as follows.Definition 1. The double cut and join operation acts on the breakpoint graph in the following four ways ():(1) For two black edges(3) For two end-genes g i and g j , join them with a black edgeNote that the black edges and end-genes involved in one DCJ operation can be in the same chromosome, then a circular chromosome may form after some DCJ operations. Problem statement: We now formally formulate the problem to be investigated in this article. Sorting unsigned genomes by the DCJ operations (UDCJ): Input: Two unsigned linear genomes A and B and an integer k. Question: Can A be converted into B by a series of k DCJ operations  1 , 2 ,..., k ? The minimum k is the unsigned DCJ distance between A and B. Following the results in (), UDCJ is also NP-complete. W.L.O.G, assume that B is perfect. Let l A and l B be the number of linear chromosomes in A and B, respectively, we can also assumethat l A  l B , since all the DCJ operations are reversible, which means that if there exists consecutive DCJ operations  1  2 ... m that convert A into B, then we can also convert B into A by
Structure properties of UDCJFor an unsigned genome A, a signed-version of A is obtained by assigning '+ or ' to each gene in A, with '+ signs usually omitted. Obviously, every genome of n genes has exponential, i.e. 2 n , signed versions. Given two signed genomes F,H, we use DCJ s (F,H) to denote their signed DCJ distance.Proof. Notice that, loosely speaking, we can take B = B +. () Assume that there exists a series of consecutive DCJ operations  1  2 ... m that convert A into B. We say that a DCJ operation  changes the sign of a gene g if  involves reversing a segment of genes including g. For each gene g in A, let T g denote the number of times that the sign of g is changed if we trace all the m DCJ operations. g is assigned ' , if T g is odd; and '+ , if T g is even. Then we obtain a signed version of A, A * , which can be converted into B + by the m equivalent signed DCJ operations.If there exists a signed version A * of A that can be converted into B + by m signed DCJ operations  1  2 ... m , then we can also use these m (signed) DCJ operations to convert A into B, ignoring the gene signs. Thus DCJ(A,B)We now proceed to obtain the necessary properties of the optimal solution. First of all, in order to avoid distinct end points of chromosomes in A and B, we add unlabeled caps to both ends of each linear chromosome in genomes A and B, respectively, then connect the A-cap and its adjacent end-gene with a black edge and the B-cap and its adjacent end-gene with a gray edge in BG(A,B). The above preprocess is called capping. Note that each gene in BG(A,B) has degree 4 after capping, i.e. with two black edges and two gray edges. After capping, genomes A and B become  A and  B, respectively. We denote the resulting graph by BG(  A,  B). As it seems to be hard to extract the properties of the optimal solution from BG(  A,  B) directly, we take a detour. We notice that, for signed genomes F and H, after capping each vertex in the breakpoint graph BG s (F,H) has degree two and each cap has degree one, which means that all the paths end with caps. A path with an A-cap end and a B-cap end (respectively, two A-cap ends, two B-cap ends) is an AB-path (respectively, AA-path, BB-path). There are three ways to construct cycles from BG s (F,H)in the breakpoint graph BG s (F,H) of signed genomes F and H, after capping .(1) single-identifying: identify the two caps of each AB-path, close the path into a cycle containing just one A-cap (with the B-cap eliminated).(2) double-identifying: identify each B-cap of a BB-path and each A-cap of an AA-path, join an AA-path and a BB-path into a cycle containing two A-caps (with the two B-caps eliminated).(3) joining: connect the two A-caps of an AA-path with a gray edge. Let BG s (  F,  H) denote the resulting breakpoint graph after constructing cycles from BG s (F,H) following the above three ways. Then the signed DCJ distance between the signed genomes  F and  H, DCJ s (  F,  H) = bc, where b is the number of black edges and c is the number of cycles in BG s (  F,  H) (). In, we show an example of  F,  H and BG s (  F,  H), before the identifying and joining operations are performed. In the figure, an empty round (respectively, square) node is an A-cap (respectively, B-cap); moreover, in BG s (  F,  H), a signed gene +i (respectively, i) is already converted to (2i1,2i) [respectively, (2i,2i1)]. After two single-identifying operations are performed, we have two new, before the identifying and joining operations are performed. cycles (6) and (9, 8, 4, 5, 14). After a double-identifying operation is performed, we have a new cycle (2, 3, 7, 1). After a joining operation is performed, we have a new cycle (12, 13). It is worth mentioning that this distance formula is equivalent to that of, i.e. DCJ s (F,H) = nC I/2, where n is the number of genes, C is the number of cycles and I is the number of odd paths in their corresponding adjacency graph. To see this, note that I also equals to the number of AB-paths in the breakpoint graph; in addition, we have bNotice that computing an alternating-cycle decomposition of BG(  A,  B) is equivalent to finding a signed version of  A. To extract the properties of the optimal solution, we first try to make use of the breakpoint graph BG(  A,  B) instead of BG(A,B). Following Corollary 1, we can now make use of the breakpoint graphis constructed, we only need to find an optimal  A * such that the number of disjoint alternating-cycles inis maximized. The reason is that the number of black edges in BG(  A,  B) is fixed. Then we havewhere b is the number of black edges in, respectively, and c 3 is the number of cycles with three or more black edges in, thus we have the following formula:Page: 314 311316
H.Jiang et al.The above formula implies that, if we can convert A into B by at most bc 1 c 2 /2 DCJ operations, then we obtain a 1.5-approximation algorithm for UDCJ.
The algorithmThe idea of our approximation algorithm is as follows. We compute BG(  A,  B) and try to first keep all the 1-cycles in it. Then we compute many 2-cycles from BG(  A,  B) (in fact, at least c 2 /2 such 2-cycles). We comment that a similar idea was used by Christie (1998) on sorting by unsigned reversals. On the other hand, the LP-relaxation algorithm by Chen, 2010 cannot handle paths (and caps) so it cannot be immediately generalized to solve our problem. The following lemma, which involves handling paths and caps,shows that keeping all the 1-cycles in BG(  A,  B) is a good strategy to obtain some optimal alternating-cycle decomposition of it.Proof. We modify the optimal alternating-cycle decomposition in BG(  A,  B) in such a way: if two genes, say g i and g i+1 , are connected by a black edge and a gray edge, then we reassign the signs of these two genes to obtain a 1-cycle; if a gene, say g i , is connected to an A-cap by a black edge and to a B-cap by a gray edge, then we reassign the sign of the gene and identify the two caps to obtain a 1-cycle. If the newly obtained 1-cycle contains two genes, then there are two cases. Case (I): Only one of the signs of g i and g i+1 is changed. W.L.O.G, assume that the sign of g i is changed, see. The number of cycles is increased by one. Case (II): Both of the signs of g i and g i+1 are changed, seed. The number of cycles is increased by two or one or unchanged, respectively. If the newly obtained 1-cycle contains one gene and a cap (which is identified by an A-cap a and a B-cap b), then there are four cases. Note that b must be identified with some A-cap a. Case (1): The A-cap a joins with another A-cap a. The number of cycles is unchanged. SeeIt is sufficient to prove that G 2 does not contain cycles. Assume to the contrary that 2-cycles C 1 C 2 ...C r form a cycle in G 2 , where C i shares gray edge g i with C i+1 , 1 i  r 1, and C r shares g r with C 1. Then C 1 contains two gray edges g 1 and g r , but the end points of g 1 and g r cannot form two black edges (otherwise these two black edges will force into some black cyclewhich implies that the input genome contains some circular chromosome). See. It is obvious that every 2-cycle containing caps has degree at most one in G 2 , because the gray edge containing caps cannot be shared by two 2-cycles computed from M. The property we just proved in Lemma 3 is important for us to compute a maximum independent set in G 2 (without this property, the computation of a maximum independent set might be intractable). Lemma 3 immediately implies the next lemma. Lemma 4. Let S be a maximum independent set in G 2 , then |S| |M| 2. Note that if a gene is contained in some 1-cycle, then its sign can be fixed easily, i.e. if the black edge reads from (left to right) like (i,i+1) then both genes i and i+1 will be given positive signs, otherwise they will be given negative signs. If a gene is contained in some 2-cycle, its sign is fixed similarly. For instance, if in a 2-cycle the two black edges read like (i,j),(i+1,j +1) (from left to right), then the signing should be +i,j,(i+1),+(j +1). The other cases, e.g., when the directions of these black edges are possibly changed, are very much symmetric hence omitted. To complete the cycle decomposition, we arbitrarily assign signs to the remaining genes, then properly identify and join the remaining caps in the corresponding breakpoint graph. The complete Whole-Cycle Decomposition algorithm is presented as follows.
Sorting by DCJ operationsIn other words, if the DCJ distance is equal to or smaller than k, there are at most 2 2k signed versions of A among which there must be an optimal one (e.g. A * in Theorem 1). For each signed version of A, we can exploit the algorithm in;to check whether it can be converted into B + by k or few DCJ operations. If so, we can compute the corresponding k unsigned DCJ operations to convert A into B. If no valid solution is found, we report NO. This algorithm clearly runs in O(2 2k n) = O * (2 2k ) time.
DISCUSSIONIn this article, we devise the first approximation algorithm with a factor of 1.5 and an FPT algorithm running in O(2 2k n) time for the NP-complete problem of sorting linear multichromosomal genomes under unsigned DCJ distance. It is interesting to improve the approximation factor as well as the running time of the FPT algorithm. For genomes containing circular chromosomes, our approximation algorithm cannot achieve the same performance as linear genomes, so it is also meaningful to handle the problem of sorting mixed genomes (i.e. with both linear and circular chromosomes) under unsigned DCJ distance.
The Author 2010. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
, where  1 i is the reversed operation of  i. FPT and weak kernel: Basically, a fixed parameter tractable (FPT) algorithm for a decision problem with solution value k is an algorithm, which solves the problem in O(f (k)n c ) = O * (f (k)) time, where f is any function only on k, n is the input size and c is some fixed constant not related to k. FPT also stands for the set of problems that admit such an algorithm (Downey and Fellows, 1999; Flum and Grohe, 2006). Weak kernel is a relatively new concept; intuitively, it refers to the direct or indirect 'search space' to solve a search problem. For a search problem in NP, if it admits a weak kernel of size g(k), then it is in FPT (Jiang et al., 2010). We comment that weak kernel is different from the traditional kernel in which the problem instance size is reduced (to a function of k), while a weak kernel only implies that the direct or indirect solution search space is reduced (to a function of k). More details can be found in (Jiang et al., 2010). 3 A 1.5-APPROXIMATION ALGORITHM In this section, we present a 1.5-approximation algorithm for double cut and join distance on unsigned multilinear genomes. We first comment that the method by Chen (2010) cannot be converted to solve our problem, as with multilinear genomes the underlying breakpoint graph is more complex (i.e. possibly with many paths). Given an original genome A with l A chromosomes and a target perfect genome B with l B chromosomes, our goal is to convert A into B by a series of DCJ operations so that the number of DCJ operations is as few as possible. To design an approximation algorithm, we first need the structure properties of UDCJ, which in fact can be obtained from the corresponding signed genomes.
Following Lemma 1, we know that keeping all the 1-cycles in in BG(  A,  B) will not affect the value of some optimal alternating-cycle decomposition of it. Therefore, from now on we only focus on the optimal alternating-cycle decomposition of BG(  A,  B), which always keeps all the 1-cycles. Consequently, in order to approximate the optimal DCJ distance, we just need to find out as many as at least half of the 2-cycles in an optimal alternating-cycle decomposition of BG(  A,  B) (which keeps all 1-cycles). Now we present the algorithm 2-Cycle Decomposition to compute such 2-cycles. In this algorithm, we first construct a graph G 1 whose vertices are the black edges (not in any 1-cycle) in BG(  A,  B) and M is a maximum matching in G 1. Note that the maximum matching M can be computed in polynomial time (Galil et al., 1986); moreover, each edge in M results in a candidate 2-cycle. In order to bound the cardinality of S, we need the following lemmas. Lemma 2. Let M be a maximum matching in G 1 , then |M|c 2. Proof. Following the discussion in Section 3.1, c 2 corresponds to the number of 2-cycles in an optimal alternating-cycle decomposition of BG(  A,  B). These 2-cycles clearly form a matching in G 1. By the maximality of M, we have |M|c 2. Algorithm 2-Cycle Decomposition Input: BG(  A,  B)
Proof. All 2-cycles computed at Step 2 cannot share black edges. Since each gray edge is connected to at most four black edges, at most two 2-cycles which do not share black edges can share this gray edge. Equivalently, each gray edge can belong to at most two cycles computed from M. Each 2-cycle has two gray edges, so each vertex in G 2 has degree at most two.
)  2k. Following Lemma 1, we can assign signs to all genes involved in 1-cycles. So each of the remaining gene is connected to two black edges, and each black edge has at most two unsigned genes as its end points, which means that the number of unsigned genes N is bounded by the number of black edges not involved in any 1-cycle, e.g. N  bc 1  2k. Hence, the problem admits a weak kernel of size 2k.
