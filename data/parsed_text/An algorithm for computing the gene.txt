Motivation: Gene tree represents the evolutionary history of gene lineages that originate from multiple related populations. Under the multispecies coalescent model, lineages may coalesce outside the species (population) boundary. Given a species tree (with branch lengths), the gene tree probability is the probability of observing a specific gene tree topology under the multispecies coales-cent model. There are two existing algorithms for computing the exact gene tree probability. The first algorithm is due to Degnan and Salter, where they enumerate all the so-called coalescent histories for the given species tree and the gene tree topology. Their algorithm runs in exponential time in the number of gene lineages in general. The second algorithm is the STELLS algorithm (2012), which is usually faster but also runs in exponential time in almost all the cases. Results: In this article, we present a new algorithm, called CompactCH, for computing the exact gene tree probability. This new algorithm is based on the notion of compact coalescent histories: multiple coalescent histories are represented by a single compact coalescent history. The key advantage of our new algorithm is that it runs in polynomial time in the number of gene lineages if the number of populations is fixed to be a constant. The new algorithm is more efficient than the STELLS algorithm both in theory and in practice when the number of populations is small and there are multiple gene lineages from each population. As an application, we show that CompactCH can be applied in the inference of population tree (i.e. the population divergence history) from population haplotypes. Simulation results show that the CompactCH algorithm enables efficient and accurate inference of population trees with much more haplotypes than a previous approach. Availability: The CompactCH algorithm is implemented in the STELLS software package, which is available for download at
IntroductionConsider n gene lineages sampled from one population. When we trace these lineages backward in time, sooner or later two of these lineages will find a common ancestor. When this occurs, we say these two lineages coalesce or the coalescent of these two lineages occurs. Gene lineages coalesce in a stochastic way, which is influenced by multiple population genetic parameters, such as population sizes. Therefore, coalescents may potentially reveal important aspects of population evolution.introduced the coalescent theory, which provides the analytical foundation for the study of coalescents. Since then, coalescent theory has quickly become a very active research subject in population genetics. There are numerous theoretical results in coalescent theory, along with many coalescent-based software tools. See Wakeley (2008) andfor an overview of the growing field of coalescent theory. While mathematically appealing, coalescent is known to be challenging computationally. One of the most important problems on coalescents is computing the coalescent likelihood. That is, we want to compute the probability of observing some population variation V C The Author 2016. Published by Oxford University Press.
i225This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/4.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.comi233 doi: 10.1093/bioinformatics/btw261 ISMB 2016 data under a coalescent model. However, coalescent likelihood is well known to be difficult under most formulations [see e.g.. At present, there are few polynomial time algorithms for computing coalescent likelihood except under very restricted conditions. Almost all existing approaches for coalescent likelihood computation are based on statistical techniques such as Markov chain Monte Carlo (MCMC) or importance sampling (). These statistical approaches can be very useful in practice. However, from the computational point of view, these approaches cannot compute the exact coalescent likelihood. Moreover, approaches using MCMC tend to be very slow. Since coalescent likelihood is usually used in the inference of population evolution, accurate and efficient coalescent likelihood computation is highly desirable. Since the work by, the basic coalescent has been extended to address more aspects of population evolution. The multispecies coalescent is one such extension, and is the focus of this article. Multispecies coalescent concerns the coalescents among gene lineages from multiple populations where coalescents may cross the population boundary. Multispecies coalescent is fundamental to population evolution (). Multispecies coalescent has also found applications in other domains, such as species tree inference [see, e.g.. A key computational problem on multispecies coalescent is the computation of the gene tree probability (). Here, we are given a gene tree topology (without branch lengths) and a species tree (with branch lengths in the standard coalescent units). Note that the gene tree may not be bifurcating and there can be more than one gene lineages for a population (or taxon) in the gene tree. The gene tree probability is the probability of the gene tree topology as a result of the multispecies coalescent within the given species tree. There are only two existing algorithms for the exact gene tree probability computation. The first such algorithm is due to. However, their algorithm has the exponential running time and there are no known cases of species and gene trees for which their algorithm runs in polynomial time. A much faster algorithm is given in, which is implemented in the program STELLS. However, the STELLS algorithm computes the gene tree probability in polynomial time only for some very special types of gene trees and species trees. We are not aware of any statistical approaches for computing the gene tree probability. The closest related approach is the MCMC approach in, which is also based on multispecies coalescent. However, the likelihood computed in Heled and Drummond (2010) is for DNA sequences, not for gene trees. In this article, we present a new algorithm, called CompactCH, for computing the exact gene tree probability. The main advantage of CompactCH is that it runs in polynomial time for any gene tree topologies and species trees when the number of taxa (populations) is fixed to be a constant. That is, the CompactCH algorithm is efficient for gene tree topologies with large number of gene lineages if the number of populations is small (i.e. there can be many gene lineages from each population). Note that although the number of gene lineages in many phylogenetic studies tends to be relatively small, the number of gene lineages in large-scale genetic studies can be large. Therefore, CompactCH may become more useful when more gene lineages are sampled from a population which is the case in genetic projects such as the 1000 Genomes Project (2015). To the best of our knowledge, CompactCH is the first algorithm for computing the gene tree probability in polynomial time that allows arbitrary gene trees and species trees when the number of populations is fixed to a constant. Note that if gene tree topologies are considered to be observed, then the gene tree probability is the likelihood of the observed gene tree topologies given the species (population) tree. In this regard, the coalescent likelihood of gene tree topologies can be computed in polynomial time under the assumption of small number of populations. We show through theoretical analysis and empirical simulations that CompactCH outperforms the existing STELLS algorithm when the number of populations is small and the gene tree contains multiple gene lineages (alleles) per taxon. We also present a new method for the inference of population divergence history (called the population tree) from large population samples, which is based on the CompactCH algorithm.
Background
Multispecies coalescent and incomplete lineage sortingIn this article, we use population and species interchangeably. Multispecies coalescent process (or just multispecies coalescent) concerns the coalescents of gene lineages that may occur outside the species boundary. Seefor an illustration. Multispecies coalescent lies at the intersection of population genetics and phylogenetics, and has been widely used in phylogenetic and population inference [see e.g.. We use a rooted bifurcating tree T s (with branch lengths) to represent the population divergence history. We use a rooted tree topology T g to represent the genealogical history of gene lineages at a single locus. It is important to note that T g does not have branch lengths. Also T g may be multifurcating if the gene genealogy cannot be fully determined from the given genetic data. A common observation is that T s. A gene tree (in thin lines) in the species tree (in thick lines) shown in (a). Gene lineages a 1 , a 2 and a 3 originate from species A, b 1 and b 2 from B and c 1 from C. The species tree T s is shown separately in (b), so is the gene tree T g in (c). Internal nodes of both T g and T s are labeled. Coalescents: internal nodes of T g. Branches of trees are represented by their lower nodes i226 Y.Wu and T g do not always have the same topology. This phenomenon is called incomplete lineage sorting. We define the gene tree probability to be the probability of observing T g for a given T s under the multispecies coalescent model. Computing the probability of gene genealogies under multispecies coalescent is central both to phylogenetic inference of a species (or population) tree and to population genetic inference of gene flow between populations [e.g.. When T s and T g are small, simple closed-form formulas are known to calculate the gene tree probability (;). When T g and T s become larger, computation by hand is no longer feasible and an algorithm is needed.
Computing gene tree probability using coalescent historyDegnan and Salter (2005) gave the first algorithm for computing the gene tree probability of a gene tree topology T g and a species tree T s. Their algorithm is based on the notion of coalescent history. We give parts of technical details of their algorithm because our new algorithm is an improvement over their algorithm. In the following, we use the lower (i.e. closer to the leaves) node of an edge to refer to the branch in a tree T. For example, when we say branch g in, we mean the branch with lower node g in T g. Each internal node v in T g corresponds to a coalescent event between two lineages. For simplicity, we use v to also refer to the coalescent at v. For example, in, the node g corresponds to a coalescent between lineages a 1 and a 2. A coalescent history determines, for each coalescent v in T g , on which species tree branch v occurs. In, for example, the embedded T g within T s corresponds to a coalescent history. In this history, coalescent g occurs on species tree branch A, p on D and h, q and r on E (the root branch). Note that the precise positions of these coalescents within T s are not important since T g does not have branch lengths and thus branches of T g may be stretched or shrunk as long as the coalescents occur within the same species tree branches. Degnan and Salter's algorithm enumerates all possible coalescent histories h for the given T g and T s. We denote the set of all coalescent histories for T g and T s as HT g jT s . We let m be the number of branches in T s and use an integer b 2 1. .. m to refer to a branch in T s. We let k b be the branch length of the branch b in T s. Then.Here, we call the number of gene lineages at the bottom (respectively top) of a species tree branch b the lower (respectively upper) lineage count of b and denote as u b (respectively v b ). Recall that a coalescent history h specifies along which species tree branch each coalescent occurs. Thus, when h is given, both the upper and lower lineage counts of each species tree branch are known. So we use u b h and v b h to refer u b and v b specified by h. For example, consider the branch A and let h be the coalescent history shown in. Then u A h  3 and v A h  2. p uv T is the probability of u lineages coalesce into v lineages within time T (where T is the in the standard coalescent units). Equation (2) is a classic result (The reason why there are terms w b h d b h in Equation (1) is that p uv T does not impose the order of coalescents as specified in T g. For example, consider the coalescent history h shown inii  1 2 :The w b h term is a little more complex. It is equal to the number of ways of coalescents on branch b as specified by h where these coalescents match the topology of T g. Note that there are c b h  u b h  v b h coalescents on branch b. We denote these coalescents as C b h. For convenience, we use c b h to denote the number of coalescents along a species tree branch b. There are c b h! ways of ordering these coalescents, but only a subset of these ways match T g. For each coalescent u 2 C b h, let n u h; b be the number of coalescents in C b h that are within the subtree rooted at node u in T g. Here, u is included in the subtree. For example, we again consider the coalescent history h in. Then n r h; E  3 and n h h; E  n q h; E  1. Note only coalescents within branch E are considered here and thus the coalescents p and g are not counted for n h h; E and n q h; E. Note that among all possible permutations of c b h coalescents (with u being one of the coalescents), we want those with u be placed after the n u h; b  1 coalescents. There is precisely one out of n u h; b permutations with this property. Then, we have ():1 n u h; b :As an example, for the coalescent history h in,However, except the simple caterpillar trees (or trees very similar to caterpillar), there are no known cases where STELLS can compute the gene tree probability in polynomial time. Usually the STELLS algorithm becomes slow when the sizes of T g and T s increase.
The CompactCH algorithm for computing gene tree probabilityWe now present a new algorithm, called CompactCH, for computing the exact gene tree probability. CompactCH builds on Degnan and Salter's algorithm, and is very different from the STELLS algorithm. The key idea of the CompactCH algorithm is combining multiple coalescent histories into a compact coalescent history and thus making the computation in Equation (1) more efficient. For the ease of exposition, we assume gene trees are bifurcating unless otherwise stated. We will later extend to the multifurcating gene tree case.
Gene tree probability computation using compact coalescent historySince our algorithm involves a number of notations, we provide a list of notations in the Supplemental Materials. We first recall that Equation (1) is a summation of products over coalescent history h. Each product consists two terms for each species tree branch b: the coalescent factor term w b h d b h and the coalescent probability term p u b hv b h k b . The coalescent probability term only depends on the upper and lower lineage counts of the branch b. Suppose we group the coalescent histories with the same upper and lower lineage counts for every species tree branch into a compact coalescent history ch. Then all these histories will have the same coalescent probability terms. More precisely, a compact coalescent history is a list of upper lineage counts at all species tree branches (except the root branch). For example, consider the coalescent history shown in. We arrange the upper lineage counts for species tree branches in the order of A, B, C and D. Then the corresponding compact coalescent history ch is represented as: {2, 2, 1, 3}. That is, there are two, two, one and three gene lineages at the top of A, B, C and D, respectively. We denote the set of all possible compact coalescent histories for the given T g and T s as CHT g jT s . A compact coalescent history can be viewed as the combination of one or multiple coalescent histories. As an example, consider T g and T s in. There are total seven compact coalescent histories as shown in. The compact history {2,2,1,3} combines two coalescent histories: the history shown in shown inand the history with h as the only coalescent occurring within branch D and p occurring within the branch E.While a compact coalescent history only specifies the upper lineage counts, Lemma 3.1 shows that both upper and lower lineage counts as well as the number of coalescent events on all species tree branches (including the root branch) are all fully determined by a compact coalescent history. Lemma 3.1. The lower and upper lineage counts, and the numbers of coalescent events along all species tree branches are determined by a compact coalescent history.
Proof.Recall a compact coalescent history specifies the numbers of gene lineages on top of each species tree branch (except the root branch). Note that for the root r, the upper lineage count v r is always one. This is because all gene lineages must coalesce into one lineage within the root branch. Consider a species tree branch b. If b is a leaf branch (i.e. one of the nodes of b is a leaf in T s ), its lower lineage count is equal to the number of sampled linages from this leaf, which is given as part of the input. This is because there is no time for coalescent to occur at a leaf of T s. Let b be an internal branch. Let Desc(b) be the set of descendant branches of T s (i.e. these branches are the outgoing edges from the lower node of b). For example, in, DescE  fC; Dg and DescD  fA; Bg. Then, u b  P x2Descb v x. This is because the lineages at the top of the descendant branches of b enter b from below. Thus, the set of lineages at the lower node of b is simply the merged set of the sets of lineages at the top of all b's descendant branches. Note that this merging process is instantaneous and there is no time for coalescent to occur. Note that the number of coalescents on b is simply equal to the difference between the lower and the upper lineage counts at b. Therefore, the number of coalescent events on b is fully determined by the compact history for all b. From Lemma 1, we use u b ch and v b ch to denote the lower and upper lineage count at branch b, and c b ch as the number of coalescents on b, which are specified by the compact coalescent history ch. We now consider Equation (1) again. Note that each coalescent history can be mapped to a compact coalescent history. For a compact coalescent history ch, let Hch be the set of coalescent histories combined in ch. We now group the coalescent histories in Hch together for each ch when applying Equation (1). Note that for all histories h in Hch, u b h (respectively v b h) are the same. Thus they have identical coalescent probability terms p u b chv b ch k b  terms in the summation over Hch. Moreover, we have the same 1 d b ch terms. This is because according to Equation (3), 1 d b h only depends on u b h and v b h, which are identical for histories in Hch. This allows us to extract the common product of theCCH: compact coalescent history (the numbers are the numbers of upper lineage counts for species tree branches A, B, C and D). For each compact history, we give the number of coalescent histories that are merged into this compact history (denoted as #histories). i228 Y.Wu
Efficient computation of coalescent coefficientWe first note in Equation (4), c b h  u b h  v b h. Thus, for all h in Hch, c b h can be written as the same c b ch. So,nuh. Note that the species tree branch b is implicit in C 1 ch. In C 1 ch, the term 1 nuh depends on specific h because the numbers of coalescents along species tree branches depend on h. When the number of h is large, direct summation of these 1 nuh terms is inefficient. We now show C 1 ch can be computed efficiently using a recurrence. For the remaining part of this section, we consider a specific ch. Thus, we omit ch [e.g. by writing C 1 ch as C 1 and. We consider each coalescent (internal node) c in T g. We denote the species tree branch on which c occurs as b c. We denote the number of coalescent events that are within the subtree of T g rooted at c and occur on b c as n c. We denote the set of species tree branches below (and including) b as Bb. That is, b 2 Bb. Here, c itself is considered to be within the subtree rooted at c and thus is included in n c. We denote S c as the set of species tree branches where the coalescent c may occur. For example, In, BD  fA; B; Dg and S g  fA; D; Eg. b h  E, b q  E, n r  3 (including coalescents r, h and q) in the coalescent history shown in. We denote the list of the numbers of coalescents on each species tree branch as n. We define unit vector v i as the vector where v i i  1 and v i j  0 when j  i. For a specific integer list n of length m, we say n s is a sublist of n if 0 n s i ni for all 1 i m. We denote the set of all possible sublists of n as Sn. For example, suppose n  2; 2; 1; 3. Then a possible sublist is. For a coalescent c, a branch b s of T s and an integer list n, we define:That is, C 2 c; b s ; n restricts C 1 to the subtree rooted at c where c occurs on b s and the numbers of coalescents within the subtree rooted at c is n. We impose the following constraints for C 2 c; b s ; n. If any of the constraints is violated, we have C 2 c; b s ; n  0. (1). n only specifies coalescent numbers for species tree branches in Bb s  (i.e. either at b s or within the subtree below b s : nb  0 for any b 6 2 Bb s .. There is at least one coalescent at b s : nb s  ! 1. Moreover, b s 2 S c. We let b r be the root branch of T s and c r be the root of T g. Note that we assume there is at least one gene lineage from each species. Then c r must occur on b r. We have:Here, cch refers to the list of upper lineage counts implied by the compact history ch. We initialize the computation of C 2 c; b s ; n for the coalescent c, where there is no coalescent within the subtree of T g rooted at c except c (i.e. c is the lowest coalescent in T g :Case 2: both immediate descendants c 1 and c 2 of c are internal nodes. In this case, we need to split n  v bs into two parts, one for c 1 and one for c 2. Then, we may sum over all such partitions and all possible species tree branches where c 1 and c 2 may occur.
The CompactCH algorithm for computing the gene tree probabilityThe CompactCH algorithm for computing the gene tree probability is as follows.1. Enumerate and compute all coalescent coefficients for T g and T s as in Equations (8) or (9). 2. Enumerate all compact coalescent histories ch for T g and T s. The enumeration can be performed in a bottom-up way. Compute the terms p u b chv b ch k b  and d b ch for each species tree branch b. Obtain Cch using Equations (6) and (7). 3. Compute the gene tree probability by summing over all compact coalescent histories using Equation (5).CompactCH runs in polynomial time in the number of gene lineages when the number of populations is fixed to be a constant. The gene tree probability computation in Equation (5) depends on the number of compact coalescent histories N T g ; T s  for the given T g and T s , which in turn depends on the number of gene lineages n and the number of species tree branches m. The main advantage of our new algorithm is that it runs in polynomial time when there are constant number of species. The algorithm is more efficient than the existing algorithms when there are multiple gene lineages per species. Thus, we assume m is fixed to a constant. We first show that N T g ; T s  is polynomial in terms of n when m is a constant. We then show that coalescent coefficient is polynomial time computable for each compact history. First, recall that a compact coalescent history consists of a list of the upper lineage counts, one for each species tree branch. For a T s with m species tree branches, the length of this list is m  1, and at each position of the list the upper lineage count is at most n  1. So the number of choices for each position is n. Therefore, there are at most n m1 compact histories. When m is fixed to be a constant, this is polynomial in n. For each compact history, Equation (5) takes O(m) time. So, the total time is Omn m1 . We now show coalescent coefficient computation in Equation
Analysis of the CompactCH algorithm(6) runs in polynomial time for a given compact coalescent history ch in a bifurcating T g when m is a constant. These coalescent coefficients are pre-computed before Equation (5) is evaluated. By Equation (7), we need to show C 2 c r ; b r ; cch can be computed efficiently. Note that C 2 c r ; b r ; cch is computed using a recurrence over C 2 c; b; n. Here, c is a coalescent in T g , b is a species tree branch and n is the list of coalescent counts (i.e. the number of coalescents) for the branches with the subtree of T s rooted at b. The number of such C 2 c; b; n is bounded by n  1mn  1 m , which is a polynomial of n when m is a constant. Each C 2 c; b; n can be computed by Equations (8) or (9) in Om 2 n  1 m  time. So, all coalescent coefficients can be computed in Onm 3 n  1 2m  time. Therefore, we have: Theorem 3.2. The CompactCH algorithm runs in Om 3 n 2m1  time for a bifurcating T g , which is polynomial in n when the number of species in T s is a constant. REMARK. The CompactCH algorithm computes the gene tree probability runs in polynomial time in n when m is fixed to be constant. At the first glance, the CompactCH algorithm appears to be very slow: when m  3 (i.e. two populations), the running time is On 7 . In practice, CompactCH appears to be significantly faster than the STELLS algorithm when m is small. This is because we may overestimate the number of needed steps (e.g. for computing the coalescent coefficients).shows that when there are two populations, the CompactCH algorithm can remain practical when n is as large as 200 where the STELLS algorithm becomes very slow. See the Section 5 for empirical performance of this algorithm. It can be shown that STELLS runs in exponential time in the number of gene lineages when there two populations. See the Supplemental Materials for details.
Multifurcating gene treesSo far, gene trees are assumed to be bifurcating. The original STELLS algorithm () and the algorithm in Degnan and Salter (2005) also assume bifurcating gene trees. Multifurcating gene trees, however, may be preferred for gene tree probability computation in some cases. For example, it is possible that some splits in the gene trees do not have sufficient support and thus multifurcating gene trees may be used to allow uncertainty in gene tree topologies. The STELLS algorithm was extended to allow multifurcating gene trees in Wu (2015). The STELLS algorithm is slower for multifurcating trees than bifurcating trees. Our new algorithm can be extended to compute the gene tree probability for multifurcating gene trees. Compact coalescent histories remain the same as the bifurcating gene tree case. For each species tree branch b, we specify the number of gene tree lineages at the top of b. Note that at a multifurcating gene tree node v of outdegree d, there are d  1 coalescents at v. For a given compact coalescent history ch and a species tree branch b, the terms p u b chv b ch k b  and d b ch can all be easily computed as before. This is because these terms only depend on the numbers of gene lineages at specific positions of T s , which are fully determined by ch. These terms do not depend on the topology of T g. The main difference of the multifurcating gene tree case is on the coalescent coefficient computation. At a gene tree internal node c with out-degree d, recurrences in Equations (8) and (9) need to be modified. Let D c be the set of c's children in T g that are internal nodes. We let SD c  be the set of all possible proper subsets of D c. We define C 3 c; b s ; S; n for S 2 SD c , a branch b s of T s and an integer list n in the same way as C 2 c; b s ; n when we treat the lineages in S form a new split in T g. Then, following the same reasoning as in Equations (8) and (9):Here, n 0 and n 00 are two integer lists which combine to n  v bs. Thus, coalescent coefficients for multifurcating T g can be computed in a recursive way, similar to the bifurcating case. The running time for coalescent coefficient computation depends on the maximum degree d max in T g. Since there are 2 dmax  2 non-empty proper subsets for d max gene lineages, the algorithms becomes slow when d max is large. If d max is bounded by a constant, the gene tree probability for a multifurcating tree can be computed efficiently when the number of species is small.
Inference of population tree from haplotypes from pairwise population distanceIn, we demonstrate that gene tree probability can be used in the inference of population tree (i.e. the population divergence history) when the given data is in the form of haplotypes.Briefly, haplotypes contain the alleles (states) at closely linked genetic variation sites. See e.g.for some background on haplotypes. Assuming population haplotypes satisfy the infinite sites model of mutations () and no intra-locus recombination, we may infer the underlying genealogical tree topologies, although these trees are usually multifurcating [see, e.g.. For a single locus, there is a unique gene tree topology and there are mutations on the branches of the gene tree. Under the infinite sites model of mutations and with no recombination, the probability of haplotypes is exactly equal to the probability of the unique gene tree with mutations [see, e.g.. For the sake of computational efficiency, the approach in Wu (2015) uses the probability of the gene tree topology (i.e. ignoring mutations) to approximate the probability of haplotypes. The probability of gene tree topology is easier to compute than that of haplotypes and can be used to infer the population tree by maximum likelihood (). See Wu (2015) for more details. We use the same approximation in this article. In Wu (2015), we demonstrate that population tree inference with gene tree probability performs well when compared with the program TreeMix (). STELLS infers population trees by searching the tree space to find the maximum likelihood estimate of the population tree. However, one main computational challenge in Wu (2015) is the computational efficiency: population tree inference becomes slow when the numbers of taxa and hapotypes increase (see the Section 5). Genetic studies now routinely involve ten or more populations, and multiple haplotypes are collected from each population. For example, the 1000 Genomes Project (2015) recently released over 1000 genomescale haplotypes from more than 20 populations. Such large-scale genetic data imposes huge challenges for inference. In this article, we develop a new population tree inference method based on the CompactCH algorithm. This method is distance based, and does not perform maximum likelihood inference. The main idea of our method is (i) first infer the distance of pairs of two populations using haplotypes from the two populations, and (ii) construct the population tree using neighbor joining from the inferred pairwise population distances. The key is in the population distance estimate. There is exactly one population tree topology (i.e. population divergence history) of two populations A and B. With the haplotypes from A and B (and the implied gene genealogies), we can infer the branch lengths d A and d B. Here d A (respectively d B ) is the length of the branch connecting A (respectively B) and the common ancestor of A and B in the species tree of A and B. This can be done by optimizing d A and d B to maximize the gene tree probability of the genealogies. See) for more details. Once d A and d B are estimated, the pairwise distance between A and B is estimated to be d A  d B. Then these pairwise distances are then used to infer the population tree of all populations by neighbor joining. The CompactCH algorithm enables fast pairwise population distance estimate from large number of haplotypes. In the Section 5, we demonstrate that this simple method can give accurate population tree inference using more haplotypes per population than the original method in Wu (2015) can handle.
ResultsWe have implemented our new CompactCH algorithm as part of the STELLS program (http://www.engr.uconn.edu/ywu/STELLS. html). We compare with the STELLS algorithm, which is currently the best algorithm for computing the gene tree probability. We first show that CompactCH outperforms the original STELLS when the number of species is small and there are multiple gene lineages per species. Then, as an application, we show that CompactCH allows fast and accurate inference of population trees from haplotypes when there are multiple haplotypes from each population.
Performance of CompactCH in gene tree probability computationWe evaluate the efficiency of CompactCH in computing the gene tree probability. We first set the number of populations m p to be two, three and four. We randomly generate species trees. We let the number of gene copies g c to be 1, 2, 5, 10, 20, 50 and 100. Note the total number of haplotypes n is g cm. We generate 500 bifurcating gene trees for a species tree using the program ms (). The running times of using CompactCH and STELLS to compute the probability of these 500 gene tree topologies for each simulated species tree are shown in. Both algorithms are very slow on many settings where both m p and g c are large. So no results are collected on these settings. Here, we say the computation is too slow if the computation does not finish within 15 days on a 3192 MHz Intel Xeon workstation running Linux (with 32 GB memory). Our second simulation aims to investigating the efficiency with larger number of populations. We fix g c to be one, and then run CompactCH and STELLS on the data. The results are shown in. As expected, the STELLS is more efficient than CompactCH for larger number of populations. Overall, CompactCH is much faster than STELLS when m is relatively small and g c is relatively large.
Using CompactCH in population tree inference from haplotypesWe run CompactCH and STELLS to infer population trees on simulated data. The design of simulations is similar to that in. Briefly, we generate simulated datasets as follows. We use randomly generated populations trees with m p populations to model the population divergence history. Here, we let m p to be eight. The population trees are the same as in. The length of each branch in the tree is assigned to a length that is uniformly chosen between 0.0 and 1.0. We then scale the population trees so that the trees satisfy clock property and the trees have fixed heights (being either 0.1 or 0.5). Note that CompactCH does not require clock-like population trees. The clock property is mainly for the ease of simulation, where we can reduce the number of parameter combinations. Then we simulate haplotypes for 100 loci from a given population tree using the program ms Hudson (2002), where there are g c gene lineages per species. Mutation parameters are fixed to be 20. We assume constant population size, no recombination within each locus and no migration between populations. Recall that the inferred genealogical tree topologies from haplotypes are usually multifurcating, and CompactCH becomes slow when the gene tree topologies have large degree at internal nodes. Thus, we discard gene trees with node degree larger than 10. We use the normalized RobinsonFoulds (RF) distanceAlgorithm for computing the gene tree probability i231 to measure the inference error in the topology. That is, for the inferred population tree topology T and the true tree T  with n taxa, the normalized RF distance is bT ; T    jBT ;T  j n3. Here, BT ; T   is the number of splits in T  but not in T. It has been demonstrated inthat the inference of population trees from these inferred genealogical tree topologies can give accurate results. In, we show that more accurate inference results can be obtained by using the pairwise population distance approach (denoted as CompactCH) in Section 4 than the STELLS approach (denoted as STELLS), when more haplotypes are used. These simulations are conducted on a computer cluster. STELLS is more accurate than CompactCH when only two haplotypes are used for each population. The main advantage is that CompactCH is much more scalable than STELLS: STELLS takes more than 5 h on average for each dataset with two alleles per population. CompactCH only takes seconds in this case. Note that STELLS can be more accurate than the results by CompactCH because STELLS uses the maximum likelihood approach to search in the tree space while CompactCH builds trees from pairwise distances. The accuracy of CompactCH increases when more haplotypes are provided. For example, when 20 or more haplotypes per population are used for the population trees of height 0.1, the inference error of CompactCH is only about one-third of that of STELLS which uses two alleles per population. It appears CompactCH performs relatively better for the species tree of height 0.1 than those of height 0.5. We also note that CompactCH becomes slow if a large number of haplotypes are analyzed. For comparison, we also run TreeMix on these data. Our results indicate that CompactCH outperforms TreeMix in most of the cases, especially for the case of shorter species tree height.These gene trees are then used to infer the population trees. Here, we discard gene trees that have out-degrees at internal nodes of nine or larger because gene trees with large degrees greatly slow down the computation. We first infer the population tree for four populations: CEU, CHB, JPT and YRI. As expected, CHB and JPT are close siblings and in the population tree, and the ancestral population of CHB and JPT is the sibling of CEU. We then infer the population tree for all ten populations (which takes less than 2 h). The inferred neighbor joining tree is shown in. Note that the tree should be viewed as an un-rooted tree. As expected, African, European and Asian populations cluster on the tree. The tree agrees mostly with the result inwith small differences (e.g. the location of GBR).
Inference with the 1000 Genomes Haplotypes
Discussion and conclusionsIn this article, we present the CompactCH algorithm for computing the gene tree probability under the multispecies coalescent model. While CompactCH is much faster than the STELLS when the number of populations is small, computing the exact gene tree probability for more populations remains a challenging task (). Nonetheless, we show in this article that efficient computation of gene tree probability for small number of (say two) populations can find applications in the inference of population history. We believe the CompactCH algorithm is a step forward for more efficient computation on coalescent models. The key idea of CompactCH is using compact coalescent histories. While merging multiple entities is a common idea in algorithm design, designing a working algorithm for coalescent computation based on this high-level idea is not trivial, as we show in this article. Our work suggests that coalescent computation can indeed be made more efficient by a well-designed algorithmfor an algorithm that speeds up coalescent computation under a different formulation]. We note that coalescent histories (in particular the mathematical properties of coalescent histories) have been actively studied recently [see e.g.. Our result presented here demonstratesAverage over 50 replicates. Eight populations. Inference error: normalized RF distance. Population tree height (Ht): 0.1 or 0.5. 100 loci. g c : number of haplotypes per population. Time: in seconds (s), minutes (m) and hours (h). Results for TreeMix are inside the parentheses. The original STELLS is only feasible for g c  2 and so only the results for the g c  2 case are provided for the original STELLS.that computation based on coalescent history can also be improved computationally. The CompactCH approach may also lead to speedup in coalescent computation in other formulations, where more complex coalescent models are used and computational efficiency is highly desirable. For example, the coalescent likelihood computed by MCMC in Heled and Drummond (2010) considers sequences, not the gene trees inferred from the sequences. Our techniques may be applied to speed up the computation of such likelihood.Funding: This work is partly supported by US National Science Foundation grant. Parts of simulations are performed on a computer cluster that is supported under grant
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
n h h;E 1 nqh;E  3! 1 3 1 1 1 1  2: The exact gene tree probability can be computed if all coalescent histories are enumerated for T g and T s. However, as shown in Degnan and Salter (2005), the number of coalescent histories grows rapidly when the sizes of T g and T s grow. In fact, when T g and T s have matching topology [assumed in most analytical results on coalescent history; see e.g. (Rosenberg, 2013)], there exists no known cases where lead to polynomial number of coalescent histories. Recently, an algorithm called STELLS was developed in Wu (2012). The STELLS algorithm is based on dynamic programming on a data structure called ancestral configuration (or AC). The STELLS algorithm is much faster than the algorithm by Degnan and Salter. Moreover, it is known that the number of ACs is bounded by a polynomial when T g and T s have matching topology and the topology is the maximal-asymmetric (i.e. caterpillar) tree. So in this special case, STELLS computes the gene tree probability in polynomial time. Algorithm for computing the gene tree probability i227 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Results are not given if it takes longer than 15 days. m p : number of populations. Columns: g c , the number of gene alleles per population. Time: in seconds. i230 Y.Wu at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
