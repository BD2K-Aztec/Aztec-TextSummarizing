Motivation: Markov models are very popular for analyzing complex sequences such as protein sequences, whose sources are unknown, or whose underlying statistical characteristics are not well understood. A major problem is the computational complexity involved with using Markov models, especially the exponential growth of their size with the order of the model. The probabilistic suffix tree (PST) and its improved variant sparse probabilistic suffix tree (SPST) have been proposed to address some of the key problems with Markov models. The use of the suffix tree, however, implies that the space requirement for the PST/SPST could still be high. Results: We present the probabilistic suffix array (PSA), a data structure for representing information in variable length Markov chains. The PSA essentially encodes information in a Markov model by providing a time and space-efficient alternative to the PST/SPST. Given a sequence of length N, construction and learning in the PSA is done in O(N) time and space, independent of the Markov order. Prediction using the PSA is performed in O(mlog N ||) time, where m is the pattern length, and is the symbol alphabet. In terms of modeling and prediction accuracy, using protein families from Pfam 25.0, SPST and PSA produced similar results (SPST 89.82%, PSA 89.56%), but slightly lower than HMMER3 (92.55%). A modified algorithm for PSA prediction improved the performance to 91.7%, or just 0.79% from HMMER3 results. The average (maximum) practical construction space for the protein families tested was 21.58±6.32N (41.11N) bytes using the PSA, 27.55±13.16N (63.01N) bytes using SPST and 47±24.95N (140.3N) bytes for HMMER3. The PSA was 255 times faster to construct than the SPST, and 11 times faster than HMMER3.
INTRODUCTIONMarkov models are often used for modeling complex sequences, such as protein sequences, whose underlying statistical characteristics are not well understood. This is especially the * To whom correspondence should be addressed. case when the sequences exhibit short-term memory. For a shortterm memory of length, say L, the sequences can be modeled using Markov models of order L, or using Hidden Markov Models (. The models provide efficient mechanisms to compute the required conditional probabilities, and also for generating sequences from the models. The problem is that the size of Markov models increases exponentially with increasing memory length L. Thus, they are practical only for low-order models with short-memory lengths. This leads to another problem: such low-order Markov models often provide a poor approximation of the true sequence being modeled. It is known that learning and inference with HMMs is computationally very challenging (). Probabilistic suffix models such as probabilistic suffix trees (PSTs) have been proposed byto address some of the key problems with Markov models. They showed the equivalence between PSTs and a subclass of probabilistic finite automata (PFA) called probabilistic suffix automata (PFA/PSA): for a given PST, there is an algorithm to construct a PFA/PSA whose size is the same as that of the PST within a constant factor. Further, the distribution generated by a PST is guaranteed to be within a small distance from that generated using the PSF/PSA, as measured by the KullbackLeibler divergence. Their probabilistic suffix models, however, require O(LN 2 ) time and space to construct, where N is the sequence length. The algorithm to construct the PFA/PSA from the PST also runs in O(LN 2 ) time. Later, () showed how the PST can be constructed in O(N) time, independent of the order L, using traditional suffix links used in constructing suffix trees (STs), and the notion of reverse suffix links. PSTs and probabilistic suffix automatons are related to contextbased models which are extensively used in sequence prediction and data compression. The use of these context models as a surrogate for variable length Markov models with applications in sequence prediction are reviewed in (). Earlier, the PST was used to model DNA sequences in (). Modeling and prediction of protein families using the PST was reported in (). Importantly, using the PST, prediction was performed without any prior alignment of the protein sequences. () proposed an improved variation of the PST, called sparse probabilistic suffix tree (SPST) for use in protein family prediction. Unlike the usual PST, the SPST allows some contexts to be grouped together to form an equivalent class. Essentially, this grouping results in a form of pruning of the PST, however, the node depths are not fixed, but could vary depending
Probabilistic suffix arrayon the sequence. In, it was shown that the SPST resulted in an improved prediction accuracy, when compared with the PST. The use of the ST, however, also implies that the practical time and space needed to construct or use the PST (or SPST) could be very high, although it is still theoretically linear in terms of the sequence length. Here, we present the PSA, a time and spaceefficient alternative to the PST/SPST. The PSA provides all the capabilities of the PST/SPST, such as learning and prediction, and maintains the same linear time for construction. The PSA is, however, significantly more efficient than the SPST (in both space and time), for both the construction stage and the prediction stage.
BACKGROUND
Suffix trees and suffix arraysGiven a string T = T [1,...,N] with symbol alphabet , its ST is a rooted tree with N leaves, where the i-th leaf node corresponds to the i-th suffix T i of T. Except for the root node and the leaf nodes, every node must have at least two descendant child nodes. Each edge in the ST represents a substring of T , and no two edges out of a node start with the same character. For a given edge, the edge label is simply the substring in T corresponding to the edge. We use l i to denote the i-th leaf node. Then, l i corresponds to T i , the i-th suffix of T. When the edges from each node are sorted lexicographically, then l i will correspond to T SA, the i-th suffix of T in lexicographic order. Some ST construction algorithms make use of suffix links. The notion of suffix links is based on a well-known fact about suffix trees (), namely, if there is an internal node u in ST such that its path label from the root LL(u) = a for some single character a  , and a (possibly empty) string   * , then there is a node v in ST such that LL(v) = . A pointer from node u to node v is called a suffix link. If  is an empty string, then the pointer goes from u to the root node. Suffix links are important in certain applications, such as in computing matching statistics needed in approximate pattern matching, regular expression matching or in certain types of traversal of the ST. A predominant factor in the space cost for STs is the number of interior nodes in the tree, which depends on the tree topology. A simple implementation of the ST, for instance using Ukkonen's algorithm (), can require as large as 33N bytes of storage with suffix links, or 25N bytes without suffix links (). Improved ST construction algorithms Kurtz (1999) require 15.67N bytes on average, and 21N 29N bytes in the worst case (includes 1 byte/symbol for input text), depending on whether linked lists or hash tables were used for representing the nodes. These do not include the extra space required for the auxiliary structures needed for the PST. The suffix array (SA) provides a lexicographically ordered list of all the suffixes of a string. If SA=j, it means that the i-th smallest suffix of T is T j , the suffix starting at position j in T. A related structure, the LCP array contains the length of the longest common prefixes between adjacent positions in the SA. Combining the SA with the LCP (Longest Common Prefix) information provides a powerful data structure for pattern matching. Worst-case linear-time direct SA construction algorithms are described in. A linear-time algorithm for constructing ST from SA is presented in. Space-efficient constructions for representing the ST based on the SA have also been studied. Examples here include the enhanced suffix array (ESA;), linearized suffix trees () and the virtual suffix tree (VST;). Compressed index representations, such as compressed STs and compressed SAs have also been studied (). Much earlier, Kurtz (1999) proposed direct methods for space-efficient construction of the ST, without using SAs. See Section 4.4 for further discussion on efficient ST representations. In this article, we focus on the use of standard SA as the basis for the proposed probabilistic SAs.
Variable length Markov modelsA Markov model is a sequence of stochastic events {X n , n = 0,1,2,3,...} with a state space that satisfies the Markov property:where, L is the order of the model. Thus, in an order-L Markov model, the current state is dependent on the past L states. Fixed length Markov models (FLMMs) represent a probabilistic finite state machine which can be used to model arbitrarily complex sequences. Such models learn the probabilityP( |C), the conditional probability of a symbol  , given its contexts C, where   and C  L , L is the order or memory length of the model, and is fixed. The FLMM of order L is represented as a L  matrix. The space needed is thus in O( L+1 ). Variable length Markov models (VLMMs) differ from FLMM in an important way. VLMMs attempt to learn the conditional distribution of a symbol where the context length or model order could be varying, depending on the data being modeled. Essentially, for VLMM, C  L i=1 i. This property of varying memory length implies that with the VLMM, Markov dependencies of varying order in the training databoth large and smallcould be captured with ease. This flexibility of the VLMM, however, comes at a huge cost in terms of space requirement. To represent a VLMM of order L, we have to store L matrices, one for each order, from 1 to L. The total space requirement will be in O( 2 + 3 ++ L+1 ) or O( L+2 ). The space is huge, even when L is small. Thus, the space requirement for Markov models is exponential in L, whether we consider fixed length or variable length models. An important observation that could point to a potential reduction in the space requirement for Markov models is that for a given sequence of length N, there are N(N +1)/2 possible substrings in the sequence. (The number of unique substrings is typically smaller, and also depends on L,|| and the specific sequence.) Thus, there are at most N(N +1)/2 states that need to be represented in the Markov model for the sequence, for any given order. For the lengthN sequence, the maximum order of a Markov model will be N 1. Thus, given the sequence, we can have a limit on the possible number of states in its Markov model.
Probabilistic suffix treeThe PST is based on the traditional suffix tree. Like the suffix tree, the PST represents all the N(N +1)/2 substrings from the root to the leafnodes. The PST models VLMMs, which means that the string depth is not fixed for every node. For an FLMM, its corresponding PST can be obtained from the PST of the VLMM by constraining each leaf node to be of the same string depth. The transition probability of a symbol on a given path is computed as the relative frequency of the symbol in the observed data, given the preceding substring on the path. The length of the substring used to determine such conditional probabilities is simply given by the order of the model. Consider the sample sequence T = accactact$.shows its first-order transition matrix and the corresponding state diagram.shows the suffix tree and the corresponding PST. The PST is shown for the case of order L = 3. In this PST, we label the transition probabilities for each symbol. The transition probability for a given symbol is calculated using the conditioning context. The original PST algorithm () needed an O(LN 2 ) time to construct and prune the PST from a suffix tree. The improved algorithm () used balanced redblack trees () to construct the PST in O(LN logN) time complexity. () presented an O(N) time algorithm using suffix links and reverse suffix links. () proposed an improved variation of the PST, called sparse probabilistic suffix tree (SPST) for use in protein family prediction. The SPST differs from the PST in that the SPST models sparse Markov chains (SMCs), whereby the conditioning contexts are defined by sparse sequences, that is, subset of sequences of amino acids. In an SMC, some contexts can be grouped together to form an equivalent class. In SPST, this grouping is performed by considering the contexts with similar prefixes. This leads to a type of partitioning of the contexts, based on their common prefixes. In practice, the effect is essentially a form of pruning of the PST, whereby the node depths are not fixed, but could vary depending on the sequence. This variability in node depths makes the SPST different from the PST with fixed order or node depth L [e.g. L = 20 in Bejerano and. Results reported inshowed that the SPST improved on PST prediction by 24%, while maintaining the same general time complexity.
Empirical probabilities via SAsIn Apostolico and Bejerano (2000);, the conditional probabilities required for the PST were computed as relative counts, using empirical probabilities, based on symbol frequencies from the observed data. To compute the empirical probabilities, we use the notions of term frequency (TF) and document frequency (DF) as used in information retrieval. The TF is simply the number of times a given term (or substring in our case) occurred in a given sequence. There are N(N +1)/2 substrings in a sequence of size N. Using a nave algorithm, we will need to compute TFs for all the N(N +1)/2 terms. However, with the suffix tree for this sequence, we have N leaf nodes and at most N internal nodes. These 2N nodes represent the N(N +1)/2 substrings in the sequence. Therefore, some multiple substrings at different positions in the sequence must have been represented by the same node. These substrings represented in the same node must have the same frequency count. Since the node labels are unique in the suffix tree, this means that the multiple substrings in the same node are essentially the same substring, that was repeated multiple times along the sequence. Thus, each unique substring forms a 'group', whereby group members essentially differ in terms of their starting locations in the string T. While there are O(N 2 ) possible substrings in T , there are at most O(N) unique substrings (or groups). Hence, we need to compute the TF for only the 2N unique substrings.presented a data structure, called the interval array, to represent the groups as nodes in the suffix tree using a SA. For example, the substring 'ac' occurred three times in the sample sequence shown in. This 'ac' group corresponds to the interval < 1,3 > (). Using the interval array, their algorithm calculated all the required TFs in O(N) time.shows the interval array for the sample sequence T = accactact$. From the table, we can describe two important properties of the interval array (or substring groups).(1) There are at most 2N groups in a sequence of size N. Substrings in the same group have the same statistics (for example: TF and DF) and the same derivative measurements.(2) An lcp-delimited interval < i,j > is constructed using the LCP array, where (i,j) is an interval on the SA. An lcp-delimited interval < i,j > must meet the condition: max(LCP,LCP) < Length group(i,j)  min(LCP,LCP[i+2],...,LCP)where, Length group(i,j) is the LCP of the suffixes that belong to the same group with the < i,j > interval. Let  and  be two substrings in the same lcp-delimited interval < i,j >. Then, TF() =TF() = j i+1.
METHODPSAPrevious work () has represented Markov models and PFA using the PST. Here, we present a space-efficient data structure to represent such finite state machines. We call our data structure the PSA, since it is built on the SA data structure. The PSA uses an array of nodes to capture the branching structure in the suffix tree, and other auxiliary arrays to maintain information needed for learning from the observed data. Learning in the PSA is performed by computing conditional probabilities at each node in the PSA using empirical probabilities computed via the TF.
Data structureEssentially, we use the probabilistic SA to simulate the PST. Each node in the PST has a corresponding position in the PSA. The basic PSA structure has three types of attributes. The first category of attributes is the foundation attributes, which consists of the original text and its SA. Construction of the SA is in O(N) time and space, using any of the various linear-time, linear-space algorithms
Probabilistic suffix array(b) (a)of the PST, say u, encode the conditional probabilities P( |C) of observing the symbol  after observing the context C, which in this case is the sequence corresponding to the node label, LL(u). Angle brackets at the internal nodes in the ST denote the intervals in the SA. These are used by the PSA.Seefor the position of each interval in the suffix tree.The second category of attributes are the internal node attributes. These are derived from the interval array, which is determined following Yamamoto and Church (2001). These are used to represent the internal nodes in the suffix tree, including the suffix links. The suffix link is the link from an internal node to its corresponding suffix node. The third type of attributes are measurement attributes. These record measurement information, such as TF, DF and conditional probabilities, which are needed to compute probabilities in the Markov model.shows the three types of attributes used in the PSA. The TF can be calculated at run time. Thus the attribute Conditional Probability ( cProb ) which is based on TF can be computed also at run time. We use the term length of the PSA (denoted by M) to refer to the number of nodes in the PSA. The term length emphasizes the fact that our PSA nodes are stored as arrays.
Internal node attributes.The internal node attributes are derived from the interval array. The pair <Start, End> represents the interval position of a node in the SA. The PSA internal node attributes are used to simulate the internal nodes in a suffix tree. The attribute sLink is a regular suffix link from the current internal node to its suffix node. We use this link to continue the searching process when a mismatch occurs at the time of prediction. The attribute Parent is the parent node of the current node. The internal node attributes including the suffix link are constructed using Algorithm BuildPSA.
Measurement attributes. These attributes are dependenton the application. For example, for applications in document feature selection, or in protein sequence classification, we only compute the TFs and the conditional probabilities (as needed) at run time, using the formula (EndStart+1). In other applications, such as protein sequence clustering, we may need to compute DF for thea indicates an attribute that will be computed at run time, and hence does not need extra storage. classes, rather than just the DF. The attributes are also dependent on the methods used in calculating the probabilities in the Markov model. Thus, we focus on the method for computing the conditional probabilities, and the probability of a node in the VLMM. For a given node with node label, say (S 1 ,...,S n ), its probability, P VLMM is given by:does not occur in the training data, we find the longest suffix ofHere, TF u is the term frequency at the node with node label u. We make two observations: First, if the terminal symbol S t of a path S k ,...,S t1 S t is a first symbol in an edge of the suffix tree, then the conditional probability P(S t |S k ,.
..,S t1) is calculated by the frequency of the current node divided by the frequency of the parent node. Second, if the terminal symbol S t of a path S k ,...,S t1 S t is not a first symbol in an edge of the suffix tree, then the conditionalis 1. We call this a trivial conditional probability. Thus, we need to calculate the conditional probabilities for only the first symbol in each edge. When we determine that the terminal symbol of path is not a first symbol in an edge, we simply return 1 for the conditional probability of the symbol.
Example PSA. Tables 3 and 4 show the nature of the PSA nodes and the order-3 conditional probabilitiesin a PSA, using the sequence T = accactact$ used in. The entries inare directly calculated from the interval array. We notice that P(c|a) is 1. This indicates the substring 'ac' is represented on one edge and that the terminal symbol 'c' is the second symbol on this edge. This is a trivial conditional probability. Entries inare computed from the PSA leaf nodes. We only showed the non-trivial conditional probabilities on the leaf nodes. These conditional probabilities are calculated based on the first observation described in Section 3.1.2. The numerator is 1 since this is a leaf node which must have a frequency of 1. The denominator is the frequency of the substring corresponding to the node label of the parent of the current leaf node. This is easily obtained as (EndStart+1) using the elements in the interval array. The PSA nodes can be compared with the example PST shown in.
Constructing the PSAHaving described the building blocks for the PSA, we are now ready to describe how we put them together to construct the PSA. For a given input sequence, algorithm BuildPSA uses five major steps to construct the PSA data structure. The first step is the construction of the SA from the original sequence. We use standard linear-time, linear-space algorithms for this step. The next two steps construct the tree-like structure used in the PSA. Step 2 constructs the interval array (iArray) using the print_LDIs_stack function defined in Yamamoto and Church (2001). The next step maps each position in the input sequence to its interval. This step calculates the parent node of each node. The final step computes the inverse SA. Using the inverse SA the algorithm determines a link that allows the interval array to point to the next position, based on which the the suffix link for each PSA node is determined. A more detailed description of the PSA construction steps and their computational complexity analysis can be found in Lin (2011).
Build probabilistic SABuildPSA(T ) 1 SA  BuildSA(T ) 2 iArray  print_LDIs_stack(SA) 3 <posIntv,parent>  BuildIntervalTree(SA, iArray) 4 PSA  BuildSuffixLink(posIntv,parent)
Prediction with VLMM via the PSAAn important procedure in Markov models is to compute the probability that a given test pattern is generated by the model. This is particularly important in our problem of modeling protein families using VLMMs. For instance, given a protein family with some known sequences, one may be interested in checking if a given unknown protein sequence belongs to the family. This can be done by first constructing a model of the family (i.e. the PSA in our case) using the known sequences. Given a protein family with Z sequences, say T 1 ,T 2 ,...,T Z , this is performed by constructing the PSA for the concatenated sequence: T = T 1 $ 1 T 2 $ 2 ...T Z $ Z. To determine whether the unknown protein sequence belongs to the family, we use the model to compute the probability that the unknown sequence is generated by the model. For the VLMM, we denote this probability as the P VLMM of the input pattern. Algorithm VLMM-Prediction calculates the P VLMM of a test sequence using the PSA data structure. This algorithm uses Equation (1) to compute P(S 1 ),P(S 2 |S 1 ),... by searching for the subpatterns S 1 ,S 1 S 2 ,... When there is a mismatch while searching with the subpattern, say S k ,...,S t , the algorithm jumps to the node pointed to by the suffix link attribute of the current node. Thus, matching proceeds from the node representing the suffix S k+1 ,...,S t , after accounting for the prefix of this suffix, which has already been matched in the previous step. When a mismatch occurs, the algorithm uses the previously computed index to determine the suffix link. Thus the search will be redirected to the new branch following the suffix link. The algorithm now uses the longest suffix of the subpattern that so far matched in the previous matching step as the new subpattern, and restarts matching from the symbol that mismatched. This redirection is a constant time operation. The foregoing implies that, given a sequence T = T [1,...,N], with symbols from an alphabet , and the PSA for T , we can decide on whether a pattern P = Pis generated by the same variable length Markov chain that generated T in O(mlog N || ) time. We can use the predicted probability above to perform protein sequence classification. Suppose we have F protein families and we have computed the PSA for each family. Let PSA k be the model constructed using the k-th protein family. Further, let
Probabilistic suffix arrayP VLMM (P,PSA k ) be the probability that protein sequence P is generated by PSA k , as returned by algorithm VLMM-Prediction. Then, we classify P to protein family f , where, f = argmax k=1,.
..,F{P VLMM (P,PSA k )}.
Prediction with VLMM via the PSA
RESULTS AND DISCUSSIONWe performed experiments on protein sequences to test the proposed PSA data structure. The experiments were performed using a DELL PC, with 4  2.67 GHz CPU, and 8G memory, running Ubuntu 10.10 Linux operating system. All programs were compiled using gcc.
Predicting protein familiesGapped-BLAST () provides a simple but popular approach to protein family prediction. Perhaps the most popular and accurate methods for protein family classification are based on profile HMMs, introduced in the 1990's (). HMM is more accurate than BLAST, and also performs better in detecting distant homologs. In (), the PST was compared with both Gapped-BLAST and an earlier implementation of HMM, using the old Pfam 1.0 dataset (). In terms of prediction accuracy, the PST generally did better than BLAST, but under-performed HMM by 25% (90.7% versus 91.596.1%). The PST was, however, much faster than HMM for both training and searching. In, the SPST was introduced as an improved variant of the PST, resulting in 2% improvement in accuracy. The latest implementation of profile HMM is HMMER 3.0 http://hmmer.janelia.org/ () which is now essentially as fast as BLAST, but more accurate. Our major objective was to develop a time-and space-efficient alternative to the PST/SPST. To test the performance of PSA in modeling protein sequences and in predicting the family forunknown sequences, we downloaded the current Pfam database (release 25.0;). We use family members from the unaligned sequences to generate the PSA, one PSA for each family. We selected the first 48 families with 12 or more members (based on alphabetical ranking of the family names). For each family, we selected the first 1000 protein sequences (or all sequences if family size <1000) to make up our dataset. The result is a total of 46 810 protein sequences from the 48 families. For each family, we selected 80% of the protein sequences (37 448) for training, used the remaining 20% (9362 sequences) for testing. Below, we compare the proposed PSA with SPST (best performing variant of PST), and HMMER 3.0 (latest implementation of profile HMM). For HMMER3, we use the e-value to decide to which family a given test sequence should be assigned. Thus, in some cases HMMER3 returns a 'no match', which we consider as a missed detection. To use the PSA, for each sequence in the test dataset, we compute the P VLMM using the PSA structure for each family. We then assign the protein sequence to the family with the maximum probability. When the maximum probability is obtained using the model of the correct family (whose PSA is generated without the test sequence), we say we have a correct classification (true positive), otherwise, there is a classification error. This simple approach avoids the difficult problem of setting thresholds for correct classification.shows the summary classification performance on the Pfam dataset using the PSA. Detailed classification results, showing performance on each family are provided as Supplementary. For comparison, we have also included the results obtained using the SPST and HMMER3 on the same dataset. As expected, both SPST and PSA produced comparable results with respect to modeling and classification of protein families. The SPST had an average true positive rate of 89.82%, whereas the PSA had 89.56%. These were just 3% lower than the average performance (namely 92.55%) obtained using HMMER 3.0. We performed a harder test, by using 20/80 data partitioning (rather than 80/20) for training versus testing. The overall true positive rate was reduced for each of the three schemes (PSA 85.40%, SPST 84.49% and HMMER3 89.91%; see Supplementary). The results, however, show that with respect to prediction accuracy, SPST and PSA are not significantly worse than HMMER3, the current state-of-the-art, even under the more challenging scenario of 20/80 split for training versus testing.To evaluate the impact of increasing database set size and diversity on the PSA performance, we selected 1000 protein families with 1000 or more members in Pfam. For each family, we selected the first 1000 protein sequences to make up our dataset. The result is a total of 1 000 000 protein sequences from the 1000 families. For each family, we selected 80% of the protein sequences (800 000) for training, used the remaining 20% (200 000 sequences) for testing. We compare the performance of the proposed PSA with that of HMMER3 on the large dataset. The performance decreased somewhat, for both HMMER3 and PSA. The performance for PSA changed from 89.56% (for F = 48 families) to 87.10% (for F = 1000 families), or a decrease of 2.46%. However, HMMER3 showed a less performance decrease of 1% [from 92.55% (F = 48) to 91.58% (F = 1000)]. Detailed comparative results, showing the classification performance on each family are provided as Supplementary Table S4. One advantage of performing classification using Equation (3), is that, when there is an error in the classification, we can consider the family with the next highest predicted probability. For instance, we can consider the top-k classification rate, which shows the probability of finding the correct protein family within the first k families, as ordered based on their generated probabilities, using the test sequence.shows the classification performance of the PSA on some sample families, using the top-k classification rate. We can observe how the classification performance rapidly approaches 100% after the first few k-values.
Space considerationA major problem with suffix trees is their practical memory space requirement. Although, they have the same theoretical linear space requirement as SAs, in practice, suffix trees consume much more space (). This was our primary motivation for developing the PSA.shows the summary data on the protein families in Pfam 25.0 used in our experiments.compares the memory space required to construct the SPST and HMM with that required for the PSA. First, we can observe the nature of the protein sequences (). The maximum branching factor ( = M N ) observed was 0.687,whereas the minimum was 0.432. The average was 0.538. The branching factor provides an indication of the nature of the sequence. Higher values typically indicate less repetition in the sequence. As a key performance measure, we used the memory consumption factor (MCF), defined as the ratio of the required memory to the total sequence length (N) of the family. We compared the MCF for PSA, SPST and HMMER3.shows that the PSA ratio was steady at about (21.586.32N) bytes. The maximum memory required by the PSA for any of the families was 42.11N bytes. This can be compared with the (mean and maximum) memory needed for SPST (27.5513.16N,63.01N) and HMMER3 (4724.95N,140.3N). Supplementaryshows more detailed information on the memory consumption needed to construct the data structures, using the Pfam 25.0 protein families. We can observe that the minimum MCF for HMMER3 was larger that the average MCF for PSA.shows the corresponding MCF for the three schemes during the time of prediction (testing). Perhaps, more significantly, while the PSA memory is relatively constant independent of the sequence or family, we can observe the significant fluctuation in the memory needed for the SPST and HMMER3, as captured by the range and SD on the MCF. This relative stability can be observed during both PSA construction and PSA prediction. For the dataset, the PSA required an average MFC of (13.6N 0.96) and a maximum MFC of 16N for storage, after construction.Recorded time is time needed per family (in seconds). Speedup is computed as the ratio with respect to PSA time.shows the summary of the time required for constructing the PSA and the PST data structures.shows the corresponding summary of the time needed for prediction using the models. The tables show that for prediction, on average, the PSA was 10.8 times faster to build than HMMER3, and 255 times faster than constructing SPST. For prediction, the PSA was 371 times faster than SPST.
Probabilistic suffix array
Computational time requirement
DiscussionThe proposed data structure is based on the standard SA, and hence can be implemented using compressed index structures such as compressed suffix arrays (CSAs;).showed that for a general alphabet, , with || > 2, the CSA can be constructed in O(N log || N) processing time and stored in (1+ 1 2 loglog || N)N log||+5N +O N loglogN bits, such that each lookup operation can be performed in O loglog || N time. Similarly, in theory, the PST or SPST can be implemented using compressed suffix trees (CSTs). () showed that a CST with full functionality (including suffix links) can be constructed in O(N) time, and represented using O(N log||) bits of storage space. He showed that the CST can be implemented using (NH h + 6N +o(N)) bits, where H h is the order-h entropy of the original sequence. For the CSA, the storage requirement can be reduced to (NH h +O N loglogN log || N bits. These will no doubt result in a lower memory requirement when compared with our current result using standard SAs. However, apart from the usual slowdown in processing speed using CSAs or CSTs, some types of traversals and new attributes required for the PSA (or PST/SPST) could be quite difficult to implement on a standard CSA (or CST). This type of improvement will be an interesting direction for further work on space-efficient probabilistic suffix structures. The proposed methodIndicated results are true positive rates in percentage (%). For PSA, w = 10 using average probability, and w = 80 using maximum probability. is not directly affected by the computer word length (32 bit or 64 bit), so far as the data structure including input data can fit into main memory. For very large datasets where this may not be the case, methods will need to be considered for more efficient I/O operations (Ferragina, 2010). In terms of prediction accuracy, a potential approach to improve the performance will be to consider prediction based on short fragments of the test sequence. These will provide more locality in the analysis, and hence may be able to improve the ability for detecting distant homology. One way to use the predictions from different fragments will be to choose the one with the family with the maximum predicted probability over all the fragments as the predicted family. However, other approaches are also possible, for instance by combining the predictions using some well defined protocol. We tested this approach, using overlapping windows of various sizes, w. The best results were obtained at w = 10 (86.80%) using average of window probabilities, and at w = 80 (91.76%) using the maximum probability.provides a summary of the results, showing that with the improvement, the average PSA prediction accuracy is now <0.8% below that of HMMER3. Detailed results are in Supplementary Table S1. Further, as can be seen from the results (Supplementary Tables S1 and S2), there are cases where the PSA performed signifcantly better than HMM, e.g. by as much as 40% for FAD_binding_3 or 59% (for FA_hydroxylase). Thus, a potential improvement could be obtained by combining prediction results from the PSA with those from non-PST-based methods, such as the profile HMM, for instance, using an approriate classifier fusion scheme (). We acknowledge some basic problems with using VLMMs in general (whether PST, SPST or PSA). One problem is that these tend to provide a global characterization of the sequence, and hence may have problems when similarity between sequences is localized within a smaller region of the proteins, or is interspersed between islands of non-similar regions. This will thus affect the ability to detect distant homology, or the ability to handle a previously unseen mutation in a protein sequence that is being analyzed. This last problem is akin to the zero-frequency-problem, and various methods have been proposed, for instance, using a default probability distribution, or a Poisson process model (). A related problem with the current PSA implementation is that the conditioning context for the symbol probability reverts to the longest observed suffix, meaning that the conditional probability would be based on a small number of counts. This may not always correspond to the true probability. One solution would be to use some kind of
J.Lin et al.interpolation scheme, in which the probabilities are estimated based on shorter prefixes, for instance, bigrams or trigrams. Though these may still not always provide the true probabilities, the estimates are likely to be closer to the true values, and also likely to be more robust. This approach is somewhat similar to the successive reduction in context size as used in context models such as prediction by partial matching (PPM) (; Cleary and Witten, 1984;) used in effective data compression. Another approach is to use approximate matching in evaluating the similarity between prefixes, rather than exact matching as is used in the current implementation. () provides some more discussions on improvements on the prediction strategy. We mention one issue with the current implementation of protein family prediction using the PSA. Currently, the family with the highest probability as reported by P VLMM () is always chosen as the predicted family. This means that, there is no significance attached to the prediction, and that the system must report a prediction for any given test sequence. Thus, when the test sequence does not belong to any of the families in the training set, the assignment must necessarily be in error. This problem can be reduced by including a mechanism that can return a 'no match' (similar to HMMER3), for instance, based on some measure of confidence on the prediction. Using the PSA approach, one simple way to do this will be to consider the maximum and second maximum probabilities returned by P VLMM (). If the difference between the two is above a certain threshold, the system will report a prediction (i.e. family with the maximum probability). Otherwise, it reports a 'no match'.
CONCLUSIONWe have presented the PSA, a data structure for representing information in VLMMs. The PSA provides the same functionality as the PST, but at a significantly reduced time and space requirement. Given a sequence of length N, construction and learning in the PSA is done in O(N) time and O(N) space, independent of the Markov order. Prediction using the PSA is performed in O mlog N || time, where m is the pattern length, and is the symbol alphabet. We have shown practical results on the comparative performance of PSA, SPST and HMMER3 using protein families from Pfam 25.0. In terms of modeling and prediction, SPST and PSA produce equivalent results (SPST 89.82%, PSA 89.56%). These were slightly lower than the 92.55% obtained using HMMER3 on the same dataset. An improved version of PSA prediction (predicting families using fragments from the test sequence) improved PSA perfomance to 91.7%, thus reducing the performance gap with HMMER3 to just 0.79%. The average practical construction space for the protein families tested was 21.586.32N bytes using the PSA, 27.5513.16N bytes using SPST and 4724.95N bytes for HMMER3. The maximum practical space needed was 42.11N for PSA, 63.01N for SPST and 140.3N for HMMER3. With respect to construction time, the PSA was 255 times faster than SPST, and 11 times faster than HMMER3. Our results show that, the PSA provides an accuracy similar to that of PST/SPST and HMMER3 in protein family prediction, but at a significantly lower time and space requirement.
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
