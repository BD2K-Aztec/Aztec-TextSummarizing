Motivation: The introduction of next-generation sequencing techniques and especially the high-throughput systems Solexa (Illumina Inc.) and SOLiD (ABI) made the mapping of short reads to reference sequences a standard application in modern bioinformatics. Short-read alignment is needed for reference based re-sequencing of complete genomes as well as for gene expression analysis based on transcriptome sequencing. Several approaches were developed during the last years allowing for a fast alignment of short sequences to a given template. Methods available to date use heuristic techniques to gain a speedup of the alignments, thereby missing possible alignment positions. Furthermore, most approaches return only one best hit for every query sequence, thus losing the potentially valuable information of alternative alignment positions with identical scores. Results: We developed SARUMAN (Semiglobal Alignment of short Reads Using CUDA and NeedleMAN-Wunsch), a mapping approach that returns all possible alignment positions of a read in a reference sequence under a given error threshold, together with one optimal alignment for each of these positions. Alignments are computed in parallel on graphics hardware, facilitating an considerable speedup of this normally time-consuming step. Combining our filter algorithm with CUDA-accelerated alignments, we were able to align reads to microbial genomes in time comparable or even faster than all published approaches, while still providing an exact, complete and optimal result. At the same time, SARUMAN runs on every standard Linux PC with a CUDA-compatible graphics accelerator.
INTRODUCTION
Challenges of next-generation sequencingTogether with the advent of new high-throughput sequencing technologies, the amount of generated biological data steadily increased. These techniques allow for cost-effective sequencing of complete libraries of different bacterial strains that may provide new insights e.g. into microevolution, but experimental data need to be processed before any conclusion can be drawn. Given an Illumina Solexa setup with a 36-bp read length, even one lane on the flow cell will suffice for deep coverage sequencing of several bacterial genomes. Typically, the generated reads are mapped on a closely related reference genome to perform a targeted re-sequencing, an in-depth SNP analysis, or to gain knowledge about gene expression when performing transcriptomic experiments using cDNA sequencing. Different tools for mapping reads against reference genomes are available at this time including MAQ (), BWA (), Bowtie (), PASS (), SHRiMP () and SOAP2 (). MAQ was one of the first mapping tools available and uses a hash data structure to keep reads in memory while traversing the reference genome, resulting in a comparably low memory footprint. But it lacks support for the output of more than one mapping position per read and is not able to compete with more recent approaches in terms of speed (). BWA, Bowtie and SOAP2 are indexing the complete reference genome using a Burrows-Wheeler-Transformation (BWT) () and process all the reads sequentially, resulting in a considerable speedup of the mapping process. PASS and SHRiMP also perform an indexing of the reference sequence, but use a spaced seed approach () instead of BWT. All mentioned approaches except SHRiMP are heuristic and do not guarantee the mapping of all possible reads. Especially reads that show insertions or deletions (indels) compared to the reference sequence are often missed. Bowtie is unable to identify such alignments by design, while SOAP2 only supports gapped alignments in paired-end mode. As high accuracy and confidence of short-read alignment is highly desirable, especially in the analysis of single nucleotide polymorphisms (SNPs) or small-scale structural variations, we decided to design an exact short-read alignment approach that identifies all match positions for each read under a given error tolerance, and generates one optimal alignment for each of these positions without any heuristic. To obtain an adequate runtime even for large-scale, whole-genome applications, we employ the massively parallel compute power of modern graphics adapters [Graphic Processing Unit (]. A qgram-based () filter algorithm was designed to find auspicious alignment positions of short reads within the reference sequence. After the localization of possiblePage: 1352 13511358
J.Blom et al.mapping positions, we use a NeedlemanWunsch () algorithm to compute optimal alignments of the candidate sequences to the reference sequence. The alignments are processed in parallel on a NVIDIA graphics card using the NVIDIA CUDA (Compute Unified Device Architecture) framework. This combination of a filter step with the parallel computation of optimal alignments on graphics hardware allows us to compute an exact and complete mapping of all reads to the reference in a time comparable to existing heuristic approaches.
Parallelization in biosequence analysisIn computational biology, huge amounts of data need to be processed and analyzed, therefore suggesting the exploration and evaluation of new computational technologies like parallel programming. One basic idea behind parallel programming is to divide a problem into smaller, easier to solve subproblems, a technique known as 'divide and conquer'. Another approach is to solve a huge number of small independent tasks by parallelization such that each problem can be solved on a different processing unit, either cores of one computer or a compute cluster. Once all calculations are finished, they are combined into a solution of the original problem. While server systems with 32 and more CPU cores are available today and can be used to efficiently speedup multithreaded software, they still pose a significant capital investment. Therefore, specialized hardware for parallel processing has been employed, such as Celeras GeneMatchASIC (application-specific integrated circuit) approach which uses specialized processors to accelerate several bioinformatics algorithms. A few years later, TimeLogic developed Field Programmable Gate Arrays (FPGAs) to run adapted versions of the SmithWaterman, BLAST and HMMer software with significant performance gains. Unfortunately, the prices for such optimized special purpose hardware together with appropriate licenses lie in the same expensive investment range as large servers. A more cost-efficient possibility is the use of existing hardware which can be employed for scientific computing through different frameworks. The MMX technology introduced by Intel in 1997 is a SIMD (single input multiple data) approach which allows for parallel processing of large amounts of data with specialized CPU instructions. The MMX instruction set as well as its successor SSE (Streaming SIMD Extensions) have been used to accelerate implementations () of the SmithWaterman algorithm (). In 2008, also a first attempt on non-PC hardware has been published. SWPS3 () employs the Playstation 3's cell processor to speedup an adapted version of the SmithWaterman algorithm. Another trend in the recent past is the use of modern graphics adapters in scientific computation due to their immense processing power which still increases at a much faster rate than the processing power of general purpose processors. While there are several implementations available () that focus on the alignment of one query sequence to a database of reference sequences, an algorithmic adaptation of massively parallel pairwise alignments, as it could be used for shortread alignments, is still missing. First approaches using graphics cards as hardware accelerators for bioinformatics algorithms () relied on OpenGL, resulting in a difficult and limited implementation. Today, frameworks simplify software development by hiding the layer of 3D programming behind a more general Application Programming Interface (API). Thus, the focus of development shifts from fitting a given algorithm to OpenGL operations to the development of the best implementation. The CUDA platform developed by the NVIDIA cooperation (http://www.nvidia.com/object/cuda_home.html) and ATI's Stream framework (http://www.amd.com/stream) are novel approaches to use the huge computational power of modern graphics cards not only for games but also for scientific applications. Contemporary graphics processing units are built as massively parallel computational devices, optimized for floating point operations. Compared to universal central processing units (CPUs) used in every computer, GPUs are specialized for parallel execution of many small tasks while CPUs are designed to execute fewer large tasks sequentially. As such, GPUs are also well suited for the highly parallel computation of small-scale alignments.
METHODS
ProblemThe short-read matching problem can be defined as follows: we have given a short sequencing read f of length |f |=m, a (in most cases genomic) reference sequence g of length |g|=n, and an error threshold e  0 defined by the user. Then we want to calculate all starting positions i in g, such that there exists an alignment of f and a prefix of gwith at most e errors (mismatches and/or indels). The algorithm shall be capable to export an optimal alignment for every such match position. This problem has been studied widely in the past, and most solutions are based on one of the two following principles, or combinations thereof: the qgram lemma states that two strings P and S with an edit distance of e share at least t qgrams, that is substrings of length q, where t = max(|P|,|S|)q+ 1qe. That means that every error may destroy up to qe overlapping qgrams. For non-overlapping qgrams, one error can destroy only the qgram in which it is located, which results in the applicability of the pigeonhole principle. The pigeonhole principle states that, if n objects (errors) are to be allocated to m containers (segments), then at least one container must hold no fewer than n m objects. Similarly, at least one container must hold no more than n m objects. If n < m, it follows that n m =0, which means that at least one container (segment) has to be empty (free of errors). Moreover, if n < m this holds for at least mn segments. In our algorithm, presented in the following section, we first use a 2-fold application of the pigeonhole principle to find regions of interest in the genome, before we apply parameters derived from the qgram lemma to make our final selection of positions to pass the filter.
SolutionAssumptions and definitions: as a basic assumption, we require a minimal length of reads in relation to the given error threshold: m > e+1. Given this assumption, we calculate the length of the qgrams for our filter algorithm as follows. We define the length q of the qgrams as the largest value below m e+1such thatThis guarantees that a read f can be split into e+1 intervals with an additional non-empty remainder of length R := m(e+1)q. Given the calculated qgram length, we create an index I of the starting positions of qgrams in sequence g, such that for each possible qgram x, I(x) contains the starting positions of x in g. In the following step of the filter algorithm, every read is segmented into pieces of length q (). We choose a set S of c == m q segments S = s 1 ...s c of length q from f , such that for i = 1,...,c : s i = fmost cases q == m e+1 , it can easily be shown that c converges against e+1 for increasing read length m. We additionally choose a second set K of c segments K = k 1 ...k c of length q, such that for i = 1,...,c : k i = f [(i1) * q+ 1+R...i * q+R], a set shifted by the remainder R. The simple version of our algorithm allows for mismatches only, not for insertion or deletions. In this case, it can be shown by the following observations that a matching read f must have at least two matching segments from the sets S and/or K. There are two cases, in the first case two segments of set S will match, in the second case one segment from S and one segment from K will match. The term 'matching segment' in the following indicates that a starting position for the respective segment can be found in the genome via exact occurrence within index I. The first segment found in the index is used as seed, the second 'matching' segment has to be listed in the index in appropriate distance to this seed. The algorithm is based on the assumption that S and K comprise c = e+1 segments. In cases where c > e+1, we know by the pigeonhole principle that at least two segments of S must match, which fulfills our filter criterion directly. The segment set K is not needed in such cases, and all algorithmic steps after the first can be skipped. Filter algorithm: by the pigeonhole principle, we know that one segment of set S 'must' match, as we allow e errors and have e+1 segments. We can identify all match positions of segments s i  S for the given read in the qgram index I and use them as starting points for the filter algorithm.
GPU short read alignment(1) For every segment s i matching at a position b in the genome g we check in I if there is another segment s j  S,j > i, that starts at the expected position b+(j i) * q. If we find such a segment, we identified the two matching segments we expect.In the case that only one segment s i  S matches, there has to be exactly one error in every remaining segmentOtherwise, a second segment of set S would match. We can infer that not more than ci errors are remaining in the segments to the right of read s i , but due to the overlapping construction of our segment sets we have one segment more of K to the right of read s i to check. Hence, if read f is a possible hit, one of these c(i1) segments k i ...k c has to match, and we can start the checks for set K at position k i .(2) Check if segment k i overlapping s i matches. If it does, we have successfully matched 2 qgrams and passed the filter. If segment k i does not match, we know that k i overlaps s i on qR positions. These positions are free from errors (as s i matched without errors). Thus, the error causing k i not to match must have been on the last R positions of k i which are the first R positions of s i+1. As there is exactly one error in every segment of S, we can conclude that the last qR positions of s i+1 are free of errors, which are the first qR positions of k i+1. So if k i+1 does not match, the next error is in the first R positions of s i+2 and so on.(3) Iteratively check all remaining segments k i+1 ...k c until one segment matches and the read f passes the filter or until k c is reached.If we reach k c , that means that k c1 did not match, we know that the error of s c was in the first R positions. So the last qR positions of s c mustfor j  i+1,.for t (e(i1)),...,+(e(i1))
..,c do
end if
20.
end for
21.
end for
22.
if not B  C then
23.## check segments of K ## 24.
forj  i,.
..,c dofor t e(j 1),...,e(j 1) do 27.align f to gand report hit if successful 38. end for global alignments of a read sequence with a short substring of a reference genome. Thus, compared to SW-Cuda, SARUMAN does not align sequences against a database of templates, but is designed as an alignment application to perform thousands of short pairwise global sequence alignments in parallel. The CUDA API is an extension to the C programming language. Thus, the mapping part of SARUMAN was implemented in the C programming language to simplify the integration of CUDA code. Our software is divided into two consecutive phases, namely mapping and aligning. Phase one, the creation of the qgram index together with the following mapping of reads through qgrams, is completely processed on the host computer. During phase two, CUDA is used to compute the edit distance for candidate hits on the graphics card using a modified NeedlemanWunsch algorithm. If the computed edit distance of read and genome lies below a given error threshold, the optimal alignment is computed in the backtracing step on demand. The complete workflow of SARUMAN is illustrated in.
if B+v+t
end if
30.
end for
31.
end for
32.
end if
33.
end for
Mapping phaseThe memory usage of the qgram index depends on the qgram length and the number of replicates per qgram number, but is mainly dependent on the size of the reference genome. To process large reference genomes with limited resources, the reference sequence is divided into several chunks that are processed iteratively. The size of a sequence that can be processed in one iteration is restricted by the available memory. Using this technique, it is possible for SARUMAN to run on computers with small amounts of RAM by dividing the qgram index into chunks perfectly fitting into available memory. Our tests show that a standard computer with 4 GB of RAM and a recent dual core CPU is able to read and process even large bacterial genomes like Sorangium cellulosum (13 033 779 bp) without any difficulties. However, this approach is not feasible for large eukaryotic genomes as the number of needed iterations would be too high. Supported read input formats are FASTA as well as FASTQ. While the reads are stored in memory, all sequences containing more than e ambiguous bases (represented as N) are filtered out, due to the fact that an N would nevertheless be treated as a mismatch by SARUMAN. Subsequently, perfect matches are determined by exact text matching and exported as hits. Preceding the actual filtering step, all reads are preprocessed. During this phase, all located start positions of the 2 * c qgrams of a read in the reference genome are extracted from the qgram hash index. This list of positions is stored in an auxiliary data structure in order to minimize access to the hash index in later stages and therefore speedup the following filter step. Reads with perfect hits on the reference genome are still further processed as there may exist imperfect hits elsewhere on the reference, but for such reads the starting positions of qgrams representing the perfect hit are removed from the auxiliary data structure. After the first steps, each read is mapped onto the reference genome using the algorithm described in Section 2, whereas a read is only mapped once to a given start position to avoid redundancy. While a combination of first and last qgram (e.g. s 1 and k c ) exactly determines start and end position of the read, two 'inner' qgrams (e.g. s 2 and k c1 ) would result in a longer alignment in order to find the correct start and stop position. Start positions for possible mappings are stored and transferred to the CUDA module in a later stage. In order to not only exploit the parallel architecture of graphics cards but also the availability of multicore CPUs, the matching phase uses two threads. The first thread handles mapping on the sense strand, whereas the second thread processes mapping on the antisense strand. In contrast to many other approaches, which employ a 2-bit encoding for the four DNA letters, SARUMAN is able to handle Ns in reads as well as in the reference genome. Since many genomes contain a small number of bases with unknown identity, it is of advantage to treat these bases as N. Replacing these positions with random or fixed bases to maintain the 2-bit encoding may lead to wrong and in case of random replacements even to irreproducible results.
Alignment phaseTo efficiently use CUDA, it is of great advantage to understand the underlying hardware of CUDA capable graphics adapters. A GPU consists of a variable number of multiprocessors reaching from 1 in Page: 1355 13511358entry level graphics adapters up to 60 multiprocessors in high end video cards. Each of these multiprocessors has access to registers of 8 or 16 kb size and is divided into 8 small processors. The available registers are divided and equally assigned to processors. This small amount of writable memory should be used for data processed in the currently active thread while texture memory and constant memory are read only and can be used to prefetch data from the much slower device memory. An overview of the CUDA hardware and memory model is given in. Implementing code for the execution on a GPU is very similar to standard application development. Some additional keywords extending the C programming language are used to define on which device a function should be executed. A function on the GPU is mapped to one thread on one processor located on the graphics card, whereas one function can and should be executed on many different datasets in parallel. This execution scheme is called SIMT (single input multiple threads) due to its relation to the similar SIMD scheme used in classical parallel programming. Parallel programming with CUDA is transparent and (within NVIDIA products) device independent for developers and users. Launch of a CUDA application is controlled using only a few parameters defining the total number of threads. Those threads are organized hierarchically into grids, which themselves consist of threadblocks. Each threadblock is a collection of a given number of threads. A threadblock must be executable in any order and therefore must not have any dependencies on other blocks of the same grid. Once a sufficient number of candidate hits has been found by the filter algorithm, all necessary data for performing the alignments is collected. Read and genome sequences are stored together with auxiliary data structures. Afterwards, all required data for the alignment phase is copied to the GPU as one large unit in order to minimize I/O overhead. The maximal number of alignments fitting in the GPU memory heavily depends on read length. SARUMAN automatically calculates a save value for the number of parallel alignments. As the memory of the graphics adapter is also a limiting factor, SARUMAN does not use the quality information of reads as this would double up the memory usage. For datasets with sufficient coverage and quality, we recommend to simply remove all reads with low-quality bases. For 36 bp reads, a value of 200 000 alignments (100 000 for each mapping thread and direction) can be achieved on a standard GPU with 1 GB of graphics memory. Once all data of the candidate hits has been copied to the GPU for each pair of genome and read sequence, the edit distance is computed using the desired values for match and mismatch positions. By comparing the distance with the supplied maximal error rate, all candidates with values above this threshold are discarded. Complete alignments are only computed in a second backtracing step for candidates with a tolerable edit distance. Typically, the alignment phase for one batch takes only a few seconds to complete, including the whole process of copying raw data to and processed alignments from the GPU. Before any output is written, alignments are postprocessed by clipping gaps at the start and end. For each possible start position of each read, the optimal alignment is reported, in contrast to other available tools which only deliver a fixed number of positions or do not even guarantee to report any optimal alignment. SARUMAN produces tab separated output by default which includes start and stop position of the mapping together with the edit distance and the complete alignment. The package includes an easy to use conversion tool to generate the widely used SAM alignment format. The SARUMAN software is available for download at http://www.cebitec.uni-bielefeld.de/brf/saruman/saruman.html. Page: 1356 13511358
GPU short read alignment
J.Blom et al.
RESULTS
Evaluation methodsThe evaluation was accomplished on a standard desktop PC with an Intel Core2Duo E8400 3 GHz dual core processor with 8 GB DDR2 RAM and a GeForce GTX280 graphics card with 1 GB of VRAM. All programs were run multithreaded on both processor cores, the operating system was Ubuntu Linux. We used four datasets for the performance evaluation, three synthetic read sets of roughly 18 mio. reads generated from the Escherichia coli K12 MG1655 genome (GenBank accession NC_000913), and a real dataset with data from one lane of a re-sequencing run of Corynebacterium glutamicum ATCC 13032 (GenBank Accession BX927147) using the Illumina Solexa GAII sequencer, comprising 18 161 299 reads of 35 bp length. The settings for all programs used in the comparisons were adjusted to make the run parameters as comparable as possible.To achieve this, we allowed two mismatches/indels for each read and set all programs to support multithreading. Furthermore, we allowed gapped alignment of reads where possible and adjusted the alignment scoring matrix to simple unit costs. Detailed settings for all tool runs are given in the Supplementary Material.
Performance evaluationIn order to prove the exactness and completeness of the presented approach and to measure the discrepancy between exact and heuristic implementations, we used the synthetic read sets described in Section 4.1. Synthetic reads were generated with 36, 75 and 100 bp length in both directions with up to two errors of different types, i.e. mismatches, insertions, deletions and combinations thereof. About three million of the artificial reads contained indels. These reads were mapped to the original source genome Escherichia coli K12 MG1655. The dataset is available on the project homepage.compares the mapping ratios of the different tools together with their respective running time for 75 bp reads. Data for 36 bp reads and 100 bp reads are provided in the Supplementary Material. The goal was to map all artificial reads on the genome at the exact position without missing any mappings. As expected, using SARUMAN we were able to map all artificial reads to the genome. Furthermore, nearly all reads were mapped to the correct position in the reference genome. In some rare cases (ca. 0.45%), SARUMAN returned optimal alignments that are shifted from the reads original position by up to e bases (). Such cases cannot be resolved, this is a general problem of the edit cost function and not a flaw of SARUMAN. Additionally, SARUMAN reported a large number of other matches on different sites of the genome. Among them were six matches that placed a read to an alternative position in the reference genome with a better score than the alignment to the original position. In this case, the incorporation of errors led to a read that just by chance fits better to a wrong genomic position. While alternative hits can be identified as misplaced in synthetic data, this behavior is preferable for real data as one can not determine the correct mapping position among several equally good locations. The evaluation shows a clear separation of the programs into two classes, depending on their ability to handle gaps. Neither SOAP2 nor Bowtie are able to perform gapped alignments, both tools wereThe upper part shows the runtime of the filter step, the alignment candidates passing the filter and the number of reads that where successfully aligned. The lower part compares the runtime of the alignment step on a GPU versus the runtime on a CPU.candidates resulting from the filter algorithm with the number of alignments successfully verified by the alignment step. The results are shown in. The efficiency of the filter algorithm is slightly increasing with longer read lengths due to the bigger qgram size. The performance of the alignment step is decreasing as the alignments of the longer reads are more memory consuming on the graphics adapter. But even for 100 bp reads, the GPU implementation shows a more than 5-fold speedup compared to the CPU implementation of the same algorithm.
DISCUSSIONFor short-read alignments against microbial genomes, SARUMAN has proven to be as fast or even faster than other available approaches like SOAP2, Bowtie, BWA, SHRiMP and Pass (Tables 1 and 2). In contrast to heuristic approaches, SARUMAN guarantees to find optimal alignments for all possible alignment positions. Compared to SHRiMP, another exact aproach, SARUMAN shows a better runtime performance. Thus, it is the first non-heuristic approach providing full indel support in competitive computing time. The completeness of the SARUMAN mapping was demonstrated using a constructed dataset, where all reads could be mapped correctly (). SARUMAN is designed as a short-read alignment approach; nonetheless, it works properly and with reasonable running times for reads up to lengths of 125 bp. The qgram index used in the filter step has a memory usage that in worst case increases linearly with the size of the reference genome. Furthermore, as SARUMAN provides a proper handling of Ns in the reference sequence as well as in the reads, it cannot use two bit encoding Page: 1358 13511358
J.Blom et al.of nucleotides, which further increases the memory footprint. On a standard desktop PC with 4 GB RAM, it can map reads to all bacterial genomes in a single iteration, with 8 GB RAM fungal genomes of up to 50 Mb in size were processed in a single run. If a reference genome is too large for the available memory, it is automatically split into two or more parts as described in Section 3. Of course the running time of the algorithm has to be multiplied by the number of iterations that are needed. Due to this limitation, we propose SARUMAN as dedicated solution for read mapping on microbial reference genomes or other reference sequences of comparable size. SARUMAN does not natively support paired end sequencing data, but as all possible alignments are returned this can be handled by post-processing the results to flag read pairs as matching either in compatible distance or not. A postprocessing tool is under development. Several further improvements to SARUMAN are planned for the future. One idea is to combine the CUDA alignment module with other filter algorithms. These may be heuristic solutions to establish an even faster short-read alignment, or algorithms based on compression techniques like the BWT to reduce the memory usage and make the approach more applicable to large reference genomes. The highest potential for a further speedup has the processing of the filtering algorithm on the graphics adapter. Unfortunately, this is not yet foreseeable as it is quite complicated to handle the reference sequence data with the limited amount of memory available on the graphics cards, but it may become feasible with future generations of graphics hardware. Another planned development is a native support for color space data as generated by the SOLiD sequencing system.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
be correct, and so must be the first qR positions of k c. The remaining R positions of k c must also be correct because all errors are within segments s 1 ...s c. The last R positions of k c are not part of one of these segments, so any error within them would be the e+1st one. If k c does not match, it can be excluded that read f can be aligned to the reference sequence g with a maximum of e errors at the actual position. See Figure 2 as illustration of this matching process. Insertions and Deletions: it is possible to allow indels in the matching process by checking every segment not only on one position, but also on several positions by shifting the segment to the left or right by up to t positions, where t = e(i1) for an initial matching segment s i as at least i1 errors have already occurred in the previous i1 segments. Hence, we conclude that if there are only e errors in f , it is always possible to match (i) two segments of S or (ii) one segment of S and one segment of K. Algorithm 1 identifies reads as candidates for a NeedlemanWunsch alignment by checking for this condition. Alignment phase: as soon as a second qgram hit has been found for a given start index B, the alignment of f to g[Be,B+m+e] is enqueued for alignment and the rest of the filter phase for this value of B can be skipped. To speed up this alignment procedure in practice, the verification by alignment is computed on graphics hardware. Due to the parallel computation of alignments on graphics hardware, a huge number of possible alignment positions is collected before being submitted to the graphics card. The actual number depends on the amount of memory available on the graphics card (VRAM). The alignment of the read sequence f to the possibly matching part g[Be,B+m+e] of the reference sequence identified in the filter step is computed by a NeedlemanWunsch algorithm. On both sides of this template sequence, e, additional bases are extracted from the reference sequence to allow for indels in an end-gap free alignment. We use unit edit costs for the alignment matrix. As soon as the error threshold is exceeded in a complete column of the distance matrix, the calculation is stopped, the read is discarded and backtracing is omitted. If the complete distance matrix is computed, an optimal alignment path is calculated in the backtracing step and the read is reported as hit together with its optimal alignment. SARUMAN does not use banded alignments, yet, this is planned for future releases. 3 IMPLEMENTATION The feasibility of sequence alignments using GPU hardware was demonstrated by different tools like SW-Cuda (Manavski and Valle, 2008) or CUDASW++ (Liu et al., 2009). But, compared to our solution, existing implementations focused on the search for similar sequences in a huge set of other sequences, which corresponds to a BLAST-like use. In contrast, SARUMAN searches for local alignments of millions of short sequences against one long reference sequence. Employing the filtering algorithm described in the previous section, all possible alignment positions in the reference genome can be identified, and thereby the problem is reduced to
