Motivation: Tandem mass spectrometry has become a standard tool for identifying post-translational modifications (PTMs) of proteins. Algorithmic searches for PTMs from tandem mass spectrum data (MS/MS) tend to be hampered by noisy data as well as by a combina-torial explosion of search space. This leads to high uncertainty and long search-execution times. Results: To address this issue, we present PTMTreeSearch, a new algorithm that uses a large database of known PTMs to identify PTMs from MS/MS data. For a given peptide sequence, PTMTreeSearch builds a computational tree wherein each path from the root to the leaves is labeled with the amino acids of a peptide sequence. Branches then represent PTMs. Various empirical tree pruning rules have been designed to decrease the search-execution time by eliminating biologically unlikely solutions. PTMTreeSearch first identifies a relatively small set of high confidence PTM types, and in a second stage, performs a more exhaustive search on this restricted set using relaxed search parameter settings. An analysis of experimental data shows that using the same criteria for false discovery, PTMTreeSearch annotates more peptides than the current state-of-the-art methods and PTM identification algorithms, and achieves this at roughly the same execution time. PTMTreeSearch is implemented as a plugable scoring function in the X!Tandem search engine. Availability: The source code of PTMTreeSearch and a demo server application can be found at http://net.icgeb.org/ptmtreesearch.
INTRODUCTIONMass spectrometry is now the de facto method used for protein identification in complex biological samples. Subsequent computational analysis of data from even a single sample may be intense and involve the application of a long pipeline of various algorithms to reveal protein identification and structure. (For reviews see) Difficulties arise when unexpected or missed cleavages, point mutations and post-translational and chemical modifications need to be considered in the analysis, since the inclusion of these structural features of proteins can lead to the combinatorial explosion of the search space. This can lead to increases in search-execution time, decreases in the significance of hits, and increases in the number of false assignments. A solution to this problem involves application of a so-called two-round-search (often termed error-tolerant search) applied extensively in X!Tandem () and Mascot (). The first round of this strategy uses 'clean', i.e. unmodified peptides to identify proteins, and then in a second round of analysis, a more exhaustive search is used to identify modified peptides. This principle assumes that at least one high-quality unmodified peptide is present in the sample under analysis. Identification of post-translational modifications of proteins (PTMs) is an especially difficult task. On average, human proteins are thought to carry about three PTMs per molecule (). However, 51% of the proteins in the UniProtKB/Swiss-Prot databases are annotated with PTMs (), meaning significant variations from this estimate may exist. The current list of known PTMs is 4500, and they can be found in various lookup tables (PTMDBs, PTM databases). A good example is the RESID Database of Protein Modifications (). A PTM carried on a peptide alters the molecular weight of the peptide and the corresponding fragment ions and results in a shift within the mass spectrum fragment ion series. We term this shift a 'gap'. A PTM search can then be formalized as follows: given a theoretical and an experimental spectrum, *To whom correspondence should be addressed. insert one or more gaps into the theoretical spectrum such that it maximizes the number of the overlapping peaks or other scoring functions. The main challenge for the PTM-search algorithms is then to find such gaps that can be interpreted as PTMs in the MS/MS data, while keeping the execution time and the false discovery rate (FDR) low (). PTM-search algorithms can be categorized into three large groups: targeted, untargeted and de novo PTM-search methods (for a review see). In the case of targeted PTM searches, the user/experimenter has to specify the PTMs that may be present in the sample as an input parameter to the search program and these parameters will then be used to calculate the gaps. For instance, X!Tandem () considers one type of PTM per amino acid. However, this results in a combinatorial explosion of the search space that increases the execution time and often reduces the significance of the hits. For example, a partial (incomplete) modification, such as phosphorylation of serine would result in a mass shift of $80 Da at serine residues and would effectively double the number of serine-containing peptides. This is because each serine residue would have to be annotated with and without the mass shift due to phosphorylation. Untargeted PTM searches do not require the user to specify expected PTMs but instead use heuristic search algorithms to find modifications on the basis of a database of known PTMs. RESID () is one such database that can be used in this type of search. For instance, the algorithm PILOT_PTM (prediction via integer linear optimization and tandem mass spectrometry) uses a binary integer optimization model to find PTMs that best match the experimental data under analysis (). MODi () identifies shortsequence tags (35-amino acid long) and fills gaps between tags with amino acids that are unmodified or modified by PTMs. PTMSearchPlus () uses further information obtained from accurate intact protein mass to identify PTMs in MS/MS data. De novo PTM-search algorithms (also called 'unrestricted PTM searches or blind searches') do not use a priori information about modifications making it possible to discover novel, previously never reported, modifications. In general, a theoretical spectrum of a peptide sequence is aligned to an experimental spectrum, allowing placement of one or a few gaps in one way or another. These gaps are then reported as putative PTMs. To explain this in more detail, let  denote the mass difference between the precursor mass of the experimental spectrum and the parent mass of the theoretical peptide. Some methods have a restriction on gaps, such as the number of the gaps or the sum of the inserted gaps must be  . MS-Alignment () uses a dynamic programming approach to calculate the best alignment. A similar method has been proposed by (), but in this case does not take  into account during the alignment calculation. P-Mod (), PTMap () and pMatch () place  of each amino acid on the theoretical peptide and matches it to the experimental spectrum iteratively. In a similar manner, TwinPeaks () and DeltAMT () calculate the location of the PTM but TwinPeaks shifts the theoretical peptide over a wide range and derives the PTM mass from the shift providing the highest score. DeltAMT meanwhile assumes that both modified and unmodified versions of the peptides are present in the sample and looks for frequent occurrences of the retention time and parent ion-mass difference between spectral pairs. High concentration of such pairs is assumed to represent modification groups in the sample. OpenSea (), in a similar manner to MOD i , identifies shortsequence tags from the spectrum but fills the gaps between tags without using a PTMDB. SIMS () meanwhile interprets pairs of product ion peaks, which represent potential amino acid residues or intervals, as a means of mapping PTMs. The de novo PTM identification algorithms often misplace PTMs on the amino acid sequence or require other corrections to improve accuracy. PTMClust () and PTMFinder () have been designed to improve the quality of PTM assignments obtained with de novo PTM identification. Building a prefix tree from theoretical peptide sequences constitutes a different kind of approach wherein the problem of PTM identification is reduced to tree traversal (). For a peptide sequence p 1. .. p n of length n, a prefix tree structure can be built wherein the nodes at the i-th level of the tree are labeled with the amino acid p i and each branch represents different modifications on p i taken from a PTMDB. At each node, the corresponding theoretical fragment ion masses are calculated and matched to the experimental spectrum, providing a score for the given node. Leaves that have gathered modifications on the path from the root and add up to the parent mass difference are considered feasible solutions. The problem with this approach is the tree's size: a complete traversal is too time-consuming for practical application. A greedy traversal heuristic has previously been proposed that traverses only a fraction of the full search space thus reducing running times to a manageable level (). However, greedy algorithms may fail to find the best solution and report false annotations. Instead of developing more sophisticated tree traversal algorithms for this problem, we decided to develop treepruning rules to eliminate unlikely modifications and reduce the search space. In this article we present a novel method, called PTMTreeSearch, which is designed to identify modifications in experimental spectra using a PTMDB. PTMTreeSearch is executed in two rounds. Using strict tree-pruning rules, the first round of search is aimed at identifying a restricted set of PTM types with high confidence. The second round uses this restricted set of PTM types but runs with relaxed tree-pruning rules so as to identify more modified spectra. To the best of our knowledge, this method is the first that applies a two-stage-search approach to PTM identification. This idea is analogous to the two round peptide identification strategy used by X!Tandem and Mascot, where the first round is used to reduce the search space to likely solutions followed by an error-tolerant, more exhaustive search in the second round. The rest of this article is structured as follows: Section 2 presents the PTMTreeSearch algorithm along with the tree pruning techniques applied; Section 3 describes the datasets and methods used and Section 4 presents and discusses the results. Finally, Section 5 concludes our findings and outlines further work. Let L a be a list of modification masses (measured in Daltons) for the amino acid a and n a  jL a j denote the number of the elements in the list (0.0 Da is always included and represents no modification). A modification mass is the mass difference that the amino acid gains or losses due to the molecular modification. For example L c  /0.0, 17.0265, 47.9847, 57.0215, 71.0371,. .. , '/' means the amino acid cysteine can be (i) unmodified, (ii) lose 17.0265 Da (via losing ammonia from cysteine), (iii) gain 47.9847 Da (via complete oxidation), (iv) gain 57.0215 Da (via carbamidomethylation) and (v) gain 71.0371 Da (via propionamide), and so on. The molecular mass of cysteine is 121.16 Da and becomes 178.1815 Da after carbamidomethylation. Note that one particular amino acid molecule is not modified with more than one modification at the same time, but an amino acid can be modified with various modifications at different occurrences in the peptide sequence (and in different peptides as well). Let q be an experimental spectrum represented as a list of locationintensity peak pairs, p  a 1 a 2. .. a n be a peptide sequence, PM(q) and PM(p) denote the precursor mass of q and p, respectively, and   PM(q)  PM(p). The basic idea is to generate the theoretical fragment ion peaks for all modified variations of peptide p and store them in a prefix tree, where a branch at the level i denotes a PTM on amino acid a i. A tree node at the level i contains a structure v  hs, b, y, m, ci, where s is a score that quantifies the comparison of the peptide part a 1. .. a i to the experimental spectrum. Then c is the number and m is the sum of the mass of the acquired modifications in the sequence a 1. .. a i. The variables b and y store the masses (m/z) of the b-and y-fragment ions that correspond to the (a 1. .. a i )  m and (a i1. .. a n )    m fragment ions, respectively. Now we recursively define the tree and the values stored in the node structures as follows: the root node is h0, 0, PM(q), 0, 0i at level 0. If v  hs, b, y, m, ci is a node in the tree at the level i (0 i5n), then the node v j  hs  h, b  m ai1  m j , y  m ai1  m j , m  m j , c 0 i is a child of the node v at level i  1, where m ai1 is the mass of the amino acid a i1 , m j is the j-th modification in the list L ai1 , h is the sum of the intensities of the experimental peaks that matches to the theoretical peaks b  m ai1  m j and y  m ai1  m j within the small ion match tolerance, c 0  c  1 if m j 6  0, otherwise c 0  c (that is c 0 counts the PTMs on the a 1. .. a i1 fragment).The node v j at level i  1 represents that the amino acid a i1 in the peptide p is modified with the j-th modification from L ai1. If v is a node at level n then v is a leaf node. A leaf l  hs, b, y, m, ci is called a feasible solution if   m (up to a small precursor mass tolerance); that is the mass of the peptide with the acquired modification masses is equal to the precursor mass of the query spectrum. Note that h can be calculated in an efficient way by storing the peaks of the experimental spectrum in an ordered list ordered by the peaks' m/z locations. The score of the spectrum q and peptide p comparison is the maximum score of the feasible solutions, if there is any, otherwise 'null' is returned. This goal can be found with any kind of tree traversal method  depthfirst traversal algorithms are a good example in this case. The modifications on the peptide can then be extracted from the path between the root and the best goal leaf. Note that all nodes at level i correspond to the i-th amino acids in peptide p, and all have the same n ai number of children. Hence, the tree is balanced and all leaves have the same depth. This gives the size of the search space:which makes the time complexity of the traversal algorithm impractical. Note also that the size of the search space does not depend on the experimental spectrum. In the next subsection we define pruning techniques in order to maintain the run time polynomial and make it appropriate for real applications. An example computational tree is given in.
Search space reduction via tree pruningIn theory, for a peptide of 10 residues each modifiable by three modifications, the search space will be a tree consisting of around four million nodes. Checking all these nodes means a complete traversal of the tree would require prohibitively long calculations for practical applications. However, we can define simple rules for eliminating potential modifications and/or combinations that are unlikely to occur. This is a rule-based reduction of the search space, which corresponds to the pruning of the tree. Namely, if a rule is not fulfilled at a certain node, a sub-tree beyond the node in question is eliminated, and, as a result, tree traversal will become faster. We use the following rules.(i) Limiting the number of modifications: Let MB be a user-defined upper bound on the number of modifications allowed on any peptide. The algorithm eliminates the node v  hs, b, y, m, ci along with the corresponding sub-tree from the search space if c4MB. We noticed that applying a large MB value (say 5) leads to a disproportionally large number of erroneous annotations in short peptides (data not shown). This bias can be removed by applying a length-dependent upper bound, MB 0  min(MB, n/3), where n is the length of the peptide in question.(ii) Excluding adjacent, compensatory modifications: In the database of modifications there are 102 pairs in which the mass change is identical but of adverse sign. We term these 'pairscompensatory' modifications. For instance, hydroxylation of lysine to hydroxyl-lysine leads to a mass gain of 15.9994 Da, while reduction of serine to alanine (or threonine to-aminobutyrate) leads to a mass loss of 15.9994 Da. The algorithm would automatically allow these pairs to be included since the overall mass of the peptide would not change. Currently we disallow such compensatory modifications if they are adjacent (but are not necessarily on two subsequent amino acids). If the sum of the peak shifts caused by two adjacent PTMs is 0 within a certain tolerance, the node and the respective sub-tree will be pruned from the tree.(iii) Excluding non-productive modifications: In the first approximation, a PTM is accepted if adding its mass shift to the corresponding theoretical peaks (type b-and its complementary peak. Illustration of a computational tree representation of the search space of the peptide MQLSQL, where the amino acid M can be oxidized, Q can carry 0.98 and 31.9898 modifications, and where the curly bracket shows the structure of a node. Each path from the root to the leaf represents a modified peptide and each branch represents an insertion of a modification to the peptide of type y-) will cause the modified peak to match with one peak of the experimental spectrum. Formally, the node v j  hs', b', y', m', c'i is to be deleted if c 0 4c and s  s 0 with respect to its parent node v  hs, b, y, m, ci.(iv) Setting a threshold on matching intensities: In practice, an experimental-theoretical spectrum comparison can be considered acceptable if the total intensity of the matching peaks exceeds a certain threshold. The algorithm applies such a threshold and prunes a node when the score of the current node plus a predicted score for the path from the current node to leaves does not exceed a certain value. Formally, let S be the sum of the intensity of the d most intense experimental peaks, where d is the number of the theoretical peaks of the peptide and let matching intensities (score ratio (SR)) be a user-defined threshold (05SR51). The node v  hs, b, y, m, ci at level i is to be eliminated if (s/S  (n  i)/ n)5SR. Score estimation for a path connecting a node to a leaf is a widely used technique in A*-algorithms (). (v) Equilibrated matching frequencies: We define matching frequency as the number of theoretical peaks matching with the experimental peaks divided by the total number of the theoretical peaks. By prescribing equilibrated matching frequencies, we require that the matching frequency of fragments carrying 0, 1, 2,.. . PTMs, respectively, should be roughly the same. For instance, if a peptide has 10 unmodified fragments, 20 fragments carrying one PTM and 10 fragments carrying two PTMs, we expect that the ratio of matching peaks should be roughly the same, say 40%, in all three groups. For quantifying the evenness of the distribution, we define the modified peptide entropy score (MPE), which is based on the formula of Shannon entropy (see Supplementary Materials Section S1 for the formal definition). MPE is 1.0 when the modified fragment ions match to experimental peaks evenly, while MPE is 0.0 when only one type of (modified or non-modified) fragment matches. We note that MPE does not take into account the number of the matching peaks and it can give 1.0 as a value for poor but evenly matching frequencies (such as those that occur in random spectrumpeptide comparisons). Hence, MPE does not substitute the usual scoring function but rather complements it. A high MPE score is a necessary but not sufficient condition for identifying modified peptides. This rule is applied on feasible solutions (leaves)i.e. it filters solutions but not tree nodes. Hence application of this rule does not speed up the calculations, but improves accuracy by eliminating ambiguous annotations. PTMTreeSearch builds, explores and applies the pruning rules simultaneously, i.e. it does not build a full tree before pruning it. PTMTreeSearch builds the tree recursively, starting from the root node and applies the tree pruning rules in each newly created node. In addition, tree traversal follows a depth-first search strategy, meaning that only the path from the root to the current node is kept in memory. As a consequence, the RAM requirement of PTMTreeSearch is low. We note that rules defined here can be applied independently from each other. Supplementary Material Section S3 shows a flowchart and a pseudo code of the algorithm.
Two-stage searchingPruning parameters [MB, non-productive modifications (NPM), SR, MPE] determine the size of the search space. Strict parameter settings (small MB, NPM, high SR and high MPE) allow identification of high confidence PTMs in good quality spectra in relatively short times. Conversely, loose parameter settings (high MB, without NPM, low SR and low MPE), allow the analysis of a larger search space and give rise to a larger set of PTMs at the expense of running time. In order to keep the benefits of both strategies, PTMTreeSearch is implemented in a two-round fashion. The first round uses strict parameter settings and serves to identify a smaller set of likely PTM types, while looser parameter settings applied in the second round identify all possible occurrences of this restricted set of PTM types. This approach is based on the assumption that each modification type present in a sample has to be found in at least one good quality spectrum. This idea builds on the two-step database search principle used by programs such as X!Tandem and Mascot.
Implementation, availability, and remarksPTMTreeSearch is written in C using MPICH (message passing interface) parallelization technology. It is implemented as a pluggable scoring function () within the X!!Tandem search engine (), which is a parallel version of the X!Tandem program. PTMTreeSearch consists of two main classes. One class is called PTMTreeSearchScore. It derives from the class mscore_tandem and it implements the PTMTreeSearch method. The other class is called PTMTreeSearch. It derives from the mrefine class and initializes the variables, loads the modifications, launches the spectrum-peptide comparisons using PTMTreeSearchScore and collects the modifications found. The PTMTreeSearch class carries out the two-stage searching. The source code of PTMTreeSearch along with an installation guide and the parameter specifications can be found at http://net.icgeb.org/ptmtree search/doc. For demonstration purposes, we developed a web server that contains the X!!Tandem search engine with PTMTreeSearch included (http://net.icgeb.org/ptmtreesearch). We note that X!Tandem uses a binning technique for peak representation, while in contrast PTMTreeSearch uses the exact measured location of the peaks and the accurate mass of the modifications. The latter was chosen because it provides a higher accuracy than a binning approach.shows PTMTreeSearch within the X!Tandem pipeline. X!!Tandem implements reading of the input experimental spectra, filters and manages the results and outputs it in a standard manner. From X!Tandem, as it is specified in the input parameter file, PTMTreeSearch obtains the parameter settings, such as the tolerance parameters, fragment ions to score (a-, b-, c-, x-, y-, z-ions) and considers partial, missed cleavage and multiply charged precursor ions. Fixed modifications defined in X!Tandem are not included up to the allowed PTM limit MB.
Methods and datasets
Spectrum datasetsused for testing 'The Aurum' dataset is a publicly available dataset that contains 9832 singly charged spectra generated on an ABI 4700 MALDI TOF/TOF instrument from 246 purified and trypsin-digested protein samples. This dataset was explicitly designed for testing novel MS/MS algorithms and tools ().The data were downloaded from ProteomeCommons.org Tranche network via the following hash: HnxUzQuuP7BIqF10aetLtjwnffOwuOMAfDvg2BFmenNe9Ue MgprBFh7wtpbcWnXqMk2KY-8z9VjmwqXY DbQ0pTNqIx4AAAAAA SJlaw . 'HSPP2A' is a dataset containing 29 583 spectra (20 773 doubly and 8706 triply, 474 quadruply, 26 quintuply and four hexuply charged spectra) and was obtained with an LTQ mass spectrometer. The data were obtained from trypsin digested proteins of the human protein phosphatase 2A system () and downloaded from www.peptideatlas. org/repository/publications/ Glatter2008. The Universal Proteomics Standard I (Sigma) dataset (UPS1) contains 3368 singly charged spectra obtained from 50 trypsindigested proteins using an Applied Biosystems 4800 MALDI TOF/TOF instrument (). The data were obtained from the authors.
Protein sequences Computational identification of PTMs requires a collection of protein sequences, which are selected by the experimenter, and will be dependent on the goal of the experiment. In order to compare various algorithms on an equal footing, we compiled uniform collections of protein sequences that were then used with each PTM finder program used in this work. Each spectral dataset was submitted to the X!Tandem program using the IPI.Human v3.81 protein sequence dataset (), and the proteins that passed to the second round were collected in separate FASTA files (). For statistical analysis, we constructed decoy datasets () from reversed sequences (). The target and reverse datasets were unified in concatenated FASTA files before use by various programs. Supplementary Material Section S8 shows a summary of the datasets and the corresponding parameters used.
Performance evaluation The performance was evaluated usingthe receiver operator characteristic (ROC) curve technique (). Annotated spectra were ranked according to a matching score. Spectra annotated with target peptide sequences were then plotted as a function of the number of spectra annotated with a decoy peptide sequence by varying a threshold over the ranking variable range. This plot gives a monotonously increasing curve, the ROC curve. A higher running ROC curve indicates better performance. The false discovery rate (FDR) was calculated as the ratio of the number of the decoy hits over the number of positive hits at a certain threshold t using the following formula ():The ROC plot can also be used to compare methods at the level of the same FDR. For instance, FDR  1% is a straight line in the ROC plot, and the intersections with the ROC curves indicate the number of target and decoy peptides found at the same level of FDR. The FDR  100% would coincide with the diagonal x  y line.
PTMfinding programs 'InsPecT' [version 2012.01.09 (was downloaded from the project web site (http://prote omics.ucsd.edu/Software/Inspect.html) and installed on Linux. Inspect was running in 'unrestrictive' mode in order to find modifications in a de novo way. No fixed or partial modifications were included as parameters. The parameter MaxPTMSize was set to 200 Da. The results files were then post-processed by ComputeFDR.jar script (part of Inspect) and the field InspectFDR was used as a ranking variable for the ROC analysis. MOD i v3.01 () was run remotely at the web server available at http://prix.hanyang.ac.kr/modi/search.jsp. The runs were performed without fixed modifications and by allowing all 615 variable modifications present in the database of MOD i. The modification range was set from 50 to 200 Da. The ROC analysis was carried out using the 'Probability' field as ranking parameter. 'SIMS' () was obtained from the authors. SIMS was used with the 'FULL_TRYPTIC FALSE' parameter setting and the modification range was set to 0200 Da. No fixed or variable modifications were used. 'X!Tandem' version 10-12-01 () was downloaded from www.thegpm.org. For the experimental calculations only, the source code of X!Tandem was slightly altered such that it uses the complete restricted protein sequences in the second round in order to allow FDR and ROC calculations based on target/decoy comparisons. The LogE values taken from the X!Tandem output file were used for FDR and ROC calculations.
Computational environment All programs (except MOD i ,which was run on a web server) were executed on a Linux cluster consisting of one frontend and 20 backend nodes, each equipped with 2.2 Ghz CPU and 2 GB memory. The execution time was calculated as if the experiments were run on a single CPU computer in order to make the execution time comparable with other methods.
RESULTS AND DISCUSSIONS
Comparison of tree-pruning strategiesPTMTreeSearch has three parameters (MB, SR, NPM) that control the size of the search space. In this section we investigate their impact on accuracy and execution time. First, we fixed MB  1 and MPE  0.0, and we defined six search strategies () for the SR and NPM, in which the size of the search space gradually decreases from complete search (no tree pruning) to restricted search (strict tree pruning).These search strategies were applied to the three spectrum datasets and the identified peptides (spectra that are assigned to a peptide sequence), the modified peptides (peptides that carry at least one modification) and the modification types (a modification from the PTMDB, such as carbamidomethylation of cysteine or oxidation of methionine) were counted at the level of 1% FDR. Note that the number of identified peptides includes both modified and unmodified peptides. The exact numbers can be found in the Supplementary Materials, Section S4. On each dataset, the relative increase or decrease in speed, compared to the full search (Search Strategy 1) were calculated, and averaged over the three spectrum datasets. These are illustrated in. As expected, stricter pruning rules reduced the execution time (PTMTreeSearch became 34-times faster) however they also reduce the number of the identified modification types and annotated modified peptides. We have evaluated the six search strategies using MB  2, and the results are presented in the Supplementary Materials Table S4,in Section S4. These results show that larger search space can result in higher execution times and fewer annotations at FDR  1%. When tree-pruning rules are applied, the execution time decreases significantly and the number of annotated peptides increases. In order to further improve the performance we decided to implement a two-stage-search process.
Two-stage searchIn the first stage of this strategy, strict tree pruning rules are used to identify trusted modification types from PTMDB. The modification types found in the first stage are filtered according to the MPE criterion as described in Supplementary Materials Sections S1 and S2. A more exhaustive search is then performed in the second round, using this relatively small set of trusted modification types in conjunction with more relaxed tree pruning rules. In practice, we used MB  1, with NPM, SR  0.4 and MPE  0.99 as the parameter settings for the first round. The impact of the MPE on the number of the modification types and on the results can be found in the Supplementary Materials (Section S2). A comparison of PTMTreeSearch with MPi Preview v1.0 is shown in Supplementary Material Section S6. For the second stage, we used the following parameter settings: SR  0.3, without NPM, and MPE  0.00, with various values (between 1 and 5) for MB. The number of allowed modifications, MB, is a critically important parameter since it regulates the search space size in all PTM finding algorithms. Untargeted PTM finders used in practice frequently produce prohibitively long running times if more than two or three modifications are allowed, while de novo PTM finders usually allow one modification per peptide. The effect of MB on the performance of PTMTreeSearch is shown in. Data used for the figure can be found in the Section S5 in the Supplementary Materials. In these experiments, MB was varied only in the second round of the search. The data show that allowing more modifications dramatically increases the running time of PTMTreeSearch. Allowing four to seven modifications increases the running times by 1050 times, respectively. It is also apparent that allowing more than three or four modifications does not improve the number of correct assignments. The change in correct assignments is simply due to the fact that the combinations of more modifications can easily produce random matches which will then impair the significance of the hits. Therefore an optimal settings for the two-stage search process we propose are MB  1, using NPM, SR  0.4, MPE  0.99, for the first round and SR  0.3, MPE  0.0, without NMP and MB  1, 2, 3. The Section S5 in the Supplementary Materials presents results with various parameter settings.
Comparison of PTMTreeSearch with other state-of-the-art methodsThe performance of the optimized two-stage PTMTreeSearch was compared to InsPecT, MOD i and SIMS using the ROC analysis and shown in. At any given FDR, PTMTreeSearch identifies more peptides and misses relatively fewer than the other methods.shows that PTMTreeSearch identifies 73% more and misses 13% less peptides on average in comparison to the other methods at FDR  1%. For a detailed comparison and execution times see Supplementary Tables S12 and S13, respectively. Supplementary Excelpresents a summary about known modification types found in UPS1 dataset. If one PTM is allowed, the running time of PTMTreeSearch compares quite favorably to those of the other programs. If we allow more modifications, PTMTreeSearch becomes slower. For these cases, we cannot compare the accuracies since InsPecT and SIMS allow only one modification per peptide. We also evaluated PTMTreeSearch on the PTM benchmarking dataset of The Proteome Informatics Research Group (iPRG) of the Association of Biomolecular Resource Facilities (ABRF), which was designed for a programming contest in 2012 (http://www.abrf.org/index.cfm/group.show/ProteomicsInformat icsResearchGroup.53.htm#R_4). This spectrum dataset has been spiked with 69 additional synthetic peptides, with modified phosphorylation, methylation, acetylation, nitro, sulfation, etc. We compared PTMSearch with the two best anonymous contest participants, 71755v and EK93128i, as well as Inspect, SIMs and MODi. Supplementaryshows that PTMTreeSearch identifies 35% more peptides than the two best submissions, compared at FDR  1%. Supplementary Excelsummarizes the modification types found in this dataset. Supplementary Excelshows a separate list of hits found on the 69 spiked modified. The effect of allowed modifications on the number of assignments (number of identified peptides, modified peptides) in the two-stage search. The general parameter settings were (MB  1, with NPM, SR  0.4, MPE  0.99) for the first and (SR  0.3, without NPM, MPE  0.0) with MB  1,.. . , 5 for the second stage, respectively. MB was varied in round 2 only. The data were normalized by taking the number of assignments and the running time values of the full database search as 100%, and then the data obtained on the three datasets were averaged. The effect of tree pruning on execution times and the number of assignments (peptides, modified peptides, modification types). The abbreviations of the tree-pruning strategies are explained in the text. The data were normalized by taking the number of assignments and the running time values of the full database search as 100%, and then the data obtained on the three datasets (Aurum, UPS1, HSPP2A) were averaged. Two-stage searchpeptides. In this comparison, PTMTreeSearch was also one of the best performers, although this, depended on the number of modifications allowed (See Supplementary Materials Section S8 for further details). We have compared the current version of the PTMTreeSearch to its previous version (). In the earlier version, the full search space was traversed using a greedy algorithm allowing for backtracking with a limited size priority double-ended queue. On average, on our datasets, the greedy approach identifies 36% more modification types, but 5% fewer peptides, 18% fewer modified peptides and takes three and half times longer than the current version of PTMTreeSearch. Data are shown in the Section S7 in Supplementary Materials. The time increase is due to the priority queue operations, which are logarithmic in time. The current version of PTMTreeSearch using treepruning rules and a two-round search strategy provided more assignments in shorter running times.
CONCLUSIONSIn this article, we have presented a novel algorithm called PTMTreeSearch for identification of PTM in tandem mass spectrometry data using a large collection of known amino acid modifications. The method employs a prefix tree for search space representation where branches represent PTMs and tree pruning techniques are used to eliminate unlikely solutions and to reduce the execution time. Moreover, it uses a two-stage search, where a small set of trusted modification types are identified in the first round, and this restricted set of modification types is used in the second round to identify PTMs in an exhaustive manner. We believe PTMTreeSearch and the state-of-the-art methods (such as Inspect, SIMS, MOD i ) are able to find the PTMs in a complex biological sample. The question remains whether modifications are identified with high confidence or if the modified peptide annotation vanishes among the decoy matches. In our opinion the computational tree provides a natural way to represent the search space for finding modifications and avoiding redundant calculations. The tree pruning techniques and the two-stage search provide more accurate modification identification at a reasonable time cost, and identifies more peptides than current state-of-the art PTM finder algorithms at the same FDR level. We implemented PTMTreeSearch as a plug-in of the X!Tandem framework, and hence PTMTreeSearch is fully compatible with all data and output formats of X!Tandem. In addition, PTMTreeSearch fixes one drawback of X!Tandemnamely, that X!Tandem cannot detect different modifications on the same type of amino acid (not on the same side-chain). For example, with PTMTreeSearch it becomes possible to search for multiple modifications of cysteine without multiple searches. Simply put, if the corresponding modifications are part of the user-defined PTMDB, PTMTreeSearch will consider them in various combinations on the peptide sequences at the same time. Finally, we note that PTMTreeSearch interprets peak shifts using known PTMs, so it cannot identify PTMs that neither induce peak shifts nor alter the type of the product ions.
ACKNOWLEDGEMENTSThe authors thank Drs. Yoonsung Joh, Eunok Paek and the MODi team for their help with using MODi program as well as to Dr Max Bingham (freelance, Rotterdam, The Netherlands) for editorial assistance prior to submission.
The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
PTMTreeSearch at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
A.Kert sz-Farkas et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
