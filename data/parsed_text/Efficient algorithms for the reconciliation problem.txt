Motivation: Gene family evolution is driven by evolutionary events such as speciation, gene duplication, horizontal gene transfer and gene loss, and inferring these events in the evolutionary history of a given gene family is a fundamental problem in comparative and evolutionary genomics with numerous important applications. Solving this problem requires the use of a reconciliation framework, where the input consists of a gene family phylogeny and the corresponding species phylogeny, and the goal is to reconcile the two by postulating speciation, gene duplication, horizontal gene transfer and gene loss events. This reconciliation problem is referred to as duplication-transfer-loss (DTL) reconciliation and has been extensively studied in the literature. Yet, even the fastest existing algorithms for DTL reconciliation are too slow for reconciling large gene families and for use in more sophisticated applications such as gene tree or species tree reconstruction. Results: We present two new algorithms for the DTL reconciliation problem that are dramatically faster than existing algorithms, both asymptotically and in practice. We also extend the standard DTL reconciliation model by considering distance-dependent transfer costs, which allow for more accurate reconciliation and give an efficient algorithm for DTL reconciliation under this extended model. We implemented our new algorithms and demonstrated up to 100 000-fold speed-up over existing methods, using both simulated and biological datasets. This dramatic improvement makes it possible to use DTL reconciliation for performing rigorous evolutionary analyses of large gene families and enables its use in advanced reconciliation-based gene and species tree reconstruction methods. Availability: Our programs can be freely downloaded from
INTRODUCTIONGene families evolve through complex evolutionary processes such as speciation, gene duplication, horizontal gene transfer and gene loss. Accurate inference of these events is crucial not only to understanding gene and genome evolution but also for reliably inferring orthologs, paralogs, and xenologs (To whom correspondence should be addressed); reconstructing ancestral gene content and dating gene birth (); accurate gene tree reconstruction (); and for whole genome species tree reconstruction (). Indeed, the problem of inferring gene family evolution has been extensively studied. In the typical formulation of this problem, the goal is to reconcile an input gene tree (gene family phylogeny) to the corresponding rooted species tree by postulating speciation, duplication, transfer and loss events. Much of the previous work in gene treespecies tree reconciliation has focused on either duplication loss (DL) () or transfer loss (TL) (), but not on duplication, transfer and loss together. However, duplication and transfer events frequently occur together, particularly in prokaryotes, and the analysis of such families requires reconciliation methods that can simultaneously consider duplication, transfer and loss events. This problem of gene treespecies tree reconciliation by duplication, transfer and loss simultaneously is referred to as the duplication TL (DTL) reconciliation problem. Previous work. The DTL reconciliation problem has a long history and is well studied in the literature. This is partly due to its close association with the hostparasite cophylogeny problem () which seeks to understand the evolution of parasites (analogous to genes) within hosts (analogous to species). Almost all known formulations of the DTL reconciliation problem are based on a parsimony framework () (but see alsofor an example of a probabilistic formulation, as well asfor a probabilistic framework based on gene content). Under this framework, each duplication, transfer and loss event is assigned a cost and the goal is to find a reconciliation that has the lowest total reconciliation cost. Optimal DTL reconciliations can sometimes violate temporal constraints; that is, the transfers are such that they induce contradictory constraints on the dates for the internal nodes of the species tree. We refer to such paradoxical reconciliations as time-inconsistent (after). In general, it is desirable to consider only those DTL reconciliations that are time-consistent (i.e. paradox-free). Henceforth, we refer to the problem of specifically computing optimal time-consistent
M.S.Bansal et al.DTL reconciliations as the tcDTL Reconciliation problem. Although the DTL reconciliation problem can be solved in polynomial time, solving the tcDTL reconciliation problem is NP-hard (). If divergence time information is available for the nodes of the species tree (or if there is a known relative temporal ordering for each pair of internal nodes), then any proposed DTL reconciliation must also respect the temporal constraints imposed by the available timing information, i.e., transfers must be restricted to occur only between coexisting species. When such divergence timing information is available, even the tcDTL reconciliation problem becomes polynomially solvable (LibeskindHadas and Charleston, 2009). (Note, however, that time-consistency cannot be guaranteed just by ensuring that transfers occur between coexisting species). In general, the input species tree can be undated, partially dated, or fully dated depending on whether the divergence timing information associated with the nodes of the species tree is absent, partial, or complete, respectively. Thus, in practice, when the species tree is undated or partially dated, one solves the DTL reconciliation problem, and if the species tree is fully dated, one can solve either the DTL reconciliation or the tcDTL reconciliation problem. Let m denote the number of leaves in the input gene tree and n the number of leaves in the species tree. Both the DTL reconciliation problem and the tcDTL reconciliation problem, along with some of their variants, have been extensively studied in the literature (). The most recent algorithmic work on these problems includes;;; and David and Alm, 2011. The paper bystudies a restricted version of the reconciliation model that ignores losses (equivalent to assigning a cost of zero for loss events under the DTL reconciliation problem) and shows that, under this restricted model, the DTL reconciliation problem on undated trees can be solved in O(mn 2 ) time. They also gave a fixed parameter tractable algorithm for enumerating all most parsimonious reconciliations. The time complexity of the O(mn 2 )time algorithm was further improved to O(mn) in(under the same restricted reconciliation model). However, with the increasing availability of whole-genome datasets, such a restriction on the reconciliation model can be problematic as losses are a rich source of information that can be critical for accurate reconciliation. Indeed, losses play a fundamental role in the ability to distinguish between duplications and transfers as well as in mapping the nodes of the gene tree into the nodes of the species tree, and thus should be explicitly considered during reconciliation. The paper byshowed that, for fully dated species trees, the tcDTL reconciliation problem could be solved in O(mn 2 ) time. Recently, an O(mn 2 )-time algorithm for the tcDTL reconciliation problem on fully dated trees has also been independently developed for Version 2 of the program Jane (). Finally, the recent paper bygave an O(mn 2 )-time algorithm for the DTL reconciliation problem on undated trees. In summary, in spite of tremendous methodological and algorithmic advances, even the fastest existing algorithms for DTL reconciliation () as well as for tcDTL reconciliation on fully dated trees () still have a time complexity of (mn 2 ). This makes them too slow to reconcile trees with more than a few hundred taxa, and completely unsuitable for all but the smallest trees when used in sophisticated applications such as reconciliation-based gene tree or species tree reconstruction that require the reconciliation of a multitude of trees while searching through tree space (). Our contributions. Recall that the DTL reconciliation problem, even on fully dated species trees, does not guarantee that the optimal reconciliation is time-consistent, whereas the tcDTL reconciliation problem does. However, the tcDTL reconciliation problem suffers from two major drawbacks that limit its applicability in practice. First, the tcDTL reconciliation problem can only be solved efficiently when the species tree is fully dated. This limits its application to only those species tree that contain a relatively small number of taxa (say <100). This is because, it can be extremely difficult to accurately date large species trees () and the accuracy of tcDTL reconciliation relies implicitly on having a correctly dated species tree. Second, the time complexity of the fastest known algorithm for the tcDTL reconciliation problem is O(mn 2 ), which makes it too slow to be used with large datasets (as we also demonstrate later). This also makes it too slow for reconciliation-based gene tree reconstruction of even relatively small gene trees, as it involves repeatedly reconciling a multitude of candidate gene trees against the species tree. Furthermore, the tcDTL reconciliation problem cannot be used for reconciliationbased whole-genome species tree construction (also called gene tree parsimony), as the topology of the species tree is repeatedly modified and so at each step, the species tree is undated. Thus, in this work, we focus on the DTL reconciliation problem. In particular, we improve upon the current state of the art for the DTL reconciliation problem in the following ways:(1) We provide an O(mn)-time algorithm for the DTL reconciliation problem on undated species trees. This improves on the fastest known algorithm for this problem by a factor of n. The DTL reconciliation problem on undated trees is the most common version of the DTL reconciliation problem and arises whenever the species tree cannot be accurately dated, as is usually the case with large gene families, and in applications such as reconciliation-based species tree reconstruction.(2) For the DTL reconciliation problem on fully dated species trees, we provide an O(mn logn)-time algorithm, which improves on the fastest known algorithm for this problem by a factor of n/logn. Even though the fully dated version of DTL reconciliation does not guarantee time-consistency, as we show later using thorough experimental studies, optimal DTL reconciliations closely approximate optimal tcDTL reconciliations. This algorithm is thus meant as a faster alternative to the O(mn 2 )-time algorithm for tcDTL reconciliation.(3) We give a simple O(mn 2 )-time algorithm for DTL reconciliation that can handle distance-dependent transfer costs and can work with undated, partially dated, or fully dated species trees. This is a factor of n faster than the fastest known algorithm that can handle distance-dependent transfer costs ()
Reconciliation using Duplication, Transfer, and Lossa fixed transfer cost (), and its use may lead to more accurate DTL reconciliations.In addition, we also discuss how to efficiently incorporate other enhancements such as detecting transfers from unsampled or extinct lineages that further improve the accuracy of DTL reconciliation. Our O(mn)-time algorithm for undated species trees builds on the O(mn)-time algorithm from Tofigh (2009) that computes optimal reconciliation scenarios under a simpler reconciliation cost that ignores losses. Specifically, we show how to augment that algorithm to efficiently keep track of losses as well. Fully dated species trees presented a greater algorithmic challenge and to obtain our fast O(mnlogn)-time algorithm, we developed a novel algorithmic framework that exploits the structure of fully dated species trees and makes use of recent algorithmic advances on the dynamic range minimum query problem (). Our new algorithms and other enhancements represent a great improvement in the runtime and applicability of DTL reconciliation compared with extant approaches. They not only make it possible to analyze large gene families but also to quickly analyze thousands of gene families from across the entire genomes of the species under consideration. Furthermore, and perhaps most importantly, they make DTL reconciliation much more amenable for use in sophisticated applications such as reconciliation-based gene tree or species tree reconstruction. The ability to efficiently handle distancedependent transfer costs, as well as the other enhancements, in turn, makes it possible to reconstruct the evolutionary history of gene families even more accurately. We benchmark our algorithms to both simulated and biological datasets and demonstrate the dramatic improvements in runtime at a range of dataset sizes. We also assess the accuracy of DTL reconciliation, on both dated and undated species trees, compared with optimal tcDTL reconciliations on fully dated trees and demonstrate the utility of using distance-dependent transfer costs in the reconciliation model. In the interest of brevity, all proofs appear in the Supplementary Material (Section S.1).
DEFINITIONS AND PRELIMINARIESGiven a tree T , we denote its node, edge and leaf sets by V (T ), E(T ) and Le(T ), respectively. If T is rooted, the root node of T is denoted by rt(T ), the parent of a node v  V (T ) by pa T (v), its set of children by Ch T (v), and the (maximal) subtree of T rooted at v by T (v). If two nodes in T have the same parent, they are called siblings. The set of internal nodes of T , denoted I (T ), is defined to be V (T )\Le(T ). We define  T to be the partial order on V (T ), where x  T y if y is a node on the path between rt(T ) and x. The partial order  T is defined analogously, i.e., x  T y if x is a node on the path between rt(T ) and x. We say that v is an ancestor of u, or that u is a descendant of v, if u  T v (note that, under this definition, every node is a descendant as well as ancestor of itself). We say that x and y are incomparable if neither u  T v nor v  T u. Given a non-empty subset L  Le(T ), we denote by lca T (L), the least common ancestor (LCA) of all the leaves in L in tree T ; that is, lca T (L) is the unique smallest upper bound of L under  T. Given x,y  V (T ), x  T y denotes the unique path from x to y in T. We denote by d T (x,y) the number of edges on the path x  T y. Throughout this work, unless otherwise stated, the term tree refers to a rooted binary tree. A species tree is a tree that depicts the evolutionary relationships of a set of species. Given a gene family from a set of species, a gene tree is a tree that depicts the evolutionary relationships among the sequences encoding only that gene family in the given set of species. Thus, the nodes in a gene tree represent genes. We assume that each leaf of the gene trees is labeled with the species from which that gene was sampled. This labeling defines a leaf-mapping L G,S : Le(G)  Le(S) that maps a leaf node g  Le(G) to that unique leaf node s  Le(S) which has the same label as g. Note that gene trees may have more than one gene sampled from the same species. Throughout this work, we denote the gene tree and species tree under consideration by G and S, respectively, and will implicitly assume that L G,S (g) is well defined.
Reconciliation and DTL scenariosCopyedited by: TRJ MANUSCRIPT CATEGORY:(b) At least one of M(g ) and M(g ) is a descendant of(3) Given any edge (g,g )  E(G), (g,g )  if and only if M(g) and M(g ) are incomparable.(4) If g  I (G) and g and g denote the children of g, then,(a) g  only if M(g) = lca(M(g ),M(g )) and M(g ) and M(g ) are incomparable,(c) g  if and only if either (g,g )  or (g,g )  ,(d) If g  and (g,g )  , then M(g) and  (g) must be incomparable, the species represented by them must be potentially coexisting with respect to the available divergence time estimates, and M(g ) must be a descendant of Constraint 1 above ensures that the mapping M is consistent with the leaf mapping L. Constraint 2(a) imposes on M the temporal constraints implied by S. Constraint 2(b) implies that any internal node in G may represent at most one transfer event. Constraint 3 determines the edges of G that are transfer edges. Constraints 4(ac) state the conditions under which an internal node of G may represent a speciation, duplication and transfer, respectively. Constraint 4(d) specifies which species may be designated as the recipient species for any given transfer event. DTL scenarios correspond naturally to reconciliations and it is straightforward to infer the reconciliation of G and S implied by any DTL scenario.shows two simple DTL scenarios. Given a DTL scenario, one can directly count the minimum number of gene losses in the corresponding reconciliation as follows:Definition 2.2 (Losses). Given a DTL scenario, for G and S, let g  V (G) and {g ,g }=Ch(g). The number of losses Loss  (g) at node g is defined to beWe define the total number of losses in the reconciliation corresponding to the DTL scenario  to be Loss  = gI (G) Loss  (g). Let P , P and P loss denote the costs associated with duplication, transfer and loss events respectively. The cost of reconciling G and S according to a DTL scenario  is defined as follows. Definition 2.3 (Reconciliation cost of a DTL scenario)., for G and S, the reconciliation cost associated with  is given byGiven G and S, our goal is to find a most parsimonious reconciliation of G and S. More formally.Based on whether the species tree is undated or fully dated, we distinguish two versions of the MPR problem: (i) The undated MPR (U-MPR) problem where the species tree is undated and (ii) the fully dated MPR (D-MPR) problem where every node of the species tree has an associated divergence time estimate (or there is a known total order on the internal nodes of the species tree). We will exploit the local structure unique to each version to develop faster algorithms for them.
COMPUTING THE MOST PARSIMONIOUS RECONCILIATIONIn this section, we first develop our fast algorithms for the UMPR and D-MPR problems and then give a simple O(mn 2 )-time algorithm for the (general) MPR problem that can efficiently handle distance-dependent transfer costs. Before we proceed, we need a few definitions and additional notation. Definitions: Given any g  I (G) and s  V (S), let c (g,s) denote the cost of an optimal reconciliation of G(g) with S such that g maps to s and g . The terms c (g,s) and c (g,s) are defined similarly for g  and g  , respectively. Given any g  V (G) and s  V (S), we define c(g,s) to be the cost of an optimal reconciliation of G(g) with S such that g maps to s. Thus,incomparable to s c(g,x), and inAlt(g,s) = min xV (S(s)) c(g,x). In other words, inAlt(g,s) is the cost of an optimal reconciliation of G(g) with S such that g may map to any node in V (S(s)); out(g,s) is the cost of an optimal reconciliation of G(g) with S such that g may map to any node from V (S) that is incomparable to s; and in(g,s) is the cost of an optimal reconciliation of G(g) with S such that g may map to any node, say x, in V (S(s)) but with an additional reconciliation cost of one loss event for each edge on the path from s to x. Note that the optimal reconciliation cost of G and S is simply: min sV (S) c(rt(G),s). The equation for c(g,s) above, used in a dynamic programming framework and coupled with methods for computing the values of c (g,s), c (g,s) and c (g,s), forms the basis of all our algorithms.
i286
Reconciliation using Duplication, Transfer, and Loss
An O(mn)-time algorithm for U-MPRThe following algorithm solves the U-MPR problem in O(mn) time. Our algorithm builds on the O(mn)-time dynamic programming algorithm from Tofigh (2009) that computes optimal reconciliation scenarios under a simpler reconciliation cost that ignores losses. We compute the values c (g,s), c (g,s) and c (g,s) for each g  V (G) and s  V (S) by performing a nested post-order traversal of G and S. For efficiency, we save and reuse as much of the computation from previous steps as possible, and the values in(,), inAlt(,) and out(,) help us in efficiently computing the values c (g,s), c (g,s), and c (g,s) at each dynamic programming step. For instance, for any g  I (G), the value of c (g,s) is simply:  if s  Le(S), and min{in(g ,s )+in(g ,s ), in(g ,s )+in(g ,s )}, where {g ,g }=Ch G (g) and {s ,s }=Ch S (s), if s  I (S). The values of c (g,s) and c (g,s) can be similarly computed; see Steps 10 and 18 of Algorithm U-Reconcile for c (g,s) and Steps 11 and 19 for c (g,s). The nested post-order traversal ensures that when computing the values c (g,s), c (g,s) and c (g,s) at nodes g  G and s  S, all the required in(,), inAlt(,), out(,) and c(,) values have already been computed. Algorithm U-Reconcile(G,S,L) 1. for each g  V (G) and s  V (S) do
2.Initialize c(g,s), c (g,s), c (g,s), c (g,s), in(g,s), inAlt(g,s), and out(g,s) to . 3. for each g  Le(G) do
4.Initialize c(g,L(g)) to 0, and, for each s  S L(g), initialize in(g,s) to P loss d S (s,L(g)) and inAlt(g,s) to 0. 5. for each g  I (G) in post-order do
6.for each s  V (S) in post-order do
7.Let {g ,g }=Ch G (g).
8.if s  Le(S) then 9. c (g,s) =.
10.c (g,s) = P +c(g ,s)+c(g ,s).
11.If s = rt(S), then c (g,s) = P +min{in(g ,s)+ out(g ,s), in(g ,s)+out(g ,s)}.
12.c(g,s) = min{c (g,s),c (g,s),c (g,s)}.Note that, while the above algorithm only outputs the optimal reconciliation cost, it can be easily adapted, without affecting its time complexity, to output the DTL scenario itself. (ii) The algorithm above implicitly assumes that if g  I (G) is a transfer node such that (g,g )  , then  (g) = M(g ). The reason for this is easy to see: any reconciliation in which  (g) is not M(g) (and losses have a strictly positive cost), cannot be most parsimonious. This, however, only holds true for the U-MPR problem, and we will be unable to make this assumption when working with partially or fully dated species trees. We have the following theorem. (all proofs are available in the Supplementary Material). Theorem 3.1. The U-MPR problem on G and S can be solved in O(mn) time.
An O(mnlogn)-time algorithm for D-MPRIn the D-MPR problem, there exists a total ordering of the internal nodes of the species tree based on their divergence times. Thus, in this setting, for any given pair of species tree edges, it is known whether the two species represented by those edges overlapped in their time of existence, and transfers are only allowed between two species if they are coexisting. We assign consecutive positive integers, starting with one, to the internal nodes of the species tree according to the total order. These numbers are referred to as time stamps and they represent the temporal order in which the species represented by these nodes diverged. Given a node s  V (S), we denote its time stamp by t(s). If the largest time stamp assigned to the internal nodes is k, then we assign time stamp k +1 to each leaf of S. Any two consecutive time stamps x,x +1 define the time zone labeled x on S. Given a node s  V (S)\rt(S), the species represented by that node exists along the edge (pa(s),s) and is consequently associated with the time stamp intervaland the time zonesObserve that any edge from E(S) is associated with at least one time zone. Given any pair of nodes s,s  V (S)\ rt(S), a transfer is allowed between the species represented by those nodes if and only if the two edges (pa(s),s) and (pa(s ),s ) overlap in at least one time zone. Our algorithm for the D-MPR problem, called Algorithm Dreconcile, makes use of the same overall dynamic programming structure as Algorithm U-Reconcile, and the procedure for computing the values c (,) and c (,) remains identical. The difference is in the way c (,) is computed, as we can no longer rely on the out(,) values. Instead, we need a more elaborate procedure that can efficiently yield the 'best receiver' for a transfer originating at the species tree node currently under consideration, from among the relevant time zones. More concretely, suppose we want to compute the value c (g,s) assuming that (g,g )  , where g  Ch(g), for each s  V (S). Our algorithm first efficiently computes the locally best and locally second-best receivers of gene g in each time zone based on the values c(g ,). Then, for each candidate node s under consideration, we efficiently compute the best receiver, for a transfer originating at s, by choosing the globally i287
M.S.Bansal et al.optimal value from among the previously computed locally best and locally second-best receivers for the relevant time zones. For efficiency, our algorithm makes use of (i) a binomial heap data structure and (ii) a dynamic range minimum query data structure. The binomial heap data structure maintains a set of P-values while supporting find-min, insert and delete operations in O(1), O(logp) and O(logp) time, respectively (). The dynamic range minimum query data structure maintains an ordered list of numbers and can answer queries that seek the smallest element in a given query range in O(logp) time and also supports update operations that change the value of an element in the list in O(logp) time (). Definitions. Let k denote the number of time zones on the species tree. Given a time zone idenote the set of edges from E(S) that are associated with time zone i. Let Best(g,i) and secondBest(g,i) denote, respectively, the two edges from Z(i) with the smallest value of in(g,). Preprocessing. Before running Algorithm D-Reconcile, we assume that we have precomputed, for each time zone i), referred to as end(i) and (ii) the set of edges (pa(s),s)  E(S) for which t(pa(s)) = i (i.e. (pa(s),s) is associated with Z(i), but not with Z(i 1)), referred to as begin(i). The algorithm below makes use of the procedure bestReceiver which takes as input a node g  I (G), a child x of g, and an edge s from S and returns, from among all those edges that share at least one time zone with s, an edge (pa(y),y) for which the value in(g,y) is smallest. Essentially, the returned edge (pa(y),y) implies that, in a scenario where g maps to s and g is a transfer node with (g,x)  , the best possible mapping for x (i.e. one for which c (g,s) is minimized) is y.denote the number of time zones on S.Create an empty binomial heap data structure H.
10.Consider each edge (pa(y),y) from Z(k) and add it to H based on the value in(x,y).
11.Query the heap H to assign Best(x,k) and secondBest(x,k).Update the heap H by deleting from it all the edges in begin(i +1) and inserting all the edges in end(i) (according to their in(x,) scores).
14.Query the heap H to assign Best(x,i) and secondBest(x,i).
15.Add all the edges Best(x,) and secondBest(x,), labeled by their c(x,) scores, to a dynamic range minimum query data structure, indexed by their time zones (Note that, as stated, each index gets assigned two values, which makes for an ill-defined range minimum query data structure. However, this is easy to get around by assigning Best(x,i) to index 2i 1, and secondBest(x,i) to index 2i, and querying the data structure accordingly). We denote this data structure by x .
16.Delete the heap H.
17.for each s  V (S) in post-order do
18.If s = rt(S), then let (pa(u),u) = bestReceiver(g,g ,s), and (pa(v),v) = bestReceiver(g,g ,s).
19.This part of the algorithm is identical to Steps 8 through 22 of Algorithm U-Reconcile, except, (a) Steps 11 and 19 are replaced by the following:Theorem 3.2. The D-MPR problem on G and S can be solved in O(mnlogn) time.
Considering distance-dependent transfer costsUnder the current reconciliation model, all transfers have the same cost irrespective of the span of the transfer. However, it has been observed that transfers are more likely to occur between closely related species than between distantly related ones (). This suggests that, ideally, the cost of a transfer should depend on the phylogenetic distance between the donating and receiving species. Such a cost scheme could be implemented in several different ways: one straightforward way to implement this is to define the transfer cost between species a and b to be. If branch lengths are available on the species tree, d S (a,b) could also be replaced by a term that counts the total branch length between a and b. A simpler alternative is to have different constant transfer costs for different ranges of transfer spans. Next, we give a simple O(mn 2 )-time algorithm for the (general) MPR problem that can work with undated, partially dated, or fully dated species trees and can handle distance-dependent transfer costs. This makes it a factor of n faster than the fastest known algorithm that can handle distance-dependent transfer costs. Our algorithm, which we will refer to as algorithm reconcile, is essentially the same as algorithm U-Reconcile, except that we remove our dependence on the out array and assign a cost of  to those transfers that violate any given time constraints. Specifically, we (i) remove Lines 14, 22, and 23 through 25 and (ii) replace Steps 11 and 19 with the following five: Let X ={x  V (S) : x is incomparable to and potentially coexisting with s}.
Reconciliation using Duplication, Transfer, and Lossfor each x  X Temp(x) = P (s,x)+min{in(g ,x)+in(g ,x),Given any a and b, the value of P (a,b) under distance-dependent transfer costs can be computed in constant time as long as the value d S (a,b) (or its equivalent in terms of branch lengths) can be computed in constant time. This can be achieved after an O(n) preprocessing of the species tree, which (i) allows constant time LCA querying () and (ii) labels each species tree node with its distance (or total branch length) from the root. This yields the following theorem. Theorem 3.3. The MPR problem on G and S with distancedependent transfer costs can be solved in O(mn 2 ) time.
Algorithmic extensionsUnrooted gene trees. If the input gene trees are unrooted, each possible rooted version of the unrooted gene tree is reconciled against the species tree and the goal is to find a reconciliation that has minimum cost among all rootings. Each of our three algorithms described earlier can be easily extended to work with unrooted gene trees without any increase in their respective time complexities. This is done by relying on the oft-used observation () that, w.r.t. any internal node g, all rootings of the tree can be partitioned into three sets, depending on which of the tree edges incident on the node is closest to the root node. We have implemented this feature into our software RANGER-DTL. Multiple optimal solutions. It should be noted that, for any given values of the event costs P , P and P loss , there may be more than one optimal solution for the MPR problem. The O(mn 2 ) algorithm above can be easily adapted to output all possible optimal reconciliations for any given problem instance. Further enhancements. It is also possible to extend each of our three algorithms, without any increase in their time complexities, to consider more complex biological scenarios, such as transfers from potentially extinct or unsampled lineages, or transfer from a species that then loses its copy of that gene. A more detailed discussion of these enhancements appears in the Supplementary Material (Section S.2).
EXPERIMENTAL EVALUATIONWe implemented our fast algorithms into a software package called RANGER-DTL (Rapid ANalysis of Gene family Evolution using Reconciliation-DTL). Since the accuracy and utility of DTL and tcDTL reconciliation for inferring gene family evolution have already been demonstrated elsewhere (), we do not attempt to do so here. Instead, our goal is to (i) demonstrate the immense speedup in running time achieved by our algorithms over existing state-of-the-art programs; (ii) compare the solutions obtained by DTL reconciliation on undated and fully dated species trees against tcDTL reconciliation on fully dated trees (which can be thought of as a 'gold standard'); and (iii) demonstrate the utility of enhancements such as distance-dependent transfer costs. To that end, we applied RANGER-DTL to a variety of simulated and biological datasets. Specifically, we created 500 simulated datasets (gene tree species tree pairs), 100 each with 50, 100, 200, 500 and 1000 taxa generated using the probabilistic gene evolution model described in; Tofigh (2009);. We ensured that each simulated gene tree had at least one gene from each species in the corresponding species tree, and they contained on average 98.2, 195, 334.3, 618.8 and 1423.5 leaves, respectively, for the 50, 100, 200, 500 and 1000 taxa datasets. We also created a 10 000-taxon gene treespecies tree pair with random topologies to demonstrate the feasibility of analyzing even extremely large trees with RANGER-DTL. We point out that the running time depend only on the sizes of the input gene and species trees and are thus independent of the actual rate parameters used to generate the simulated trees and of the event costs used to compute the reconciliation. Our biological dataset was derived from David and Alm (2011) and consists of over 4700 unrooted gene trees with a species tree of 100 (predominantly prokaryotic) species sampled broadly across the tree of life. This biological dataset was analyzed using the same cost parameters (P = 2, P = 3, P loss = 1) used in David and Alm (2011). Running time. To compare the running time of our algorithms, we used an implementation of our algorithm for DTL reconciliation on undated species trees, referred to as the RANGER-DTL-U program, and compared it against AnGST () and Mowgli () which are two of the most advanced programs implementing the fastest known algorithms for DTL reconciliation on undated species trees and tcDTL reconciliation on fully dated species trees, respectively. When running RANGER-DTL-U and AnGST on these datasets, all divergence-time information (branch lengths) on the nodes of the species trees was ignored. Moreover while both RANGER-DTL and AnGST can efficiently handle unrooted gene trees, Mowgli cannot; thus, we first randomly rooted each of the 4733 gene trees of the biological dataset.depicts the results. We find a dramatic improvement in runtime and scalability over both AnGST and Mowgli. For instance, on the 100 simulated 100-taxon datasets, RANGER-DTL-U is an impressive 300 and 4500 times faster than AnGST and Mowgli, respectively. Similar speedups are observed on the biological dataset as well, with RANGER-DTL-U requiring just over a minute to analyze the entire dataset of 4733 gene trees. (Even when run directly on the original unrooted gene trees, it requires only about 2 min to analyze the entire dataset). Moreover, the speedups are, as anticipated, even greater for larger datasets. AnGST required between 8 and 10 h on each of the 10 randomly chosen 500-taxon datasets that we tried, suggesting a running time of at least 800 h on all 100 datasets, and it crashed immediately on the 1000-taxon datasets. Similarly, Mowgli crashed after 4 h of running time on each of the 10 randomly chosen 500-taxon datasets that we tried, and did not terminate in 60 h (after which we stopped the program) on any one of the 10 1000-taxon datasets we ran it on. This suggests a total running time of at least 400 and 6000 h on all 100 of the 500-and 1000-taxon datasets, respectively, for Mowgli. In contrast, RANGER-DTL-U required <2 s on each 1000-taxon dataset, which is, remarkably, over 100 000 times faster than Mowgli. While neither AnGST nor Mowgli can be run on the 10 000-taxon dataset, RANGER-DTL-U required only 4 h to analyze it. Solution quality. Note that it is ineffective to compare the actual reconciliations themselves as the presence of multiple
M.S.Bansal et al.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Reconciling a gene tree with a species tree involves mapping the gene tree into the species tree. Such a mapping allows us to infer the evolutionary events that gave rise to that particular gene tree. In this case, the evolutionary events of interest are speciation, gene duplication, horizontal gene transfer and gene loss. Next, we define what constitutes a valid reconciliation; specifically, we define a DTL scenario (Tofigh et al., 2011) for G and S that characterizes the mappings of G into S that constitute a biologically valid reconciliation. Essentially, DTL scenarios map each gene tree node to a unique species tree node in a consistent way that respects the immediate temporal constraints implied by the species tree and designate each gene tree node as representing a speciation, duplication or transfer event. For any gene tree node, say g, that represents a transfer event, DTL scenarios also specify which of the two edges (g,g ) or (g,g ), where g and g denote the children of g, represents the transfer edge on S, and identify the recipient species of the corresponding transfer. Incorporating available divergence time information. When accurate divergence time information is available, for some or all of the nodes of the species tree, DTL scenarios must respect the temporal constraints imposed by the available timing information. Specifically, those transfer events that are inconsistent with the available timing information are disallowed (as transfer events could only have happened between two coexisting species). If there is no divergence time information available, then transfers are allowed to occur between any pair of incomparable species on the species tree. The definition of a DTL scenario below is a generalization of the definition from Tofigh et al. (2011). The generalization is necessary to correctly handle optimal reconciliations in cases when the species tree is dated. Specifically, we enforce that, if the species tree is dated, then transfers can only occur between coexisting species and introduce an additional variable to explicitly specify the recipient species for any transfer event. Definition 2.1 (DTL scenario). A DTL scenario for G and S is a seven-tuple L,M,,,,,,,,, , where L : Le(G)  Le(S) represents the leaf mapping from G to S, M : V (G)  V (S) maps each node of G to a node of S, the sets , and partition I (G) into speciation, duplication and transfer nodes, respectively, is a subset of gene tree edges that represent transfer edges, and  :  V (S) specifies the recipient species for each transfer event, subject to the following constraints: (1) If g  Le(G), then M(g) = L(g). (2) If g  I (G), and g and g denote the children of g, then, i285 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
h by AnGST and over 41 h by Mowgli. Even on the 1000-taxon datasets, it required <15 min per dataset. Although we have not yet implemented our fast O(mnlogn)-time algorithm for the D-MPR problem (since the general O(mn 2 ) algorithm solves the D-MPR problem as well), its runtime can be expected to be only slightly higher than that of RANGER-DTL-U. RANGER-DTL can be freely downloaded from http://compbio.mit.edu/ranger-dtl/. 5 DISCUSSION AND CONCLUSION In this article, we addressed the DTL reconciliation problem for reconstructing gene family evolution. We proposed new algorithms that are dramatically faster than any existing algorithms for this problem and proposed several enhancements necessary for improving the utility and accuracy of the computed solutions. Our work represents a substantial improvement in the ability to accurately analyze large gene families. It also enables, for the first time, the use of powerful, reconciliation-based gene tree and species tree reconstruction methods for prokaryotes. For instance, to reconstruct a 100-taxon species tree by gene tree parsimony, using a standard local search heuristic, one would need to reconcile on the order of many millions of gene tree/species tree pairs; using even the fastest existing DTL reconciliation algorithms, such as AnGST, one would require several years of computing time to perform such an analysis, compared with just a few days using RANGER-DTL. There are a number of ways to further improve the accuracy of DTL reconciliation and we would like to explore these in the future. For instance, it would help to explicitly distinguish between two types of transfers: ones that contribute an additional gene to the recipient genome and those that recombine with an existing gene copy and replace it. Under the current DTL reconciliation models, recombining transfers are counted as a transfer followed by a loss. Moreover, our current implementation assumes that the input gene tree topology is correct and it would be very useful to have an effective way to deal with any uncertainty in gene tree topologies.
i291 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
