BFC is a free, fast and easy-to-use sequencing error corrector designed for Illumina short reads. It uses a non-greedy algorithm but still maintains a speed comparable to implementations based on greedy methods. In evaluations on real data, BFC appears to correct more errors with fewer overcorrections in comparison to existing tools. It particularly does well in suppressing systematic sequencing errors, which helps to improve the base accuracy of de novo assemblies. Availability and implementation: https://github.com/
IntroductionError correction is a process to fix sequencing errors on a sequence read by using other overlapping reads that do not contain the errors. Many de novo assemblers, in particular short-read assemblers for large genomes, use error correction to reduce the complexity of the assembly graph such that the graph can be fitted to limited RAM. Error correction was first expressed as the spectral alignment problem (), whereby we take a set of trusted k-mers and attempt to find a sequence with minimal corrections such that each kmer on the corrected sequence is trusted. The majority of error correctors are based on this idea and take a greedy approach to solving this problem approximately. They make a correction based on the local sequence context and do not revert the decision. We worried that the greedy strategy might affect the accuracy given reads from a repeatrich diploid genome, so derived a new non-greedy algorithm that explores larger search space in attempt to achieve higher accuracy.
MethodsAlgorithm 1 is the key component of BFC. It defines a state of correction as a 4-tuple i; W; C; p, which consists of the position i of the preceding base, the last (k-1)mer W ending at i, the set C of previous corrected positions and bases (called a solution) up to i, and the penalty p of solution C. BFC keeps all possible states in a priority queue Q. At each iteration, it retrieves the state i; W; C; p with the lowest penalty p (line 1) and adds a new state i  1; W1; k  2 a; C 0 ; p 0  if a is the read base or W a is a trusted k-mer. If the first k-mer in S is error free and we disallow untrusted k-mers by removing line 3, this algorithm finds the optimal solution to the spectral alignment problem.have described a more general non-greedy algorithm. Its strict form is not implementable in practice. The heuristic adaptation is loosely similar to ours without line 3.In total, 445 million pairs of $150 bp reads were downloaded from BaseSpace, under the sample 'NA12878-L7' of project 'HiSeq X Ten: TruSeq Nano (4 replicates of NA12878)', and were corrected together. On a subset of 2 million randomly sampled read pairs, the original and the corrected sequences were mapped to hs37d5 (http://bit.ly/GRCh37d5) with BWA-MEM (). A read is said to become better (or worse) if the best alignment of the corrected sequence has more (or fewer) identical bases to the reference genome than the best alignment of the original sequence. The table gives kmer size (maximal size used for Bloocoo, fermi2, Lighter and Musket), the wall-clock time when 16 threads are specified if possible, the peak RAM measured by GNU time, number of corrected reads mapped perfectly, number of chimeric reads (i.e. reads with parts mapped to different places), number of corrected reads becoming better and the number of reads becoming worse than the original reads. For each metric, the best tool is highlighted in boldface.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from It is possible to modify Algorithm 1 to correct insertion and deletion errors (INDELs) by augmenting the set of the 'next bases' at line 2 to: N  fj; ajj 2 fi  1; ig; a 2 fA; C; G; Tgg [ fi; g In this set, (i, a) substitutes a base at position i, i;  deletes the base and i  1; a inserts a base a before i. We have not implemented this INDEL-aware algorithm because such errors are rare in Illumina data. The worst-case time complexity of Algorithm 1 is exponential in the length of the read. In implementation, we use a heuristic to reduce the search space by skipping line 4 if the base quality is 20 or higher (Q20) and the k-mer ending at it is trusted, or if five bases or two Q20 bases have been corrected in the last 10 bp window. If function CORRECTERRORS still takes too many iterations before returning, it stops the search and claims the read uncorrectable. Given a read, BFC finds the longest substring on which each k-mer is trusted. It then extends the substring to both ends of the read with Algorithm 1. If a read does not contain any trusted k-mers, BFC exhaustively enumerates all k-mers one-mismatch away from the first k-mer on the read to find a trusted k-mer. It marks the read uncorrectable if none or multiple trusted k-mers are found this way. We provided two related implementations of Algorithm 1, BFC-bf and BFC-ht. BFC-bf uses KMC2 (Deorowicz et al., 2015) to get exact k-mers counts and then keeps k-mers occurring three times or more in a blocked bloom filter (Putze et al., 2007). BFC-ht uses a combination of bloom filter and in-memory hash table to derive approximate k-mer counts (Melsted and Pritchard, 2011) and counts of k-mers consisting of Q20 bases. We modified Algorithm 1 such that missing trusted high-quality k-mers incurs an extra penalty. This supposedly helps to correct systematic sequencing
H.Li at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
