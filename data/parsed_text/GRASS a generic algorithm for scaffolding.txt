Motivation: The increasing availability of second-generation high-throughput sequencing (HTS) technologies has sparked a growing interest in de novo genome sequencing. This in turn has fueled the need for reliable means of obtaining high-quality draft genomes from short-read sequencing data. The millions of reads usually involved in HTS experiments are first assembled into longer fragments called contigs, which are then scaffolded, i.e. ordered and oriented using additional information, to produce even longer sequences called scaffolds. Most existing scaffolders of HTS genome assemblies are not suited for using information other than paired reads to perform scaffolding. They use this limited information to construct scaffolds, often preferring scaffold length over accuracy, when faced with the tradeoff. Results: We present GRASS (GeneRic ASsembly Scaffolder)— a novel algorithm for scaffolding second-generation sequencing assemblies capable of using diverse information sources. GRASS offers a mixed-integer programming formulation of the contig scaffolding problem, which combines contig order, distance and orientation in a single optimization objective. The resulting optimization problem is solved using an expectation–maximization procedure and an unconstrained binary quadratic programming approximation of the original problem. We compared GRASS with existing HTS scaffolders using Illumina paired reads of three bacterial genomes. Our algorithm constructs a comparable number of scaffolds, but makes fewer errors. This result is further improved when additional data, in the form of related genome sequences, are used. Availability: GRASS source code is freely available from
INTRODUCTIONHigh-throughput sequencing (HTS) technologies, such as Illumina (Illumina, Inc., San Diego, CA), 454 (Roche Applied Science, Penzberg, Germany) and SOLiD and IonTorrent (Life Technologies, * To whom correspondence should be addressed.Carlsbad, CA) produce millions of short DNA reads of typical lengths of 36500 bp at low cost, making them attractive for de novo sequencing applications. With the aid of assembly algorithms (), short reads can be joined together into longer sequences called contigs. However, contigs are typically shorter than the sequenced DNA molecules, as genomic repeat regions longer than the read length cannot be unambiguously assembled using the read sequences alone. Scaffolding, the process of using additional data to place contigs in the right order, orientation and at the right distance in longer (gapped) supercontigs called scaffolds, is a crucial step in obtaining high-quality draft genome sequences. Paired reads (mate pair or paired end reads, depending on the sequencing protocol), i.e. reads of known relative orientation, order and approximate physical distance, are often used for scaffolding. Additional information, including reference sequences of related organisms, restriction maps () and RNA-seq data, can be used to derive more accurate contig placement (), thereby reducing the cost of finishing experiments and allowing for more reliable downstream analyses. However, most existing scaffolding algorithms are not able to utilize such information for scaffolding. To our knowledge, only Bambus () and SOPRA () can make use of additional data sources, although the latter was not originally designed for this purpose. Generally, the contig scaffolding problem (CSP) is finding a linear ordering and orientation of contigs that minimizes the number of unsatisfied scaffolding constraints. These constraints are derived from the available data through translation of the inherent distance, order and orientation constraints onto the contigs. The derived constraints can be mutually exclusive, which makes the problem of minimizing the number of unsatisfied constraints NP-hard (). Consequently, practical scaffolding algorithms only approximately solve this problem: Bambus () separately finds contig orientation and order and uses greedy heuristics to remove inconsistent constraints; SSPACE () greedily extends scaffolds using a heuristic stopping criterion; and SOPRA () uses an iterative procedure to identify a subset of contigs with consistent scaffolding constraints. Notable exceptions are OPERA () and the MIP Scaffolder (), which simplify the CSP by dropping types of constraints. OPERA implements an algorithm for finding an exact CSP solution without minimumcontig distance constraints; the MIP Scaffolder () couples a Mixed-Integer Programming (MIP) formulation of the CSP that does not enforce order constraints with an algorithm heuristically dividing the original problem into subproblems to be solved exactly. We propose a novel GeneRic ASsembly Scaffolding (GRASS) algorithm that can be applied to any type of scaffolding information. Our work is similar to, as we propose a MIP formulation of the scaffolding problem. However, we combine contig orientation, order and distance in a single quadratic optimization objective. Similar to, we employ an iterative procedure to select a consistent subset of contigs. However, we apply an expectationmaximization strategy to maximize the objective function that identifies inconsistent constraints rather than contigs, thereby retaining more scaffolding information. We implemented the algorithm in C++ and tested it on de novo assemblies of paired read data for the bacteria Eschrichia coli, Pseudoxanthomonas suwonensis, and Pseudomonas syringae and compared it with the SSPACE, OPERA and MIP scaffolders. GRASS produces a competitive number of scaffolds with fewer scaffolding errors, particularly when combining various sources of scaffolding information.
METHODS
Data representationScaffolding constraints on contig distance, order and orientation are derived from the data in a manner depending on the data type. For example, the known relative orientation, relative order and approximate distance of paired reads that map to different contigs can be translated into relative contig orientation, order and approximate contig distance by taking mapping orientations and positions into account; similarly, physical distance, relative order and orientation of two contigs mapping to the same reference sequence can be translated into corresponding constraints. However, different data types eventually define the same type of pair-wise contig constraints, which can be conveniently represented as arcs (i.e. directed edges)defined over the set of contigs V (). The weight can be chosen to reflect information source importance and consistency. A relative order r l j , relative orientation e l j and approximate distance suggested by the pair-wise constraints, are then associated with every arc l j. The approximate distance is recorded as mean  l j and its SD  l j. This form is a natural choice for capturingThis abstract definition is illustrated in. It allows capturing any combination of contig order, distance and orientation, including constraints derived from paired end reads, mate pair reads and contig mapping.
Contig link bundling and erosionWe create a single contig link for every available piece of evidence (e.g. pair of reads) and by default set its importance weight to one (a parameter adjustable per information source). For high-coverage HTS data this procedure creates a large number of links. Contig link bundling is used to reduce the number of links, and thereby the complexity of the problem. For every ordered pair of contigs (u,v), arcs (u,v)  E that agree on contig distance, order and orientation are combined into one or more contig links as in. The weight of a link after bundling is equal to the sum of weights of links bundled together to create it. Our definition of contig links permits having links that agree on all constraints, yet cannot be bundled together because they are oppositely directed in G. To enable bundling of such links, we re-set r l j relative to one of the end points of l j to make sure that all links connecting a pair of contigs have the same directionality. Finally, contig links with importance weight smaller than a pre-defined erosion threshold e are removed from the graph. This assumes that erroneous links are rare.
Optimization formulationWe present a mixed-integer quadratic programming (MIQP) formulation of the CSP. Our formulation is equivalent to the traditional oneto the optimization problem. These values are sufficient to puzzle contigs into scaffolds. For every contig c i , i = 1,...,n the following variables are defined, as illustrated in. @BULLET t i = 0, c i comes from the forward strand of the scaffold 1, c i comes from the reverse strand of the scaffold is used to define contig orientation in the scaffold. @BULLET x i  R + corresponds to the 5 position of c i in the scaffold (when input contigs and the constructed scaffold are viewed as having a 5 to 3 orientation).Naturally x i should be an integer variable, but it is relaxed to simplify the optimization problem and is rounded to the nearest integer when the solution is converted into scaffold nucleotide sequences. Additionally, with every link l j , j = 1,...,m the following variables are associated:As distance and order constraints are influenced by the orientation, different slack variables are required for both orientations. We omit orientation arrows above slacks  l j and l j when the contig pair orientation is not important, or is clear from the context. Contig links impose scaffolding constraints, which can be modeled as MIQP optimization constraints. We demonstrate here how such constraints can be derived from paired read data; the same type of constraints can be derived in a similar way from other sources of scaffolding information (for example, see Section 3.2). Distance constraints are expressed as:where d(a l j ,b l j ) is the distance between contigs a l j and b l j , and  l j is a distance slack variable. This inequality captures uncertainty in the distance by measuring the difference with the mean in SDs. We derive contig distance d(a l j ,b l j ) from the paired read insert size as the gap size plus the contig lengths. The calculation then depends on the order and orientation of contigs connected by l j. It can be fixed by assuming that the contigs have relative orientation and order suggested by l j. For example, for the case of (e l j = 0r l j = 0) shown in, the distance expression depends on contig pair orientation through t a l j :Combined with (1) the following constraints are obtained:,where different slack variables are used for the two contig pair orientations. The expressions for other combinations of e l j and r l j are derived similarly. Order constraints are derived from read order constraints (i.e. if c j follows c i , then they should not overlap and c j must be upstream of c i ), which additionally can be relaxed. The relaxation is necessary because (i) assembled contigs may overlap (); (ii) in some cases the order constraints on data are not valid when extended to contigs, as illustrated in. Translating order constraints into optimization constraints as(formulas shown for e l j = 0  r l j = 0) discourages overlaps while still allowing the order constraint to be violated when l j > 1. These slack variables are weighed by the length of the downstream contig to allow measuring them on a single scale. As for the distance optimization constraints, it is assumed that the relative contig orientation is correct. Orientation constraints are modeled in the optimization objective function, which is designed to attain larger values when more orientation constraints are satisfied. The function is given by a polynomialwhere q ab = t a +t b 2t a t b  0, a and b are equally oriented 1, otherwise .It is equal to the sum of weights of contig links with satisfied orientation and serves as a basis for the optimization objective that is further penalized proportionally to slack variables. Slack penalties: the distance and order constraints are added to the optimization problem through slack variable penalization. The penalty is proportional to the importance weight of the corresponding contig link and to the value of the slack variable. To avoid situations when a low-weight violated constraint results in a large penalty, a maximum penalty of half of the importance weight is enforced, after which the constraint is considered disabled. Doing this has the additional benefit of equalizing the influence of order and distance constraints. To this end we penalize as followswhere  l j is chosen asaccording to the contig pair orientation and S  is the maximum slack threshold (after which the slack is disabled). Because the expression min(,S  ) is not suitable for direct use in a MIP, it is unrolled using the switch variables as. Similar penalties with variables l j and  l j , and maximum slack threshold S are used for the order constraints. We set S  = 6 (i.e. six SDs) as in; Li and Durbin (2009); and S = 1, as at this value of slack the physical order constraint is not satisfied anymore. Further, only the slacks for the appropriate contig pair orientation have to be penalized. This is achieved by penalizingExpansion of this function leads to a fourth degree polynomial, containing only terms that consist purely of binary variables, or one continuous and up to three binary variables. To construct a MIQP formulation, using the big-M formulation (), these terms can be replaced by a single new auxiliary variable each at the expense of introducing new optimization constraints. Putting it all together: we maximize
Problem splittingWe tackle this intractability with an expectationmaximization (EM) like procedure. The maximization step assumes the contig orientations are known (i.e. t i and q ab are fixed). Knowing t i allows us to choose the slack variables (depending on the contig pair orientations, and to select contig links with satisfied relative orientation before the optimization problem is constructed, significantly reducing the number of optimization constraints and the complexity of the optimization problem:This fixed optimization problem, however, is still NP-hard due to the binary variables  l j and  l j involved in expansion of the min terms. We obtain an approximate solution to this problem by first exactly solving its continuous relaxation, choosing  l j and  l j according to the slack values in the relaxation solution and finally, re-solving the problem with these values fixed. The relaxation is obtained by replacing h(,,. This eliminates all binary variables, allowing the use of efficient optimization algorithms (). The solution for the relaxed problem gives us optimal values for slacks  l j and l j , which are used toand allows us to re-solve problem (5). The rationale behind is that, since the majority of link information is assumed to be correct, large slack values will be associated with incorrect constraints that have to be disabled. The total penalty for l j is memorized (initially set to zero) for use in the expectation step asThe expectation step is used to obtain the expected contig orientations t i , which maximize the objective function for the previously observed penalties. Consider the MIQP problem when penalties associated with the links are known (i.e. l j ,  l j ,  l j and  l j are fixed), and the optimal contig orientation is sought. In this problem, when a contig link is enabled, its weight is penalized by the associated slack l j. We can, therefore, consider an equivalent problem where all slacks are zero and link weights are modified asas as l j   l j  l j. The problem is then to maximizefree of any constraints. This is an unconstrained binary quadratic programming (UBQP) problem (), the problem of maximizing a function c(t) = t t Ct, where x is a binary vector of length n and C is an nn real matrix. Consider a vector of orientations t {0,1} n and a matrix C of size n. Starting from a zero matrix, C = (c ij ) can be obtained by updating it for every link l j = (a,b) asThe functions f (t) and c(t) will then differ by a constant and, therefore, reach maxima for the same t. Solving a UBQP is known to be an NP-hard, but well-studied problem with efficient heuristic algorithms available (). Thus, the UBQP formulation of the problem is preferred over (6) for obtaining values of t i. The EM steps are iterated while contig orientations change. The algorithm can be viewed as an iterative UBQP approximation of the original MIQP problem. In practice, it converges to a solution within seven iterations.
Scaffold extraction and post-processingRepeat contigs in the contig link graph G are connected by ambiguous links, hindering a confident positioning in scaffolds. In a pre-processing step, we detect such contigs using a modification of the A-statistic () proposed by, and prevent their incorporation in scaffolds by removing all links from G incident to them. The connected components of G correspond to separate subproblems, which are solved independently. After optimization, each solution tuple (x,t,,) and corresponding subgraph G are converted into one or more scaffolds. First, contig links with disabled constraints (i.e.  l j = 0 l j = 0) are removed from G to minimize the chance of incorrectly incorporating contigs in the same scaffold. Every connected component of the resulting G is used to construct a single nucleotide sequence. Contigs are processed in order of their downstream end coordinates. The left end of the first contig is put at the start of the sequence; every new contig is added to the scaffold such that the gap between two consecutive contigs is preserved. When consecutive contigs are predicted to overlap (i.e. have a negative gap size), the new contig is pushed upstream to eliminate the overlap. Because resolving contig overlaps in this way potentially leads to erroneous sequence reconstruction, we also explore an optional postprocessing approach that performs global sequence alignment on consecutive contigs to find the best overlap. Global alignment is performed using a divideand-conquer version of the NeedlemanWunsch algorithm (). Algorithm implementation from the NCBI C++ Toolkit was used (National Center for Biotechnology Information, 2011). For every consecutive pair of contigs predicted to have a gap of  bp, all gap sizes of at most d = 100 bp away from the predicted value are examined. Negative gap sizes indicate overlaps. For each gap size g, global alignment of overlapping contig ends is performed (match score of p match = 2, mismatch penalty of p mismatch =3). The best gap size is then chosen based on the alignment score S and proximity to the predicted gap size  by maximizingWith the (mis)match scores chosen as above, this expression takes values in. Due to computational complexity only overlaps of no more than 1500 bp are considered (gap sizes with longer overlaps are assigned a score of 1). The decision to join two contigs, to leave a gap between them or to
GRASS: generic assembly scaffoldersplit the scaffold is then made:@BULLET If none of the considered gap sizes suggest overlaps, the two contigs are positioned in a scaffold with a gap of  bp. @BULLET If value of expression (7) for the chosen gap size g passes a quality threshold of 0.8, the contigs are positioned to have an overlap of g bp. The overlap is replaced with the alignment consensus sequence, where mismatches are masked with unknown nucleotides. @BULLET If the chosen gap size does not pass the quality threshold and is shorter than 50 bp, the two contigs are positioned successively one following another with no overlap. @BULLET Finally, if the chosen gap size suggests a longer overlap, the currently constructed scaffold is split into two with a new scaffold starting from a contig that was predicted to lie upstream.In principle, the proposed post-processing step with scaffold splitting allows for construction of more accurate scaffolds compared with the nave scaffold extraction. We refer to the combination of GRASS and post-processing as GRASS+.
Evaluation criteriaSimilar to assemblies, scaffolds are evaluated based on accuracy and contiguity. Scaffold accuracy can be assessed by comparing scaffolds to available reference sequences. We adopted the evaluation criteria from;and counted the number of scaffold breakpoints, i.e. consecutive contig pairs in the scaffold that do not agree with the reference on contig distance, order or orientation. We perform local alignment of scaffolds to the reference and count the number of breakpoints within each scaffold. Two consecutive alignments are counted as a breakpoint if any of these hold: (i) they align to two different chromosomes in the reference; (ii) their relative orientations in the scaffold and in the reference do not match; (iii) their relative orders in the scaffold and in the reference do not match; (iv) the difference in distance in the scaffold and in the reference is larger than. We used = 10 kb and = 500 bp to asses contig distance correctness at low and high resolution, respectively. MUMmer () was used to align scaffolds to references. Best hits for each position in the scaffold were computed. Only hits with at least 90 aligned bases (alignment length  alignment identity), were taken into account. In practice, very few alignments do not pass this cutoff. The alignments are also used to calculate the percentage of the scaffold bases and the reference bases that are aligned (). These numbers capture scaffold accuracy and completeness. Finally, scaffold completeness and contiguity are captured as in sequence assembly, calculating total length of all scaffolds, number of scaffolds, maximum scaffold length and the N50 statistic.
IMPLEMENTATIONGRASS source code is available under the GNU GPL v3 license. It was developed in C++ and tested on Linux. GRASS consists of linker and scaffolder modules. The linker takes contigs and the available information sources as input and produces linking and coverage data, which is then used by the scaffolder module. It filters out repeat contigs and uses the remaining data to produce scaffolds. Scaffolds are output both as lists of contigs with assigned coordinates and orientations, and as linear FASTA sequences with gaps.
Paired read data processingTo obtain contig links from paired read data, the linker module performs single-end mapping of the reads to contigs. The algorithm used for mapping depends on the data type: BWA () for Illumina reads, NovoAlign (http://www.novocraft.com/) for 454 data. The aligners are set to output all mapping locations, including non-unique hits, as a SAM file (), which is then converted to BAM for further processing. This process is applied to each paired read library. Read alignments are pre-processed to remove read pairs with low quality and ambiguous alignments. As a rule, only unique hits with no mismatches and minimum read length of 30 bp are kept. The filtered alignments are then scanned for paired reads that align to different contigs. Each such read pair mapping is used to create a single contig link with distance, order and orientation constraints derived from the mapping and the given read pairing method (i.e. paired ends or mate pairs). The BamTools API () is used for filtering and processing read alignments.
Related genome data processingAn available reference sequence, such as the genome of a related organism, can be used for guiding the scaffolding process. For this purpose, contigs are aligned to the reference sequence. For every contig, a position in the reference sequence is obtained from contig tiling constructed from local alignments using MUMmer. Contig links are then created for every pair of consecutive contigs aligning to the same reference sequence, with relative orientation and order derived from the tiling. To capture alignment quality, weights for linksb l j are alignment coverages reported by MUMmer for the corresponding contigs, and W > 0 is a weight assigned to the reference sequences as a scaffolding information source. This procedure is applied for each available reference sequence to create links, which are then used together in the optimization.
Optimization problem solutionThe EM procedure proposed for solving the MIQP formulation of the CSP splits it into a continuous linear programming (LP) problem, and an UBQP problem. Although more efficient algorithms for solving UBQPs are available (), a memetic algorithm from Merz and Katayama (2004) was chosen for ease of implementation. Usually, contig link graphs are sparse due to the linear scaffold structure that they encompass. Memetic algorithms improve individual solutions through local search, which in turn is well-suited for smooth search landscapes (as in the case of sparse contig link graphs). Graph sparsity is further exploited by implementing sparse matrix operations as in. We use the C++ Concert API for the CPLEX Optimizer (IBM ILOG, 2011) to solve LPs. CPLEX is freely available for academic use.
RESULTS AND DISCUSSION
Experimental setupWe have evaluated GRASS on de novo HTS assemblies of three bacterial genomes: E.coli K12, substr. MG1655; P.suwonensis 11-1; and P.syringae B728a. For these organisms, finished genome sequences and HTS data from resequencing experiments are available. Presence of a finished genome sequence allows for reliably evaluating the algorithm and comparing it to other scaffolders in a de novo setup. This is achieved by using the reference sequence only in scaffold evaluation (thus not as an additional information source in the scaffolding process). The available test data is summarized in. Insert size and coverage were obtained from paired read mapping using BWA and BEDTools (). Velvet () was used to assemble reads into contigs. All assemblies had a coverage cutoff of 6 and were not scaffolded by the assembler. Only contigs longer than 150 bp were kept. Repeat resolution was disabled (i.e. no expected coverage was provided). For each organism, the k-mer length was chosenby performing assemblies for various k and choosing one based on assembly contiguity, length, percentage of mapped single reads, and percentage of properly paired reads () (Supplementary Tables S1, S2 and S3). For E.coli, P.suwonensis and P.syringae, k = 31, k = 59 and k = 23 were chosen, respectively. This way of choosing k reflects real-life de novo assembly scenarios, yielding a realistic algorithm evaluation. Final assemblies are characterized in Tables 24.
Comparison to other scaffoldersWe compared GRASS with SSPACE, MIP and OPERA scaffolders. Where required, insert size estimates fromwere used. Tables 24 show evaluation metrics calculated for these scaffolders and the available test data. Unless stated otherwise, all scaffolders were run with default parameter settings. BWA was used to map reads to scaffolds and produces SAM files required by the MIP Scaffolder. As in, at most two mismatches were allowed in read mapping. For SSPACE and OPERA, reads were aligned with Bowtie () using scripts provided with the scaffolders. GRASS used an erosion cutoff of 4 (although better results can be obtained by tuning this parameter) and coverage estimates obtained from exact mapping of the reads to the assembly contigs. The latter is available from output of the linker module. The SSPACE maximum distance parameter was set to 6 SDs for each paired library. Libraries were input in order of increasing insert size. The MIP Scaffolder was also provided with coverage estimates computed from exact read mapping. Following the original publication, we tried different filtering parameters (,p) and chose those which gave the highest N50 value. Settings (36,0.8), (70,0.4) and (50,0.6) were selected for the E.coli, P.suwonensis and P.syringae data, respectively. Maximum partition sizes were set to 100 for the E.coli scaffolds and 50 for the P.suwonensis and P.syringae scaffolds. Maximum and minimum insert sizes were chosen by adding and subtracting 6 SDs to the mean insert size. OPERA does not allow using multiple read sets. It was applied to each read library separately, and in the case of P.suwonensis, also to a join of the available read sets, as they have the same insert size. The minimum contig length was set to 150 bp, i.e. the contig length cutoff parameter used in Velvet. We used the default PET parameter value whenever possible and increased it to the minimum value that allowed OPERA to finish without triggering a timeout abort. Cutoff values 6 and 7 were used for the E.coli dataset; cutoffs 27, 5 and 5 were used for the P.suwonensis dataset; and 11 was used for the P.syringae dataset (values are given in the order of the experiments in Tables 24). SOPRA was applied to assembly graphs produced by Velvet. However, when used with parameters chosen in accordance to the manual provided, SOPRA produced highly fragmented scaffolds compared with results from. To allow for a fair comparison, its results were not taken into account.As a scaffolder, Velvet was provided with mean insert size and SD for each library. The data was reassembled with repeat resolution (expected coverage estimated automatically) and scaffolding turned on. Its performance was used as a baseline over which all scaffolders improved on P.syringae data and only SSPACE and GRASS improved on E.coli and P.suwonensis data. Tables 24 contain the results. Note that the minimum number of breakpoints is one, due to the circular structure of bacterial genome. Breakpoints at = 10 kb and = 500 bp differ only slightly, suggesting that gap lengths are estimated with high precision. SSPACE produced the longest scaffolds for E.coli. It also produced the smallest number of scaffolds for E.coli and P.suwonensis. The longest scaffolds and the smallest number of scaffolds on the P.syringae dataset are achieved by the MIP Scaffolder. Similar scaffold and reference coverage percentages were achieved by all scaffolders. However, GRASS+ has the smallest number of breakpoints for all considered organisms. Additionally, for the case of P.suwonensis, GRASS constructed the longest scaffolds and GRASS+ produced breakpoint-free scaffolds while providing a 2-fold reduction in the number of contigs. Scaffolds produced by the MIP Scaffolder and OPERA are either very fragmented or have a large number of breakpoints.
GRASS: generic assembly scaffolderWhen constructing scaffolds, scaffolding algorithms balance between scaffold contiguity and scaffold accuracy. This tradeoff is captured inby plotting the number of breakpoints (at = 10 kb) against the number of scaffolds. A good scaffolder would be located in the lower left corner of such a plot. In many cases, GRASS combines a smaller number of breakpoints with a small number of scaffolds, compared with other scaffolders. The MIP Scaffolder and SSPACE can achieve smaller numbers of scaffolds, but at the cost of (much) larger numbers of breakpoints. Clearly, GRASS and SSPACE represent two possible choices of scaffolding algorithms, with GRASS being more accurate with respect to the number of breakpoints and SSPACE constructing longer scaffolds. This behavior of the two algorithms is consistent over all datasets. We also measured scaffolding running times, these are depicted inusing marker size. Exact numbers, as well as read mapping running times are available in. Like most scaffolders, GRASS spends a majority of its time on read alignment, making running times of different scaffolders comparable and running time of the core scaffolding part of GRASS on the considered datasets negligible. Based on simulation results, we do not expect computation to become a bottleneck for large genomes. Nevertheless, to reduce computational load it is always possible tosplit the contig graph into graphs of manageable size by increasing the erosion parameter e.
A.A.Gritsenko et al.
Using additional informationTo demonstrate the ability of GRASS to utilize various scaffolding information sources, we used two related genomes (see) to help scaffold the E.coli assembly: DH10B and BW2952. These genomes were used individually, together and in combination with paired reads. When combining several information sources, care has to be taken in choosing the weights W r and the erosion threshold parameter e. In individual genome experiments, W = 100 and e = 80 were chosen to remove links derived from low-quality alignments. In the experiment using only two related genomes (thus no links derived from paired read data) a higher weight was given to the more closely related strain: e = 70 and W DH10B = 80, W BW2952 = 100 were used for the DH10B and BW2952 strains correspondingly. For experiments combining a single genome with paired reads, W = 10 and e = 4 were chosen. Finally, W DH10B = W BW2952 = 3 and e = 5 were used in the experiment combining all data (including the paired read constraints) to emphasize use of links supported by at least two information sources. When used in the experiment, paired read link weights were set to 1. An SD of 3000 bp was used for links derived from related genomes. Interestingly, using just related genomes GRASS constructs a smaller number of scaffolds than when only paired reads are used.shows, however, that this is achieved at the expense of scaffold accuracy: besides having an increased number ofbreakpoints, scaffolds constructed based on related genomes alone have a high-total assembly length and, as a consequence, a lowscaffold coverage. The higher than anticipated total assembly length is due to differences in contig distances (i.e. physical distances obtained by aligning contigs to a genome sequence) between the MG1655 strain and the related strains. This is also the reason for the large differences observed between breakpoints at = 10 kb and = 500 bp: while relative order and orientation have been preserved for large parts of the genomes of the considered strains, the exact physical distances have not. This situation is partially alleviated when information from the two genomes is combined, because (i) consistent links (derived from the two genomes) get higher weights after link bundling, and (ii) the more closely related strain BW2952 was given a higher weight. In this case, GRASS is able to further reduce the number of scaffolds without introducing new breakpoints.
GRASS: generic assembly scaffolderCombining paired read data with information from individual related genomes allows for construction of a smaller number of scaffolds with fewer breakpoints than when using these data individually. The results vary between repeated runs of the algorithm, due to inconsistencies between linking information provided by paired reads and related genomes, combined with the stochastic nature of the optimization strategy used for solving the MIQP formulation. Depending on the intermediate solutions found, different contig links are disabled in the optimization process, leading to different final solutions and, thereby to different scaffolds., hence, shows a range of scaffold and breakpoint counts, and other results as averages over five repeated runs. This variability is smaller when all data is combined, since a 'voting' approach can be implemented by setting W and e in such a way that all links supported by only a single information source have low weights and are ignored. Using all available information, GRASS reduced the number of scaffolds by 40% compared with just using paired reads, at the expense of introducing a single new breakpoint. The increase in the number of breakpoints is not surprising, as the de novo scaffolding information is augmented with links derived for a different (related) organism. The best result on combined data is shown in.
CONCLUSIONWe presented GRASS, a generic scaffolding algorithm suitable for combining multiple information sources, as well as GRASS+, incorporating a post-processing scaffolding step. Its use was demonstrated by scaffolding genomes based on paired read data and information in related genome sequences, both individually and combined. GRASS achieves the best results when all available scaffolding information is used, as this allows conflicting information from a single source to be ignored when the majority of sources do not support it. Such a mode of operation is supported by the possibility of choosing weights for the individual information sources, combined with the contig link erosion threshold. We compared GRASS with a number of state-of-the-art scaffolders (SSPACE, MIP and OPERA) on three datasets. GRASS constructs the most accurate scaffolds on all datasets, while keeping the number of scaffolds low. Only SSPACE consistently produces lower numbers of scaffolds, but these are significantly less accurate. The accuracy/contiguity tradeoff displayed by GRASS puts it in a unique niche compared with existing scaffolders. The current implementation of GRASS supports the use of paired read information and related genomes for scaffolding. However, the algorithm is not limited to any particular set of information sources. We will extend GRASS to allow use of other sources, such as optical restriction maps, RNA-seq and EST data.
ACKNOWLEGEMENTWe would like to thank Bas Dutilh for fruitful discussion and the anonymous reviewers for comments which helped improve the manuscript.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
