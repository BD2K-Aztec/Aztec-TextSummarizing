Motivation: Small-induced subgraphs called graphlets are emerging as a possible tool for exploration of global and local structure of networks and for analysis of roles of individual nodes. One of the obstacles to their wider use is the computational complexity of algorithms for their discovery and counting. Results: We propose a new combinatorial method for counting graph-lets and orbit signatures of network nodes. The algorithm builds a system of equations that connect counts of orbits from graphlets with up to five nodes, which allows to compute all orbit counts by enumerating just a single one. This reduces its practical time complexity in sparse graphs by an order of magnitude as compared with the existing pure enumeration-based algorithms. Availability and implementation: Source code is available freely at
INTRODUCTIONFollowing the advent of high-throughput methods more than a decade ago, analysis of complex network data has assumed the central role among computational methods in bioinformatics. The huge size of such networks on one hand and the computational intractability of the related methods on the other have spawned a number of innovative analytic approaches. Przuljdescribed an approach focused on small induced subgraphs called graphlets. Owing to combinatorial explosion, such analysis is usually limited to the 30 graphlets with 25 nodes (). The number of appearances of graphlets in the network provides a description of the network's structural properties. On a local level, counting how many times a particular node participates in each kind of graphlet induced in the network gives a topological signature of the node's neighbourhood represented as a 30-dimensional vector. For a finer description, the nodes of every graphlet are partitioned into a set of automorphism groups called orbits (). Two nodes belong to the same orbit if they map to each other in some isomorphic projection of the graphlet onto itself. Nodes of graphlets on 25 points are grouped into 73 orbits shown by numbers and node colors in. For instance, the five nodes from G 14 belong to three different orbits, marked with different colors and numbers; the black (as well as the grey) nodes have symmetric positions in the graphlet and thus belong to the same orbit (31 for the black, 32 for the grey), and the white node belongs to the orbit 33. By counting the number of times a node of a graph appears in each orbit, the node can be described by a 73-dimensional vector of orbit counts, which reflects its position with respect to the local structure and gives insight into its role in the network. Existing methods for counting the graphlets and orbits are based on direct enumeration: to count them, they need to find all their embeddings in the network. We propose a new method, Orbit Counting Algorithm (Orca), which reduces the time complexity by an order of magnitude by computing the orbit counts using the relations between them and directly enumerating only smaller graphlets.
MotivationGraphlets are used for different kinds of analyses in bioinformatics. Milenkovicnd PrzuljPrzulj (2008) designed a method for comparing node neighbourhoods based on graphlets and demonstrated that clusters of nodes in proteinprotein interaction (PPI) networks, obtained with their graphlet-based distance measure, share common protein properties. They showed how to use this approach to predict functions of proteins and their memberships in protein complexes, subcellular compartments and tissue expressions. Milenkovict al. (2010b) studied the relation between cancer genes and their network topology. They examined several clustering methods based on a graphlet similarity measure and found a difference between the PPI network structure around the cancer and non-cancer genes. Around 80% of the predicted cancer gene candidates have been validated in the literature. Similarly, cost functions for network alignment that are based on graphlet degree vectors show superior results in comparison with other state-of-the-art methods. In particular, MilenkovictMilenkovict al.showed how alignment between the PPI networks of Saccharomyces cerevisiae, Drosophila melanogaster and Caenorhabditis elegans with the human PPI network can be used for identification of genes related to aging, which are difficult to observe directly for humans due to our long lifespans. Milenkovict al. (2011) also applied graphlets to estimate node's topological centrality. Their graphlet degree centrality measure is based on graphlet degree vectors and captures density and complexity of a node's extended neighbourhood. They showed that the genes participating in key biological processes also reside in complex and dense parts of networks.argue that to understand the biological networks, we need to find the mathematical models describing their structure, even though this may not be of direct predictive use. Przuljshowed that although the network structure may be unstable in regions with low edge-density, high-density regions are suitable for network comparison using graphlet degree distributions. Graphlets can also assist in other analytic methods, such as global network alignment. GRAph ALigner (GRAAL) () is an algorithm for aligning arbitrary networks based solely on their topology, which uses a local topology similarity measure based on graphlet degree vectors. The technique was used to show the large amount of shared network topology between yeast and human PPI networks, which can be used to predict biological functions of aligned proteins or reconstruct phylogenetic trees. H-GRAAL () aligns networks by reducing the problem to a weighted bipartite matching that can be solved with Hungarian algorithm. Finally, MI-GRAAL () integrates multiple sources of node similarity information, including the graphlet degree vectors.extended the use of graphlets by defining the orbits for graphlet edges and demonstrated their use with a new clustering method that is not limited to locally similar edges and allows some overlap between clusters. As a practical result, they predicted new pathogen-interacting proteins from clusters in the human PPI network that represent drug target candidates. Therefore, graphlet analysis is a useful tool for bioinformatics, and with the increase of available data there is also a growing need for fast graphlet counting tools.
Related workWe will denote the explored graph as G  V, E. Let  jVj and e  jEj be the number of vertices and edges, and let d denote the maximal node degree. Let N(u) denote the set of vertices adjacent to vertex u. In numbering the graphlets and orbits, we follow PrzuljPrzulj (2007); we refer to the j-th graphlet and i-th orbit by G j and O i , respectively. Counting subgraphs is a computationally intensive task. Common approaches to speed it up include sampling (), exploiting pattern symmetries () or using reconfigurable hardware accelerators based on Field-Programmable Gate Array (FPGA) chips (). The method described in this article is related to the approach developed by, who constructed a system of equations that allows computing the number of occurrences of all six induced four-node subgraphs by knowing the count of any of them. The time complexity of setting up the system equals the time complexity of multiplying two square matrices of size n. We extend this approach to counting how many times each node participates in each orbit. Our method also works on five-node graphlets and scales better on sparse graphs.generalized the result byto count subgraph patterns of arbitrary size. There are several programs for graphlet counting and motif detection that are used in bioinformatics. Fast Network Motif Detection (FANMOD) () is a network motif detection tool based on sampling random subgraphs and comparing their counts with those from random network models. Besides implementing a novel sampling algorithm (), it also provides a full enumeration procedure for graphlets on 28 nodes. Whelan and SonmezSonmez (2012) developed GraphletCounter, which works as a Cytoscape plugin and merges graphlet analysis with visual inspection of the network. GraphCrunch () is a tool for large network analysis. It includes a function for computing orbit signatures of every graph node for graphlets of up to five nodes using an enumeration procedure with correction for over-counting some of the graphlets. A well-organized enumeration method imposes constraints that eliminate the need for isomorphism testing except for distinguishing between a few different graphlets; this is further accelerated by comparing the number of edges and individual node degrees. GraphCrunch has been extended with a new method for topological network alignment and with). Colors are chosen arbitrarily; nodes of the same color belong to the same orbit within that graphlet, e.g. both black nodes in G 14 belong to orbit 31 comparison of the networks with some additional mathematical models (). The graphlet counting procedure in the new version remained essentially the same. Rapid graphlet enumerator (RAGE) () takes a different approach to counting four-node graphlets. Instead of counting the induced subgraphs directly, it reconstructs them from counts of non-induced subgraphs. For computing the latter, it uses specifically crafted methods for each of the six possible subgraphs (G 3 to G 8 in). The time complexity of counting non-induced cycles and complete graphs is Oe  d  e 2 , whereas counting other subgraphs requires Oe  d. Another bound, which is also more suitable for comparison with our method, is Oe  d 2   On  d 3 . Unlike FANMOD and GraphCrunch, RAGE works only for up to four-node graphlets.
METHODSLet x represent a certain node of interest in graph G. Our task is to compute the number of times, o i , that x appears in each orbit O i across all graphlets induced in G. We will present an approach based on a system of linear equations that relate the orbit counts o i. The rank of the system is smaller than the number of orbits by one, so we can compute all values of o i from directly enumerating only a single one. The algorithm allows to compute the orbits for all points x in a graph in time that is smaller than the existing direct enumeration approaches by an order of magnitude. We will first show how to construct a system of equations for fournode graphlets. As for the single orbit that must be enumerated, we chose O 14 , which represents nodes of the complete graph, K 4 (or G 8 ); we show an efficient way to enumerate it. The approach used for four-node graphlets is less suitable for larger graphlets, so we present a different technique for five-node graphlets.
Orbits in four-node graphletsRight sides of equations we are about to construct contain terms that are computed from the graph G. Let cu, v  jNu \ Nvj denote the number of common neighbours of nodes u and v. Let pu, v denote the number of paths on three nodes that start at node u, continue with v and end with some node t, which is not connected to u. We can compute pu, v as pu, v  degv  1  cu, v. If some node x participates in a k-node graphlet G i , it also participates in some k  1-node graphlet G j. This can be seen by removing one of the graphlet's nodes that are the farthest away from x. The subgraph induced by the remaining nodes is connected (any disconnected node would have to be farther from x than the removed node), so it is isomorphic to some k  1-node graphlet G j. We will use this observation in reverse: every four-node graphlet can be constructed by adding a node to some three-node graphlets. To find the relations between counts of orbits in four-node graphlets for a certain node x, we enumerate all three-node graphlets touching the node and count their possible extensions with the fourth node. An example is shown in. Nodes x, y and z induce graphlet G 1 , a path on three nodes; we will observe its extensions to four-node graphlets with the fourth node, w, connected to y and z (dashed lines). The number of such nodes w is cy, z. In our example, there are cy, z  3 such nodes, which we marked by w 1 , w 2 and w 3 (). The edge x, w might exist in the graph G (as in the case of w 3 , the dotted line) or not (as for w 1 and w 2 ). With no edge, nodes x, y, z and w form a paw (G 6 ) with x in orbit O 9 (). With an edge between x and w, they form a diamond (G 7 ) with x in orbit O 12 (). Because all cy, z nodes in Ny \ Nz must participate either in G 6 or G 7 , which puts x in O 9 or O 12 , this gives o 9  o 12  cy, z for the particular triplet x, y and z.We sum this over all possible three-node paths starting at x. Summation must account for symmetries: each graphlet G 6 appearing in the graph is counted twice with roles of z and w reversed, and G 7 is counted twice with reversed roles of y and w. Accounting for this, we getwhere ffi denotes graph isomorphism (e.g. Gfx, y, zg, a subgraph on nodes x, y and z is isomorphic to G 1 , a path with three nodes). For a different example, we will relate orbits O 6 and O 9. We will extend a path on nodes x, y and z with another path that starts with nodes x and y; we denoted the number of such paths by px, y (). Depending on whether the new node is adjacent to z, the extended graphlet is either a claw (G 4 ,) or a paw (G 6 ,). After accounting for symmetries and subtracting 1, as px, y also covers the case when w  z, we getThere are only two three-node graphlets and relatively few possible extensions. Investigating all possibilities in a similar manner yields 10 linearly independent equations with 11 variables that correspond to counts of 11 orbits in four-node graphlets (see the Supplementary Material). Right sides depend on the graph G and need to be computed for each point x. To accelerate their computation, we precompute values of cu, v and pu, v. In all equations, except for the last one, cu, v is computed on pairs of nodes u, v that are connected; in pu, v, they are connected by the definition of p. Therefore, it suffices to precompute cu, v and pu, v only for all pairs of connected nodes u and v, which requires O(e) space. The last equation, in which the new node closes a cycle, is treated separately. Nodes x and z are not adjacent but we can precompute the number of paths of length 2 that start at node x and end at node y. This requires O(n) space for each point; because we compute orbits for one point at a time, this memory can be recycled. Altogether, all lookups in the sums on the right sides can be done in constant time by sacrificing the memory of size Oe  n for precomputed values cx, y and px, y. The total time complexity for computing all orbits for all nodes is Oe  d  T 4 , where OT 4  is the time needed to enumerate complete graphlets on four nodes. Later in the text, we describe an algorithm that does this in On  d 3 , yet the actual importance of this term depends on the structure and density of the graph.
Counting complete graphletsFor every node, we still have to determine the count of one of the 11 orbits. Because graphs are usually sparse, a good candidate is the rare orbit 14, which represents the nodes of the complete graphlet on fourSolid lines are edges in the three-node graphlet being extended. Dashed lines exist by definition: w (or w i ) are the common neighbours of y and z. Dotted lines are optional edges that make the resulting four-node graphlet on x, y, z and w i isomorphic to G 6 or G 7 nodes G 8. Because of few occurrences of this graphlet and its symmetricity, we can efficiently restrict the enumeration. A straightforward way to count the complete graphlets of size four that touch a given node x 1 is to start with that node and in every step add a neighbour x i of the last added node x i1 , while checking that the new node is also connected to all nodes before x i , x j5i1. In this way, when we add x 4 as a neighbour of x 3 we have to check whether it is connected to x 1 and x 2 (dotted lines in), which is unlikely, especially in sparse graphs. A better strategy is to find the common neighbours of x 1 and x 2 , Nx 1  \ Nx 2 , which can be done in O(d). We then choose pairs x 3 , x 4  from this set and check whether they are connected (). Candidates generated in this way have to satisfy only one additional condition, as opposed to two in the straightforward approach. To avoid counting the same graphlet multiple times, we request that x 2 5x 3 5x 4 under some fixed arbitrary ordering of nodes. Although the theoretical time complexity for finding all G 8 that touch x using this algorithm is the same for both approaches, Od 3 , the latter is much faster on sparse graphs. This method can be generalized for efficient counting of larger complete graphlets in sparse graphs. In every step, we maintain a list of candidate nodes C i for x i that are adjacent to all previously added nodes. We select one of these candidates and form a new candidate set C i1 consisting only of nodes in C i that are adjacent to the selected node,The time complexity of finding all complete k-node graphlets that touch x using this algorithm is Od k1 . Later in the text, we use such procedure to enumerate complete subgraphs on five nodes.
Orbits on five-node graphletsFor counting four-node graphlets, we constructed a list of equations by adding nodes to three-node graphlets and observing the resulting fournode graphlets. Extending the four-node graphlets to five-node graphlets would yield a huge number of equations that are not linearly independent. We will use a different approach: for each orbit, we choose some node y from the corresponding graphlet and observe the graphlets and orbits in which the node of interest, x, appears if we add edges between y and other nodes in the graphlet. Let x be the node of interest, let y be the node whose edges we observe and let x 1 , x 2 and x 3 be the other three nodes in that graphlet.illustrates counting of appearances of x in O 59 , which belongs to G 24 (). We will focus on the node marked by y, which is connected to the nodes marked by x 1 and x 3. Removing y reduces G 24 into a diamond, G 7 , with x in orbit O 12. Now assume that we are computing orbits for a certain node x and discover some induced subgraph H ffi G 7 with x in O 12. We assign labels x 1 , x 2 and x 3 to the remaining nodes as shown in the figure. Altogether, the graph G contains cx 1 , x 3  common neighbours of x 1 and x 3 (similar to nodes marked with w in). Although all these nodes areby definition of cx 1 , x 3 connected to x 1 and x 3 , some are also connected to x 2 or x, or both.shows all four possibilities, which give graphlets G 24 , G 26 , G 27 and G 28 with x in orbits 59, 65, 68 and 70, respectively. Therefore,Condition x 1 5x 2 (under some arbitrary ordering of nodes) is needed to consider each graphlet G 7 just once. The other two conditions put x in O 12. The second term in the sum, cx 2 , x 3 , accounts for the case in which the roles of x 1 and x 2 are exchanged. Using a similar construction for other orbits, except for O 72 , gives 57 linear equations for 58 orbits (see the Supplementary Material). Like for four-node graphlets, we directly enumerate the orbit O 72 , which belongs to the complete graphlet. Equations are linearly independent due to the way in which they were constructed: each equation is set up with one orbit in mind (e.g. O 59 in the aforementioned example), and the other orbits that appear in the equation belong to graphlets with a larger number of edges (the additional edges between y and the other nodes, like the dotted edges ind). Additional nice consequence besides independence is that the system is easy to solve, as orbit counts can be computed from those belonging to graphlets with more edges towards those with less. When constructing the equations, we choose y that allows for efficient computation of the right sides: we will ensure that the right sides contain only the node degrees and the numbers of common neighbours of pairs and of connected triplets. This will allow us to precompute and store the values of cu, v and cu, v, t for all pairs and connected triplets in G before computing the orbit counts for individual nodes. First, we choose the node y so that the remaining nodes constitute a four-node graphlet, i.e. removing y does not break the graphlet into disconnected components, which would require enumeration of disconnected subgraphs. Second, the node y has to have at most three connections to avoid the need to compute the number of common. Enumerating G 8 by adding one neighbour at a time or by checking pairs of neighbours. Dashed edges are added by iterating through neighbours, and dotted edges are checked in the last step neighbours of four points, cu, v, w, t. Besides, when y has three neighbours, they need to be connected. A node y that fulfils these criteria exists for all orbits except O 72. Precomputing the values cu, v, t for all connected triplets takes Oe  d 2  time, and storing them in a hash table takes Oe  d space. Computation of the right sides also requires enumerating all the fournodes graphlets, which again has a complexity of Oe  d 2 . The total time required to compute all orbit counts for all x 2 V is then Oe  d 2  T 5  with Oe  d space, where OT 5  is the time required to enumerate all complete five-node graphlets (G 29 ). The algorithm thus has the same upper bound complexity as the existing algorithms, On  d 4 . However, experiments show that the bound is not tight: the contribution of the OT 5  is negligible over the range of sensible graph densities, and the actual running times are smaller by an order of magnitude. We could use the same technique to construct systems of equations for larger graphlets. However, we reduced the running times by imposing some conditions to the selection of the node y. We have not researched whether such nodes also exist for larger graphlets; although theoretically interesting, this may be of little practical use in the context of bioinformatics.
RESULTS AND DISCUSSIONWe compared the speed of Orca with RAGE, GraphCrunch and FANMOD. We ran all experiments on a modest desktop computer (Intel Core 2, 2.67 GHz). We have not experimented with parallel execution; all four algorithms allow for trivial distribution of work on multiple cores, so the benefits of parallelization should be the same for all. We compared the performance of methods on the three largest species-specific PPI networks from the July 2013 update of the Database of Interacting Proteins () and the human PPI network from the BioGRID () 3.2.104 release. The sizes of individual datasets are presented in. All algorithms except the significantly slower FANMOD counted orbits for four-node graphlets in the smaller graphs in a few seconds (). Five-node graphlets present a more difficult task: running GraphCrunch on the S.cerevisiae PPI network took 49 min (as compared with 4.4 s for four-node graphlets). FANMOD was almost 10 times slower, whereas Orca finished the same task 80 times faster, in 6.6 s. RAGE is limited to four-node graphlets. We got similar results for the other two networks. In the larger human network, Orca counted the four-node graphlets 100 and 1800 times faster than Rage and GraphCrunch, respectively; we aborted FANMOD after 24 h. Orca was also the only algorithm capable of counting fivenode graphlets in a human PPI network in less than a day. For comparison with RAGE, we included a test network of Internet autonomous systems (http://www.netdimes.org/ PublicData/csv/ASEdges4_2012.csv.gz) that was used as the benchmark for RAGE (). FANMOD required49 h, GraphCrunch finished in 37 min, RAGE in 3 min and Orca in 2.5 s. Orca finished the computation for five-node graphlets in 49 min, whereas the other two algorithms were stopped after 24 h. The time that Orca needs for counting orbits in five-node graphlets is comparable with those that GraphCrunch needs for four-node graphlets. This is consistent with the way the two algorithms are constructed: GraphCrunch enumerates four-node graphlets to count them, whereas Orca enumerates them to count five-node graphlets. As expected, the time needed for enumeration of complete five-node graphlets is negligible at these network densities. For more insight into time complexities of the compared algorithms, we tested them on synthetic data using three different random network modelsErdo 00 sRenyiRenyi, geometric and BarabasiBarabasiAlbert, random graphs. Erdo 00 sRenyiRenyi graphs are constructed by randomly connecting e pairs of nodes. We generated geometric graphs by randomly placing nodes in a 3D unit cube and connecting the e closest pairs; geometric graphs show largest resemblance to protein interaction networks (). BarabasiBarabasiAlbert preferential attachment model generates scalefree networks that exhibit hubs and individual highly connected nodes.We explored the performance of GraphCrunch, RAGE and Orca at different network densities. FANMOD was not included as it consistently finished previous tests far behind GraphCrunch. All graphs had 1000 nodes; for each method, we increased the graph density until the method needed more than a minute to complete the test. The corresponding graphs were relatively dense, containing up to 40% of all possible edges for test with four-node graphlets and $10% for five-node graphlets. RAGE counted the four-node graphlets slightly faster than GraphCrunch, but they were both significantly outperformed by Orca (and Supplementary Tables S1S6). We observed similar results when counting five-node graphlets (). Orca achieved the highest gain in comparison with other methods on BarabasiBarabasiAlbert models, in which hubs present a large obstacle for GraphCrunch and RAGE. This makes Orca more suitable for real-world networks, which often display the small-world property and contain hubs.
CONCLUSIONGraphlet-based network analysis is useful for various tasks in bioinformatics, such as alignment of PPI networks and prediction of protein functions based on topological similarities. Past studies used these approaches to, for instance, identify genes related to cancer () and aging (). We presented a new algorithm for counting graphlet orbits that is based on derived relations between orbit counts. To count the orbits for k-node graphlets, it enumerates k  1node graphlets and a single k-node graphlet. Empirical results confirm that this decreases the time complexity by an order of magnitude in comparison with other known methods. In practical terms, the algorithm counts orbits in large PPI networks 50100 times faster than other state-of-the-art algorithms.. Comparison of times needed for counting orbits in four-node graphlets in random networks. Graphs are cut off at one minute; results of experiments in which the methods were allowed to run for up to 1 h are available in the Supplementary Material
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
T.Ho evar and J.Dem ar at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Graphlet counting at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
