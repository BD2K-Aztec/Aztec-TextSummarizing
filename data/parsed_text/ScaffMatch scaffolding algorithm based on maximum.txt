Motivation: Next-generation high-throughput sequencing has become a state-of-the-art technique in genome assembly. Scaffolding is one of the main stages of the assembly pipeline. During this stage, contigs assembled from the paired-end reads are merged into bigger chains called scaffolds. Because of a high level of statistical noise, chimeric reads, and genome repeats the problem of scaffolding is a challenging task. Current scaffolding software packages widely vary in their quality and are highly dependent on the read data quality and genome complexity. There are no clear winners and multiple opportunities for further improvements of the tools still exist. Results: This article presents an efficient scaffolding algorithm ScaffMatch that is able to handle reads with both short (<600 bp) and long (>35 000 bp) insert sizes producing high-quality scaffolds. We evaluate our scaffolding tool with the F score and other metrics (N50, corrected N50) on eight datasets comparing it with the most available packages. Our experiments show that ScaffMatch is the tool of preference for the most datasets. Availability and implementation: The source code is available at
IntroductionNext-generation sequencing (NGS) is a powerful technology as it can produce millions of short paired-end reads covering whole genome. The cost of producing reads keeps a trend of decreasing making it a very attractive tool for genome sequencing and assembly. Genome assembly from short NGS reads is a challenging problem. Assembled genomes are frequently highly fragmented and consist of contigs of highly variable length. The connectivity information coming from read pairs mapped to contigs can be used to merge them into a scaffold which is a set of chains of oriented ordered contigs with estimated gaps between all pairs of adjacent elements. A recent comprehensive evaluation of available software tools shows that the scaffolding problem still does not have an adequate solution (). Because of misassemblies in contigs, repeats and chimeric reads, the information about relative ordering and orientation of two contigs connected with a set of read pairs can be contradictory and not reliable. Thus, choosing a wrong subset of read pairs as an evidence of connection between two contigs can result in inferring a wrong relative ordering and/or orientation as well as the gap estimation between them. Edges that comply with the true orientation of contigs and the distance between them are usually called concordant, otherwise discordant edges. The scaffolding problem is usually formulated as an optimization problem on a graph with the vertices corresponding to the contigs and the edges corresponding to the bunches of read pairs connecting contigs. In contrast, the optimization objectives and the methods to find optimal scaffolding with respect to these objectives significantly vary from one tool to another. For example, OPERA () maximizes the number of concordant edges using dynamic programming, SCARPA () minimizes the number of discordant edges using fixed-parameter tractable and bounded algorithm and linear) maximizes number of read pairs agreeing with a chosen contig orientation using nonserial dynamic programming. As all optimization scaffolding formulations are NP-hard (see e.g.), many state-of-the-art scaffolding tools use heuristic approaches exploiting specific properties of the underlying scaffolding graph. SCARPA and SILP2 solve separately the orientation and the ordering problems, MIP () and SILP2 use decomposition of the scaffolding graph into biconnected components. SSPACE () uses a simple but powerful greedy heuristic and BESST () uses read pair statistics to filter out spurious edges created by structural errors and starts scaffolding with larger contigs. In this article, we propose a novel optimization formulation representing scaffolding as a maximum-weight acyclic 2-matching (MWA2M) problem. As the Hamiltonian path problem can be reduced to this problem, this formulation is also NP-complete. The presented algorithm ScaffMatch efficiently finds the maximumweight 2-matching and iteratively destroys all cycles. This approach works very well since, usually, number of cycles is very small. Our experimental study follows the evaluation of state-of-the-art scaffolders inperformed on five scaffolding datasets [including four from the GAGE project (. We have run the majority of up-to-date versions of stand-alone scaffolders such as OPERA, SOPRA (), SSPACE and MIP as well the recently published ones, SILP2 and BESST. We have also included the results for scaffolding modules of SGA () and SOAPdenovo2 () run independently of de novo assembly following (). Our matching-based tool ScaffMatch compares favorably with the state-of-the-art tools in terms of widely accepted N50 metric, the metrics introduced in, as well as sensitivity, PPV and F score in predicting contig junctions.
MethodsBelow we describe the problem formulation and algorithmic details in the following main scaffolding steps: @BULLET Preprocessing of read pairs including read mapping, handling repeats and gap estimation for each read pair. @BULLET Scaffolding graph construction with vertices corresponding to contig strands and edges corresponding to read pairs. @BULLET Matching scaffold finding near-maximum weight paths in the scaffolding graph and the corresponding orientation and ordering contigs. @BULLET Insertion of skipped contigs into the matching scaffold. We conclude with the implementation details of our scaffolding tool.
Read preprocessingEach contig has two reverse complement strands, and each read from a pair is mapped to one of the strands. We discard reads aligned to (suspected) repeats. First, we filter out read pairs in which at least one read has multiple alignments. Then for each contig we compute its read coverage and filter out contigs with coverage greater by 2:5r than the average where r is the standard deviation of contig coverage. This empirically chosen threshold allows to remove majority of repeats while keeping almost 99% of correct contigs. Although assemblers may give chimeric contigs or produce two contigs for the same genomic region (representing the two haplotypes), ScaffMatch does not attempt to identify or modify any contigs. Each read is mapped only to one of the two contig strands (palindromes are discarded). For each read pair connecting two distinct contig strands, we estimate the gap according to[for an alternative gap estimation model see. Among all read pairs connecting the same contig strands, we find a read pair p with the median gap estimation and then bundle p with all read pairs whose gap estimation is at most 3r away from p's estimation. As we want to keep only reads that agree with each other, the reads outside of this bundle are discarded.
Scaffolding graphEach vertex of the scaffolding graph G  V; E corresponds to one of the contig strands and each inter-contig edge corresponds to a bundle of read pairs connecting two strands of different contigs (). The weight of an inter-contig edge is equal to the size of the corresponding bundle. Also for each contig, we have a dummy edge connecting its two strands.
Matching scaffoldingIdeally, we expect that the scaffolding graph would consist of a set of paths each corresponding to a different chromosome (). Unfortunately, repeats introduce noisy edges connecting unrelated contigs even from different chromosomes. Additionally, the paths corresponding to chromosomes may skip short contigs (especially contigs which are shorter than the insert length). Therefore, any set of paths passing through all dummy edges in the scaffolding graph G corresponds to a plausible scaffold (). The most likely scaffold would be supported by the largest number of read pairs. Therefore, we can formulate the following
The scaffolding problemGiven a scaffolding graph G, find a set of paths passing through all dummy edges with maximum total weight of all inter-contig edges. By setting the weight of each dummy edge to a large number (e.g. number of all read pairs), we reduce the scaffolding problem to the following.
MWA2M problemGiven a weighted graph G  V; E; w, find a maximum weight acyclic subset of edges M E, such that each vertex v 2 V is incident to at most two edges in M. The MW2AM of an n-vertex graph G with all edge weights 1 has the weight n  1 if and only if G has a Hamiltonian path. Therefore, the MWA2M problem is NP-complete since it includes the Hamiltonian path problem. A similar well-known problem, the maximum weight 2-matching (MW2M), allows chosen edges to form cycles. In contrast to the MWA2M problem, the MW2M problem can be efficiently solved ().. Gap estimation d is calculated in conformity with the formula: d  L f  LA  startr1  LB  startr2, where L f is the fragment length, LA; LB are lengths of contigs A and B, startr 1  (respectively, startr 2 ) is the distance from the starting position of r 1 (respectively r 2 ) to the beginning of the strand A (respectively, B 0 ) 2.3.3 Maximum-weight matching heuristic for the MWA2M problem We propose to almost optimally solve the MWA2M problem with the following iterative heuristic based on the well-known blossom algorithm () for finding the maximum-weight matching in weighted graphs. It starts with finding the maximum-weight matching M among the inter-contig edges. All the dummy edges also form a matching D. If the union of these two matchings M [ D does not contain cycles, then the heuristic reaches the optimal collection of paths. Otherwise, a negative weight 1 is assigned to the least weight intercontig edge in each cycle. The above steps of finding the intercontig matching M and destroying cycles in M [ D are repeated until the union M [ D becomes a collection of paths. The output of this heuristic will be called the Matching Scaffold. In general, the deletion of least-weight edges may significantly reduce (as much as twice in the worst case) the total weight of the collection of paths. Fortunately, the erroneous heavy inter-contig edges are very rare in real data. Our experiments show that for each scaffolding example, there is no more than a single cycle in the initial union M [ D of the maximum-weight matching M and the dummy edges solution and after the second iteration M [ D does not contain any cycles at all.
Greedy heuristic for the MWA2M problemThe maximum weight matching can be computed efficiently even for larger genomes. Still the runtime can be dramatically decreased using the Greedy Heuristic repeatedly choosing the heaviest feasible edge, i.e. an edge which does not make a vertex degree higher than 2 and does not form cycles with the previously chosen edges. Note that the Greedy Heuristic picks the globally heaviest edge in contrast to greedy scaffolders (such as SSPACE) greedily extending existing chains. We provide an option that allows ScaffMatch to run with the Greedy Heuristic reducing the runtime complexity from On 3  to On  log n as we use max heap in our implementation. Our experiments show that the Greedy Matching performs very well in practice but sacrificing not much in quality to the maximum-weight matching heuristic.
Contig ordering and orientationThe Matching Scaffold is represented by a collection of disjoint chains of contig strands. The sequence of edges along each chain alternates: two strands of the same contig are connected with a dummy edge and two strands of different contigs are connected with an inter-contig edge. When traversing the strands along the paths in the matching scaffold, the order of traversing ends of dummy edges gives us the orientation of the corresponding contigs and the order of traversing inter-contig edges gives us the relative order of contigs.
Insertion of skipped contigsThe matching scaffold can skip short contigs whose length is less than the read pair insert size. For example, let the true scaffold contain a triple of consecutive contigs A, B and C such that l A > l ins ; l C > l ins , but l B ( l ins. Then instead of picking both edges AB and BC, the Matching Scaffold may choose one single edge AC since the edge weight between short contigs depends almost linearly on the length of the contigs. Thus, even though the contig B must follow A in the final scaffold, the weight of the edge between A and B is much smaller than the weight of the edge between A and C, which 'jumps' over B. Below we describe the insertion of skipped contigs into the matching scaffold (Algorithm 1). A contig is identified as skipped only if it is isolated or is a part of a 2-chain in the matching scaffold. Scaffolds with more than two contigs are kept intact. For each skipped contig, we identify the most bundle-supported slot in the matching scaffold satisfying the gap estimations and insert it in this slot (). If several skipped contigs are assigned to the same slot, their relative order and orientation is decided based on the gap. Contigs A, B and C with connecting bundles of read pairs and the corresponding scaffolding graph. Each contig is split into two nodes connected with a dummy edge. Each bundle of read pairs corresponds to an inter-contig edge connecting respective strands with the weight equal to the size of the bundle. A plausible scaffold corresponds to the path C 0  C  A 0  A  B 0  B supported by two inter-contig edges CA 0 and AB 0X, we estimate the distance to the left contig and orient it according to the adjacent strands. Then we sort all contigs with respect to this distance and insert them according to this order.
Software implementationOur algorithm is implemented as a stand-alone software tool called ScaffMatch. We separately provide a UNIX shell script for mapping reads to contigs. As a short read aligner, bowtie2 is used (). The scaffolder takes as input a fasta file containing the contigs and two SAM files produced by mapping the two read files to the contigs. We keep a small set of mandatory parameters: the mean insert size, the standard deviation and the orientation (forwardreverse, reverseforward or SOLiD-style) of the paired-end reads. The program outputs a fasta file with scaffolds. We use Networkx python library for graph computations ().
Results
DatasetsWe validate and compare the scaffolding tools on the collection of scaffolding datasets used inincluding four datasets from the GAGE project (). Thegives the parameters of all used scaffolding datasets.
Quality metricsThe main metric that is used for evaluation of scaffolding tools is N50 (). However, this metric may not be representative enough as mentioned inwhere a comprehensive evaluation of scaffolders was performed. There state-of-the-art tools were compared based on multiple criteria, such as the number of correct junctions between two adjacent contigs, the number of junctions with incorrect relative order, relative orientation, gap estimation and their combinations (e.g. incorrect relative order  incorrect gap estimation). The scores assigned to the scaffolders, however, can be misleading. For example, MIP on S.aureus (using bowtie2) got a high score despite the fact that it joined no contigs. Thus, we introduce an F-score-based metric to compare the results of our tool ScaffMatch with other de-novo stand-alone scaffolding tools.is obtained with the maximum weight matching; the contig B is connected with edges to all four contigs of the matching, the contig X is connected to A and C; B should be placed between A and C according to the consensus of connecting edges and X should be placed between C and D. (b) Since there is a sufficient distance between contigs A and C, B is placed there, i.e. the edge A; C 0  from the matching is replaced with A; B 0  and B; C 0  [the sum of weights of A; B 0  and B; C 0  is less than the weight of A; C 0 ]; since there is no sufficient room for X between contigs C and D, the edges A; X 0  and X ; E 0  are removed. The resulted scaffold is A  B  C  DScaffMatch: maximum weight matching scaffoldingVarious quality metrics have been proposed up to date. Rather than coming up with our own metrics, we have decided to follow the most recent evaluation paper (), which besides N50 and corrected N50 also reports the number of correctly and erroneously predicted joins between contigs in the reference genome. Following, we do not distinguish between links connecting long and short contigs and contigs from different chromosomes. Let P be the number of potential contigs that can be joined in scaffold which is the number of contigs minus the number of chromosomes, let TP be the number of correct contig joins in the output of the scaffolder (true positives) and FP be the number of erroneous joins (false positives). We compute the following quality metrics: TPR  TP P , PPV  TP TPFP , F score  2TPRPPV TPRPPV , where TPR is sensitivity and PPV is positive predictive value.
Evaluation and comparisonScaffMatch is compared with well-established scaffolders SSPACE, OPERA, SOPRA, MIP, SCARPA, two recently published scaffolders SILP2 and BESST () scaffolding modules of SGA () and SOAPdenovo2 ().SSPACE, OPERA and SOPRA used bowtie () mapping, SOAPdenovo2 used its own mapping and all other scaffolders used bowtie2 mapping. All software has been run with the same versions and options as inexcept SILP2 and BESST for which default parameters were used from the respective websites. Results for SILP2 are not given for the combined insert size datasets as it does not have an option to process datasets with multiple insert size. For computing the number of correct and erroneous links, we used scripts provided in. Note that MIP and SGA did not give meaningful results, respectively, for the S.aureus and H.sapiens (long insert size). We compared three different versions of ScaffMatch: ScaffMatch (maximum weight matching with insertion), ScaffMatch_G (greedy matching with insertion) and ScaffMatch_B (maximum weight matching) in the Supplementary Table S1 (see Supplementary Data). ScaffMatch usually has the best F score among all three versions. ScaffMatch_G also can be very different from ScaffMatch since it may choose to match completely different contigs. ScaffMatch_B has usually the highest PPV and corrected N50 among all three versions implying that insertion of skipped contigs might be erroneous. Unexpectedly, the number of contigs skipped by ScaffMatch_B is not much greater than for ScaffMatch showing that the solution for the scaffolding/MWA2M problem does not skip over many contigs. The results for GAGE scaffolding testcases are inand results for P.falciparum are in. The entries in the bold font are the best among all 10 scaffolders with respect to the corresponding quality metric. ScaffMatch has the top F score for four testcases and the top corrected N50 for two testcases. Additionally, ScaffMatch_B has the top corrected N50 for S.aureus. SOAPdenovo2 has the top F score for two testcases and the top corrected N50 for three testcases. MIP is a top performer once for F score and once for corrected N50. Finally, OPERA is the best in corrected N50 for two testcases (still losing to ScaffMatch_B on S.aureus) and SSPACE has the best F score for one testcase. The runtime of all compared scaffolders are in Supplementary Table S2 in Supplementary Data. The runtime growth rate with respect to the dataset size is similar for all scaffolders. The fastest scaffolder is SSPACE, and the slowest is SOPRA.
ConclusionsIn this article, we present a novel stand-alone scaffolding algorithm ScaffMatch, which is based on representation of the scaffolding problem as the maximum weight acyclic 2-matching. Our experiments show that, unexpectedly, the number of skipped contigs is not significantfor many datasets, the results for ScaffMatch_B are only slightly improved by insertion of skipped contigs in ScaffMatch. The ScaffMatch software implementation is shown to be consistently one of the top performers on majority of the scaffolding datasets.
FundingThis work is supported in part by the NSF Grant IIS-0916401. Conflict of Interest: none declared.ScaffMatch: maximum weight matching scaffolding
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
I.Mandric and A.Zelikovsky at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
