During the past years we have witnessed the rapid development of new metagenome assembly methods. Although there are many benchmark utilities designed for single-genome assemblies, there is no well-recognized evaluation and comparison tool for metagenomic-specific analogues. In this article, we present MetaQUAST, a modification of QUAST, the state-of-the-art tool for genome assembly evaluation based on alignment of contigs to a reference. MetaQUAST addresses such metagenome datasets features as (i) unknown species content by detecting and downloading reference sequences, (ii) huge diversity by giving comprehensive reports for multiple genomes and (iii) presence of highly relative species by detecting chimeric contigs. We demonstrate MetaQUAST performance by comparing several leading assemblers on one simulated and two real datasets. Availability and implementation: http://bioinf.spbau.ru/metaquast.
IntroductionMetagenomics studies genetic material taken directly from environmental samples. NGS technologies allow for extracting short reads even from low abundant organisms without cloning. However, the data produced in such experiments tend to be enormous, noisy, and contain fragments from thousands of species highly varying in abundance and homology. Those challenges led to a new computational problem of metagenome assembly, followed by a diversity of methods (), which demands a standard benchmark procedure. Most existing assembly evaluation approaches are not designed to work with metagenomes. However there exist methods which count read likelihoods with respect to the assembly (), or determine single-copy conservative ubiquitous gene content (). Unfortunately, none uses contig alignments to a closely related reference genome. In this article we present MetaQUAST, a metagenomic-specific improvement over QUAST (). QUAST detects errors based on alignments to a given closely related reference genome, and also reports and plots contig statistics like N50 and gene content which gives an overview of constituent species even without user-supplied reference sequences. To address metagenome assemblies, MetaQUAST adds several new features: (i) ability of using an unlimited number of reference genomes, (ii) automated species content detection, (iii) detection of chimeric contigs (interspecies misassemblies) and (iv) significantly redesigned visualizations.
Materials and Methods
Reference-based evaluationThere are well-studied metagenomic datasets with known species content () or simulated reads (). They can be used with MetaQUAST to evaluate assembly methods based on alignments to reference genomes.The multiple-reference pipeline consists of four major steps (Supplementary): 1. All reference genomes get concatenated into one file (combined reference). QUAST is fed with all input assemblies versus the combined reference. We force QUAST to report all ambiguous alignments instead of only one. For metagenomic datasets containing closely related species, all ambiguous alignments are essential. 2. We partition all contigs into groups, each of which contains sequences mapped to a particular reference genome (based on previously generated alignments). The contigs mapped to several genomes go into every matching group. Unaligned contigs are put into one extra group. 3. Next, QUAST is launched for each input reference separately, feeding it with a corresponding group of contigs. The group of unaligned contigs is processed without any input reference. 4. Finally, the results of all QUAST runs are grouped together into summary reports and visualizations. A user can view both detailed full QUAST outputs for each run, as well as bird-eye overviews of the results from the entire dataset.In addition to the QUAST standard set of quality statistics (N50, genome fraction, etc.), we added two metrics:In contrast with regular QUAST which uses GeneMarkS, MetaQUAST uses MetaGeneMark () for gene prediction, which is developed specially for metagenomes.
De novo evaluationMost experimental metagenomic studies operate with de novo assemblies where the reference information is not available. When MetaQUAST is executed without input reference sequences or species lists, it attempts to identify species content and automatically pull reference sequences. Note that the algorithm works under the assumption that researchers are mostly interested in microbial communities, so the search is restricted to bacteria and archaea. The workflow (see Supplementary) starts with applying BLASTn () to align contigs to the 16S rRNA sequences from the SILVA database (). The 16S subunits, which are present in almost all microbial species, are highly conserved sequences but also include a hypervariable region that can serve to classify organisms into taxonomic groups. For each detected species, one strain with the best score is remained in the assembly. Top 50 organisms are queried against NCBI, and the least fragmented sequence for each species is downloaded. Due to the known issues with differences in the copy number of rRNA operons between organisms, and intra-genomic heterogeneity of the 16S genes, some of the downloaded genome sequences may not have representation in the assembly under assessment. MetaQUAST attempts to filter false positives by removing genomes with a contig coverage fraction of less than 10% (for all assemblies). In special cases when all sequences have a very low genome fraction, the list remains unfiltered.As a result, we obtain a set of genomes possibly represented by the assembled sequences. We launch MetaQUAST using these sequences (as in section 2.1) and produce the same output files as in the case of usual reference-based analysis. Our approach is a compromise between accuracy and time/memory consumption. For more precise results, we would advise using MGTAXA (), or methods based on exact read alignments, e.g. Kraken () or CLARK (). Very precise results can be obtained by a BLASTx () search against the whole NCBI-nr database. The acquired list of species names can be fed to MetaQUAST in a plain text format, making it download the specified sequences from the NCBI database and use them for the reference-based evaluation (see Section 2.1).
Refining misassemblies based on read mappingThe regular single-genome QUAST algorithm reports structural disagreements between contigs and a reference genome as misassemblies. However, in some cases they may be proof of structural variants (SVs) rather than true assembly errors. This is especially important when analysing a metagenomic community for which no close references are available. MetaQUAST addresses this problem by taking pair reads mapping into consideration (Supplementary). MetaQUAST applies a structural variation finding algorithm to detect breakpoints based on discordant read-pairs, which then used to mute misassemblies that share called breakpoints.
SV detectionMetaQUAST utilizes bowtie2 () for performing reads alignment against the combined reference genome. The BAM file () produced by bowtie2 is sorted by coordinate and passed as an input for SV discovery software. We have chosen Manta () SV caller that outperforms LUMPY () and Pindel () by sensitivity and precision on our test datasets.
Misassembly classificationEach misassembly reported by QUAST is compared with breakpoint confidence intervals of all discovered SVs. If both start and end coordinates of the misassembly lie within the SV intervals extended by a small d, MetaQUAST marks this misassembly fake and does not include into the final report. If no similarity is found between SVs and the misassembly, it is considered true. The default d value is 100 bp which is based on manual analysis of dozens SVs occurred on real and simulated datasets. This approach allows us to significantly reduce number of falsely reported misassemblies on all three test datasets. See Supplementary Material for detailed benchmarking results.
VisualizationMetaQUAST complements the QUAST visualizations with a number of bird-eye overviews. In addition, an interactive summary HTML report combining key statistics for all assemblies and references is generated. Charts and summary HTMLs are demonstrated in Supplementary Material. We classify summary plots into three groups:shows a value for the combined reference and can be expanded to show values per each reference (see). The blue/red heatmap emphasizes outliers.
ResultsWe tested MetaQUAST on three datasets: the CAMI (http://camichallenge.org) simulated toy dataset, the MH0045 sample from MetaHit and the SRS077736 tongue dorsum female sample from HMP (). We assembled these data using four leading assemblers commonly used in metagenomic studies: IDBA-UD (), SPAdes (), Ray Meta () and SOAPdenovo2 (). Comparisons results and MetaQUAST performance on all three datasets are demonstrated in Supplementary Material. The comparison on these datasets demonstrated that none of the assemblers can be called an undisputed leader in metagenomic assembly. Thus, tools such as MetaQUAST are of great practical importance for the community. It will help scientists to assess different assembly software and choose the best pipeline for their research.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
