Motivation: Motifs in DNA sequences often appear in degenerate form, so there has been an increased interest in computational algorithms for weak motif discovery. Probabilistic algorithms are unable to detect weak motifs while exact methods have been able to detect only short weak motifs. This article proposes an exact tree-based motif detection (TreeMotif) algorithm capable of discovering longer and weaker motifs than by the existing methods. Results: TreeMotif converts the graphical representation of motifs into a tree-structured representation in which a tree that branches with nodes from every sequence represents motif instances. The method of tree construction is novel to motif discovery based on graphical representation. TreeMotif is more efficient and scalable in handling longer and weaker motifs than the existing algorithms in terms of accuracy and execution time. The performances of TreeMotif were demonstrated on synthetic data as well as on real biological data.
INTRODUCTIONRegulatory regions such as promoters, enhancers, locus control regions, etc. contain motifs or regulatory elements that control biological processes such as gene expression (). Generally, activation or inhibition of gene expression is regulated by proteins referred to as transcription factors (TFs) that bind to particular sites in regulatory regions. For example, TATA box with a core sequence of 5-TATAAA-3 located in the promoter region of genes is bound by TFs such as TFIID, TFIIA and TFIIB to initiate transcription. Such TF binding sites (TFBS) are useful DNA motifs and their locations and detection are important to decipher and control sophisticated regulatory mechanism of gene expression. In practice, sequence motifs occur with mutations or degeneration at sites, which are then referred to as motif instances. Motifs are denoted as (l,d)-motifs where l denotes the motif length and d denotes the maximum number of mutations allowed in the motif. Many techniques have been proposed for detecting motifs: enumeration algorithms (), probabilistic * To whom correspondence should be addressed. algorithms and () deterministic algorithms (). In addition, ensemble techniques have been attempted (). An algorithmic challenge for motif discovery was posed in Pevzner and Sze (2000): find 20 planted motif instances of (l,d)-motifs in 20 DNA sequences of length 600. It was observed that most existing techniques were unable to detect a (15, 4)-motif. This problem, referred to as motif challenge problem, planted motif discovery problem or subtle/weak motif discovery problem, has recently received increased attention. Many deterministic graphbased algorithms have been proposed for weak motif discovery, which begin by representing l-mer substrings sampled from sequences in the dataset as nodes in a multipartite graph. Thereafter, the nodes with  2d Hamming distance are connected by edges as two instances of the same motif must not differ by more than in 2d sites. The cliques of a sufficient size of this graph represent instances of the motifs in the dataset. A graph-based algorithm WINNOWER was proposed to solve the motif challenge problem (). cWINNOWER imposes an additional filtering constraint to WINNOWER to decide whether edges should be deleted or retained (). The modification substantially improves the execution time compared with WINNOWER. We have previously proposed an exact graphbased algorithm DPCFG, which efficiently detects weak motifs by constructing lists (cliques) of motif instances in graphs (). DPCFG had better accuracy and execution time than those of WINNOWER for sequences as long as 2000 for the (15, 4)-motif problem. However, for longer and weaker motifs such as (24, 8), DPCFG demands high memory requirements. This work attempts to solve problems with longer and weaker motifs with less memory and time requirements. Probabilistic graph-based algorithms, such as MotifCut () and MCL-WMR (), have also been proposed for weak motif discovery. MotifCut formulates the problem into finding maximum density subgraphs in a weighted graph constructed using all l-mer substrings from the dataset. MCLWMR is a heuristic that uses the Markov cluster to search for cliques of motif instances in weighted graphs. MCL-WMR has shown competitive execution time and accuracy. Non-graph-based algorithms were also proposed. For example, PROJECTION enhanced discovery performances through finding good starting points for expectation maximization (). PROJECTION produced higher performance than WINNOWER for weaker (l, d)-motif detection problems. However,Page: 2642 26412647
H.Q.Sun et al.its performance begins to drop significantly above sequence length of 1400 for the (15, 4)-motif problem (). A rule-based algorithm iTriplet was recently proposed for weak motif discovery (), which uses substrings of sample sequences to construct triplets. Based on several proposed rules, iTriplet generates candidate motifs from the intersection of three circles centered at each member of a triplet. The candidate motifs are then associated to the sequences. If a generated candidate motif is associated to an expected number of sequences in the dataset, it will be selected as the target consensus motif. iTriplet has been shown to be capable of handling highly degenerated long motifs, such as (18, 6)-and (24, 8)-motifs. However, it suffers from substantial computational requirements. In this article, a new deterministic tree-structured graph-based algorithm is introduced for weak motif discovery. Using reference nodes from a pair of reference sequences, TreeMotif constructs one node trees with nodes from one specific sequence by dynamically appending new nodes from the other sequences as the leaf nodes of the trees. The TreeMotif is able to detect long weak motifs such as (40, 14) efficiently in time with acceptable memory requirements.
TREEMOTIFTreeMotif is inspired by graph-based approaches to weak motif discovery. The novelty of TreeMotif is that it uses a tree-structured algorithm to find cliques from the graphical representation of motif instances. In addition, as a clique may not represent a deterministic motif consensus [for some sites, more than one bases are likely to appear (, TreeMotif, driven by samples instead of specific patterns, is capable of detecting motifs with highly degenerated positions. The algorithm consists of three main steps: graph representation, tree construction and motif refinement. In what follows in this section, we describe these steps in detail.
Graph representationGiven a set s={s i } m1 i=0 of m DNA sequences where s i =(s i,j ) n1 j=0 denotes the i-th sequence in the dataset and s i,j ={A, C, G, T }, we are interested in detecting (l,d)-motifs. For simplicity, all the sequences are assumed to be of the same length n ( l) and oneoccurrence-of-motif-per-sequence (OOPS) model is assumed. Let v i ={v i,j } nl j=0 be the set of all l-mer subsequences in sequence s i where v i,j =(s i,j ) j+l1 j =j represents the subsequence starting at site j of the sequence. These subsequences are represented as nodes in a m-partite graph. Let function D compute the Hamming distance between two nodes and D max compute the maximum pairwise Hamming distance among the nodes in its arguments. In order to build the graph representing motif instances in the dataset, a pair of reference sequences are chosen: without loosing generality, let us choose s 0 and s 1 as reference sequences. The reference node pairs, one from each reference sequence, are selected as the node pairs that are of 2d distance apart. A graph is constructed by drawing edges between the reference node pair and each node in the other sequences
Tree constructionAnother reference sequence (other than the reference pair for node selection) is selected for tree construction. Let us select s 2 as the reference, and then the nodes in P 2 are initialized as the individual roots for building trees. Let T ={root(T )} K k=1 T k be a K-ary tree with a finite set of nodes where root(T ) denotes the root of the tree. Except the root node of the tree, other nodes are partitioned into k disjoint subsets {T k } K k=1 where each T k is a K-ary tree. Except for the root, each node in T has one unique parent node and can have up to K child nodes. Let parent() denote the parent node of the argument node, child() denote the set of child nodes of the argument node and depth() denote the depth of the argument node in the tree. Note that depth(root(T )) = 1. Specifically, for each reference node pair, all the trees initialized are constructed by appending nodes in {P i } m1 i=3 incrementally. Any branch of a tree is a connected path of nodes. A branch is said to be extendable by a node if the maximum Hamming distance between any one of the nodes on the branch and the node is  2d. The extendable() function is designed by filtering tree T in a breadth-first manner by using a first-in-first-out queue Q, as given in Algorithm 2. The leaf nodes are retained in Q as filtered nodes. Initially, Q is set as empty. For the root node R of T , if D(v i,j ,R)  2d, R is inserted into Q; otherwise, filtering is stopped and Q is returned as empty. The process of possible filtering starts at the check on the front node in Q. If the node is a leaf node of T , filtering is stopped and Q is returned; otherwise, the node is removed from Q and its children (whose Hamming distances from v i,j are not > 2d) are inserted into the end of Q. While Q is not empty, the above process is repeated. Note that a tree node v i,j corresponds to a node from S i starting at position j. As discussed, if queue Q is non-empty, all filtered nodes correspond to branches that are extendable by node v i,j. Thus, we directly append v i,j onto these leaf nodes. If Q is empty, it means that no branches in T can be extendable by v i,j. After check on appending of v i,j , the same filtering and appending processes are carried out for all the other nodes in P i. If not any node in P i is appended, the current tree can be stopped for construction and cleared. The tree-construction algorithm is given in Algorithm 3.
Motif refinementThere may be spurious branches that cannot lead to motifs subjected to OOPS constraint and redundant branches that correspond to the Page: 2643 26412647
Tree-structured algorithm for long weak motif discoveryAlgorithm 2 extendable(v i,j ,T )Given tree T and a node v i,j Q  // set the queue as empty if D(v i,j ,root(T ))  2d then Q.back()  root(T ); // insert the root to the end ofsame motif. The refinement of the trees as follows is necessary to include more target motif instances. @BULLET Elimination of spurious branches in tree construction: if a branch cannot be extendable by any node in a specific sequence, pruning of this branch is performed by backtracking from the leaf node to a node whose parent has more than one child; and just prune away the subbranch from this node to the leaf node. @BULLET Merging redundant tree branches after tree construction: once a tree is obtained, each branch together with related reference nodes corresponds to a clique of motif instances. Therefore, such cliques are merged if all the nodes are within 2d (making the clique size larger than m). This can guarantee more target instances included in the same clique.After refinement, trees that have nodes from every sequence represent motifs. Consensuses of the motifs are then found using all the motif instances (that is, the nodes in the trees). An example on tree construction and motif refinement is given in Section A of Supplementary Material.
Time complexitySuppose p is the probability of two random strings of length l having a Hamming distance  2d. Thenwhere p is a measure about the weakness of the (l, d)-motifs. The larger the value p, the weaker the motif becomes ().shows the time complexity of TreeMotif and related motif discovery algorithms. The time complexity of TreeMotif is approximately O(mn 4 p 2 ) when p < 0.32 and n  800. When sequences are long or motifs become weaker, TreeMotif is able to reduce the execution time by generating new branches more accurately compared with DPCFG. In addition, TreeMotif does not have to duplicate the previous tree for new nodes. It only needs to append new nodes onto the previous tree after filtering. Necessary pruning operations only take place when all nodes (selected from a specific sequence) have been checked for extendability. This makes information from the previous sequences intact without duplications, reducing execution time and memory requirements.
RESULTSThe performance of TreeMotif was evaluated on synthetic data as well as on real biological data. Synthetic datasets provide quantitative measures that can compare its performance with the existing techniques (). Experiment results of MEME, GibbsDNA, PROJECTION, iTriplet, DPCFG and TreeMotif were obtained from runs on a workstation with 2.66 GHz CPU and 3 GB RAM. Detections with MEME, GibbsDNA, PROJECTION and DPCFG were based on exactly one motif occurrence per sequence (OOPS) while with iTriplet and TreeMotif, detections were made with at least one motif instance per sequence.
Synthetic dataFollowing, synthetic datasets are generated using the model of fixed number of mutations. First, a specific number of i.i.d. sequences were generated. Second, an instance of a target motif of length l is planted at a random position of every sequence. Third, for each motif instance, equal to or less than d positions were mutated by randomly selecting from l positions.). Note that nPC is <1.0 because random substrings could exist in the sequences, which are as conserved as the target motif instances. TreeMotif, DPCFG and iTriplet show comparable nPC and nSn, higher than those of MEME, GibbsDNA and PROJECTION. Thereinto, DPCFG shows the highest nPC but with lower nSn while iTriplet shows perfect nSn at the cost of lower nPC. With OOPS model, TreeMotif can achieve the same results as DPCFG; if the target is to find an exact consensus motif, TreeMotif can achieve the same results as iTriplet. On performance, TreeMotif can be considered as an eclectic method of iTriplet and DPCFG. Note that TreeMotif and DPCFG did not detect the correct motif (at low nSn), because the clique of the correct motif instances was (found but) not reported as the top ones. Although pattern-driven methods such as iTriplet can show better nSn due to the alignment using candidate consensus patterns, when there is no exact consensus motif in a dataset, they usually fails to find the motif instances. This is why the clique of motif instances are kept as the target for TreeMotif. As for time efficiency, TreeMotif and DPCFG required comparable execution times that are less than the other methods for (15, 4)-motif problem.
Motif challenge problem
H.Q.Sun
Weakness of embedded motifThe p value reflects the weakness of an (l, d)-motif (Section 2.4). With n = 600 and m = 20, the average nPC and average execution time of TreeMotif, DPCFG and iTriplet with increasing p are depicted in. For relatively stronger motifs (showing smaller p value), such as (13, 3) and (40, 12), TreeMotif shows comparable performance to DPCFG. For weaker motifs such as (14, 4) and (19, 6), TreeMotif shows relatively higher nPC and consumes less execution time. In addition, TreeMotif can successfully produce results for much weaker motifson the (16, 5)-motif, because many random cliques occur in such data. In this case, more informative target function on ranking the cliques are needed. Meanwhile, when l > 20, TreeMotif can find the target motif instances with slightly higher nPCs while consuming much less execution time than iTriplet. For instance, for the (24, 8)motif problem which other methods such as MEME and GibbsDNA all have difficulty in dealing with (), TreeMotif requires about one-seventh the execution time of iTriplet. iTriplet yielded low values of nPC because it failed to find the target motif instances for a part of the datasets tested (due to out of memory). As seen from, performance of iTriplet is influenced by both the weakness p of the motif and the motif length while that of TreeMotif is influenced only by weakness. Generally, patterndriven algorithms cannot scale efficiently with the length of motif as the number of candidate motifs to test grows exponentially with l. TreeMotif is a sample-driven algorithm, which is more scalable for dealing with long weak motifs. For example, with settings (13, 3) and (40, 12) showing approximately the same p, iTriplet requires much more time on the latter while TreeMotif performs consistently.
Length of embedded sequencesWe tested TreeMotif on synthetic data with sequence length increased from 600 to 2000. For each dataset, one instance of a (15, 4)-motif is planted in each of the 20 sequences. Performances of the algorithms are shown inand 2.shows that PROJECTION can produce slightly better results than MEME and GibbsDNA, but their nPCs are all <0.5. Approximately, nPC of DPCFG is the highest when sequence length is <1500. This is because it outputs exactly m instances and most of them are the target instances. However, when the sequence length is >1500, nPC of DPCFG decreases quickly. This is because too many target instances have been substituted by spurious sequence instances. nPC of TreeMotif and iTriplet is >0.70 as sequence length is increased to 2000. Their nPC also decreases when the sequences become longer since random substrings that are as conserved as the target motif instances were collected in the resulted cliques. That is, the main reason why low nPC is resulted by DPCFG is that it misses true signals, whereas TreeMotif and iTriplet report false signals. Overall, iTriplet has similar nPCs as TreeMotif. However,
Tree-structured algorithm for long weak motif discoveryfor certain datasets with sequences of length 1000, iTriplet runs out of memory and thus fails to produce correct results. This results in its lower average nPC.compares the execution times of TreeMotif and DPCFG. Part of the execution time of iTriplet is also included. As seen, iTriplet consumes much more execution time than TreeMotif and DPCFG. As n is increased from 600 to 2000, TreeMotif requires less time to discover motifs than DPCFG. For example, when the sequence length is <1300, two algorithms require comparable time. But when the sequence length is 2000, TreeMotif consumes about one-third the execution time of DPCFG.
Similarity of embedded sequencesFor synthetic data, all bases were generated with no bias on their contents, that is, their occurrences are equally likely. Any bias on the bases introduces spurious signals into sequences (). This may cause TreeMotif to take a longer time to find motifs (see Section B of the Supplementary Material). For example, with G + C = 0.35, TreeMotif requires >100 s to find out a (15, 4)-motif while it requires <1 s when G + C = 0.5. Execution time of probabilistic algorithms such as MEME is not affected by such settings. However, they cannot guarantee the discovery of the target instances. For patterndriven algorithms, they are also not affected. However, as discussed in Section 3.1.1, such algorithms take effect only for data containingdeterministic consensus motifs. Therefore, although sample-driven algorithms such as TreeMotif are time consuming for the discussed settings, one may be inclined to use them to produce results if not enough prior information is known about the data.
Real dataTo test the practicality, TreeMotif was tested on datasets of preproinsulin, DHFR and c-fos (), LexA (), and E.coli CRP (). Discovered and published motifs are shown in. For all the datasets, each sequence was assumed to contain one instance and experiments were carried out with l starting from 6, and pair (l,d) were set empirically to check if the target motif consensus is discovered. Data c-fos, DHFR and prerpoinsulin consist of sequences in the upstream regions of eukaryotic genes. Motifs they contained had only a few mutations, which were discovered efficiently and accurately by TreeMotif.
E.coli CRP data For E.coli CRP data from GenBankRelease 55, each sequence contains at least one CRP-binding site. Although each sequence consists of only 105 bases, the motif tgtgaxxxxgxtcaca is rather weak. For this data, TreeMotif can produce the motif as tgtgaxxxagxtcacatt with l = 18, d = 6. With the same l and d, PROJECTION cannot find the motif although it can produce the consensus as ttgtgatggagttcacattt with l = 20, d = 4. Also, as not all the bases on each position are unique, pattern-driven methods such as iTriplet fail to find the motif. This demonstrates the better capability of TreeMotif to discover weaker motifs than PROJECTION [note that (18, 6) is a weaker setting compared with (] and the pattern-driven methods.
LexA dataThis data contain 16 sequences but only 14 of them contain more than one motif instances (sequences himA and uvrC contain no instances). By setting l = 24 and d = 8, one motif is discovered as tactgtatataxaxxcagtxxaat (with 80% of the bases of the published motif). In addition, after excluding himA and uvrC (to obtain the OOPS data), tactgtatataxatacagta is discovered by setting l = 20 and d = 5.
Other benchmark dataBenchmark datasets for the evaluation of motif discovery algorithms have been constructed bySandve et al.
H.Q.Sun et al.(2007) using binding sites extracted from TRANSFAC database version 9.4. The real data version of the benchmarks contains 50 datasets formed using genomic sequences. Each dataset contains five or more sequences of the maximum length of sequences as 2000 bp. For each motif, gaps are not allowed and each sequence is expected to have one or more occurrences of the motif instances. Compared with the benchmark designed by, these datasets are more appropriate for evaluating motif discovery algorithms (). On this dataset, using performance of MEME as the base, the performance of TreeMotif was compared with Weeder () which is a suffix tree-based quasi-exact algorithm, as it shows relatively better performance than some other tools according to the analysis in. Following, the nucleotide level correlation coefficient nCC was used as the performance metric. 3 The discovery results of TreeMotif is uploaded to the web benchmark tool provided by. We compare nCC of TreeMotif and Weeder by keeping FP approximately at the same level, as shown inand 4. The nCC of all datasets produced by MEME are sorted in the ascending order and used as a basis. Then the performances of Weeder and TreeMotif on each dataset are drawn accordingly. As seen, TreeMotif achieves better nCC than weeder for 34 out of 50 datasets. Overall, at the comparable level of FP, TreeMotif achieves an average nCC of 0.194 compared with that of Weeder as 0.096. For the five datasets on which Weeder achieves better nCC by reporting fewer FP, it also reported less or equal TP than TreeMotif. Weeder outperforms other existing tools, because it reports only the 'strongest' motifs (thus fewer FP) (). For the other 11 datasets, TreeMotif fails as too many random cliques were found while the target clique is not reported as the top one (this is similar to the discussion in paragraph 5 of Section 3.1.1). A possible reason for this may be that the contents of nucleotide bases are biased, i.e. bases are not uniformly distributed. For instance, the G + C content of these files is 0.55 or 0.45. This increases the probability of two random strings being within 2d (related to the problem we addressed), especially when the background sequences are long. As a result, the number of random cliques, which may inhibit the detection of correct target, increases.).
DISCUSSIONWeak motif discovery is an important yet unresolved problem in computational biology. Several graph-based exact methods such as WINNOWER and DPCFG have shown improved accuracy compared with heuristics or probabilistic methods. However, clique finding to discover the motifs can be time consuming. In this article, we designed TreeMotif for discovering weak (l, d)-motifs by building up trees on nodes of graphs. After initialization, TreeMotif appends new nodes onto existing trees, where the appending operations happen only when cliques indicated by the leaf nodes are extendable by the new nodes. The novel-constrained strategy of clique construction introduced in TreeMotif can avoid trivial operations on intermediate results of final cliques. In addition, by doing motif refinement, the sensitivity of motif discovery (defined in Section 3.1.1) can be increased compared with the list algorithm inwhich produces exact OOPS motif instances by using a recursive node selection. Performance comparisons with several popular motif discovery methods have shown that TreeMotif detects weak motifs accurately, especially for relatively longer weak motifs. Moreover, it performs better on a recent benchmark constructed using real motif data. One drawback of TreeMotif is that its memory requirement grows exponentially as the sequence length n or parameter p is increased. Because of large memory requirements, TreeMotif failed to find weaker (l, d)-motifs such as (13, 4), (15, 5), (17, 6), (18, 6) and (19, 7). This is due to the maintenance of increased number of Page: 2647 26412647
Tree-structured algorithm for long weak motif discoverytree branches (i.e. intermediate cliques of size i  m1). In all such cases, if the number of sequences is small, say K, TreeMotif might be able to find K-cliques (K < m). Therefore, by devising K that divides a dataset of m sequences into m/K subdatasets, TreeMotif can be used on these subdatasets. After all cliques of size K are found, they could be merged as larger ones. This will be part of our future work. Another limitation of TreeMotif is that it can deal with only OOPS type of data at the current stage. While in practice, the data may contain sequences with no motif instances. Therefore, techniques to avoid noisy instances during tree construction have to be designed. For example, a strategy has been introduced to construct cliques of all varying sizes and has shown success in finding motifs in noisy data (). Correspondingly, a similar strategy might be used that appends new nodes onto not only leaf nodes but also nodes on the upper levels of a tree. In this way, cliques of all sizes will be constructed instead of those of only size i. This might involve more space; however as a trade-off, the noise in the cliques might be excluded. Generally, the strategy for tree construction still needs improvement to make TreeMotif more time and memory efficient.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
nPC=TP/(TP + FN + FP). 2 nSn=TP/(TP + FN).
