Motivation: The Full-text index in Minute space (FM-index) derived from the Burrows–Wheeler transform (BWT) is broadly used for fast string matching in large genomes or a huge set of sequencing reads. Several graphic processing unit (GPU) accelerated aligners based on the FM-index have been proposed recently; however, the construction of the index is still handled by central processing unit (CPU), only parallelized in data level (e.g. by performing block-wise suffix sorting in GPU), or not scalable for large genomes. Results: To fulfill the need for a more practical, hardware-parallelizable indexing and matching approach , we herein propose sBWT based on a BWT variant (i.e. Schindler transform) that can be built with highly simplified hardware-acceleration-friendly algorithms and still suffices accurate and fast string matching in repetitive references. In our tests, the implementation achieves significant speedups in indexing and searching compared with other BWT-based tools and can be applied to a variety of domains. Availability and implementation: sBWT is implemented in C þþ with CPU-only and GPU-accelerated versions. sBWT is open-source software and is available at
IntroductionIndex structures, such as the Full-text index in Minute space (FM-index) derived from the BurrowsWheeler transform (BWT) () and enhanced suffix arrays (), have been widely used in NGS applications for mapping short reads to the references (). Recently the biological applications of the FM-index are expanding; the FM-index has been used to compress NGS data () and de novo assembly (). These applications require dynamic construction of the indexes based on reads. For instance, in the construction of the overlap graph for doing de novo assembly as demonstrated by Simpson and Durbin (). The suboptimal performance of
Bioinformatics Advance Access published July 21, 2016indexing, especially for huge read sets or assembling contigs/ chromosomes has become a cause for concern. Several algorithms have been proposed to construct the FMindex from a huge collection of reads, such as the dynamic FMindex (), BCR (), CX1 () and ropeBWT2 (); however, these algorithms are unable to handle long fragments efficiently (up to kilobases), which appear in the later rounds of the contig assembly or are generated from long read sequencing techniques (). Many efforts have been made to improve the efficacy of the construction of the index structure (). One BWT variant, Schindler transform (a.k.a. sort transform, ST), uses only order-k contexts (i.e. the order of suffixes are determined only by their first k-mers) and is still invertible with some extra complexity and performance penalty (;). ST is faster and much easier to parallelize with hardware than BWT. Several implementations of ST have been proposed but the indexes built are not applicable to searching (). Recently,has demonstrated the use of ST for short read alignment; however, the proposed approach required to keep huge data structure from the fully sorted BWT, which is not scalable and does not take full advantage of the ST. To reduce the excessive memory footprint that is usually not applicable to graphic processing unit (GPU) or hardware accelerated environments, we herein propose novel, simple and highly parallelizable algorithms coupled with ST and still competent in string matching for general purposes. Two implementations of our algorithms (i.e. sBWT) are provided and were fully tested and compared with existing tools. We also applied our implementations to improve the most timeconsuming step in de novo assembly and thereby exemplified the broad utility of sBWT. sBWT can be incorporated in many existing algorithms and pipelines to benefit a wider range of applications.
Methods and resultsWe build the k-ordered FM-index based on ST for the long and repetitive reference from its k-ordered suffix array (k-ordered SA) with only three simple steps: split sort, k-ordered bucket sort, and merging and compression (see Supplementary Materials for more details). In the split sort step, as described in previous literature () but much simplified, extract a sufficiently large set (e.g. n  1000) of suffixes from the reference sequence T by random sampling, and then, in the k-orded bucket sort step, sort the set of suffixes in the lexicographical order with the multikey quicksort and/or the bucket sort. Then use every mth (e.g. m  100) element of the sorted set as splitters to group all suffixes of T into n/m  1 suffix blocks. Suffixes that are bigger than the ith splitter and smaller than the i  1th splitter lexicographically fall in the i  1th suffix block. Note that the relative order of these blocks has to be maintained in the succeeding step. To save memory, only one block is created at a time and the indexes of all the suffixes of the block are stored in secondary storage. Multiple blocks can be processed in parallel to decrease running time when sufficient memory is provided. The values of n and m should be determined according to the maximal memory available. In the merging and compression step, the resulting n/m  1 transformed strings are concatenated in the same order of the suffix blocks and are compressed to form the k-ordered FM-index (i.e. the ST string) including other auxiliary tables (i.e. the C, Occ tables, and a specially designed location table, see below and supplemen tary method for more details). Since biological sequences consist of a relatively small alphabet, the transformed string (T') can be further encoded to save space. Another edge of compressing the BWT string is that the backtracking algorithm (used for searching, see below) can recover multiple nucleotides in reading one single byte and reduce the time calculating positions in searching with the help of some additional lookup tables. To search with the k-ordered FM-index, we basically follow the similar strategy as Torres et al. proposed; however, to save the memory needed for Torres's approach, we construct a lookup table called location table to store the mapping between the index (denoted as i) of T' and the start position of the corresponding suffix (i.e. k-ordered SA) like the text offset table used in fully sorted FM-index (see Supplementary Materials); the key distinction is at that the table is sampled according to the k-ordered SA, instead of i, in an interval of v. In other words, only the suffixes whose start positions in the text are at the multiples of v are stored in the location table. This table can be constructed easily along with the construction of the T' (see Supplementary Materials). With the proposed location table, we can find all the locations within k recursions of enumerating the alphabet (i.e. R  {A, T, C, and G}; see Algorithm 1, 2, 3 and Supplementary Materials). Indeed, the maximum length of each query sequence is restricted to the parameters (i.e. k and v) upon construction, which could be inconvenience; however, since modern short read aligners fragmentize the query into several short 'seeds' and tailor the alignments of each seed against the reference together afterward (), we believe it is not difficult to choose the right combination of parameters to fit the general purpose of fast string searching by the proposed k-ordered FM-index (By default, k is set as 256, and v is 64; maximum query length  192; see Supplementary Materials for more details). We implemented the indexing and searching algorithms of the proposed k-ordered FM-index for both central processing unit (CPU)-only (sBWT) and GPU-accelerated (sBWT-CUDA) architectures. The implementations were fully tested and compared with other available tools in the use of general-purposed read mapping and creating the index of a huge set of reads for de novo assembly. We compared the performance of indexing and searching in simulated genomes using sBWT and sBWT-CUDA with that of two conventional FM-index based aligners (i.e. Bowtie and BWA; We picked Bowtie instead of Bowtie2 for its better performance of short read mapping) and four GPU-accelerated aligners (i.e. CUSHAW (), SOAP3-dp (), BarraCUDA () and nvBWT [nvlabs.github.io/nvbio/). The results showed great time efficiency of sBWT (C). The simplicity of the k-ordered FM index also led to a highly parallelizable GPUacceleration friendly implementation, sBWT-CUDA, which significantly improves the performance of both indexing and searching. To further demonstrate the usefulness of k-ordered FM-index, we used sBWT-CUDA to construct the index for de novo assembly from a subset of a real-life deep sequencing library (SRR065390, see Supplementary Materials for more details). sBWT-CUDA was compared with two other implementations of the FM-Index based indexing algorithms designed specifically for building indexes on a huge set of reads, ropeBWT2 () and nvSetBWT, an implementation based on the CX1 algorithm () (). The results suggest that sBWT-CUDA can have a better overall performance during the entire process of de novo assembly. More details and the parameters used for all tests and all tools can be found in Supplementary Materials. The proposed k-ordered FM-index, location table and the accompanying algorithms are much simpler to implement than the conventional onesa simple bucket sort can do all the tricks; no need to deal with repetition at all (e.g. difference covers sampling (DCS);), see Supplementary Materials). The search space of the novel location table is bounded by O(kjRj), whereas that of the conventional offset table, at worst case, is bounded by O(N). It was somehow unexpected to see the searching of sBWT without any parallelism was faster than other CPU-only tools, but it is possible due to the complexity of their designs for more functionalities such as mapping quality evaluation or information logging. Our innovation can also help the construction of the overlap graph (including finding irreducible edges) used in de novo assembly. Most excitingly, our implementation can create the index for multiple reads of any length. Other tools that designed specifically for the purpose do not scale as good as the proposed methods when the contig length grows along with the assembly. Future applications such as searching within multiple gigabase genomes can be better achieved by our innovations.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
C.H.Chang et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
X 3 2 X 1 X 3 2 X 1 X 3 2 X 1 X 3 2 X Fig. 1. The overview of the performance comparison with other tools. (sBWTC: sBWT-CUDA) (A) Time needed for indexing genomes with different level of repetition. Five different types of genomes (which are all 80M bp long) were generated and differed in the level of repetition (i.e. 1X, 2X, 4X, 8X, 16X and 32X) and the averages of five repeated measurements are plotted. (B) Time needed for searching in the genomes with 1 and 32 genomes by CPU-only tools and (C) GPU-accelerated tools. (D) The speed of indexing a set of reads relatively to that by sBWT-CUDA. To be comprehensive, we simulated the scenarios of assembling long contigs by creating an array of reads with different length from SRR065390. We generated six different sets of reads, in which reads length are set to 100 (bp), 1k, 2k, 5k, 10k, and finally the length of the entire library. nvSetBWT worked only on 100bp-long reads in our tests. Note that CUSHAW and BarraCUDA do not provide any advancement in indexing, so the comparison with them only focused on searching. Searching by all tools was restricted in exact string matching only. CPU-only implementations (i.e. Bowtie, BWA and sBWT) were tested on a machine with 2.0 G INTEL 24-core CPU and 32G DDR3 memory. GPU-based implementations, namely sBWT-CUDA, SOAP3-dp, nvBWT, CUSHSAW and BarraCUDA, were tested on the same machine with an NVIDIA Tesla C2075 card (1.15G 448-core GPU and 6G GDDR5 memory) installed Memory efficient implementation of the hardware-acceleration-friendly Schindler transform
