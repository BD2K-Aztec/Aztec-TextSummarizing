Motivation: Boolean networks (BNs) are commonly used to model genetic regulatory networks (GRNs). Due to the sensibility of the dynamical behavior to changes in the updating scheme (order in which the nodes of a network update their state values), it is increasingly common to use different updating rules in the modeling of GRNs to better capture an observed biological phenomenon and thus to obtain more realistic models. In Aracena et al. equivalence classes of deterministic update schedules in BNs, that yield exactly the same dynamical behavior of the network, were defined according to a certain label function on the arcs of the interaction digraph defined for each scheme. Thus, the interaction digraph so labeled (update digraphs) encode the non-equivalent schemes. Results: We address the problem of enumerating all non-equivalent deterministic update schedules of a given BN. First, we show that it is an intractable problem in general. To solve it, we first construct an algorithm that determines the set of update digraphs of a BN. For that, we use divide and conquer methodology based on the structural characteristics of the interaction digraph. Next, for each update digraph we determine a scheme associated. This algorithm also works in the case where there is a partial knowledge about the relative order of the updating of the states of the nodes. We exhibit some examples of how the algorithm works on some GRNs published in the literature. Availability and implementation: An executable file of the UpdateLabel algorithm made in Java and the files with the outputs of the algorithms used with the GRNs
IntroductionGene regulation networks (GRNs) consist of interacting genes and gene products, which give rise to complex cell behaviors. Due mainly to the lack of detailed kinetic information and quantitative data, qualitative logical models have been used for a better understanding and simulation of GRNs. Examples of these models are the Boolean networks (BNs), which despite their simplicity are able to capture key dynamical features and predict some activation patterns). Boolean networks were introduced by Stuart Kauffman into model GRNs. The gene expression level, in this case, is modeled by binary values, 1 or 0, indicating two transcriptional states, either active or inactive, respectively, and this level changes in time according to some local activation function which depends on the states of a set of nodes (genes or gene products). The interactions between the elements of a BN is represented by a directed graph (digraph), named interaction digraph, where there is an arc (i, j) in the interaction digraph if the state value of the node j depends on the state value of the node i. The dynamics of the network, is governed by an update schedule which determines when each node has to be updated. In the original model, the updating scheme was considered to be synchronous, that is at each time step, the state of all nodes is updated at the same time. Some examples of GRNs modeled by synchronous Boolean networks are exhibited in. However, due to the synchronous scheme is considered not being very realistic many GRN modelers have used other update schedules with different levels of asynchronism (). The difficulty of determining time delays of updating in a GRN makes modelers often sample different update schedules to better capture an observed biological phenomenon. In this context, some used schemes are the deterministic update schedules, where the set of nodes of a network is partitioned into blocks, which are updated sequentially while within the blocks, the nodes are updated synchronously in every time step, (see for example). This family of update schedules, introduced by F. Robert in, includes the sequential schedules (each group has size one), the parallel schedule (there is only one group) and the block-sequential schedules. In the past, a lot of analytical work has been done about the dynamical behavior of BNs with this kind of scheme (). In BNs with deterministic update schedules the relative order of updating of two nodes interacting can be represented by a label on the respective arc of the interaction digraph. More precisely, we put on the arc (i, j) the label  if the node i is updated after or at the same time than j, according to a given update schedule of the network, and the label I otherwise. The interaction digraph of a BN labeled in this way is called update digraph (). In this paper we also deal with deterministic update schedules which are not fully defined, that is, the relative order of updating for some pairs of nodes is unknown. In such cases we put on the corresponding arcs the label L. Inwas proved that given a BN with two different deterministic update schedules, if the schemes have the same update digraph associated, then the dynamical behaviors of the networks under these schemes are equal. Hence, equivalence classes of deterministic update schedules in a given BN can be defined according to the update digraph associated, and such that two equivalent schemes yield exactly the same dynamical behavior of the network. Thus, in order to know the different dynamical behaviors of a BN (for example to study the robustness of the dynamics against to changes in the updating scheme), modelers of GNRs need to test only non-equivalent update schedules, being this set of schemes usually much smaller than the total set (see Supplementary information and). Similarly, if someone wants to determine the dynamics of a BN with updating schemes that are compatible with a set of constraints (on the relative order of updating of some pairs of nodes) then it is sufficient to test the non-equivalent extensions of this update schedule partially defined; this is useful, for example, when there are constraints that come from wanting to keep some dynamical property of a BN. In this way, two important problems to solve are determining all non-equivalent deterministic update schedules of a BN and the nonequivalent extensions of an updating scheme partially defined. In this paper, we address both problems and construct efficient algorithms to solve them. For that, we first build algorithms that determine the update digraphs associated to a given BN, which encoding the non-equivalent updates schedules. Next, we use the algorithm introduced in, and shown in Supplementary information, to determine in polynomial time a scheme associated to each found update digraph and hence to enumerate all nonequivalent update schedules of the network. The algorithms designed to calculate the update digraphs associated to a BN use two strategies. The first one is to avoid infeasible solutions using a polynomial algorithm. The second one is to make use of the structural characteristics of the digraph of interaction associated to a BN, as the presence of bridges, to divide the problem into subproblems, with smaller instances, which can be solved independently and whose solutions can be combined to determine the general solution. This procedure significantly reduces the total execution time of the main algorithm. As example of application of the constructed algorithms we determined in few seconds the whole set of non-equivalent deterministic schemes of four Boolean models of GRNs published in the literature: Arabidopsis Thaliana regulatory network (), Yeast transcriptional network (), the network for Body segmentation in Drosophila Melanogaster () and Mammalian Cell Cycle network (). Besides, for this latter network we determine the non-equivalent extensions of an update schedule partially defined, whose restrictions are necessary in order to keep the unique limit cycle of the network synchronously updated.
Definitions and notationA Boolean network N  F; s is defined by a finite set V of n elements; n state variables x v 2 f0; 1g; v 2 V; a function F  f v  v2V : f0; 1g n ! f0; 1g n called global activation function, where its component functions f v : f0; 1g n ! f0; 1g are called local activation functions, and an update schedule defined by a function s : V ! f1;. .. ; ng, where s(v)  k means that in each unit of time the state of node v is updated in the kth place (see an example in Supplementary information). An update schedule s is also denoted by s  fv : sv  1gfv : sv  2g    fv : sv  ng. The state values in a Boolean network with update function s are given by x k1 v  f v x lu u : u 2 V, where l u  k if sv su and l u  k  1 if sv > su. Given a digraph G we will denote its set of vertices as V G and its set of arcs as A G. The digraph associated to a function F  f v  v2V , called interaction digraph, is the directed graph G F , where V G F  V and u; v 2 A G F if and only if f v depends on x u , i.e. if there exists x 2 f0; 1g n such that f v x 6  f v x u , with x u different of x only in position u (see an example of an interaction digraph in).
Non-equivalent update schedules in Boolean networksGiven a digraph G a label function is any function lab : A G ! f; ; Lg. We call labeled digraph to G; lab. We denote A  G;lab  fu; v 2 A G jlabu; v  g. Analogously we define A  G;lab and A L G;lab. Given a label function lab, we call support of lab to the set Suplab  A  G;lab [ A  G;lab. The arcs in the support are also called labeled arcs; remaining arcs of G will be called unlabeled arcs. We say that G; lab is fully labeled if Suplab  A G. Otherwise, we say that it is partially labeled (see Example 1 in Supplementary information). The label function f lab : A G ! f;  ; Lg is an extension of lab : A G ! f;  ; Lg if 8a 2 Suplab; f laba  laba. If Sup f lab  A G , we call f lab a full extension. Given a digraph G and a partial label function lab. If laba  L, we define the simple extension lab a , as the function where: 8e 2 A G n fag; lab a e  labe and lab a a  . Analogously, we define the simple extension lab a . Inwas defined the update digraph associated to a BN N  F; s as G F ; lab s ; where lab s is the label function related to the scheme s, that is given by lab s i; j   if si ! sj and lab s i; j   if si < sj. In this way, given any label function lab : A G ! f  ; g, we say that the digraph G; lab is update if there exists s such that G; lab  G; lab s , which can be found in polynomial time using for example the algorithm exhibited inInwe show two labeled digraphs. In (a) it is shown an update digraph. Indeed, for the update schedule s  f3; 4g f5gf1; 2g we have that lab 1  lab s. In (b), the labeled digraph G; lab 2  is not an update digraph. Since otherwise, for any given update schedule s, s3 < s5 < s4 s3, which is a contradiction.In this work we extend the concept of update digraph to partially labeled digraphs. We say that G; lab is an update digraph, if there exists a full extension lab 0 such that G; lab 0  is update (see Example 2 in Supplementary information). We denote by SG; lab the set of full extensions of lab 0 that make G; lab 0  an update digraph. The condition required for a labeled digraph to be an update digraph it is related to the notion of reverse graph defined as follows: Given a labeled digraph G; lab, we define the reverse digraphA GR  fu; vju; v 2 A  G;lab _ v; u 2 A  G;lab g and lab R u; v   if v; u 2 A  G;lab and lab R u; v   otherwise. InIn other words, if there exists a path from v 1 to v n in the reverse digraph.There is a negative reverse path from v 1 to v n , if there exists a path in the reverse digraph that contains a negative arc. Inthe path marked by the gray arrows is a reverse path from 6 to 5. This is also a negative reverse path, because the arc (3, 2) is on the sequence. A forbidden cycle is a negative reverse path v 1 ; v 2 ;. .. ; v n  where v 1  v n (see an example in, where the forbidden cycle is defined by the gray arrows). It was proved in Aracena et al.(2011) that a labeled digraph is an update digraph if and only if there does not exist any forbidden cycle.
Complexity of update digraph extension problemIn this article we are interested in finding a set of non-equivalent deterministic update schedules satisfying some constraints (if any) about the relative order of updating of some nodes of a BN or equivalently the extensions of a partially labeled digraph (eventually with empty support) that are update digraphs. More precisely, we address the following problem:Update digraph extension (UDE):Given a labeled digraph G; lab, find the set SG; lab of all full extensions lab 0 of lab such that G; lab 0  is an update digraph. To know the computational complexity of the UDE problem, we study the following counting problem associated to UDE: Counting update digraph extensions (CUDE):Given G; lab a labeled digraph, determine the number of all full extensions lab 0 of lab such that G; lab 0  is an update digraph. We will prove that CUDE is a difficult problem, thereby we can conclude the complexity of the UDE problem.The proof (see Supplementary information) is based on the idea that an acyclic labeled digraph is an update digraph if and only if its reverse digraph is acyclic. This is because in the reverse digraph of an update digraph the only allowed cycles have every arc labeled as positive. In this way, it is easy to define a bijection between an update digraph and the acyclic orientation of its underlaying graph. Note that previous result tell us that the enumeration of all extensions from a partially labeled digraph is a hard problem, whilewhere the gray arrows form a forbidden cycle the related existence problem is known to be polynomial ().
AlgorithmsIn this section we present the theoretical results that lead to design an algorithm that solves the UDE problem. In first place, we focus on verify the existence of one solution, then we reduce our problem contracting each positive strongly connected component (i.e. strongly connected component in the digraph induced by the positive arcs of the labeled digraph) in one vertex. In second place, we present the two main results of this article: they are the effect of forcing arcs, that allows to eliminate infeasible solutions in polynomial time, and the division of our problem into smaller pieces using algorithms to find bridges and strongly connected components.
VerifyFirst, we verify whether the labeled digraph is an update digraph. To check this, we use the ReversePaths algorithm to search any forbidden cycle. ReversePaths algorithm is an adaptation of Floyd Warshall algorithm, where instead of finding minimum weight paths, we determine the existence of reverse paths and negative reverse paths between each pair of vertices. The algorithm returns the matrix M where: Mu; v  1 if there exists a negative reverse path from u to v; Mu; v  1 if there is a reverse path from u to v, but not a negative one and Mu; v  1 otherwise. See details of ReversePaths and Verify algorithms in Supplementary information.
Reducing the size of the instances of UDE problemAs we mentioned above, the UDE problem belongs to a class of problems for which there are not known polynomial algorithms that solve them. Hence, the decrease in size of an instance of UDE problem is very important. In this way, we define the reduced digraph of an update digraph which involves replacing each positive strongly connected by a single vertex. The following lemma is a property of the update digraphs which allows to define correctly the reduced digraph of an update digraph.Let G; lab be an update digraph, G 1 and G 2 two positive strongly connected components of G, and f lab a full extension such that G; f lab is a fully labeled update digraph. ThenThe proof of this lemma (detailed in Supplementary information) uses the fact that if f laba 6  f laba 0  then there exists a forbidden cycle in the labeled digraph. From the previous lemma we know that we can preliminarily label some arcs. This help us to avoid a multidigraph when we obtain the reduced digraph or problems in its label function.Furthermore, lab rd v i ; v j   labu; v, if 9u; v 2 V Gi  V Gj  \Suplab and lab rd v i ; v j   L otherwise. We say that a labeled digraph G; lab is reduced if G; lab  RG; lab. Note that if G; lab is connected, then obviously RG; lab is also connected. Furthermore, as G; lab is an update digraph, then RG; lab is an update digraph, since otherwise there would be a forbidden cycle.Example 2: Inan example of a reduced digraph is shown. The nodes 4, 5 and 6 are in a positive strongly connected component, so in the reduced digraph they are all represented by node v 4 .
Theorem 3:The elements of the solution set of the UDE problem for G; lab are in bijection with those of the UDE problem for RG; lab.The proof of this theorem uses the previous lemma (details in Supplementary information). In fact, if we have an unlabeled arc between nodes in the same positive strongly connected component, this must be labeled positive to avoid a forbidden cycle. In terms of update schedule, that means that every node in the positive strongly connected component is updated at the same time, so we can represent all these nodes in one. Also, the arcs between different positive strongly connected components must have the same direction in the reverse digraph to avoid forbidden cycles, hence we can represent all of them by just one that has the right direction in the reverse digraph. The application of this results leads to Algorithm 1. In this algorithm we use SCC  , i.e. the algorithm that returns the positive strongly connected components of a digraph. This is very easy to construct using, for example, Tarjan algorithm ().3: A G rd ; 4: for i  1 to k do 5: for j  1 to k do 6: if 9u; v 2 A G with u 2 V Gi and v 2 V Gj then 7:
ForceGiven an update digraph G; lab with Suplab 6  A G , there are situations in which an unlabeled arc i; j 2 A G may be labeled just in one way to keep the update digraph property. In fact, if every unlabeled arc is forced to have a unique label the solutions of the UDE problem is unique.In Figure 5a we see that there exist negative reverse paths (marked for gray arrows) from 3 to 2 (3,1,2) and from 2 to 4 (2,4), then the unlabeled arcs (2,3) and (2,4) must be labeled negative and positive respectively, as shown in b.The fact that there exists an unlabeled arc forced to have an unique label, called simply forced arc, depends only on the existence of reverse and negative reverse paths in the interaction digraph as shown in the following proposition.1. For all i; j 2 A G there exists a negative reverse path from j to i if and only if G; lab i;j  is a nonupdate digraph; then we say that the arc (i, j) is forced to be negative. 2. For all i; j 2 A G there exists a reverse path from i to j if and only if G; lab i;j   is a nonupdate digraph; then we say that the arc (i, j) is forced to be positive. Proof: We will prove the first case, the second one is analogous.()) If we consider that there exists a negative reverse path from j to i, then if we label (i, j) positive, there will be a negative reverse path (forbidden cycle) from j to j. Hence, G; lab i;j is a nonupdate digraph. (() If G; lab i;j is a nonupdate digraph and G; lab is, then a forbidden cycle is produced by labeling positive the arc (i, j). Hence there exists a negative reverse path from j to i in G; lab. n It is important to observe that the order in which the forced arcs are chosen to be labeled is irrelevant in the label obtained. Because, the labeling of forced arcs does not give us additional information in terms of reverse and negative reverse paths in the interaction digraph. Indeed, if there exists a negative reverse path from j to i we label negative the forced arc (i, j), i.e. we add a new negative reverse path from j to i. Analogously, if there is a reverse path from i to j in the interaction digraph, we label (i, j) positive, i.e. we add a new reverse path from i to j. To check the existence of forced arcs allows to avoid extensions that are not update schedules. Hence, we build Algorithm 2 that labels all the forced arcs. Applying this algorithm to an update digraph we obtain the maximal extension, which is the extension of G such that every forced arc is labeled.Next, we introduce a simple algorithm that name SimpleLabel, to find all the extensions of a given partially labeled update digraph and which uses Force algorithm. Firstly, this algorithm finds the maximal extension of the given label function. Thereafter, the algorithm labels an unlabeled arc positive and recursively calls itself. In this way, it finds all the solutions with this arc labeled positive, then it repeats the procedure labeling the arc negative. Finally the total solution is the union of both solution sets (see Algorithm 3).
Algorithm 3 SimpleLabelRequire: An update digraph G; lab Ensure: The set SG; lab denoted by S and its cardinal r : jSj 1: S; r ;; 0 2: lab ForceG; lab 3: if Suplab  AG then 4: return lab; 1 5: else 6: Let be a 2 AG n Suplab 7:
Divide and conquerIn order to improve the efficiency of the SimpleLabel algorithm, we use structural properties of the digraph to divide the problem into subproblems, by partitioning the arc set, such that their combined solutions give us the solution of the original problem. To formalize this combination of solutions we define the operator .Given a digraph G; fA i g k i1 a partition of A G and fL i g k i1 a family of label functions such that for every i 2 f1;. .. ; kg; L i flabjlab : A i ! f;  ; LgisalabelfunctionofGg, we define:The following result is directly obtained from the previous definition.
Division by bridgesThe first division is to separate nodes joined by a bridge in the underlying graph (i.e. the graph obtained by replacing all directed edges of G with undirected edges). This idea comes from the fact that any forbidden cycle cannot contain any bridge.The proof of this proposition is detailed in Supplementary information. Inwe can see an example of division by bridges of a labeled digraph with the associated partition of the arc set.and (2, 4) are forced to be negative and positive, respectively. The gray arrows define reverse paths. (b) G; f lab  is the maximal extension of G; lab
Division by strongly connected componentsAnother way to simplify the digraph consists in divide it by its strongly connected components in the extended reverse digraph, i.e. the reverse digraph where unlabeled arcs are replaced by unlabeled arcs in both directions. As in the case of bridges, forbidden cycles cannot use arcs connecting different strongly connected components.Let G; lab be an update digraph with G 1 ;. .. ; G k its strongly connected components of the extended reverse digraph, we define the set of arcs:which it is composed by the arcs between strongly connected components of the extended reverse digraph of G; lab. Then,where 8i 2 f1;. .. ; kg; e G i  GV Gi . Inwe can see an example of division by strongly connected components of an update digraph with the associated partition of the arc set. The proof of this last proposition is similar to that of the Proposition 6 shown in Supplementary information, and is based on the fact that (G, lab) is an update digraph if and only if every labeledNext we define the Algorithm 4, called Label, that requires as input an update digraph with a label function without forced arcs, and which uses the divisions defined above to partition our problem. It applies the same ideas of SimpleLabel, i.e. to force arcs, label one and apply recursively the same algorithm.
Algorithm 4 LabelRequire: G; lab, a maximal extension of an update digraph. Ensure: The set SG; lab denote by S and its cardinal number r : jSj 1: S; r ;; 1 2:Finally, we present the main algorithm, to solve the UDE problem, named UpdateLabel, which first checks if the labeled digraph (G, lab) received as input is an update digraph, i.e. if SG; lab 6  ; (see Algorithm 5).
Comparison of algorithms with and without divisionsTo illustrate the efficiency of doing divisions in the main algorithm we compare the performance of our algorithm Label against SimpleLabel algorithm that only uses the idea of forced arcs. As the algorithms require an update digraph as input, we use UpdateLabel algorithm to call both. The tests were run in complete digraphs and chains (see) of different sizes and with empty supports in a laptop with Processor: 2.4 GHz Intel Core i5, RAM memory: 8 GB 1600 MHz DDR3, operating system: OS X 10.9.5. Inwe can see as the main algorithm with Label runs (column Label) faster than with SimpleLabel (column SimpleL), even in the case of complete digraphs where there is a small number of divisions. However, when the number of solutions (i.e. jSG; labj) is big it is convenient to use SimpleLabel instead of Label, because the latter uses a lot of RAM memory (see for example the case of K 9 ). It is important to mention that the times listed in columns SimpleL and Label ofcorrespond to the runtimes of the implementation of UpdateLabel algorithm available at www.inf.udec.cl/$lilian/UDE/ with output the list of non-equivalent schemes associated to the update digraphs of S(G, lab). In the cases of columns Coded and Count, they correspond to the implementation with output S(G, lab) and jSG; labj respectively.
Algorithm 5 UpdateLabelRequire: A labeled digraph G; lab Ensure: The set SG; lab denote by S and its cardinal number r : jSG; labj. 1: if VerifyG; lab  false then 2: return ;; 0 3: else 4: G rd ; lab rd  ReduceG; lab 5: f labNon-equivalent update schedules in Boolean networks
Application to genetic regulatory networksWe apply our algorithm UpdateLabel to enumerate the non-equivalent deterministic update schedules of four Boolean models of GRNs published in the literature: Mammalian Cell Cycle network (), Arabidopsis Thaliana regulatory network (S nchez), Yeast transcriptional network () and the network for body segmentation in Drosophila Melanogaster (), also studied in (Marques). The mammalian cell cycle network has 10 nodes and 31 arcs. A detailed description of the network can be found in Supplementary information. For this network we used the implementation of UpdateLabel algorithm available at www.inf.udec.cl/$lilian/UDE/ without divisions and with divisions to enumerate all non-equivalent deterministic update schedules of the network (row Mammalian1 of) and those that are extensions of the partially labeled interaction digraph shown in Supplementary information, and corresponding to label eight arcs of the network as positive, in order to preserve the limit cycle C of the synchronous dynamical behavior also specified in Supplementary information (row Mammalian2 of). The times listed incorrespond to the same of those specified in. It is important to observe that the quantities 466712 and 1440 represent an upper bound for the total number of different dynamics and for the number of possible dynamics exhibiting the limit cycle C, of the mammalian cell cycle network with deterministic update schedules, respectively. Besides, these number are much less than the total number of deterministic update schedules for the network, which it is approximately 1  10 8 (see Supplementary information). We also applied the implementation of the algorithms to the other mentioned networks labeling some arcs as negative when the 'head' vertex of the arc has associated a constant function as local activation function. The corresponding partially labeled interaction digraphs are shown in Supplementary information. In the case of Arabidopsis Thaliana we only use SimpleLabel algorithm because the size is too big to process in RAM Memory. The results obtained are shown in
DiscussionThe problem of testing different deterministic update schedules of a BN modeling a GRN, for example to better capture an observed biological phenomenon or to study the robustness of the dynamics against to changes in the updating scheme, is reduced to use only nonequivalent schemes. This set, defined according to the update digraphs associated to a network, can be much smaller than the total set of schemes (Supplementary information and). In this article we addressed the problems of determining all non-equivalent deterministic update schedules of a BN and the non-equivalent extensions of an updating scheme partially defined. To solve them, we first construct an algorithm, named UpdateLabel, determining the label functions on the arcs of the interaction digraph of a BN that have an update schedule associated (i.e. the set of update digraphs of a BN). The UpdateLabel algorithm uses two major ideas in its design. The first one is the base of the Force algorithm, which in polynomial time checks whether the given labels on some arcs uniquely determine the label in others (only possible extension), allowing to eliminate infeasible solutions in polynomial time. The second one is to make use of the structural characteristics of the interaction digraph associated to a BN, as the presence of bridges, to divide the problem into subproblems, with smaller instances, which can be solved independently and whose solutions can be combined to determine the general solution. This procedure significantly reduces the total execution time of the main algorithm as observed in. Next, for each update digraph found with UpdateLabel algorithm we determine an update schedule scheme belonging to the class, by using a polynomial algorithm. Results obtained when the main algorithm is used with and without divisions on some digraphs K n and P n. Here, jV j and j Aj denote the number of nodes and arcs of each digraph, respectivelyshow that in few seconds we can obtain the whole set of non-equivalent update schedules of each studied network, whose cardinals correspond to the maximum number of possible dynamical behaviors of the studied networks when they are modeled by BNs with deterministic update schedules. It is important to note that despite the UpdateLabel algorithm with divisions on the interaction digraph is faster, it is limited by the RAM memory of the computer. So for large networks is advisable to use simply the UpdateLabel algorithm without division, when the number of non-equivalent schemes so allows.
FundingThis work was partially supported by project Fondecyt 1131013 (J.A. and L.S.) and Master's scholarship CONICYT (E.P.). Conflict of Interest: none declared.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
E.Palma et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
