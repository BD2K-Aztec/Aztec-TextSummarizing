Motivation: Haplotype assembly is the computational problem of reconstructing haplotypes in dip-loid organisms and is of fundamental importance for characterizing the effects of single-nucleotide polymorphisms on the expression of phenotypic traits. Haplotype assembly highly benefits from the advent of 'future-generation' sequencing technologies and their capability to produce long reads at increasing coverage. Existing methods are not able to deal with such data in a fully satisfactory way, either because accuracy or performances degrade as read length and sequencing coverage increase or because they are based on restrictive assumptions. Results: By exploiting a feature of future-generation technologies—the uniform distribution of sequencing errors—we designed an exact algorithm, called HAPCOL, that is exponential in the maximum number of corrections for each single-nucleotide polymorphism position and that minimizes the overall error-correction score. We performed an experimental analysis, comparing HAPCOL with the current state-of-the-art combinatorial methods both on real and simulated data. On a standard benchmark of real data, we show that HAPCOL is competitive with state-of-the-art methods, improving the accuracy and the number of phased positions. Furthermore, experiments on realistically simulated data-sets revealed that HAPCOL requires significantly less computing resources, especially memory. Thanks to its computational efficiency, HAPCOL can overcome the limits of previous approaches, allowing to phase datasets with higher coverage and without the traditional all-heterozygous assumption.
IntroductionDiploid organisms such as humans contain two sets of chromosomes, one from each parent. Reconstructing the two distinct copies of each chromosome, called haplotypes, is crucial for characterizing the genome of an individual. The process is known as phasing or haplotyping and the provided information may be of fundamental importance for many applications, such as analyzing the relationships between genetic variation and gene function, or between genetic variation and disease susceptibility (). In diploid species, haplotyping requires V C The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com assigning the variants to the two parental copies of each chromosome, which exhibit differences in terms of single-nucleotide polymorphisms (SNPs). Since a large scale direct experimental reconstruction of the haplotypes from the collected samples is not yet cost-effective (), a computational approachcalled haplotype assemblythat considers a set of reads, each one sequenced from a chromosome copy, has been proposed. Reads (also called fragments) have to be assigned to the unknown haplotypes, using a reference genome in a preliminary mapping phase, if available. This involves dealing in some way with sequencing and mapping errors and leads to a computational task that is generally modelled as an optimization problem (). Minimum error correction (MEC) () is one of the prominent combinatorial approaches for haplotype assembly. It aims at correcting the input data with the minimum number of corrections to the SNP values, such that the resulting reads can be unambiguously partitioned into two sets, each one identifying a haplotype. wMEC () is the weighted variant of the problem, where each possible correction is associated with a weight that represents the confidence degree assigned to that SNP value at the corresponding position. This confidence degree is a combination of the probability that an error occurred during sequencing (phred-based error probability) for that base call and of the confidence of the read mapping to that genome position. The usage of such weights has been experimentally validated as a powerful way to improve accuracy (). Haplotype assembly benefits from technological developments in genome sequencing. In fact, the advent of next-generation sequencing (NGS) technologies provided a cost-effective way of assembling the genome of diploid organisms. However, to assemble accurate haplotypes, it is necessary to have reads that are long enough to span several different heterozygous positions (). This kind of data is becoming increasingly available with the advent of 'future-generation' sequencing technologies such as single molecule real-time technologies like PacBio RS II (http:// www.pacificbiosciences.com/products/) and Oxford Nanopore flow cell technologies like MinION (https://www.nanoporetech.com/). These technologies, thanks to their ability of producing single end reads longer than 10 000 bases, eliminate the need of paired-end data and have already been used for tasks like genome finishing and haplotype assembly (). Besides read length, the future-generation sequencing technologies produce fragments with novel features, such as the uniform distribution of sequencing errors, that are not properly addressed (or exploited) in most of the existing methods that, instead, are tailored to the characteristics of traditional NGS technologies. Recently, MEC and wMEC approaches have been used in the context of long reads, confirming that long fragments allow to assemble haplotypes more accurately than traditional short reads (). Since MEC is NP-hard (), exact solutions have exponential complexity. Different approaches tackling the computational hardness of the problem have been proposed in literature. Integer linear programming techniques have been recently used (), but the approach failed to optimally solve some 'difficult blocks'. There were also proposed fixedparameter tractable (FPT) algorithms that take time exponential in the number of variants per read () and, hence, are well-suited for short reads but become unfeasible for long reads. For this kind of data, heuristic approaches have been proposed to respond to the lack of exact solutions (). Most of the proposed heuristics, such as REFHAP (), make use of the traditional all-heterozygous assumption, that forces the heterozygosity of all the phased positions. These heuristics have good performances but do not offer guarantees on the optimality of the returned solution (). Two recent articles () aim at processing future-generation long reads by introducing algorithms exponential in the sequencing coverage, a parameter which is not expected to grow as fast as read length with the advent of future-generation technologies. The first algorithm, called PROBHAP (), is a probabilistic dynamic programming algorithm that optimizes a likelihood function generalizing the objective function of MEC. Albeit PROBHAP is significantly slower than the previous heuristics, it obtained a noticeable improvement in accuracy. The second approach, called WHATSHAP (), is the first exact algorithm for wMEC that is able to process long reads. It was shown to be able to obtain a good accuracy on simulated data of long reads at coverages up to 20 and to outperforms all the previous exact approaches. However, it cannot handle coverages higher than 20, and its performance evidently decreases when approaching that limit. In this article, we exploit a characteristic of future-generation technologies, namely the uniform distribution of sequencing errors, for introducing (Section 2) an exact FPT algorithm for a new variant, called k-cMEC, of the wMEC problem where the parameters are (i) the maximum number k of corrections that are allowed on each SNP position and (ii) the coverage. The new algorithm, called HAPCOL, is based on a characterization of feasible solutions given inand its time complexity is Ocov k1 Lm (albeit it is possible to prove a stricter bound), where cov is the maximum coverage, L is the read length and m is the number of SNP positions. HAPCOL is able to work without the all-heterozygous assumption. In Section 3, we experimentally compare accuracy and performance of HAPCOL on real and realistically simulated datasets with three state-of-the-art approaches for haplotype assemblyREFHAP, PROBHAP and WHATSHAP. On a real standard benchmark of long reads (), we executed each tool under the all-heterozygous assumption, since this dataset has low coverage ($3 on average) and since the covered positions are heterozygous with high confidence. HAPCOL turns out to be competitive with the considered methods, improving the accuracy and the number of phased positions. We also assessed accuracy and performance of HAPCOL on a large collection of realistically simulated datasets reflecting the characteristics of 'future-generation' sequencing technologies that are currently (or soon) available (coverage up to 25, read length from 10000 to 50 000 bases, substitution error rate up to 5% and indel rate equal to 10%) (). When considering higher coverages, interesting applications such as SNP calling or heterozygous SNPs validation become feasible and reliable (). Since these applications require that haplotypes are reconstructed without the all-heterozygous assumption, on the simulated datasets we only considered the tools that do not rely on this assumptionWHATSHAP and HAPCOL. Results on the simulated datasets with coverage 1520 show that HAPCOL, while being as accurate as WHATSHAP (they achieve an average error of $2%), is faster and significantly more memory efficient ($2 times faster and $28 times less memory). The efficiency of HAPCOL allows to further improve accuracy. Indeed, the experimental results show that HAPCOL is able to process datasets with coverage 25 on standard workstations/ small servers (whereas WHATSHAP exhausted all the available memory, 256 GB) and that, since the number of ambiguous/uncalled positions decreases, the haplotypes reconstructed by HAPCOL at coverage 25 are $9% more accurate than those reconstructed at coverage 20.
Methods
Preliminary definitionsLet s be a vector. Then, we denote the value of s at position t by st. A haplotype is a vector h of length m belonging to f0; 1g m. Let h 1 , h 2 be the two haplotypes of an individual. A position j is called heterozygous if h 1  j 6  h 2  j, otherwise (i.e. if h 1  j  h 2  j) j is called homozygous. A fragment is a vector f of length m belonging to f0; 1; g m. In a fragment f, a position f j   is called a hole. A gap in a fragment f is a maximal sub-vector of f of holes, preceded and followed by a non-hole element. Moreover, the length of a fragment f is defined as the number of elements contained in f between the leftmost and rightmost non-hole elements (included). A fragment matrix is a matrix M consisting of n rows (fragments) and m columns (SNPs). We indicate as L the maximum length for all the fragments i in M. We denote by M j the jth column of M. Notice that each column of M is a vector in f0; 1; g n , while each row is a vector in f0; 1; g m. Given two row vectors s 1 and s 2 belonging to f0; 1; g m , s 1 and s 2 are in conflict when there exists a position j, with 1 j m, such that s 1 j 6  s 2 j and s 1 j; s 2 j 6  , otherwise s 1 and s 2 are in agreement. A fragment matrix M is conflict free if and only if there exist two haplotypes h 1 , h 2 such that each row of M is in agreement with one of h 1 and h 2. In an equivalent way, a fragment matrix M is conflict free if and only if there exists a bipartition (P 1 , P 2 ) of the fragments in M such that each pair of fragments in P 1 is in agreement and each pair of fragments in P 2 is in agreement. A correction of the entry M j i, where M j i 6  , is a flip of the value of M j i. Now we are able to introduce the MEC problem.Problem 1. MEC () Input: a matrix M of fragments. Output: a conflict free matrix M 0 obtained from M with the minimum number of corrections. A column of a matrix is called homozygous if it contains values in f0; g or in f1; g, otherwise it is called heterozygous. We say that a fragment i is active on a column M j , if M j i  0 or M j i  1. The active fragments of a column M j are the set activeM j   fi : M j i 6  g. The coverage of the column M j is defined as the number cov j of fragments that are active on M j , that is cov j  jactiveM j j. In the following, we indicate as cov the maximum coverage over all the columns in M. Given two columns M j1 and M j2 , we denote by activeM j1 ; M j2  the intersection activeM j1  \ activeM j2 . Notice that on the one hand, any heterozygous column M j encodes a bipartition of the fragments in activeM j  indicating which one belongs to h 1 and which one belongs to h 2. On the other hand, any homozygous column M j does not encode a specific bipartition and, since it gives no information on how its active fragments have to be partitioned, it is 'in accordance' with any other bipartition or heterozygous column.
Definition 1:Two columns M j1 ; M j2 of a fragment matrix M are in accordance if (1) at least one of M j1 ; M j2 is homozygous or (2) M j1 ; M j2 are both heterozygous and on activeM j1 ; M j2  they are identical or complementary.The correction distance between two columns M j1 ; M j2 evaluates the minimum number of corrections needed to transform M j1 and M j2 into heterozygous columns in accordance and it is defined as dM j1 ; M j2   minfjEj; jEjg, where E  fi : M j1 i 6  M j2 i^ M j1 i 6   ^ M j2 i 6  g and E  fi : M j1 i  M j2 i ^ M j1 i 6   ^ M j2 i 6  g. Given a column M j of a fragment matrix M, we define the homozygous distance HM j  as the number of times the minor allele (i.e. the least frequent value of the column) appears in M j if it is not greater than an integer k, or infinity otherwise. More formally, HM j  is equal to dM j ; 0 if dM j ; 0 k (notice that dM j ; 1  dM j ; 0, where 0 and 1 are the columns composed only of zeros and ones, respectively) or to 1 otherwise. Homozygous columns cannot induce a conflict due to the fact that the corresponding positions in the two reconstructed haplotypes can be homozygous with no influence on the other positions. For this reason, we can remove every homozygous column from any input fragment matrix M without changing the optimal solution and we can assume that M is only composed of heterozygous columns. However, notice that a heterozygous column M j in the input can be transformed into a homozygous column M 0 j in the output. As a consequence, the optimal solution M 0 can potentially contain homozygous columns. Furthermore, given a conflict free matrix M 0 , notice that the two resulting haplotypes h 1 , h 2 can be easily computed from the bipartition of the fragments induced by the columns of M 0. In the weighted variant wMEC of MEC, there is a weight wM j i associated with each non-hole entry M j i of the input matrix M that represents the cost of correcting that entry. In this case, the goal is to minimize the total weight instead of the number of corrections. Each gap in any fragment of the input matrix M can be modeled as zero-weight entries equal to 0 or 1. For this reason, even though we propose an approach that considers fragment matrices without gaps, called gapless fragment matrices, the approach can be easily extended to deal with any general fragment matrix M. Lemma 1 () proves a property of these matrices that will be fundamental for our FPT algorithm.Consider a gapless fragment matrix M. Then, M is conflict free if and only if each pair of columns is in accordance.
The k-constrained MEC problemIn this work, we introduce a variant of the MEC problem, called k-cMEC, motivated by the uniform distribution of sequencing errors of future-generation technologies, where the number of errors (hence, corrections) per column are bounded by an integer k. Given an input fragment matrix M, a conflict free fragment matrix M 0 obtained from M with h corrections is defined as a k-corrected matrix for M if for each column M j we have dM j ; M 0 j  k. According to this definition we introduce the following variant of MEC:Problem 2. k-constrained MEC (k-cMEC) Input: a fragment matrix M and an integer k. Output: a k-corrected matrix M 0 for M obtained with the minimum number of corrections.Given a k-corrected matrix M 0 for a fragment matrix M, we can see each heterozygous column M 0 j in M 0 as the correction of the corresponding column M j in M. Hence, considering a column M j , we define a k-correction B j for M j as a vector in f0; 1; g n with activeB j   activeM j  such that dM j ; B j  k and B j is heterozygous. According to this definition, a k-correction B j describes a feasible way to transform M j into the heterozygous column M 0 j when dM 0 j ; B j   0. Therefore, we define the space of these corrections as b j , such that b j is the set containing all the possible k-corrections B j for the column M j. Notice that 0 and 1 can be imagined as the corrections for any homozygous column in M 0. The weighted variant of this problem can be easily defined in the same way as wMEC for MEC. The goal of the weighted version is to compute a k-corrected matrix M 0 obtained from M with minimum total weight. Consider a fragment matrix M. There always exists a feasible solution for the MEC problem on input M, while a feasible solution for the k-cMEC problem, for a fixed k, on input M may not exist. This implies that a feasible solution for the MEC problem on input M may not be a feasible solution for the k-cMEC problem. Hence, an optimal solution for the k-cMEC problem is not necessarily an optimal solution for the MEC problem.
AlgorithmIn this section, we present an FPT algorithm for solving the k-cMEC problem, when parameterized by the maximum number k of corrections that are allowed in each column and by the coverage cov. The algorithm is based on an exact dynamic programming approach. After presenting the basic dynamic programming equation for the gapless case, we show that the approach can be easily adapted to manage gaps and, possibly, the all-heterozygous assumption. Informally, the algorithm iteratively computes, for all j from 1 to m, a k-corrected matrix M 0 on the first j columns M 1 ;. .. ; M j of the input matrix M by considering all the possible corrections M 0 j for the last column M j such that dM j ; M 0 j  k and choosing the best option. The corrected column M 0 j can be either homozygous or heterozygous. If it is homozygous, we pay a cost equal to the homozygous distance HM j  of M j but then M 0 j is in accordance with any other column and no other check must be performed. If M 0 j is heterozygous, then we consider all the possible k-corrections B j for M j in b j and for each one two different cases may arise: (i) there exists a column M q with q < j that 'shares' some fragments with M j and that in the optimal solution M 0 q is heterozygous (clearly, q ! j  L) or (ii) all the previous columns that share some fragments with M j are homozygous in the optimal solution M 0. In the first case, M 0 q and M 0 j must be either identical or complementary on the shared fragments (Lemma 1). It follows that we have to choose the best option among all the k-corrections B q such that dB q ; B j   0 and we pay a cost equal to that of the correction B j (i.e. dM j ; B j ) plus the cost of transforming the columns between M q and M j into homozygous columns (i.e. their homozygous distance). In the second case, all the columns to the left of M j that share some fragment with M j are homozygous in the optimal solution M 0 (and we pay a total cost equal to their homozygous distance). As a consequence, any k-correction B j of M j is in accordance with them and we pay a cost equal to dM j ; B j . More formally, let M be a fragment matrix and B j be a k-correction for M j , we define Dj; B j  as the minimum number of corrections needed to obtain a k-corrected matrix M 0 for M on columns M 1 ;. .. ; M j such that M 0 j is heterozygous and dM 0 j ; B j   0. Moreover, we define OPTj as the minimum number of corrections needed to obtain a k-corrected M 0 for M on columns M 1 ;. .. ; M j. Finally, we define M Lj (M Rj , respectively) as the rightmost (leftmost, respectively) column to the left (right, respectively) of M j such that activeM Lj ; M j   / (activeM Rj ; M j   /, respectively); if it does not exist, M Lj (M Rj , respectively) corresponds to an empty column in position 0 (m  1, respectively). Note that j  L j L and R j  j L.Without loss of generality, we implicitly assume that there exists a dummy empty column M 0 in position 0 of the input M. Thus, we can define OPT0  0 and D0;   0. For 0 < j m; D j; B j  and OPT j can be computed as follows:D j; B j   min min q : Lj  1 q j  1; Bq : dBj; Bq  0 Dq; B q   dM j ; B j  OPT j  min OPTj  1  HM j  ==M j is homozygous min 8Bj Dj; B j  ==M j is heterozygous (The optimum cost is given by OPTm and a corresponding optimal solution M 0 can be reconstructed by backtracking. The formal proof of correctness along with some technical details about the backtracking procedure are in the Supplementary Material. The algorithm can be easily adapted to the weighted version of k-cMEC. In this case, each non-hole element M j i of the input matrix M has a weight wM j i. Given a column M j and any k-correction B j in b j , the key idea is to consider the weight wM j ; B j  as the minimum sum of the weights to transform M j in M 0 j such that dM 0 j ; B j   0 and to consider the weight w H M j  as the minimum sum of weights to transform M j into a homozygous column. Hence, we want to minimize the sum of such weights by replacing dM j ; B j  with wM j ; B j  and HM j  with w H M j  in the recursive equations. Assume to consider a general fragment matrix M that may contain gaps. As explained before, any gap can be modeled as zeroweight elements. Since each of these elements can be equal to 0 or 1 with a cost of 0, we can adapt the algorithm such that for each column all the combinations of values for its gaps will be considered. It follows that any k-correction B j for a column M j is extended with any combination of values for its gaps and added to b j. Furthermore, the algorithm can be slightly modified to find a solution under the all-heterozygous assumption that forces to reconstruct two complementary haplotypes. In this case, the homozygous columns, both in the input and in the output, have to be considered as 'special' heterozygous columns that place all the covered fragments in the same part of the fragments bipartition. Hence, we remove from the recursive equation the possibility to transform each column M j into a homozygous column and we add to b j the k-correction B j that transforms. Let M be a gapless fragment matrix. Given two columns M j1 and M j2 , and a k-correction B j1 for M j1 , we define p j2 B j1  as the vector of size jactiveM j1 ; M j2 j that is obtained from B j1 by keeping only elements that correspond to fragments that are in activeM j1 ; M j2 . We define the intermediate projection table for each column M j , for each q in fL j  1;. .. ; j  1g and for each vector C representing a possible correction of the positions in activeM j ; M q , as follows:~ Dq; j; C  min 8Bq2b q :dC;pjBq0 Dq; B q :Entry ~ Dq; j; p j B q  (and ~ Dq; j; p j B q , where p j B q  is the complement of p j B q ) can be filled in Ocov time [needed to compute p j B q ] while computing Dq; B q  and, consequently, the asymptotic overall time complexity does not change. Intuitively, ~ Dq; j; C corresponds to the minimum number of corrections to obtain a k-corrected matrix M 0 for M on the first q columns such that M 0 q is heterozygous and dC; p j M 0 q   0. As a consequence, Equation(1) can be equivalently rewritten as:In other words, with this recurrence, each entry Dj; B j  is computed using the entries ~ D; j;  and, at the same time, it is used to update the entriesspace, since for any column M j we only consider all the values q in fL j  1;. .. ; j  1g and j  L j L. Therefore, since the algorithm iteratively proceeds column wise, when it is at the step corresponding to the column M j , we just need to consider the entries ~ Dy; ;  for all the columns M y with j y R j. For this reason, we just needspace to store that window of the projection table. Furthermore, if we consider a general fragment matrix M modelling the gaps as zero-weight elements (using the approach described before), the number of k-corrections B j in b j for a column, where g is the maximum number of gaps in a column (hence 2 g is the number of all the combinations of values for gap elements). As a consequence, the overall time complexity becomes space, respectively.
ImplementationA prototypical implementation of HAPCOL is available under the terms of the GPL at http://hapcol.algolab.eu/. Since coverage varies across columns, HAPCOL adaptively adopts a different maximum number k j of corrections for each column M j computed as the smallest integer such that the probability that M j contains more than k j errors is at most a, with a given as input. Such a probability is computed assuming that sequencing errors are uniformly distributed with a substitution error rate (given as input), an assumption which reflects the characteristics of future-generation sequencing technologies. Therefore, the two parameters given in input to HAPCOL are and a and can be chosen by the user depending on the estimated sequencing (substitution) error rate and on the user's preference towards better performances (larger a) or increased probability of finding a feasible solution (smaller a). The strategy currently implemented for choosing the maximum number of corrections per column assumes that errors are uniformly distributed. However, it can be easily modified to process datasets produced by technologies with different error profiles (even those with systematic errors, especially if the average error rate is low, such as current Illumina technologies) and/or to automatically increase the values k j until a feasible solution exists.
The NA12878 datasetThe real dataset (called 'NA12878 dataset') is the one produced using a fosmid-based technology from the HapMap sample NA12878 by. This dataset is considered a standard benchmark for comparing haplotyping algorithms on long reads, since the haplotypes of individual NA12878 were independently and confidently reconstructed using the sequenced genomes of the individual and of her parents. The dataset is composed of 271 184 reads with average length of $40 kb and with average coverage of $3. The reference haplotypes are the trio-phased variant calls from the GATK resource bundle (), filtered on the 1 252 769 positions that are also covered by the fragments of the NA12878 dataset. HAPCOL, REFHAP, PROBHAP and WHATSHAP have been executed independently on each chromosome. HAPCOL and WHATSHAP can be executed with or without the all-heterozygous assumption without affecting the exponential part of their time/space complexities. In this case, these two tools have been executed using the allheterozygous assumption, since the positions covered by the dataset are heterozygous with high confidence and since the comparison between solutions obtained with different assumptions may lead to misleadingresults.Moreover, HAPCOL has been executed with e  5% and a  10 3 and, for this choice of the parameters, a feasible solution existed for each chromosome.reports, for each tool, the overall error rate and the percentage of phased positions over all the phasable positions, the total running time and the peak of memory for the whole dataset (i.e. for all the chromosomes). On this dataset, HAPCOL reconstructed the most accurate haplotypes and phased the largest number of positions compared with the other tools. In particular, HAPCOL improves the accuracy obtained by WHATSHAP, PROBHAP and REFHAP by around 6%, 43% and 48%, respectively. Furthermore, HAPCOL is also the tool which phases the largest number of positions. In fact, HAPCOL phases 0.15% more positions than WHATSHAP, 2.03% more than PROBHAP and 2.18% more than REFHAP. To the contrary, REFHAP was the fastest and most memoryefficient tool among the four considered. This was expected, as REFHAP is a heuristic-based method, while the other ones are exact (albeit they minimize different objective functions). Overall, all the tools can be run with modest/medium computing resources. Indeed, each one analyzed the dataset in less than 25 min and using less than 24 GB of memory. However, while HAPCOL and WHATSHAP concluded in a few minutes, PROBHAP was significantly slower than the others ($20 min) and, possibly, it could not be able to scale to datasets with higher coverage. HAPCOL and WHATSHAP required significantly more memory than PROBHAP and REFHAP (4 times and 44 times, respectively). However, such a peak of memory usage is due to a small number of consecutive positions on chromosomes 2, 3 and 10 where coverage is high (up to 30), but most of values are gaps (all but 2-4 non-gap alleles on average). In these regions, the performances of HAPCOL and WHATSHAP degrade since both approaches model the gaps as zero-weight elements and must essentially 'guess' the alleles at those positions. Clearly, in this case, phase prediction is not reliable and a simple pre-filtering step can easily find (and possibly remove) such positions from further analyses. If we exclude chromosomes 2, 3 and 10, then WHATSHAP becomes the fastest tool (30 s), followed by REFHAP (35 s), by HAPCOL (60 s) and by PROBHAP that remains the slowest tool (956 s). In terms of memory usage, HAPCOL turns out to be the most memory-efficient method (0.06 GB), followed by WHATSHAP (0.16 GB), by PROBHAP (0.48 GB) and by REFHAP (0.54 GB).
Simulated datasetsWe used simulated datasets to assess how accuracy and performances change while the characteristics of the dataset (coverage, especially) vary. As motivated before, in this part we focused on the tools that can work also without the all-heterozygous assumption, namely HAPCOL and WHATSHAP. The simulation of the datasets has been performed as in. The dataset consists of a ground truth, which was assembled by inserting all known variants of chromosomes 1 and 15 of J. Craig Venter's genome into theAccuracy is given in terms of phasing error ('error') and total phased positions ('phased') of the reconstructed haplotypes, while performances are given in terms of total running time ('time') expressed in seconds and the peak memory usage ('mem.') expressed in GB. Best results for each column are highlighted in boldface.The simulated instances have coverage ('cov') 15 and 20, substitution error rate ('e') 1% and 5% and indel error rate fixed to 10%. The metrics considered are the number of instances with feasible solutions ('feas.'), the average phasing error ('error') of the reconstructed haplotypes, the average running time ('time') and the average maximum used memory ('mem.'). HAPCOL has been executed with two different combinations of and a: 5% / 10 2 and 5% / 10 3. human reference genome (hg18), mapped simulated long reads of lengths 1000, 5000, 10 000 and 50 000 bases with varying uniform substitution rates 1% and 5% and with a uniform indel distribution of 10% at 30 coverage. These rates reflect the characteristics of the long read data generated by the future-generation sequencing technologies (). From each set of simulated reads, five datasets were obtained by randomly extracting a maximal subset with (maximum) coverage of 15, 20 and 25. HAPCOL has been executed with two combinations of its input parametersnamely e  5% with a  10 2 , and e  5% with a  10 3 to assess the behavior of HAPCOL depending on the choice of the parameters. We remark that some fragment matrices could not admit a feasible solution for the k-cMEC problem with some choices of parameter k (depending on and a in the implementation), while the same instances have always a feasible solution for the (unconstrained) MEC problem. Both tools have been executed on all the instances, but HAPCOL terminated on some of them because no feasible solution existed for that choice of the input parameters. WHATSHAP, which should be able to find a feasible solution for all the instances, computed a solution only for the instances with coverage 15 and 20, while, as expected (), it was not able to successfully conclude the execution on the instances with coverage 25 since it exhausted the available memory (256 GB).reports, for any combination of input parameters and a, the number of instances with a feasible solution (column 'feas.'), the average error of the reconstructed haplotypes, the average running time and the average memory usage over all the instances of a given chromosome (Venter chromosome 1 and chromosome 15), coverage (15 and 20) and substitution error rate e (1% and 5%) (the indel error rate is fixed to 10%, thus is not reported). The results presented in the table refer only to the subset of instances which have a feasible solution for the k-cMEC problem and are averaged over the read lengths. Since WHATSHAP was not able to successfully terminate on any instance with coverage 25, the results on that subset of instances are separately reported (only for HAPCOL) on. First, as expected, the number of instances with a feasible solution increases as the combination of parameters and a allows more corrections per column. Indeed, for e  5% and a  10 2 , the maximum numbers of corrections per column (not shown) are quite low and, as a consequence, a feasible solution does not exists for many instances, especially for those with high substitution error rates e. For the other combination of parameters (namely, e  5% and a  10 3 ), the number of instances with a feasible solution rapidly increases. This trend, albeit less evident for chromosome 15, is clear for chromosome 1. Noticeably, when e  5% and a  10 3 , a feasible solution exists for all but three instances with coverage at most 20. In terms of accuracy of the reconstructed haplotypes, on all the instances, HAPCOL obtained the same phasing error rate of WHATSHAP, which, in turn, was shown to be competitive with other state-of-the-art approaches (). This observation supports the validity of the newly introduced k-cMEC problem as a computational model for haplotype assembly on long reads. Albeit HAPCOL and WHATSHAP achieve the same accuracy, in terms of performances HAPCOL is both faster and significantly more memory-efficient than WHATSHAP. In particular, on average, HAPCOL is at least twice faster than WHATSHAP when the coverage is 20 even for the largest values of maximum number k j of corrections per column (i.e. when e  5% and a  10 3 ). Moreover, with the same parameters and with read length of 10 000 bases (a typical average read length in the foreseeable future), HAPCOL is almost three times faster than WHATSHAP, allowing to process a single dataset in less than 11 min (on average). Concerning memory usage, we observe the same general trend, except that differences are even more evident. In fact, the average memory usage of WHATSHAP on chromosome 1 (the largest one) at coverage 20 is $138 GB, while HAPCOL requires only $5 GB. Moreover, on instances with read length at most 50 000 bases, WHATSHAP requires up to 164 GB, while HAPCOL never requires more than 10 GB. As a consequence, with HAPCOL, the analysis of a genome-wide dataset at coverage 20 is feasible even on a standard workstation/small server. As noticed before, three instances do not admit a feasible solution with e  5% and a  10 3. However, by setting e  5% and a  10 4 , a feasible solution exists also for these instances and the error rate of the solution obtained by HAPCOL is equal to that obtained by WHATSHAP. In terms of performance, HAPCOL is slower than WHATSHAP on the single instance with coverage 15 and it has a similar running time of WHATSHAP on the two instances with coverage 20 ($21 min, on average). Noticeably, the amount of memory required by HAPCOL on these two instances ($9 GB, on average) is $15 times lower than that required by WHATSHAP ($143 GB, on average), a further confirmation of the memoryefficiency of HAPCOL even when more corrections per columns are allowed. Furthermore, these results confirm that a simple strategy that progressively increases the number of corrections allowed in each column until a solution is found would be practicable, since it always leads to a solution while keeping the memory usage as low as possible. A comparison between HAPCOL and WHATSHAP is not possible on instances with coverage 25, since WHATSHAP was not able to solve these instances within the available amount of memory. Hence, we evaluated how accuracy and performances of HAPCOL vary between instances with coverage 20 and 25 (). For space constraints, we report the results only for e  5% and a  10 3 , that is for the parameters for which the maximum number of instances has a feasible solution. Moreover, to not discard the effect of read lengths, we focused only on instances with read length50 000 bases. Such a read length has been chosen since almost all these instances have a feasible solution for both coverage 20 and 25. We observe that increasing coverage from 20 to 25 allows to improve accuracy ($9%) of the reconstructed haplotypes (as we already observed for coverage 15 and 20). Moreover, the increased accuracy is mainly due to a significant reduction (approximately 10% on average, data not shown for space constraints) of the number of ambiguous positions, leading to an increased number of phased SNP positions. Concerning performances, instances with coverage 25 can be still analyzed with modest computing equipments; indeed HAPCOL completed the tests on chromosome 1 in <73 min and using less than 40 GB of main memory.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Results and discussion We experimentally compared accuracy and performance of HAPCOL with those of state-of-the-art haplotype assembly approaches on both real (Section 3.1) and simulated datasets (Section 3.2). The experimental comparison on the real long read dataset is focused on evaluating the accuracy of the tools under the all-heterozygous assumption since such a standard benchmark dataset has low average coverage ($3) and contains only heterozygous SNP positions. We also assessed accuracy and performances of the tools while varying coverage, read length and sequencing/indel error rate on simulated long read datasets with characteristics similar to those of the 'futuregeneration' sequencing technologies that are currently (or soon) available (coverage up to 25, read length up to 50 000 bases, substitution error rate up to 5% and indel rate equal to 10%) (Carneiro et al., 2012; Jain et al., 2015; Roberts et al., 2013). We compared HAPCOL with three state-of-the-art haplotyping tools specifically designed for handling long reads, namely, REFHAP, which was shown to be one of the most accurate heuristic methods (Duitama et al., 2012), PROBHAP, a recent probabilistic method which has been shown to be sensibly more accurate than REFHAP (Kuleshov, 2014) and WHATSHAP, the first exact approach for the weighted MEC problem specifically designed for long reads (Patterson et al., 2014, 2015). At higher coverages, applications such as SNP calling or validating which SNPs are really heterozygous in the given sample (e.g. there could be a significant portion of positions that, due to sequencing errors, appears to be heterozygous, but that should be predicted as homozygous) become feasible and reliable (Nielsen et al., 2011). However, since these applications require that haplotypes are reconstructed without the all-heterozygous assumption, on the simulated datasets we only considered WHATSHAP and HAPCOL as they do not rely on this assumption. The analyses focused on the accuracy of the reconstructed haplotypes and on the performances of the tools. Accuracy of the reconstructed haplotypes has been evaluated in terms of (switch) error rate (Browning and Browning, 2011) (i.e. the number of inconsistencies over contiguous phased variants) and in terms of phased positions (i.e. the number of positions for which the tool gave a phase prediction over the total number of positions that can be phased using the fragments given as input). Performances of the tools have been evaluated in terms of running time and peak memory usage, as reported by the Unix utility time. All the tests have been performed on a server equipped with four Intel Xeon E5-4610v2 CPUs and 256 GB of RAM.
Y.Pirola et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Conclusion We have proposed an exact algorithm, called HAPCOL, for the weighted k-cMEC, a new variant of the wMEC problem that takes into account the main characteristics of future-generation sequencing technologies, namely the uniform distribution of sequencing errors and the increasing length of sequenced reads. We showed that the haplotypes computed by HAPCOL on a real benchmark dataset are at least as accurate as those computed by current state-of-the-art approaches. This result supports the validity of the additional constraints imposed by the k-cMEC problem. Furthermore, HAPCOL is able to overcome the traditional all-heterozygous assumption and to process datasets with coverage 25 on standard workstations/small servers, while the current state-of-theart methods either rely on this assumption or become unfeasible on coverages over 20. Thanks to these results, HAPCOL is potentially able to directly perform SNP calling or heterozygous SNPs validation that become feasible and reliable on coverage up to 25. HAPCOL has been specifically designed to exploit the uniform distribution of errors that characterizes 'future-generation' sequencing technologies, but it can be successfully applied on sequencing data with a different error distribution by choosing the maximum number k of errors per position according to the error model. Furthermore, HAPCOL can be easily extended to adaptively increase the value of k (on certain columns) until a feasible solution exists. This strategy allows to process datasets affected by systematic sequencing errors without a great impact on the performance if the average error rate is low (such as in the current Illumina sequencing technologies). An interesting future direction would be the extension of the k-cMEC problem to deal with individuals related by structures such as trios or pedigrees (Browning and Browning, 2011). Indeed, the Mendelian laws of inheritance induce further constraints that may improve the accuracy of the reconstructed haplotypes, as shown for example by Pirola et al. (2012).
