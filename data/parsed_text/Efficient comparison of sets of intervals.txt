Motivation: High-throughput sequencing produces in a small amount of time a large amount of data, which are usually difficult to analyze. Mapping the reads to the transcripts they originate from, to quantify the expression of the genes, is a simple, yet time demanding, example of analysis. Fast genomic comparison algorithms are thus crucial for the analysis of the ever-expanding number of reads sequenced. Results: We used NC-lists to implement an algorithm that compares a set of query intervals with a set of reference intervals in two steps. The first step, a pre-processing done once for all, requires time O½#R logð#RÞ þ #Q logð#QÞ, where Q and R are the sets of query and reference intervals. The search phase requires constant space, and time Oð#R þ #Q þ #MÞ, where M is the set of overlaps. We showed that our algorithm compares favorably with five other algorithms, especially when several comparisons are performed. Availability: The algorithm has been included to S–MART, a versatile tool box for RNA-Seq analysis, freely available at http://urgi.versailles. inra.fr/Tools/S-Mart. The algorithm can be used for many kinds of data (sequencing reads, annotations, etc.) in many formats (GFF3, BED, SAM, etc.), on any operating system. It is thus readily useable for the analysis of next-generation sequencing data.
INTRODUCTIONWith the advent of high-throughput sequencing, bioinformatics must analyze a large amount of data every day. Modern sequencers can generate several hundred millions of sequences in a week for a price that is affordable to more and more labs. When a reference genome is available, the first task is to map the reads on the genome. Many mapping tools are now available and research is active on this topic. For RNA-Seq, the second step may be the assignment of the mapped read to the transcripts they originate from, to estimate the expression of the genes (). In general, the genomic comparison of the mapped reads with a reference annotation is the basis of many analyses: comparison of putative transcription factor binding sites with up-regulated genes (); detection of the single-nucleotide polymorphisms that are located in coding regions (); processing de novo transcript sequences to determine if they represent known or novel genes (). These three examples involve a comparison of two annotations, and the problem has been addressed often. However, high-throughput sequencing, for the amount a data it produces, requires optimized algorithms for its analysis. Most tools model the reads or annotation as intervals, or lists of intervals when different elements are modeled (exons, UTRs, etc.). These intervals are considered along a reference, which usually is a chromosome or a scaffold. Thus, comparing RNASeq reads with known transcripts reduces to comparing a set of query intervals (the reads) with a set of reference intervals (the exons of the transcripts). Every efficient algorithm requires a dedicated data structure, such as an indexed database, an indexed flat file [such as a BAM file (, an R-tree or NC-lists (nested containment lists) (). These structures are usually built once during the pre-processing step, and can be reused for other analyses. Although these structures may take considerable amount of time to build, the balance is usually favorable to pre-processed structures when several comparisons are performed, as the time spent for the comparison itself is considerably reduced. This observation leads to the conception of the BAM format, now widely used in the bioinformatics community. With the notable exception of the fjoin algorithm (), almost all the algorithms previously described only get all the reference intervals that overlap with one given query interval: most algorithms have been designed to retrieve all the intervals a user can see when he selects a given window in a genome browser (). Whereas these algorithms can be used to compare two sets by comparing each query interval, one after the other, with the reference intervals, we will show here how comparing the whole query set with the reference set can be more efficient. Among the possible data structures presented to compare intervals, NC-lists () are one of the most promising. NC-lists have been first described to retrieve all the reference intervals that overlap with a single interval. Their structure is compact (a simple set of two arrays, L and H), the algorithm is fast in practice and the search phase requires only constant space, which is compulsory when handling several hundreds of millions of reads. The key idea of NC-lists is to perform binary dichotomic search on the list of reference intervals. But dichotomic search cannot be performed when some intervals are contained (or nested) inside other intervals, so NC-lists arrange intervals into liststhe L arraywhere no two intervals are nested. If some intervals are nested inside an ancestor interval, *To whom correspondence should be addressed.  The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com they are stored in a separate sublist using the H array (see). NC-lists can be built in linearithmic time [i.e. of the form On log n], using linear space (actually, only five integers are stored per interval). In their article, the authors presented a recursive dichotomic algorithm, equivalent to Alg. 1, which uses NC-lists. It is claimed that getting all the reference intervals that overlap with a query interval could be done in time Olog#R  #M, where R is the reference set and M the pairs query/reference that overlap, but this is not accurate for some cases (see section 3.1). In this article, we will present an algorithm, which relies on NC-lists, and provides all the pairs query intervals/reference intervals that overlap. In a pre-processing step, the algorithm sorts the query and the reference intervals. It then builds a NC-list for the reference intervals. In the search phase, the algorithm compares every query interval with the reference intervals in time O#R  #Q  #M. All together, the algorithm takes O#R log#R  #Q log#Q  #M. Although the complexity of the whole algorithm is not better than already known algorithms, the runtime complexity is significantly lower than other constant-space algorithms. As such, our algorithm is especially useful when performing multiple comparisons on large sets of data, such as in an RNA-Seq data analysis.
Algorithm 1 Original algorithmAlgorithms 2 Simplified algorithm
METHODSTo compare two sets of intervals, we also used a NC-list for the reference set, and query intervals are simply sorted by their start position. Our aim is to find all the query intervals that overlap with at least one reference interval. The main idea of the algorithm is that knowledge from the comparison between a query interval and a reference interval will be used for the comparison of the next query interval. A sketch of the algorithm, which provides all the pairs of query/reference intervals that overlap, is presented in Alg. 2. The actual algorithm is slightly more complex, and is described in section 3.2. It uses a special variable, nfo (for next first overlap), which stores the first reference query that may overlap with the next query interval.
ALGORITHMS
Original algorithmDefinitions. We will describe and analyze here the problem of the comparison of genomic intervals. We will first formally define our data and the NC-list structure. DEFINITION 1. An interval i  a, b is an element of N 2 such that a b. By convention, we set i:start  a and i:end  b. For two intervals i and j, we define: i5j , i:end5j:start  i is before j i54j , i:start j:end ^ j:start i:end i and j overlap i & j , j:start i:start ^ i:end j:end i is contained in jr:start r 0 :start _ r:start  r 0 :start ^ r:end ! r 0 :end 8 < :
The associated asymmetric relation is defined by8r, r 0  2 R 2 , r 0 r 0  , :r 0 " r If two different intervals, r and r 0 , have the same coordinates [r:start  r 0 :start ^ r:end  r 0 :end], we define r 0 r 0 or r 0 0 r arbitrarily. To avoid ambiguity, the 0 relation is subscripted by the set it relates to (namely 0 Q for the query set and 0 R for the reference set). The successor of an element r 2 R with respect to the order 0 R will be noted succr, when it exists.The construction phase of the NC-list groups the sorted intervals into lists, such that an interval that is contained in another interval is moved into the sublist of the container interval.8c, p 2 R 2 , c:parent  p , p 2 r:children Finally, r:ancestors is the list of ancestors of r 2 R, i.e. the list r 1 , r 2 , r 3 ,. .. , r n  such that r 1 has no parent, r k  r k1 .parent and r n  r:parent.The previous definition provides a way to build the nested containment structure from a sorted list of intervals: given an interval r, all its successors that are nested into r should be found in a list under r. They are the subelements of r. The children of r are the subelements that are right under r (i.e. there is no other interval nested in r that contains a child of r). Note that an interval r may have no parent. In this case, we set r:parent  ; and all the intervals that have no parent form the top list. DEFINITION 4. The NC-list of a set of intervals is a tree-like data structure such that each node contains sorted intervals, the root node is the list of intervals that has no parent, there is an edge between every interval and the list of its children.Notice that a NC-list is not a tree because an edge connects a node (the parent interval) to a list of nodes (the children intervals). Revised complexity. The original algorithm, equivalent to Alg. 1, considers a query interval q and a set of reference intervals R. It gives the elements of R that overlap with q. We will show here that the algorithm presented by Alekseyenko and Lee (2007) does not have the complexity claimed in the article. In the example in, the announced complexity does not hold. The example has a nested structure, where each reference interval has the same number of siblings. For each list of siblings, none but the last one has children. The query overlaps every last sibling of each list. The number of layers is equal to the number of siblings, n. Here, #M  n and #R  n 2. Executing the algorithm yields a time complexity of On logn, as n binary searches are performed (one for each layer). However, the expected complexity is Ologn 2   n  On5On logn.
New algorithmDEFINITION 5. The problem of the comparison of sets of intervals considers two sets of intervals, Q and R (hereafter named the query set and the reference set) and finds all the pairs q, r 2 Q  R such that q and r overlap.Notice that there is no assumption on the two sets: elements from the query or reference sets may be nested or not, have different sizes, etc. DEFINITION 6. Consider a query read q. Let Bq  fr 2 R : r5qg be the set of reference intervals that are before q. Mq  fr 2 R : r54qg be the set of reference intervals that overlap with q. Aq  fr 2 R : r4qg be the set of reference intervals that are after q.Because B, Mand Aare disjoint, and cover the entirety of R, fBq, Mq, Aqg is a partition of R. Moreover, any optimized algorithm would of course try to compute Mas fast as possible, while avoiding scanning Band A. The two following lemma (their proof are omitted for they are straightforward) will help us skipping reading these sets. LEMMA 1. If an interval is in B, then all its subelements also are. A consequence, if a reference element is in B, then its children intervals will not be compared with q.The previous lemma implies that if we scan the reference interval using the ordering 0 R , the search can stop when the leastelement of Ais found. In other words, the greatest element of M, when this set is not empty, is the predecessor of the least element of A. There is no similar rule concerning the least element of Mand B, and characterizing the 'left frontier' of Mis slightly more complex.To do so, we will define here nfo. Informally, this variable is the least (using the ordering 0 R ) lowest (meaning that none of its children does) interval that overlaps with q. Because nfo overlaps with q, all its ancestors also do. Because it is the least variable that overlaps with q, the successors of nfo either overlap with q or are after q. In the algorithm, this variable is set when we compare a query interval q with the set of reference intervals, and it is the first interval that will be compared with the successor of q. We will prove the previous claims here.LEMMA 3. Let mq  min 0R fMq [ Aqg. If mis undefined, we set mq  None. If mis None, the nfoalso is. Otherwise, mq 2 fnfoqg [ nfoq:ancestors PROOF. Let us suppose that mis not None (the proof is clear otherwise). If mq 2 Aq, then mq  nfoq and the lemma is proved. Otherwise, let r be a reference element such that mq 2 r:ancestors ^ r:children  ;. Such an element exists, otherwise the number of sublists would be infinite. Clearly, r 2 fr 0 2 Mq : r 0 :children & Bqg, so nfoq" R r. We have thus mq" R nfoq" R r and r 2 mq:sub, which implies, by definition of the subelements, that nfoq 2 mq:sub, or nfoq  mq. This proves the lemma.As a result, suppose that we have found nfoand that we are looking for nfoq 0 , with q 0  succq. Because Bq & Bq 0 , the previous corollary implies that nfoq 0  is either a parent of nfoor one of its successors. LEMMA 5. 8m 2Mq, 8r 2 R, m 0 R r ^ m 6 2 r:ancestors ) r 2 Mq [ Aq PROOF. Let r be a reference interval such that m 0 R r ^ m 6 2 r:ancestors. The following assertions hold:(1) m:start q:end ^ q:start"m:end (q and m overlap),(2) m:start r:start(3) m:start4r:start ^ m:end5r:end (m 6 2 r:ancestors).From 2 and 3, we deduce that m:end5r:end. Comparing with 1, we deduce that q:start5r:end, and so r 2 Mq [ Aq. This proves the lemma.This last proposition implies that in general, all the elements greater than nfocould overlap with the successor of q. The only exception is when nfooverlaps with q. In this case, children intervals must be skipped. This is why we use a variable skip, which stores this configuration. Algorithm. From the previous propositions, we can directly infer an algorithm, which is completely presented in supplementary materials. A loop iterating over the query elements is described in findOverlap. The algorithm that compares a query interval with the reference intervals is described in findOverlapIter. A last algorithm, getNext, shows how to get the successor of a reference interval (considering the ordering 0 R ). Informally, the main algorithm directly jumps to the nfo reference element that had been computed by the previous query interval. It then checks the ancestors. Then, it scans forward. If the current reference is in B, it jumps to the next interval. If the current reference is in M, it goes down to the sublists, except if the variable skip is true. In such case, it directly jumps to the next interval. If the current reference is in A, it stops. The variable nfo is updated when necessary.In every case, the query interval (q) is in black, and the other colors refer to the reference intervals. nfois indicated by the arrow. To help the reader, reference intervals in Bare white; the intervals in Mare light gray; dark gray intervals are in A. Case (A) is the simple case, the other cases are less intuitive. In case (B), we can observe that the first overlapping interval is not nfo: it is the bottom-most overlapping element. In case (C), all the children of nfoare in B. In case (D), nfois in Amq  min 0R fMq [ Aqg is either a parent of nfoq 0  or one of its successors. Besides, we have previously proved that mq 2 fnfoqg[ nfoq:ancestors. Thus, starting from the previous nfo, checking its ancestors, then possibly going right until mis found, and then finally going down is enough to find nfo. This is what the algorithm does. PROPOSITION 8. The time complexity of the algorithm is O#Q  #R  #M. PROOF. Let us consider the reference intervals that will be compared with q. Let q 0 be its predecessor. The reference intervals that are scanned are BqnBq 0 , M, and the least element of A. Because the sets fBqnBq 0  : q, q 0  2 Q 2 , succq 0   qg are all disjoint, the total number of comparisons is O#Q  #R  #M.Notice that the algorithm findOverlap sometimes needs to go from the child to the parent, and thus be able to visit the tree from bottom to top, whereas the original algorithm described in Alg. 1 is a typical top-down algorithm. To be able to go up, we added in the L table a new cell, which contains the address of the parent element in the L table.Transcript modelization. Transcripts usually are not simple interval, but a succession of several intervals, which are the exons. Similarly, the reads can also be splitted in several parts if they overlap the exon/exon junction. In our implementation, we modeled the query and the reference element as a single interval (the smallest interval that contains all the exons), and store these intervals into the NC-list. To avoid reporting the reads that are the introns, we also store, for each interval, a pointer to the memory address where the transcript or read is completely described. To do so, we simply added a new column in the L table, which stores the address. When an overlap is found, the full structure is retrieved and the query and reference intervals are compared in detail to report only true matches.
RESULTSComparison to other implementations. We show here the results of our algorithm when compared with several other published methods. The first is a simple NC-list algorithm, as presented by, which does not use any information between two consecutive query intervals, hereafter called 'nc'. The second method implements binning () using an indexed SQLite table, hereafter called 'bin'. We also implemented another flavor of this algorithm, called 'has', where the database has been replaced by a hash structure, such that the keys are the bins, and the values are lists of intervals. A forth algorithm is a binning table with segment tree, as described in Segtor (), called 'seg'. We also added FJoin () ('fj'), which scans the previously sorted query intervals and reference intervals simultaneously to find overlaps. Our algorithm will simply be called 'new'. Among the presented algorithms, only 'bin', 'nc' and 'new' have constant space complexities. The other algorithms, 'has', 'seg' (where the trees are stored in memory) and 'fj' (which has a linear space complexity), are thus not likely to work on the large amount of data modern sequencers generate, with a standard computer. For instance, in our implementation, the 'has' algorithm fills our RAM (4 GB) when the reference dataset contains 30 M intervals. Still, as they rely on in-memory data, they usually run faster on the sets they can handle. For a fair comparison of all the algorithms, and to exclude any bias that would originate from the choice of the programming language used by the different methods, we re-implemented all the algorithms carefully as described by the articles. All the algorithms have exactly the same input, output and functionalities, which reflect a usual mapped reads/annotation comparison study. First, strand is ignored (as many RNA-Seq data have no strand information, and most algorithms, when described in their original articles, do not deal with this case). Second, each feature (hereafter a read or a transcript) is stored as a single interval. If an overlap is detected, the transcript is extracted from the input file (each method keeps track of the memory address of the features) and a second comparison is performed to check if the overlap is not located in the introns of the transcript, in which case the overlap is not reported. Last, the output file is a GFF3 file, which contains the query intervals that overlap with at least one reference element, and the list of the overlapping elements are added in the tags of the ninth field. These implementations, as well as the benchmark itself, are available in the SMART toolbox. See supplementary materials for more information about these implementations. Example on a real dataset. We downloaded three different publicly available RNA-Seq datasets: on yeast, fly and cress (available as SRR014335, SRR030228 and SRR346552 datasets in GEO). We mapped the reads with Bowtie () on the reference genome and we compared the mapped reads with the annotation (the genome sequence and the annotations are both available from the Bowtie website). For each dataset, we reported the number of annotated transcripts (which are the reference intervals) as well as the number of reads (the query intervals). We used the six different algorithms previously mentioned. Run-time results are shown in. The first columns give the characteristics of the datasets: number of reads, number of transcripts and number of overlaps. The following columns give the run-time spent by the algorithms when the genes are the reference and the reads are the query. As expected, 'has' and the 'fj' algorithms usually perform well on this dataset because the intervals are stored in memory.Our algorithm is still among the fastest ones. However, the preprocessing of our algorithm is by far the slowest one (see Supplementary Data). This is a typical trade-off between run-time speed and pre-processing-time speed because the 'bin' algorithm, the slowest algorithm in the comparison step, is the fastest algorithm in the pre-processing step among constant space methods.Example on simulated datasets. We also generated several datasets to compare the algorithms in detail. The intervals ranged from 36 to 100 nt, the genome contained a single chromosome, ranging from 10 k to 2 M bp. The number of reference and query intervals varies from 100 to 100 k and 100 to 10 M elements, respectively. Each configuration was generated five times. The results ingive the run-time results of each method. Our algorithm is still the fastest among the constant space complexity algorithms. The 'fj' required too much RAM (more than 4 GB) to work on the largest datasets. Regarding the pre-processing step, our algorithm is the slowest one (see Supplementary Information) but overall, the balance is always favorable to our algorithm after three comparisons when compared with the 'bin', the 'seg' or the 'nc' algorithm.Insertion in SMART. SMART () is a versatile tool box for the analysis of RNA-Seq data. It contains many useful tools for the comparison of RNA-Seq data with respect to a given annotation: number of reads for each transcript, distance distribution between the reads and the closest transcripts, discovery of previously unknown transcribed loci, etc. We added a new tool, called FindOverlapsOptim, which implements the algorithm presented in this article. As a consequence, the algorithm can be used for many kinds of data (such as RNA-Seq reads, but also annotation of any feature) in many formats (GFF3, BED, SAM, etc.). We included a so-called 'nclist' format in SMART, which contains several NClists (one per chromosome), so that preprocessing can be done once for all. This pre-processing step can be performed using a separate tool called ConvertToN CList. These files can be used as input file by most tools of the SMART suite, much like BED or GFF3 files. We also implemented a second version of our algorithm in the SMART tool called CompareOverlapping. This version is more flexible and accepts many different parameters: it may output the query elements only if they are collinear (or antisense) to the overlapping reference element, the query elements that are nested inside reference elements, the query elements that overlap the first 100 bp of the reference elements, etc. Because CompareOverlapping is much more flexible than FindOverlapsOptim, it is also substantially slower. Last, we added two versions of the much faster 'has' algorithm in SMART, to be used when the query or the reference have moderate sizes. The encapsulation of the algorithms within SMART ensures that the presented method is not only a theoretical work, but also used in a tool that is readily available to biologists. For the computer scientists, we also implemented an API and executables in C so that they can embed them in their algorithms.
DISCUSSIONThe method presented here uses NC-lists and provides a fast algorithm that compares two large sets of intervals efficiently.To our knowledge, it is the first time that an algorithm with both linear time complexity and constant space complexity during the search phase is presented. This low run-time complexity comes at the cost of a high pre-processing time complexity, where the intervals should be sorted. However, this step is done only once and is far from untractable (the samtools sort algorithm is used routinely to sort BAM files). As a result, the algorithm presented in this article is adapted to multiple comparisons. When we designed the algorithm, we had the idea in mind that it could help comparing features such as RNA-Seq data, which can amount to several hundreds millions reads. While this algorithm presents a theoretical interest by itself, we also encapsulated it in the SMART tool box, which includes all the features to handle usual file formats. As a consequence, we hope this work will be useful for both computer scientists and biologists.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
2 1 1 (top list) (sublist of 2) (sublist of 3) (sublist of 6) 14 30 24 16 23 15 28 H L 0 1 Fig. 1. Transforming a set of ordered intervals an NC-list. All the intervals have been previously sorted according to their increasing start position and, in case of tie, decreasing end position. Because intervals 3, 4 and 5 are nested inside interval 2, they are removed from the top list (which consists in intervals 1, 2 and 6) and inserted into another sublist. Intervals 3 and 5 are moved to the sublist of 2. Similarly, interval 4 is nested inside interval 3, and thus moved to another sublist. When an interval is nested into two intervals (as it is the case for the interval 7, which is nested in 2 and 6), the right-most interval that contains it is chosen. Here, it is interval 6. An NC-list is a set of two arrays, L and H. Each line of L stores the start and end positions of an interval, as well as an index to the H array. The L data are stored so that the intervals that are in the same list appear contiguously. For each sublist, a corresponding line of the H array stores the index of its least interval and the size of the list. As highlighted by the arrows, the sublist of interval 2 (line 1 of the L array, which is a zero-based structure) is the line 1 of the H array. The sublist starts at index 3 of the L array and contains 2 intervals (the intervals 3 and 5)
M.Zytnicki et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Efficient comparison of sets of intervals at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
