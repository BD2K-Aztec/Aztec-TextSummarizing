Motivation: Scaffolding is often an essential step in a genome assembly process, in which contigs are ordered and oriented using read pairs from a combination of paired-end libraries and longer-range mate-pair libraries. Although a simple idea, scaffolding is unfortunately hard to get right in practice. One source of problems is so-called PE-contamination in mate-pair libraries, in which a non-negligible fraction of the read pairs get the wrong orientation and a much smaller insert size than what is expected. This contamination has been discussed before, in relation to integrated scaf-folders, but solutions rely on the orientation being observable, e.g. by finding the junction adapter sequence in the reads. This is not always possible, making orientation and insert size of a read pair stochastic. To our knowledge, there is neither previous work on modeling PE-contamination, nor a study on the effect PE-contamination has on scaffolding quality. Results: We have addressed PE-contamination in an update to our scaffolder BESST. We formulate the problem as an integer linear program which is solved using an efficient heuristic. The new method shows significant improvement over both integrated and stand-alone scaffolders in our experiments. The impact of modeling PE-contamination is quantified by comparing with the previous BESST model. We also show how other scaffolders are vulnerable to PE-contaminated libraries, resulting in an increased number of misassemblies, more conservative scaffolding and inflated assembly sizes. Availability and implementation: The model is implemented in BESST. Source code and usage instructions are found at https://github.com/ksahlin/BESST. BESST can also be downloaded using PyPI.
IntroductionGenome assembly is still a challenging process, especially for large genomes, and scientists experiment with different combinations of data and tools to reduce errors, improve contiguity and avoid ambiguity. An important step in the assembly process is scaffolding, in which contigs are ordered, oriented and joined to form a larger scaffold unit. The input is a set of contigs and one or several genome mappings of paired short reads from either paired-end (PE) sequencing or mate-pair (MP) sequencing. Evaluations (e.g.) have shown that scaffolders make many mistakes, perhaps more than one might expect from what could appear a straightforward computational problem. The input to a scaffolder is however both large and noisy, and the data characteristics can vary a lot depending on the organism and V C The Author 2016. Published by Oxford University Press.
1925This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/4.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited. assembler. Although contiguity and errors are the most important metrics to evaluate a scaffolder by, we came to note that there are other artifacts from scaffolders not reported in these metrics. We observed that assemblies could increase in size by up to 106% after scaffolding and this mostly affects fragmented assemblies. We call this effect assembly inflation. A successful scaffolding will have some assembly inflation due to, e.g. unsequenced regions, but it should in general be very small. The type of technology, PE or MP, and their main parameter, the insert size, determine how far apart the reads are distributed on the genome and thereby at what distances contigs can be connected into scaffolds. Whether it is PE or MP also determines if the reads are read towards (PE) or apart (MP) from each other. There are numerous complications with PE and MP reads. For example, the insert size is not perfectly controlled and larger insert size typically means a larger variance in the distribution of distances between the reads, making scaffolding harder (). A largely ignored problem (on the computational side) is so-called PE contamination of MP libraries, which is a consequence of the MP library preparation. During the process, an unknown fraction of fragments that do not contain the circularization junction are sequenced. These misreads behave like PE reads, with opposite read direction from MP (see) and effectively with a much smaller insert size (). Hence, PE contamination reads may confuse a scaffolder that assumes an MP library is clean from contamination, suggesting a different relative order of contigs. When designing a scaffolder, one can take the stance that PE contamination is (1) an experimental issue which should be controlled in the wet-lab and (2) it can be treated as noise in the MP that will get filtered away in a scaffolding optimization procedure anyway. Regarding (1), we probably have to accept PE contamination as a largely unavoidable difficulty and, in that case, we argue that the PE should be explicitly modeled in MP datasets to reduce errors. Although a decent MP library will contain more true MP reads than PE, and hence overshadow PE contaminants in many cases, assumption (2) will not hold for fragmented assemblies as there are many short contigs close to each other making PE links dominate MP links. The ambition can also be set higher: perhaps we can start utilizing PE contamination as valuable short-range information rather than nuisance that needs to be filtered away? One may also ask how sensitive the current generation of standalone scaffolders are to MP libraries with a high amount of PE contamination? If scaffolders have been designed for near ideal datasets, what can one expect in a more difficult situation? PE-contamination has been discussed in relation to integrated scaffolders in end-to-end assemblers such as ALLPATHS-LG () and MaSuRCA (). These methods rely on the orientation being observable, e.g. by finding and removing the adapter sequence. In practice that is not always the case, as a fraction of read pairs will not contain the adapter (depending on shearing size) and orientation will not be observable. A method that does not rely on adapters being observable has the additional benefit of not putting a constraint on the fragment shearing size (in the re-fragmentation step of the circularized fragments in the library construction protocol). Smaller shearing size yields more 'identifiable' mate-pairs (adapter is present in the end of at least one read), but a higher contamination content of PE-fragments and chimeric reads (adapter present in the start or middle of a read). On the other hand, larger shearing size gives fewer identifiable mate-pairs but larger amount of true mate pairs as well as fewer PE-fragments and chimeric readsdue to the increased probability of sequencing full length reads on both sides of the adapter on a larger fragment. Scaffolding with a library with larger fragment shearing size also has the advantage that span coverage of the PE-contamination increases, giving better short range connections. As this contamination has neither been modeled nor examined in terms of how it degrades scaffolding results, we decided to investigate this. We developed a scaffolder that models PE contamination reads in the scaffolding process on MP libraries. We show that modeling PE-contamination improves scaffolding. Our design utilizes an integer linear program (ILP) for the MP/PE classification and uses information from the interval structure of the contig graph to heuristically obtain a set of linear programs (LP) to solve. The heuristic method is very fast and finds the correct order of contigs in all cases given the model assumptions, as seen on our simulated data.
MethodsThe presented work builds on the BESST scaffolder (), which iterates over PE and/or MP libraries in the order of their mean insert size. For each library, BESST scaffolds in two steps. In the first step, safe linking, large contigs are scaffolded using a greedy statistical scoring heuristic (a contig is large if it is unlikely that a read-pair can span over the contig). In a second step, improved linking, smaller contigs are placed within gaps of the larger contigs, or between larger contigs that were not linked in the first step (e.g. because their distance was larger than the insert size). The second step is done with a breadth-first search where the highest scoring paths (i.e. sets of contigs in the contig graph, see) are selected. The methods presented here are applied to the output of the improved linking step, that is, to paths of smaller contigs. Each path is a local subset of the contig graph, thus naturally dividing the contig graph into subregions in which the contigs needs to be oriented, ordered, and positioned accurately (deciding distance between contigs in a scaffold). If PE contamination is present, it can confuse the ordering as PE reads have the opposite orientation to MP reads.shows the two possible orderings for two contigs joined by a paired read link, notice however that the relative orientation between the contigs remains the same. We will here define the problem of ordering and positioning contigs with PE-contamination as an ILP. For m contigs linked with paired reads, we can have up to m! possible orderings and it is not feasible to try them all. We therefore find a solution to this ILP by solving a reduced set of Linear Programs (LP) where each LP is induced by fixing the order of the contigs. With a fixed ordering of the contigs, solving the LPs will reduce to finding optimal gap sizes between contigs using the gap model by).
Integer linear program formulationThe following paragraphs introduce the ILP formulation. We first consider a fixed contig ordering where the contigs are linked only byThe corresponding contig graphs where '5' and '3' denotes the 5 0 and 3 0 ends of contigs MP links. We then add PE links to the formulation via an unknown variable representing the order of contigs.
Fixed ordering objective without contaminationLet a contig graph G be an undirected graph created by contigs and read pair links where each contig is represented by two vertices (for the 5 0 and 3 0 end respectively) and an intra-contig edge. Let an intercontig edge be an edge in G that connects two vertices that come from different contigs if one or more read pairs suggest those two contigs are linked and the read pair(s) suggest the same orientation and distance of contigs (known as 'link-bundling',). The intra-contig edges are used in the implementation but does not contribute to the ILP problem and we will from now on only discuss inter-contig edges. Notice that a read pair can give rise to two different edges in G, depending on if the read pair is assumed to be in PE or MP orientation, see. Assume that we have a connected subgraph of G induced by contigs c 1 ;. .. ; c m and a set E of inter-contig edges (not all contigs need to have edges between them), see supplementalfor an example of a contig region. A linear order of m contigs has m  1 gaps g 1 ;. .. g m1. Let us focus on the edge e between contigs c i and c j , defined by w e links. Using only the links between c i and c j , assume that we have an estimate ^ d e of the distance between these two contigs, see. Note that this distance is not to be confused with the gaps g 1 ;. .. g m1 , as c i and c j might not be adjacent in the given ordering. How to get the estimate of ^ d e accurately is described in (). From ^ d e and o e (see), we naturally get the average insert size of the links that spans c i and c j as ^ l e  o e  ^ d e , where o e is the average observation. That is, ^ l e is the average insert size suggested by the links between c i and c j. Notice that we define the insert size to include the read lengths (sometimes denoted the fragment length). In a given placement of the m contigs, c i and c j will be at distance P j1 ki1 jc k j  X j1 ki jg k j  o e , adding up the j  i  1 contigs and j  i gaps between c i and c j. The objective is to minimize the discrepancy between the placement in the current ordering and ^ l e , that is, to minimizeSinceis constant, we omit this denominator in the objective. Note that higher uncertainty gives lower relative penalty. We have the objective function asAs seen in the objective, edges with larger weights w will penalize a possible distance discrepancy more.
Fixed ordering constraintsDue to the MP library insert size, we do not allow gaps larger than l MP  kr MP , with k empirically set to 2. Therefore, we have m  1 constraints g i l MP  kr MP :Notice that even though a gap is an integer value, we choose to work with a relaxed problem to be able to apply LP.
Formulating an ILP for unknown orientation and orderingThe unknown in this problem is the orientation of contigs in a region. Let I MP e be the indicator function for edge e having MP orientation. The full ILP has the variables g, z and I MP and is written asWe can use the minimum objective value to this ILP to evaluate contig orderings. For m contigs, there are m! possible orderings, thus we need a way to efficiently choose a subset of orderings to run the ILP on. For each assignment of I MP e ; e 2 E, the problem is a regular LP (remember the assumption g 2 R) and we use common LP methods to express the LP on standard form, i.e. introducing help variables to remove absolute values and negative valued variables. This implies that we have 2m  1  jEj constraints in practice. The jEj extra constraints comes from the fact that z e is an absolute value and 2m  1 constraints because the gap variables are allowed to be negative (letting g i  x i  y i , for x i ; y i > 0). We solve the LP with the simplex method which we denote with S. S takes a path (translated into an LP instance) as argument and returns a real valued objective value.In this step, the permutation gives paths with contig orderings of the type c 1 ;. .. c i ; c i1 ;. .. c m ; 8i 2 3; m  1. We choose the path with the
Solving the ILPAssembly scaffoldinglowest objective for the next iteration as p 1  argmin p2P0 Sp. If p 1 6  p 0 0 (i.e. there has been a change in ordering), we will remove the index i from E 0. This means that the edge between contig c i1 and contig c i is more likely to be a PE edge. That is, we have calculated the objective values of each candidate ordering formed by only permuting each consecutive pair of contigs, and we chose the one with the lowest objective. Notice that we 'switch' at most one MP link to a PE link by this procedure. We have now outlined the first iteration step of the algorithm. A general iteration step j has three substeps. Substep 1: We form m  j  2 contig orderings p 0 j ;. .. ; p mj3 j made from permutations, 8i 2 E j , inserting segment c k ;. .. ; c i at position ac i1 ; p j1 , where ac k ; p j1   ac i1 ; p j1   1, i.e. c k comes immediately after c i1 in p j1. Notice that the indices i always refer to the initial ordering in p 0 0 i.e. c 1 ;. .. ; c m . In a general step j, c i1 and c i might no longer be adjacent (hence we needed to introduce the function a; ). Substep 2: We calculate S(p), 8p 2 P j and letSubstep 3: If p j1  p 0 j , we return the final path p 0 j. That is, no candidate orderings obtained a lower objective than the identity permutation. Otherwise, if p j1  p i j for i 6  0, we let E j1  E j ni. That is, we accepted the MP edge between c i ; c i1 as being PE oriented.(4) Return to step (1). Seefor an illustration of the algorithm in practice. The algorithm stops either when p j1  p 0 j or when the set of candidate edges are empty, which happens when j  m  3. This algorithm will at most compute m3m4 2 LPs. In practice, on the datasets we have scaffolded, m is almost always smaller than 15 and we have never observed m over 25. Notice that changing relative orientation of contigs would yield pairs of orientation FF or RR, which are invalid according to our model, thus no such operation is allowed. A solution to each LP gives a set of real valued gaps g i , i 2 1; m  1 that are used to place the contigs accurately as information from several edges are used simultaneously for each gap. The model is implemented in the workflow of BESST, and after applying BESST's scaffolding procedure (), we obtain ranked clusters of contigs (created by splitting the contig graph based on longer contigs) where the rank is based on how many supporting versus contradicting links a cluster has. Here, we start solving the ILPs, with the highest ranked cluster first. Paths containing contigs that are already included in higher ranked paths are discarded. As described, each ILP i is solved by solving a set of LPs. Our heuristic solution works well when the PE distribution has a short span. If the PE fragment length distribution is wide, and a significant number of PE-links would link non-neighboring contigs, more permutations would be needed. Thus, the permutation of adjacent contigs is efficient if most PE read pairs link adjacent contigs in the true ordering.
Results and discussionWe have compared our new implementation of BESST, called BESST-v2 below, with SSPACE (), OPERA (), SOPRA (), SCARPA () and SCAFFMATCH (). Version 1 of BESST () is included for reference. We also include integrated scaffolder results provided by GAGE, labeled 'INTEGRATED'. SSPACE, SCARPA, SOPRA and OPERA were run with mappings from Bowtie () as suggested bywhen comparing the aligners BWA (), Bowtie and Bowtie2 (). SCAFFMATCH is coupled with Bowtie2. BESST was run with BWA-MEM (). Full running instructions and details on resource usage are given in Supplementary data.
DatasetsWe have included a simulated dataset, sim, which we developed the model on. A genome of size 500 000 bp was simulated and contigs of either 5000 (P  0.2) or 500 bp (P  0.8) were generated from this genome with no gap between contigs. The random generation of contig sizes ensure different complexities on the subproblems. The longest stretch of smaller contigs between border contigs consisted of 20 consecutive small contigs. Based on the reference genome, a MP library with 50 coverage of 2 100 bp reads was simulated. The MP library had insert-size distribution N(3000, 300) and 30% of the reads were PE contamination with insert size chosen from N(400, 40). Simulated data from the Assemblathon 1 study () is denoted assemblathon3k. We assembled contigs with Minia () from the paired-end reads provided by GAGE (). This gave approximately 74 000 contigs. The contigs were scaffolded with the 3 kbp MP library provided by Assemblathon 1. It contains mate pairs with insert-size distribution N(3000, 300) and 20% PE contamination with an insertsize distribution of N(500, 50). Three cases, Staphylococcus aureus, Rhodobacter sphaeroides and human chromosome 14, were taken from the Genome Assembly Gold-standard Evaluation (GAGE) study (), a comprehensive evaluation of large-scale genome assembly algorithms. We denote them staph, rhodo and hs14, and GAGE provides 8, 9 and 9 contig assemblies, respectively. These assemblies were scaffolded with the original shortjump libraries provided by GAGE. By aligning these libraries to the reference genomes with BWA-MEM () we detected a natural PE contamination in the rhodo and hs14 libraries at 41% and 33%, respectively, with mean insert size of 211 and 200 bp, respectively (see Supplemental Figs S2 and S3). The staph library had almost no PE contamination with the given alignments ((1%, see). We created additional libraries for each reference genome to study the effect of increased levels of PE contamination and PE span coverage. The parameter c added is introduced to indicate the percentage of added PE reads in a library. The original GAGE libraries have c added  0 (0% added contamination). The c added  15 libraries were formed by simulating PE reads from the genomes with distribution N(300, 30) and adding them to the original read library. Similarly, the c added  40 libraries were formed by simulating PE reads from the genomes with distribution N(400, 40) and adding them to the original library. We used NxTrim (O') and FastQC (http:// www.bioinformatics.babraham.ac.uk/projects/fastqc) to find adapters within the GAGE datasets but a very small fraction of adapters were found (in 09% of the read pairs), hence MP and PE orientation could not be determined on the large majority of the reads which inhibits the use of an adapter filtering tool to filter out PEcontamination. We therefore include additional evaluation of BESST-v2 scaffolding with all read pairs against BESST scaffolding with only MP-filtered read pairs on two datasets where a significant number of adapters can be found, see section S3 for detailed results and discussion.
Evaluation methodAssembly evaluation is known to be difficult (), as there are many metrics to consider. Ultimately, the end result of an assembly should be as long error-free sequences as possible. However, two assemblies with the same lengths on error free sequences can still differ if one of the assemblers/scaffolders contains false joins, making the assembly look more contiguous. Thus, errors is another important metric. We therefore choose to look at the number of errors and the adjusted E-size (, the expected length of error free sequence in the assembly,) which we denote by E 0. Moreover, we need an informative way to present the quality increase/decrease of an assembly from contigs to scaffolds. Since the GAGE datasets contains assemblies of varying quality (with respect to contig errors and E 0 ) of each organism, we present the quality improvement between contigs and scaffolds. Let E 0 c and E 0 s denote the adjusted E-size of the original contig assembly and the scaffolded assembly. We report the increase in errors from original contigs to scaffolds as well as the ratio E 0 s =E 0 c. Tables S2S18 in Supplementary data contains results for individual experiments and the summary tables presented here shows the average increase on each organism and library.
Assembly size inflationAs another aspect of scaffolding quality, we also show how total assembly size grows after scaffolding. We observed that some scaffolders increase the assembly size more than others and we wanted to find the cause. Since no scaffolder (in this comparison) puts a contig sequence in multiple places (e.g. repeats) or derive new sequence from the reads, inflation is due to added gaps (stretches of N's). We categorize inflation into three possible causes: (1) The genomic content between two contigs is not present in the assembly, thus an approximately correct number of N's is inserted. This is correct behaviour from a scaffolder and, to some extent, it improves the quality of the assembled genome. (2) The genomic content between two contigs a and c is present in another contig b in the assembly, but the scaffolder is unable to place b. The scaffolder creates (a correct number of) N's between a and c and leaves b isolated in the output file. This increases the assembly size, as there are two versions of a single location in the assembly, represented by b and N's respectively. It is not a misassembly, but it can confuse downstream analysis, and it negatively affects the assembly quality through size inflation. (3) Errors: a gap between contigs is inserted due to a false join, or the gap sequence significantly differs in length to the real gap length. This is seen as a misassembly that decreases the quality of the assembly. When we discuss assembly inflation we will refer to these three causes as (1), (2) or (3). We also report the ratio of scaffolded assembly size compared to initial contig size, labeled inflation in the tables, and find that some scaffolders are prone to (2).
Note on evaluationSnakemake (K oster and) was used to run our evaluation pipeline. QUAST () was used for evaluating the scaffolders as it uses alignments to a reference to identify misassembly breakpoints. Support for computing E-size was added. QUAST classifies a misassembly as a breakpoint in the scaffold where the left and right flanking bases differs more than N base pairs from the reference sequence. We have set N  100 to allow for reasonable variation in gap size estimations. Also, QUAST does not handle allele shifting of contigs on scaffolds from a diploid genome with a diploid reference. As the assemblathon3k dataset provides both copies of each chromosome, the evaluation was performed by giving only one of the copies of each chromosome (copy A) as reference to QUAST. Therefore, some of the errors occur due to the omitted reference copy. For example, the original assembly of minia is free from misassemblies if both copies is given as references. The scenario is however the same for all scaffolders so relative performance can still be compared.
Inflated assembly sizesAll scaffolders increase the assembly size to some extent but there is large variation among them. On the simulated dataset, all scaffolders except BESST-v2 and SCARPA inflate the assembly size by 18% or more even though all contigs have the potential to be linked (see). SCAFFMATCH inflates the assembly size the most (106.6%) and manual inspection reveals that this is due to a mix of cause (2) and (3). SCAFFMATCH uses an approach (maximum matching) that only permits one neighbour of every contig to be joined; a limitation on fragmented assemblies, making mate pairs link to several neighbors. SCAFFMATCH addresses this limitation by including a separate insertion-step that attempts to place remaining singleton contigs, but it does not perform well on this dataset. SSPACE also inflates the assembly size of the dataset sim to a large extent, but has only one error. The inflation is from (2), which is a result of SSPACE's heuristic; SSPACE extends scaffolds greedily by choosing (only) one neighboring contig with the most links. OPERA, SOPRA and BESST show vulnerability by making orientation mistakes (as in) due to creating many joins where the link is interpreted as a MP instead of a PE. SCARPA has low inflation on this dataset. On the assemblathon3k dataset, see, BESST-v2 is able to increase the adjusted E-size with a factor of 22 while keeping the size of the assembly relatively constant. SCAFFMATCH, SSPACE, BESST and SCARPA inflate the assembly size significantly, but the large amount of errors and small E 0 s =E 0 c (for SSPACE and SCAFFMATCH) suggests that this is due to cause (3). As the PE oriented read has mean insert size of 500, this is the dataset where PE contamination has the highest span coverage and therefore most likely poses the biggest challenge. On the GAGE datasets () the inflation levels vary significantly among scaffolders. This phenomenon is most evident for SCAFFMATCH and SSPACE and is likely an artifact of theirSSPACE gives only one error but places very few contigs and has an inflation of 43.5% from type (2). OPERA and BESST are the most sensitive to PE contamination with respect to misassemblies. 'Contigs' denotes the initial contig assembly metrics from which the relative inflation, increase in errors and corrected contiguity are computed.
Assembly scaffoldingmethodology. SCAFFMATCH inflates the assembly size the most and shows larger inflation as contamination increases (up to 19.2% and 28.7% on average on rhodo and hs14 respectively). SSPACE also shows high inflation rate on the GAGE assemblies already with the original libraries (c added  0), e.g. 6% on hs14. The contamination further worsens this behavior for SSPACE to 17% on average on rhodo and 9% on hs14 for c added  40. SCARPA and BESST are also affected by assembly inflation, but not to the same extent as SSPACE and SCAFFMATCH. Notably, SCAFFMATCH, SSPACE and SCARPA show an extreme inflation in assembly size on the two most fragmented assemblies on rhodo (ABySS and SGA) with inflation between 28 and 49% on ABYSS and 58 and 103% on SGA (Supplemental data,S9), and a similar trend for the most fragmented assemblies on hs14 (Supplemental data, S13). Such extreme inflation is clearly not correct as it almost doubles the assembly size, especially when the contig assembly size is already larger than the true genome size. We also argue that even subtle inflation increase on these datasets are artifacts as BESST-v2 in general has the fewest errors and highest increase in contiguity with only a small increase in assembly size. Inflation/deflation level vary among the integrated scaffolders. For example, SGA contig assemblies are generally significantly larger than the genome size and SGA's scaffolder removes a lot of sequence in the scaffolding step. In the hs14 assemblies, the integrated scaffolders in Velvet, Bambus2, MSR-CA and SOAPdenovo inflate assembly size the most and also introduce significantly more errors than the other scaffolders.
Summary inflationIn total, our results indicate that assembly inflation is more likely due to poor scaffolding (cause) or the inability to place many contigs in a fragmented scaffold (cause (2)) rather than correctly added sequence gaps (1) for both stand alone and integrated scaffolders. This is supported by investigating the individual assemblies (Tables S2S14). The more fragmented assemblies show significantly higher inflation and error rate than the higher quality ones. We suggest users of scaffolders to look at similar metrics after the scaffolding step is performed. Notably, BESST-v2 reduces the assembly size slightly with increased PE contamination (). This is due to the fact that BESST-v2 can use the extra short range information to place smaller contigs, thus lowering inflation by reducing gapped sequence, i.e. gaps caused by (2).
Errors and contiguityThe sim and assemblathon3k datasets show how strongly PE contamination can affect scaffolding (Tables 12). There are extreme differences in inflation, errors and E 0 s among the scaffolders on these two datasets. The differences in result between BESST and BESSTv2, as well as the number of errors of, e.g. OPERA, SOPRA and SCAFFMATCH, indicate that a large part of the links created in the scaffolding graph are from PE contamination. BESST-v2 corrects all errors on sim and the majority of errors on assemblathon3k, which indicates that it is an efficient method for finding the correct ordering. The GAGE datasets () further show that PE contamination affects scaffolding significantly, especially when assemblies are more fragmented, as is common for more complex genomes (see hs14,). OPERA and BESST seem to be the most vulnerable to contamination with significant increase in errors and lower E 0 s across most assemblies as the contamination level increases. SCARPA is another scaffolder where introduced contamination changes the results drastically across single assemblies. However, one assembly (MSRCA) is missing from SCARPA on hs14 due to our computational time constraint and the average is therefore somewhat distorted for hs14 with c added  40. The effect on individual assemblies is an increasing number of misassemblies (see Tables S12S14). SSPACE takes a more conservative approach as it only chooses one neighboring contig to extend the scaffold with, which is reflected with increased level of inflation. This results in a slightly lower E 0 s for the c added  40 libraries. On rhodo (), however, there is a large increase in errors, where almost the entire increase is on the two fragmented assemblies ABySS and SGA. Due to the number of failed runs by SOPRA on hs14 (from the time constraint), no general conclusion about trend can be made with the averaged data presented here. However, as with the other scaffolders, SOPRA is the most affected by fragmented assemblies and greatly increases the number of errors on SGA and Velvet on hs14 when contamination is present (S14). SCAFFMATCH shows fairly consistent number of misassemblies and E 0 s across all datasets and with a relatively good E 0 s. However, it always has significantly more misassemblies than other scaffolders. With the GAGE libraries, BESST-v2 has the second fewest to fewest misassemblies and second highest to highest E 0 s for almost all runs. The E 0 s even increases on rhodo () as contamination is introduced due to the extra read pair information. Although average number of misassemblies increases slightly for BESST-v2 with the contamination level in the GAGE runs, the difference is relatively small. In fact, the number of misassemblies at c added  40 made by BESST-v2 are competitive also at c added  0 with other scaffolders. The tradeoff between misassemblies and increase in E 0 s gives BESSTv2 favorable results to the other scaffolders.for hs14 with c added  0 shows that BESST-v2 lowers the misassemblies with almost 40%, with the most significant decrease on ABySS, ABySS2, SGA and Velvet. This suggests that a large part of the edges formed in a fragmented contig graph comes from PE contamination. Notably, BESST-v2 also improves scaffolding compared with integrated scaffolders across almost all datasets (see Tables S4, S7 and S12). On hs14, BESST-v2 has both fewer errors and higher corrected contiguity for all assemblies except for ABySS and ABySS2, where contiguity is 3-fold higher but at the cost of more errors. In conclusion, stand-alone scaffolders introduce a large number of misassemblies on the fragmented assemblies with contamination present (e.g. ABySS and SGA in rhodo,S9, or ABySS, SGA and Velvet in hs14,S14). By comparing the two versions of BESST, we see that BESST-v2 corrects most of theseS9 and hs14,S14, in Supplementary data). Modeling PE contamination in the scaffolding step is important for larger and more complex genomes where assemblies tends to be fragmented, thus the proportion of PE links increases. This is supported by looking at the number of errors that is corrected in the hs14 assemblies on real data; with original GAGE libraries BESST-v2 reduce 54% of BESST's errors when scaffolding the SGA assembly and 53% on the ABySS assembly (See Supplemental). Finally, BESST-v2 generally gives preferable results over integrated scaffolders on GAGE data.
Runtime and alignmentsWe also measured runtime and peak memory of the tools, see Supplementary Tables S36S47. Resource usage is not the main objective in this study and has been studied in other work (). However, we note that BESST, BESSTv2, SSPACE, OPERA and SCAFFMATCH (with the greedy approach) all have runtimes that should be practical on most genomes. There is no big difference in speed and memory demand between BESST-v2 and BESST.
ConclusionsWe have designed a scaffolder that can identify and make use of read pairs with PE orientation in a MP library, so called PE contamination. The scaffolder (BESST-v2) accurately infers scaffolds, even with high levels of contamination, and we showed that other scaffolders are vulnerable to PE-contaminated libraries. Our results indicate that, when modeled, PE contamination helps scaffolding, serving as short-range linking information which complements longranging mate-pair reads. This combination of reads helps placing. GAGE contig assemblies for Staph, rhodo and hs14 scaffolded with GAGE's shortjump MP-library, c added  0, with an added 15% PE contamination reads, N(300, 30), c added  15, and with an added 40% PE contamination reads, N(400, 40),The numbers are averaged over each assembly. Full tables are found in Supplementary data. 'Contigs' denotes the initial contig assembly metrics from which the relative. Boldfaced numbers indicates fewest scaffolding errors and highest ratio of increase in corrected E-size between contigs and scaffolds. small contigs in fragmented assemblies. We also showed that inflated assembly sizes after scaffolding are more often a result of the inability of scaffolders to place all contigs in a scaffold or erroneous gaps, rather than correctly inserted missing sequence from the contig assembly.
FundingThis work was in part funded by the Swedish Research Council (grant 20104634). The computations were performed on resources provided by the Swedish National Infrastructure for Computing through Uppsala Multidisciplinary Center for Advanced Computational Science (UPPMAX) under project b2013169.
Conflictof Interest: none declared.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
K.Sahlin et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
