Motivation: Large-scale evolutionary events such as genomic rearrange.ments and segmental duplications form an important part of the evolution of genomes and are widely studied from both biological and computational perspectives. A basic computational problem is to infer these events in the evolutionary history for given modern genomes, a task for which many algorithms have been proposed under various constraints. Algorithms that can handle both rearrangements and content-modifying events such as duplications and losses remain few and limited in their applicability. Results: We study the comparison of two genomes under a model including general rearrangements (through double-cut-and-join) and segmental duplications. We formulate the comparison as an optimization problem and describe an exact algorithm to solve it by using an integer linear program. We also devise a sufficient condition and an efficient algorithm to identify optimal substruc-tures, which can simplify the problem while preserving optimality. Using the optimal substructures with the integer linear program (ILP) formulation yields a practical and exact algorithm to solve the problem. We then apply our algorithm to assign in-paralogs and orthologs (a necessary step in handling duplications) and compare its performance with that of the state-of-the-art method MSOAR, using both simulations and real data. On simulated datasets, our method outperforms MSOAR by a significant margin, and on five well-annotated species, MSOAR achieves high accuracy , yet our method performs slightly better on each of the 10 pairwise comparisons. Availability and implementation:
IntroductionIn addition to the point mutations (single base-pair substitutions, insertions and deletions), in the course of evolution, genomes also undergo many large-scale events, which are usually divided into two categories, rearrangements and content-modifying events. Genome rearrangements include inversions, transpositions, circularizations and linearizations, all of which act on a single chromosome, and translocations, chromosomal fusions and fissions, which act on two chromosomes. Rearrangements can shuffle the order and switch the transcriptional orientations of the genes on chromosomes but cannot change the number of gene copies. On the other hand, the content-modifying events, which include segmental duplications, tandem duplications, gene insertions and losses, can affect the copy number of the genes. These two types of large-scale events are ubiquitous in the tree of life and have been shown playing a very important role in the variations of the individual traits. The molecular mechanisms behind them, although have been widely studied, are still very diversefor a review]. One basic task of comparative genomics is to infer the events took place in the evolutionary history for the extant species. Many combinatorial optimization problems aiming to compute the most parsimonious number of events between two given genomes (i.e. the edit distance) are formulated, and many algorithms, heuristics or exact ones, are proposed for them. When only rearrangement events are considered,gave the first polynomial-time algorithm to compute the inversion distance, which was later improved to linear time ().proposed a universal operation, called double-cut-andjoin (DCJ), which can unite most of the rearrangement events. Under the DCJ model, the edit distance can also be computed in linear time, but in a more simple and elegant way (). Because of its simplicity, DCJ model has formed the basis for the following algorithmic research on rearrangements (). All of the above efficient algorithms assume that genomes do not contain duplicated genes. In the presence of duplicated genes, most V C The Author 2015. Published by Oxford University Press.
i329This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/4.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com, i329i338 doi: 10.1093/bioinformatics/btv229 ISMB/ECCB 2015 of the edit distance problems are NP-hard. For two genomes with duplicated genes,proposed an efficient heuristic to compute the inversion distance by decomposing the problem into two new optimization problems.devised an exact algorithm to compute the DCJ distance by formulating the problem as an integer linear program. Both of the methods output a one-toone correspondence between the homologous genes and thus can be applied to assign orthologs. When only content-modifying events are considered, Kahn and Raphael (2008) devised an efficient dynamic programming algorithm to compute the duplication distance, which was later extended by introducing likelihood techniques and then applied to reconstruct the evolutionary history of the segmental duplications in human genome ().proposed an alignment approach to reconstruct the ancestral genome for two genomes with segmental duplications and gene losses and applied it in a phylogenetic context to infer the evolution of the stable RNA gene content and organization in various genomes. When both rearrangements and content-modifying events are considered, El-Mabrouk (2001) proposed an efficient algorithm to compute the edit distance for inversions and deletions.) gave a linear time algorithm to compute the edit distance for DCJs, insertions and deletions. Notice that these algorithms also assume that the given genomes do not contain duplicated genes. Shao and Lin (2012) gave a 1.5-approximation algorithm to compute the edit distance for two genomes in the presence of duplicated genes under a model that includes DCJs, singlegene insertions and single-gene deletions.extended the heuristics into unite rearrangements and single-gene duplications as a new software package, called MSOAR, which can be applied to detect in-paralogs in addition to orthologs. In this article, we compare two genomes in the presence of duplicated genes with DCJs and segmental duplications. Formally, the problem is to compute a set of segmental duplications in each genome and a bijection between the nonduplicated genes, such that the total cost of the segmental duplications and the DCJs induced by the bijection is minimized. We propose an exact algorithm for this problem by formulating it as an integer linear program. Based on studying the underlying structure of problem, we then devise an efficient preprocessing algorithm to simplify the problem while keeping the optimality. We also discuss and propose a reasonable way to balance the costs between DCJs and segmental duplications. Finally, we apply our method to assign in-paralogs and orthologs and compare its performance with MSOAR on both simulated and biological datasets.
Problem statementWe model each genome as a set of chromosomes and model each chromosome as a linear or circular list of genes. Each gene is represented by a signed ( or ) symbol, where the sign indicates the transcriptional direction of this gene. Homologous genes are grouped into gene families. For a genome X, we use AX to denote all the gene families in X and use F(X, f) to denote the set of genes in X that come from gene family f. We say consecutive genes on one chromosome form a segment. The length of a segment s is defined as the number of genes in s, denoted by jsj. We say two segments in the same genome are independent if they do not contain the same gene. We say segments s  a 1 ; a 2 ;   ; a n  and t  b 1 ; b 2 ;   ; b n  are homologous if a i and b i are homologous and have the same sign for all 1 i n or a i and b n1i are homologous and have the opposite sign for all 1 i n. We say segment s is possibly duplicated, if there exists segment t in the same genome such that s and t are independent and homologous. For a genome X, we use SX to denote the set of all the possibly duplicated segments in X (). We say a subset S & SX is independent if every two segments in S are independent. For an independent subset S & SX, we use X n S to denote the new genome after removing all genes appearing in the segments in S from X. Given two genomes X and Y, we say two independent subsets S & SX and T & SY are consistent if X n S and Y n T have the same gene content, i.e. for each gene family f 2 AX [ AY, we have jFX n S; f j  jFY n T; f j (). In this article, we assume that the given two genomes X and Y satisfy that AX  AY; otherwise we modify them by removing all the genes that are not in AX \ AY. With this assumption, there always exist two independent subsets S 2 SX and T 2 SY that are consistent. Suppose we are given two independent consistent subsets S 2 SX and T 2 SY. We denote by BX n S; Y n T the set of bijections that map each gene in X n S to a homologous gene in Y n T. If X n S and Y n T contain only singletons, i.e. we have jFX n S; f j  jFY n T; f j  1 for all f 2 AX [ AY, then we have jBX n S; Y n Tj  1, and the DCJ distance between X n S and Y n T is well defined and can be computed in linear time (). Once a bijection B 2 BX n S; Y n T is given, we can relabel X n S and Y n T by assigning each pair of genes in B with a distinct gene family and thus results in two new genomes with only singletons. We denote by d(B) the DCJ distance between these two new genomes induced by bijection B. In this article, we study the following problem: given two genomes X and Y satisfying AX  AY, and a cost function c, which maps each segment in SX [ SY to a positive value, compute a triple Q  S; T; B, where S & SX and T & SY are two independent consistent subsets and B 2 BX n S; Y n T, such that the total cost of Q, cQ  X s2S[T cs  dB, is minimized.
ILP formulationWe now formulate the above problem as an integer linear program. To achieve that, we first introduce the adjacency graph in Section3.1, which is the essential data structure to compute the DCJ distance. We also propose a new extension of the adjacency graph, called the extended adjacency graph, which can incorporate duplicated genes and thus forms the basis for the following ILP formulation. We then describe a capping method to remove the telomeres, in Section 3.2, which allows us only to count the number of cycles when computing the DCJ distance. On the basis of them, we finally give the ILP formulation in Section 3.3.
Adjacency graphWe first introduce some notations. The two ends of a gene a are called extremities. The head is denoted by a h and the tail is denoted by a t. The set of all extremities in genome X is called the extremity set of X, denoted by EX. If genes a and b are homologous, we also say the two corresponding extremity pairs, a h and b h , a t and b t , are homologous. Two consecutive genes a and b form one adjacency, which is represented by a set of two extremities. Thus, each adjacency comes in one of the four types: fa t ; b t g; fa h ; b t g, fa t ; b h g and fa h ; b h g. If gene a lies at one end of a linear chromosome, then this end can be represented by a set of one extremity, fa h g or fa t g, called a telomere. Suppose that we are given a triple Q  S; T; B, where S & SX, T & SY are two independent consistent subsets and B 2 BX n S; Y n T. We can build the adjacency graph w.r.t. Q, denoted by G(Q), as follows. We first build X n S and Y n T through removing all genes in S [ T and take all the extremities in them, i.e. EX n S [ EY n T, as the vertices of G(Q). Then for each adjacency in X n S and Y n T, we add one gray edge to connect the two extremities in it. Finally, for each pair of homologous extremities specified by B (each homologous gene pair in B specifies two pairs of homologous extremities), we add one black edge to connect them (c). Clearly, in G(Q), the degree of each vertex is at most 2, and thus it consists of a set of vertex-disjoint cycles and paths. The length of a cycle (or a path) is defined as the number of black edges in it. Let c be the number of cycles and o be the number of oddlength paths in G(Q). We have that the DCJ distance induced by B can then be computed as dB  n  c  o=2, where n is the number of genes in X n S (). Given a triple Q  S; T; B defined above, we propose an equivalent form of G(Q), called the extended adjacency graph w.r.t. Q, denoted by G 0 Q. The set of vertices of G 0 Q includes all the extremities in X and Y, i.e. EXFor each adjacency in X and Y, there is one gray edge connecting the two extremities in it. For each pair of homologous extremities specified by B, there is one black edge connecting them. For each gene contained in some segment in S [ T, there is one internal edge connecting the two extremities in this gene (). The difference between G 0 Q and G(Q) is that, the latter one explicitly removes those extremities in the genes in S [ T, whereas the former one keeps them but adds internal edges connecting the two extremities in those genes. Clearly, G 0 Q also consists a set of vertex-disjoint cycles and paths, and there is a one-to-one correspondence between the connected components in G(Q) and that in G 0 Q. Thus, the DCJ distance induced by B can also be computed as dB  n  c 0  o 0 =2, where c 0 is the number of cycles and o 0 is the number of odd-length paths in G 0 Q, and n is the number of genes in X n S. As we will see later, this extended adjacency graph is the key point in devising the ILP formulation.
Add capping genesIn Shao and Lin (2012), we described a method to remove telomeres by introducing capping genes. A capping gene contains only one extremity, which combines with the adjacent telomere (or another capping gene) to form one adjacency. All capping genes are homologous to each other, forming a distinct gene family, denoted by f s. Given two genomes X and Y with l X and l Y linear chromosomes, respectively (without loss of generality, we assume that l X !l Y ), we first add one capping gene to each end of all the linear chromosomes in X and Y; then we add l X  l Y  dummy chromosomes, each of which contains only a pair of capping genes, to genome Y (). We denote by ^ X and ^ Y the two new genomes after adding capping genes for X and Y. Clearly, we have jF ^ X; f s j  jF ^ Y ; f s j. Thus, given a pair of independent consistent subsets S & SX and T & SY, we know that ^ X n S and ^ Y n T also have the same gene content. Using the same argument as in, we can prove that minbelongs. We say gene a is duplicated in Q  , if there exists one segment s 2 S  [ T  such that a 2 s and nonduplicated otherwise. We now give the ILP formulation to compute Q . For each segment s 2 SX [ SY, we have one binary variable x s to indicate whether s 2 S  [ T . For each gene a 2 X [ Y, we have one binary variable y a to indicate whether a is duplicated in Q . We use the following two sets of constraints to guarantee that y a  1 if and only if there exists one segment s 2 S  [ T  such that a 2 s: y a ! x s ; 8s 2 SX [ SY and 8a 2 s; y a X s2SX[SY:a2s x s ; 8a 2 X [ Y:We require that these segments in S  [ T  are independent, i.e. there do not exist two of them that contain the same gene: X s2SX[SY:a2s x s 1; 8a 2 X [ Y:We also require that X n S  and Y n T  have the same gene content, i.e. for each gene family there must be an equal number of nonduplicated genes in Q  in this family in each genome:And for each gene family, at least one gene is nonduplicated inFor each pair of homologous genes a 2 X and b 2 Y, we add one binary variable z a;b to indicate whether B  contains this pair. We require that for each gene in X [ Y, it is mapped to exactly one homologous gene in the opposite genome if and only if it is nonduplicated in Q  : X b2FY;fa z a;b  1  y a ; 8a 2 X;These constraints guarantee that these pairs in B  form a valid bijection between the genes in X n S  and those in Y n T . To compute dB  , we need to count the number of cycles in G 0 Q  . We add a variable l e for each extremity e 2 EX [ EY to represent the label of e. We then assign a distinct upper bound for l e , denoted by U e (for example, we can just sort all the extremities in EX [ EY in an arbitrary order and assign U e as the index of e in the sorted list): 0 l e U e ; 8e 2 EXWe then require that all the extremities in the same cycle in G 0  Q   have the same label. This can be achieved by forcing that the two extremities connected by any edge in G 0 Q   have the same label. To guarantee this, we add the following three groups of constraints, each of which corresponds to one type of edges. First, we require that the two extremities in each adjacency have the same label (these constraints correspond to the gray edges): l ei  l ej ; 8fe i ; e j g form an adjacency in X or in Y: Second, we require that each pair of extremities specified by B  have the same label (these constraints correspond to the black edges). To achieve that, we add the following four constraints for each pair of homologous genes a 2 X and b 2 Y (if a and b are capping genes, then we have a h  a t and b h  b t and thus the following four constraints degenerate into two):Third, we require that the two extremities in each duplicated gene have the same label (these constraints correspond to the internal edges):We then add a binary variable w e for extremity e to indicate whether l e reaches its upper bound:Since all the extremities in the same cycle in G 0 Q   are forced to have the same label, and all label variables have distinct upper bounds, we know that for each cycle in G 0 Q   at most one extremity can have its label reaching its upper bound. Thus, we have that X e2EX[EY w e is exactly the number of cycles in G 0 Q  . And dB   can then be computed bywhere the first two items give the number of genes in X n S . Finally, we set the objective function of the ILP as
Identify optimal substructuresGiven two genomes X and Y after adding capping genes, we say two homologous segments s in X and t in Y form a pair of shared segments, denoted by hs; ti. Intuitively, shared segments are more likely to be nonduplicated and mapped to each other. Below, we give one sufficient condition and one algorithm to decide whether a pair of shared segments is in some optimal solution, i.e. in this optimal solution, a i and b i are nonduplicated and a i is mapped to b i , for all 1 i n. From now on, we assume that the cost function only depends on the length of the segments, i.e. we assume that if jsj  jtj then we have cs  ct.
A sufficient conditionWe say gene a in genome X is isolated, if there does not exist any segment s 2 SX such that a 2 s and jsj!2. The following theorem gives a sufficient condition to decide whether a pair of shared segments of length two is an optimal substructure.Let Q  S; T; B be an arbitrary triple such that either b 1 or b 2 is duplicated in Q, or B does not contain hb 1 ; b 2 i. Below, we will show that we can always build a new triple Q 0  S 0 ; T 0 ; B 0  in which both b 1 and b 2 are nonduplicated and B 0 contains hb 1 ; b 2 i and also verify that cQ 0  cQ. Since Q is arbitrary, this proves the theorem. First, assume that in Q both b 1 and b 2 are duplicated. Let s 2 S and t 2 T be the segments containing b 1 and b 2, respectively. Since both b 1 and b 2 are isolated, we know that jsj  jtj  1. Let S 0  S n fsg and T 0  T n ftg. We have that X n S 0 and Y n T 0 still have the same content. Let B 0  B [ fhb 1 ; b 2 ig. We have that dB 0   dB, since X n S 0 has one more gene than X n S, whereas GQ 0  has one more cycle than G(Q) (). Thus, we haveSecond, assume that in Q gene, b 2 is duplicated, while b 1 is not (or symmetrically, b 1 is duplicated, while b 2 is not). Suppose that b 1 is mapped to b 3 in B, i.e. hb 1 ; b 3 i 2 B. Let S 0  S and T 0  T n ftg [ ft 0 g, where t 2 T is the segment containing b 2 and t 0 is the segment containing only gene b 3. Clearly, we also have that X n S 0 and Y n T 0 have the same content. Let B 0  B n fhb 1 ; b 3 ig). This implies that the number of cycles in GQ 0  is no less than that in G(Q). In addition to the fact that X n S 0 and X n S have the same number of genes, we have that dB 0  dB. Thus, we have cQ 0   X u2S 0), we can prove that dB 0  dB. Thus, we still have cQ 0   X u2S 0 [T 0 cu  dB 0  cQ:
An algorithmWe say a pair of shared segments p  ha 1 ; a 2 ;    ; a n ; b 1 ; b 2 ;    ; b n i between genomes X and Y is half fixed, if b i is singleton for all 1 i n (and thus none of them can be duplicated) and all genes in FX; f ai are isolated for all 1 i n. Let p be such a pair of half fixed shared segments (PHFSS for short). We use Ap to denote all the gene families in p, i.e. Ap  ff a1 ; f a2 ;    ; f an g. In this section, we propose an algorithm to decide whether a PHFSS is in some optimal solution. Notice that for a PHFSS p, if we further know that in some optimal solution a k is mapped to b k for some 1 k n, then we can immediately conclude that the whole p is in some optimal solution by iteratively applying theorem 3.differ only on these gene families in Ap. We now define a new graph to focus on Ap while hiding others. Let Q be a triple and p be a PHFSS. We can build the reduced adjacency graph w.r.t. Q and p, denoted by R(Q, p), as follows. The vertices of R(Q, p) are divided into two types, the core vertices, which are exactly those extremities in the genes in the gene families in Ap and the boundary vertices, which consist of these extremities that form adjacencies with core vertices (). The edges of R(Q, p) are divided into four types, gray edges, black edges, internal edges and reduced edges. For any two vertices in R(Q, p), they are connected by gray edges or internal edges, if and only if they are connected by the same type of edge in G 0 Q. For any two core vertices in R(Q, p), they are connected by one black edge if and only if they are connected by one black edge in G 0 Q. For any two boundary vertices in R(Q, p), they are connected by one reduced edge if there exists one path connecting them in G 0 Q without going through any core vertices or boundary vertices (except its two ends). Clearly, R(Q, p) also consists of a set of vertex-disjoint cycles (Comparing genomes with rearrangements and segmental duplications i333 that corresponding to ha i ; b i i and then replace the internal edges corresponding to a i with that corresponding to a 0 i .In summary, once we know RQ; p, i.e. whether there exists one possible path connecting them that does not go through any other core vertices or boundary vertices. Notice that this path must be alternating, i.e. the edges with odd indices must be either black edges or internal edges and the edges with even indices must be gray edges (and d). There exists a linear time algorithm to decide the existence of an alternating path between two given vertices (Bang). We now adapt it for our use. Given a PHFSS p and two boundary vertices x and y, the algorithm first build a graph with V 1 [ V 2 [fx; yg as its vertices, where V 1 is the set of all extremities except all the core vertices and boundary vertices and V 2 is a copy of V 1. Two extremities in V 1 are connected by one gray edge if they form one adjacency. Two homologous extremities in V 2 in different genomes are connected by one black edge, and the two extremities in V 2 in a possibly duplicated gene are connected by one internal edge. We connect x (resp. y) to its all homologous extremities in V 2 in the opposite genome by black edges. Finally, all the counterparts between V 1 and V 2 are connected by bridging edges (). Clearly, all the bridging edges form a matching of size j V 1 j, denoted by M. The algorithm then computes an augmenting path w.r.t. M using the Blossom algorithm, which takes linear time. We claim that such an augmenting path exists if and only if there exists one alternating path connecting x and y without going through any core vertices or boundary vertices. In fact, if such an augmenting path exists, then the two ends of this path must be x and y, since they are the only two unmatched vertices. We claim that the edges in the augmenting path that are not in M form an alternating path connecting x and y. This is because edges in M are spanning V 1 and V 2 , whereas gray edges are all inside in V 1 and black edges and internal edges are inside in V 2. The opposite side of statement can be reasoned in a similar way. The algorithm to decide whether a given PHFSS p is in some optimal solution proceeds as follows. The first phase of the algorithm is to compute the core vertices and the boundary vertices w.r.t. p and then for each pair of boundary vertices, to check whether they can be connected by a reduced edge. If the total number of edges (reduced edges plus those among core vertices) is larger than log n, the algorithm terminates. Otherwise, the algorithm comes to the second phase. It enumerates all the possibilities of RQ; p for all the possibilities, then the algorithm concludes that p is in some optimal solution. The above algorithm runs in polynomial time. In fact, the first phase runs in polynomial-time, since we can decide the existence of a reduced edge for each pair of boundary vertices in linear time. In the second phase, the number of edges is in logarithmic-size, which implies that the number of possibilities of RQ  p ; p is in polynomial size. Thus, the second phase also runs in polynomial time. We remark that usually not all pairs of boundary vertices can be connected by a reduced edge (). In fact, if this is not the case,; p contains more cycles than RQ  p ; p, in which case the algorithm fails. In other words, the first phase to identify possible reduced edges is very essential, which not only decreases the number of possibilities but more importantly makes the algorithm capable of identifying optimal substructures. We also remark that this algorithm is a sufficient test, i.e. if it returns 'yes', then p is guaranteed in some optimal solution. However, if it returns 'no', then it is still possible that p is in some optimal solution. This is because two reduced edges in RQ  p; p might not be able to coexist in G 0 Q  p . We can apply the theorem in Section 4.1 and the algorithm in Section 4.2 on all shared segments to verify their optimality. If such an optimal substructure is identified, we immediately fix it and update the genomes through assigning each pair of genes in it a distinct gene family. We can iteratively repeat this process until no such optimal substructure can be found. This serves as a preprocessing algorithm to simplify the problem before calling the ILP solver. The performance of this preprocessing algorithm on real genomes is analyzed in.
Set the costUnder a parsimonious model, it is natural to set a unit cost for all segmental duplications (as we do for all DCJs). However, in this case, two segmental duplications, one in each genome, that create a pair of shared segments can be always explained as two DCJs with the same total cost. Consider the example in, for which we have two optimal solutions with total cost of 2: one is to regard a 2 and a 4 as duplicated genes, and the other uses two DCJs, which first cut a 2 out from X and then insert it back between c 1 and d 1. The scenario in the second case (two DCJs using one circular chromosome as intermediate) requires three inversions to explain, and therefore it is much less unlikely to happen comparing with the first scenario. Thus, to avoid the second case we set c < 1. On the other hand, if we have c 0:5, then every DCJ that inverts a possibly duplicated segment can be always explained by two segmental duplications with the same or even better total cost. Consider the example in, for which one solution is to use only one DCJ to invert the segment a 2 ; b 2  on X. However, if we have c 0:5, then we can regard a 2 ; b 2  and b 4 ; a 4  as duplicated segments, whose total cost is at most 1. Thus, to avoid the second case, we need to set c > 0:5. Combining the above two facts, in the following experiments, we set c  0:75.
Infer in-paralogs and orthologsUnder a most parsimonious evolutionary scenario, the duplicated genes in the optimal triple infer the in-paralogs in each genome, whereas the bijection between the nonduplicated genes in the two genomes infers a subset of the orthology pairs [more specifically, positional orthologs (. In the following, we apply our method to infer in-paralogs and orthologs on both simulated datasets and biological datasets and compare its performance with MSOAR.
Results on simulated datasetsWe simulate a pair of genomes as follows. We start from an ancestor genome with only one linear chromosome consisting of N  5000 singletons (we also test N  1000 and N  2000; the results are not presented since they agree with N  5000). We then perform S 1 segmental duplications on the ancestor genome to make some gene families contain more than one copy. A segmental duplication randomly chooses a segment of length L and inserts its copy to another random position. The two extant genomes then speciate independently from this ancestor genome. The speciation process on each branch includes randomly mixed S 2 segmental duplications and D DCJs. A DCJ randomly chooses two positions in the genome and then reverses the segment in between. We make sure that the expected number of genes per gene family in each extant genome is 1.5 (this number is comparable to that in human genome, which is 1.46), therefore we have that S 1  S 2  0:5  N=L. We further fix S 1  0:2  N=L and S 2  0:3  N=L (we also test S 1  0 and S 2  0:5  N=L, and the results are almost the same). Thus, a simulation configuration is determined by parameters L and D. For each pair of simulated genomes X and Y, we take them as input to run MSOAR and our method. For MSOAR, we run its binary version downloaded from http://msoar.cs.ucr.edu/. For our method, we first apply the preprocessing algorithm described in Section 4 and then formulate the simplified problem as an ILP instance, which is solved using the GUROBI solver. We set the time limit to 2 h for each instance, i.e. if the ILP solver does not return the optimal solution in 2 h, we terminate it and return the current sub-optimal solution. Both methods return triples (S, T, B), where S and T infers the in-paralogs in the two extant genomes, respectively, and B infers the orthology pairs. We now give the measures to evaluate them. First, we regard the problem to infer in-paralogs as a standard binary classification problem: those genes that are generated by segmental duplications in the speciation process are considered as gold standard positive in-paralogs and those genes that are in the segments in S [T are considered as predicted positive in-paralogs. Thus, we use the sensitivity and specificity to measure (S, T). To evaluate the performance of B, we refer to those gene pairs in the two extant genomes that correspond to the same gene in the ancestor genome as the true orthology pairs. We therefore use the following way to evaluate B: we say a pair in B is assessable, if at least one of its two genes can be found in some true orthology pair, and the accuracy ofComparing genomes with rearrangements and segmental duplications i335 B is then defined as the ratio between the number of true orthology pairs in B and the number of assessable pairs in B. For each parameter configuration, we simulate 10 instances and compute the average sensitivity, specificity and accuracy for both methods. The performance of the two methods is shown in10, where the parameters L 2 f1; 2; 5g and D ranges from 250 to 2000. First, we can observe that both methods get very high sensitivity (above 90% on all configurations). However, MSOAR gets relatively low specificity. One reason for this is that MSOAR uses unit cost for both rearrangements and single-gene duplications. According to the discussion in Section 5, unit cost for all operations might misclassify in-paralogs. Second, as D increases, the performance of both methods decreases. This is because the number of DCJs is highly positively correlated to the difficulty of the problem. When D 500, i.e. roughly 10% of the size of the simulated genome (which is usually the case for real genomes, seecolumns d(B) for some examples), we can see that our method almost gets perfect performance. Third, observe that MSOAR is very sensitive to L even when D is very small. This might be because the evolutionary model for in-paralogs in MSOAR is single-gene duplication, which creates trouble when genomes contain long segmental duplications. Finally, our method outperforms MSOAR on all the configurations.
Results on biological datasetsWe compare both methods on five mammalian species, human (H.s.), gorilla (G.g.), orangutan (P.a.), mouse (M.m.) and rat (R.n.). For each species, we collect all the protein-coding genes and download their positions on the chromosomes and the Ensembl gene family names from Ensembl (http://www.ensembl.org). Two genes are considered as homologous if they have the same Ensembl gene family name. Since the tandemly arrayed genes (TAGs) have a different evolutionary model from segmental duplications, we merge each group of TAGs into only one gene through only keeping the first gene in the group while removing all the following ones. We do the pairwise comparison for all five species, and for each pair of species, we run both methods to obtain triples (S, T, B). We use the same accuracy defined in Section 6.1 to evaluate B. To compute the accuracy, we use the gene symbols (HGNC symbols for primate genes, MGI symbols for mouse genes and RGD symbols for rat genes, downloaded from Ensembl) to define true orthology pairs: those gene pairs that have the same gene symbol form the set of true orthology pairs for each pair of species. We do not have annotation data to serve as gold standard positive in-paralogs (we cannot just regard those genes that are not in the true orthology pairs as gold standard positive in-paralogs, since many genes have not yet been assigned a valid gene symbol). Thus, we are not able to compute the sensitivity and specificity of (S, T).The solid lines and dashed lines track our method and MSOAR, respectively. The circles, triangles and diamonds track L  1, L  2 and L  5, respectivelyBold values highlight larger accuracy. The last column shows the running time of MSOAR (in min).
Table 2. Comparison with MSOAR on inferred operations and total scoreSpecies pairs jSj  jTj d(B) Total cost MSOAR ILP MSOAR ILP MSOAR ILP The comparison on accuracy is shown in. We can observe that both methods have very high accuracy, indicating that the inferred orthology pairs from gene order data mostly agree with the annotations. On the other hand, our method gets higher accuracy than MSOAR on all the 10 pairs. The running time of MSOAR is also shown in. On average, for each instance, MSOAR takes 108 min, which is on the same level with our method (120 min for each instance). In, we compare the number of operations and total score inferred by the two methods to evaluate their ability as an optimizer. First, we can see that our method gets more segmental duplications and many fewer DCJs than MSOAR. One reason for this is that we use smaller weight for segmental duplications. Second, our method gets smaller total cost on all the 10 pairs. This shows the advantage of our exact algorithm over the heuristic applied in MSOAR. Notice that the total cost shown inis computed using our weight, i.e. dB  0:75  jSj  jTj, for both methods. However, if the total cost is computed using MSOAR's weight, i.e. dB  jSj  jTj, our method still has less total cost on all pairs. In, we analyze the distribution of the length of the inferred duplicated segments by our method. We can see that most of them are single-gene duplications. We can also observe that the rat genome contains more duplications than the other four genomes. In, we analyze the composition of B returned by our method. If a gene family is a singleton in both genomes, then this pair of genes cannot be duplicated and must be mapped to each other by definition. We call such pair a trivial pair. Observe that roughly half of the pairs in B are trivial pairs (trivial column). We also show the percentage of the pairs that are fixed through the preprocessing algorithm (predetermined column). We can see that this preprocessing algorithm is very efficient, which can fix almost all the nontrivial pairs, leaving a very small portion (remaining column) that are to be determined by the ILP. This is because these species contain many shared segments and many isolated genes (because most of the segmental duplications are single-gene duplications), and thus there are many optimal substructures that can be identified by our algorithm.
Conclusion and discussionWe proposed an exact algorithm to compute a set of DCJs and segmental duplications with minimum total cost between two given genomes. As far as we know, this is the first exact algorithm to compare two genomes in the presence of duplicated genes with both rearrangements and content-modifying events. This algorithm can be applied to infer in-paralogs and orthologs, and the inferred results were showed highly agreeing with the annotations. The algorithm described in Section 4.2 has potential to extend. For example, it can be directly used to test whether a general substructure, rather than a single PHFSS, is optimal. Moreover, we made a strong assumption that all genes in the related gene families are isolated, which immediately makes the cost of the segmental duplications trivial to compare and thus allows us to focus on the number of cycles. In fact, we can relax this assumption, as long as we can guarantee that the segmental duplications induced by the substructure that is tested is optimal. Although the evolutionary model used in our algorithm, i.e. DCJ plus segmental duplication, is already quite general, there are some other events, like tandem duplications, that cannot be explained by this model. We will extend our algorithm for more general models in the future.
M.Shao and B.M.E.Moret at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
^ B2B ^ XnS; ^ Y nT d ^ B  min B2BXnS;YnT dB; and the optimal B can be recovered from the optimal ^ B through discarding the pairs with capping genes. This statement allows us to add capping genes to remove telomeres on the two given genomes without affecting the optimal bijection. Since the two new genomes ^ X and ^ Y do not contain telomeres, we have that for any triple Q  S; T; ^ B, where S & SX, T & SY and ^ B 2 B ^ X n S; ^ Y n T, both G(Q) and G 0 Q contain only cycles (Fig. 2). This property allows us only to count the number of cycles when computing the DCJ distance, which simplifies the following ILP formulation. 3.3 ILP formulation Let X and Y be two given genomes after adding capping genes. Let Q   S  ; T  ; B   be the optimal triple minimizing X s2S  [T  cs  dB  , where we have S  & SX; T  & SY and B  2 BX n S  ; Y n T  . (Notice that here X and Y may contain capping genes, but we define SX and SY are in terms of the original genomes, which do not contain segments with capping genes.) To facilitate our description, we use a 2 X to denote that gene a is contained in genome X. We use a 2 s to denote that gene a is contained in segment s. We denote by f a the gene family to which gene a
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
