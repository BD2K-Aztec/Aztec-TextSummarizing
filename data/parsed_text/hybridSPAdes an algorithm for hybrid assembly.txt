Motivation: Recent advances in single molecule real-time (SMRT) and nanopore sequencing technologies have enabled high-quality assemblies from long and inaccurate reads. However, these approaches require high coverage by long reads and remain expensive. On the other hand, the inexpensive short reads technologies produce accurate but fragmented assemblies. Thus, a hybrid approach that assembles long reads (with low coverage) and short reads has a potential to generate high-quality assemblies at reduced cost. Results: We describe HYBRIDSPADES algorithm for assembling short and long reads and benchmark it on a variety of bacterial assembly projects. Our results demonstrate that HYBRIDSPADES generates accurate assemblies (even in projects with relatively low coverage by long reads) thus reducing the overall cost of genome sequencing. We further present the first complete assembly of a genome from single cells using SMRT reads. Availability and implementation: HYBRIDSPADES is implemented in Cþþ as a part of SPAdes genome assembler and is publicly available at
IntroductionWhile de novo sequencing from long and inaccurate SMRT reads results in accurate assemblies (), these projects require high coverage of a genome by reads and thus remain expensive. Moreover, for Oxford Nanopore technology (with even higher error rates than in SMRT reads), accurate de novo assemblies remain challenging even in high coverage sequencing projects (). For example, the highest reported accuracy of assemblies from Oxford Nanopore reads (99.5%) is significantly below the acceptable standards for finished genomes. On the other hand, recently developed hybrid approaches for assembling long (and inaccurate) and short (and accurate) reads proved to be useful in generating high-quality assemblies at a relatively low cost (). In some complex applications (e.g. metagenomics and single cell genomics), the hybrid approaches may represent an attractive alternative to de novo assembly for long reads. We describe HYBRIDSPADESa hybrid assembly approach that benefits from synergy between accurate short and error-prone long reads. HYBRIDSPADES uses the same algorithms for both Pacific Biosciences reads (about % 14% error rate) and Oxford Nanopore reads (an even higher error rate), e.g. recently, HYBRIDSPADES was applied to studies of bacterial plankton using assembly of Illumina and Pacific Biosciences reads () and for analyzing antibiotics resistance using assembly of Illumina and Oxford Nanopore reads ().We benchmark HYBRIDSPADES against other hybrid assembly tools () and demonstrate that it enables accurate assemblies even in the case when the number of long reads is relatively small. We further show that HYBRIDSPADES works well even in the difficult case of single cell genome assembly resulting in the complete circular chromosome assembly of the elusive Candidate Phylum TM6 () that remains uncultivated.
ApproachWhile the de Bruijn graph approach currently dominates the short reads sequencing projects, its applications to assembling long reads faces various challenges. Indeed, high error rate in long reads makes it difficult to construct the de Bruijn graph from long reads for any reasonable choice of the k-mer size. As a result, the existing de novo long read assemblers use the overlap-layout-consensus approach instead of the de Bruijn graph approach (). Thus, one has to choose between the de Bruijn graph and the overlap-layout-consensus approaches while assembling short and long reads. SPADES constructs the de Bruijn graph from short reads and transforms it into an assembly graph (). The assembly graph is defined as the condensed and simplified de Bruijn graph () of k-mers in reads after removal of bulges, tips and chimeric edges. After SPADES constructs the assembly graph, HYBRIDSPADES uses long reads for gap closure and repeat resolution in this graph. EXSPANDER () is a module of SPADES that utilizes various sources of data (e.g. multiple paired-end or mate-pair libraries) for resolving repeats and closing gaps in assembly. EXSPANDER is a modular and easily extendable algorithm based on the path extension framework (). Given a path in the assembly graph, EXSPANDER iteratively attempts to grow it by choosing one of its extension edges (all the edges that start at the terminal vertex of this path). The choice of the extension edge is controlled by the EXSPANDER decision rule () that evaluates how well this extension edge is supported by data (e.g. paired reads). Thus, in order to incorporate the repeat resolution by long reads in the EXSPANDER framework, one has to represent each long read as a read-path, the path in the assembly graph that spells out the errorfree version of the long read. HYBRIDSPADES uses a new decision rule in EXSPANDER that is based on the analysis of these read-paths. In addition to resolving repeats in the assembly graph constructed from short reads, long reads can also contribute to closing the coverage gaps in this graph. In the case when a coverage gap is spanned by multiple long reads, one can fill in the gap by constructing the consensus of long reads within the gap's span (). Overall, HYBRIDSPADES includes the following steps: 1. Constructing the assembly graph from short reads using SPAdes; 2. Mapping long reads to the assembly graph and generating readpaths; 3. Closing gaps in the assembly graph using the consensus of long reads that span the gaps; 4. Resolving repeats in the assembly graph by incorporating long read-paths into the decision rule of EXSPANDER.
Methods
Mapping long reads to the assembly graphGiven a set of short reads SHORTREADS, DB k ShortReads; k is the de Bruijn graph constructed on all k-mers from this set. SPAdes uses various graph simplification procedures () to transform the de Bruijn graph DB k  ShortReads; k into the assembly graph DB  k  DB  k ShortReads; k. In this section we describe an algorithm for analyzing how each long read Read traverses the graph DB  k resulting in a read-path Path(Read). Similarly to BLASR tool for SMRT reads alignment (), HYBRIDSPADES selects a seed length t (the default value t  13) and maps t-mers in long reads to edges in the assembly graphs that contain these t-mers. This information is used to find out how each long read traverses DB  k. To answer this question, we first find out how a long read traverses edges in the assembly graph.
Mapping t-mers from reads to the assembly graphHYBRIDSPADES transforms each long read into a set of t-mers and finds positions of these t-mers on the edges of the assembly graph. Note that t-mers starting at the first positions or ending at the last positions of an edge map to a vertex in the assembly graph. Thus, since such t-mers may be assigned to multiple edges incident to these vertices, we exclude them from further consideration. Given a t-mer shared by a read and an edge in the assembly graph, we define its t-mer mapping as a triple (e, i, j) where e is an edge in the assembly graph where the t-mer is mapped, and i and j are the positions of the t-mer on this edge and in the read, respectively. Since there are many spurious t-mer mappings, the fact that a tmer in a read Read maps to an edge in the assembly graph does not necessarily mean that the read-path Path(Read) traverses this edge. However, our analysis revealed that for nearly all reads, if more than MinSeedNumber t-mers in a read map to an edge in the assembly graph then the read-path traverses this edge (the default value MinSeedNumber  8). We therefore say that an edge in the assembly graph is supported by a read if at least MinSeedNumber t-mers in this read map to this edge.
Mapping long reads to edges of the assembly graphConsider mappings e 1 ; i 1 ; j 1  and e 2 ; i 2 ; j 2  of two t-mers from a given read. Define d read  jj 2  j 1 j and d graph as the distances between these t-mers in the read and in the assembly graph, respectively. d graph is defined as follows: if the mappings share the same edge and i 1 < i 2 , the distance is i 2  i 1 , otherwise it is the length of the shortest path in the assembly graph from the position i 1 on edge e 1 to position i 2 on edge e 2. A mapping e 1 ; i 1 ; j 1  is a predecessor of mapping e 2 ;the distance along the read is not too small as compared to the distance in the assembly graph; @BULLET d read =d graph c 2 if these t-mers map to the same edge in the assembly graph, i.e. the distance along the read is not too large as compared to the distance along a single edge in the assembly graph. This condition is not enforced if two t-mers map to different edges in the assembly graph since the read-path between these edges is not necessarily the shortest path in the assembly graph; @BULLET both d read and d graph are smaller than c 3 .The default values of parameters c 1 , c 2 and c 3 are 0.7, 1.3 and 500, respectively. We further construct a directed graph GraphDB  ; Read using the set of all t-mer mappings from the read Read as the vertex-set. We connect vertices (t-mer mappings) in this graph by a directed edge if the first one is a predecessor of the second. Since the resulting graph is acyclic (every edge connects a mapping with a smaller read coordinate to a vertex with a larger read coordinate), we can find a longest path in this graph using a fast dynamic programming algorithm. Next, we determine how the found path through t-mer mappings in the graph GraphDB  ; Read traverses long edges of the assembly graph. Since there are many spurious t-mer mappings, we limit attention to the sequence of edges EdgeSequence(Read) in this path that are supported by the given read Read. Note that EdgeSequence(Read) may have some missing edges as compared to the correct read-path Path(Read). Our goal now is to reconstruct these missing edges that often aggregate into complex subgraphs in the assembly graph.
Mapping long reads to complex subgraphsof the assembly graph Consider two consecutive edges in the sequence EdgeSequence(Read) that are not consecutive in the assembly graph. Our goal is to figure out how the correct read-path Path(Read) traverses the assembly graph between these edges.depicts two consecutive edges from EdgeSequence(Read) (shown in red) that are separated by a complex subgraph in the assembly graph. We need to determine which of the alternative paths between these edges in the assembly graph inare traversed by Path(Read). Given a path Path in a directed graph with edges labeled by characters from a given alphabet, we define String(Path) as the concatenation of labels of the edges from Path. We define the edit distance dString 1 ; String 2  between strings String 1 and String 2 as the minimum total cost of substitutions and indels needed to transform one string into another (we assume that every substitution has cost l and every indel has cost r). Our goal is to solve the following problem: Graph Alignment Problem: Find a path between two given vertices of the labeled directed graph that spells out the string with minimal edit distance to the given string (among all possible paths between these vertices). Input: A string String and a labeled directed graph Graph with vertices source and sink. Output: A path Path in Graph minimizing dString; StringPath over all possible paths in Graph from source to sink. A brute-force solution of this problem (in the context of hybrid assembly) is to enumerate all possible paths between two long edges (within a certain range of lengths) and to find a path with the minimum edit distance to the long read. While this approach works for bacterial genomes and is used in the current HYBRIDSPADES implementation, the number of paths may be exponential in the number of vertices of the assembly graph. Below we describe a polynomial algorithm for solving the Graph Alignment Problem. Given a labeled directed graph Graph and a string String, we define a graph Graph(String) with the vertex-set corresponding to the pairs hv; ii where v is a vertex in Graph and i 2 0; jStringj. In order to define the edge-set of Graph(String), we specify the incoming edges to the vertex hv; ii as follows:It is easy to see that each series of edit operations with total cost score between String and a string spelled by a path from source to sink in Graph corresponds to a path of length score between hsource; 0i and hsink; jStringji in Graph(String). Therefore, in order to solve the Graph Alignment Problem, we need to find a shortest path between hsource; 0i and hsink; jStringji in Graph(String). Since this graph may have directed cycles, we use the Dijkstra algorithm () with the worst caserunning time OjE 0 j  jV 0 jlogjV 0 j, where V 0 and E 0 are the vertexset and edge-sets of the graph Graph(String), respectively. In the case of the hybrid assembly, since there are at most 4 outgoing edges for each vertex in the assembly graph, there are at most 4  1  4  9 outgoing edges for each vertex in the graph Graph(String). Thus, since the total number of edges in Graph(String) is OjVj  jStringj, the running time of the algorithm is OjVj  jStringj  logjVj  jStringj, where V is the vertex-set of the assembly graph. In the context of a typical assembly graph, jVj is much larger than jStringj. Also, for the majority of reads, there exists a path of length approximately jStringj between source and sink in the assembly graph. Therefore, we can ignore all the vertices of DB  k that are farther than jStringj from both source and sink while searching for a path with the minimum edit distance.
Closing coverage gaps in the assembly graphAlthough the coverage by short reads is rather uniform in most assembly projects, there are sometimes significant drops in k-mer coverage () and even regions where the k-mer coverage drops to zero. However, these drops in the k-mer coverage rarely affect repetitive edges in the assembly graph since it is unlikely that they occur in all copies of a repeat. Below we focus on gaps in the k-mer coverage that occur within a unique (non-repetitive) region of a genome corresponding a single edge in the assembly graph. A coverage gap breaks this edge into two edges that we refer to as a sink edge (ending in a vertex without outgoing edges) and a source edge (starting in a vertex without incoming edges). If a long read maps to both a sink and a source edge, then this read can potentially close a gap in the assembly graph. However, a single errorprone long read spanning the gap does not allow one to accurately close a gap, i.e. to reconstruct the nucleotide sequence of the gap. We thus collect the set of all long reads spanning the same pair of sink and source edges (forming the set of reads SpanningReads) and close the coverage gap using the consensus sequence of all these reads. For each read from SpanningReads, we align this read against the sink edge (ending at position p of the read) and the source edge (starting at position q of the read). The segment of the read from position p  1 to q  1 represents an error-prone sequence of the gap. HYBRIDSPADES fills in the gap by solving the Multiple String Consensus Problem () for all such segments derived from SpanningReads. To solve this problem, we apply the Partial Order Graph approach () and use its ConsensusCore library implementation from Pacific Biosciences that proved to work well for SMRT reads ().
Repeat resolution in the assembly graphThe read-against-graph alignment algorithm described above allows one to map each long read to a read-path in the assembly graph. During the repeat resolution stage of HYBRIDSPADES, we limit attention to paths traversing at least two long edges in the assembly graph. Our goal is to transform this set of paths into contigs that represent the genome assembly. Below we explain how to achieve this goal using the EXSPANDER repeat resolution framework (). EXSPANDER iteratively constructs a set of paths Paths that represent contiguous segments of the genome. In the beginning, Paths is formed by paths consisting of single long edges in the assembly graph. EXSPANDER attempts to iteratively extend each path in Paths using its decision rule (see Section 2). If multiple extension edges pass the decision rule for a given path (which usually implies that this path ends in a difficultto-resolve repeat), EXSPANDER stops the extension process for this path. Given a path P and its extension edge e, EXSPANDER defines the scoring function score P e and bases its decision rule on analyzing all values score P e for all extension edges. Below we describe how HYBRIDSPADES defines score P e. Read-paths P 0 and P 00 overlap if a suffix of P 0 (i.e. the path formed by the last i edges of P 0 ) coincides with a prefix of P 00 (i.e. the path formed by the first i edges of P 0 0). We define overlapP 0 ; P 00  as the longest suffix of P 0 that coincides with a prefix of P 00. A read-path is called trivial if it consists of a single edge and nontrivial otherwise. Since trivial read-paths do not contribute to the repeat resolution, we exclude them from further consideration. Note that there are typically multiple reads with the same read-path, at least in projects with high coverage by SMRT reads. We define multiplicity of a read-path as the number of long reads resulting in this read-path and classify a read-path as reliable if its multiplicity exceeds 1 (SMRT datasets have many chimeric reads that typically have multiplicity 1). Let ReadPaths be the set of all non-trivial reliable read-paths and
.. e n coincides withReadPath, and at least one of edges from e i. .. e j is non-repetitive. Given a path P and a set of read-paths ReadPaths, we define ReadPaths P as the set of all read-paths from ReadPaths that follow P. Given an extension edge e of a path P, we define score P e as the total multiplicity of read-paths in the set ReadPaths Pe , where P  e is the path P extended by the edge e. If a path P has an extension edge e whose score dominates scores of all other extension edges (i.e. exceeds them by a factor of at least c), HYBRIDSPADES extends P by e (the default value c  2). Otherwise, the extension procedure stops. If the highest scoring extension edge does not dominate the scores of all other extension edges, exSPAnder applies the standard extension rules based on read-pairs ().
Results
DatasetsWe analyzed datasets combining short and long reads from E.coli str. K12 (datasets ECOLI100, ECOLI200 and ECOLI-NANO), M.ruber (dataset MRUBER), Streptomyces sp. PAMC26508 (dataset STREPTO) and candidate division TM6 bacterium TM6SC1 (dataset TM6). The reads in the latter dataset were generated from single cells amplified with the Multiple Displacement Amplification (MDA) technology (). Prior to this study, the genome of TM6SC1 was only partially assembled (seethat the strain used for generating these datasets differs from the reference sequence of E.coli str. K12 (three insertions of mobile elements about 1 kbp in length). These differences result in six breakpoints that are reported as six assembly errors by the assembly evaluation tool QUAST (). We thus ignored these six (pseudo) errors while benchmarking various assemblers.Illumina reads (265  coverage) generated from MDA-amplified single cells. The Illumina reads were generated with Genome Analyzer IIx (read length 100 bp, mean insert length 270 bp). Note that MDA-based single cell approaches result in highly uneven genome coverage by reads (). The links to all the datasets and reference genomes are available in supplementary materials.
Software toolsWe benchmarked HYBRIDSPADES (as a part of SPADES 3.6 release), Cerulean () and PBcR () (version wgs-8.3rc1). In the hybrid mode (that we refer to as hybridPBcR), PBcR uses short Illumina reads to error-correct the long (SMRT or Nanopore) reads. In the self-correction mode (that we refer to as selfPBcR) PBcR only uses long reads for assembly. We used the QUAST assembly evaluation tool () for benchmarking. While QUAST reports many assembly metrics, the benchmarking tables below are limited to NG50, NG75, LG50, the length of the longest contig, and the number of misassemblies (MA), where NG50 is the length for which the collection of all contigs of that length or longer covers at least half of the reference genome, NG75 is defined similarly to NG50 with 75% of reference genome instead of 50%. LG50 is the number of contigs longer or equal than NG50. Although AllPaths-LG () has a hybrid mode for assembling short and long reads, we did not have an opportunity to benchmark it since none of the datasets described above satisfy the strict constraints on the insert sizes imposed by AllPaths-LG. The field of hybrid assembly has been rapidly developing in the last year when the Oxford Nanopore assembly pipeline Nanocorrect (), hybrid Nanopore & Illumina assembly pipeline NanoCorr () and hybrid scaffolder LINKS (were added to the arsenal of tools for assembling Oxford Nanopore reads. However, Nanocorrect and NanoCorr focused on Oxford Nanopore reads rather than Pacific Biosciences reads. We and others () demonstrated that HYBRIDSPADES works well for hybrid assembly with both Pacific Biosciences and Oxford Nanopore reads.
BenchmarkingHYBRIDSPADES and selfPBcR assembled both ECOLI100 and ECOLI200 datasets in a single contig (). As expected, both HYBRIDSPADES and selfPBcR resulted in six (pseudo) assembly errors caused by the known differences between the analyzed and the reference strains (three insertions of mobile elements). selfPBcR produced two additional (real) misassemblies and HYBRIDSPADES produced one. Cerulean and hybridPBcR generated more fragmented assembly and, in case of Cerulean, more misassemblies for ECOLI100 dataset. For ECOLI200 dataset, both Cerulean and hybridPBcR generated inferior assemblies. In addition to hybrid assembly of Illumina and SMRT reads, HYBRIDSPADES also assembled ECOLI-NANO dataset into a single contig. All other tested assemblers failed to assemble this dataset. We have also investigated how the performance of HYBRIDSPADES and PBcR deteriorates when the coverage by long reads is reduced. To perform this analysis, we retained a fixed fraction of randomly chosen SMRT reads resulting in coverage varying from 200 to 6.25. Asillustrates, even with low 12.5  coverage by SMRT reads, HYBRIDSPADES generates a high-quality assembly (better than PBcR with 50  coverage). The quality of PBcR assemblies deteriorates when the coverage falls below 50. selfPBcR assembled MRUBER dataset into a single contig with a single misassembly, while HYBRIDSPADES assembled this dataset into three error-free contigs with zero misassemblies (). HYBRIDSPADES failed to assemble this dataset into a single contig because long reads in this dataset do not span over a long 7 Kbp repeat. hybridPBCR produced an assembly with quite similar stats. Cerulean produced lower quality assembly, HYBRIDSPADES generated a high-quality assembly of STREPTO dataset with NG50 % 883 Kbp (2 misassemblies), while Cerulean generated an assemblyFor each parameter we boldfaced the best results. Longest contig, NG50 and NG75 were compared with reference (4639675 bp). We did not run various genome polishing tools like Quiver () since our benchmarking focused on assembly errors rather than basecalling errors.with NG50 % 645 Kbp and 10 misassemblies (). hybridPBcR failed on this dataset while selfPBcR produced a low-quality assembly due to the low coverage by SMRT reads. In contrast to the previous assemblies of SMRT reads in single cell genomics () that came short of closing the assemblies, application of HYBRIDSPADES to TM6 dataset resulted in a single circular contig of length 1089 Kbp (which contains all previously sequenced seven long contigs with total length 1075 Kbp (). To the best of our knowledge, it is the first assembly of SMRT reads in single cell genomics that resulted in a complete genome. Since prior to this study, TM6 genome was incomplete, we used the genome assembled by HYBRIDSPADES to evaluate performance of other assemblers on this dataset. Cerulean generated an assembly with the largest contig of length 774 Kbp and 1 misassembly (). hybridPBCR failed on this dataset while selfPBcR produced a low-quality assembly. Our benchmarking demonstrated that HYBRIDSPADES improves on the state-of-the-art hybrid assemblers on all datasets we have analyzed (on two of these datasets with a high SMRT read coverage, selfPBcR showed similar results).
ConclusionsEarly tools for hybrid assembly combined Illumina and Sanger reads or Illumina and 454 reads (). However, hybrid assembly of Illumina and SMRT reads presents new algorithmic challenges since SMRT reads have higher error rates than Sanger reads or 454 reads. Our benchmarking demonstrated that HYBRIDSPADES assembles short accurate and long error-prone reads into long and accurate contigs. The resulting low-cost high-quality assemblies are important for accurate genome annotations and comparative genomics. Moreover, HYBRIDSPADES opens a possibility to complete genomes assembled from single cells. Although 1000 s of bacterial genomes have been assembled from single cells in the last 3 years using specialized single cell assemblers SPAdes () and IDBA-UD (), finishing genomes amplified from single cells is often viewed as an impossible task (). Moreover, sequencing single cell genomes from SMRT reads is likely to be excessively expensive due to highly non-uniform coverage characteristic of the MDA-amplified datasets. Hybrid assembly of short and long reads, on the other hand, turns complete genome assembly from single cells into reality. While the detailed analysis of the relative market costs and trade-offs of various sequencing technologies remained beyond the scope of this article, we anticipate that many future sequencing projects will use hybrid assembly of reads generated by various technologies.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
D.Antipov et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
