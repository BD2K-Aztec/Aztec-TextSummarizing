Motivation: Multiple sequence alignment is a basic part of much biological research, including phylogeny estimation and protein structure and function prediction. Different alignments on the same set of unaligned sequences are often compared, sometimes in order to assess the accuracy of alignment methods or to infer a consensus alignment from a set of estimated alignments. Three of the standard techniques for comparing alignments, Developer, Modeler and Total Column (TC) scores can be derived through calculations of the set of homologies that the alignments share. However, the brute-force technique for calculating this set is quadratic in the input size. The remaining standard technique, Cline Shift Score, inherently requires quadratic time. Results: In this article, we prove that each of these scores can be computed in linear time, and we present FASTSP, a linear-time algorithm for calculating these scores. Even on the largest alignments we explored (one with 50 000 sequences), FASTSP completed <2 min and used at most 2 GB of the main memory. The best alternative is QSCORE, a method whose empirical running time is approximately the same as FASTSP when given sufficient memory (at least 8 GB), but whose asymptotic running time has never been theoretically established. In addition, for comparisons of large alignments under lower memory conditions (at most 4 GB of main memory), QSCORE uses substantial memory (up to 10 GB for the datasets we studied), took more time and failed to analyze the largest datasets. Availability: The open-source software and executables are available online at
INTRODUCTIONEstimation of multiple sequence alignments for molecular datasets is fundamental to many problems in biology, including the prediction of protein function and structure and phylogeny estimation. Estimated alignments are often compared with other alignments in order to assess accuracy or to determine the features shared by two or more alignments. In addition, since different alignment methods can produce alignments that differ enough to introduce phylogenetic uncertainty () and alignment error increases with the size of the dataset (), the use of several alignments, and comparisons of these alignments, is advisable for large-scale phylogenetic studies. * To whom correspondence should be addressed.Of the various methods for comparing an estimated alignment to a reference alignment, four are generally in use: the Developer score (also called the SP-score, for sum-of-pairs), Modeler score, Total Column score and Cline Shift Score. The SP-score and Modeler scores are quite similar: the SP-score is the percentage of the homologies in the reference alignment that appears in the estimated alignment, and the Modeler score is the percentage of the homologies in the estimated alignment that appears in the reference alignment. Thus, each can be obtained by computing the number of shared homologies and then normalizing by either the number of homologies in the reference or true alignment. The Total Column score is the number of alignment columns shared by both alignments, and can also be normalized by the number of columns in one of the alignments. Finally, the Cline Shift Score () is computed by averaging the Cline Shift scores for each of the induced pairwise alignments. Each of these normalized scores ranges from 0% to 100%, with 0 indicating that the two alignments are maximally dissimilar for the criterion and 100% indicating that the two alignments are considered identical with respect to the criterion. Thus, these scores represent accuracy measures, and complementing these scores (subtracting them from 100%) produces the corresponding error metrics. While several methods have been developed for comparing alignments, only qscore () and Lobster (available online at http://www.drive5.com/qscore and http://www.drive5 .com/lobster, respectively) correctly compute the SP-score. However, the computational complexity of these methodsi.e. their asymptotic running timehas never been established. Clearly, all four scores can be computed in quadratic time using bruteforce techniques, and the Cline Shift Score (by definition) requires quadratic time. However, the SP-score, Modeler score and Total Column scores might not require quadratic time. In this article, we show that the SP-score, Modeler score and Total Column scores can each be computed in linear timetime where n is the number of sequences and k is the length of the longer alignment]. We present a method, FastSP, to compute the number of shared homologies between two alignments and prove that it runs in linear time. The result then follows, since each of the three scores can be obtained directly from this number. Since error scores are complements of these accuracy scores, FastSP can be used to compute error rates such as SP-FN (the percentage of true homologies missing in the estimated alignment) and SP-FP (the percentage of predicted homologies that are not present in the true alignment). Furthermore, FastSP can be used to evaluate the reliability of a given alignment with respect to a set of alignments, since it enables fast all-pairs comparisons. Thus, FastSP is a basic tool for analyzing sets of multiple sequence alignments.
FASTSPSeveral aspects of the algorithm design lead to the linear-time complexity of FastSP. First, we represent the set of homologies defined by a single multiple sequence alignment in an auxiliary data structure, and by toggling back and forth between the two representations of the alignment, we are able to implicitly represent the common homologies between a pair of alignments in linear time. We then show that computing the number of shared homologies from that implicit representation can also be done in linear time through the use of pre-computed values. We have also taken care with the memory usage in our implementation of FastSP; as a result, our code is not only fast, but also never used more than 2 GB on any of our datasets. We found that FastSP used much less memory than qscore, the fastest competitor. Thus, while FastSP and qscore had essentially the same running time when memory is unlimited (both completing in just a few minutes on all datasets), FastSP ran much faster when analyzing large alignments when the available memory was limited to 4 GB. Thus, FastSP improved upon all current methods for computing the accuracy scores between large alignments: it reduces running time on low memory conditions, and matches running time and reduces memory usage on high memory conditions.
APPROACHLet S be a set of n sequences over a fixed alphabet (where is arbitrary but is typically nucleotides or amino acids). Let A and A be two input alignments on S. We can define an alignment by its set of homologies, where a homology is a pair of letters from the input sequences that occur in the same site. Although the alphabet can be arbitrary, we will illustrate the definitions using nucleotides. Consider S ={s 1 ,s 2 } where s 1 = ACAT and s 2 = GA and alignment A be given byLet alignment A be given byThen these two pairwise alignments share no common homologies, even though both have a site that contains two A's. That is, we need to distinguish between the different occurrences of each nucleotide within each sequence. Thus, instead of writing s 1 = ACAT , we will write,4 , so that N i,j indicates that nucleotide N appears as the j-th letter of sequence s i (if we are interested in the actual nucleotides, we would save the information that N 1,1 = A,N 1,2 = C, etc.). Then the homologies defined by an alignment consist of pairs of these subscripted nucleotides. Thus,With this representation, it is clear that although both alignments contain sites that are uniformly occupied by the nucleotide A, they do not share any common homologies. This representation of an alignment as a set of homologous pairs extends to multiple alignments by taking the union of homologous pairs of each of the pairwise alignments induced by the multiple alignment. We will denote by H(A) the set of homologous pairs defined by the alignment A, and by h(A) =|H(A)|. Note that if A has R sites and r i non-gap letters in the i-th site, then h(. Thus, every alignment of n sequences with length R consists of O(Rn 2 ) homologous pairs. Under the assumption that the true alignment is known, the error in an estimated alignment can be defined in several ways. One of the various ways of defining this is the SP-FN error, where 'SP' stands for sum-of-pairs, and 'FN' stands for 'false negative'. Thus, the SPFN error of an estimated alignment is the number of homologous pairs in the true alignment that are missing in the estimated alignment (i.e. false negatives). Similarly, the SP-FP error is the number of pairs that are predicted to be homologous in the estimated alignment that are not present in the true alignment (i.e. false positives). Both quantities can be then normalized by the number of homologous pairs in the relevant alignment to produce a value between 0 and 1 (so that the SP-FN error is normalized by the number of homologies in the true alignment, and SP-FP is normalized by the number of homologies in the estimated alignment). As an example, suppose we have,s 4 = T and s 5 = G. Let alignment A on S be given byWe rewrite this asThe set H(A) of homologous pairs defined by A is thereforeNote that the first site in A has four nucleotides and hence contributes six homologous pairs to this set, whereas the second site has two nucleotides and so contributes only one homologous pair to the set. Now suppose A is another alignment on the same set S given byThen we rewrite A in the same way we rewrote A (using the N i,j notation), and obtain its set of homologous pairs as H(Thus, the set of homologies shared in common between these two alignments is H(A)H()}. If we were to treat one alignment (say, A) as the true alignment, then the alignment SP-FN error for A would be the
S.Mirarab and T.Warnownumber of homologies in A missing from A , or |H(A)H(A )|. In this particular case, that would mean that there were four missing homologies, since the two alignments shared three common homologies and A had seven homologies.
ALGORITHMThroughout this section, we will assume that we have two alignments A and A , each on n sequences, and with k the length of the longer alignment. Several brute-force approaches can be used to calculate the number of shared homologies between two alignments, and hence the true positive rate, as well as the false positive rate. For example, if each sequence has length at most L (in the unaligned form), then each alignment can be represented as a presence/absence matrix with nL rows and columns; consequently, the true positive rate thus can be calculated in O(n 2 L 2 ) time. However, we can calculate this quantity more efficiently, as we now show. We begin by defining an equivalence relation on the letters N i,j that appear in a site x of alignment A. We say that two elements of the x-th site are equivalent if they are in the same site of A. For a given site x in A and a given alignment A , there will be t equivalence classes (where an equivalence class is a maximal set of letters that are pairwise equivalent), and we let m(i) denote the cardinality of the i-th equivalence class. For example, the nucleotides that appear in site 1 in alignment A are N 1,1 ,N 3,1 ,N 4,1 and N 5,1. In this definition, N 1,1 and N 5,1 are equivalent since they appear in site 1 in A , and N 3,1 and N 4,1 are equivalent since they appear in site 2 in A. Thus, A defines an equivalence relation on these elements of two equivalence classes (one for each site in A ), each having two elements. Note then that the number of homologous pairs that are in common between A and A is the sum, over all the sites x in A, of the number of pairs of letters that appear in site x that are equivalent to each other. Furthermore, the number of such pairs contributed by an equivalence class of size z is exactly z(z2) 2. This means we can calculate the total number of common homologies by computing the equivalence relation defined by each site in A, and the number of elements in each of the equivalence classes for that site. We now show how to do this efficiently. The first thing we do is to replace the nucleotide entries in the alignment by entries of the form N i,j (i.e. we show the indices). In fact, the indices are the only things we need to knowwe do not need to know the actual nucleotides in each position of the alignment. Given this representation of the alignment, we then define an nk matrix Sof ordered pairs, so that S=(a,b) implies that N i,j appears in site a for alignment A and in site b for alignment A. If j is larger than the length of the i-th sequence (after gaps are removed), then we set Sto (0,0). As an example, given the alignments A and A from the previous section, we have n = 5 and k = 2. For this pair of alignments, we obtain S@BULLET Step 0: we set A(j) = j(j1) 2 for each j = 1,2,...,n. For each site x in alignment A, let b x be theSince N(x) is the number of shared homologies for site x in A, it follows that N is the total number of shared homologies. Hence the SP-FN score is H(A)-N. As an illustration, using the alignments A and A given previously, N(1) = 2, since the first site in A contains six homologous pairs, two of which are also present in A. Similarly we see that N(2) = 1. Therefore, m(, as expected. We now show how to compute N and h(A) efficiently. Consider a fixed site x in A. We examine alignment A and write down the (at most k) sites in A for the elements of site x. Then we examine each site x in A, and write down its nucleotides. For each i,j such that N i,j appears in site 1, we examine S. Since N i,j appears in site x for alignment A, S=(x,b), and hence N i,j appears in site b in alignment A. We then write down b in the list of sites in A associated with site x. That is, we note the set Sites(x) of A s sites y that appear, and the multiplicity m(y) with which each site y appears. As an example, consider the same pair of alignments A and A , as before. We examine the first site in A, and we see N 1,1 ,N 3,1 ,N 4,1 and N 5,1. We then examine S,S,Sand S. We see Sand S=(1,1). We write down the sequence 1,2,2,1, so that Sites(x) ={1,2}, and m(1) = m(2) = 2. This sequence gives us two equivalence classes, each of size two. Thus, m(1) = m(2) = 2. The algorithm will compute the following values: @BULLET List(x): the list of sites in A that appears in site x of A. This is initialized to the empty list. @BULLET m(y): a non-negative integer for the number of occurrences of y in, for each y that appears in List(x). This is initialized to 0 for all y = 1,2,...,k. @BULLET Processed(y): a Boolean variable that indicates that we have added A(y) to N(x). This is initialized to False for all y = 1,2,...,k. @BULLET N(x): a non-negative integer that will be). This is initialized to 0. To set all these values, we examine the site x in A. As we visit each element of site x in A, we append the site in A to List(x). Thus, for N i,j in site x of alignment A, with (a,b) = S, we note that a = x and b is the site in A for N i,j. We therefore append b to List(x). We initialize m(y)  0 for all y = 1,2,...,k, where k is the number of sites in A. We then scan List(x), and for each element y in List(x), we add 1 to m(y). At the end of the scan of List(x), all the counts m(y) are set properly, but Processed(y) is still False for every y. We process List(x) again. For each element y of List(x), if Processed(y) is False, we set N(x)  N(x)+A(m(y)), and set Processed(y) to True. Thus, A(m(y)) is added to N(x) exactly once during the pass through List(x). As we process List(x), we can also find out whether the entire column is aligned correctly (required for TC-score). Note that
FASTSPcolumn x is aligned correctly in A if and only if two conditions hold. First, there should exists only one value of y for which m(y) is non-zero. If there are multiple values of y with m(y) > 0, then the column x in A has been divided into multiple columns in A. Second, the number of characters in column y of A [call this quantity c(y)] should be equal to m(y). If the first condition holds but the second condition does not hold, the column in alignment A that corresponds to column x in A has some extra characters and should not be considered correctly aligned. Therefore, to compute the column score we need to check (for each column x in A) whether m(y) has non-zero values for only one y, and that c(y) = m(y). This can be easily checked while scanning elements of List(x) by keeping a count of non-zero m(y) values and by checking m(y) against c(y). Note that c(y), the number of characters in columns of A , can be easily computed and kept in memory as matrix S is being created. TC can be computed at the end by dividing the number of correctly aligned sites by the total number of sites in A. Columns that have only one non-gap character do not represent homology statements, and are ignored in the calculation of the TC-score. After processing site x, we reset all the variables to their initial values.
Running time analysis:recall that we have n sequences and the longer of the two alignments has k sites. Calculating the matrix Stakes O(nk) time, as follows. We initialize S=0 for all i,j. We rewrite each alignment so that we write each nucleotide in the form N i,j. We then visit each site in A, and for each nucleotide N i,j that appears in site x we set the first element of Sto x. We repeat this for A , and for each nucleotide N i,j that appears in site y in A we set the second element of Sto y. The preprocessing step of the algorithm involves the calculation of A(j) for each j = 1,2,...k, and so requires O(k) arithmetic steps involving numbers up to k; thus, the preprocessing costs O(k) (since each arithmetic step has unit cost). Calculating each N(x) involves O(n) operations, and hence calculating all N(x) involves O(nk) operations. Finally, calculatingwork. Thus, this algorithm costs O(nk) time, which is linear in the input size.
THE FASTSP CODEThe algorithm described above is implemented in a publicly available Java program, FastSP. The implementation has been designed to reduce the memory usage. Therefore, although FastSP keeps the reference alignment in memory as a list of strings, it does not keep the entire estimated alignment in memory; instead, it only keeps the matrix S. Also the first elements of the tuples defined for S are not necessary and therefore our implementation omits them. In addition, the number of columns in S can be reduced to the number of non-gap characters in the longest sequence in the reference alignment. Therefore, if the reference alignment has R sites and the longest sequence has L non-gap characters, then FastSP needs Ln integers (each 4 bytes) to store S, and Rn characters (each 2 bytes) to store the reference alignment. Since L  R, this means that FastSP needs only O(Rn) memory, and so scales linearly with the reference alignment size, and not also with the estimated alignment size. The implementation first reads the reference alignment and saves it in memory. It then reads the estimated alignment and creates the S matrix as an nk array of integers. Next, it iterates over the columns of the reference alignment. In each iteration, first, referring to matrix S, a data structure is created (using a Java HashMap) that for each column of the estimated alignment holds the number of letters in that column that correspond to a letter in the reference alignment column [similar to m(y) introduced before]. Then, A(x) = x(x1) 2 is evaluated for the elements in this data structure, and the sum of these values is added to the total number (N) of shared homologies. Each iteration also computes the number of homologies in the current column of the reference alignment, and adds this value to the total number of homologies in the reference alignment h(A). In addition, we keep track of the number of correctly aligned columns (C), using the technique described earlier. Once the iterations finish, N and h(A) provide the required information to compute the SPscore and Modeler score, and C provides the information required to compute TC. We tested our implementation on many different datasets, and compared SP, Modeler and TC scores computed to the scores computed using existing tools. For every case where there was a disagreement between our scores and those produced by other software, we were able to find a bug in existing tools (as described later in the article).
PERFORMANCE STUDY
DatasetsWe studied the performance of the proposed algorithm on a variety of datasets, both simulated and biological (seefor the dimensions of a representative sample of the alignments on each of these datasets). Our datasets were selected to span a wide range of alignment sizes, from 100 to 78 000 sequences. We used four simulated nucleotide datasets, three with 100, 500 and 1000 taken fromand one much larger dataset with 78 000 sequences from; these are all available online at http://www.cs.utexas.edu/users/phylo/datasets/ (). For the biological datasets, we included the datasets used in, taken from the Gutell Comparative Ribosomal Website (CRW) (http://www.rna.ccbb.utexas.edu/). For each of these datasets, we have a curated alignment based upon confirmed secondary (and higher order) structures, which is highly reliable. We also included another nucleotide alignment with 50 000 sequences, 16S.GG-50K, which is a random sample from a dataset of 237 882 sequences obtained from the Green Genes database (), and studied previously (). On every dataset, we obtained at least one (typically more than three) estimated alignments and a reference alignment. On the biological datasets, in all but one case we used an available curated alignment as the reference. In the case of 16S.GG-50k, no curated alignment was available; however, the original publication of this dataset includes an automatically created alignment (), which we used as our reference alignment. On the simulated datasets, we used the true alignment as the reference alignment. In total, our study involves the calculation of alignment scores for 75 pairs of alignments, one estimated and one reference alignment.
Alignment methodsWe included alignments estimated on these datasets using SAT (), MAFFT (), MAFFTPartTree (), Muscle (), Prank+GT (), Opal () and ClustalW in its default and Quicktree versions (). MAFFT-PartTree and ClustalWQuicktree methods are specifically designed to be used on very large datasets. Most of the alignments used in this article are available from the original studies. In addition, we obtained the following alignments. On 16S.GG-50k, we produced a PartTree alignment, and we produced SAT-II] alignments on the 16S.B.ALL, 16S.T and 16S.3 datasets. The alignment on the simulated dataset Price-78K is also one of the datasets obtained from. For the other simulated datasets, we ran MAFFT, ClustalW (in its default setting) and SAT-II (in its default setting) to obtain estimated alignments. These additional alignments were produced using ClustalW version 2.0.4 (downloaded from http://www.ebi.ac.uk/Tools/msa/clustalw2/), MAFFT version 6.240 (downloaded from http://mafft.cbrc.jp/alignment/software/) and SAT-II version 1.22 (downloaded from http://phylo.bio.ku.edu/ software/sate/sate.html). In the commands for each method, given below, <input> is a FASTA-formatted input file containing unaligned sequences and <output> is the resulting FASTAformatted output file. @BULLET ClustalW: clustalw2-align-infile=<input>-outfile=<output>-output=fasta @BULLET MAFFT: mafft localpair maxiterate 1000 quiet <input> > <output> @BULLET MAFFT-PartTree: mafft parttree retree 2 partsize 1000 <input> > <output> @BULLET SAT: python run_sate.py-i <input>
Methods for calculating the SP-scoreThere are a few existing programs that compute the SP-score, or can be modified to compute this. However, not all software claiming to compute the SP-score actually calculates it correctly. For example, although bali_score is widely used, it is now known () that this calculation is incorrect in some cases: bali_score ignores sites that have >20% gaps and also ignores sites that have a gap in the first sequence (). Our study used three programs in addition to FastSP to compute SP-scores: qscore () (also known as the PREFAB Q-score, and downloaded from http://www.drive5.com/qscore), Lobster (downloaded from http://www.drive5.com/lobster) and BigMatrix () (downloaded from http://www .cs.utexas.edu/users/kliu/public/BigDataMatrix.java). Lobster is a precursor to qscore, and BigMatrix implements a brute-force quadratic time algorithm for the SP-score; these are included in our experiments for completeness, but the main focus of the study is comparing qscore and FastSP. Our initial attempts to run qscore on large datasets failed (i.e. Q-scores >1 were produced). After corresponding with the author, we were able to diagnose the problem as an integer overflow, which we then solved by changing the code to use 64 bit integers (more precisely, we added the following line to fastq.cpp: #define unsigned int64_t). By default, qscore computes SP-and TC-scores, both of which by FastSP is computed as well. However, there is a problem with the way qscore calculates the TC-score. Consider the two alignments given byHere, we have four correctly aligned columns (1,3,4 and 5) and therefore correct TC-score is 0.67. qscore, however, considers the number of correctly aligned columns to be 5, giving 0.83 for TCscore. qscore considers column 2 as correctly aligned, persumably
FASTSPbecause all homologies in A are present in the same column in alignment A. It seemingly ignores the fact that column 2 of alignment A has an extra character. FastSP avoids this problem by making sure the associated column in the estimated alignment does not contain extra characters. qscore can also compute the Modeler score if run with extra options, but for reasons that are not clear to us, qscore runs much slower when computing Modeler score (see the line labeled 'qscore-modeler' in). Also, qscore can compute Cline Shift Score () if run with extra options, but that uses a different part of the qscore code that runs in quadratic time. We present results comparing qscore, qscore-modeler, Lobster, BigMatrix and FastSP for calculations of the SP-score. We used the following commands: @BULLET qscore: qscore-test <estimated alignment>-ref <reference alignment> @BULLET qscore-modeler: qscore-modeler-test <estimated alignment>-ref <reference alignment> @BULLET Lobster: lobster-score <estimated alignment>-ref <reference alignment> @BULLET BigMatrix: java-Xmx3500m BigDataMatrix-v <reference alignment>-f <estimated alignment>-sp @BULLET FastSP: java-Xmx2000m FastSP-e <estimated alignment>-r <reference alignment>
Evaluation procedureWe compared FastSP and qscore under three conditions64bit machines with 2 GB, with 4 GB or with 832 GB of the main memory. We also ran Lobster and BigMatrix on the 832 GB machines as well. In our first experiment, we performed the analyses on a dedicated 64-bit Linux machine, each with 4 GB of main memory. The subsequent experiments were performed on a heterogeneous Condor cluster (). We compared the SP-scores calculated by different programs to make sure they were identical. After the modification to qscore to ensure that it runs on all datasets, qscore, BigMatrix, Lobster and FastSP all produced the same SP-scores on all the datasets on which they were able to run. We also gathered data regarding the peak memory usage and the running time of each execution, as reported in the next section. We note that small differences in running times should not be considered significant, due to the conditions in which the experiments were run: heterogeneous machines with varying amounts of main memory (unless limited by JVM), and on machines that were being used by other processes.
RESULTS
First experiment: 4 GB machinesWe begin with a discussion of performance on machines with 4 GB of main memory.shows the running time as a function of the number of cells in the two alignments together, where 'cells' are the nucleotides and gaps; therefore, the number of cells is n(k 1 +k 2 ),where each alignment is on n sequences and the first alignment has k 1 sites and the second alignment has k 2 sites. Note that qscore failed to score the largest dataset, 16S.GG.50k, with 50 000 sequences, while FastSP successfully completed all analyses. For the remaining datasets, qscore and FastSP were equally fast on the smallest of these datasets, but FastSP was computationally more efficient than qscore on the larger datasets. In particular, on the largest of the datasets on which both methods ran, qscore took >5 min and FastSP finished in <1 min. Averaging over all 27 datasets with more than 10 million cells, and excluding the cases where qscore fails, the running times were 0.54 and 0.25 min and memory usages were 1.38 GB and 502 MB, respectively, for qscore and FastSP.
Second experiment: 2 GB machinesWe then examined the running time on machines with 2 GB of main memory (). As expected, qscore failed to complete the analysis of the 16S.GG.50k dataset, but it also failed to complete analyses of three pairs of alignments on the 16S.B.ALL dataset, which has 27 643 sequences. In contrast, FastSP completed its analyses of all the datasets under these conditions. Thus, reducing the memory from 4 GB to 2 GB resulted in more failures for qscore. Averaging over all 27 datasets with more than 10 million cells, and excluding the cases where qscore fails, qscore and FastSP took 1.18 and 0.21 min and used 931 MB and 366 MB of memory, respectively. Also, FastSP never used >3 min on any dataset, while qscore used 6 min on one of the larger datasets. All these results were obtained on 64 bit machines.with only 2 GB of main memory. We also reduced the memory available to JVM by changing JVM's-Xmx option. FastSP was able to successfully run on the 16S.GG.50k dataset using 1.47 GB of memory in 2.7 min. It also finished in 1.3 min using 865 MB of memory for 16S.B.ALL/PARTTREE, and 0.5 min and 773 MB of memory for 16S.B.ALL/SAT-II. The running times under these low JVM memory conditions are close to the running times reported on the 64 bit cluster machines, and indicate the robustness of FastSP to conditions with limited memory.
S.Mirarab and T.Warnow
Third experiment: large memory machinesOur third experiment compared FastSP to all three other methods (Lobster, BigMatrix and qscore) on machines with 832 GB of the main memory (). Although FastSP and qscore succeeded in completing all their analyses, Lobster and BigMatrix failed on several datasets. In particular, Lobster failed to analyze 14 of the largest datasets, including all alignments on 16S.T, Price-78K, 16S.GG.50k, and most alignments on 16S.B.ALL and on 16S.3, while BigMatrix failed to analyze the two largest datasets, Price78K and 16S.GG.50K.shows the running time, given in log scale, as a function of the total number of cells in both alignments together, as well as the regression line in log space for each method. In these analyses, we show results for qscore computing the default scores (SP and TC) and then also computing the Modeler score (indicated by qscoremodeler). Lobster was the slowest of the three methods, and BigMatrix was clearly much slower than either qscore or FastSP. FastSP and qscore took about the same time, and their running times increased at about the same rate. When qscore is run so that it computes the modeler score, it runs much slower, and its running time is not linear. Figures 4 and 5 provide a direct comparison of qscore and FastSP with respect to running time and peak memory usage,respectively, with qscore computing only the default scores (SP and TC). While the running times of FastSP and qscore were close, their peak memory usage differed substantially. These data show that the memory requirement of qscore scaled linearly with the total number of cells in both alignments, reaching 10 GB on the largest dataset. In contrast, the memory usage of FastSP grew more slowly. In the extreme case of the 16S.GG.50k dataset, qscore used 10 GB of peak memory, but FastSP never used more than 2 GB of peak memory.. Comparison of FastSP and qscore-default with respect to peak memory usage on machines with 'at least' 8 GB of main memory.
Page: 3257 32503258
FASTSP
DISCUSSIONThe main observations we can make are these. When run on machines with sufficient memory (at least 8 GB for these datasets we studied), FastSP and qscore have very close running times, but qscore has higher peak memory usage. Thus, even though the two methods are not distinguishable by running time in this case, they differ substantially in terms of memory usage. On the other hand, when memory is limited to 4 GB, the two methods have substantially different running times for large alignments. Thus, in general the two methods cannot be distinguished on alignments with small numbers of taxa, but are distinguished on large alignments either with respect to running time (if memory is limited to 4 GB) or with respect to memory usage (when memory is not limited). Although the methods have different running times, it is evident that the differences in running time are a result of differences in their memory usage. But, why do we see these differences? Recall that FastSP has memory usage that grows only linearly with the reference alignment size, and does not need to keep the estimated alignment in memory; this can reduce the memory usage substantially. The most likely explanation is a simple one: qscore uses more memory simply because it was not implemented with memory usage optimization as one of its objectives.
CONCLUSIONSThis article has two main contributions. First, we provide a proof that the number of shared homologies between two alignments can be computed in O(nk) time, where n is the number of sequences and k is the length of the longer alignment. Therefore, the SP-score, Modeler Score and Total Column scores can each be computed in linear time as well. Second, we present FastSP, a new linear-time method to compute these three scores, and we explore its performance on large alignments in comparison to the current best method, qscore. The implementation we provide runs efficiently and requires very little memory: even on the very largest alignments with 50 000 sequences and thousands of sites, FastSP finished in <2 min and used less than 2 GB of main memory. The best of the other methods for computing the SP-score is qscore. The comparison between FastSP and qscore shows that the two methods have roughly the same running time when run on large memory machines with 832 GB of main memory [thus suggesting that qscore also runs in O(nk) time], but qscore uses much more memory than FastSP on the largest dataset. In addition, when run on lower memory machines (e.g. on machines with only 4 GB of memory), qscore will fail to analyze some datasets, and will require more time than FastSP to analyze the largest datasets. Our results show that the memory usage of qscore when comparing pairs of large alignments can be quite large, using at least a few gigabytes (and in one case, using 10 GB) of peak memory, whereas FastSP never used more than 2 GB of peak memory. While this level of memory usage may not have a substantial impact for a single comparison, when several pairwise comparisons are desired, either very large memory machines or sequential pairwise analyses will be needed. In contrast, many pairwise comparisons can be run using FastSP on a single machine. There are several applications where many pairwise comparisons between alignments would be made. One obvious application is evaluating sequence alignment methods [a problem that is very important for many applications (. In addition, the phylogenetics research community is increasingly aware of the importance of considering many different alignments () and the impact of 'alignment uncertainty' on phylogenetic estimation (). In addition, rather than using one alignment technique, current molecular phylogenetics studies often explore a number of different alignments for each dataset. These alignments can be obtained directly using methods such as SAT or BAliPhy () that explore alignment space, or using many different alignment methods. Once the set of alignments is obtained, they can be used to estimate an alignment [as in TCoffee () and MCoffee (, to produce a consensus alignment () or to evaluate the support for each homology within an alignment (). These meta-analyses can then be used to improve biological inferences, such as predicting function (). Alignments can also be compared with each other in order to train alignment estimation methods so that they produce more accurate alignments (). Thus, real-world applications exist in which many pairwise comparisons between alignments are made. Furthermore, large phylogenetic analyses are becoming the norm, and datasets with tens of thousands of taxa (such as we studied in this article) are being analyzed [e.g.. Therefore, methods, such as FastSP that can compare alignments in a time-and memory-efficient manner, are bioinformatics tools that are likely to have increasing importance for future phylogenetic analyses. Future work will seek to integrate FastSP into other software, such as alignment visualization tools or methods that annotate alignments using a set of alignments.
The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
