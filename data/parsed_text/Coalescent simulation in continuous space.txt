Coalescent simulation has become an indispensable tool in population genetics, and many complex evolutionary scenarios have been incorporated into the basic algorithm. Despite many years of intense interest in spatial structure, however, there are no available methods to simulate the ancestry of a sample of genes that occupy a spatial continuum. This is mainly due to the severe technical problems encountered by the classical model of isolation by distance. A recently introduced model solves these technical problems and provides a solid theoretical basis for the study of populations evolving in continuous space. We present a detailed algorithm to simulate the coalescent process in this model, and provide an efficient implementation of a generalized version of this algorithm as a freely available Python module. Availability:
INTRODUCTIONThe extinction/recolonization model (or spatial -Fleming-Viot process) is a recently introduced model () that captures the dynamics of populations evolving in a spatial continuum (). The model solves long-standing problems (with the classical models of isolation by distance () and has the potential to explain key biological facts that cannot be captured by simple diffusion (). In this model, each individual occupies a fixed location in continuous space and all movement and reproduction happen as the consequence of extinction/recolonization events. Events fall randomly throughout space, independent (crucially) of the location of extant individuals. At an event, some fraction of the individuals nearby die, to be replaced by the offspring of a small number of parents chosen from the nearby population immediately before the event. Events at different scales model the effects of life history and demography. For example, the regular reproduction of individuals may be modelled by means of small and frequent events in which a few individuals in a local area die and are replaced by the progeny of nearby parents. On the other hand, broad-scale mortality events can affect a substantial fraction of the population over the entire species range. Seefor an extensive review of the model, its applications and background.
SINGLE LOCUS ALGORITHMThe coalescent process for the extinction/recolonization model at a single locus is straightforward (), and we describe a detailed algorithm to simulate this process in this section. In the interest of simplicity, here we restrict ourselves to a single class of event from the disc model () in which events have a fixed radius r; within these discs, a single parent is chosen uniformly and individuals die with probability u. The algorithm is described in terms of oriented trees (Knuth, 2011, p. 461). In an oriented tree, parentchild relationships are important but the order of children at a node is not. This information is encoded as a sequence 1. .. n , where j is the parent of node j and node j is a root if j  0. Oriented trees have several advantages over more traditional approaches to encoding genealogies such as nested parentheses or linked structures. They provide a concise and elegant means of describing genealogies, are trivial to store and parse, and can be annotated with additional information without effort. Finally, as oriented trees are simple lists of integers, we can describe coalescent algorithms precisely and without ambiguity. Let R U A be an element of the set A chosen uniformly at random, and let R E  be an exponentially distributed random value with rate. Also, let Bz, r, L define a disc of radius r centred at z on a 2D torus of diameter L, and let ? denote the null point. Algorithm S (Single locus coalescent). Simulate the ancestry ,  of individuals sampled at locations x 1. .. x n at time t  0 under a model in which events with radius r and impact u occur at rate on a 2D torus of diameter L. S1Set j 0, j 0 and j ? for 1 j52n. Then set j x j for 1 j n and set S f j j1 j ng. Finally, set n  1 and t 0. S2Set t t  R E  and z R U 0, L 2 . S3Set C ;. For each j 2 S, if j 2 Bz, r, L and R U 0, 15u, set C C [ fjg. Afterwards, if jCj  0, go to S2; else, if jCj  1, go to S4; otherwise, go to S5. S4 [One lineage jumps.] Let C  fjg, set j R U Bz, r, L and go back to S2. S5For each j 2 C, set j . Then, set t, R U Bz, r, L, S S n C [ fg and  1. Finally, if jSj41, go back to S2. *To whom correspondence should be addressed.Algorithm S operates by mapping individuals in the sample to the integers 1 j n and those ancestral to the sample to integers greater than n. The set S contains the lineages ancestral to the sample at time t, and we proceed backwards in time event-by-event. Because most events will not hit any lineages, the majority of the time spent in the algorithm is looping quickly around steps S2 and S3. Occasionally, a single lineage will be hit, we execute step S4 and move the lineage to a new location. Very rarely, an event hits more than one lineage, and C is the set of lineages born from a single parent. Thus, in step S5 we set the parent of each lineage in C to be and the location of to a random point within the ball defining the event. We then record that lineage entered the sample at time t by setting to t. Finally, we remove the children born in this event from the sample (as we are no longer interested in them) and insert into the sample (as we are interested in its further history). This process continues until there is one individual in the sample, and ,  describes the full history of the sample.
MULTILOCUS ALGORITHMThe single locus model is extended to incorporate recombination by letting each individual in the sample consist of multiple loci and allowing for multiple parents in events, so that a given individual may descend from different parents at different loci. Specifically, we consider a model in which each individual has m linearly arranged loci and there are parents at each event. (In sexually reproducing species,  2 in small-scale reproduction events. We must consider the possibility of more than two parents in large-scale events, as several generations may elapse before the local area is repopulated.) For each child in an event, there is a probability ' that loci ' and '  1 are inherited from different parents. See Etheridge and VeberVeber (2012) for more details. Simulating this multilocus coalescent follows the same pattern as Algorithm S: we begin with a sample of n lineages and proceed event-by-event until the ancestry of the sample is complete, and we have a pair ,  describing the history at each locus. The sample S is most conveniently represented as a set of (location, ancestry) tuples x, a 1. .. a m . Each sequence a 1. .. a m represents the ancestry of a lineage such that a ' 6  0 if there is genetic material ancestral to the sample present in this lineage at locus ' and a '  0 otherwise (). Termination of the algorithm is controlled by maintaining the invariantThus  nm initially, and the algorithm terminates when  m, indicating that all loci have coalesced. Suppose that C is the set of lineages born in an event. We must first decide which children descend from which parent at each locus. To do this, we first set k, ' ; for 1 k and 1 ' m. Then, for each child lineage a 1. .. a m 2 C we choose a parent for the first locus by setting k R U f1,. .. , g. We then iterate over each locus 1 ' m, and if a ' 6  0 (that is, there is ancestral material at this locus), we set k, 'Then, with probability ' , a recombination event occurs and we choose a new parent for the next locus by setting k R U f1,. .. , g n fkg. Having completed the task of deciding which children have descended from which parents, we must generate the new parental ancestry sequences and update the genealogies and node times. This is accomplished by examining the sets of descendants k, ' for each parent k at locus ' and proceeding in the same manner as algorithm S, updating , and for each locus as appropriate. This algorithm is far from optimal and can be improved in many ways to improve performance, particularly in special cases. It does provide a useful starting point for these special cases, however, and is easily adapted and analysed. A straightforward implementation of the algorithm in Python is included as Supplementary Material for reference.
IMPLEMENTATIONThe multilocus coalescent algorithm described in the previous section is implemented as a Python module, ercs. The implementation supports an arbitrary number of event classes, including events from the Gaussian model (), and incorporates spatial indexing to improve performance over the basic algorithm outlined here. The module is written primarily in C in the interest of efficiency and is distributed freely under the terms of the GNU General Public License.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
J.Kelleher et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
