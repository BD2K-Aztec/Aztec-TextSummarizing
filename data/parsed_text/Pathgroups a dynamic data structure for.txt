Motivation: Ancestral gene order reconstruction problems, including the median problem, quartet construction, small phylogeny, guided genome halving and genome aliquoting, are NP hard. Available heuristics dedicated to each of these problems are computationally costly for even small instances. Results: We present a data structure enabling rapid heuristic solution to all these ancestral genome reconstruction problems. A generic greedy algorithm with look-ahead based on an automatically generated priority system suffices for all the problems using this data structure. The efficiency of the algorithm is due to fast updating of the structure during run time and to the simplicity of the priority scheme. We illustrate with the first rapid algorithm for quartet construction and apply this to a set of yeast genomes to corroborate a recent gene sequence-based phylogeny.
INTRODUCTIONMany comparative genomic problems require the reconstruction of unknown genomes, more specifically their gene orders, starting from knowledge of one or more given, contemporary, genomes. These include the inference of ancestral genomes as part of the small phylogeny problem (), and its archetypical cases, the median () and quartet () problems, based on three or four given genomes, respectively. These also include the genome halving (El) and genome aliquoting () problems, based on a single genome where every gene is duplicated or in a gene family of size m  2; the idea being to infer the immediate pre-polyploid ancestor. There are various hybrid problems, such as guided genome halving (GGH;), which combines genome halving with phylogenetic inference, or small phylogeny on unequal genomes (), which integrates missing data considerations. In addition, there are also problems where one or more current, rather than ancestral, genomes, lacking full gene order (), gene orientation (), or affected by paralogy () or high levels of gene order error, are to be completed or corrected based on comparative evidence. We do not study this latter group of problems here, having previously shown how to leverage the minimization inherent in rearrangement distance definitions in order to optimally complete or correct the genomes (). The computational status of most of the ancestral reconstruction problems have been reviewed inand in a recent textbook (). With few exceptions (such as genome halving or multichromosomal breakpoint median), they are NP hard problems, especially the more realistic versions. Nevertheless, with high demand from the phylogenetics community (), a great variety of exact and heuristic algorithms have been developed, some of which are in wide use (). At the heart of many of these methods, especially those that find, or at least seek, a most economical solution in terms of genomic distances is the strategy of maximizing the number of cycles in the breakpoint graph () [or its dual, the adjacency graph (, while reconstructing the unknown genome. In this article, we propose a data structure that is designed entirely for this type of strategy. Pathgroups is a compact and flexible way of storing partially completed cycles, so that genome-wide greedy searches (allowing look-ahead strategies and problem-specific constraints) are rapidly executed and the database rapidly updated. Pathgroups is readily adapted to virtually all the gene-order reconstruction problems and indeed its virtues can be appreciated by studying the basic steps in such procedures as diverse as genome halving (El) and the median problem (). The procedure handles constraints on the reconstructed genomes (e.g. exact tetraploidy in genome halving problems) efficiently. A key advantage of the method is that its running time depends only on genome size and not the rearrangement distances among the input genomes, while run time of other reconstruction methods are highly dependent on the distance. In this article, after formalizing a number of ancestral reconstruction tasks, we present the basic structure of pathgroups, and show how it is adapted to all of the problems. In particular, we use it in a new heuristic to efficiently search for a solution to the quartet problem. As applied to a number of yeast gene orders, we show that gene order data confirm the phylogeny previously obtained from gene sequence data.Page: 1588 15871594
C.Zheng
Fig. 1. Constructionof the breakpoint graph. Left: genomes G 1 and G 2 , with '-' sign indicating negative polarity. Middle: vertices and edges of individual genome graphs. Right: cycles in completed breakpoint graph.
THE PROBLEMSIn this section, after establishing basic concepts and definitions, we sketch four ancestral genome reconstruction problems with reference towhich depicts them all.
Preliminaries
Genomes and rearrangement operationsA genome can be modeled as a set of chromosomes, each chromosome consisting of a number of linearly ordered elements called genes. The genes are all distinct and each one has positive or negative polarity. Biologically, the polarity indicates on which of the two DNA strands the gene is located or, equivalently, if the gene is transcribed from left to right or from right to left. Genomes can be rearranged, i.e. the order of the genes and their polarity, which chromosome contains a given gene, the total number of chromosomes, can all change, through the accumulated operation of number of classical processes familiar in classical genetics: inversion, reciprocal translocation, transposition, chromosome fusion and fission. We will not delve into the details of these rearrangement operations; they can all be subsumed under a single operation called double-cut-and-join, which need not be described here. All that is needed for our purposes is a formula due to, stated in Section 2.1.2, that gives the minimum number of rearrangement operations needed to transform one genome into another, in terms of properties of the 'breakpoint graph' determined by the initial and final genomes.
Rearrangement distanceThe genomic distance d(G 1 ,G 2 ) is a metric counting the number of rearrangement operations necessary to transform one multichromosomal gene order G 1 into another G 2 , where both contain the same n genes. To calculate D efficiently, we use the breakpoint graph of G 1 and G 2 , constructed as illustrated in. For each genome, each gene g with a positive polarity is replaced by two vertices representing its two ends, i.e. by a 'tail' vertex and a 'head' vertex in the order g t ,g h ; for g we would put g h ,g t. Each pair of successive genes in the gene order defines an adjacency, namely, the pair of vertices that are adjacent in the vertex order thus induced. For example, if i,j,k are three neighboring genes on a chromosome then the unordered pairs {i h ,j t } and {j h ,k h } are the two adjacencies they define. If there are m genes on a chromosome, there are 2m vertices at this stage. The first and the last of these vertices are called telomeres. We convert all the telomeres in genome G 1 and G 2 into adjacencies with additional vertices all labeled T 1 or T 2 , respectively. The breakpoint graph has a blue edge connecting the vertices in each adjacency in G 1 and a red edge for each adjacency in G 2. We make a cycle of any path ending in two T 1 or two T 2 vertices, connecting them by a red or blue edge, respectively, while for a path ending in a T 1 and T 2 , we collapse them to a single vertex denoted 'T '. Each vertex is now incident to exactly one blue and one red edge. This bicolored graph decomposes uniquely into  alternating cycles. If n is the number of blue edges, then ():
The median problem
The quartet problemLet
GGHLet T be a genome consisting of  chromosomes and 2n genes a(1) 1 , .
.., a(1)n , dispersed in any order on the chromosomes. For each i, we call ai 'duplicates', but there is no particular property distinguishing all elements of the set of a(1) i in common from all those in the set of ai. A potential 'doubled ancestor' of T is written A A , and consists of 2 chromosomes, where some half () of the chromosomes, symbolized by A , contains exactly one of ai for each i = 1,...,n. The remaining  chromosomes, symbolized by A , are each identical to one in the first half, in that where ai appears on a chromosome in the A , a(2) i appears on the corresponding chromosome in A , and where a(1) i appears in A. We define A to be either of the two halves of A A , where the superscript (1) or (2) is suppressed from each ai. These  chromosomes, and the n genes they contain, a 1 ,...,a n constitute a potential 'doubled ancestor' of T .(Note that ascribing 2n genes on 2 chromosomes to a tetraploid is consistent with only n genes on  chromosomes in a diploid. As far as gene order is concerned, there is no need to distinguish between maternal and paternal chromosomes). The genome halving problem for T is to find an A for which some d(A A ,T ) is minimal. The genome halving problem can be solved in linear time (El). Unfortunately, the algorithmic result suffers from severe non-uniqueness. To overcome this problem, a reference genome, or outgroup, is introduced. Let T be a genome consisting of  chromosomes and 2n genes an , dispersed in any order on the chromosomes, where for each i, genes ai are duplicates. Any genome R is a reference or outgroup genome for T if it contains the n genes a 1 ,...,a n .
Genome aliquotingThe genome aliquoting problem 'ALQ' () is a generalization of the genome halving problem. Whereas the genome halving problem reconstructed the 'doubled ancestor' of a genome which contains exactly two copies of each gene, genome aliquoting extends the scope from two copies of duplicates to m copies of paralogs in a genome. Let genome P (for " polyploid") consist of mnn , The genome aliquoting problem for P is to find an A for which some d(
ALGORITHMAll the problems listed in Section 2 are known to be NP hard, with the possible exception of aliquoting, whose status is not settled. Our method will be shown to run in linear time, so obviously it is not guaranteed to find an exact solution. However, its rapidity makes it an ideal way to obtain reasonably accurate first approximations for large-scale instances and good initializations for iterative methods when there are two or more ancestral genomes to be reconstructed.
General solution
Paths and fragmentsWe generalize our definition of a path to be any connected subgraph of a breakpoint graph, namely, any connected part of a cycle as previously defined in Section 2.1.2 and, where the two endpoints are incident to blue edges. We represent each path by an unordered pair of vertices (u,v) = (v,u) consisting of its current endpoints, though we keep track of all its vertices and edges. Initially, each blue edge in the given genomes is a path. A fragment is any set of genes connected by red edges in a linear order, i.e. there are two gene tails and/or heads not connected to any other vertex. The set of fragments represents the current state of the reconstruction procedure. Initially, the set of fragments contains all the genes, but no red edges, so each gene is a fragment by itself.
PathgroupsThe objective functions for each of the ancestral reconstruction problems consists of the sum of a number of genomic distances, e.g. three distances for the median of three genomes, five distances for quartet construction, just one for genome halving or aliquoting and two for GGH. Each of these distances corresponds to a breakpoint graph. A given genome determines blue edges in one breakpoint graph, while the red edges correspond to the ancestral genome being constructed. For each such ancestor, the red edges are identical in all the breakpoint graphs corresponding to distances to that ancestor. In problems such as halving or aliquoting, there may be two or more identical copies of each red edge in breakpoint graphs involving a polyploid ancestor. A pathgroup is a set of r  3 paths, one or more from each partial breakpoint graph currently being constructed. For a given problem, all the pathgroups contain the same number r of paths. There is one pathgroup for each non-T vertex and for each ancestor. We do not construct a pathgroup for each T vertex separately, though paths ending in T vertices are found in pathgroups determined by non-T vertices. This approach was chosen for reasons of efficiency and simplicity, as will be explained in Section 3.1.4. In the median of   3 genomes problem, each breakpoint graph contributes one path to each pathgroup, so r = . In the GGH problem, the tetraploid contributes two paths and the reference genome one, so r = 3. In genome aliquoting based on m-gene families, each pathgroup contains r = m paths, all from the single breakpoint graph constructed in this problem. In the quartet problem, there are separate pathgroups pertaining to the two ancestral genomes. As with the median problem for three genomes, there are (potentially) r = 3 paths in the pathgroup. However, one of the paths in the pathgroup determined by a vertex x may be missing, since the blue edge incident to x in the breakpoint graph of the two ancestral genomes may not have been drawn yet. In this case, we simply place x in the pathgroup instead of the missing path. Moreover, paths from this breakpoint graph may begin or end with red edges. Pathgroups overlap because most paths are in two pathgroups, one associated with its initial vertex and one with its final vertex, unless the latter is a T. With respect to a given path xy, we say the pathgroup determined by vertex x is the partner of the pathgroup determined by y. A pathgroup may have up to r distinct partners.
PrioritiesOur main algorithm presented in Section 3.1.4 aims to construct one or more breakpoint graphs with a maximum aggregate number of cycles. At each step it adds one red edge, the same red edge, to each of the paths in the pathgroup, thus changing one or more breakpoint graphs. This removes two (partner) pathgroups, turning one or more of their paths into cycles and concatenating each of their remaining paths with a path in some other pathgroup. We do not add red edges incident to T vertices. It is always possible to create one cycle, at least (as long as not all the paths in the pathgroup contain a T ) by adding a red edge between the two ends of any one of the paths. The strategy is to create as many cycles as possible. Among alternate choices of steps creating the same number of cycles, to choose the one that sets up the best configuration for the next step. Thus, the pathgroups are prioritized,(1) first by the maximum number of cycles that can be created within the group, without giving rise to circular chromosomes; and(2) second, for those pathgroups allowing equal number of cycles, by considering the maximum number of cycles that could be created in the next iteration of Step 1, in any one pathgroup affected by the current choice.A pathgroup may receive no priority, if creating any cycle within the pathgroup necessarily creates a circular ancestral chromosome. Note that in adding a red edge xy, this causes not only the disappearance of two partnered pathgroups, but it also changes paths in other pathgroups, which we call secondary pathgroups. Furthermore, each secondary pathgroup may itself have partner pathgroups whose paths, though not affected by the addition of xy, may have changed priorities. We call these tertiary pathgroups.
Page: 1590 15871594
C.Zheng
..G 4 , including ancestors M 1 and M2 , genome halving of tetraploid T to identical diploids A and A guided by reference diploid genome R, and aliquoting of a hexaploid H to three diploids A 1 , A 2 and A 3. Gray squares indicate given genomes, red squares those to be reconstructed. Each line connecting two genomes represents a breakpoint graph and a distance.For the MED ( = 3), GGH, QRT and ALQ (m = 3) problems, the pathgroups and the priorities are basically the same, as illustrated in.(1) add red edge to pathgroup of highest priority, creating at least one cycle, thus deleting this pathgroup and its partner.
The makeCycles algorithm By(2) update the paths in the secondary pathgroups affected by the addition of the red edge, and update the red fragment extended by this edge or created by the joining together of two existing red fragments.(3) update the priorities of the secondary pathgroups, the tertiary pathgroups and the at most two pathgroups associated with the endpoints of the red fragment extended or created in Step 2.Note that we are not inferring that all the red fragments output by makeCycles are complete chromosomes of the ancestral genome; some of them may just be chromosome fragments, depending on the particular instance.Proof. The paths in the pathgroups for x and y contain no more than 2(r 1) endpoints that are not x or y, so there can be no more than 2(r 1) secondary pathgroups. A secondary pathgroup determined by vertex z contains no more than r 1 paths that are not x, y or z, so that there are at most 2(r 1) 2 tertiary pathgroups. The proposition, together with the two facts:(1) the total number of pathgroups decreases by two by each step; and(2) the calculation or recalculation of the priority of each pathgroup requires constant time; ensure the O(n) running time of the algorithm. Note that if we had allowed red edges to connect T vertices or if we had allowed pathgroups determined by T vertices, the number of potential secondary and tertiary pathgroups affected by the addition of a red edge would have depended strongly on the number of chromosomes in the genomes. In the remainder of this section, we will discuss how this algorithm applies to the MED, GGH, QRT and ALQ problems, with reference to, which details the different priorities for pathgroups, and the origin of each path in the pathgroup in the appropriate breakpoint graph. An example of how the algorithm works is presented in the Supplementary Material., there are seven priority levels, corresponding to constructing
Application to specific problems
Median As illustrated in(1) three cycles,(2) two cycles setting up (a) three, (b) two or (c) one in the lookahead or(3) one cycle setting up (a) three, (b) two or (c) one in the lookahead.Note that when a red edge is defined, the pathgroup is emptied, either by the creation of cycles, or by the integration of x as a non-endpoint of some path. For the median of  genomes, the number of priority levels is 1+(1).
GGH Recallthat the pathgroups for GGH contain three paths, two from the tetraploid and one from the reference diploid. As illustrated in, the pathgroup structure assures that as a red edge is added, two identical red fragments are extended in the same way. The reconstructed genome will thus eventually consist of two identical sets of chromosomes, a wholly doubled genome. We may use the notation x and  x for the two copies of a gene, although this is not indicated in the general scheme of. At the outset, it is inconsequential which copy is labeled x and which is labeled  x. The vertex x may be linked with y or with  y, and this does have consequences for the breakpoint graph, including the number of cycles. The two alternatives must be checked each time a priority is calculated, to see which one gives the better priority.
Genome aliquotingThe pathgroups for the genome aliquoting problem with mn genes are similar to those for the median problem for  = m genomes. The main difference is the blue edges all come from a single polyploid genome instead of  separate genomes. Moreover, there is a complication in calculating the priorities. Although it is clear how many cycles are formed when adding a red line to a pathgroup, the look-ahead may have to search among several possibilities of joining paralogs together to find the maximum number of cycles that could be produced. For example, if x,  x and   x are the three copies of gene x, consider the case where the path (x,y) is turned into a cycle by the addition of a red edge, but the other two paths in the pathgroup are (x,w) and (x,z). Then (x,w) may be joined by a red edge to ( y,s) creating path (w,s), while (x,z) may be joined by a red edge to (   y,t) creating path (z,t). But we could also construct (w,t) and (z,s) instead; we must Page: 1591 15871594
Pathgroups for genome reconstruction problemsfor inserting red edges, in four reconstruction problems. Includes sketch of three paths in 'x' pathgroup plus other paths involved in calculating priority. For example, completing the pathgroupby adding the red edge xy always produces two cycles, but can set up a pathgroup with 3 potential cycles (priority 2), 2 potential cycles (priority 3) or 1 potential cycles (priority 4). consider both alternatives in calculating the priority of the pathgroup determined by x.
QuartetsIn the quartet problem, there are 14 pathgroups shown in, seven for adding red edges to paths in the median, the edges in M 1 are considered as blue paths, and vice versa. As with the median problem for three genomes, there are (potentially) three paths in the pathgroup. However, one of the paths in the pathgroup determined by x may be missing, since the blue edge incident to x in the breakpoint graph of the two ancestral genomes may not have been drawn yet. In this case, we simply place x in the pathgroup instead of the missing path. Moreover, paths from this breakpoint graph may end with red edges. These aspects are very important, as will be detailed in Section 5.1. Note that when a red edge is added in a pathgroup for M 1 , this becomes a blue edge in a pathgroup for M 2 , and vice versa.
IMPLEMENTATIONVersions of the pathgroups algorithms have been implemented before, for the median problem () and the guided halving problem (), but without any attempt to achieve the computational efficiencies available with this approach. In the present work, we implemented makeCycles so that it could achieve its worst case linear run time capability. The particular problem we focused on was quartet construction, with two r = 3 pathgroups, one for each ancestor, for each vertex x in the breakpoint graph, as in the QRT column of.
EfficiencyWe carried out a number of simulation experiments to establish the average run time performance. Each data point in our experiments comes from the average of 100 simulations. All simulations started with 20 chromosomes, and rearrangements were apportioned as 90% inversions and 10% reciprocal translocations. For each rearrangement, chromosomes were chosen at random and breakpoints within the chromosome were chosen at random. The initial genome at M 1 was used to generate G 1 ,G 2 and M 2 independently with genome size n and d rearrangements on each branch. Then the genome at M 2 was used to generate G 3 and G 4 in the same way.shows the result of four experiments. One where run time t is plotted against n varying from 1000 to 10 000, while d = 1000. Another is the same except d = 25000. The other two experiments set d = n/2 and d = 2n, respectively. Except for the first experiment, the average behavior of t as a function of n appears the same. In other words, except for low values of d the run time of the makeCycles routine is independent of d, depending only on n. Moreover, above n = 5000 the average run time is close to linear.highlights the fact that run time does not depend on d for moderate and large values of d.
Questions of accuracyAs mentioned in Section 3, we do not expect to guarantee exact solutions for NP hard problems in linear time. Moreover, because this is a single-pass method, we cannot even expect to find locally optimal solutions. Thus, we must investigate how close is the approximation and what are the prospects for improvement. In the same experiment as, we measured the total distance of the quartet by summing the edge distances using the simulated ancestors constructed by random rearrangement. We then Page: 1592 15871594This characteristic is achieved after n = 5000. Note that with genomic distance d = 1000, the slope is less than with d = 25 000, but there is little difference among the curves for n = 25 000, d = n/2 and d = 2n.compared this with total distance using the ancestors we inferred with makeCycles. The results appear in. That both curves are concave is no surprise. By definition, the inferred distance between two genomes is less than or equal than the number of rearrangements used to derive one from the other during simulation. And it is known that this difference increases as the number of rearrangements increases; indeed the inferred distance cannot be greater than n while the number of rearrangements that can be applied is not bounded. Nor is it surprising that the total based on the inferred ancestors, which are chosen to minimize the total is smaller than that based on the simulated ancestors, which are fixed. What is of concern is the interval below d = 5000, where the distances based on the inferred ancestors is marginally greater than the total based on the fixed ancestors. This clearly reflects some degree of imprecision of this method for this problem. Whether the tradeoff between speed and precision is worth, it depends on the particular application. And the pathgroups solution may be useful as an initialization of an iterated method where the median algorithm is applied alternatively to M 1 and M 2 until no further improvement is obtained.), including Saccharaomyces ancestor before whole-genome duplication.
C.Zheng
Quartets of rapidly and slowly evolving yeastsSaccharomyces cerevisiae and its closest relatives are descendants of a whole-genome duplication event more than 100 million years ago (). In a maximum likelihood phylogeny of 79 yeast species inferred from eight gene sequences (), there are six relatives of S.cerevisiae whose genomes have been sequenced, but that diverged before the whole gene duplication. These six, plus the manually reconstructed ancestral genome () that underwent whole-genome duplication are depicted in. Since their divergence these genomes have evolved at very different rates, with Eremothecium gossypii, for example, showing a substitution rate over three times as great as Lachancea Kluyveri, making phylogenetic inference prone to various biases. We extracted gene orders involving the 4011 sets of orthologous genes that these genomes all have in common from the Yeast Gene Order Browser (). Gene order rearrangement distances between them shows that the evolution rate for gene order varies in much the same way as for gene sequence, with E.gossypii, for example, changing gene order much more rapidly than L.kluyveri. We applied our quartet construction algorithm to all 35 subsets of four genomes. Each of these subsets may be arranged in three different quartets, for a total of 105 quartets (and 30 s of computing time). Only one of the three can be consistent with a given tree. For the tree in, the least total distance quartet was consistent with this tree in 34 out 35 subsets, which represents a very high degree of confirmation.
Page: 1593 15871594
Pathgroups for genome reconstruction problems
DISCUSSION
Small phylogenyMedian solving and quartet building are the prototypical small phylogeny problems, and the special nature of the pathgroups for the quartet problem hints at the solution of the small phylogeny problem. Indeed, with appropriate calculation of priorities, the makeCycles algorithm requires no extensions or modifications to apply to this general problem. There should be an entire set of pathgroups for every internal (ancestral) node of a small phylogeny. Consider 'binary' topologies, where each given genome is connected to one ancestral genome, and all ancestral genomes are adjacent to three genomes. Initially, the pathgroups for those ancestral nodes connected to two given genomes should have the same form as those for M 1 and M 2 in the quartet problemone of the paths missing and replaced by a single vertex of the breakpoint graph. Those ancestral nodes connected to only one given genome will have two missing paths in each pathgroup, both replaced by the vertex. Finally, those ancestral nodes connected only to other internal nodes will have all paths missing in each pathgroup, all replaced by the vertex. As the algorithm executes, all the pathgroups associated with all the internal nodes are scanned at each step to find the one with the highest priority. The pathgroups connected to two given nodes will tend to be processed first, building up all three paths and combining the pathgroups one by one. Each time a red edge is added to a path, this becomes a blue edge in the corresponding pathgroup for ancestral genome(s) connected to it. Eventually even the nodes furthest from any given genomes will accumulate enough edges in their pathgroups so that cycles can be formed and so that fragments of the associated genomes begin their reconstruction. It is clear from the structure of binary trees that the algorithm will continue until all the ancestral genomes are constructed. These considerations carry over to trees where the internal nodes have degree greater or equal to three. Higher degree nodes have more paths in their pathgroups, but the same principle should be used to establish priorities: the greater the number of cycles that can be created, the higher the priority.
Impact and future workThe main interest of the pathgroups approach is its applicability to a wide range of reconstruction problems. Ultimately all these problems may be considered to be part of the small phylogeny gene order problem, where polyploidization events are allowed. The virtues of our heuristic are its flexibility, simplicity and speed. Of course, being a one-pass algorithm, where all information flows from the given genomes to the most ancestral ones, with no traceback, it cannot always find solutions that are as good as the common iterative approach originating with (). Methods like these and others derived from them () iteratively traverse the overlapping medians constituting the small phylogeny in the search for improvements. Nevertheless, it is known that good initialization for the ancestral genomes is the key to finding good solutions, and our method represents a rapid and relatively accurate way of providing such initialization. Moreover, the pathgroups approach is perfectly suited to iterative improvement of overlapping medians or quartets. The formulation of our problems and the method has been situated in the context of genomes with multiple linear chromosomes, i.e. modeling eukaryotic nuclear genomes. Indeed the halving and aliquoting problems are only really pertinent in this context. This explains our attention to avoiding circular fragments in the algorithm. There would be no additional difficulty in reformulating and solving the median, quartet and small phylogeny problems allowing genomes to consist of one (or more) circular chromosomes. Finally, enhancing the accuracy of our method could start with more elaborate priority schemes, without sacrificing the linear dependence of run time of genome size or its independence of gene order rearrangement distances. At the same time, we could allow additional pathgroups, those determined by T vertices. This would tend to increase the accuracy by creating more high priority pathgroups, and would not substantially slow the algorithm for a reasonable number of chromosomes.
The Author 2010. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oxfordjournals.org 1587 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
