Motivation: A promising class of methods for large-scale population genomic inference use the conditional sampling distribution (CSD), which approximates the probability of sampling an individual with a particular DNA sequence, given that a collection of sequences from the population has already been observed. The CSD has a wide range of applications, including imputing missing sequence data, estimating recombination rates, inferring human colonization history and identifying tracts of distinct ancestry in admixed populations. Most well-used CSDs are based on hidden Markov models (HMMs). Although computationally efficient in principle, methods resulting from the common implementation of the relevant HMM techniques remain intractable for large genomic datasets. Results: To address this issue, a set of algorithmic improvements for performing the exact HMM computation is introduced here, by exploiting the particular structure of the CSD and typical characteristics of genomic data. It is empirically demonstrated that these improvements result in a speedup of several orders of magnitude for large datasets and that the speedup continues to increase with the number of sequences. The optimized algorithms can be adopted in methods for various applications, including the ones mentioned above and make previously impracticable analyses possible. Availability: Software available upon request.
INTRODUCTIONWith the cost of genomic sequencing rapidly decreasing, there is a growing need for statistical methodologies that can efficiently accommodate genomic-scale data for many individuals while accounting for complex patterns of variation (e.g. linkage disequilibrium) caused by evolutionary processes such as mutation and recombination. The applicable underlying statistical model is the coalescent with recombination, which describes the distribution of genealogical histories for a collection of individuals. Known methods for inference under this model are generally intractable at the genomic scale, so practicable methods must realize a balance * To whom correspondence should be addressed. between computational efficiency and approximating key properties of the coalescent with recombination. A promising class of such methods use the conditional sampling distribution (CSD). A CSD approximates the probability (under the coalescent with recombination) of sampling an individual with a particular DNA sequence, given that a collection of sequences from the population has already been observed. Intuitively, recombination partitions the newly sampled sequence into segments, each of which is a copy of the corresponding segment in a previously sampled sequence, with imperfections introduced by mutation. For computational efficiency, this construction is often cast as a hidden Markov model (HMM). The hidden state at a site indicates the previously sampled sequence being copied and the associated observed state the allele of the new sample. Even within this framework there are alternatives, as it is possible to trade-off fidelity to the underlying coalescent process for computational efficiency. The CSD of, for example, is the most accurate but is a constant factor slower than CSDs proposed byand by, with the latter being the fastest, but least accurate. CSDs for more complex models, incorporating gene conversion (), diploidy (), demography () and admixture (), have also been proposed. Methods incorporating the CSD generally fall into one of several categories. Likelihoods can be approximated using CSD-based importance sampling (De) coupled with composite methods () or directly as a product of CSDs (). In conjunction with expectationmaximization or Markov chain Monte Carlo, these methods have been used for estimation of fine-scale recombination rates (), gene conversion parameters (), population demography () and population structure (). It is also possible to infer and use the hidden states in the HMM CSD computation. This has been used for admixture inference (), in which genomic segments corresponding to ancestral populations are identified and also within a pseudo-Gibbs sampling framework to phase genotype sequence data into haplotype sequence data and to impute missing data ().
Blockwise HMM computationNearly, all of these methods rely on iterative Monte Carlo or expectationmaximization techniques. As a result, they are computationally intensive, often requiring several hours, or, in some cases, days, to produce a result, even for modest non-genomic datasets (); directly extending the methods to large genomic datasets is thus often impractical. Moreover, nearly all of the running time is expended on CSD computation, and so the choice of CSD is often made on the basis of efficiency and (arguably) at the expense of accuracy (;). In this article, we help to overcome these limitations by proposing two related optimizations to the relevant HMM-based CSD computations. Consider sampling a large number of sequences from a population. If the sampled sequences are very long, it is likely that nearly all of them will be unique. However, for most relatively short regions, the number of unique subsequences will be reduced. This intuition forms the basis of the first optimization, which locally reduces the complexity of the CSD computation, thereby improving efficiency. The collection of locally unique subsequences on which this optimization depends are formalized as a partition C of the sampled sequences; we characterize the optimal partition given the sampled sequences and provide a fast algorithm for approximating this optimum. A second common feature of the sampled sequences is an abundance of non-polymorphic sites. These sites are informative for example, a local over-abundance of non-polymorphic sites indicates a recent common ancestor, which in turn indicates a low propensity for recombinationand should be included in the analysis. Indeed, Li and Durbin (2011) used the physical distribution of polymorphic and non-polymorphic sites between a pair of sequences to infer past population sizes of humans. Using the fact that non-polymorphic sites do not differentiate the sequences, we show that it is possible to reduce the complexity of the CSD computation at non-polymorphic sites. We stress that our solution is different from simply ignoring non-polymorphic sites; we are proposing algorithmic improvements to incorporate non-polymorphic sites into the analysis in an efficient way. In formally describing and evaluating our optimizations, we restrict attention to the most accurate HMM-based CSD,   SMC , proposed byand consider the problem of computing the conditional sampling probability (CSP), denoted denoted denoted SMC (|n), of a particular individual  given a collection n of previously sampled individuals. (Incidentally, in the case the size n of the previously observed sample n is 1, the HMM underlying underlying underlying SMC is equivalent to the HMM used in the aforementioned work of Li and Durbin; we anticipate thatthat that SMC provides one way of extending this line of work to many sequences). On simulated data, our algorithmic improvement leads to a speedup of about 550 for n = 5000 previously sampled individuals; by making regularity assumptions on mutation and recombination rates, this speedup increases to about 1850. Importantly, we show that the empirically observed speed-up increases with the number n of previously sampled individuals. Although we describe our optimizations in the context of computingcomputing computing SMC (|n), they are more generally applicable. We provide two sufficient conditions for our optimizations and use them to show the applicability to other HMM-based CSDs, including those of Fearnhead and Donnelly (
2001) and Li and Stephens(2003), as well as CSDs for more complex demographic models and population genetic HMMs. Also, in the Supplementary Material, we describe extending our algorithms to allow for efficient inference of hidden states, often termed posterior decoding. We stress that the work presented here is fundamentally different from previous works on 'approximating' CSD-based population genetic inference.consider a fixed-size subset of the haplotype configuration n, chosen using a measure of 'closeness' to the sampled haplotype , in order to reduce the state space of the HMM-based CSD and speed up computation. Similarly, Scheet and Stephens (2006) and Browning and Browning (2007) consider an HMM with reduced state space by compacting the configuration n into a substantially smaller haplotype model. More recently,have proposed an approximate HMM formulation relying on a partition of the sampled sequences similar to that proposed herein (Section 2.6). As described earlier, using such heuristics improves computational efficiency, but ultimately at the expense of accuracy. The purpose of this article is to provide highly optimized 'and exact' computation for a large class of approximate CSDs, rather than to introduce additional approximations to the underlying models.
METHODSHerein, we describe the HMM formulation ofof of SMC , the algorithms that are currently being used to comput  SMC (|n) and the optimizations we are proposing to improve the running time. We remark that the theoretical analysis of our algorithms is limited to asymptotic time (and space) complexity. As a measure of real-world performance, asymptotic analyses often leave much to be desired. Consider, for example, a sample in which 1 out of every 1000 sites is polymorphic. If we denote by k the total number of sites and k p the number of polymorphic sites, then formally O(k) = O(k p ). Nevertheless, we would like to distinguish between an algorithm that operates on each of the k sites and an algorithm that operates only on the k p polymorphic sites, as the the latter will be some 1000 faster; we thus write the complexities for the two algorithms as O(k) and O(k p ), respectively.
NotationWe consider haplotypes in the finite-locus finite-alleles setting. Throughout, we suppose that there are k loci, and that recombination may occur between any adjacent pair of loci (,+1) where 1  <k. The space of all such haplotypes is denoted by H, and given a haplotype h  H, the allele at locus is denoted by hand the sub-haplotype for a range of loci  is denoted by h. A sample configuration of haplotypes is specified by a vector n = (n h ) hH , with n h being the number of haplotypes of type h in the sample. The set of 'unique' haplotypes associated with configuration n is denoted by H n ={h  H : n h > 0}. Finally, the total number of haplotypes is denoted by |n|=n, the number of unique haplotypes by |H n |=n u and the number of polymorphic loci, which generally depends on the sample n, by k p .
A brief description ofof of SMCSuppose that, conditioned on having already observed a haplotype configuration n, we wish to sample a new haplotype . By generalizing the technique ofbased on the diffusion process, Paul and Song (2010) introduced the CSDCSD CSD PS intended to approximate key properties of the coalescent with recombination, the model under which inference is to be performed. The central idea ofof of PS is to fix the unknown ancestry of n to be the 'trunk genealogy' A * (n), in which lineages associated with the haplotypes do not mutate, recombine, or coalesce with one another, but ratherwith the shading indicating the allelic type at that locus. Time is represented vertically, with the present (time 0) at the bottom. The marginal genealogies at the first, second and third loci are shown as dotted, dashed and solid lines, respectively. Mutation event, along with resulting allele, is indicated by small arrow. Absorption events at each locus, and the corresponding absorption time (t (a) and t (b) ) and haplotype (h (a) and h (b) , respectively), are indicated by horizontal lines extend infinitely into the past. Having fixed the ancestry of n, a conditional genealogy C associated with haplotype  is sampled; within C, lineages evolve backwards in time subject to mutation, recombination, coalescence and 'absorption' into one of the lineages of A * (n). When every lineage of C has been absorbed, the process terminates; the type of every lineage of C is now determined and a sample for  is generated. Although a recursion for computing the CSPCSP CSP PS (|n) is known, it is computationally intractable for all but the smallest datasets. To remedy this limitation,adopted a sequentially Markov framework () for the conditional genealogy C. The central idea is to consider the 'marginal' conditional genealogy s associated with each locus , which is described, disregarding mutation events, by the pair s = (t ,h ), where t [0,) is the absorption time and h  H n is the absorption haplotype. The conditional genealogy C can thus be represented as a sequence of marginal conditional genealogies {s }. Seefor an illustration. In general, the random sequence of marginal conditional genealogies is not Markov, due to the potential for coalescence events within the conditional genealogy. Nonetheless, it is possible to 'approximate' this sequence as Markov by using a two-locus transition distribution. Mutation can then be realized at each locus independently as a Poisson process on the marginal conditional genealogy, thereby generating a sample for . The resulting CSD is denoted byby by SMC .found that the Markov approximation underlyingunderlying underlying SMC has minimal effect on accuracy compared withwith with PS , coinciding with findings in similar domains (). Owing to its Markov structure, the CSDCSD CSD SMC can be cast as an HMM wherein the th hidden state is the marginal conditional genealogy s = (t ,h ) and the th observed state the conditionally sampled allele . In order to use standard dynamic programming methodologies for inference, the state space of the HMM must be finite, and so absorption time is discretized by partitioning [0,) into a (possibly large) finite number m of intervals I and considering an absorption interval, denoted by d  I, rather than an absorption time. The discretized hidden state at the th locus is then s = (d ,h ), and the initial, transition and emission distributions for the discretizeddiscretized discretized SMC HMM are denoted by  (),  (|) and  (|), respectively.Interested readers should consult Paul and Song (2010) andfor details.
Computation withwith with SMCThe CSPCSP CSP SMC (|n) under the discrete-space HMM can be efficiently computed using the 'forward algorithm', a dynamic program associated with the HMM forward recursion:with base case F 0 (d,h) =  (d,h).Importantly, this recursion, and the associated dynamic program with time complexity O(k(n u m) 2 ), is applicable to a general HMM. In the following, we examine the transition and emission distributions more carefully and obtain a series of refined recursions and the associated dynamic programs.
Improving efficiency through the transition distributionConsider the description ofof of SMC given above and more rigorously defined in. If a recombination does not occur between loci 1 and , then (d 1 ,h 1 ) = (d ,h ); moreover, if recombination does occur, the absorbing haplotype h is independent of h 1 and uniformly distributed. As a result, we have the following property (We remark that Property 1 is a sufficient, though not necessary, condition for the algorithmic optimizations described in this and subsequent sections. For example, as stated, the transition distribution imposes a uniform distribution on the absorbing haplotype in the case of a recombination; in fact, the algorithms can be generalized to accommodate an arbitrary distribution over haplotypes that does not depend on d or h. In Section 4, we discuss the applicability of these optimizations to more general (and more specialized) classes of approximate CSDs.):are known analytic expressions. Using Property 1 in conjunction with definitionswe can express equations (1)(3) aswith base caseUsing these recursions, the dynamic program in Algorithm 1 can be used to comput  SMC (|n). Within the pseudocode description, the time complexity of Lines 6, 7 and 8 are O(m), O(n u ) and O(n u ), respectively. As a result, the time complexity of Lines 59, and for the algorithm as a whole, is O(km(m+n u )). This represents a substantial improvement over the quadratic dependence on n u in the naive forward algorithm for HMMs. This simple optimization has already been generally adopted () and serves as a baseline for improvement.
Improving efficiency through the emission distributionThe state of th  SMC HMM at locus is a tuple (d ,h ). However, the emission probability of is governed only by the time interval d and the allele h. As a result, the following property holds:@BULLET For every haplotype h  H n and 1   k, there exists 'exactly' oneFor a given locus , a configuration partition C induces a partition of the haplotypes H n , denoted by C , and Property 2 applies to each B  C. In the next sections, we present new sets of recursions and dynamic programming algorithms valid for an arbitrary partition C. The computational complexity of these algorithms will depend on C through two functions, namely (C)and (C), defined as follows: For locus , define  (C) =|C |, the number of blocks in C and define  (C) to be the total number of haplotypes in blocks of the configuration partition 'ending' at locus. Then,In some cases, we are primarily concerned with polymorphic loci, and so we define p (C) to be the analog of (C) summed over 'only' polymorphic loci. Finally, we define the trivial partition C T for haplotype configuration n as the partition containing a single block ({h},1,k) for each h  H n. Note thatu. Seefor an illustration of both C T and two non-trivial configuration partitions.
A general configuration partitionNow suppose (B,, s ,, e )  C. Applying Definition (8) and Property 2 to equation (6), then for s   e , Q (d,B) =  (|d,B)where T (d,B) = =s  (|d,B)y1 , and solves the recursion, T (d,B) =  (|d,B)yfor s   e , with base case T s1 (d,B) = 1. For each block (B,, s ,, e )  C, we take advantage of equations (9) and (11) to directly compute Q (d,B) and T (d,B) at every locus s   e. At the end of each block, when = e , the finer-grain values F (d,h) are computed for each h  B using equation (10), and subsequently used to compute initial values for blocks beginning at locus +1. The associated dynamic program to compute the CSPCSP CSP SMC (|n) is given in Algorithm 2. Within Algorithm 2, the time complexity of Line 7 is O(m); of Line 8 is O( (C)) and of Lines 9 and 10 is O( (C)). Thus, the time complexity of Lines 611, and the dynamic program, is O(km 2 +m((C)+(C))). Observe that Algorithm 1 is a special case of Algorithm 2 for C = C T. Thus, if it is possible to obtain a configuration partition C for n such that (C)+(C) is substantially less than (C T )+(C T ) = kn u +n u , our new algorithm may be considerably faster than Algorithm 1; constructing such a configuration partition is the subject of Section 2.6.
The absence of polymorphismIn many reasonable evolutionary scenarios, a great many loci will not be polymorphic. Accommodating such loci in the analysis is important and can be done efficiently making use of Property 2. In particular, for a non-polymorphic locus , Property 2 applies to the trivial set B 0 = H n , and therefore the emission distribution can be written  (|d,B 0 ) =  (|d) and moreover, Q (d,B 0 ) = Q (d). Suppose consecutive loci * s ,...,, * e are not polymorphic. Rewriting equations (9) and (10) for blockwhere T (d)Compute Q (d,B) and T (d,B) using (9) and (11),Algorithm
if locus is polymorphic then
4.
if locus 1 is not polymorphic then
5.Compute Q 1 (d,B) and T 1 (d,B) using (15) and (16) 6.
end if
7.Algorithm 2, lines 710 8.Now, let C be a configuration partition with (B,, s ,, e )  C. Suppose that there is a stretch of non-polymorphic lociSimilarly, considering the definition of T (d,B) along with equation (14),Algorithm 2 can be modified to accommodate such stretches of nonpolymorphic loci as a special case, making use of equations (12) and (14) to directly compute the values of Q (d) and T (d) at each non-polymorphic locus. If we then assume (without loss of generality) that each (B,, s ,, e )  C has e at a polymorphic locus, then at the final non-polymorphic locus, for which = * e , equations (15) and(16) may be used to compute Q (d,B) and T (d,B) for each B  C. This modification is detailed in Algorithm 3. Within Algorithm 3, the time complexity of Lines 5 and 8 is O(1), of Line 7 is O(m+ (C)+ (C)) and of Line 10 is O(m). As a result, the time complexity of Lines 212, and of the dynamic program, is). Relative to Algorithm 2, less computation needs to be done for non-polymorphic loci; thus, in the typical case of many nonpolymorphic loci, this dynamic program will have a decreased running time. For C = C T , the time complexity is O(km 2 +k p mn u ).
An optimization for non-polymorphic lociThe key recursions (12)and(14) for non-polymorphic loci can be written in matrix form as, where Q and T are m-dimensional column vectors having dth entry Q (d) and T (d), respectively; E and Y are (mm)-dimensional diagonal matrices having (d d)th entry  (|d) and yNow, suppose that the mutational model is symmetric and the mutation rate constant for all loci. Then, E = E does not depend on , for all nonpolymorphic loci. Similarly, if the recombination rate between each pair of loci is constant, then Y = Y and Z = Z do not depend on. With theseand the values of (E(Y +Z)) r and (EY) r can be pre-computed (either by eigenvalue decomposition or repeated multiplication) for a relevant range of r-values. Using this technique for explicitly computing only the necessary values of Q (d) and T (d), stretches of non-polymorphic loci can be 'analytically' skipped. The modified dynamic program associated with this optimization is given in Algorithm 4. The time complexity of Line 4 is O(m) and of Line 6 is O(m+ (C)+ (C)). Thus, the time complexity for the dynamic program is). This refinement once again reduces the computation required for nonpolymorphic loci, and so we might expect substantial improvements in performance over Algorithms 2 and 3. For the choice C = C T , the time complexity is O(k p m(m+n u )). Note that the assumptions necessary for Algorithm 4, namely a symmetric mutation model and uniform mutation and recombination rates, can be relaxed, but at the expense of additional pre-computation. For example, given non-uniform, but locally similar, recombination rates, pre-computation might be performed for each of several rates; each stretch of non-polymorphic loci could then use the pre-computed values associated with the closest recombination rate.
A fast algorithm for configuration partitionsIn Section 2.5, we assumed a configuration partition C to be specified and showed that, for Algorithms 24, the time complexity depends on C through the functions (C) (or p (C)) and (C) and more particularly their sum. It is intuitively clear that a configuration partition minimizing will maximize (as in C T ), and vice versa, and in general these quantities are inversely related; minimizing a convex combination of these quantities is therefore difficult. In this section, we propose a fast and simple parametrized algorithm for constructing reasonably good configuration partitions. Given a configuration n, the algorithm proceeds sequentially over the loci: initially, let, for a particular configuration n and an arbitrary   H n. Several values of s  (2,...,500) were used, and each circle corresponds to a particular value of s. The curve of circles demonstrates the trade-off between small p (small s-values) and small (large s-values). As predicted by the asymptotic time complexity results, running time appears to depend linearly on both p-and-values, and fitting a linear model indicates the constant associated with p is 1.5 times greater than the constant associated with . The configuration n was generated using coalescent simulation for 500 individuals, each having 10 5 bi-allelic loci, using population-scaled mutation rate  = 0.005 per locus and population-scaled recombination rate  = 0.001 between each pair of adjacent loci, and resulting in k p = 1724 polymorphic loci and n u = 324 unique haplotypes block B and add (B,, s ,, e ) to the configuration partition. Set s = e +1 and repeat until locus k is reached. An example configuration partition resulting from this algorithm is shown in. Applying this procedure to configuration n with threshold parameter s results in a configuration partition which we denote C s. Observe that for s =|H n |, we obtain C s = C T , which minimizes. On the other hand, for s = 2 (in the bi-allelic case), the algorithm produces a configuration partition that minimizes p. Intermediate values of s produce the intermediate results that are of interest. In order to gauge the effect of different combinations of p and on the running time, the CSPCSP CSP SMC (|n) was computed using the configuration partition C s for each of several values of s, and the times recorded; the results are plotted in. As our intuition suggested, the running time depends substantially on the choice of C and, in accordance with the asymptotic time complexity results depends linearly on both p and . Furthermore, as anticipated, the values of p and are inversely related.
Blockwise HMM computationBy fitting a linear model to the data, we can deduce the constants associated with p and , which the asymptotic results cannot provide. Although these constants will depend on the implementation and hardware, their ratio should be relatively stable, and therefore informative for choosing an optimal trade-off between p and. We find that the constant associated with p is 1.5 times that associated with , suggesting that running time is minimized for a choice of C that minimizes 1.5 p (C)+(C). Furthermore, making use of the above algorithm, we defineIn practice the value s * is found using binary search and determining C * is very fast. This definition will be used frequently in Section 4, as C * (and the analogous result for Algorithm 1, using in place of p ) provides a good, though not necessarily optimal, choice for C.
RESULTSWe have presented three optimized algorithms for computing the conditional sampling probability (CSP)   SMC (|n). Briefly,Recall that Algorithm 2 with C = C T is equivalent to Algorithm 1.
J.S.Paul and Y.S.Song(b) (a)performance substantially, particularly as the number of haplotypes n increases. Given the results for Algorithm 3 in particular, it is clear that the key quantity p (C)+(C), taken from, increases more slowly with n for C = C * than for C = C T. Finally, as in the previous case, the asymptotic results for general C indicate that computation is dominated by the) term for both Algorithms 3 and 4; the associated convergence of running times appears to be occurring in, though more slowly than in; thus, Algorithm 4 is a practically useful alternative to Algorithm 3, even for larger values of n. Although general trends are clear from, the logarithmic scale makes it difficult to appreciate the magnitude of the effects of the optimizations. As mentioned earlier, assuming rough homogeneity over the genome, the computation time increases linearly with the number of loci. In, we summarize the constant associated with this linear behaviour as the time required to process 110 5 loci, along with the speedup relative to the baseline, Algorithm 1. Observe that Algorithm 3, with C = C * , which can be applied in complete generality, provides a speedup of 15, 250 and 546 for conditional sample sizes n = 100,2000, and 5000, respectively; and in most cases, Algorithm 4 can be applied, which increases these speedups to 320,1300 and 1845. Importantly, the speedup increases with the conditional sample size n.
DISCUSSIONWe have presented a number of optimized algorithms for computing the CSPCSP CSP SMC (|n). Our optimizations are based on two intuitive observations: first, the number of unique haplotypes in a genomic sample is dramatically reduced within relatively short regions and second, the large number of non-polymorphic loci in a genomic sample, though informative, do not distinguish between haplotypes. These observations are formalized and leveraged to refine the recursive equations for computingcomputing computing SMC (|n), yielding optimized, yet exact, algorithms. We have described our optimization algorithms in the context of the HMM associated with the CSDCSD CSD SMC proposed by. It is natural to question whether similar optimizations are applicable to related CSDs, such as those proposed by Fearnhead and Donnelly (2001) and by. In Section 2, we described two sufficient conditions: Property 1, which stipulates that, upon recombination, a new hidden haplotype is chosen independently and uniformly at random and Property 2, which stipulates that the emission distribution depends only on the allele at the current locus of the hidden haplotype. The aforementioned CSDs do satisfy both of these properties; in particular, stronger forms of Property 1 hold for both CSDs, enabling additional optimizations. We have not empirically analysed the resulting optimized algorithms, but by considering the resulting asymptotic time complexities, analogous to those in, we anticipate that the speedups obtained will be qualitatively comparable to those observed forfor for SMC , though the corresponding magnitudes are difficult to estimate. It is also interesting to consider CSDs for more complex demographic scenarios. A theoretically straightforward extension of of of SMC to variable population size, for example, will continue to satisfy both Properties 1 and 2 and will therefore be amenable to very similar optimizations. On the other hand, extension to structured populations, populations that are divided into several demes between which there is limited migration, will not satisfy Property 1 as the new hidden haplotype chosen upon recombination depends on
Blockwise HMM computationthe deme in which recombination occurs. Nonetheless, a relaxed version of Property 1 will be satisfied along with Property 2, and we anticipate analogous optimizations will be possible. The outcome is similar ifif if SMC is extended to conditionally sampling diploid, rather than haploid, individuals. Related optimizations may be possible in other contexts as well. For example, Li and Durbin (2011) make use of a population genetic HMM which satisfies conditions that correspond to Properties 1 and 2 and is used to analyse genomic data. It is interesting to note that, in order to make their method practicable, Li and Durbin consider non-overlapping 100 bp windows as their set of loci; using the optimization detailed in this article may render such compromises unnecessary. It is less clear whether our optimizations are applicable to other population genetic HMMs, such as those considered by; nonetheless, we hope that our work will foster progress in this area. We conclude by recalling that a broad range of population genetic methods have been developed and will continue to be developed, based on the CSD. These methods are generally computationally intensive, and approximations are often made on the basis of efficiency and at the expense of accuracy; with the advent of inexpensive genomic sequencing, such computational problems will be compounded. We have introduced several optimizations for CSD computation that can potentially speed up this computation by several orders of magnitude without introducing additional approximations. We believe that these optimizations will enable analyses that were previously impracticable, particularly for large genomic datasets. We also hope that the optimizations will encourage more accurate methods, and in particular more accurate CSDs, to be developed and used for population genomic inference.
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
