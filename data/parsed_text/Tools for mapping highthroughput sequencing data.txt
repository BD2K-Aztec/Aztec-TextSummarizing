Motivation: A ubiquitous and fundamental step in high-throughput sequencing analysis is the alignment (mapping) of the generated reads to a reference sequence. To accomplish this task, numerous software tools have been proposed. Determining the mappers that are most suitable for a specific application is not trivial. Results: This survey focuses on classifying mappers through a wide number of characteristics. The goal is to allow practitioners to compare the mappers more easily and find those that are most suitable for their specific problem. Availability: A regularly updated compendium of mappers can be found at
INTRODUCTIONIn the past decade, high-throughput sequencing (HTS) has changed the way life sciences research is done. The decreasing costs have made HTS technology more mainstream, and it is now exploited in a growing number of biological applications, the so-called-seq experiments: DNA-seq (, ChIP-seq (), RNA-seq (), BS-seq () and numerous other applications, such as investigating the spatial organization of the genome inside the cell nucleus (). We refer tofor an overview of sequencing technologies and related applications. A common feature of all HTS technologies and applications is the generation of relatively short reads (fragments of DNA sequences), which have to be aligned (mapped) to a reference sequence. The primary challenge is to efficiently find the true location of each read from a potentially large quantity of reference data while distinguishing between technical sequencing errors and true genetic variation within the sample. Presently, more than 60 mappers are available (seefor a list of mappers andfor a timeline), most of them proposed after 2008, concurrent with developments in sequencing technologies. Mappers have had to adapt to: (i) handle growing quantities of data generated by HTS; (ii) exploit technological developments (); and (iii) tackle protocol developments. For instance, paired-end library protocols motivated the development of mappers that exploit read pairing information (). Furthermore, the appearance of novel protocols may result in specific biases (). One consequence of the increasing number of mappers is that making a suitable choice for a specific application is not easy. Resources such as the SeqAnswers forum Wiki pages () have collated information about different mappers, such as the operating system supported and different technologies that the mappers have been designed to handle. However, information about other equally important features/ characteristics of the mappers is difficult to find, being still scattered through publications, source code (when available), manuals and other documentation. This survey aims to help overcome these challenges by allowing practitioners to compare mappers more easily and, thus, find those that are most suitable for their specific problem. It does not evaluate mappers in terms of their accuracy, but instead it presents an overview of their characteristics. It complements previous studies that focused mainly on a reduced subset of mappers and/or empirically compared the performance of a small number of mappers (;).
OVERVIEWThe HTS data mapping problem can be generally stated as follows: given a set of sequences Q (produced by an HTS technology), a set of reference sequences R, a possible set of constraints and a distance threshold k, find all substrings m of R that respect the constraints and that are within a distance k to a sequence q in Q, i.e. dq, m k, where d() is some distance function. The occurrences m in R are called matches. The constraints imposed can vary depending on the HTS application and data type (e.g. whether the data generated are single-or paired-end reads). The main goal of a mapper is to find the true location of each sequence q from a potentially large quantity of reference data while allowing for errors and structural variation. To allow for these errors/variants, the matching has to be approximate. The distance measures typically used account for the number of mismatches and indels to allow for errors and structural variation, but they may also incorporate gap sizes or probabilities associated with the reads.provides a brief overview of the mappers considered herein. The information presented in the tables of this manuscript was collected mainly from the publications, manuals and other documentation, by direct inspection of the source code, and, in some cases, by contacting the developers. When we could not collect information, the cells in the table were left *To whom correspondence should be addressed.  The Author 2012. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/3.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.Li et al.(
Input data featuresThe read length supported by a mapper is a particularly important characteristic. For instance, aligning miRNA data, which typically comprises short reads ranging between 16 and 30 bases in length after trimming the adapters, requires mappers that support rather short reads. Naturally, the miRNA-specific mappers support reads of the mentioned length, but some more general purpose mappers, such as Bowtie, BWA, GNUMAP, MapReads, Maq, Novoalign, SHRiMP, Stampy and SOAP, may also be used for this purpose. In contrast, advances in sequencing technologies have enabled reads longer than 1000 bases to be generated (up to 10 000 bases have been reported using PacBio sequencing). The trend of increasing read length has motivated the development of novel mappers (e.g. RazerS, BWA-SW, SOAP2, RUM, RMAP, SOAPSplice and Bowtie2) that efficiently handle the longer reads. Sequencing platforms can produce reads in pairs, which can help to detect alignment errors and to improve sensitivity and specificity compared with using single-end reads (). The majority of the mappers exploit read pairing information (see PE column in). To align paired reads, a strategy often followed is to independently align the two reads belonging to a pair before searching for the pair of hits with the correct orientation relationship and proper distance. HTS data can consist of hundreds of millions of reads. Therefore, it is useful when the mappers can (natively) be executed inin the fourth and fifth columns, respectively, including when possible the maximum number of allowed mismatches and indels: by default the value is in bases; in some cases, the value is presented as a proportion of the read size; or as score, meaning that mapper uses a score function. The Gaps column indicates whether consecutive insertions or deletions are allowed during alignment. The Alignments reported column indicates the alignments reported when a read maps to multiple locations: A-all, B-best, R-random, U-unique alignments only (no multi-maps), and S-user defined number of matches. The Alignment column indicates whether the reads are aligned end-to-end (Globally) or not (Locally). The Parallel column indicates whether the mapper can be run in parallel and, if yes, how: using an SM or/and a DM computer. The QA (Quality awareness) column indicates whether the mapper uses read quality information during the mapping. The support for paired reads is indicated in the PE column. The Splicing column indicates, for the RNA mappers, whether the detection of splice junctions is made de novo or through user provided libraries (Lib). Yes is abbreviated as Y, and No is abbreviated as N. A cell in the table is filled with '' when a third-party mapper is used to perform the alignment. parallel in distributed-memory (DM) computers (i.e. a cluster composed of multiple computers) or/and using shared-memory (SM) computers (available in computers with modern shared-memory multi-core processors). Given the large number of reads that need to be mapped, it is not surprising that the majority of the methods have been developed to exploit multiple processors/computers to speed up the mapping. A different approach is followed by CloudBurst (), a cloud aware mapper designed to run in computer clouds and in local computer clusters. Implementation details for each mapper are provided in the Supplementary file. The Quality aware column inindicates whether a mapper exploits the base quality scores (generated by the sequencer) during the alignment. It has been shown () that using accurate quality scores can reduce alignment errors by giving a lower penalty for a mismatch in a position with a low quality score. Several mappers, such as Bowtie, BWA, GEM-Mapper, PASS, SHRiMP2, ZOOM, SOCS, RMAP and GNUMAP, exploit quality scores during the alignment but differ in the way that they do it. For instance, RMAP does not penalize mismatches for bases with a quality score below a pre-determined cut-off value, whereas Novoalign uses base qualities to calculate base penalties for the NeedlemanWunsch algorithm. GNUMAP goes a step further and uses the Solexa/ Illumina probability output files to construct a position weight matrix for each read, before a modified NeedlemanWunsch alignment algorithm exploits these matrices to score and align a read against the reference sequence.
Variation and errorsTo cope with errors and variation, mappers must allow the matching of the reads to the reference sequences to be approximate. For instance, in a project to detect genome variation, the mapper should allow a small number of errors but enough to cope with the expected variation. However, more errors should be allowed when aligning reads against reference sequences from different species or when longer reads are used, e.g. 5 mismatches in a read with 36 bases (14%) is quantitatively different from 5 mismatches in a read with 150 bases (3%). The Mismatches and Indels columns inindicate whether a mapper aligns reads while allowing for errors (mutations and short indels), whereas the Gaps column indicates whether consecutive insertions or deletions are allowed during alignment. The challenge is to distinguish between nucleotide variation caused by true genetic variation and differences from the reference due to inaccuracy in sequencing. In an attempt to improve computational efficiency, many mappers impose constraints on the number of mismatches/gaps allowed. Some mappers allow a small number of mismatches (e.g. ELAND supports up to 2 mismatches, VMATCH and WHAM support up to 5 mismatches and BSMAP supports up to 15 mismatches), whereas others accept an arbitrary number of mismatches and no indels (e.g. MapReads, MicroRazerS and mrsFast). Some mappers support indels but, again, often with some constraints: e.g. SOAP and SOAP2 support up to 3 and 2 indels, respectively, MrFast up to 6 indels and BWA up to 8 indels. Finally, some mappers impose no constraint on the number of mismatches and indels (e.g. Bowtie, Bowtie2, GNUMAP, Mosaik, RazerS, SSAHA2, VMATCH, SHRiMP and SHRiMP2). In this final case, a threshold on the score function value is often used to determine whether a read is mapped to a particular location. Support for gaps (long indels) comes at the cost of computational efficiency but is a feature required in several contexts, namely, to map longer reads (because they have a greater probability of containing gaps) or to map RNA-seq data. Li andshowed that gapped alignment increases the percentage of reads mapped but that it did not reduce the percentage of reads incorrectly aligned. In an attempt to minimize the computational cost incurred from allowing gaps, many mappers impose constraints: e.g. SOAPSplice, SpliceMap and WHAM allow for a single gap with different gap size constraints; SOAP2 and QPALMA allow a single gap with no constraint on size and BLAT allows multiple gaps with a maximum size of 23 kb. The alignment phase in RNA-seq experiments presents many challenges that arise, in general, from splicing events. These can be handled easily if reads are mapped to a pre-defined transcriptome at the cost of missing novel transcripts. Alternatively, the reads can be mapped to the genome. However, reads that span multiple exons will have potentially large gaps in the alignment corresponding to intronic sequence. Hence, RNA-seq mappers should be able to support large gaps, as is the case for MapSplice, TopHat, Supersplat, SOAPSplice, SpliceMap, RNA-mate, RUM, PASS, QPALMA or MapSplice. These mappers are also termed spliced aligners () owing to their ability to align a read to multiple exons. Some of these mappers are, in fact, wrappers to other mappers (e.g. TopHat uses Bowtie; RUM uses Bowtie or BLAT; RNA-Mate uses MapReads and SpliceMap can use Bowtie, Eland or SeqMap). Some wrappers (e.g. MapSplice or SpliceMap) use an exon-first approach that involves two main steps: (i) map reads to the genome using unspliced read aligners; (ii) unmapped reads are then split into shorter segments and aligned independently. The genomic regions surrounding the mapped read segments are then searched for spliced connections. This approach is efficient because a smaller proportion of the reads are used in the more computationally demanding second step. Alternative approaches are seed-and-extend variations, as exemplified by TopHat when used to align RNA-seq reads to a genome. Briefly, TopHat starts by mapping the reads using Bowtie against the whole genome, and then aggregates the reads into islands of candidate exons, before generating potential donor/acceptor splice sites using neighbouring exons. Finally, unmapped reads are mapped (using Bowtie) to these splice junction sequences.
AlignmentsThe task at hand will determine whether the exact alignments or locations are of interest. Mappers can report (semi-) global or local alignments with respect to the reads (see Alignment column in). A mapper performs a (semi-) global (or end-to-end) alignment with respect to the reads when it produces an alignment that involves all of the bases in the read. A local alignment considers only bases in part of the read (bases at the ends of the read are usually omitted in the alignment). Local alignment of the reads is often faster than global (or end-to-end) alignment because the mappers can stop the alignment process when a good quality unique match is found. This is useful for cases where the number of hits is of interest, as opposed to the alignments per se. Multi-map reads (also known as multi-reads) are those that align to multiple locations with similar alignment scores, due to the reads originating from repetitive regions and/or due to the short length of the reads. Having identified a multi-map read, a mapper has several reporting options. For instance, in RNA-seq data analysis when the reference is a transcriptome, one may want to consider reads with many possible alignments (and then perform some post-processing). TopHat, on the other hand, uses Bowtie to map and report reads with up to 10 possible locations and excludes the reads that have more than this number of alignments: the aim is to include multi-map reads from paralogous genes but to exclude reads aligned to low-complexity sequences. Although several mappers have an option to report all possible mapping locations of a read, they are less efficient than mappers specifically designed for this purpose, such as mrFast, mrsFAST and PatMaN.
EXECUTION TIME AND MEMORY REQUIREMENTSThe computational time required by a mapper to align a given set of sequences and the computer memory required are critical characteristics. If a mapper is extremely fast but the computer hardware available for performing a given analysis does not have enough memory to run it, then the mapper is not very useful. A mapper is also not useful if it has a very low memory requirement but is very slow. Hence, ideally, a mapper should be able to balance speed and memory usage while reporting the desired mappings. We measured the computational speed and memory requirements of the mappers empirically. The human genome (Homo sapiens, assembly GRCh37), obtained from Ensembl (build 66), was used as a reference. Two further reference sets (subsets of chromosomes of the human genome, with a size of 130 Mb and 1 Gb) were used to assess the impact of reference size on computational speed and memory usage. Samples of 1 million high-quality reads were mapped against each reference.presents the total time (in minutes), maximum memory usage, time spent in pre-processing/preparing the data (which includes indexing), time spent on mapping and number of reads aligned. Because of space constraints, we only show, for each type of data, the five mappers with lowest mapping time, total time, memory usage or highest number of reads mapped when aligning to the whole human genome. It should be stressed that the focus of the evaluation is on the speed and memory of the mappers, and the accuracy of the mappings produced was not evaluated. All the values presented are averaged across multiple runs. The default parameter values of the mappers were used whenever possible, and no parameter optimization was attempted. The mappers were configured to use a single processor and up to a maximum of 32 GB of RAM. Further information about the data, methods and more results are presented in Section 2 in the Supplementary file.
DISCUSSIONThe development of numerous mappers for HTS data is motivated not only by novel developments of HTS technology but also by the growing number of biological applications. The variety of applications has led to the appearance of specific types ofOne commonly asked question is what is the best mapper for a given application. Although the 'best mapper' criterion involves application-specific requirements such as how well it work in conjunction with downstream analysis tools (e.g. variant callers), it often also includes speed and, in particular, accuracy. Despite some recent evaluation studies (), determining the most accurate and fastest mappers for a particular application is still difficult. The primary challenge in assessing mappers is the lack of gold standard datasets for different applications and sequencing technologies. These datasets would not only include the reads but also their true locations and could be based on true data or data generated in silico, using novel or existing simulators such as ART (), BEERS () or FluxSimulator (). The research community has started to address these issues in the context of different projects, such as the RGASP (http://www.gencodegenes.org/ rgasp/) and the Alignathon (http://compbio.soe.ucsc.edu/alignathon/) projects, which aim, respectively, to assess the status of computational methods to map human RNA-seq data and DNA-seq data to whole genomes. However, no results are publicly available at this time. More generally, a common approach for comparing mappers has been to count the number of reads aligned. However, increasing the number of reads is not useful if the probability of the reads being correctly mapped decreases, i.e. if the increase in mapped reads is done at the expense of increasing the proportion of incorrectly mapped reads. One way to address this problem would be to compute the likelihood of a read being correctly mapped (e.g. as available in RMap or ZOOM) and allow the users to choose only the alignments above some threshold. Users may want to consider several mappers in their HTS analysis and to incorporate them in pipelines, such as in ArrayExpressHTS (). This raises the issue of mapper interoperability. To achieve interoperability, input and output formats need to be standardized. Currently, the majority of the mappers accept input files in FASTQ or CFASTQ format and generate SAM/BAM files as output. Hence, the level of interoperability is high. However, there is still room to improve because FASTQ files include quality values encoded in different formats and BAM files can also come in different 'flavours' (their standardization should be encouraged). Moreover, in the future, mappers may also include the option to output files in the CRAM format (), which may prove useful for efficiently compressing DNA sequences. The input parameters of the mappers are far from being normalized, which makes it more difficult for a practitioner to switch between mappers. Hence, it would be useful if there was an effort to standardize the most commonly used parameters (e.g. for defining seed lengths, input/output files and formats). Finally, the great flexibility and configurability of most mappers comes with a price: a considerable number of parameters that have to be set. Determining the best parameter values to achieve some pre-defined level of mapping specificity/sensitivity is far from being trivial. Mappers with the ability to automatically tune their parameters to achieve some user-defined specificity/sensitivity may be a solution to this problem.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Mapping high-throughput sequencing data at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from blank. We collected, and included in the table, the number of citations of the bibliographic reference (when available) associated with each mapper, and the number of citations normalized by the lifetime (in years) of the publication in an attempt to provide an idea of the popularity of the mappers. However, we emphasize that one cannot infer that mapper A is better than mapper B simply because it is cited more often. One obvious issue when considering the choice of a mapper is the type of data that it was designed for or is suitable to align (DNA, RNA, miRNA or bisulphite). Another dimension to consider is the sequencing platform that generated the HTS data. General mappers such as BLAT, SSAHA, Exonerate and Mummer were designed for aligning any sequences (DNA, RNA or Protein), and the source of data is irrelevant. However, as can be observed in Table 1, a considerable number of mappers support HTS data generated from a subset of technologies. For instance, Slider was designed specifically for Illumina data and exploits the base call probabilities in Illumina's probability output files. In contrast, SOCS, RNA-Mate and MapReads are tailored for aligning SOLiD reads, which are encoded in colour space. Some mappers also try to exploit specific biases associated with a sequencing platform. For instance, for the Illumina platform, sequencing accuracy decreases with increasing number of read cycles; therefore, less reliable base calls are produced towards the 3 0-end of each read. Some mappers like SOAP, Bowtie or Novoalign can therefore trim several bases off the 3 0-end of reads in an attempt to overcome this problem. Most eukaryotic genes are composed of multiple exons, which can be spliced together in distinct combinations to generate different transcripts. Thus, when RNA-seq reads are mapped to a reference genome, reads that span multiple exons will have potentially large gaps in the alignment corresponding to intronic sequence. The Splicing column in Table 2 indicates for the RNA mappers whether the detection of splice junctions is made de novo or via user-provided libraries of junction locations. De novo detection of splice junctions means that the mappers are able to detect splice junctions without relying on existing annotation. An alternative is to build exon junction libraries that include sequences around known or predicted splicing junctions. Some mappers construct these libraries during execution using splice junction information provided by the user, whereas others require that the user provides the library. Finally, hybrid approaches that couple de novo with prior information are also possible. For example, QPALMA starts by aligning the reads to the genome to identify putative exons from clusters of mapped reads. Next potential junctions are enumerated within a certain distance around putative exons. Finally, the unmapped reads are aligned against the sequences flanking possible junctions, thus making it possible to find novel junctions. QPALMA, although similar to TopHat, differs by training a support vector machinelike algorithm using known splice junctions from the genome of interest (thus also requiring a set of known junctions from the reference). 3 FEATURE-LEVEL COMPARISON Table 2 enables a comparison of mappers based on data-centric features (e.g. read length limits, utilization of read pairing information, parallel processing) and alignment sensitivity and reporting (e.g. errors allowed, support for gaps, alignments reported, type of alignment performed and the role of read quality information during alignment).
Mapping high-throughput sequencing data at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
N.A.Fonseca et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Mapping high-throughput sequencing data at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
