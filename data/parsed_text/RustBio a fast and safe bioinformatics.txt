We present Rust-Bio, the first general purpose bioinformatics library for the innovative Rust programming language. Rust-Bio leverages the unique combination of speed, memory safety and high-level syntax offered by Rust to provide a fast and safe set of bioinformatics algorithms and data structures with a focus on sequence analysis.
IntroductionWith ever increasing amounts of experimental data being generated, their computational analysis becomes increasingly challenging. For novel or custom problems where carefully engineered highperformance standalone tools (like read mappers) are not yet available, general purpose bioinformatics libraries can help to minimize the coding effort. Bioinformatics libraries are published for many popular programming languages, e.g. SeqAn for C, Biopython, Bioperl and BioRuby (). Choosing the programming language for a specific task usually entails a tradeoff between execution and development speed. Low-level system programming languages like C or C provide optimal performance at the cost of increased complexity. Higher level languages like Python or Perl provide a more concise syntax while leading to computational overhead introduced by online memory management (e.g. reference counting or garbage collection), type inference and not being compiled but interpreted during execution. Often, the combination of a high-level language with some carefully engineered implementations of a bioinformatics library is a good choice to quickly solve a problem with reasonable performance. However, the amounts of data the bioinformatics community is facing in the coming years and the need to handle nature's resources carefully implies that using a high-performance, compiled language is still beneficial for certain problems. Recently, Rust (http://www.rust-lang.org) has gained attention as a new programming language combining speed with memory safety and high-level syntactical features. Being compiled with LLVM (), Rust has many advantages of low-level, system programming languages, such as speed and a small memory footprint. Supporting automatic type inference, its code is often less verbose than C or C code. With Rust, type inference happens at compile time, such that runtime overhead (appearing with scripting languages like Python) can be avoided. The key feature of Rust is a concept of ownership and borrowing of variables, that enables the compiler to automatically decide about lifetime of objects during compile time, making an online memory management superfluous without requiring manual freeing of resources. At the same time, this concept prevents common sources of errors with low-level languages like accessing invalid memory regions. Finally, the ownership concept enforces thread-safety, such that race conditions cannot occur. These features make Rust a promising solution to above tradeoff problem. In this work, we present Rust-Bio, the first general purpose bioinformatics library for the Rust programming language. Rust-Bio provides a high-level, fast and safe API for many state-of-the-art data structures and algorithms used in bioinformatics.
LibraryRust-Bio is built with the following principles in mind. Where possible, iterators are returned. This allows to process streams of data with minimal memory footprint. On top, using the extensive set of iterator tools available in Rust, iterators can be, e.g. filtered,structure, we provide complexities in the documentation. Where more than one alternative is available, the documentation tries to highlight distinguishing use cases. So far, Rust-Bio is focused on algorithms and data structures for biological sequences. A central component of Rust-Bio are alphabets, which, e.g. allow to check in linear time whether a given sequence is a word over the alphabet, transform symbols to their lexicographical ranks and perform bit-encoding to save memory or iterate over q-grams. Rust-Bio can read and write common file formats like FASTA, FASTQ and BED. For SAM/BAM, CRAM and VCF/BCF support, it is complemented by Rust-HTSlib. Listing 1 Creating an FM-Index for a given sequence with an occurrence table sampling rate of 3. Here, the alphabet is used to provide guarantees for being able to limit memory usage during FMIndex construction. Afterward, we iterate over a FASTQ file, use the alphabet to validate read sequences and search for exact matches in the FM-Index. This example illustrates how to create a simple read mapper with Rust-Bio.Especially when considering sequencing data, many problems can be solved with a set of well-established data structures like suffix arrays (), the Burrows-Wheeler Transform (), rank/select data structures () and q-gram indices. In line with that, Rust-Bio implements induced sorting for suffix array construction (), the FM-Index () for pattern matching on top of the Burrows-Wheeler Transform, a practical variant of a rank/select data structure () and a q-gram index for arbitrary alphabets and q 32. Further, Rust-Bio implements the FMD-Index (), that allows to find supermaximal exact matches in DNA sequences and their reverse complements in linear time. Implementations for many classical pattern matching algorithms are provided, including the algorithm of Knuth, Morris and Pratt, Backward Nondeterministic DAWG Matching, Backward Oracle Matching, the algorithm of Horspool and the Shift-And algorithm (). In the Supplementary Material, we compare the speed of these algorithms against the C-based Seqan, which is among the fastest bioinformatics libraries (). The benchmarks exemplify that the speed of Rust-Bio is comparable to that of C-based implementations. For approximate pattern matching, Ukkonen's dynamic programming-based algorithm () and Myer's bit-parallel algorithm () are provided. Finally, Rust-Bio implements local, global and semi-global pairwise sequence alignment as variants of the SmithWaterman and NeedlemanWunsch algorithms (). An example for using the Rust-Bio API can be seen in Listing 1.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Conclusion Rust-Bio is a general purpose bioinformatics library. Building on the innovative Rust programming language, Rust-Bio combines memory safety with speed, complemented by rigorous continuous integration tests. So far, a wide set of algorithms and data structures for biological sequences is provided, ranging from index data structures to pattern matching and alignment, complemented by readers and writers for common file formats.
Rust-Bio
J.K ster at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
