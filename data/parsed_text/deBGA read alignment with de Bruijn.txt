Motivation: As high-throughput sequencing (HTS) technology becomes ubiquitous and the volume of data continues to rise, HTS read alignment is becoming increasingly rate-limiting, which keeps pressing the development of novel read alignment approaches. Moreover, promising novel applications of HTS technology require aligning reads to multiple genomes instead of a single reference; however, it is still not viable for the state-of-the-art aligners to align large numbers of reads to multiple genomes. Results: We propose de Bruijn Graph-based Aligner (deBGA), an innovative graph-based seed-and-extension algorithm to align HTS reads to a reference genome that is organized and indexed using a de Bruijn graph. With its well-handling of repeats, deBGA is substantially faster than state-of-the-art approaches while maintaining similar or higher sensitivity and accuracy. This makes it particularly well-suited to handle the rapidly growing volumes of sequencing data. Furthermore, it provides a promising solution for aligning reads to multiple genomes and graph-based references in HTS applications.
IntroductionA fundamental challenge of high-throughput sequencing (HTS) technology is the quick and accurate alignment of sequencing reads to one or more reference genomes (). Read alignment is one of the most compute-intensive steps of HTS analysis (), and is becoming increasingly ratelimiting as HTS technology becomes ubiquitous and the volume of data from each sequencing run continues to rise. Moreover, as more genomes are available (), promising new applications of HTS technology require aligning reads to multiple genomes instead of a single reference. For example, the genomes of the typical strains of a species are used as gold standard reference points (), and species or pathogens can be precisely identified and characterized by simultaneously aligning reads from isolated or metagenomic samples to these reference genomes (), which has enormous potentials. Similarly, reads from mouse xenograft models typically need to be aligned to both the human and the mouse genome. However, it is still not viable to align large numbers of HTS reads to multiple divergent genomes of various strains or species simultaneously, primarily due to two limitations. Firstly, most state-of-the-art aligners are optimized for a single genome reference. Although they can support almost any reference sequence, appending genomes together to make a longer reference typically degrades performance and decreases accuracy, as many reads have multiple, equally good matches. Secondly, efforts have been made to support pan-genome indexing (); however, most of the proposed methods organize genomes through collinear multiple sequence alignment (MSA). These approaches are useful for highly similar genomes, such as multiple human genomes (1000 Genomes), but not the genomes of more distant strains or species. Such distant homologues often have significant structural variants (SVs) () (such as inversions, translocations and duplications), and collinear MSA could be not suitable for representing these non-collinear events (). In this situation, these approaches may not be applicable to align reads against multiple divergent genomes, e.g. a reference composed by a set of microbial genomes. Moreover, proposed pan-genome indexing methods also have additional limitations. GenomeMapper () and BWBBLE () can only integrate relatively small variants (such as SNPs and small indels). The size of generalized compressed suffix array index () could exponentially increase, which could not be suited to handle the variants in repetitive regions ().proposed an augmented MSA-based graph (named as population reference graph, PRG) to better support diverse kinds of variants. In this approach, the de Bruijn graph of the reads is aligned with PRG to infer the donor genome. This approach falls between de novo assembly and the alignment of genome sequences. It is suited to the inference of the complex genomic regions, such as the MHC region. However, it is mainly designed for local regions, and due to the lack of effective approach to index the PRG of whole genome, it is still non-trivial to extend this approach to the read alignment against whole genome. Besides the aforementioned limitations, MSA-based aligners also have lower speed, e.g. 10100 times slower than state-of-the-art aligners (). Meanwhile, the MSA itself may also affect the result of read alignment, as there is still not a standard method to implement the MSA of genomes (). Most of the state-of-the-art generic aligners are based on seedand-extend approach (). They are superior to backtracking suffix tries [utilized, e.g. BWA (for the increasing read length of HTS technologies, which requires large edit distance. Generally, seed-and-extend aligners consist of two steps: (i) seeding: the inference of putative read positions (PRPs) from the matches (hits) of tokens (seeds) between the read and reference genome; and (ii) extension: alignment of the read to the region surrounding each PRP to determine the most likely read position(s). One of the major bottlenecks faced by this approach is how to handle repetitive genomic regions, even in the context of a single genome, for example, over 50% of the human genome comprised repeats (). Because of repeats, many seeds have numerous hits, and the cost of extending all of them is prohibitively high. This problem is even more serious for a reference consisting of multiple genomes, as it will be even more repetitive due to the homologous sequences. Various strategies have been developed to handle hits more effectively, including heuristically filtering the hits (), limiting the number of hits per seed () or merging hits before extension (). However, as all of these strategies process each hit independently, it could be also expensive to evaluate, sort and prioritize the numerous hits. After these steps, however, there could be still a number of candidates left for extension due to the repeats, and the cost of separate alignment of the read to each of them could still be prohibitive. To improve the alignment of reads to multiple references, as well as the handling of repeats within a single genome, we propose the de Bruijn Graph-based Aligner (deBGA), which uses a graph-based seedand-extension algorithm to align reads to one or more genomes that have been organized and indexed by a Reference de Bruijn graph (RdBG). de Bruijn graph and A-Bruijn graph were used for the alignment of genomes (); however, they have not been fully utilized for HTS read alignment. deBGA takes the advantage of the non-branched paths of RdBG (i.e. unipaths;) to recognize similar seeds and identical local sequences, which enables it to simultaneously evaluate multiple PRPs located in the same unipath, regardless of the repetitiveness of the corresponding seeds. This greatly reduces the computational burden caused by repeats. Due to its handling of repeats, deBGA is substantially faster than other stateof-the-art aligners. Furthermore, to our knowledge, deBGA is the first viable solution which can align reads to multiple genomes with high throughput and without restriction on the types of variants.
Materials and methods
Overview of the deBGA methoddeBGA builds an RdBG to organize one or more reference genomes, and uses a hash table-based data structure, Reference de Bruijn graph Index (RdBG-Index), to index the unipaths of the RdBG instead of the original sequence (and Supplementary). This novel genome index provides two fundamental operations to. A schematic illustration of the deBGA method. (a) The organization and indexing of reference. The reference (consisting of one or more genomes) is collapsed into an RdBG. As the copies of a k-mer within the reference collapse to the same vertex of the RdBG, the repetitive sequences of the reference (the segments with various colors) collapse to various unipaths (the hollow dots with the same colors corresponding to the repetitive sequences). Further, the unipaths are indexed by RdBG-Index, a hash tablebased data structure (Supplementary). (b) The read alignment method. The k-mers of the reads are used as seeds and matched to the vertices of the RdBG through RdBG-Index (the solid vertices). deBGA takes advantage of the property of RdBG to merge seeds having similar PRPs through unipaths, which can efficiently process repetitive seeds (Section 2, Supplementary). For each of the merged seeds (the blue and red rectangles), if all the local sequences around its PRPs are within the same unipath (the case of 'read2'), the read is directly aligned with the unipath (the red dashed arrows) for simultaneously performing the corresponding extensions (Supplementary); otherwise, deBGA clusters the local sequences extending outside the unipath on-the-fly, and separately aligns the read with the clustered local sequences (the blue dashed arrows) (Color version of this figure is available at Bioinformatics online.) recognize and merge similar seeds as well as identical local sequences by taking the advantage of the unipaths of de Bruijn graph. With the RdBG-Index, multiple similar seeds and identical extensions within the same unipath can be simultaneously handled regardless of their repetitiveness. deBGA utilizes the functions of RdBG-Index for implementing a graph-based seed-and-extension approach which can well-handle the repeats within the reference to reduce the cost of read alignment. A schematic illustration of the deBGA method is in.
Indexing reference genome with RdBG-IndexdeBGA initially builds a de Buijn graph of the reference genome (RdBG) with a user-defined k-mer length (-k option in the software). The vertices and edges of the RdBG are simply derived from all the (k  1)-mers of reference genome. deBGA investigates the in-and out-degrees of the vertices to recognize the starting vertices of the non-branched paths (i.e. the unipaths) of RdBG, and derives the unipaths by traversing the graph from the starting vertices. The sequences of the unipaths (unitigs) are then generated by collapsing all the vertices of the corresponding unipaths. As a unitig may have multiple copies in the reference genome, for each of the unitigs, deBGA also records the starting positions of all its copies. RdBGIndex is then built for indexing the unitigs. It consists of three major data structures (SupplementaryThis index provides three major functions: (i) retrieving the unipath coordinate for a given k-mer (including the offset of the k-mer within the unipath), (ii) retrieving all the genomic positions corresponding to a given unipath coordinate and (iii) retrieving the corresponding unitig for a given unipath. It is worthnoting that, for any k-mer of the reference genome, its unipath coordinate is unique, as it appears exactly once in RdBG. Moreover, the genomic positions of any given k-mer can be obtained by jointly retrieving UT k-mer and UT pos. Using the three functions, the following two operations are implemented to merge similar seeds as well as reduce identical extensions.
Recognizing similar seeds through unipath decompositionAll the copies of a k-mer within the reference genome collapse to the same vertex of the RdBG. This property indicates that a k-bp-long seed's hit on the reference genome essentially connects the seed and a certain vertex of RdBG, i.e. the hits of the seed are exactly the short token matches on the various copies of the same unitig. Thus, the hit at the ith copy of the unitig, G i hit , can be represented aswhere C U is the number of the copies of the unipath, G i U is the starting position of the ith copy of the unitig, and O hit is the unitig offset of the seed. Considering that, for each of the hits, a specific PRP can be estimated as a genomic position around G i hit  O read  E indel  1   , where O read is the seed's offset on the read and E indel is the effect of indels, all the PRPs can be decomposed by the G i U , O hit , O read and E indel values (Supplementary). It is also worthnoting that when inferring PRPs, most aligners consider the effect of indels (E indel ) as a constant (e.g. considering it as a limited size of indels).In this situation, if two seeds hit the same unipath, it is possible that they have two similar sets of PRPs (Supplementary). More precisely, for each copy of the unipath, the distance between the corresponding PRPs of the two seeds can be represented asand(iv) particularly take advantages of the two operations mentioned above. In each iteration, if the edit distance of the best end-to-end alignment found is smaller than a pre-defined threshold, C ED (-c option in the software), deBGA considers that the read is confidently aligned and stops the process early. The obtained optimal and suboptimal alignments will be outputted as results. However, if the read still cannot be successfully aligned after R S iterations, deBGA resets the seed density to R S  I S bp, and ignores the limitation on the number of hits per seed, i.e. sets M hit  1, to deal with very repetitive reads. In practice, for most reads, the algorithm finishes in only a few iterations by finding an alignment with edit distance much smaller than C ED. It is also worthnoting that there is a heuristic in deBGA for handling very divergent reads. If there is at least one match between seeds and reference in a given iteration, but no successful alignment is obtained, deBGA can dynamically adjust the early-stop condition, depending on the user setting. That is, in the following iterations, deBGA can dynamically adjust C ED according to the user setting of cl option, or accept the best obtained local alignment as a result if the local option is set. If neither of the two options are set (the default setting of deBGA), the heuristic will not be used. This heuristic is beneficial for effectively handling large number of sequencing errors, e.g. simultaneously improving the sensitivity and throughput of the alignment of the reads having many low quality bases.
Seed generationdeBGA finds maximal exact matches between the read and the unitigs as seeds (called 'Uni-MEM seeds'). A Uni-MEM seed is generated initially by a k-mer match from the read to a specific unitig, and the match is subsequently extended until it meets a mismatch or the end of either the read or the unitig (Supplementary). In practice, for the rth iteration (r  1,. . ., R S ), deBGA extracts the kmers starting at every (R S  r  1)I S bp from the read as candidates, and tests each of them from upstream to downstream. As a UniMEM may cover multiple candidate k-mers, deBGA will neglect the untested positions which have already been fully covered by an existing Uni-MEM. A Uni-MEM seed can be formulated by a tupleS UOffset depicts the connection between the read and the RdBG (called a 'read-RdBG connection'), where S R indicates the seed's offset on the read, S UI D and S U Offset ; respectively indicate the identifier and the offset of the unitig. S cover is a bit-vector recording the read positions covered by the seed, and S hit is the set containing all the hits of the seed. A Uni-MEM seed can be also seen as an implicit combination of a series of continuous k bp seeds (Supplementary). Because of the property of the RdBG, all such seeds imply identical PRP sets, i.e. they are practically equivalent for the read alignment process, and a Uni-MEM seed implicitly merges them.
Seed reduction within same unipathdeBGA bins the Uni-MEM seeds in terms of their unipaths to reduce seeds implying similar sets of PRPs. For each bin, deBGA chooses the seed having largest coverage length as the 'merging seed', and checks whether each of other seeds in the bin can be merged. If it can be merged, deBGA removes the seed and merges its S cover vector into that of the merging seed (Supplementary). The merging condition is as following, assuming the read-RdBG connections of the merging seed and the testing seed are, respectively,U Offset , if the value ofis smaller than the maximal allowed length of indels, the two seeds are considered similar and merged. Here, the maximal allowed length of indels is used for considering the effect of small indels during the merging process, and the parameter is empirically set as 32. When a merging seed cannot merge any remaining seeds in the same bin, deBGA sets it aside and chooses a new one from the remaining seeds to continue this procedure, until no seeds remain.
Seed merging across unipathsSeeds within various unipaths may have hits at nearby genomic positions. deBGA merges these similar hits using a split-and-merging approach. For each seed remaining from the last step, deBGA splits it into a set of individual 'hit-seeds', i.e. each of them inheriting the read-RdBG connection and read coverage from the original seed, but only associated with a specific hit. All the hit-seeds are binned in terms of their positions. For each bin, the hit-seed with largest read coverage length is selected, and other hit-seeds are merged into it by simply merging their S cover bit vectors. Next, deBGA regroups the merged seeds which have identical read-RdBG connections and read coverage vectors. The seeds generated by the regrouping are considered as candidate seeds for extension. To avoid unnecessary extensions, deBGA pre-filters out all candidate seeds with coverage length !k bp shorter than that of the largest seed. For paired-end reads, deBGA also filters out the hits on each end of the read that cannot be paired with any hit on the opposite end.
Seed extension with identity checkingFor each candidate seed, deBGA investigates the local structure of the RdBG around the seed to recognize whether the corresponding unipath can accommodate the local sequences for extension. If so, a simultaneous extension will occur because the corresponding local sequences are identical (Supplementary). Otherwise, deBGA extracts and clusters all the local sequences around the PRPs of the seed, and separately aligns the read against each of the clustered sequences. It is worthnoting that the employed local sequences are not always as long as the read shown in Supplementary. If that happens, deBGA, respectively, extends both sides of local sequences at an extra 32 bp (i.e. the maximal allowed length of indels) to cope with potential indels. LandauVishkin () and banded SmithWaterman () algorithms are used to implement end-to-end and local alignment, respectively. After the extension process, the primary and alternative alignments of the read are chosen based on the alignment score, and a BWAlike mapping quality is also calculated based on the chosen alignments.
Anchoring alignment for paired-end readsFor paired-end reads, deBGA performs additional processing if the read is unaligned after all the iterations. In such cases, deBGA separately aligns the two ends of the read with the seeds generated in the R S-th iteration (the seeds are recorded in advance). The optimal and suboptimal alignments of each end are used as anchors, and the opposite read ends are aligned to the local regions around the anchors to compose a paired-end alignment. However, if too many bases of the opposite end cannot be matched in the anchoring alignment, the single-end alignments of the two ends are separately outputted as the result.
ResultsWe benchmarked deBGA with two categories of tasks, i.e. read alignment against multiple genomes and a single genome, to evaluate its ability on various applications. In each of the tasks, a series of simulated and real datasets were employed to assess its speed, sensitivity and accuracy. Six state-of-the-art aligners, Bowtie2, BWA, BWA-MEM, STAR, SeqAlto and GEM, were compared. All the aligners were run with a variety of configurations (Supplementary Notes). The benchmarks were conducted on a server with an Intel Xeon E4820 CPU at 2.00 GHz and 1 TB RAM, running Linux Ubuntu 14.04.
Read alignment against multiple genomes
Read alignment against multiple genomes of the same speciesFor many species, there have already been multiple genomes of their various strains assembled. Previous studies () indicate that it is helpful to align reads against the multiple genomes of the same species to perform precise re-sequencing analysis, especially when the strains are divergent. Moreover, this task is also a fundamental step to read alignment against a library of the genomes of various species (e.g. the RefSeq database), as such libraries usually record more than one genomes for the various strains of the same species. We assessed the ability of the aligners on such tasks with a series of simulated datasets from Escherichia coli strains at first. We downloaded the genomes of all the 62 E. coli strains available from NCBI RefSeq database () (http://www.ncbi.nlm. nih.gov/refseq/). Five reference genome libraries, consisting of 1, 10, 20, 40 and 62 strains, respectively, were built (Supplementary). For each library, Mason Simulator () was used to simulate 1 million 100 bp Illumina-like paired-end reads from all the involved genomes (insert size: 500 6 25 bp). Each of the reads could originate from any strain in the library, and was aligned to the corresponding composite reference. The sensitivity, accuracy and speed of the alignment were investigated. The sensitivity is assessed by the proportion of aligned reads; the accuracy is assessed with two metrics, i.e. the proportions of the reads correctly aligned by all the alignments and by the primary alignments; and the speed is assessed using the read alignment time, i.e. the wall clock time of the execution of the aligner deducting the time of loading index, as the cost of loading index is constant (Supplementary Notes). The results (and Supplementary) demonstrate that: i. deBGA is efficient, especially when the reference is more repetitive. To investigate the repetitiveness of the references, we assessed the number of distinct k-mers and the copies per k-mer (termed as C k ) of the references (Supplementary). It is observed that the C k values obviously increase with more strains involved, indicating that the references with more strains are more repetitive and more difficult to cope with, since a seed would on average have more hits to handle. We also found that the references with ! 10 E. coli strains have even higher C k values than that of human reference genome (GRCh37/hg19), which is commonly considered as highly repetitive. The results suggest that deBGA has a substantial improvement on alignment speed. This is especially noticeable for datasets with more strains, e.g. on the dataset with 62 strains, it is 2.8113 times faster than other aligners. This advantage stems from that similar seeds and identical extensions are largely merge-and-reduced with the graph-based seed-and-extension strategy. ii. Overall, deBGA correctly aligns more reads (98.7799.95%) than other aligners. For all the aligners, the accuracies of primary alignments dropped with increasing numbers of strains. This is not surprising, as the more strains are involved, the more homologous sequences there are, and the more reads that cannot be confidently aligned. In this situation, aligners that output multiple equally best alignments, like deBGA and BWA (configured to output up to 1000 results per read), will be less affected and perform better (especially on the 62 strains dataset). Bowtie2, SeqAlto, BWA-MEM and STAR correctly align fewer reads, although this is likely due to their inherent design. That is, when reads can be aligned to multiple equally good positions, candidate positions are randomly selected based on the various heuristics adopted by the aligners as a result. In this situation, a proportion of reads could be aligned to wrong strains due to homologous sequences, or wrong positions in the same strain due to the repeats of the same genome.Two simulated datasets from Arabidopsis thaliana strains were employed to further benchmark the aligners on the multiple genomes of a eukaryote organism. One is from the reference genome of A. thaliana (TAIR10), and the other one is from TAIR10 plus other 18 A. thaliana strains assembled by 1001 Genomes Project () (the genomes were downloaded from: http://mus.well. ox.ac.uk/19genomes). Similar results are obtained (and Supplementary), i.e. deBGA is at least three times faster on both of the one and the 19 genome(s) datasets; meanwhile, it correctly aligned highest number of reads. We also implemented GenomeMapper (), a read alignment tool specifically designed for multiple genomes, on the simulated datasets from the 62 E. coli strains and 19 A. thaliana strains. However, we found that although its accuracy is comparable (marginally lower) to state-of-the-art aligners, the tool has a much slower speed (line 161 of Supplementaryand line 65 of Supplementary). GenomeMapper costs about 160-folds more alignment time than deBGA to process only a half of the E. coli dataset, and nearly 600-folds more time to process onetenth of the A. thaliana dataset. This speed could not be well-suited to handle large amount of HTS data. To further investigate the effect of repetitiveness on the performance, we benchmarked the aligners with two additional simulated datasets which, respectively, are from two divergent E. coli strains [K-12 MG1655 substrain (NC_000913) and O157:H7 strain (NC_002695)] and two highly similar strains [K-12 MG1655 substrain (NC_000913) and K-12 W3110 substrain (NC_007779)]. It is observed that (Supplementaryand Supplementary) although aligners outputting multiple best positions (e.g. deBGA) can still achieve high overall accuracies on both of the two datasets, all the aligners achieved low accuracies of primary alignments on the dataset from the two similar strains. This is mainly due to that the two similar strains already shared many homologous sequences, so that many reads are hard to be confidently aligned to only one best position. Such results suggest that the accuracy of read alignment against multiple genomes greatly depends on the similarity of the genomes. If the genomes share many common sequences, it would be hard to confidently align the reads; otherwise, the reads are easier to accurately align with confidence. We used three real datasets from E. coli strains to evaluate the performance of deBGA at aligning real reads. Two of them are from E. coli K-12 MG1655 substrain (SRA accession: ERR008613 and SRR522163), and one is from E. coli O157:H7 strain (SRA accession: SRR530851). For each of the three datasets, 1 million paireddeBGAend reads were randomly extracted and aligned to the reference consisting of all the 62 E. coli strains. Two sensitivity metrics were assessed, i.e. one is the proportion of aligned reads, and the other is the proportion of reads aligned to the correct strain. The latter metric is more critical to the read alignment against multiple genomes, and also reflects the accuracies of the aligners. The speeds of the aligners were also assessed by the alignment time. The results suggest that, with its default setting, deBGA is overall at least three times faster than BWA and GEM, and many times faster than other aligners (and Supplementary). Further, a portion of real reads had many low-quality bases, especially the longer Illumina MiSeq datasets (i.e. SRR522163 and SRR530851). deBGA addresses these reads more efficiently using an early-stop heuristic (cl parameter, optimum setting: 0.35, refer to Section 2). With the heuristic, it is about 4114 times faster than other aligners. deBGA also aligned more reads to the correct strain (98.55%, 88.38% and 96.39% for the three datasets, respectively) than other aligners, suggesting that it is sensitive. Meanwhile, for all the datasets, the numbers of reads aligned to the correct strains (i.e. NC_000913 for ERR008613 and SRR522163, and NC_002695 for SRR530851) by deBGA are much higher than other distant strains (Supplementaryand Supplementary). This signal may be useful for a wide variety of applications, such as pathogen identification. Meanwhile, other close homologues such as NC_ 007779, NC_010473, NC_012759, NC_017625 and NC_017638 for the K-12 MG1655 substrain, and NC_017906, NC_011353, NC_002655 and NC_013008 for the O157:H7 strain, have similar numbers of reads aligned. This is also reasonable as these genomes share many homologous sequences, thus many reads could also have equally best alignments on these genomes.
Read alignment against multiple genomes of various speciesThere are also many applications requiring aligning reads against the genomes of multiple species. For example, in many metagenomics studies, it needs to align reads to a large set of known genomes; it is also essential to align reads from mouse xenograft models to both of the human and the mouse genomes. Such tasks are still non-trivial to state-of-the-art approaches. We used simulated and real datasets to benchmark deBGA on such tasks, the aligners shown good performance in the previous tasks, i.e. BWAMEM, BWA, GEM and STAR, are compared. We used Mason to simulate two datasets for evaluating the ability of the aligners to handle metagenomics reads and xenograft model reads, respectively. One is from all the RefSeq bacteria genomes, and the other one is from the human (GRCh37/hg19) and mouse (MM10) reference genomes. Each has 1 million 100 bp Illumina-like paired-end reads (insert size: 500 6 25 bp). Three issues are observed from the results (and Supplementary Tables S8 and S9), which are quite similar to that of the previous tasks. Firstly, deBGA is at least 4-folds faster on the metagenomics dataset, and obviously faster on the xenograft dataset as well. Considering the C k values of the references (higher than that of human reference genome, Supplementary), the speed suggests the superior ability of deBGA to handle repeats. Secondly, the sensitivities of the aligners are quite high only except for STAR on the metagenomics dataset, that about 10% of the reads are unaligned. Thirdly, deBGA and GEM achieved equally high overall accuracies, outperforming other competitors. This is also likely due to the different designs of the aligners for repetitive reads. As there is lack of ground truth for real metagenomics datasets, we built a 'pseudo' real metagenomics dataset by six real sequencing datasets from various bacteria genomes, to assess the ability of the aligners on real data. Each dataset is independently sequenced from a specific bacteria strain recorded in RefSeq (line 15 of Supplement). A total of 250K paired-end reads were randomly extracted from each of the datasets, i.e. the whole datasets consist of 1.5 million reads. For this dataset, we assessed the speed and the sensitivity. The results (Supplementary) suggest that,similar to that of the real E. coli reads, deBGA correctly aligned highest number of the 'pseudo' metagenomics reads with fastest speed, indicating that the method is potentially very effective to handle the reads from metagenomics samples. It is also worthnoting that the speed of STAR is comparable; however, it unaligned nearly 50% of the reads and the number of the reads aligned to the correct genomes is even lower, indicating that it may be less sensitive to process metagenomics datasets. This is likely due to the heuristics adopted by STAR which may discard many repetitive reads.
Read alignment against a single genome3.2.1 Read alignment against human reference genome Five simulated and three datasets from human genome (Supplementary) were aligned to human reference genome (GRCh37/hg19). The five simulated datasets are in various read lengths (100, 125, 150, 200 and 250 bp), which are simulated by Mason based on GRCh37/hg19, to mimic the datasets from extant Illumina platforms. Each has 1 million paired-end reads (insert size: 500 6 25 bp). Two of the three real human datasets are from the CEU HapMap individual sample NA12878 which are, respectively, sequenced by Illumina HiSeq 2000 (SRA accession number: ERR174324) and HiSeq X Ten platforms (downloaded from Illumina BaseSpace website); and one is from the Yanhuang (YH) sample () sequenced by Illumina HiSeq 2000 platform (SRA accession number: ERR161544). For each of the three datasets, one million paired-end reads were randomly extracted for benchmarking, and only the sensitivities were assessed by the proportions of aligned reads, due to the absence of a ground truth. Three conclusions (, Supplementaryand Supplementary Tables S11S14) can be drawn.(i) deBGA is overall faster than STAR, especially with the fast cl  0.35 setting, but they are comparable. Compared with other aligners, the superiority of deBGA is more obvious. For example, it is on average as twice as fast as GEM with the default setting m  4% (the third fastest tool), even though GEM is less sensitive with this setting. When GEM is configured to be as sensitive as deBGA (e.g. m  8%), it is 713 times slower than deBGA. (ii) deBGA aligns simulated reads with high accuracy. Only considering the primary alignments, the accuracy of deBGA is comparable to (i.e. only several tenths of percent lower) that of BWA-MEM, which is the most accurate. Further, of those reads not correctly aligned by the primary alignments of deBGA, about 8090% (on various datasets) were correctly aligned by alternative alignments with the same or even larger edit distances (Supplementary), indicating that it is hard to make the correct choice for these reads. When considering all the alignments, deBGA aligned almost all (99.6799.90%) of the reads to their correct positions, more than all other aligners on all but one dataset. On the 100 bp dataset, GEM with m  6% and 8% configurationsNote: 'Raw' and 'VQSR pass', respectively, indicate the variants initially output by GATK HaplotypeCaller and filtered by VQSR. 'GIAB#' and 'GIAB%', respectively, indicate the number and the ratio of the GIAB ground truth variants which are recovered by the called variants. 'DbSNP#' indicates the number of the called variants which can be matched by dbSNP ver. 146.and S14 (the corresponding lines are highlighted). Also refer to Supplementaryfor a 'zoomed-in' view of the results which more clearly presents the difference between the aligners deBGA
Additional resultsOther features of deBGA, including the time of index construction, the memory footprint and the performance of multiple threads, were also investigated. Refer to Supplementary Notes for these additional results.
DiscussionResults on various datasets demonstrated that deBGA can align reads to one or more genomes quickly and sensitively, making it particularly well-suited to handle the rapidly growing volumes of genomics and metagenomics data. This advantage originates from its de Bruijn graph-based organization of references and specifically designed seed-and-extension process, which enables to well handle the repeats. deBGA is suited to be integrated into many re-sequencing pipelines. Moreover, this method could be further extended to solve other important problems, which are also future works for us. One of the potential works is to extend the approach to better align reads spanning the breakpoints of large or non-co-linear events, such as the DNA-seq reads spanning SVs, or RNA-seq reads which usually have splicing events. The alignment of such reads is difficult, and critical to many downstream analyses. Graph-based approach may have its own advantage to this task, as the non-colinear events could be better modeled under the de Bruijn graph framework, comparing to the linear representation of the reference. However, the alignment method still needs to be well-designed to fully take the advantages of the graph representation. Another potential extension is to use the deBGA method to align reads against other data structures which can also be split into k-mers, such as MSA-based graphs. This will make deBGA an important step toward rapidly aligning reads to variation-aware references representing a population of genomes, such as the 1000 Genomes Project or the UK100K (http://www.genomicsengland.co.uk/) datasets.
B.Liu et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
read    , where O 1 read and O 2 read are the read offsets, and O 1 hit and O 2 hit are the unitig offsets of the two seeds, respectively. This distance is regardless of the G i U values, i.e. on all the copies, the distance between the corresponding PRPs is exactly the same. Thus, it is easy to directly assess the difference between the two PRP sets by D 12 PRP , without separately investigating the specific PRPs. Furthermore, if this value is smaller than the maximal allowed length of indels (usually a few tens of base pairs), the two seeds can be considered as having similar effects to the seedand-extension process and they can be safely merged without loss of important PRPs. In practice, it is easy to check whether two seeds connect to the same unipath through UT k-mer. If so, the D 12 PRP value can be calculated to investigate the similarity of the seeds. deBGA takes advantage of this property to generate and merge seeds without separately investigating their hits. 2.2.2 Recognizing identical local reference sequences through unipath embedding For a given seed, it is easy to directly investigate the distance between its unipath offset and the two ends of the unipath to determine whether the unitig can accommodate the local sequences to be aligned with (i.e. embedded in the unipath). If so, all the extensions for the seed involve aligning the read to the various copies of the unitig. In such cases, the extensions can be reduced to a specific alignment between the read and the unitig itself, regardless of the number of the hits (Supplementary Fig. S3). In practice, given a seed, deBGA retrieves UT k-mer and UT seq to determine whether it implies a set of identical local sequences. If it does, deBGA aligns the read against the retrieved unitig to simultaneously accomplish the extensions. 2.3 Workflow of read alignment A flowchart of read alignment is in Supplementary Figure S4. deBGA aligns a read in several iterations. In each iteration, deBGA generates a set of seeds (i.e. 're-seeding') to adapt to the divergence of the read. The main idea of this iterative process is to use fewer seeds to more efficiently align less divergent reads and to use more seeds in later iterations to sensitively align more divergent reads. Three user-defined parameters, R S (the number of iterations of reseeding,-s option in the software), I S (the minimal interval of seeding,-i option in the software) and M hit (the maximum allowed number of hits per seed,-n option in the software) decide the number of iterations and the generation of seeds in each iteration. More precisely, in the rth iteration (r  1,. . ., R S ), deBGA tries to generate seeds every (R S  r  1)I S bp on the read. The alignment is implemented in the graph-based seed-and-extension strategy which mainly consists of four steps: (i) using k-mers to find the maximal exact matches between the read and the unipaths of RdBG as seeds, (ii) merging seeds within the same unipath to reduce seeds implying similar PRP sets, (iii) splitting and regrouping the remaining seeds to further merge hits at similar genomic positions and (iv) for each of the regrouped seeds, if all the local sequences around its PRPs are within the same unipath, directly aligning the read against the unipath to simultaneously accomplish the corresponding extensions, otherwise, clustering the local sequences from unipaths onthe-fly, and separately aligning the read against the clustered local deBGA
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Project Phase1 data produced by the lobSTR pipeline itself (available at: http://melissagymrek.com/lobstr-code/download.html). It is observed that deBGA and BWA-MEM also have similar numbers of called STRs which can be matched to the 1000 Genomes Phase1 callset. Considering the numbers of called and matched STRs, the two callsets are also likely to have similar quality, like that of SNPs and indels. Delly (Rausch et al., 2012) was employed to call two types of non-co-linear SVs, i.e. duplications and inversions. The results (Supplementary Table S16) showed that similar numbers of inversions were called with deBGA and BWA-MEM; and the number of duplications called with deBGA is higher than that of BWA-MEM, but they are still on the same magnitude. We manually checked a set of duplications in the callset of deBGA but not in that of BWAMEM, and found that this issue is mainly caused by that deBGA aligned some of the reads as disconcordant pairs; however, BWAMEM aligned them as normal pairs but with relatively larger edit distances (an example is in Supplementary Fig. S10). This may be due to the different design of the two aligners. Further, we compared the calls of the two aligners with the SV callsets of NA12878 provided by 1000 Genomes Project Release3 (Sudmant et al., 2015), and found that, with deBGA and BWA-MEM, similar numbers of variants in the 1000 Genomes Project callset are recovered. This result indicates that the alignments of deBGA and BWA-MEM may make the downstream SV caller have similar sensitivities. Moreover, similar numbers of called SVs are matched as well (the reciprocal 50% criterion is used for determining the numbers of recovered and matched SVs). Considering these similar numbers, the quality of the callsets of deBGA and BWA-MEM is still comparable to each other. Moreover, there are still a large proportion of the variants called by deBGA and BWA-MEM cannot be matched by the 1000 Genomes Project callset, indicating that, for both of the two aligners, there are some SV-spanning reads still not well-handled. More advanced approach could be still needed to improve the quality of the alignment of SV-spanning reads.
