Motivation: Nucleic acid diagnostics has high demands for non-heuristic exact and approximate oligonucleotide string matching concerning in silico primer/probe design in huge nucleic acid sequence collections. Unfortunately, public sequence repositories grow much faster than computer hardware performance and main memory capacity do. This growth imposes severe problems on existing oligonucleotide primer/probe design applications necessitating new approaches based on space-efficient indexing structures. Results: We developed PTPan (spoken Peter Pan,'PT' is for Position Tree, the earlier name of suffix trees), a space-efficient indexing structure for approximate oligonucleotide string matching in nucleic acid sequence data. Based on suffix trees, it combines partitioning, truncation and a new suffix tree stream compression to deal with large amounts of aligned and unaligned data. PTPan operates efficiently in main memory and on secondary storage, balancing between memory consumption and runtime during construction and application. Based on PTPan, applications supporting similarity search and primer/probe design have been implemented, namely FindFamily, ProbeMatch and ProbeDesign. All three use a weighted Levenshtein distance metric for approximative queries to find and rate matches with indels as well as substitutions. We integrated PTPan in the worldwide used software package ARB to demonstrate usability and performance. Comparing PTPan and the original ARB index for the very large ssu-rRNA database SILVA, we recognized a shorter construction time, extended functionality and dramatically reduced memory requirements at the price of expanded, but very reasonable query times. PTPan enables indexing of huge nucleic acid sequence collections at reasonable application response times. Not being limited by main memory, PTPan constitutes a major advancement regarding rapid oligonucleotide string matching in primer/probe design now and in the future facing the enormous growth of molecular sequence data. Availability: Supplementary Material, PTPan stand-alone library and ARB-PTPan binary on http://ptpan.lrr.in.tum.de/.
INTRODUCTIONFast methods for non-heuristic exact and approximate oligonucleotide string matching are of central importance for in silico primer/probe design and evaluation. Many applications in the field of nucleic acid diagnostics are based on the usage of indexing structures to speed up computations (). A prominent example is the PT-Server, the central search index of the software package ARB, which is used worldwide for phylogenetic microbial sequence analyses of molecular markers such as ribosomal RNA (). Based on suffix trees, the PT-Server is suitable for highly efficient approximate oligonucleotide string matching supporting the design and in silico evaluation of phylogenetic primers and probes widely applied in microbiology (). Furthermore, it is the basic component of the probeCheck server and the recently published comprehensive signature search tool CaSSiS (). The PT-Server has to fit into main memory during construction and application. This imposes limitations on the rapidly growing databases. Current collections of small subunit ribosomal RNA (ssu-rRNA) such as Greengenes () or SILVA () are already becoming unsuitable for common desktop computers. The growth of SILVA (See statistics at http://www.arb-silva.de/documentation/background/ release-104/) reveals the fatality of the memory dependence in near future. In addition, the PT-Server relies on Hamming distance metric for approximate string matching concerning primer/probe design and evaluation. The resulting inability to identify insertions or deletions (indels) prohibits the detection of possible sequencing errors or mutations which can lead to a misjudgment of the sensitivity of primers or probes with severe implications to experimental results (). Finally, the PT-Server can only be constructed from an ARB database limiting its field of application strictly to the ARB environment. Consequently, a new memory efficient and sustainable approach is required, coping with the increasing sequence data flood. Extended Levenshtein (edit) distance metric search includes significant matches with indels and thus improves the future in silico prediction of sensitivity and specificity of an oligo primer/probe sequence. For the same reason, the new approach should support indexing of ambiguous sequence characters and treating matches at ambiguous positions in an efficient way. It seems reasonable to treat all ambiguities as wildcard in string matching ('N'-character).Page: 2798 27972805
T.Eiler et al.Furthermore, features for advanced primer/probe design should be supported as well. These comprise the handling of alignment data. Beyond the precise comparative positioning of matches, it provides the opportunity to include higher order structure and function information, such as probe accessibility, in the in silico design process (). Furthermore, a weight scheme for approximate matches is important for primer/probe design. Weighting approximate matches with respect to type and position of mismatches can help to scale the distance between exact and inexact matches as well as to better rate the specificity and sensitivity of a probe (). Many state-of-the-art indexing techniques, mainly originating from indexing structure theory, have been examined for their general viability to function as core structure for our approach taking into account aforementioned requirements. The k-truncated suffix tree (kTST ) () reduces the amount of required memory by limiting the depth of suffix trees like the PT-Server described above does, suffering from the same memory constraints. A data structure well known for being able to replace suffix trees is the enhanced suffix array (eSA). In practice, it has a dramatically reduced memory requirement of 6n bytes per input character (). Unfortunately, it still needs to fit into memory entirely during application. Taking the rRNA-sequence database SILVA (; release 104, SSURef_104_SILVA_08_10_10_opt.arb), with its 738 million nucleotide bases, this would result in a memory requirement of already >4 GB for the final index. Sophisticated approaches to further reduce main memory requirements are the so-called selfindexes, such as the compressed suffix trees (CST ) (most recently). These use memory space in the order of input text size, already including the original text. Russo and colleagues, however, report a severe slowdown of factor 6.2 to 33 compared with 'classical indexes' conducting Levenshtein distance-based approximate string matching for error limits 13 on self-indexes, even for their fastest algorithm (). Some approaches shift the memory requirements from main memory to secondary storage to build an index. The disk resident suffix arrays (rSA) with reduced space requirements offer a compact representation of suffix arrays on secondary storage (). Moderate disk space requirements are reported for rSA coding DNA4. Exact pattern matching is functional but being more favorable for long query strings in terms of response time (). However, no report on approximate string matching using rSA is published to date. Suffix trees in external memory (eST ), recently reviewed by Barsky and colleagues (), are well studied. eST s can be constructed efficiently even with limited main memory, although requirements for secondary storage are high. Approximate string matching, however, is reported to be an open challenge for existing eST approaches. Searching for problems related to approximate oligonucleotide string matching, mapping short reads produced by next-generation sequencing technologies to reference sequences attracts attention. A representative mapping tool known to be among the fastest ones is BWA (). It looks promising for oligo string matching in the field of primer/probe design as well. This is due to its fast query times, low main memory demands, its non-heuristic search capabilities and the ability to identify indels. BWA is currently incapable of indexing ambiguous characters or dealing with alignment information. However, an examination of its performance seems to be reasonable in order to decide on the viability for adding the missing features in a reimplementation. In summary, with approximate oligonucleotide string matching as main purpose in mind, eST seems the most appealing approach while it still has remaining challenges, namely the memory consumption on secondary storage and the inability to perform approximate string matching reasonably. The first issue can be partly addressed by combining eST with truncation employed in kTST and the PT-Server. Nevertheless, approximate string matching still needs to be addressed. An initial approach addressing both challenges at once, conducted in our group, looked promising, but was limited to small databases (). To keep up with the growth of available nucleic acid sequence data and to provide further search functionality enhancing the capabilities of existing oligonucleotide string matching approaches such as the ARB PT-Server, we developed PTPan, a space efficient search index capable of dealing with large amounts of nucleic acid (RNA/DNA) data. Based on suffix trees on secondary storage, it combines partitioning, truncation and a new suffix tree stream compression to construct a space-efficient index. It may outgrow available main memory while enabling efficient approximate oligonucleotide string matching, solving the issues of suffix trees on secondary storage for our field of application. We implemented the applications ProbeMatch and ProbeDesign as well as FindFamily based on PTPan, utilizing the Levenshtein distance metric for approximate oligonucleotide string matching. This allows to identify indels besides substituted base positions. All ambiguous base positions in the sequence are treated as wildcard ('N'). Results are formatted user-friendly for easy evaluation. PTPan is implemented in C/C++. It is available as stand-alone library and incorporated into the ARB software environment where it can be used as a replacement for the PT-Server. It runs on 64-bit (Ubuntu) Linux systems which are common nowadays.
METHODS
Suffix tree basicsThe suffix tree is a well-known index structure. For a non-empty string S over the alphabet , a suffix tree is a tree with labeled edges. The labels contain one or more characters. The paths of the tree, i.e. the concatenation of edge labels from the root to a leaf, correspond to the suffixes of S. Their start positions are stored at the leaves. Therefore, a suffix tree allows for fast searching of substrings contained in S taking time linear to the length of the search string plus the number of occurrences in S to return all appearances. A recent review byincludes a more detailed description of suffix trees and common construction algorithms.
Sequence alphabets and compact representationNucleic acid sequences are concatenations of symbols out of the DNA4 alphabet consisting of the four symbols 'A', 'C', 'G' and 'T' (or 'U' in RNA, respectively). Many nucleic acid sequences in public repositories contain ambiguous bases which are all represented by 'N' within PTPan. The corresponding alphabet, DNA5, is used in this study. For a compact representation, the codes of the DNA5 alphabet are first mapped into the following integer interpretation: val('N') = 0, val('A') = 1, val('C') = 2, val('G') = 3, val('T') = val('U') = 4. A series of bases can now be stored as the sum of their sequence codes to the base of five:
Branch maskTo avoid the storing of empty downward pointers in a tree, a branch mask is used. This branch mask of alphabet size || has the bit i set for each element i of the alphabet. For DNA5, this results in a mask of five bits. Hence, the first base character of every downward edge is already defined implicitly and does not need to be stored in the edge label.
EncodingsPrefix codes are applied to provide variable length payload information after the corresponding prefix. Prefixes must conform to the requirement demanding no prefix being prefix of another one. Huffman encoding is used to represent the sequence data losslessly according to its entropy (). This technique is used e.g. to store more frequently occurring branch masks in the compressed stream with a shorter representation than less frequent ones reducing the number of bits required on average.
RESULTSPTPan combines several techniques to construct a persistent and space-efficient suffix tree. The core structure is a partitioned, truncated and stream-compressed suffix tree. Utilizing the suffix tree, approximate string matching algorithms as well as primer/probe design functionality have been implemented. The three main steps of the PTPan construction algorithm are as follows:(1) Data retrieval and preparation (Section 3.1).(2) Partition determination and index header storage (Section 3.2).
Data retrieval and preparationPTPan incorporates distinct sequences into one index. The sequences are retrieved by a defined interface currently available for the ARB database and for multiFASTA-files. A compact representation of the data is stored in the index header utilizing the compression method described in Section 2.2. Optionally available alignment information is included as well, i.e. gap characters and a reference entry. For the construction algorithm, all sequence data are merged into a temporary compressed raw data file stripping all non-DNA5 characters. For referencing the position inside the merged raw sequence data to its origin, the start position is stored for each sequence entry. The raw data is padded with 'N'-characters at the end to ease the construction process (Section 3.3.1).
Partition determination and index header storageFirst, the maximum number of base positions fitting into available main memory is calculated. If the merged raw sequence (Section 3.1) has more bases than this threshold value, partitioning is required. If so, the merged raw sequence (Section 3.1) is scanned once for the frequency of each prefix of a fixed, data-dependent precalculated length. This histogram information is then used to determine partitions small enough to fit into main memory during construction. Prefixes start with length one, i.e. one for each symbol of the alphabet. These initial prefixes are extended by one character for each symbol of the alphabet if the number of occurrences exceeds the threshold value. For all newly created prefixes, the determination process is repeated until all defined partitions fit into main memory. Prefixes not occurring in the sequence data are omitted. Finally, all remaining basic index information is stored into the index header including the number of partitions and their prefixes.
Constructing compressed suffix tree for each partitionFor each calculated partition, a truncated suffix tree is constructed in main memory. Thereby, two kinds of suffix nodes are distinguished (Section 2.1). Inner nodes have up to five children, but no leaves. A branch mask (Section 2.3) keeps track of the downward children present. Border nodes have no children, but at least one leaf. Both node types carry ingoing edge information, i.e. label and length, except the root node. The label is stored as 64-bit integer value during construction instead of a reference to the original source text. This allows an edge-label length of up to 27 characters (Section 2.2). The default pruning depth of the suffix tree is set to a path length of 20. This value can be altered, though the current implementation is limited to a maximum length of 27 for a path.
Insert prefix occurrenceFor each partition, defined by its prefix, the input sequence is scanned once. A sliding window is used to avoid repeated accesses to the raw sequence data. It keeps a copy of enough parts of the compressed raw sequence data to obtain the sequence string starting with the current position and the following characters up to the pruning length. If an occurrence of the current prefix is reached, the existing suffix tree is traversed comparing the edge labels with the sequence starting at the position. If a border node is reached, the path is already present and the current occurrence is added as new leaf. If a mismatch appeared inside an inner node, a new border node including one leaf is added with the remaining characters of the window as edge label. The last case is a mismatch inside an edge label. It requires splitting of the edge label, insertion of a new inner node labeled with the matching part, update of the downstream node and insertion of a new border node for the remaining characters of the current window. To avoid the repeated traversal of the first few levels of the suffix tree, a hash-map is used for the suffixprefixes up to a certain length available as integer values in the compact representation (Section 2.2). The hash entry for a prefix points to the appropriate inner node which is reached by traversing from the root down the path denoted by the characters of the prefix. If a prefix of a new suffix to insert is already present, several edge comparisons can be omitted. The insertion process can start to add the rest of the suffix after the prefix at the appropriate inner node. This speeds up the construction algorithm significantly.
Prepare edges and branch masksFor the final streamcompressed suffix tree, two kind of edges are distinguished. Short edges are all edges with less or equal length of six characters.
T.Eiler et al.Instead of storing an offset to a dictionary string and the length of the edge, a statistically based Huffman encoding of the edge is stored directly into the compressed stream as it is more space efficient. This takes into account that occurrences of short edges are not equally distributed. Scarce short edges are not encoded, keeping the Huffman tree representation compact. Long edges are all edges that do not get a short edge representation, either because they are too long to store directly or they do not appear frequently enough. Long edges are stored as a combination of an offset inside a dictionary string and the length of the edge. A long edge dictionary string is stored along with the suffix tree of the corresponding partition. Before writing the tree to disk, long and short edges as well as the branch masks are prepared. The in-memory suffix tree is traversed counting the short edges and the occurrences of the different branch mask combinations. This enables the calculation of the Huffman encoding (Section 2.4) for the short edges, providing a single one for long edges as well, and for the branch masks. Afterwards, during a second traversal, the long edges are counted and the short edges are replaced by their Huffman representation.
Building the long edge dictionaryPTPan utilizes a greedy algorithm for building the long edge dictionary. Initially, the edge labels are sorted lexicographically enabling the locating of edges that are equal or prefixes to other ones. These prefix edges are clustered together by equating the offsets. Afterwards, the edges are sorted by starting offset. This allows the detection of overlapping fragments. These fragments are chained to longer concatenated edge labels for the dictionary, covering the smaller edge fragments. After building the concatenated edges, these are sorted by length. An initial subset of them is added to the dictionary and a temporary truncated suffix tree is constructed allowing fast determination if an edge is already present in the dictionary. Afterwards, the remainder of the concatenated edges are looked up and added to the long edge dictionary if not already present. The temporary suffix tree is updated every time a new edge has been added. Subsequently, the long edges are sorted by their length ensuring that as many edges as possible are a substring of prior inserted ones. Long edges which are part of a concatenated edge are skipped in this step as they are already present in the long edge dictionary. For the remaining ones, the temporary suffix tree is queried for an occurrence. If none is found, the edge is appended to the dictionary. Finally, the long edge dictionary is compressed (Section 2.2) and a long edge length Huffman encoding is built, which is required for storing.
Relocating the treeIn the final suffix tree representation, the downward child pointers are stored as offsets relative to the position right after the current node. Thus, the size of all child nodes must be available prior to storing a node. Therefore, the tree is traversed in depth-first-search (DFS) order as final preparation step prior to writing the suffix tree. During this traversal, the size of each node is calculated and stored instead of the downward child pointer of the parent node. The tree DFS order is kept in an array of pointers to the suffix nodes for writing the tree to disk.
Writing the stream-compressed suffix treeThe suffix tree is written to disk as a stream of bits. During the compression step, the suffix nodes used during construction are transformed into compressed nodes. A compressed node consists of three parts: the edge label, the branch mask and the child references, for inner nodes respectively, a compressed leaf array for border nodes. For nodes with a short ingoing edge, its corresponding Huffman encoding is written into the stream. Otherwise the stream starts with the special Huffman code for long edges followed by the Huffman encoded edge length and the long edge dictionary offset. Afterwards, for inner nodes, the branch mask Huffman code is issued then followed by up to five encoded child reference offsets in DFS order corresponding to the branch mask bits. As the references are written in ascending order, each can be stored relative to the last one reducing space requirements. In case of a border node, a leaf array follows instead of the child references indicated by a special code for the branch mask. To store the leaf array in a more efficient way, the sequence offsets are sorted in ascending order. Afterwards, the resulting array is delta encoded (Section 2.4) to obtain smaller values for storing. A detailed example of the compression can be found in the Supplementary.
PTPan applications
Basic tree traversalFor each partition, the root node is decompressed as it starts at position 0. All child node offsets are revealed during this and the tree can therefore be traversed recursively topdown to the nodes carrying the leaf arrays. The decompression of the stream is the inverse operation to the encoding described in Section 3.3.5. Because of the branch mask, the first character of a downward edge can be determined prior to decompressing the next node, one level deeper into the tree.
ProbeMatchis a string matching algorithm leveraging basic tree traversal described in Section 3.4.1. It is capable of carrying out exact as well as approximate string matching using the Levenshtein distance metric. This enables the locating of insertions and deletions (indels) besides substitutions. Approximate string matching can be executed in basic-or weighted-match mode. In basic-match mode, each substitution or indel increase mismatch counter by one. In weighted-match mode, the type of a substitution and its position impacts the size of a weighted mismatch score. In this mode, a fixed score value is assigned to indels currently. In addition, 'N's occurring in the original sequence are treated as wildcard and named 'N'-mismatches which are counted separately. String matching is carried out by searching the partitions one after another and merging the results into one list. Hits crossing entry borders in the merged raw sequence data are filtered out. Searching for query strings longer than the pruning depth requires a verification step for each hit. The query string is compared with the decompressed original sequence data of each hit candidate. Subsequently, a result list representation with individual information on every match is created. It provides identifier and name of the sequence entry containing the match, a differential alignment representing equal positions, substituted bases, the position of a deletion ('_') or insertion (' * ') and match context at nine positions at 3 and 5 ends. The match position is returned as well, taking into account alignment information if available. Additionally, values indicating the distance to the search string are determined for each match. The first value 'mis' indicates the distance between search string and match by the total number of substitutions, insertions and deletions. The second value 'wmis'Page: 2801 27972805
PTPanovercoming memory limitations in oligonucleotide string matchingindicates the weighted distance according to the weighted mismatch score mentioned above. Both values are used for sorting the result list. Finally, 'nmis' displays the number of 'N'-mismatches.
ProbeDesign was implemented utilizingthe PTPan index structure and ProbeMatch functionality. It allows to identify unique oligonucleotide probe sequences and their reverse complement, i.e. the target sequences. Goal is the identification of probe sequences with high coverage, i.e. preferably hitting a user selected single sequence or sequence group entirely, while guaranteeing high specificity, i.e. preferably hitting no out-group sequence or only with a high distance. The search can be initially constrained by setting parameters melting temperature, GC content and probe length. An initial set of probe candidates matching these constraints is selected utilizing basic tree traversal (Section 3.4.1). The candidates are afterwards evaluated according to the settings of two additional parameters, i.e. minimum percentage of in-group and maximum number of out-group hits. Probe candidates not matching the latter constraints are omitted at this stage. Remaining candidates are matched with ProbeMatch functionality (Section 3.4.2) with up to four mismatches allowed. From the match lists, the number of outgroup hits with 'wmis'-values ranging from 0 to 4 are counted and displayed at 'wmis'-value intervals of 0.2. Finally, all candidates are evaluated based on the percentage of in-group hits, the number of out-group hits and the parameters mentioned before. Afterwards a sorted list is displayed with the most promising probe candidates on top. The candidate list includes target and probe sequences, hit information and a list of out-group hit numbers for increasing weighted mismatch values.
FindFamilyis a method for fast and comprehensive sequence similarity searches by oligonucleotide string matching frequencies. It can be used for unknown sequences to rapidly find their most similar sequences within large datasets without prior alignment. For a selected sequence entry, FindFamily generates oligonucleotide sequences of user-defined length utilizing a sliding window. Subsequently, depending on the settings, exact and approximate string matching is performed for each oligo, summing up the number of hits individually in a hit score for every sequence entry incorporated in PTPan. Finally, a result list returns the sequence entries sorted by decreasing hit score.
EXPERIMENTAL RESULTS
Experimental setupPTPan was integrated into the ARB software package () to compete with the current PT-Server. We compared time consumption and space requirements of the construction algorithms as well as oligonucleotide string matching times for both. Real life test data were retrieved from the SSURef_104_SILVA database (
Construction timeThe construction performance was measured for 10 replicates of PTPan and the PT-Server for each of the different test databases.plots the average value of the time to construct with standard deviation against the test dataset size in a number of nucleotides. An almost equal construction time was recognized up to dataset with 460 million base characters (equivalent with 300 000 sequence entries). For the two largest datasets tested, PTPan was constructed significantly faster than the PT-Server. This effect can be put down to a strong rise of the PT-Server construction time above 468 million nucleotides, caused by a construction algorithm alteration circumventing more disadvantageous memory effects (R. Westram, personal communication). On the test computer with 4 GB main memory, PTPan was constructed for all test datasets, even the complete SSURef_104_SILVA database in 52 min. The construction time was significantly longer than on the 24 GB-memory machine, because a higher number of smaller partition had to be constructed, due to the limited memory size. The PT-Server, however, was efficiently constructed for smaller sized datasets only. For test datasets with 300 000 sequence entries or more, the PT-Server construction process started to use swap memory and could not finish in reasonable time starting with the 400 000 sequence entry database (Section 3.1 in Supplementary Material).Number of nucleotidesPT-Server PTPan
Space requirementsIn, the space requirements on secondary storage are shown for the PTPan and the PT-Server. For the complete SSURef_104_SILVA database, PTPan requires about 3 GB, whereas the PT-Server requires 2.8 GB. The average memory consumption over all test databases is 5.1 bytes per base for PTPan and 4.9 bytes for the PT-Server. The PT-Server is stored compressed. Before application, it is loaded and decompressed into main memory entirely in addition to the corresponding ARB database which must be present at the same time. For the usage of the complete SSURef_104_SILVA database including PT-Server, 5 GB out of 8 GB total memory use are exclusively for the PT-Server. PTPan, in contrast, does not need to fit entirely into main memory during application due to its partitioned and stream-compressed design. The partition files are mapped into main memory to keep the memory demands low. But even when loaded entirely into main memory, PTPan required significantly less memory compared with the PT-Server. For the complete SSURef_104_SILVA it allocated 3 GB only, about the same memory space requirement as on disk. Sustainability tests conducted with SSUParc_104_SILVA database reveal a doubling of the PTPan index size, thus increasing linear (details in Section 3.1 in Supplementary Material ).
ProbeDesignProbeDesign offers fast search capabilities for unique oligonucleotide probes. It aims at finding probes matching most target sequence entries selected combined with a large distance to nontarget entries, satisfying relaxed search parameters. The probe candidate result list is sorted according to high target group coverage and a large weighted distance to non-target sequence entries pinpointing the most promising candidates at the top positions (). We examined performance of ProbeDesign using PTPan indexed SSURef_104_SILVA for 'best' and 'worst' case queries. Searching for a unique 18mer probe sequence for a single sequence entry (accession number AJ318041) with default settings served as 'best' case query. ProbeDesign offered several probe candidates matching the search constraints and returned them in a sorted list with the probe sequence CGGAGAGCAUAACGCCCU on top (Section 3.3 in Supplementary Material). As a 'worst' test case for probe design, the phylogenetic group containing all 16S rRNA sequences of domain 'bacteria' incorporated in the SSURef_104_SILVA database (almost 440 000 entries) has been chosen. The number of allowed out-group hits was set to 10, the coverage percentage to 75%. For the remaining values, default settings were kept.lists the probe candidates calculated in only about 5 min. The second suggested probe is the already published EUB338 targeting bacteria (). This demonstrates that ProbeDesign is not only capable of fast generating probe candidates, but also of finding highly used probes confirming the correctness of the results.
ProbeMatchString matching capabilities of PTPan and PT-Server were tested with the SSURef_104_SILVA database for proposed 'best' case and 'worst' case scenarios. Here, the single-sequence-specific probe designed in Section 4.4 served as 'best' case for its property to have minimal number of hits in the test database. The 'worst' case example was the probe EUB338, a sequence well known to have a very high number of entry hits in SILVA (). Tests have been conducted in basic-match mode (section 3.4.2) for exact as well as approximate queries up to five allowed mismatches. In, quantitative aspects of ProbeMatch results are shown. The hit numbers are plotted against the numbers of non-weighted mismatches defined as upper limit for a hit. For exact queries, the number of hits are the same. For approximate string matching, PTPan returns a higher number of hits with the divergence increasing for higher number of mismatches allowed. The discrepancy is caused by the PT-Server utilizing the Hamming distance metric while PTPan leverages the Levenshtein distance metric. Comparing PT-Server to PTPan, the latter additionally identifies matches with indels (details in Section 3.2 in Supplementary Material).shows overall string matching times for different numbers of maximum allowed mismatches. This includes the time required to generate the result list. PTPan shows about four times higher string matching times for exact queries. For approximate string matching with error rates from 1 to 4, PTPan is 8.515 times slower compared to the PT-Server extending to about 3233 times for a maximum error rate of five. One reason is the requirement of PTPan decompression during traversal. Furthermore, for higher error rates, the number of paths in the suffix tree containing possible hits increases faster as PTPan must check for indels besides substitutions. Finally, for the larger amount of hits, output creation takes longer along with differential alignment creation being more complex. Hit context information needs to be decompressed and, if mismatches are allowed, positions of indels must be determined. Compared to locating substituted bases, this is more compute intensive.shows an excerpt of a PTPan result list incorporating indel hits. Sustainability tests were conducted on SSUParc_104_SILVA database revealing constant matching times per hit returned compared with SSURef_104_SILVA (Section 3.2 in Supplementary Material). Evaluating BWA revealed faster matching times for exact and approximate string matching with default settings compared with PTPan. Though BWA returns only the single query hit with the lowest distance to the search string. Modifying BWA settings to be comparable with PTPan basic-match mode, i.e. disabling iterativeQuery timesearch in order to return all matches, lowering mismatch and gap penalties as well as allowing more than one gap open, resulted in approximate string matching times of BWA being worse compared with PTPan. Furthermore, the BWA result list does not include information about the weighted mismatch value, mismatch type and position, mismatch context at 3 and 5 ends as well as alignmentrelated position information. Details about BWA test results and settings are reported in Section 1 in Supplementary Material .
Page: 2803 27972805
PTPanovercoming memory limitations in oligonucleotide string matching
FindFamilyTo test FindFamily, different sequence entries have been chosen in the SSURef_104_SILVA database (). For each chosen entry, FindFamily has been carried out and the results were evaluated by comparing the proposed next neighbors to the neighbors in the phylogenetic reference tree which is incorporated into the SILVA database. This process was repeated for > 50 entries. The average runtime was <1 min with default settings. The result listed, in all cases, the next neighbors in the phylogenetic tree as candidates. Thus, the results show that FindFamily delivers a good first estimation of sequence similarity (details in Section 3.4 in Supplementary Material).
DISCUSSIONWe presented PTPan, a persistent and space-efficient suffix index for oligonucleotide string matching which deals with limited main memory. It incorporates enhanced non-heuristic exact and approximate search capabilities to find exact as well as approximate matches containing substitutions and indels, due to a user-defined search string distance. It has been developed and optimized to support similarity searches and primer/probe design in huge nucleic acid sequence collections, highly demanded in molecular microbial diagnostics. PTPan is integrated into the ARB software package () and available as stand-alone library. We have reviewed memory-efficient indexing structures according to their viability for non-heuristic approximate oligonucleotide string matching with respect to our main focus, primer/probe design in large nucleic acid sequence databases (Section 1). In doing so, we have evaluated BWA for suitability Page: 2804 27972805for our approach in practice. BWA is a successful non-heuristic short read mapper based on a space-saving index structure with fast construction times (). Although short read mapping is a problem related to oligonucleotide string matching for primer/probe evaluation, it differs in the actual goal. BWA aims at the best hit for a short read. In contrast, primer/probe design for microbial diagnostics targets at finding all matches with distance smaller or equal to a required value to the query string. Every match is important to detect in silico sensitivity and specificity of a primer/probe as good as possible, in particular to identify potentially cross-reacting non-target sequences (and respective organisms) in the analyzed data collection. BWA performed approximate string matching faster than PTPan for default settings, though missing significant matches. To get thorough enough results for careful primer/probe evaluation, BWA parameter settings had to be adopted resulting in a performance worse than PTPan. Furthermore, essential information for advanced evaluation of primer/probe candidates is not provided (see Section 4.4). Extending BWA by required functions would lead to a further incalculable slowdown, as we concluded. We focused our further efforts on suffix trees on secondary storage. The remaining challenges of high space requirements and inability to efficiently carry out approximate string matching were targeted. We employ partitioning and truncation combined with a new suffix-tree stream compression to reduce space requirements and optimizing the index structure for topdown traversal required by approximate oligonucleotide string matching. Though the achieved memory efficiency has an implication for the current implementation of ProbeDesign, the length of probes is limited to the depth of the suffix tree, 27 at maximum. Nevertheless, this is sufficient for many applications such as PCR or fluorescence in situ hybridization (FISH) (). Designing longer probes is possible using a sideway if no other options exist. ProbeMatch results, e.g. of a 27mer probe target candidate, provide context information of each match. With this a target candidate sequence can be elongated according to the matching base characters within the context. Since ProbeMatch is not limited to 27mers, this procedure can be repeated iteratively in order to design longer oligonucleotide probes. Alternatively, concatenation of overlapping 27mer probe target sequence candidates could be applied. An index providing comparable functionality targeting the same field of application, namely primer/probe design based on oligonucleotide approximate string matching, is the widely used PT-Server integrated into the ARB software package (). A detailed comparison between PT-Server and PTPan revealed similarities as well as important differences. As public nucleic acid sequences may contain ambiguous base characters, proper handling is required. Both indexes treat all ambiguities as 'N'-character during build and wild-card during search. The great advantage of this is the identification of matches containing ambiguous characters which helps to optimize in silico primer/probe evaluation. In addition, both indexes support basic-and weighted-match mode (Section 3.4.2). This is extremely advantageous during search and evaluation of diagnostic oligonucleotide primer/probe candidate sequences. In particular, a weighted mismatch allows to measure a fine grain distance between a match and the search sequence string, taking type and position of substitutions into account. This enables rating of in silico specificity and sensitivity of a probe by evaluating its distance to target and non-target sequences. This is important when predicting the ability of an oligonucleotide probe to cross-react with a non-target oligonucleotide sequence stretch despite mismatches (). Both PTPan and the PT-Server return a meaningful result list for each query, facilitating fast evaluation of query hits significantly. The list incorporates hit names, absolute and relative position in the original multiple alignment, number of mismatches, weighted mismatch scores and the sequence contexts in a multiple differential alignment. For list creation, the original sequence data are required to retrieve context information. To avoid memory intensive permanent accesses to the original database during applicationas with the PT-ServerPTPan incorporates all sequence and alignment information making it independent of the sequence data source. Besides the similarities, there are some major advantages of PTPan compared with the PT-Server. For approximate string matching, the PT-Server utilizes the Hamming distance metric for finding exact matches and those with substituted bases. However, it misses matches with indels. This could be a major drawback when trying to assess in silico coverage and specificity of diagnostic oligonucleotide primer/probes. McIlroy and colleagues have recently shown that oligo probes can form stable hybrids with non-target sequences despite indels, leading to false positives in FISH (). Thus, the ability to include indels into the probe design and evaluation process is of great interest. PTPan, utilizing the Levenshtein distance metric, also detects matches with real indels and those resulting from sequencing errors at the target position (Sections 3.4.2 and 4.5). This is a major advancement for in silico primer/probe design. The PT-Server relies entirely on source sequences in the ARB database format for index construction. PTPan currently supports ARB databases and multiFASTA files. Moreover, it provides an interface easy to implement for other sequence data formats. PTPan is available as stand-alone library, too. Hence, it is easily usable for oligo string matching beyond the ARB software environment. Finally, PTPans central advantage over the PT-Server is its significantly lower main memory demand during index construction and application (Section 4.3). The PT-Server has comparable memory requirements on disk as it reduces space consumption by truncation, but significantly higher demands in main memory (Section 4.3). This causes severe problems when trying to apply
T.Eiler et al.
Page: 2805 27972805
PTPanovercoming memory limitations in oligonucleotide string matchingthe PT-Server to approximate oligonucleotide string matching on real-life datasets on a common desktop computer, which is solved by PTPan (Section 4.2). In the case of the thousands of ARB users worldwide, an index for the complete SSURef_104_SILVA database with >512 000 sequence entries and 738 million nucleotides can now be constructed and used for string matching, probe design and sequence similarity searches, even with only 4 GB main memory instead of at least 8 GB required before (Sections 4.2 and 4.3). PTPan clearly relaxes the problem of providing efficient, main memoryindependent string matching capabilities facing the nucleic acid sequence data growing faster than computer hardware performance and main memory capacity. Regarding construction time, PTPan is highly competitive to the PT-Server despite the additional load of partitioning and compression (see Section 4.2). As expected, query times are slower by factor 433 depending on the number of mismatches allowed to define a match (Section 4.5). This is due to overhead induced by decompression and computationally intensive indel searches. In addition, PTPan identifies and returns a significantly higher number of hits for approximate string matching, i.e. indel matches besides matches delivered by the PT-Server. Regarding the consequences of query times slowdown for in silico probe design, it is important that usually the candidate sequences have to be evaluated down to matches with a maximum weighted distance of four (). Thus, oligonucleotide string matching with five non-weighted mismatches, currently showing unacceptable performance, is rarely applied. Furthermore, PTPan query times slowdown seems to be in the same range as the slowdown reported for self-indexes (). Self-indexes operate completely in main memory, whereas PTPan utilizes slower secondary storage. Nevertheless, compared with self-indexes PTPan shows a slowdown of factor 33 not until deeper searches. PTPan provides a sustainable nucleic acid sequence data (DNA/RNA) index. This has been demonstrated by constructing PTPan for SSUParc_104_SILVA database with its 1.45 billion nucleotides on common desktop computers, equipped with various amounts of main memory (Section 4.2). Hence, PTPan construction is not limited by the amount of data at the price of increasing construction time. For long sequences or sequence stretches, such as genomes, the current implementation has only one strong limitation: each individual sequence entry of a given dataset has to entirely fit into main memory during construction.
CONCLUSIONPTPan is a space-efficient, persistent nucleic acid sequence data index. With suffix trees on secondary storage as core structure, it combines partitioning, truncation and a new stream-compression technique. It performs well for approximate oligonucleotide string matching, probe design and similarity search functions, all taking indels into account. Even largest gene sequence databases can be searched efficiently on common desktop computers, now and in the future, due to PTPan's superior sustainability. As future core component of the worldwide used software package ARB, complementing or even replacing the ARB PT-Server, it will offer thousands of users advanced functionality with significantly reduced hardware requirements. Currently, the only PTPan trade-off is the slower, though still, reasonable query time. To overcome this constraint facing the continuous data flood, the efficient usage of multicore architectures by parallelization could be a promising continuative approach.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
