Motivation: Second-generation sequencing (SGS) generates millions of reads that need to be aligned to a reference genome allowing errors. Although current aligners can efficiently map reads allowing a small number of mismatches, they are not well suited for handling a large number of mismatches. The efficiency of aligners can be improved using various heuristics, but the sensitivity and accuracy of the alignments are sacrificed. In this article, we introduce Basic Alignment tool for Mismatches (BatMis)—an efficient method to align short reads to a reference allowing k mismatches. BatMis is a Burrows–Wheeler transformation based aligner that uses a seed and extend approach, and it is an exact method. Results: Benchmark tests show that BatMis performs better than competing aligners in solving the k-mismatch problem. Furthermore, it can compete favorably even when compared with the heuristic modes of the other aligners. BatMis is a useful alternative for applications where fast k-mismatch mappings, unique mappings or multiple mappings of SGS data are required.
INTRODUCTIONSecond-generation sequencing (SGS) technologies generate a high volume of sequencing data economically and this abundance of data has introduced new possibilities to genomic studies. Applications such as whole-genome sequencing (), gene expression profiling () and ChIPseq () have benefited from it. All these applications need to map the SGS reads to a reference genome. Due to the differences between the sampled genome and the reference genomes and the errors introduced during the sequencing process, the mapping needs to be done allowing a reasonable number of errors. Mapping SGS reads in general require the ability to map indels. However, for platforms like Illumina and SOLiD, most of the reads can be aligned allowing mismatches only. In fact, some popular aligners like Bowtie () only  The authors wish it to be known that, in their opinion, the first two authors should be regarded as joint First Authors. * To whom correspondence should be addressed. consider mismatches in alignment, while many others consider only mismatches by default (). There are many experiments where a large number of mismatches are allowed, sometimes along with indels (). Therefore, the k-mismatch problem, i.e. mapping a short read allowing k-mismatches to a reference genome, is an interesting problem in bioinformatics. Although the general k-mismatch problem can be solved heuristically with generic aligners like BLAST () or exactly with aligners like BWT-SW (), they are not practical solutions to handle tens of millions of reads produced by SGS. Therefore, specialized aligners for short read mapping are needed and the existing aligners can be broadly categorized into two classes. The first class uses a variety of hashing methods or the indexing data structure BWT to index the reference genome (). Others use hashing methods to index the reads (). Then, by enumerating possible mismatch patterns, the reads are aligned onto the genome. When the number of mismatches is not high, these aligners are very efficient. However, the running time will increase rapidly when the number of mismatches increases. The hashing-based methods become slow since they need to look up many hash table entries as the number of allowed mismatches increases. BWT-based aligners, since they simulate suffix/prefix tree traversal, become slow due to the rapid increase of branches that needs to be traversed as the number of mismatches increases. As shown in Section 3, the current aligners are slow or inadequate to handle even moderate numbers of mismatches. To overcome the slowdown with large mismatches, aligners use various heuristic methods. A common solution is to use seeding methods [e.g. BWA, Bowtie and ELAND (. In these methods, selected seed regions of a read are aligned to the reference allowing a small number of mismatches and these alignments are extended allowing k mismatches. Some specialized methods like RazerS () can guarantee to find a given percentage of correct alignments. These methods cut down the alignment time dramatically. However, applying these heuristics to solve the k-mismatch problem will result in a loss of sensitivity and accuracy. Different types of experiments require different types of mappings. The most basic type of alignment reports the first hit of a read satisfying a given mismatch threshold. However, in some experiments, hits are required to satisfy some form of a uniqueness criterion. For example, in ChIP-seq experiments, scientists might prefer to map reads uniquely for better accuracy. Other situations require multiple hits for each read. For example, RNA-seq pipelines like Tophat () need an external aligner to
Fast algorithm for k-mismatch mappingproduce mappings of a given read, which are then post-processed for splice junctions. These pipelines usually require multiple mappings of a given read, since the first or the unique hits may map the read to pseudo-genes or map a read covering a splice junctions to a contiguous region in the genome. Although an aligner can be designed to perform extremely well for a first hit search, it might perform relatively slow for multiple and unique mappings. Therefore, it is preferable to have a mapping algorithm that can efficiently handle these common requirements. This article introduces a new exact method BatMis (Basic Alignment T ool for Mismatches) that solves the k-mismatch problem much faster than existing methods. BatMis does not use heuristics. It is an exact method that aligns a read to the reference genome with the minimum number of mismatches. BatMis can align a read allowing up to 10 mismatches in the whole read. Our benchmarks show that BatMis is at least as fast as the current aligners. It also shows that in many cases, BatMis can compete favorably even when compared with the heuristic modes of other aligners.
METHODS
The k-mismatch problemLet X and Y be two strings of equal length. The Hamming distance between X and Y measures the number of mismatches between X and Y and is denoted by d(X,Y ). Consider a genome T and a string R. The k-mismatch problem is to find all positions i such that d(R,T [i..i+|R|1])  k. This article is also interested in reporting the occurrences in the order of increasing mismatches, i.e. we report i before i if d(R,T [i..i+|R| 1]) < d(R,T [i. .i +|R|1]).
Suffix array and SA rangesSuffix array is an index for exact string matching which was first introduced by. Let T [1..n] be a genome of length n where the nucleotides are represented by characters taken from the alphabet = {a,c,g,t}. We assume a special character $ appears at the end of T , and it is assumed to be lexicographically smaller than all characters in. We use the notation T * to denote the string constructed by reversing T [1..n1] and appending $ to its end. The empty string is denoted by . The suffix array SA T [1..n] of T is a permutation of {1,...,n} such that, for any i < j, the suffix starting at position SA Tis lexicographically smaller than the suffix starting at position SA T. Let P be a string. Suppose SA Tand SA Tare the lexicographically smallest and largest suffixes, respectively, having P as a prefix. We define the intervalas the SA T range of P. The length of the SA T range of P is j i+1. In general, we will call SA T ranges and SA T * ranges as SA-ranges.
Exact matches with BWTThe BWT, or the BurrowsWheeler transformation () B T of a string T is an easily invertible permutation of T. B T and SA T are related by the formula B T). The result of a backward search will not be a proper interval when the SA T range does not exist. We can find the SA T range of any pattern P by starting off with the empty string, whose SA T range is, and compute the SA T range of Pusing Lemma 2.1 for i = n down to 1. We call this the backward search for P in T. We further use the backward search for P * in T * to simulate the forward search for P in T. Both types of searches will find all occurrences of the pattern P in T , but the forward search is more natural when the pattern is searched from left to right, and the backward search is the natural choice when the pattern is searched from right to left. If an SA T rangeis returned after a backward search for P in T , P occurs at locations SA T,p = i,...,j, in T. If an SA T * rangeis returned after a forward search for P in T , P can be found at locations nSA T *,p = i,...,j, in T. As an illustration, for the string T = acaactta$, we have
B T = atc$aaatc, B T * = acca$attaand SA T = (9,8,3,1,4,2,5,7,6),SA T * = (9,8,5,6,1,7,4,3,2).When performing a backward search for ac in T by Lemma 2.1, we iteratively obtain the SA T ranges of c and ac, which areand, respectively. When performing a forward search for ac in T , we will search for ca in B T * using backward search, i.e. we iteratively obtain the SA T * ranges of a and ca, which are] and, respectively. These will translate to Locations 1 and 4 in T .
Description of the algorithmConsider a reference T. Let R be a read and K be a mismatch threshold. Our aim is to find the set of all strings x in T such that d(x,R)  K. Let H k R be the set of all substrings x in T such that d(x,R) = k for k = 1,...,K. Our aim is equivalent to computingProof. When k is even, from the pigeon hole principle, we have the casesIn the first case, the proof is obvious. In the second case we haveHence Case 1 follows. Similarly, we can show that Case 2 is true.We can now re-state the algorithm as follows. When k is even, we extend patterns inRr to obtain all k-mismatch patterns of R.When k is odd, we extend patterns inRr to obtain all k-mismatch patterns of R. The Phase 2 of the algorithm where the extension of patterns are performed is done using the procedures PExt and SExt. Given a set X of substrings of T , PExt(X,R,k) performs prefix extension of the strings x in X to form another set Y of strings y = x  of T until every string y  Y satisfies either (1) |y|=|R| and d(y,R)  k or (2) d(y,R) = k +1. Similarly, SExt(X,R,k) performs suffix extension of the strings x in X to form another set Y of strings y = x of T until every y  Y satisfies either (1) |y|=|R| and d(y,R)  k or (2) d(y,R) = k +1. The procedures use the following recurrences and their pseudocode is shown inSExt({ x},R,k), otherwiseGiven these two procedures, the k-mismatch patterns of R can be computed as follows. When k is even, we report {x  PExtis odd, we report {x The above procedure not only computes all k-mismatch patterns of R, but also reports them in the increasing order of the number of mismatches. However, it is slow since it performs a lot of redundant computations. We can modify the seed extension routine to avoid redundant computations. We divide our seed extension procedure into K +1 iterations. For the kth iteration where k = 0,1,...,K, our procedure tries to obtain H k R , i.e. all kmismatch patterns of R. In the 0th iteration, we set H 0 R ={R} if R exists in T ; and H 0 R = otherwise. For the remaining iterations, we will not generate H k R starting from scratch. Instead, our routine will check all the unsuccessfully extended patterns from the (k 1) st iteration and see if they can be extended and become a k-mismatch pattern of R. Precisely, the kth iteration is divided into two stages. The first stage tries to extend those unsuccessfully extended patterns from the (k 1) st iteration. The second stage tries to recover the remaining k-mismatch patterns by extending a special set of seeds that guarantees to generate all the remaining k-mismatch patterns with no redundancy. Before we give the details of Phase 2, we need some definitions to describe the set of unsuccessfully extended patterns from the (k 1) st iteration. By Lemma 2.2, if k 1 is odd, we need to extend the patterns in (k2)/2Rr to obtain all the (k 1)-mismatch patterns of R. If k 1 is even, we need to extend the patterns inRr to obtain all the (k 1)-mismatch patterns of R. When the extended patterns accumulate k mismatches, their extensions are stopped and are marked as unsuccessfully extended patterns. These unsuccessfully extended patterns are included in PRE k R and SUF k R depending on whether they have k mismatches with a prefix or a suffix of R, respectively. Formally, they are, defined as follows. (Note that k/21 = (k 2)/2 if k 1 is odd and (k 1)/2 if k 1 is even. In addition, k/21 = (k 2)/2 if k 1 is odd and (k 3)/2 if k 1 is even.) @BULLET Let PRE k R be the set of substrings x in T such that d(x,R) = k,@BULLET Let SUF k R be the set of substrings x in T such that d(x,R[|R||x|+Intuitively, PRE k R contains a subset of the shortest substrings of T having exactly k mismatches with a prefix of R and SUF k R contains a subset of shortest substrings of T having exactly k mismatches with a suffix of R. The following lemma states how to compute the setsProof. By Lemma 2.2, for any string R which has 1 mismatch with R,The following two lemmas state the recursive formulas to compute
Lemma 2.4. Consider a read R and suppose k is odd. Let P
Fast algorithm for k-mismatch mappingProof. Let R be any string in T such that d(R ,R) = k, where k is odd. By Lemma 2.2, we have either, there should be some , where |R l | |R |, such that d(RR contains all k-mismatch stings of R in T , we have H k R {x  P S | d(x,R) = k}. From the last two relations, the first identity can be obtained. By definition, PRE k+1 RUsing similar arguments, we can prove the third statement.) iteratively for k = 2,...,K (see lines 817). Finally, the program reports H k R for k = 0,...,K.
Details of implementationWe need to find all occurrences of strings corresponding toand SUF j R for 0  i K/2,0  j  K. Furthermore, we need an efficient way to extend them. To solve this problem, we build two BWT indexes B T andare represented by their SA T-ranges, where 0  i K/2,0  j  K. The extension of SA T *-ranges are done using forward search. Similarly, the extension of SA T-ranges is done using backward search. The strings in H k R will in general contain a mixture of SA T and SA T *ranges, and it might be necessary to convert SA T ranges to SA T * ranges or vice versa. This conversion is done by taking the string corresponding to SA T ( or SA T * ) range and performing a forward (or backward) search on it. To speedup pattern searching, we also build a table containing the SA-ranges of all substrings of length at most 6. This table can be used to calculate the SA-ranges corresponding to the first few bases of a string quickly. BatMis concatenates individual chromosomes of a genome into a single genome. The exact algorithm is run on this single genome. It might happen that a read will align to a chromosome boundary. These boundary errors occur very rarely, for example in the datasets we tested in Section 3 at most two such errors occurred per dataset. This accuracy is quite sufficient for practical purposes, but we have included a post-processing script to thoroughly resolve reads with boundary errors. The algorithm is implemented in C/C++. We use the BWT routines from BWT-SW () program. After each SA range is obtained, the corresponding locations in the genome have to be decoded. The decoding algorithm is based on. To facilitate the decoding, we store SA Tfor every i which is a multiple of some fixed length . To computeSA T, the algorithm counts the number of steps s needed to arrive at a sampled point B Tby inverting the BurrowsWheeler transform starting at B T. Then, SA T=SA Ts is computed. SA T * needs to be sampled as SA T * ranges need to be decoded as well. We improve this decoding step further in the following way. During the extension step, if the string being extended occurs uniquely in T and the corresponding SA-range was sampled, we save this SA-range. We next count the number of steps s needed to complete the extension. With this information, the location in the genome can be calculated using the formula above. In the actual implementation, since storing the sampled SA-ranges takes a lot of memory, the implementation can optionally convert all SA T ranges to SA T * ranges (or vice versa) and use only one sampling. For the human genome, if only one sampling is used with sampling length  = 8, the decoding algorithm can be run under 4 GB of RAM. Furthermore, the recursions are unrolled for efficiency. For mismatch thresholds less than 5, the algorithm is implemented as stated. When scans are performed allowing a large number of mismatches, storing SUF i R and PRE i R requires a lot of memory. To reduce memory usage, for k > 5, the set of k-mismatch hits, H k R , is computed directly based on Lemma 2.2. Although this approach reduces the memory required to store SUF i R and PRE i R for i > 5, it will also generate duplicate hits. Post-processing steps are performed to remove the duplicate hits. When mapping SOLiD reads, the reference genome is converted to color space. To convert color space reads to nucleotide space, the algorithm given in BWA is used.
RESULTSThere are a vast number of sequence aligners that can perform exact k-mismatch alignment. Different aligners have different policiesfairly, we use datasets without uncalled bases. We test each program's ability to report the least mismatch hits, the unique hits and multiple hits. By the least mismatch hit of a read R in the reference T , we mean any position i such that d(R,T [i..i+|R|1])  k, and for any other position j we have
C.Tennakoon et al.). By a unique hit of a read R in the reference T , we mean a unique lowest mismatch hit of R in T. For comparison with our algorithm, we chose BWA (version 0.5.9-r16) to represent aligners of the BWT family, RazerS2 to represent q-gram methods and ZOOM (Linux64 demo version 1.5.5.20120225072719) to represent methods that use gapped seeds. We believe that these programs are among the best in the literature for handling a large number of mismatches. All the experiments were done on a Linux server running on 26-Core Intel Xeon X5680 Processors (3.33 Ghz), with 144 GB RAM. Each aligner was run in a single core, and the user time was reported. All tested programs were run in their default settings with appropriate options for ignoring indels and enabling exact mapping set as needed. The demo version of ZOOM is only fully sensitive up to four mismatches. Because of this limitation, ZOOM was run allowing up to four mismatches only. Both BatMis and RazerS2 can report least mismatch hits and unique hits. For BWA, the default setting will report a unique hit if it exists or will otherwise report a random least mismatch hit. For ZOOM, the default mode outputs only the unique hits; it was made to output least mismatch hits with the-mk option. BWA, ZOOM and BatMis used the same reference genome where uncalled bases in the genome were replaced with a random nucleotide. For BWA and BatMis, the total time for the alignment and decoding the output is reported. For BatMis, postprocessing was done to recover hits with boundary errors, and this time was added to the total time reported. All the command line parameters to obtain each table are described in the Supplementary material.
Ability to detect mismatchesIn this section, we examine the robustness of mismatch mappings of the selected aligners. We randomly extracted two sets of 51 bp and 100 bp reads from regions of hg18. Each dataset contained 100 000 reads. New k-mismatch datasets were created by introducing exactly k mismatches uniformly at random to all reads in the original dataset for k = 0,1,2,3,4,5,8 and 10. If an aligner performs k-mismatch mapping correctly, it must be able to map all k-mismatch reads to the reference genome allowing k-mismatches. Supplementarysummarizes these results. BWA missed some hits with a large number of mismatches for 100 bp reads. It was able to map all the reads with up to five mismatches, but was only able to map 97 291 and 15 124 of reads having 8 and 10 mismatches, respectively. Other aligners were able to map back all the reads. This result suggests that BatMis, ZOOM and Razers2 can detect k-mismatches effectively but BWA might miss some hits when k is large.
Mapping real dataThis section studies the performance of different algorithms using real data. We first check the performance of each aligner when reporting the least mismatch hits. Many biologists prefer to have unique hits as a criteria to filter out noise. Therefore, we also measure the performance of different aligners on finding unique hits in real data. The evaluation used the Illumina sequencing datasets ERR000577 and ERR024201 taken from the European Nucleotide Archive. The datasets contained reads of lengths 51 bp and 100 bp, respectively. These datasets are paired end reads, and we chose the datasets containing the forward reads. Reads containing uncalled bases were filtered out, and the first 1 000 000 reads were selected for benchmarking. These sets of reads were mapped to the reference genome hg18 allowing different numbers of mismatches. ZOOM and Razers2 produce a small number of false mappings. The results of these mappings are given in Tables 1 and 2.In general, all aligners report a similar number of hits for both 51 bp and 100 bp reads. However, BWA will report significantly less number of hits compared with the other aligners when the number of mismatches is large. For all the reads where another aligner can find a least mismatch hit, BatMis will also report a least mismatch hit. In addition, BatMis will report all the correct unique hits found by other aligners.
Fast algorithm for k-mismatch mapping
Multiple mappingsWe benchmarked the time taken by each aligner to produce multiple mappings of a given read. We used the 100 bp real life dataset that were used in the previous section. BatMis and BWA have options to scan all possible hits with less than k mismatches. For ZOOM and Razers2, since such a mode is not present, the mapping was done to produce the first 100 000 hits for a given read. ZOOM and BWA gave a small number of false hits mainly due to boundary errors. The results are given in. BatMis reports all the true hits found by other aligners and is faster than them when performing multiple mappings. All aligners report about the same number of hits, although Razers2 and BWA reports less number of hits compared with the other aligners when the number of mismatches is large.
Comparison against heuristic methodsInstead of searching for the exact solution, BWA and RazerS2 can employ heuristics to speed up mapping. BWA will first find hits in a seed region allowing at most two mismatches and extend the rest of the read allowing a given number of mismatches in the full read. RazerS2 has a heuristic mode where the reads can be mapped with 99% accuracy. Heuristics may miss some hits. This will result in incorrectly calling uniquely mapped reads.shows the speed and the number of true unique hits recovered using heuristics modes of BWA and RazerS2 against the exact algorithm of BatMis. The mapping procedure was similar to that in Section 3.2, except that BWA was run in its seeding mode and RazerS2 was run with its default sensitivity of 99%. The results show that BatMis is much faster than RazerS2 in all cases. BWA performs very well in its seeded mode on real data for long reads. For 51 bp reads, BatMis is faster than BWA and produces more mappings. For 100 bp reads, BatMis is faster than BWA for up to five mismatches. At 8 and 10 mismatches the speeds are similar, with BatMis again producing more hits. The false unique hits reported by the aligners in their heuristic modes are negligible, and a reasonable number of correct unique hits were recovered. Supplementaryshows the statistics for obtaining all kmismatch hits with BWA in its heuristic mode and with BatMis. RazerS2 was not considered as it is slow even for finding uniqueBWA and RazerS2 were run in their heuristic modes. Entries in bold produce false hits, and the number of false hits is shown inside the brackets. hits. We can see that for both types of reads, BatMis is faster or has comparable speed with BWA. The heuristics of BWA can produce exact results up to two mismatches. For the 100 bp reads, BWA misses between 2 and 9% hits, and for 51 bp reads it will miss 11 and 30% hits when there are 35 mismatches.
C.Tennakoon et al.
DISCUSSIONThe solution for the k-mismatch mapping is important to secondgeneration sequencing. We introduced a new algorithm BatMis that can solve the k-mismatch problem exactly and efficiently. We checked the ability to find least mismatch hits, unique hits and multiple hits of some of the current state of the art aligners. Our results show that some aligners cannot reliably map reads with a large number of mismatches. On the other hand, BatMis was able to recover all the hits and was faster. Finally, BatMis is faster or has a comparable performance with the heuristic methods of other aligners. These results show that BatMis is a robust aligner that performs well at all mismatch thresholds. One limitation of BatMis is that it cannot handle paired-end reads and indels. We believe that BatMis is a useful alternative for mapping SGS reads when we want to perform multiple mapping, unique mapping or when we want to tolerate a large number of mismatches.
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
