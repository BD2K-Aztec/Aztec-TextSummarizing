Motivation: Low-cost genome sequencing gives unprecedented complete information about the genetic structure of populations, and a population graph captures the variations between many individuals of a population. Recently, Marcus et al. proposed to use a compressed de Bruijn graph for representing an entire population of genomes. They devised an Oðn log gÞ time algorithm called splitMEM that constructs this graph directly (i.e. without using the uncompressed de Bruijn graph) based on a suffix tree, where n is the total length of the genomes and g is the length of the longest genome. Since the applicability of their algorithm is limited to rather small datasets, there is a strong need for space-efficient construction algorithms. Results: We present two algorithms that outperform splitMEM in theory and in practice. The first implements a novel linear-time suffix tree algorithm by means of a compressed suffix tree. The second algorithm uses the Burrows–Wheeler transform to build the compressed de Bruijn graph in Oðn log rÞ time, where r is the size of the alphabet. To demonstrate the scalability of the algorithms , we applied it to seven human genomes. Availability and implementation:
Introduction
BackgroundSecond-and third-generation sequencers produce vast amounts of DNA sequence information, and it is often the case that multiple genomes of the same or closely related species are available. An example is the 1000 Genomes Project, which started in 2008. Its goal was to sequence the genomes of at least 1000 humans from all over the world and to produce a catalog of all variations (SNPs, indels, etc.) in the human population. In this article, the term 'pan-genome' of the population refers to the genomic sequences together with this catalog.coined the term pan-genome a decade ago; they evaluated the composition of six strains of Streptococcus agalactiae. The pan-genome analysis of other bacteria followed: e.g. the pan-genome structure of Escherichia coli was studied by. In a broader sense, the pan-genome defines the entire genomic repertoire of a given phylogenetic clade (which may range from species to phylum and beyond). One distinguishes between the core genome that contains genes shared by all strains within the clade (housekeeping genes, etc.), the dispensable genome (made of genes shared by only a subset of the strains) and strain-specific genes. Since the de novo assembly of, e.g. mammalian genomes, is still a serious problem (both from a technological and a budgetary point of view), the reference-based approach dominates in genomics. Small wonder that most methods to represent a pan-genome by a graph are reference based. Here, we briefly discuss a few of them:were the first to explicitly model variation in a population DAG of a few Arabidopsis thaliana genomes.used a data structure called 'Journaled String Tree' to consistently represent both SNPs and indels as edits to a reference genome, anduse a population reference graph for genome inference. In contrast to these works, which are all alignment-based,came up with a different solution: they proposed context mapping to relate genomes.proposed a reference-and alignment-free approach for pan-genome analyses. Ideally, it takes multiple assembled genomes as input, but it can also work with contigs. For some species, especially medically important bacteria, multiple complete genomes are available. For example, in 2015, NCBI GenBank contained 72 strains of Chlamydia trachomatis (a sexually transmitted human pathogen) and 62 strains of the prokaryotic model organism E.coli.proposed a compressed de Bruijn graph as a graphical representation of the relationship between genomes. Basically, it is a compressed version of the colored de Bruijn graph introduced bydescribe an On log g time algorithm that directly computes the compressed de Bruijn graph based on a suffix tree (ST), where n is the total length of the genomes and g is the length of the longest genome. They write about their software splitMEM: 'Future work remains to improve splitMEM and further unify the family of sequence indices. Although. .. , most desired are techniques to reduce the space consumption. .. ' In this article, we present two different techniques that achieve this goal. The first implements a novel linear-time suffix tree algorithm by means of a compressed ST (CST). The second algorithm uses the BurrowsWheeler transform to build the compressed de Bruijn graph in On log r time, where r is the size of the alphabet R. Preliminary ideas for the second algorithm were presented by. In contrast to splitMEM, both of our algorithms use only O(n) space. The contracted de Bruijn graph introduced by Cazaux et al.(2014) is not identical with the compressed de Bruijn graph. A node in the contracted de Bruijn graph is not necessarily a substring of one of the genomic sequences [see the remark following Definition 3 in the article by. Thus the contracted de Bruijn graph, which can be constructed in linear time from the ST, is not useful for our purposes. Very recently, other alignment-free and reference-free approaches were described by Solomon and Kingsford (2015) and. Both are k-mer approaches that use Bloom filters. We will discuss their relationship to the splitMEM approach in Section 4.
Problem definitionGiven a string S of length n and a natural number k, the de Bruijn graph representation of S contains a node for each distinct length k substring of S, called a k-mer. Two nodes u and v are connected by a directed edge u ! v if u and v occur consecutively in S, i.e. u  Si::i  k  1 and v  Si  1::i  k, where Si::j denotes the substring of S starting with the character at position i and ending with the character at position j.shows an example. Clearly, the graph contains at most n nodes and n edges. By construction, adjacent nodes will overlap by k  1 characters, and the graph can include multiple edges connecting the same pair of nodes or self-loops representing overlapping repeats. For every node, except for the start node (containing the first k characters of S) and the stop node (containing the last k characters of S), the in-degree coincides with the out-degree. A de Bruijn graph can be 'compressed' by merging non-branching chains of nodes into a single node with a longer string. More precisely, if node u is the only predecessor of node v and v is the only successor of u (but there may be multiple edges u ! v), then u and v can be merged into a single node that has the predecessors of u and the successors of v. After maximally compressing the graph, every node (apart from possibly the start node) has at least two different predecessors or its single predecessor has at least two different successors and every node (apart from the stop node) has at least two different successors or its single successor has at least two different predecessors;. Of course, the compressed de Bruijn graph can be built from its uncompressed counterpart (a much larger graph), but this is disadvantageous because of the huge space consumption. That is why we will build it directly.shows how splitMEM represents the compressed de Bruijn graph G for k  3 and the string S ACTACGTACGTACG$. Each node corresponds to a substring x of S and consists of the four components id; len; posList; adjList, where id is a natural number that uniquely identifies the node, len is the length jxj of x, posList is the list of positions at which x occurs in S (sorted in ascending order) and adjList is the list of the successors of the node (sorted in such a way that the walk through G that gives S is induced by the adjacency lists: if node Gid is visited for the ith time, then its successor is the node that can be found at position i in the adjacency list of Gid). In pan-genome analysis, S is the concatenation of multiple genomic sequences, where the different sequences are separated by special symbols (in practice, we use one separator symbol and treat the different occurrences of it as if they were different characters). The nodes in the compressed de Bruijn graph of a pan-genome can be categorized as follows: @BULLET A uniqueNode represents a unique substring in the pan-genome and has a single start position (i.e. posList contains just one element). @BULLET A repeatNode represents a substring that occurs at least twice in the pan-genome, either as a repeat in a single genome or as a segment shared by multiple genomes. According to, the compressed de Bruijn graph is most suitable for pan-genome analysis: 'This way the complete pan-genome will be represented in a compact graphical representation such that the shared/strain-specific status of any substring is immediately identifiable, along with the context of the flanking sequences. This strategy also enables powerful topological analysis of the pan-genome not possible from a linear representation'.illustrates this point of view.and the string ACTACGTACGTACG$ is shown on the left, while its compressed counterpart is shown on the right. Representation of the compressed de Bruijn graph from1.
Suffix trees and other index data structuresIn this section, we briefly introduce the data structures on which our new algorithms are based. For details, we refer to the textbooks of Gusfield (1997) and Ohlebusch (2013), and the references therein. An ST for a string S of length n is a compact trie storing all the suffixes of S, i.e. the concatenation of the edge labels on the path from the root to leaf i exactly spells out the ith suffix S i  Si::n of S (S is terminated with the special character $ to guarantee that each suffix ends at a leaf of the tree). An ST can be built in linear time. For each node v in ST, strv denotes the string obtained by concatenating the labels on the edges on the root-to-v path. In this article, we need the following operations on STs (u and v are nodes): sDepthv gives v's string-depth jstrvj; parentv=fChildv=nSiblingv yields the parent/first child/next sibling of v (if existent); if strv  aa for some character a, then the suffix link sLinkv gives the unique node u with stru  a; LCAu; v yields the lowest common ancestor of u and v; HAQv; k returns the highest ancestor u of v so that jstruj ! k. Below we will show that HAQv; k can be supported in constant time; it is wellknown that the same is true for the other operations. The suffix array SA of the string S is an array of integers in the range 1 to n specifying the lexicographic ordering of the n suffixes of S, i.e. it satisfies S SA1 < S SA2 <    < S SAn ;. A suffix array can be constructed in linear time. For every substring x of S, the x-interval is the suffix array interval i::j so that x is a prefix of S SAk if and only if i k j. For a node v in ST, the strv-interval in the suffix array, denoted by lbv::rbv, contains all the suffixes of the subtree of ST rooted at v. To support the operation HAQv; k on the ST in constant time, initialize a bit vector B of size n with zeros and proceed as follows. For each internal node u in ST with sDepthu ! k and sDepthparentu < k set Blbu  1 and Brbu  1, where lbu::rbu is the stru-interval. Now preprocess B in linear time so that a rank 1 B; i query (returns the number of ones in B up to and including position i) and a select 1 B; i query (returns the position of the ith one in B) can be answered in constant time. The resulting data structure requires only n  on bits: n bits for B and on bits to support the queries in constant time. The node u  HAQv; k can then be found in constant time as follows: select 1 rank 1 B; lbv returns the position i of the first 1 in B that is left to lbv and select 1 rank 1 B; lbv  1 returns the position j of the first 1 in B that is right to rbv (note that i  lbv and j  rbv is possible). It can be shown that leaf i is the leftmost and leaf j is the rightmost leaf of the subtree rooted at u. Hence LCAi; j yields the node u (note that u  v is possible). The BurrowsWheeler transform converts the string S into the string BWT1::n defined by BWTi  SSAi  1 for all i with SAi 6  1 and BWTi  $ otherwise;. The BWT can be built in linear time via the suffix array, but there are also algorithms that construct the BWT directly (i.e. without constructing the suffix array). The LF mapping (last-to-first-mapping) is defined as follows: IfSAi  q, then LFi is the index j so that SAj  q  1 (if SAi  1, then LFi  1). In other words, if the ith entry in the suffix array is the suffix S q , then LFi 'points' to the entry at which the suffix S q1 can be found;. In data compression, the LF-mapping is used to reconstruct the original string S from the BWT (given the BWT, the LF-mapping can easily be computed in linear time). The LCP-array stores the lengths of the longest common prefixes of lexicographically adjacent suffixes: for 2 i n; LCPi  max fp ! 0jS SAi and S SAi1 share a prefix of length pg and LCP1  1  LCPn  1; seefor an example. The LCParray can be computed in linear time from the suffix array and its inverse, but it is also possible to construct it directly from the BWT in On log r time. A CST with full functionality supports the same operations as an ST. It consists of three components: a compressed suffix array, a compressed LCP-array and a succinct representation of the ST topology. A CST requires much less space than an ST, but it cannot support all operations in constant time. A substring x of S is a repeat if it occurs at least twice in S. Let x be a repeat of length ' and let i::j be the x-interval. The repeat x is left-maximal if jfBWTqji q jgj ! 2, i.e. the set fSSAq  1ji q jg of all characters that precede at least one ofGraphical pan-genome analysisthe suffixes S SAi ;. .. ; S SAj is not singleton (where S0 : $). Analogously, the repeat x is right-maximal if jfSSAq  'ji q jgj ! 2. A left-and right-maximal repeat is called maximal repeat.An internal node v in the ST is called left-maximal if strv is a left-maximal repeat. Note that every internal node v of the ST is right-maximal in the sense that strv is a right-maximal repeat.
MethodsOur algorithms are based on the following simple lemma: Let v be a node in the compressed de Bruijn graph and let x be the string corresponding to v. If v is not the start node, then it has at least two different predecessors if and only if the length k prefix of x is a left-maximal repeat. It has at least two different successors if and only if the length k suffix of x is a rightmaximal repeat.The lemma provides a tool to decide at which positions a split occurs. Both of our methods make extensive use of it.They introduce so-called 'suffix skips' to compute repeatNodes in On log g time. Our new linear-time Algorithm 1 computes repeatNodes without them. The idea behind Algorithm 1 is as follows: Start the computation only with left-maximal internal nodes that have no internal node as child and use suffix links to detect their repeat-structure (i.e. where splits are necessary). Stop the computation if a left-maximal internal node x is encountered. This is because either x has no internal node as child, so it will be considered later, or x has an internal node y as child, so its repeat-structure will be found when y is processed. In Algorithm 1, cur is a pointer to a repeat that must or must not be split later, and ' is the number of characters that must be skipped before the split occurs (note that if a split occurs, then the left and right part overlap by k  1 characters). A split occurs if the k-length prefix of strv is left-or right-maximal, where v is the current internal node. Let u  HAQv; k and consider the situation of. In that situation, Algorithm 1 uses the following case analysis:7: else if d > k then 8: cur v 9: ' / 0 10: repeat 11: u HAQv; k " u  v is possible 12: if u is left-maximal then 13: if ' > 0 then "1 If stru is a left-maximal repeat, then the length k prefix of stru is left-maximal. This implies that the length k prefix of strv is leftmaximal. If in this case ' > 0, then x must be split at the beginning of stru; so the length '  k  1 prefix of x is a repeatNode. 1a If stru is a right-maximal k-mer (because sDepthu  k), then x must also be split at the end of stru because stru is also a repeatNode. The algorithm continues with x'  2::jxj and '  0. 1b If stru is not a right-maximal k-mer, then the algorithm continues with the string strv  x'  1::jxj and '  1. 2a If stru is not a left-maximal repeat but a right-maximal k-mer, then x must be split at the end of stru; so the length '  k prefix of x is a repeatNode. The algorithm continues with x'  2::jxj and '  0. 2b If stru is neither a left-maximal repeat nor a right-maximal kmer, then the algorithm continues with the string x and '  1. The procedure CREATE-REP-NODE in Algorithm 1 creates a new repeatNode if this node does not exist yet.is the shortest prefix of str(v) of length ! k that is right-maximal because u  HAQv ; k We will next show that Algorithm 1 runs in On time. Since all operations in the algorithm take constant time, the run-time is proportional to the overall number of suffix links that are followed. The ST of a string S of length n has n leaves. Since every internal node is branching, ST has at most n  1 internal nodes. It follows that there are at most n  1 suffix links because every internal node has exactly one suffix link. We claim that every suffix link is used at most once in Algorithm 1. Suppose to the contrary that a suffix link from node v to node w is used more than once. This is only possible if node v has at least two incoming suffix links, say from nodes u and u 0. If strv  a, then we must have stru  aa and stru 0   a 0 a for two distinct characters a and a 0. However, this implies that v is left-maximal and Algorithm 1 stops whenever a left-maximal node is reached. This contradiction proves our claim and shows that Algorithm 1 runs in linear time. Once Algorithm 1 has computed the repeatNodes, we proceed as in the second phase of splitMEM: the set of genomic starting positions that occur in each repeatNode is sorted, so that uniqueNodes that bridge any gaps between adjacent repeatNodes as well as the edges in the compressed de Bruijn graph can be computed in a single pass over the sorted list. However, there is one difference to: to achieve linear run-time, we use a non-comparison-based sorting algorithm for this task; details can be found in the Supplementary Material.
Using a (compressed) suffix tree
Using the BWTOur second algorithm uses the BWT and the LF-mapping to compute the complete compressed de Bruijn graph G (uniqueNodes, repeatNodes and the edges between them) in a single backward pass over the whole pan-genome S. To be more precise, Algorithm 2 starts with the suffix S n  $ at index j  1 in the suffix array and successively computes the indices of S n1 ;. .. ; S 1 with the help of the LF mapping (i.e. S n1 can be found at index i  LFj; S n2 can be found at index LFi, etc.). In Algorithm 2, the current string x is a prefix of suffix S p , which occurs at index j in the suffix array. The next string that must be considered in the algorithm is cx, where c  Sp  1. Note that cx is a prefix of suffix S p1 , which occurs at index i  LFj in the suffix array. The string x must be split if (i) the length k prefix of cx is a right-maximal repeat or (ii) the length k prefix of x is a left-maximal repeat; seeHere, we only briefly explain this procedure; it is described in detail in the Supplementary Material, where it is also shown that its run-time is On log r. All three bit vectors are initialized with zeros. The procedure obtains the bit vector B 1 by computing the suffix array interval lb::rb of each right-maximal k-mer and setting B 1 lb  B 1 rb  1; seefor an example. Moreover, B 1 is preprocessed, so that rank-queries can be answered in constant time. By means of B 1 , it is then possible to perform test (i) in constant time: if cx is prefix of the suffix at index i in SA, then it has a right-maximal k-mer as prefix if and only if B 1 i  1 or rank 1 B 1 ; i is odd. If this is the case, a split occurs and Algorithm 2 must continue with the k-mer prefix of cx as next node. The number brank 1 B 1 ; i  1=2c will serve as a unique identifier of this next node. In the following, rightMax  rank 1 B 1 ; n=2 is the number of right-maximal k-mer intervals. Procedure CREATE-BIT-VECTORS also computes the bit vectors B 2 and B 3 as follows: If the suffix array interval lb::rb of a left-maximal repeat of length ! k is detected (hence the corresponding k-mer prefix is left-maximal), then B 2 q is set to 1 for all q in lb::rb. Moreover, for each c in BWTlb::rb, the procedure sets B 3  LFq to 1, where q is the index of the last occurrence of c in BWTlb::rb. Finally, the procedure resets each one bit in B 3 that marks a right-maximal k-mer to zero (the reason for this will become clear in a moment); in the example of, no bit of B 3 had to be reset. By means of B 2 , it is then possible to perform test (ii) in constant time: if x is prefix of the suffix at index j in SA, then it has a left-maximal k-mer as prefix if and only if B 2 j  1. If this is the case, a split occurs and Algorithm 2 must continue with the k-mer prefix x of cx, which is a prefix of the suffix at index i  LFj, as next node. If B 1 i  1 or rank 1 B 1 ; i is odd, then brank 1 B 1 ; i  1=2c is the identifier of this next node. If not, then we use the bit vector B 3 to assign the unique identifier rightMax rank 1 B 3 ; i  1  1 to the next node, which corresponds to (or ends with) x. This is because rightMax is the number of all rightmaximal k-mers and rank 1 B 3 ; i  1  rank 1 B 3 ; lb 0  1, where lb 0 ::rb 0  is the x-interval. It can be shown that B 3 lb 0 ::rb 0  1 solely contains zeros and B 3 rb 0   1; consequently rank 1 B 3 ; i  1  1  rank 1 B 3 ; rb 0 . To sum up, after the preprocessing phase it is known that the compressed de Bruijn graph G has rightMaxleftMax  1 many nodes: there are rightMax  rank 1 B 1 ; n=2 many nodes that end with a right-maximal k-mer, leftMax  rank 1 B 3 ; n many nodes that end with a non-right-maximal k-mer and the stop node that ends with the special symbol $. Consequently, Algorithm 2 initializes an array G of that size, in which a node is represented by the triple len; posList; adjList, where posList is the sorted list of positions at which the corresponding string x occurs in S; len is the length of x and adjList is the corresponding adjacency list. The for-loop of Algorithm 2 implements the single backward pass over S as described above. A split occurs whenever number 6  ?. In this case, the position p is added to the front of the posList of the current node cur and cur is added to the front of the adjList of the next node number. If number  ?, then the length of the string corresponding to node cur is incremented by one.. The string x is prefix of the suffix S p of S and cx is prefix of Sp1. x must be split if (i) the length k prefix of cx is a right-maximal repeat or (ii) the length k prefix of x is a left-maximal repeatAs explained in the Supplementary Material, the computation of the bit vectors B 1 ; B 2 and B 3 requires On log r time. Apart from the LF-mapping, all operations in Algorithm 2 take only constant time. In our implementation, the LF-mapping is implemented by a wavelet tree of the BWT, so it takes Olog r time to compute a value LFj. Consequently, the overall run-time of Algorithm 2 is On log r.
Graphical pan-genome analysis
The size of the compressed de Bruijn graphIt follows from the preceding section that the size of the compressed de Bruijn graph can be characterized in terms of left-and rightmaximal k-mer repeats. The number of nodes equals jV 1 j  jV 2 j  1, where V 1  fxjx is a right-maximal k-mer repeat in Sg and V 2  fxj9i 2 f1;. .. ; n  kg : x  Si::i  k  1 6 2 V 1 and Si  1::i  k is a left-maximal k-mer repeat in Sg; the stop node is taken into account by adding 1. The number of edges is jfij1 i n  k and Si::i  k  1 2 V 1 [ V 2 gj.
ResultsWe implemented our new algorithms in C, using the library sdsl of. Software and test data are available at http:// www.uni-ulm.de/in/theo/research/seqana.html. Both algorithms use a variant of the semi-external algorithm described into construct the CST and the BWT, respectively. The experiments were conducted on a 64 bit Ubuntu 14.04.1 LTS (Kernel 3.13) system equipped with two ten-core Intel Xeon processors E52680v2 with 2.8 GHz and 128 GB of RAM (but no parallelism was used). All programs were compiled with g (version 4.8.2) using the provided makefile. With the CST-based and the BWT-based algorithm, respectively, we built compressed de Bruijn graphs for the 62 E.coli genomes (containing 310 million base pairs) listed in the Supplementary Material of, using the k-mer lengths 50, 100 and 1000.lists the results of our experiments. The run-times include the construction of the index, but similar to splitMEM it is unnecessary to rebuild the index for a fixed dataset and varying values of k. The peak memory usage reported inincludes the size of the index and the size of the compressed de Bruijn graph. Because of its large memory requirements, splitMEM was not able to build a compressed de Bruijn graph for all 62 strains of E.coli on our machine equipped with 128 GB of RAM. That is why we included a comparison based on the first 40 E.coli genomes (containing 199 million base pairs) of the dataset. The experimental results show that both of our algorithms use significantly less space (two orders of magnitude) than splitMEM. The CST-based algorithm is five times faster than splitMEM, while the BWT-based algorithm is more than an order of magnitude faster. It is worth mentioning that our two algorithms compute isomorphicbut not necessarily identicalcompressed de Bruijn graphs because the node identifiers may differ. To show the scalability of our new algorithms, we applied them to five different assemblies of the human reference genome (UCSC Genome Browser assembly IDs: hg16, hg17, hg18, hg19 and hg38) as well as the maternal and paternal haplotype of individual NA12878 (Utah female) of the 1000 Genomes Project; see. The compressed de Bruijn graphs of their first chromosomes (7xChr1, containing 1736 million base pairs) and the complete seven genomes (7xHG, containing 21 201 million base pairs) were built for the k-mer lengths 50, 100 and 1000. The experimental results inshow that the BWT-based algorithm clearly outperforms the CST-based algorithm. It took slightly over 6 h (22 000 s) to construct the index of the seven human genomes and less than 2 h (60007000 s) to build the graph with the Our CST-based algorithm mimics splitMEM in this respect, whereas the BWT-based algorithm treats the different occurrences of # as if they were different characters. Assuming that # is the second smallest character, this can be achieved as follows. As explained in the Supplementary Material, all right-maximal k-mers can be determined without the entire LCP-array if the algorithm inis used. If there are m  1 occurrences of # in total and this algorithm starts with m  1 singleton intervals i::i; 2 i m, instead of the #-interval 2::m, then the different occurrences of # are treated as if they were different characters.
DiscussionWe have presented two space-efficient methods to build the compressed de Bruijn graph from scratch. An experimental comparison with splitMEM showed that our algorithms are more than an order of magnitude faster than splitMEM while using significantly less space (two orders of magnitude). To demonstrate their scalability, we successfully applied them to seven complete human genomes. Consequently, it is now possible to use the compressed de Bruijn graph for much larger pan-genomes than before (consisting, e.g. of hundreds or even thousands of different strains of bacteria). Although the BWT-based algorithm is the clear winner of the comparison, CSTbased algorithms are still important. This is because STs play a central role in sequence analysis and most bioinformatics curricula comprise courses that cover this important data structure. It is therefore conceivable that a bioinformatician might be able to come up with a suffix tree algorithm that solves his/her problem at hand, but not with an algorithm that is based on the BWT and/or related data structures. If the space requirement of the ST is the bottleneck in the application, one can use a CST instead. CSTs with full functionality are, e.g. implemented in the succinct data structure library (sdsl) of. On the downside, extra features such as suffix skips are not implemented in those libraries so that a direct implementation of a suffix tree algorithm by means of a CST might not be possible. Future work includes parallel implementations of the algorithms. Moreover, it should be worthwhile to investigate the time-space tradeoff if one uses data structures that are optimized for highly repetitive texts, see Navarro and Ord n  ez (2014) and the references therein. Most important, however, is to address the problem of compressing the 'compressed de Bruijn graph' itself. (Our experiments show that for smaller k, the size of the graph can be larger than the size of the index, e.g. the graph for the seven human genomes and k  50 takes 1.65 bytes per base pair, whereas the BWT-index requires only 1.13 bytes per base pair.) Very recently, two Bloom filter methods were presented that can be used for this purpose. Solomon and Kingsford (2015) introduced the Sequence Bloom Tree to support sequence-based querying of large-scale collections of thousands of short-read sequencing experiments and applied it to the problem of finding conditions under which query transcripts are expressed. The second approach byis closer to the splitMEM approach. Their data structurethe Bloom Filter Trie (BFT)allows to efficiently store and traverse the uncompressed de Bruijn graph. In the Section Conclusion of their article,write 'Future work concerns the possibility to compress non-branching paths. .. ' This is exactly what splitMEM and our new algorithms do, so maybe the combination of both approaches will yield the ideal pan-genome representation.The first row in a block specifies the experiment. The second row shows the graph size in bytes per base pair. Rows 36 contain the numbers of edges, nodes, uniqueNodes and repeatNodes, respectively. Rows 710 show the average out-degree of the nodes as well as the average string length of the nodes, uniqueNodes and repeatNodes. The remaining rows (if applicable) contain the percentage of the nodes that are shared by x sequences.
FundingThis work was supported by the Deutsche Forschungsgemeinschaft (DFG grant no. OH 53/6-2). Conflict of Interest: none declared.
U.Baier et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
The columns show the run-times in seconds and, in parentheses, the maximum main memory usage in bytes per base pair. A minus indicates that the algorithm was not able to solve its task on our machine equipped with 128 GB of RAM.
