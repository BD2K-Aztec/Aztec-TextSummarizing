We propose a C++ class library developed to the purpose of making the implementation of sequence analysis algorithms easier and faster when genomic annotations and variations need to be considered. The library provides a class hierarchy to seamlessly bind together annotations of genomic elements to sequences and to algorithm results; it allows to evaluate the effect of mutations/variations in terms of both element position shifts and of algorithm results, limiting recalculation to the minimum. Particular care has been posed to keep memory and time overhead into acceptable limits. Availability and Implementation: A complete tutorial as well as a detailed doxygen generated documentation and source code is
MOTIVATIONSequence analysis algorithms play a crucial role in the identification of genomic functional elements. Several algorithms have been and are being developed to identify putative binding sites for a great number of functional elements involved in many cellular processes. Algorithms are usually implemented through 'sequencedriven' programs: a sequence is provided upon which calculations are made and results are returned with a reference to sequence positions. In the great majority of cases the results need to be interpreted in the light of some functional element annotated elsewhere (transcripts, genes, intron/exon boundaries, etc.) or their significance can be improved by comparison with some other features such as sequence conservation among different species or chromatin accessibility. These are time-consuming tasks that are often implemented using specialized packages based on interpreted languages like, for example BioPerl () and Bioconductor (). The same holds true when sequence variations are involved in the analysis. Sequence-driven programs need multiple runs to make calculations on multiple input sequences: this often lead to redundant recalculations and data I/O operations. Again the comparison of the results between 'varied' and * To whom correspondence should be addressed. 'unvaried' sequences is left to the user. Furthermore, variations can change the positions of genomic elements of interest making the interpretation of the results even more difficult. Despite a number of efficient and feature-rich libraries and tools have been developed for sequence-driven algorithm implementation, the above-mentioned tasks are usually left to the user. The complexity of these tasks is a severe limitation to an extensive application of algorithms implemented in this way. Several useful bioinformatics workflow tools like Taverna (), Gaggle () and Galaxy (), have been developed to automatize, standardize and speed up analyses and visualizations integrating different programs and data sources. These workflow management tools can be used to partially get around the above-mentioned limitations, but still they do not resolve the inefficiency of the sequence-driven software model, particularly in the frequent case of repeated runs on similar sequences. Moreover, there is an additional cost in terms of data formats conversion, I/O operations and script interpretation. On the other hand, most successful algorithms are employed to analyse entire genomes: results are collected in databases along with functional annotations and experimental data like in the UCSC Genome browser () and in Ensembl (). Genome browsers exploit these databases to give a useful, general and extensive picture of a genomic region features. Nevertheless, for any quantitative analysis, users have to query the underlying databases to fetch the data they need: a comparable situation to the one described above with the additional limitation that pre-computed algorithm results (often obtained under fixed default parameters) cannot be used to evaluate the effect of variations. We developed GeCo++ (Genomic computation C++ library), a C++ class library to the purpose of making easier and faster the efficient implementation of algorithms for sequence analysis when functional annotations and genomic variations need to be considered. The library is not intended as a substitute for more specialized libraries; instead it frees the programmers from the burden of keeping track of genomic annotations and variations, giving them the opportunity to use the libraries they prefer for specific fields like, for example Bio++ () and seqAn () for general sequence analysis or libSequence () for population genetics.
IMPLEMENTATIONThe library has been developed starting from the idea to represent and manage the numeric results of computational algorithmsPage: 1314 13131315
M.Cereda et al.keeping them tied to annotations of genomic elements (transcripts, binding sites, conserved regions, transposable elements, etc.), to their sequences and to genomic variations. It provides the definition of a genomic element model that tightly integrates information about genomic ranges, positions, genomic variations and computed/retrieved numerical features. The core idea of the model is to refer genomic ranges and positions to a reference sequence (e.g. a chromosome assembly) and to add a set of variations (substitutions, insertions and deletions) to represent actual elements (e.g. mutated ones, individual haplotypes, and so on). Based on this model the library provides the following capabilities: @BULLET memory efficient representation of alignments in terms of reference/variations: this can save a lot of memory especially when relatively few variations are involved; @BULLET automatic tracking of position changes introduced by insertions/deletions; @BULLET easy mapping of corresponding positions between different sequences; and @BULLET automatic recalculation of numerical features only where variations make it necessary thus avoiding unnecessary recalculations in unvaried regions.A genomic element is defined as an interval of a given reference sequence in a given strand. Positions can be referred to the reference sequence (reference positions, unsigned values) or to the Element (element positions, signed values relative to the element start along its strand). Element sites are defined as particular element positions (e.g. transcription start sites, splice sites or protein binding sites) while a connection represents a directed relation between two sites (e.g. introns, exons). Positional features are defined as properties that vary along an element. While no assumption is made on the biological meaning of sites, connections and features, the model is general enough to represent the majority of real-world genomic elements as well as their features. The GeCo++ library defines the class gElement as an implementation of this model: it allows users to instantiate objects representing genomic element which can contain sequence as well as sites, connections and features information. Element positions can be converted to reference ones and back, positions can be mapped between elements. The most important characteristic of gElement objects is that they can be instantiated as sub-intervals of another one considering the strand and the presence of genomic variations (relative to the reference). Sequence, sites, connections and features are inherited by the new object consistently with its interval, strand and variations avoiding redundant recalculation and retrieval at unaffected positions. Users can easily write algorithms to retrieve sequences or calculate features by deriving new classes from a hierarchy of retriever objects (gRetriever). This requires one single virtual member function implementation. Retrievers are then used by gElement objects that, in this way, are independent from specific algorithms for retrieval and calculation. To hold sequences, positions, connections, variations and features we defined another class, called gArray: a general purpose template array class. It provides tracking of undefined/invalid elements [not available (NA)] and memory efficient array subsetting. NA tracking is obtained through an optimized bits array class (gBitsArray). The gMatrix, gString and gSequence classes have been derived from gArray to manage matrices, character strings and DNA sequences, respectively. Given the level of abstraction and the inherent complexity, we considered an object oriented software model to be the most appropriate. The choice of ISO C++ guaranteed speed, portability and, most importantly for users, the access to a great number of other efficient and specialized computational biology libraries.
EXAMPLESThe tutorial available at http://bioinformatics.emedea.it/geco contains a detailed description of the library usage and features. Many specific code examples are reported to illustrate the capabilities of the library as well as their usage. A fully commented example is also reported for an application that takes as input a refSeq ID and the name of a file containing haplotype information and calculates haplotype specific sequence features. Furthermore, we provide comparison between this application and an equivalent R/bioconductor script.
DISCUSSIONNew cost-effective high-throughput sequencing and array techniques are now able to generate huge amounts of information on DNA, RNA as well as proteinDNA and proteinRNA interactions. Systems biology approaches can integrate these information at a genomic level describing and studying complex regulatory networks. Prediction and interpretation of the functional meaning of individual genomic variations could be inferred by studying the modifications and rewiring events they produce in these networks. Despite this being considered as one of the most promising challenges (), a gap remains to be filled between sequence analysis algorithms, genomic annotations and variations; the lack of tools integrating these three levels of analysis is going to become more evident as high-throughput techniques on one side and system biology on the other start to converge to translational research applications. Beside providing C++ programmers with features usually present in interpreted languages, our library introduces a genomic element model that tightly and time/space efficiently integrates computed features, position annotations and variations, allowing for feature rich 'in memory' representations of what usually is provided by genome browsers. The most important difference is that in our case this representation is able to dynamically keep track of genomic variations. To our knowledge this is an approach that has not been implemented in any other package yet, irrespectively by the language used. As a first attempt to fill this gap, the GeCo++ library makes the development of complex and efficient applications straightforward, not bounded to specific data sources or computational algorithms and that can easily evaluate the effect of sequence variations on genomic functional elements. Conflict of Interest: none declared.
The Author 2011. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
