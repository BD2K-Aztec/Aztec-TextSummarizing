Motivation: Linkage analysis remains an important tool in elucidating the genetic component of disease and has become even more important with the advent of whole exome sequencing, enabling the user to focus on only those genomic regions co-segregating with Mendelian traits. Unfortunately, methods to perform multipoint linkage analysis scale poorly with either the number of markers or with the size of the pedigree. Large pedigrees with many markers can only be evaluated with Markov chain Monte Carlo (MCMC) methods that are slow to converge and, as no attempts have been made to exploit parallelism, massively underuse available processing power. Here, we describe SWIFTLINK, a novel application that performs MCMC linkage analysis by spreading the computational burden between multiple processor cores and a graphics processing unit (GPU) simultaneously. SWIFTLINK was designed around the concept of explicitly matching the characteristics of an algorithm with the underlying computer architecture to maximize performance. Results: We implement our approach using existing Gibbs samplers redesigned for parallel hardware. We applied SWIFTLINK to a real-world dataset, performing parametric multipoint linkage analysis on a highly consanguineous pedigree with EAST syndrome, containing 28 members, where a subset of individuals were genotyped with single nucleotide polymorphisms (SNPs). In our experiments with a four core CPU and GPU, SWIFTLINK achieves a 8.5Â speed-up over the single-threaded version and a 109Â speed-up over the popular linkage analysis program SIMWALK. Availability: SWIFTLINK is available at https://github.com/ajm/ swiftlink. All source code is licensed under GPLv3.
INTRODUCTIONExact linkage analysis algorithms scale exponentially with the size of the input. Beyond a critical point, the amount of work that needs to be done exceeds both available time and memory. The ElstonStewart algorithm () calculates successive conditional likelihoods between family members, permitting the algorithm to scale linearly with the size of the pedigree (more precisely, the number of meioses), but can only analyse a handful of markers jointly. The LanderGreen hidden Markov model (HMM) approach (), on the other hand, can analyse many markers, but only in pedigrees of limited size. In between these two extremes, approaches using Bayesian networks, for example SUPERLINK (), scale to greater numbers of markers than the ElstonStewart algorithm and to larger pedigrees than the LanderGreen algorithm, but still cannot handle both large pedigrees and many markers. In the situation where we have a large, perhaps consanguineous, pedigree typed with many markers, we are forced to either abbreviate the input or else use an approximation like Markov chain Monte Carlo (MCMC). Although MCMC helps make the problem tractable, it can take a long time to converge. The problem of slow running time is compounded by the fact that existing software is single-threaded and, therefore, not designed to take advantage of all the processing power available in even a single modern PC. This underuse will become more acute as multicore processors feature increasing numbers of cores and graphics processing units (GPUs) become more general purpose. Parallelism has previously been applied to accelerate exact linkage algorithms in the applications FASTLINK, across networks of workstations (), PARALLEL-GENEHUNTER, on computer clusters () and SUPERLINK-ONLINE, on grid middleware (). Although parallel implementations of exact linkage algorithms perform analyses faster and can scale to larger problems owing to accessing memory in multiple machines, they still have the same fundamental scaling properties as their underlying algorithms. Problems outside of the scope of exact algorithms must be analysed with MCMC-based linkage programs such as *To whom correspondence should be addressed.  The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com SIMWALK2 () and MORGAN (), which have both been shown, where possible, to produce results of comparable accuracy to exact algorithms (). To the best of our knowledge, there have been no published attempts to parallelize MCMC-based linkage analysis. In general, parallelizing MCMC is considered a hard problem because the states of the Markov chain form a strict sequential ordering. Successful parallel MCMC implementations tend to focus either on parallelizing expensive likelihood calculations (for example,) or on multiple chain schemes (for example,). The approach we took with SWIFTLINK maximizes the use of hardware resources by combining both previous approaches, allowing different parts of the calculation to be distributed across both CPU and GPU. The Markov chain is run in parallel on the CPU, where each step in the chain is performed by one of two multithreaded block Gibbs samplers based on the locus sampler () and the meiosis sampler (). Expensive likelihood calculations required to estimate LOD (logarithm of odds) scores are performed on the GPU, if one is available. High performance is achieved on the GPU by maximizing hardware use, requiring us to identify substantial independent calculations. This article is organized as follows: we elaborate on the details of the Gibbs samplers used to form the Markov chain, what aspects of each sampler were changed to facilitate execution on parallel hardware and how SWIFTLINK orchestrates these actions to maximize hardware use. We report experimental results comparing SWIFTLINK with other MCMC-based linkage analysis software on a highly consanguineous pedigree and end with discussion and an outline of future work.
METHODSSWIFTLINK was designed to explicitly harness not only multiple processor cores, but also a GPU if one is present. We describe three core components for performing MCMC in the context of linkage analysis: LOD score calculation, the locus sampler and the meiosis sampler. For each of these modules, we highlight where independent calculations can be used to exploit parallelism and which hardware platform would be best suited to the algorithm in question. In addition, the structure of the application is such that we can safely use both CPU and GPU concurrently.
OverviewTo simulate the inheritance of genetic material through a pedigree, the Markov chain operates on a descent graph, S. The descent graph is made up of two meiosis indicators per non-founder of the pedigree, per loci. A meiosis indicator is a binary variable stating which grandparent that allele was inherited from (). We denote a particular meiosis indicator S i, j , as meiosis i at locus j. An example of a descent graph for a simple pedigree is shown in. The Markov chain is composed of two Gibbs samplers, the locus sampler and the meiosis sampler. At each step of the Markov chain, we run the locus sampler with probability P(locus sampler), otherwise we run the meiosis sampler. A single iteration is made up of a complete scan of all markers, in the case of the locus sampler; or all meioses, in the case of the meiosis sampler. The locus sampler is computationally more expensive than the meiosis sampler, but necessary as the meiosis sampler suffers from irreducibility issues on its own (). Although the locus sampler is known to have poor mixing, it is guaranteed to produce an irreducible Markov chain, given all recombination fractions between consecutive markers are positive. By combining the two samplers, we can therefore ameliorate their respective shortcomings (). The Markov chain is thinned by only scoring every n th sampled descent graph, and LOD scores are calculated at k equidistant points between consecutive markers. Dependent on the amount of chain burn-in and the values of k and n, LOD score calculations can easily take up the majority of the total runtime.
CPU and GPU architectureA modern commodity multicore CPU will feature, at the time of writing, up to eight homogeneous processor cores with some architecture-specific level of cache sharing. For example, it is common to have a core-local L1 cache, as well as shared L2 cache. Individual processor cores are capable of instruction-level parallelism by the explicit use of SIMD (single-instruction multiple data) instructions by the programmer or compiler. Course-grain parallelism using multiple cores concurrently must be performed programmatically by writing multithreaded code. There are two dominant APIs for GPU programming: CUDA and OpenCL. SWIFTLINK is implemented in CUDA, so throughout we will use CUDA terminology. GPU architectures feature several multiprocessors, each containing a number of stream processors. A function that runs on the GPU is called a kernel. Kernels split work into blocks and threads. Blocks are assigned to run on multiprocessors, each of which is composed of a programmer-defined number of threads. The number of threads contained in a block need not be identical to the number of stream processors inside a multiprocessor, as they are run in groups of 32 threads called warps. Stream processors are akin to CPU cores; however, within the same multiprocessor, they share a single fetch-decode unit. The shared fetch-decode unit forces threads to execute in lock-step, similar to SIMD instructions, but with the distinction that any thread can diverge from the common execution path (with the caveat that thread divergent code will cause all other threads within the same warp to stall). Analogous to the L2 cache of a CPU, GPUs feature shared memory; however, it must be explicitly populated and managed in software.. Simple three-generation pedigree (a) and one of the possible descent graphs explicitly showing the flow of genetic material from founders to leaf nodes (b)
Pedigree
LOD scoresSamples of possible descent graphs are generated by the Markov chain for which we calculate the likelihood of the trait locus being at different locations based on observed genotype data, Y M , and trait data, Y T. The LOD score at a position d is the likelihood ratio between the disease trait being found at d versus being unlinked. LOD scores can be approximated using the SobelLange estimator (), where the LOD score is defined asand PY T  is the probability that the trait locus is unlinked. PY T j b S i  is calculated via an iterative summation using the ElstonStewart algorithm () to traverse the pedigree, peeling individuals in sequence. The process of peeling an individual involves calculating partial likelihoods conditional on the members of their cut-set and the meiosis indicators at flanking loci. The cut-set C is defined as containing all unpeeled individuals adjacent to the graph cut partitioning peeled from unpeeled individuals (C i , the cut-set of the i th individual in the peeling sequence, will therefore always include i, as it is, as yet, unpeeled). Each iteration of the peeling algorithm is based on the following recursion:where H i C i  peels the i th individual given each possible assignment of disease phenotypes to members of i's cut-set C i  c 0 , c 1 ,. .. c C . For outbred pedigrees, the optimal cut-set size will never exceed 3; however, for inbred pedigrees, even the optimal ordering of variables can contain much larger cut-sets. The amount of work required to peel an individual increases exponentially with cut-set size as the number of disease phenotype assignments required to calculate each partial likelihood is 4 C j j .
Parallel computationThe calculations of LOD scores at different positions are independent of one another and only dependent on the underlying descent graph being scored. This workload is trivial to parallelize by dividing the total number of LOD scores between all CPU cores; however, this navenave strategy will not be suitable for the GPU. In our approach on the GPU, outlined in Algorithm 1, we assign each LOD score to a block and additionally parallelize the internal sum-of-products calculations from each step of the peeling sequence by assigning a GPU thread to calculate the likelihood of each disease phenotype assignment. Peeling a pedigree of p members requires p separate peeling operations with different sized cut-sets, requiring different numbers of threads to perform optimally. Unfortunately, making a separate call to the GPU per peel operation incurs substantial overhead (in our measurements as much as twice the runtime to calculate all LOD scores for one sample). It is more efficient to use a constant number of threads despite the fact many threads will sit idle at different stages of the computation. To calculate the data-dependent optimal number of threads prior to each simulation, SWIFTLINK performs several timing runs with different numbers of threads per block to ensure the best performance. We found that empirically discovering the optimal number of threads was far more robust than an analytical approach, as, despite using the same input data and graphics card, the optimum number of threads was also dependent on which version of CUDA was being used. GPU applications are sensitive to memory access patterns, and maximizing performance requires caching via shared memory and ensuring the GPU can batch ('coalesce' in the CUDA literature) time-consuming reads and writes to global memory. High memory latency is balanced by ensuring each kernel has a high occupancy, i.e. each multiprocessor is assigned as many blocks as possible, so work can be done by other warps when I/O operations are being waited on. Given the strong dependencies between matrices for intermediate calculations, we make extensive use of shared memory by opportunistically caching as many of the intermediate matrices needed for each iteration of peeling up to a total size of 4 kilobytes. GPUs supporting CUDA compute capacity 2.0 or above have 48 kilobytes shared memory per multiprocessor, which, as there can only be eight active blocks at once, is within this bound. Any memory requirements above the 4 kilobyte limit default to being directly accessed from main memory, however, that was unnecessary for any of the example pedigrees we have tested so far. We ensure the memory layout is such that a majority of reads and writes to main memory are made for contiguous addresses when populating software caches in shared memory.
Locus samplerThe locus sampler () similarly builds on the ElstonStewart algorithm, but unlike LOD scores, which are calculated at points between markers, the locus sampler samples a realization of the meiosis indicators at a given genetic marker:Sampling proceeds in two steps: (i) we use reverse peeling to sample ordered (or phased) genotypes and (ii) ordered genotypes are converted to appropriate meiosis indicators. To sample ordered genotypes, we first sample from the marginal distribution of the final individual in the peeling sequence and work backwards through the peeling sequence conditioning on those genotypes already sampled. Conversion to meiosis indicators is unambiguous for heterozygous parents, but the meiosis indicators to homozygous parents must be sampled with respect to the flanking loci in the descent graph. The locus sampler, like the calculation of LOD scores, can be expensive for large inbred pedigrees and reverse peeling must be performed sequentially. Each iteration of the locus sampler involves sampling a new descent graph at all loci in a pseudorandom order.
Parallel computationTo parallelize the locus samplers execution, we maintain a queue containing all loci that are shuffled into a pseudo-random order. The queue is consumed by a pool of worker threads equal to the number of CPU cores, with the special consideration that loci adjacent to those currently being sampled by other threads are avoided. Multithreading is performed using OpenMP. We do not use the GPU to parallelize the locus sampler because sampling loci in a pseudo-random order while achieving high occupancy would be difficult without affecting the mixing properties of the Markov chain. Additionally, the sampling phase is relatively long and inherently sequential, which would be better run on the CPU that can run sequential code faster than a single thread on a GPU.
Meiosis samplerThe meiosis sampler () is somewhat analogous to the LanderGreen algorithm (), but whereas the latter performs the forwardbackward algorithm on the complete hidden Markov model (HMM), the meiosis sampler only does so in a limited fashion sampling a single meiosis on one individual in the pedigree conditional on all other meioses. Formally, we are aiming to compute:The forward component of the algorithm involves computing the cumulative probability for the meiosis indicator S i, l given loci up to and including locus l. The first locus does not depend on any previous loci:and at all proceeding loci:The probability of recombination PS i, l jS i, l1  is defined as: Q l1 S i, l1 1  l1   Q l1 1  S i, l1  l1 8 where l1 is the recombination fraction between locus l  1 and l. After the forward phase, the meiosis indicators are sampled in reverse order from locus L to 1, this time taking into account the likelihood of recombination between loci l and l  1. During a single iteration, the meiosis sampler is run on all meioses in a pseudo-random order.
Parallel computationAbove we described a sequential algorithm, but we note that the calculations of PY l jS , l  are independent under the assumption of linkage equilibrium. In addition, the amount of work this involves increases as a function of the number of loci considered jointly (in our experiments, this accounted for 490% of the total runtime of the meiosis sampler). Each calculation of PY l jS , l  involves the construction and evaluation of a founder allele graph (). Graph algorithms can be difficult to parallelize on a GPU, as the structure of the graph is dependent on the genotypes of different individuals in the pedigree and differences between individuals will lead to divergent thread execution paths, which are unsuited to current GPU architectures. For these reasons, in addition to the slow sequential sampling, the meiosis sampler will be run on the CPU with the parallel calculation of PY l jS , l  at each loci being equally divided between all processor cores using OpenMP.
CoordinationBoth samplers used by SWIFTLINK are run on the CPU, and LOD score calculations are performed on the GPU, if one is present. SWIFTLINK has a master thread that coordinates between the two hardware platforms. On the CPU, the master thread selects which sampler to run at each iteration and manages a thread pool to execute that sampler in parallel using the strategies described above, whereas on the GPU, it copies sampled descent graphs from host to device memory and executes the GPU LOD score kernel. SWIFTLINK is able to use both CPU and GPU concurrently because of how code is run on the GPU. GPU kernels are run asynchronously, that is, the call to run code on the GPU does not block until completion, but returns control to the caller immediately. A CUDA application, after launching a kernel, calls a separate wait function to be signalled when results are ready to be copied from the device to host RAM. LOD score calculations are performed on the GPU by copying the current descent graph produced by the Markov chain from host to device memory and then starting the LOD score kernel. As the LOD score kernel operates on a copy of the descent graph held in GPU memory, the CPU is free to run the Markov chain independently without interfering. When the next sample is produced, before we copy it over to the GPU, we must call wait to ensure that the previous LOD score calculations have completed.
RESULTSThe single-threaded variants of both locus and meiosis samplers have been shown previously to perform well on simulated datasets that can be analysed using exact linkage algorithms (). In this article, we focus on a real-world case study to gain an appreciation for the runtimes inherent in linkage studies that require MCMC. Our case study, shown in, is a highly consanguineous six-generation pedigree with EAST syndrome. EAST syndrome is an autosomal recessive monogenic disorder related to improper renal tubular salt handling where patients additionally present with the following symptoms: infantile-onset seizures, ataxia and sensorineural deafness. Genotyping with SNPs (single nucleotide polymorphisms) was performed on six members of the pedigree using Affymetrix GeneChip Human Mapping 10K SNP chips including all affected individuals and the parents of the three affected siblings (individuals 2328 in). In this article, we only consider chromosome 1, which included 780 SNPs (0.35 cM average spacing). The disease trait iscontaining 28 members over six generations assumed to have an allele frequency of 0.0001 and to have complete penetrance. We compare the runtime performance of SIMWALK (version 2.91), MORGAN (version 3.1, lm_linkage program) and SWIFTLINK in several configurations. SIMWALK was always run with default parameters and, as the runtime can be prohibitively slow for large numbers of markers, each dataset was run in windows of 50 markers (this size was chosen based on experience with past projects). Even with this advantage, SIMWALK still had to be run on a computer cluster, whereas MORGAN and SWIFTLINK were run on a single desktop PC. We report SIMWALK's total runtime assuming sequential execution. MORGAN, by default, is compiled at optimization level 0, causing unnecessary slowdown. To ensure a fair comparison, we recompiled MORGAN at optimization level 2, which we refer to as MORGAN Fast. Following the parameters used in a previous study (), both MORGAN and SWIFTLINK were run for a total of 100 000 iterations, comprising 10 000 iterations of burn-in and 90 000 iterations of simulation. Plocus sampler was set to 0:5. The Markov chain was initialized with 1000 runs of sequential imputation. During simulation, we scored every 10th sample and calculated LOD scores at 10 equidistant points between each consecutive pair of markers. SWIFTLINK and MORGAN were both run on the same computer running Ubuntu 12.04.1 LTS edition with Linux kernel 3.2.0-30 for 64-bit. The computer has an AMD Phenom II with four processor cores (clocked at 3.2 GHz) and 4 GB RAM (clocked at 1.6 GHz). GPU performance was tested with CUDA 5.0 (Release Candidate 1) on an Nvidia GTX 580. Each experiment was repeated 10 times, all results are averages over all runs.shows typical results for the region of interest for the EAST pedigree on chromosome 1 from each of the four parallel versions of SWIFTLINK tested. The most likely linked region found by all programs corresponded to the 840 kilobase region identified in the original study containing the KCNJ10 gene with similar maximum LOD scores for the region of interest ().shows the different performance characteristics of SIMWALK, MORGAN and SWIFTLINK. In addition to these results, we anecdotally ran SIMWALK once with all markers, which took $42 days, making SIMWALK by far the slowest. Even with the advantage of running in 50 marker windows, SIMWALK had the worst runtime of the three programs tested. All versions of SWIFTLINK were faster than both MORGAN and MORGAN Fast, with single-threaded SWIFTLINK showing a 1.6 speed-up over MORGAN Fast. This difference in runtime between single-threaded programs can probably be attributed to differences in the internal representation used for pedigree peeling; SWIFTLINK peels a genotype network, whereas MORGAN appears to peel an allele network. While allele networks ultimately scale better than genotype networks, in our experience, a majority of pedigrees will be smaller than is necessary for this to make a difference. At its fastest, using four CPU cores and GPU, SWIFTLINK is 13.6 faster than MORGAN Fast and 109.4 faster than SIMWALK analysing the EAST pedigree (). SWIFTLINK achieves a high degree of parallelism, as 53% of the program's total runtime was spent on serial tasks that could not be parallelized. Using all four cores of the CPU and the GPU, we achieve up to almost an order of magnitude (8.5) speed-up over the single-threaded implementation. Compared with four CPU cores, the addition of a GPU provides a 2.4 speed-up. We had expected higher performance, but the CPU is a bottleneck which does not run the Markov chain fast enough to keep up with the GPU. We expect the situation to improve with CPUs with more cores and with improvements to our CPU code (so far we have not used SIMD instructions). To demonstrate how underused the GPU is, the LOD scoring code in isolation performs 24 faster than a single-threaded CPU implementation.SwiftLink (CPUx1) SwiftLink (CPUx2) SwiftLink (CPUx4) SwiftLink (CPUx4+GPU). Results from all four tested versions of SWIFTLINK showing region of interest from chromosome 1 of the EAST pedigree
Runtime
Memory usageRAM usage was lowest in SIMWALK, though this is unrelated to the size of the input, as all memory must be statically allocated in Fortran '77. When SWIFTLINK is run without using the GPU, memory usage is twice that of MORGAN. Using a GPU in SWIFTLINK increases memory usage on the host PC 8-fold, partly due to converting C data structures into a more appropriate format for the GPU and partly due to GPU driver overhead. RAM usage on the GPU is high, but most modern GPUs feature at least 1 GB and we assume exclusive access to the device.
DISCUSSIONThe methods presented in this article produce almost an order of magnitude speed-up of MCMC linkage analysis compared with an optimized single-threaded implementation on fairly minimal hardware. Compared with existing MCMC linkage software, SWIFTLINK achieves up to two orders of magnitude speed-up when using four CPU cores and a GPU concurrently. We believe SWIFTLINK will be especially useful to researchers in, for example, clinical research settings, where access and/or experience with computer clusters is limited. In addition, SWIFTLINK has been specifically designed to fit into existing workflows by supporting the standard 'LINKAGE' file formats (ped, map and data files) as other popular mulitpoint linkage analysis programs, e.g. Allegro and Genehunter. A majority of linkage projects include only small-to-medium size pedigrees and can therefore be analysed using exact algorithms. Many large pedigrees can be successfully abbreviated to run using an exact algorithm; however, for cases where there are few genotyped individuals or in cases like EAST syndrome (), where one of the branches only contains a single genotyped individual, any abbreviation will dramatically reduce the power of the study. This is a clear niche where SWIFTLINK can be used to great effect. Unlike many other articles detailing GPU applications, we did not show results for both 32-and 64-bit. As performance on the GPU is affected so strongly by register usage and therefore occupancy, 32-bit code tends to run faster as pointers take up half the space and more blocks can be run concurrently. However, CPU code in general performs faster in 64-bit thanks to wider instructions. In the current version of SWIFTLINK, the GPU is underused because the CPU is a bottleneck, therefore it only makes sense for us to run in 64-bit mode. In the future, we will be aiming to improve SWIFTLINK by removing the bottlenecks from the slower execution of the Markov chain on the CPU. Additional speed-ups could be made by using SIMD instructions as well as multithreading or by offloading some of the excess work to the GPU. It is not clear how to balance the load dynamically between both platforms and whether the additional complexity is warranted for a speed-up that can be provided more simply with additional CPUs, e.g. with more cores locally or in a computer cluster.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
A.Medlar et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
SwiftLink at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
