Motivation: Eugene Myers in his string graph paper suggested that in a string graph or equivalently a unitig graph, any path spells a valid assembly. As a string/unitig graph also encodes every valid assembly of reads, such a graph, provided that it can be constructed correctly, is in fact a lossless representation of reads. In principle, every analysis based on whole-genome shotgun sequencing (WGS) data, such as SNP and insertion/deletion (INDEL) calling, can also be achieved with unitigs. Results: To explore the feasibility of using de novo assembly in the context of resequencing, we developed a de novo assembler, fermi, that assembles Illumina short reads into unitigs while preserving most of information of the input reads. SNPs and INDELs can be called by mapping the unitigs against a reference genome. By applying the method on 35-fold human resequencing data, we showed that in comparison to the standard pipeline, our approach yields similar accuracy for SNP calling and better results for INDEL calling. It has higher sensitivity than other de novo assembly based methods for variant calling. Our work suggests that variant calling with de novo assembly can be a beneficial complement to the standard variant calling pipeline for whole-genome resequencing. In the methodological aspects, we propose FMD-index for forwardâ€“ backward extension of DNA sequences, a fast algorithm for finding all super-maximal exact matches and one-pass construction of unitigs from an FMD-index.
INTRODUCTIONThe rapidly decreasing sequencing cost has enabled whole-genome shotgun (WGS) resequencing at an affordable price. Many software packages have been developed to call variants, including SNPs, short insertions and deletions (INDELs) and structural variations (SVs), from WGS data. At present, the standard approach to variant calling is to map raw sequence reads against a reference genome and then to detect differences from the reference. It is well established and has been proved to work from a single sample to thousands of samples (1000). Nonetheless, a fundamental flaw in this mapping-based approach is that mapping algorithms ignore the correlation between sequence reads. They are unable to take full advantage of data and may produce inconsistent outputs which complicate variant calling. This flaw has gradually attracted the attention of various research groups who subsequently proposed several methods to alleviate the effect, including postalignment filtering (), iterative mapping (), read realignment () and local assembly (). However, because these methods still rely on the initial mapping, it is difficult for them to identify and recover mismapped or unmapped reads due to highsequence divergence, long insertions, SVs, copy number changes or misassemblies of the reference genome. They have not solved the problem from the root. Another distinct approach to variant calling that fundamentally avoids the flaw of the mapping-based approach is to assemble sequence reads into contigs and to discover variants via assembly-toassemby alignment. It was probably more widely used in the era of capillary sequencing. The assembly based method became less used since 2008 due to the great difficulties in assembling 25 bp reads, but with longer paired-end reads and improved methodology, de novo assembly is reborn as the preferred choice for variant discovery between small genomes. For variant discovery between human genomes, however, the assembly based approach has not attracted much attention. Assembling a human genome is far more challenging than assembling a bacterial genome, firstly due to the sheer size of the genome, secondly to the rich repeats and thirdly due to the diploidy of the human genome. Many heuristics effective for assembling small genomes are not directly applicable to the human genome assembly. As a result, only a few de novo assemblers have been applied on human short-read data. Among them, ABySS (), SOAPdenovo () and SGA (), as of now, do not explicitly output heterozygotes. Although in theory it is possible to recover heterozygotes from their intermediate output, it may be difficult in practice as the assemblers may not distinguish heterozygotes from sequencing errors. Cortex () is specifically designed for retaining heterozygous variants in an assembly, but it may be missing heterozygotes. ALLPATHS-LG () also paid particular attention to keep heterozygotes, but it still has a relatively low sensitivity. In addition, ALLPATHS-LG only works with reads from libraries with distinct insert size distributions and prefers read pairs with mean insert size below three times of the read length, whereas many resequencing projects do not meet these requirements and thus ALLPATHS-LG may not be applied or work to the best performance. Even if we also include de novo assemblers developed for capillary sequence reads, the version of the Celera assembler used for assembling the HuRef genome () is the only one that retains heterozygotes while capable of assembling a mammalian genome. At last, one may think to map sequence reads
Variant calling from de novo assemblyback to the assembled contigs to recover heterozygous events, but this procedure will be affected by the same flaw of read mapping. To the best of our knowledge, no existing de novo assemblers are able to achieve the sensitivity of the standard mapping-based approach for a diploid mammalian genome. In this article, we will show that the assembly based variant calling can achieve an SNP accuracy close to the standard mapping approach and have particular strength in INDEL calling, confirming previous studies (). In addition, the de novo assembly algorithm, fermi, developed for this practice is also a capable assembler for human assembly.
METHODSThe methods section is organized as follows. We first review the history of de novo assembly in the theoretical aspects, which leads to the rationale behind fermi: to use unitigs as a lossless representation of reads. We then summarize the notations used in the article and introduce bidirectional FMindex for DNA sequences. We will present several algorithms for assembling using the bidirectional FM-index. The key algorithm is based on previous works (), but we need to adapt it to our new index. We also remove the recursion in the original algorithm. Finally we will discuss practical concerns in implementation.
Theoretical background
A history of the OLC paradigmComputer assisted sequence assembly can be dated back to the late 1970s ().formulated the DNA assembling problem as finding the shortest string (the assembly) such that each sequence read can be mapped to the assembly within a required error rate. To solve the problem, they proposed a three-step procedure, which is essentially the overlap-layout-consensus (OLC) approach.pointed out that reducing DNA assembly to a shortest string problem is flawed in the presence of repeat. He further proposed the concept of overlap graph, where a vertex corresponds to a read and a bidirectional edge to an overlap. Naively, the DNA assembling problem can be cast as finding a path in the overlap graph such that each vertex/read is visited exactly once (though edge/overlap caused by repeats are not required to be traversed), equivalent to a Hamilton path problem which is known to be NPcomplete. This has led many to believe that the OLC approach is theoretically crippled. However, it is worth pointing out that although the assembly problem can be reduced to a Hamilton path problem, it can be reduced to other problems as well and in practice almost no assemblers try to solve a Hamilton path problem. We note that a fundamental difference between a generic graph and an overlap graph is the latter can be transitively reduced while retaining the read relationship. More formally, if v 1  v 2 , v 2  v 3 and v 1  v 3 are all present, edge v 1  v 3 is said to be reducible. When we removed all the contained reads and reducible edges, a procedure called transitive reduction, the resulting graph is still a loyal representation of the overlap graph (), but the path corresponding to the assembly is not a Hamilton path any more because reads from repetitive regions need to be traversed multiple times. In a transitively reduced graph, if there exists v 1  v 2 with the out-degree of v 1 and in-degree of v 2 both equal to 1, we are able to merge v 1 and v 2 into one vertex without altering the topology of the graph. After we performed all possible merges, we get a unitig graph in which each vertex corresponds to a unitig, representing a maximal linear sequence that can be resolved by reads. Multiple copies of a repeat may be collapsed to a single unitig. The concept of unitig helps to greatly simplify an assembly graph. It has played a central role in the Celera assembler (). Finding the optimal tour in a unitig graph is still NP-hard (), but such a formulation may not be useful in practice as we can rarely assemble the entire genome into one string. A more practical solution is to compute a traversal count for each edge by solving a minimum cost network flow problem () and to drop edges with zero count as false overlaps. In the resulting graph, each unambiguous path can be considered to spell a contig. Computing traversal counts in a transitively reduced graph can be conducted in small subgraphs separated by some unambiguous edges. The overall time complexity is not much worse than linearthe worst case almost never happens globally. However, deriving an overlap graph takes O(N 2 ) time, where N is the number of reads, and transitive reduction takes at least O(E) time, where E is the number of edges which is usually much larger than N. This still makes an OLC-based approach less favorable in short-read assembly where N can be of the order of 10 9. A breakthrough achieved by Simpson and Durbin (2010) finally solved this last remaining problem at least when we only consider exact overlaps. These authors developed an O(N ) algorithm to find all the irreducible edges, effectively replacing the overlapping and transitive reduction phases. In summary, in the OLC paradigm, contig sequences can be constructed in a time roughly linear in the total length of reads, though deriving a singleassembled sequence is NP-hard in theory.
De Bruijn graph and read coherenceThe de Bruijn graph is an alternative graph representation of sequence reads (). It can be trivially constructed with a simple linear-time algorithm and finding the optimal tour has polynomial-time solutions. These make the de Bruijn graph approach very attractive for assembling many short reads. However, de Bruijn is 'lossy'. From a theoretical point view, a de Bruijn graph is equivalent to an overlap graph built by splitting a long read into overlap k-mers and requiring (k 1)-mer exact overlaps between nonredundant k-mers. Such a graph does not have transitive edges. Because long reads all effectively work as k-bp reads in a de Bruijn graph, longrange information is lost. As a result, a path in the graph may be invalidated by reads. In contrast, in a unitig graph or equivalently a string graph each path models a valid assembly from input reads.called this property of path consistency as read coherence. Losing long-range information in reads, a de Bruijn graph by itself has reduced power to resolve short repeats. This flaw is usually amended by solving a Eulerian superpath problem () whereby we map reads back to the graph and bisect repeats shorter than the reads, a procedure some also called as read threading. Many de Buijn graph-based assemblers essentially take this strategy (), though they may use different terminologies. With read threading, it is possible to transform a de Bruijn graph to a coherent graph, but finding the optimal solution is known to be NP-hard () and may be complex to implement given rich repeat structures.
Concluding remarkWe noted that we only focused on the theoretical aspects of de novo assembly. In practice, many assemblers derived the final assembly by applying heuristics on the simplified graph instead of solving a network flow problem or a Eulerian problem. Furthermore, correcting errors, utilizing read pairs and controlling memory usage all pose challenges to large-scale de novo assembly. Many practical problems are not solved perfectly. De novo assembly is still a field under active development.
RationaleBeing coherent, a perfectly constructed unitig graph annotated with perunitig read counts in fact encapsulates all the information of reads and encodes no information invalidated by reads. In this sense, any unitig-based analysis has an equivalent read-based analysis, and vice versa. This article just uses this property to explore the applications for which we usually rely on reads.
H.Li
Strings and FM-index
Strings with multiple sentinels Let={$,A,C,G,T,N} be the alphabet of DNA sequences with a predefined lexicographical order $ < A < C < G < T < N, where 'N' represents an ambiguous base and '$' is a sentinel that marks the end of a string. An element in is called a symbol and a sequence of symbols is called a string. Given a string T , let |T | be the length of the string, T, i = 0,...,|T |1, be the i-th symbol in the string, T [i,j], 0  i  j < |T |, be a substring and T i = T [i,|T |1] be a suffix of T (). Following the definition by Siren (2009), we define a string terminated with '$' as a text. A text may have multiple sentinels. In a text T , if T [i]=$ and T=$, we mandate T [i] < T [j] if and only if i < j. Thus when we compare two suffixes of T , we do not need to compare beyond a sentinel because each sentinel has a different lexicographical rank. For two strings P and W , let P @BULLETW be their string concatenation. We may sometimes write P @BULLETW as PW if it is unambiguous in the context. Given an ordered set of texts, we call their ordered string concatenation as a collection, which is also a text. For example, suppose we have two reads. The first is ACG and the second is GTG. The collection of the two reads is T = ACG$GTG$. Suffix T 2 < T 6 because the first sentinel is lexicographically smaller than the second. For convenience, we assign an integer from 0 to 5 to '$', 'A', 'C', 'G', 'T' and 'N', respectively. We may use both the integer and the letter representations throughout the article. In addition, given a symbol a, we define a as the WatsonCrick complement of a. We regard the complement of '$' and 'N' is identical to itself.
FM-index The suffix array Sof text T is a permutation of integers between 0 and |T |1, where S(i), 0  i < |T |, is the position of the i-th smallest suffix of T. Given a string P, the suffix array interval I l (P),I u (P)] of P in T is defined as I l (P) = min{k : P is the prefix of T S(k) } I u (P) = max{k : P is the prefix ofFor convenience, we also define I s (P) = I u (P)I l (P)+1 as the size of the interval. The BurrowsWheeler Transform (), or BWT, of T is a permutation of symbols in T. The BWT string B is computed as B=T [S(i)1] for S(i) > 0 and B=$ otherwise. Given a text T , also define the accumulative count array C(a) as the number of symbols in T that are lexicographically smaller than a, and the occurrence array O(a,i) as the occurrence of symbols a in B. FM-index () is a compressed representation of the BWT B, the occurrence array O(a,i) and the suffix array S(i). The keyT String: T = a 0 a 1 ...a n1 with a n1 = $ |T | Length of T including sentinels: |T |=n TThe i-th symbol in string T :and I l (aP)  I u (aP) if and only if aP is a substring of T. We note that these two equations are different from the ones in our previous paper () in that C(a) and O(a,i) defined here include the sentinels, but the two arrays in the previous paper exclude them. Given a collection T = Q 0 Q 1 ...Q n1 , we can retrieve sequence Q i in linear time with Algorithm 1 (). The second return value is the rank of Q i which equals |{Q j : Q j < Q i }|.
FMD-indexGiven DNA texts R 0 ,...,R n1 , define
..R n1 R n1 as the bidirectional collectionof the texts. We call the FM-index of T as the FMD-index of R 0 ,...,R n1 and define the bi-interval of a string P as. We will show how to compute the bi-interval of aP and Pa when we know the bi-interval of P. We note that when we know the bi-interval of P, I l (aP) and I s (aP) can be readily computed with Equation (1).] is a sub-interval of] because P is a prefix of aP = P @BULLETa. Due to the innate symmetry of T , I s (cP) = I s (cP) for all c  with c I s (cP) = I s (P) = I s (P). We can compute I s (cP) for all c  with Equation (1), use these interval sizes to divide. This completes the computation of the bi-interval of aP (Algorithm 2). Furthermore, when we backward extend P, we actually forward extend P. Conversely, backward extension of P yields forward extension of P (). An FMD-index is bidirectional. In comparison to the bidirectional BWT () which uses two FM-indices, the FMD-index builds both forward and reverse strand DNA sequences in one index. Although the FMD-index is not applicable to generic texts, it is conceptually more consistent with double-strand DNA and improves the speed of exact matching as we only need to search against one index. For example, BWA-SW () gets a 80% speedup when we adopt the FMD-index as the data structure.
Unitig construction
Labeling reads and overlapsGiven a bidirectional collection, fermi labels the i-th input read R i with an ordered integer pair, where k is the rank of R i and l the rank of R i. The paircan be computed by GetSeq(2i) and GetSeq(2i +1), respectively. Obviously, if read R i is labeled by, R i should be labeled by, with the two integer swapped. For two reads labeled byand, if the tail (3 end) of readoverlaps the head (5 end) of, we use an unordered integer pair l,k to label the overlap. Such is a tail-to-head overlap. Similarly, we usel ,k for a head-to-tail overlap, l,l for tail-to-tail and k,k for a headto-head overlap. The four types of overlaps correspond to the four types of bidirectional edges in the bidirectional overlap graph ().
Finding irreducible overlapsFinding irreducible overlaps plays a central role in fermi as well as in SGA. Given its importance, we present a restructured version of this algorithm (SD10; Simpson and Durbin 2010) using our notations (Algorithm 4). In Algorithm 4, Line 1 computes the bi-interval of a single symbol. The loop at Line 2 uses backward extensions to find all the reads overlapping with the input string P. The loop at Line 3 uses forward extensions base by base to exclude reducible overlaps found at the previous step. W is this loop keeps the common substring of reads overlapping P extended from the 3 end of P. If in an iteration we find the sentinel of a read R (Line 5), then all the reads sharing the same W with R must overlap with both R and P and therefore their overlaps with P are reducible. In this case, no further forward extensions are necessary (Lines 4 and 6). Similar to the original algorithm, Algorithm 4 requires that there are no contained reads. Fermi actually implements a modified version that detects reads containment on the fly, but we think the algorithm is a little overcomplicated. It is probably easier to filter contained reads first and then run Algorithm 4, as SGA does.
Unitig constructionUnitig construction is a process of unambiguous merge of overlapped reads. Ifandhave an irreducible overlap l,k and can be unambiguously merged, we label the merged sequence with; the similar can be applied to other three types of overlaps. With this simple labeling procedure, we are able to fully keep track of the graph topology during the unitig construction and without staging the graph in RAM. This procedure can also be easily multi-threaded.
Finding the SMEMsAn FMD-index can be used to find supermaximal exact matches (SMEMs) between a reference and a query sequence. Formally, a maximal exact match (MEM) is a an exact match that cannot be extended in either direction ofis not in Curr then Append (,Wa) to Curr;
Swap Curr and Prev return IrrOvlpthe match. An SMEM is a MEM that is not contained in other MEMs on the query sequence. Fermi uses SMEMs to map reads back to the unitigs. Algorithm 5 describes the details. Basically, we use forwardbackward extension to extend an exact match and detect the boundary of a maximal match by tracking the change of interval sizes. Fermi implements a variant of Algorithm 5. It finds full-length read matches and can optionally exclude matches identical to the query sequence.
Other implementation details
Constructing FM-indexTo compute suffix arrays for strings with multiple sentinels, we modified an optimized implementation of the SA-IS algorithm () by Yuta Mori. We used the established algorithm to merge BWTs of subsets of reads (). The BWT string is run-length encoded with the length in the delta encoding ().
Error correctionFermi corrects potential sequencing errors using an algorithm similar to solving the spectrum alignment problem (), correcting bases in underrepresented k-mers. It also shares similarity to HiTEC (). Nonetheless, the fermi's algorithm differs in that it is quality aware and does not rely on a user defined threshold on the k-mer occurrences.
H.LiAlgorithm 5: Finding SMEMs Input: String P and start position i 0 ; P=0 Output: Set of bi-intervals of SMEMs overlapping i 0 Function SuperMEM1(P,i 0 ) begin Initialize Curr, Prev and Match as empty arrays;Swap array Curr and Prev;
if Curr is empty then break Swap Curr and Prev; return MatchFermi corrects errors in two phases. In the first phase, it collects all 23 mer occurring 3 or more times using a top-down traversal over the trie represented by the FMD-index. For each such 23 mer, fermi counts the occurrences of the next (i.e. the 24-th) base and stores the information in a hash table with the 23 mer being the key. In the second phase, fermi processes each read by using the 23 mer hash table to correct errors by minimizing a heuristic cost function of base quality and the occurrences of the 24-th base. Roughly speaking, fermi tries to correct a low-quality base if by looking up its 23 mer prefix we know the base is different from an overwhelmingly frequent 24-th base. This algorithm can be adapted to correct INDEL sequencing errors in principle, but this has not been done. More works are needed to perform minimization efficiently.
Simplifying complex bubblesA bubble is a directed acyclic subgraph with a single source and a single sink having at least two paths between the source and the sink. A closed bubble is a bubble with no incomming edges from or outgoing edges to other parts of the entire graph, except at the source and the sink vertices. A closed bubble is simple if there are exactly two paths between the source and the sink; otherwise it is complex. In de novo assembly, a bubble is frequently caused by sequencing errors or heterozygotes. Most short-read assemblers uses a modified Dijkstra's algorithm to pop bubbles progressively. Such an algorithm works fine for haploid genomes, but it is not straightforward to distinguish heterozygotes from errors when the bubble is complex. Fermi uses a different algorithm. It effectively performs topological sorting from the end of a vertex while keeping track of the top two paths containing most reads. A bubble is detected when every path ends at a single vertex. It then drops vertices not on the top two paths and thus turns a complex bubble to a simple one.
Using the paired-end informationGiven paired-end reads with short-insert sizes, fermi maps reads back to the unitigs with Algorithm 5. If two unitigs are linked by at least five read pairs, fermi will locally assemble the ends of unitigs together with unpaired reads pointing to the gap under a relax setting. Fermi tries to align the ends of unitigs using the SmithWaterman algorithm, which may reveal imperfect overlaps caused by sequencing errors or heterozygotes. Fermi also uses paired-end reads to break contigs at regions without bridging read pairs. This helps to reduce misassemblies during the unitig construction.
RESULTSWe evaluated fermi on 101 bp paired-end reads from NA12878 (). The total coverage of the original data is 70-fold, but we only used half of them. We assembled the 35-fold reads with fermi on a machine with 12 CPUs and 96 GB memory in 5 days. The peak memory usage is 92 GB. We obtained unitigs of N50 1022 bp, totaling 3.83 Gb. After collapsing most heterozygotes and closing gaps with paired-end reads, we got longer contigs (). Unitigs are short and redundant mainly because they break at heterozygotes. For SNP and INDEL calling, we aligned unitigs to the reference genome using BWA-SW () with command line options '-b9-q16-r1-w500'. We called SNPs with the SAMtools caller and called INDELs by directly counting INDELs from the pileup output. We did not run a standard INDEL caller as short-read INDEL callers do not work well with long contig sequences.
Performance on de novo assemblyWe obtained the HuRef capillary read assembly () and the ALLPATHS-LG NA12878 contigs (AC:AEKP01000000) from NCBI, the SGA scaffolds from http://bit.ly/jts12878 () and the ABySS assembly provided by Shaun Jackman (personal communication). For both SGA and ABySS scaffolds, we split at any ambiguous bases to get contigs; for the HuRef assembly, we split at contiguous 'N' longer than 20 bp. The ABySS, fermi and SGA assemblies are derived from essentially the same input reads. ALLPATH-LG uses a superset of reads at 100-fold coverage, including reads from multiple long-insert libraries. From Table 2, we can see that the HuRef assembly has much better contiguity than short-read assemblies. It appears to yield more alignment break points, some of which may be caused by true SVs not easily detectable with short reads. The quality of short-read assemblies varies in terms of contiguity, misassembly rate and redundancy between contigs, but overall, they are largely comparable to each other.
Performance on SNP and INDEL callingOne of the key motivations of fermi is to explore the power of de novo assembly in calling short variants. We collected several SNP and INDEL call sets () and compared the performance of fermi (Tables 4 and 5).Contigs over 150 bp in length are aligned to the human reference genome GRCh37 with BWA-SW using option '-b33-q50-r17'. A type-1 break point is detected if a contig is split during alignment and mapped to two distict locations, and at each location the alignment is longer than 500 bp and the mapping quality is no less than 10. Type-2 break points exclude type-1 break points which can be patched with gaps no longer than 500 bp.Ts/tv is the transition-to-transversion ratio of SNPs. DN50 is calculated as follows. The reference genome is masked according to the align-ability mask (http://bit.ly/snpable) and segmented into intervals at heterozygous SNPs. DN50 is computed such as 50% of unique positions in the genome are in intervals longer than DN50. DN2 is calculated similarly and D2/DN50 is the ratio of DN2 and DN50. DN50 measures the sensitivity; the smaller the better. DN2/DN50 measures the precision of heterozygous SNPs; the higher the better. For SNP calling (), fermi misses 3% of SNPs called in SS, but finds more additional ones. Manual examination reveals that the additional calls are mainly caused by two factors. Firstly, in the single-end mode, BWA-SW is very conservative. It may consistently give a correct alignment a low-mapping quality which are all downweighted by samtools. Fermi is able to assemble such reads into longer sequences which increase the power of BWA-SW.INDELs that start within a homopolymer run longer than 6 bp are excluded in all call sets. An INDEL in call set R (indexed by row) is said to be found in call set C (indexed by column) if there exists an INDEL in C such that the left-aligned starting positions of the two INDELs are within 20 bp from each other. An INDEL in R is considered to be found in 'ALL' if it is found in one of the other INDEL sets in the table, plus the AC call set. In the table, a number on the diagonal equals |R|, the number of INDEL calls in the call set. The fraction equals |{g  R : g is found in C}|/|R|.
Variant calling from de novo assemblySecondly, in the fermi alignment, some regions may be mapped with a high-mismatching rate. These may be due to small-scale misassemblies in fermi unitigs or in the reference assembly, or copynumber variations. It is possible that these clustered SNPs contain more errors. Such errors may lead to reduced ts/tv, but tend not to break long homozygous blocks due to very recent coalescences. That is why FC has a good DN2/DN50 ratio, which measures how often false heterozygotes arise from a long homozygous block.shows the comparison between different INDEL call sets. We excluded INDELs around long homopolymer runs in all call sets because INDEL sequencing errors tend to occur around long homopolymer runs and their error profile is still unclear (the 1000 Genomes Project Analysis group, personal communication). In addition, we have excluded the SS INDEL call set which is nearly contained in BS due to the use of the same INDEL caller. For the call sets in, MD and CG are relatively small due to the use of very short reads. CV uses 26X 100 bp reads. It is a small call set due to the high-false negative rate of the calling method (). The fermi call set FC is slightly smaller than BS, but it has larger overlap with other call sets than BS, and more FC calls are confirmed by others. One explanation to the lower overlapping ratio between BS and ALL is that BS is the only call set that uses 101 bp paired-end information, which gives it higher power for INDELs not detectable with single-end or very short reads. Nonetheless, purely based on, fermi appears to have higher overall accuracy. Even with all short-read call sets combined, as many as 14% of double-hit INDELs called byare missed. We manually checked 30 missing INDELs in an alignment viewer. For half of the cases, the short-read alignment and fermi alignment strongly suggest no variations, and for all these cases, the HuRef sequences are identical to GRCh37. In addition, there are a few cases called from regions under clear copy-number changes. In all, we believe INDELs called byonly may have higherror rate. With short reads, we can recover most of short INDELs found by capillary sequencing.
DISCUSSIONSIn this article, we derived FMD-index by storing both forward and reverse complement DNA sequences in FM-index. This simple modification enables faster forwardbackward search than
H.Libi-directional BWT () and makes FMD-index a more natural representation of DNA sequences. Based on FMD-index, we developed a new de novo assembler, fermi, which achieves similar quality to other mainstream assemblers. We demonstrated that it is possible to call SNPs and short INDELs by aligning assembled unitigs to the reference genome. This approach has similar SNP accuracy to the standard mappingbased SNP calling and arguably outperforms the existing methods on INDEL calling in terms of both sensitivity and precision. Assembly based variant calling is a practical and beneficial complement to mapping-based calling. In the course of evaluating INDEL accuracy, we found that outside long homopolymer regions, INDEL call sets do not often contain false positives, but they may have high-false negative rate, which leads to the apparent small overlap between call sets (). As a theoretical remark, we note that with read counts kept, unitigs are a lossless but reduced representation of sequence reads. They are 'reduced' in that individual reads are lost; they are 'lossless' in that all the information in reads, such as small variants, copy numbers and structural changes are fully preserved in unitigs, as long as they are constructed correctly. For single-end reads, it is theoretically possible to 'compress' reads to unitigs, which are largely nonredundant and much smaller in size. Accurately and efficiently constructing unitigs might provide an interesting alternative to data storage and downstream analyses in future, though practical challenges, such as the high-computational cost and the lack of accuracy of unitigs, remain at present.
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
