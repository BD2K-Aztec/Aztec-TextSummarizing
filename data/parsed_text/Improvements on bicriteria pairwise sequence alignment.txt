Motivation: In this article, we consider the bicriteria pairwise sequence alignment problem and propose extensions of dynamic programming algorithms for several problem variants with a novel pruning technique that efficiently reduces the number of states to be processed. Moreover, we present a method for the construction of phylo-genetic trees based on this bicriteria framework. Two exemplary cases are discussed. Results: Numerical results on a real dataset show that this approach is very fast in practice. The pruning technique saves up to 90% in memory usage and 80% in CPU time. Based on this method, phylo-genetic trees are constructed from real-life data. In addition of providing complementary information, some of these trees match those obtained by the Maximum Likelihood method. Availability and implementation: Source code is freely available
INTRODUCTIONRecently, there has been a growing interest on the multi-criteria formulation of optimization problems that arise in computational biology (see an extensive review in). However, exact solution approaches for most of these new formulations have not been thoroughly investigated, with the exception of the work offor bicriteria pairwise sequence alignment. For an alignment ' of sequences A : a 1 ,. .. , a n1  and B : b 1 ,. .. , b n2 , we denote by s' the substitution score of alignment ' according to a substitution matrix M, and by d' and g', the number of indels and gaps (maximal consecutive run of indels) of '. The two following score vector functions are considered: VSD' : s',  d'   VSG' : s',  g'   Two bicriteria problems that consist of finding the alignments that are 'maximal' with respect to the score vector functions above are as follows:where  denotes the set of all feasible alignments. The image of set  in the score function space is called feasible score set. To give a proper meaning to the operator vmax, we introduce the following dominance relation between score vectors in Problem (VSDP): Given two alignments ' and ' 0 , VSD'4VSD' 0  (' dominates ' 0 ) if and only if it holds that s' ! s' 0 , d' d' 0  and VSD' 6  VSD' 0 . An alignment ' is Pareto optimal if there exists no other alignment '  such that VSD'  4VSD'. The set of all Pareto optimal alignments is called Pareto optimal alignment set. The image of a Pareto optimal alignment in the score function space is a non-dominated score, and the set of all non-dominated scores is called non-dominated score set. The dominance relation and the above notation also apply to Problem (VSGP) with the necessary changes. Computing the Pareto optimal alignment set can be an intractable task: consider the sequences A : G n and B : TGT 2n and the substitution matrix Mi, i : 1 and Mi, j : 0, i 6  j; then, there exist 2n nPareto optimal alignments that match G n in both sequences, as there exists no other alignment with larger substitution score and lesser number of indels (3n  1 indels). The aforementioned example also applies to the number of gaps (n  1 gaps). However, the size of the non-dominated score set is bounded by min', n 1  n 2  2', where ' is the size of longest common subsequence of A and B (). Interesting properties of this formulation in relation to parametric sequence alignment (see) are discussed in: an optimal alignment for the parametric score function with positive parameters is a Pareto optimal alignment. However, there may exist Pareto optimal alignments that are not optimal for any parameter setting. These alignments, and corresponding scores, are called supported and non-supported, respectively (). From a geometrical point of view, supported scores are those that lie in the convex-hull boundary of the non-dominated score set. *To whom correspondence should be addressed. Furthermore, it is common to distinguish between extreme and non-extreme supported scores (). A score is extreme supported if it is a vertex of the convex hull boundary of the feasible score set; otherwise it is a non-extreme supported score. Although it is relatively easy to find all extreme supported scores (), it is more challenging to find all those that are non-extreme. Finding the whole non-dominated score set would allow identifying both extreme and non-extreme supported non-dominated scores, as well as non-supported nondominated scores. Therefore, multicriteria sequence alignment brings advantages to the practitioner, as it allows to get rid of parameters and to explore a tractable set of alignments that are not reachable by any other methods. However, to the best of our knowledge, few work has been done on multi-criteria sequence alignment (). In this article, we propose extensions of dynamic programming algorithms for several bicriteria problem variants with a pruning technique that is based on the comparison of lower and upper bounds, as performed in branch-and-bound procedures. Moreover, we describe an experimental analysis on a real dataset and discuss the use of bicriteria pairwise sequence alignment in the context of phylogenetic tree construction.
ALGORITHMSIn the following sections, we describe dynamic programming techniques for solving several formulations of the bicriteria pairwise sequence alignment as well as a novel pruning technique that reduces the number of states in practice.
Multicriteria dynamic programmingFor the sake of clarity, we introduce the dynamic programming algorithm for Problem (VSDP) as proposed inbut with a different formulation. For a given alignment ', we define a state p : VSD'. To compute the non-dominated scores, a matrix P is constructed where each entry Pi, j, for i, j 2 f1,. .. , n 1 g  f1,. .. , n 2 g, will store the set of states corresponding to the Pareto optimal alignments of subsequences a 1 ,. .. , a i  and b 1 ,. .. , b j . The recurrence for Pi, j is as follows:Pi, j : vmax p  i, j, 0 : p 2 Pi  1, j  1   p  0,  1 : p 2 Pi  1, j   p  0,  1 : p 2 Pi, j  1where i, j is the substitution score for a i , b j . The bases cases are P0, 0 : f0, 0g, Pi, 0 : f0,  ig, P0, j : f0,  jg, for 1 i n 1 and 1 j n 2. Operator vmax keeps only the non-dominated states at entry Pi, j.suggested the use of a log-linear algorithm for this operation. However, this can be performed in linear time by extending the MERGE algorithm in Beier and VockingVocking (2011) for three sorted lists of non-dominated scores. The overall time and space-complexity of the algorithm above is On 1  n 2  n 1  n 2 . The dynamic programming algorithm for Problem (VSGP) is briefly discussed in. We give a more detailed explanation of this approach, which extends the algorithm in Gusfield (1997, pp. 244). For a given alignment ' : A 0 , B 0 , we define a state q : VSG'. For computing the set of non-dominated scores, we keep four dynamic programming matrices: Q, R, S and T. For a given i, j 2 f1,. .. , n 1 g  f1,. .. , n 2 g, entry Ri, j, Si, j and Ti, j will store the set of states corresponding to Pareto optimal alignments of subsequences a 1 ,. .. , a i  and b 1 ,. .. , b j  that end with a i , b j ,  0  0 , b j  and a i , 0  0 , respectively, where 0  0 is a gap character. The entry Qi, j will store the states corresponding to Pareto optimal alignments of subsequences a 1 ,. .. , a i  and b 1 ,. .. , b j . Then, the recursion is as follows:Qi, j : vmaxRi, j Si, j Ti, j 8 < :Ri, j : q  i, j, 0 : q 2 Qi  1, j  1   Si, j : vmax Si, j  1 q  0,  1 :The base cases of the matrices are as follows: Q0, 0 : f0, 0g, Qi, 0 : Si, 0 : Q0, j : T0, j : f0,  1g, for 1 i n 1 and 1 j n 2. Operation vmax takes also linear amount of time by using the same technique as for Problem (VSDP). As the number of gaps is bounded from above by the number of indels in an alignment, the time and space-complexity is also On 1  n 2  n 1  n 2 .
Bounds in problem (VSDP)We describe a pruning technique for the dynamic programming algorithm for Problem (VSDP) that is able to reduce the number of states by comparing their upper bounds with a pre-computed lower bound set. Upper and lower bounds have also been used within scalarized score functions ().
Lower bound setFor the definition of lower bounds on the non-dominated score set for Problem (VSDP), we introduce the notions of lexicographic and scalarized score functions. We say that a vector x 2 R 2 is lexicographically larger than or equal to a vector y 2 R 2 x4 lex y if x 1 4y 1 or if x 1  y 1 and x 2 ! y 2. In this article, we consider two problems that consist of finding an alignment that is lexicographic maximal (lexmax) according to a given order of priority on the optimization of the two score function components:The order of the function components indicates the priority that is considered among the criteria. Let ' s and ' d be the lexicographic maximal alignments for Problems (LexSDP) and (LexDSP), respectively. Let MAX : VSD' s  and MIN : VSD' d . By the definition of optimality for Problem (VSDP), it holds that MAX and MIN belong to the non-dominated score set (). Moreover, they indicate that there cannot exist a Pareto optimal alignment with larger (smaller) substitution score value and more (less) indels than given by the components of MAX (MIN). Hence, the two score vectors give a bound on the possible ranges of the non-dominated score set. In fact, if MAX  MIN, then the non-dominated score set contains only a single element and no further computation is required. Another lower bound is given by the solution to a scalarized version of the bicriteria alignment problem. We consider the weighted sum scalarization approach: WSD' : w s  s'  w d  d' where w s and w d are positive real weighting coefficients. The goal is to find the alignment that maximizes the scalarized score function as follows:Other scalarized functions are also possible (). In the particular case of the weighted sum function, the alignment that is optimal to Problem (WSDP) is also Pareto optimal to Problem (VSDP), although the opposite does not hold in general (). Let ' w denote the optimal alignment for Problem (WSDP) for a given w s and w d and let MID : VSD' w . It is also important to highlight that the scalarized problem can be solved several times for different coefficients to get a tighter lower bound set. The score vectors MAX, MID and MIN allow to define a lower bound set on the non-dominated score set of Problem (VSDP). Let R denote the region R  r 2 R  R  0 : b4r, b 2 MAX, MID, MIN f g   :illustrates the location of MAX, MID and MIN and definition of R (shaded area). There may exist further Pareto optimal alignments whose score vectors are located in the complement of R. However, any alignment whose score vector is in the interior of R cannot be Pareto optimal, as it would be dominated by an alignment with a score vector equals to MIN, MID or MAX. The computation of the three score vectors can be performed with the algorithm of Needleman and Wunsch (1970) by keeping the components separately in the dynamic programming matrix and choosing the state at each entry that maximizes the scalarized score function WSD, for the case of MID, or according to the lexicographic ordering for the case of MAX and MIN, respectively. Therefore, the three score vectors can be found in On 1  n 2 -time. In the following, we only introduce the recurrence relation required for computing the lexicographic maximal alignment for Problem (LexSDP), which gives the score vector MAX. We consider a dynamic programming matrix L, where the entry Li, j, for i, j 2 f1,. .. , n 1 g  f1,. .. , n 2 g, will store the state corresponding to the lexicographic maximal alignment of subsequences a 1 ,. .. , a i  and b 1 ,. .. , b j . The elements of matrix L are calculated recursively by Li, j : lexmax Li  1, j  1  i, j, 0 Li, j  1  0,  1 Li  1, j  0,  1 8 < :with basis cases L0, 0 : 0, 0, Li, 0 : 0,  i and L[0, j]:  0,  j, for 1 i n 1 and 1 j n 2. The operator lexmax keeps only the lexicographic maximum of the three states in the recursive step.
Upper boundThe pruning technique proposed in this article follows a branch-and-bound principle. Let t : s,  d be a state at entry Pi, j. Let u be the maximum substitution score and v the minimum number of indels that can be achieved from entry Pi, j to entry Pn 1 , n 2 . Then, for either 1 i5n 1 or 1 j5n 2 , we consider the following upper bound for t: ubt : s  u,  d  v. If ubt is located in the interior of R, then state t will not lead to any state that corresponds to a score vector of a Pareto optimal alignment and can be discarded from entry Pi, j. The value of u can be computed with the algorithm ofwith a null indel penalty for the sequences a i1 ,. .. , a n1  and b j1 ,. .. , b n2 . This can be easily obtained for every entry in matrix P in a pre-processing step. The minimum number of indels v is computed by the absolute difference between the sizes of two subsequencesTherefore, ubs : s  u,  d  v is a valid upper bound for state t. This bound may not correspond to a feasible alignment. Matrix L as well as the algorithm of Needleman and Wunsch (1970) can be computed in a pre-processing phase in On 1  n 2 time. Hence, the upper bound at each matrix entry can be computed in a constant amount of time during the main phase of the algorithm.
Bounds in problem (VSGP)For Problem (VSGP), the computation of lower and upper bounds follow the same reasoning as for Problem (VSDP). In the following, we will only give a brief explanation and highlight the main differences.
Lower bound setThe lexicographic and scalarized problems described in Section 2.2.1 can also be formalized in terms of gaps. In this case, MAX and MIN correspond to the score vectors of the Pareto optimal alignments that maximize the substitution score and minimize the number of gaps, respectively. Also, MID corresponds to the score vector of the Pareto optimalalignment that maximizes a scalarized score function by taking into account the number of gaps (we use w g instead of w d ). Score vectors MAX and MID can be computed in On 1  n 2 time by using the algorithm described inwith the necessary changes (see Section 2.2.1). However, score vector MIN can be computed faster. The minimum number of gaps can only be zero or one, the latter case arising when n 1 6  n 2. Assume w.l.o.g. that n 1 5n 2. Then, the computation of the maximum substitution score that is possible for one gap can be performed by comparing the substitution score for each of the n 1  1 possible locations of a gap. This can be performed in On 1 -time in an incremental manner.
Upper boundIn this problem, the computation of the maximum substitution score that can be achieved in entry Qn 1 , n 2  by a state t at entry Qi, j follows the same procedure as explained in Section 2.2.2. For the computation of the minimum number of gaps, we consider a partition of matrix Q into three sections; w.l.o.g., we assume that n 1 5n 2. Let Q D : Qi  n 2  n 1 , i, for n 2  n 1 i n 2 , which corresponds to the diagonal in Q starting at Q0, n 2  n 1  and ending at Qn 1 , n 2 . Let Q A and Q B denote the entries in matrix Q that are located above and below Q D , respectively. From this partitioning of Q, we can derive the following results for v, the minimum number of gaps, that is achieved at Qn 1 , n 2  by a state t (we relate state t with a partial alignment ' : A 0 , B 0 ):(i) If state t 2 Q D , then v : 0; (ii) If state t 2 Q A Q B ) and alignment ' ends with a gap in A 0 B 0 ), then v : 0;(iii) If state t 2 Q A Q B ) and alignment ' ends with two characters or a gap character in B 0 A 0 ), then v : 1.Conditions (ii) and (iii) can be determined by keeping an additional variable that stores whether state t was obtained from matrix R, S, or T in the recursion. Therefore, the upper bound for the case of gaps can also be computed in a constant amount of time.
Performance of the pruning techniqueWe performed an experimental analysis for comparing the performance of the algorithms described in the previous sections, with and without the pruning technique (Prune and NoPrune, respectively) and for both problem variants with substitution matrix PAM250 (). The implementations were coded in C and compiled with gcc version 4.6.1 with theO3 compiler option, in a computer with 2 processors Intel Xeon 5620, 2.4 GHz, 4 core and 16 GB RAM, with operating system Ubuntu 11.10. Except of the compiler option, no other code optimization technique was used in the experiments. We considered the sequences available from the benchmark BAliBase version 3.0 () reference set 9. The subsets RV911, RV912 and RV913 were chosen, as they are organized into three different groups according to the sequence variability:520%, 2040% and 4080% identity, respectively. From the datasets, we extracted the sequences from the following groups: RV911-BOX096 (12 sequences), RV911-BOX115 (7 sequences), RV911-BOX010 (18 sequences), RV912-BOX075 (13 sequences), RV912-BOX258 (16 sequences), RV912-BOX154 (5 sequences), RV913-BOX158 (55 sequences), RV913-BOX222 (7 sequences) and RV913-BOX063 (8 sequences). Our implementations were run on all pairs of sequences of the same group. Preliminary experiments indicated that only three bounds (MAX, MID and MIN) were insufficient for obtaining good performance. For this reason, several weighted sum problems were solved for different weight combinations to obtain a tighter lower bound set: 5, 10, 15 and 20. For each bound w, the weights were varying in the following manner: w s : i, w d : w  i, i 2 f1,. .. , w  1g. Other experiments that we performed indicated that no improvement in terms of pruning can be obtained for w values larger than 20. In a second set of experiments for Problem (VSGP), we observed that the pruning technique was only being effective for entries Qi, j, i ! n 1 =2 and j ! n 2 =2. Therefore, to reduce the overall CPU time, we switched off the pruning technique for lower indices. Tables 1 and 2 give the results obtained for both problem variants, where size is the average sequence length, #nd corresponds to the average number of non-dominated states, CPU time gives the average and standard deviation of CPU times in seconds to terminate and %prun gives the percentage of states that were pruned in the Prune(w) version. A bold value indicates the best average CPU time; in case of a tie, the value with the largest pruning percentage was chosen, as it suggests less memory usage. The results show that the Prune version is able to prune frominformation about the reliability of the tree branches. Two datasets are used for illustration purpose, and the resulting trees are compared with those obtained with the well-known technique of Maximum Likelihood (ML).
The bicriteria methodGiven a collection of non-dominated score sets, each one obtained for each pair of sequences, our approach consists of building a phylogenetic tree for each gap/indel value that arises from the union of all non-dominated scores sets. First, for each gap/ indel value found, we collect the set of substitution score values, one for each pair of species under study. The substitution score value from the resulting score vector is normalized between zero and one. Then, the distance between two species for a given gap/ indel value is computed as one minus the normalized substitution score value. In our experiments, we used the resulting distance matrix to build each phylogenetic tree by the Neighbor-Joining method () using PHYLIP package (). An important aspect of the analysis is to understand how often certain phylogenetic tree topologies exist. A less frequent topology, or tree branch, may indicate a less reliable relation between the corresponding species. Therefore, we count how many times each branch arises in all phylogenetic trees and add the corresponding relative frequency to each branch. This information is analogous to the bootstrap values introduced by; instead of the sampling process, we use the non-dominated score sets. In the following, we describe two experiments with real-life data.
First experimentThe first dataset consists of Candida genes, Candida albicans PAPa, C.albicans PAPalpha, Candida tropicalis PAPalpha, C.tropicalis PAPa and Candida dubliniensis PAPa, as well as the genes Pichia stipitis PAPa, and Saccharomyces cerevisiae PAP.for a more detailed description of these genes.] For each pair of genes, we computed the nondominated score set with respect to Problem (VSGP) with substitution matrix Mi, i : 1 and Mi, j : 1, i 6  j; see the complete non-dominated score sets with staircase line representation in. It is possible to observe that there exists a large number of non-extreme supported score vectors, as indicated by the straight lines, which cannot be found by a parametric sequence alignment (see, Chapter 14). We constructed 567 phylogenetic trees by using our method, but only two different tree topologies were obtained. One of two tree topologies was discarded from the analysis, as it arose only once of the 576 trees.shows the remaining treeobtained for a gap value of 283, the median of all gap values found; the value close to each branch indicates the relative frequency of that branch. For comparison, we computed the evolutionary tree using the ML method based on the model from Jukes and Cantor (1969) obtained by MEGA5 (); see. The bootstrap consensus tree inferred from 1000 replicates () was taken to represent the evolutionary history of the taxonomic analysis. There were a total of 1613 positions in the final dataset with all of them having 590% site coverage removed. The percentage of trees in which the associated taxa clustered together is shown next to the branches. Initial tree(s) for the heuristic search were obtained automatically as follows: when the number of common sites was 5100 or less than one-fourth of the total number of sites, the maximum parsimony method was used; otherwise BIONJ method with MCL distance matrix was used. The tree is drawn to scale, with branch lengths measured in the number of substitutions per site. By comparing both trees, it is possible to infer that they have a similar topology and similar relative branch frequency. This conclusion can also be understood by the regularity of the lines of. The nearest genes are C.albicans PAPalpha and C.dubliniensis PAPa, which corresponds to the black line in, with the largest substitution score. In the same figure, the three pink lines allow us to infer the positioning of C. tropicalis PAPalpha with respect to C.albicans PAPalpha and C. dubliniensis PAPa, as well as the branch (C.albicansPAPa, C. dubliniensis PAPa). As expected, P.stipitis PAP and S.cerevisiae PAP are the most distant species, as seen by the green dot-dash line in. Finally, both phylogenetic trees indicate a lower value for the branch that contains P.stipitis PAP gene. We relate this value to the crossed lines between the pairs formed by P.stipitis PAP and others genes (see blue lines in).
Second experimentThe second dataset is a classic example of comparison between primates: Homo sapiens haplogroup J1c3, Homo sapiens neanderthalensis, Gorilla gorilla graueri, Pan troglodytes troglodytes and Pongo abelii species. We performed the same analysis asdescribed in the previous section.shows the non-dominated score sets with staircase line representation. The figure shows a large number of non-extreme supported score vectors and some intersecting lines. This last point indicates that the relationship between those species, in the context of evolutionary studies, may depend of the score vectors chosen (or the scalarized score function used). We conjecture that the existence of intersections may indicate a less reliable conclusion about the evolutionary relationship. By using our bicriteria method, a total of 144 phylogenetic trees were obtained, which gave rise to two different tree topologies. Plots (a) and (b) ofshow the two trees topologies obtained for a gap value of 22 and 54, respectively; these gaps values correspond to the median of all gap values found in the phylogenetic trees with the same topology. The evolutionary tree using the ML method was also computed using the same method described in the previous section. The tree with the highest log likelihood (1351.1512) is shown in. All positions with 560% site coverage were eliminated. That is, 540% alignment gaps, missing data and ambiguous bases were allowed at any position. There were a total of 376 positions in the final dataset. The two trees obtained with our method differ slightly in relationship to the Pan traglodytes traglodytes with the remaining species: in plot (a), this species arose in the top of the branch (Homo sapiens neanderthalensis, Homo sapiens haplogrop J1c3), whereas in plot (b), it arises in a different clade, paired with Gorilla gorilla graueri. The relative branch frequencies suggest that the tree of plot (b) may be more reliable. Interestingly, this is also confirmed by the tree obtained with the ML method.
CONCLUSIONIn this article, a pruning technique is introduced to improve the performance of dynamic programming algorithms for bicriteria pairwise sequence alignment, which uses lower and upper bounds to discard states in early stages of the process. This technique can easily be extended for the case of affine gap by performing the necessary changes in the recurrence relation of matrices S and T(see Section 2.1). They can also be extended for the three criteria case, where the substitution score, the number of indels and the number of gaps are simultaneously considered in the score vector function. In addition, this pruning technique can also be used in multi-criteria multiple sequence alignment, for instance, in the context of progressive alignment with sum-of-pairs score function. In the second part of this article, we showed for the first time a successful link between non-dominated score sets and phylogenetic tree construction. We present a simple method based on our bicriteria framework that allows to construct phylogenetic trees as well as to give information about the reliability of the tree branches. The advantage of this method is that no assumption about a priori knowledge on users preferences is required, therefore, being less unbiased. The two real-life test cases showed that few phylogenetic trees can be obtained and are matched with those obtained with the ML method. Further research is needed to derive theoretical relation between ML estimations and the information provided by the non-dominated score set for tree branch reliability.
The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Bicriteria pairwise sequence alignment at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
M.Abassi et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
to 92% of the states that are generated by the NoPrune version for Problem (VSDP). The improvement in terms of CPU time can go up to 80% in the set RV913-BOX063. However, no improvement can be found for RV912-BOX075 and RV912BOX154, although all versions were extremely fast in those cases ( 0:5 s). For Problem (VSGP), the pruning can reach 83% and CPU time improved up to 60% in RV913-BOX222. In both problems, it is possible to observe that the increase of parameter w does not translate directly into faster CPU time; for instance, in the sets RV911 for Problem (VSGP), the best CPU time was obtained with w  10, although better pruning percentage was obtained with w  20! 20%). Clearly, the larger the lower bound set, the higher the required time for comparison. Moreover, the pruning seems to be more effective for large levels of residue identity. It is also noteworthy to mention that the number of nondominated states is a small fraction of the average size of the genes. We also observed that both algorithms on Problem (VSGP) take roughly 45 times more CPU time than on Problem (VSDP). 3 PHYLOGENETIC TREE CONSTRUCTION Phylogenetic trees are diagrams that illustrate historical relationships among the species. They have a valuable application in evolutionary and population biology [we refer to Schuh and Brower (2009) for more details]. In the context of our bicriteria framework, it is important to understand whether the non-dominated score set can provide further information than that provided by existing methods. In this section, we describe a method for constructing phylogenetic trees from the non-dominated score set and discuss its application for deriving further
