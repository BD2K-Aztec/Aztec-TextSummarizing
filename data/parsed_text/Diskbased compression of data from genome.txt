Motivation: High-coverage sequencing data have significant, yet hard to exploit, redundancy. Most FASTQ compressors cannot efficiently compress the DNA stream of large datasets, since the redundancy between overlapping reads cannot be easily captured in the (relatively small) main memory. More interesting solutions for this problem are disk based, where the better of these two, from Cox et al. (2012), is based on the Burrowsâ€“Wheeler transform (BWT) and achieves 0.518 bits per base for a 134.0 Gbp human genome sequencing collection with almost 45-fold coverage. Results: We propose overlapping reads compression with minimizers, a compression algorithm dedicated to sequencing reads (DNA only). Our method makes use of a conceptually simple and easily parallelizable idea of minimizers, to obtain 0.317 bits per base as the compression ratio, allowing to fit the 134.0 Gbp dataset into only 5.31 GB of space. Availability and implementation: http://sun.aei.polsl.pl/orcom under a free license.
IntroductionIt is well known that the growth of the amount of genome sequencing data produced in the last years outpaces the famous Moore's law predicting the developments in computer hardware (). Confronted with this deluge of data, we can only hope for better algorithms protecting us from drowning. Speaking about big data management in general, there are two main algorithmic concerns: faster processing of the data (at preserved other aspects, like mapping quality in de novo or referential assemblers) and more succinct data representations (for compressed storage or indexes). In this article, we focus on the latter concern. Raw sequencing data are usually kept in FASTQ format, with two main streams: the DNA symbols and their corresponding quality scores. Older specialized FASTQ compressors were lossless, squeezing the DNA stream down to about 1.51.8 bpb (bits per base) and the quality stream to 34 bpb, but more recently it was noticed that a reasonable solution for lossy compression of the qualities has negligible impact on further analyzes, for example, referential mapping or variant calling performance (). This scenario became thus immediately practical, with scores lossily compressed to about 1 bpb () or less (). Note also that Illumina software for their HiSeq 2500 equipment contains an option to reduce the number of quality scores (even to a few), since it was shown that the fraction of discrepant single nucleotide polymorphisms grows slowly with diminishing number of quality scores in Illumina's CASAVA package (http://support.illumina.com/sequencing/sequencing_software/casava.ilmn). It is easy to notice that now the DNA stream becomes the main compression challenge. Even ifhigher order modeling () or LZ77-style compression () can lead to some improvement in DNA stream compression, we are aware of only two much more promising approaches. Both solutions are disk based. Yanovsky (2011) creates a similarity graph for the dataset, defined as a weighted undirected graph with vertices corresponding to the reads of the dataset. For any two reads s 1 and s 2 the edge weight between them is related to the 'profitability' of storing s 1 and the edit script for transforming it into s 2 versus storing both reads explicitly. For this graph, its minimum spanning tree (MST) is found. During the MST traversal, each node is encoded using the set of maximum exact matches between the node's read and the read of its parent in the MST. As a backend compressor, the popular 7zip is used. ReCoil compresses a dataset of 192 M Illumina 36 bp reads (http://www.ncbi.nlm.nih.gov/sra/SRX001540), with coverage below 3-fold, to 1.34 bpb. This is an interesting result, but ReCoil is hardly scalable; the test took about 14 h on a machine with 1.6 GHz Intel Celeron CPU and four hard disks. More recently, Cox et al. (2012) took a different approach, based on the BurrowsWheeler transform (BWT). Their result for the same dataset was 1.21 bpb in less than 65 min, on a Xeon X5450 (Quad-core) 3 GHz processor. The achievement is however more spectacular if the dataset coverage grows. For 44.5-fold coverage of real human genome sequence data, the compressed size improves to as little as 0.518 bpb (Actually inthe authors report 0.484 bpb, but their dataset is seemingly no longer available and in our experiments we use a slightly different one.) allowing to represent the 134.0 Gbp of input data in 8.7 GB of space. Note that if the reference sequence is available, either explicit or can be reconstructed ('presumed', in the terminology of C novas and Moffat 2013), then compressing DNA reads is much easier and high compression ratios are possible. Several FASTQ or SAM/BAM compressors make use of a reference sequence, to name Quip (), Fastqz and Fqzcomp () in one of their modes, SlimGene (), CRAM (), Goby (), DeeZ () and FQZip (). Several techniques for compressing SAM files, including mapping reads to a presumed reference sequence, were also explored in C novas and Moffat (2013). In this article, we present a new reference-free compressor for FASTQ data, Overlapping Reads COmpression with Minimizers (ORCOM), achieving compression ratios surpassing the best known solutions. For the two mentioned human datasets it obtains the compression ratios of 1.005 and 0.317 bpb, respectively. ORCOM is also fast, producing the archives in about 8 and 77 min, respectively, using eight threads on an AMD Opteron 6136 2.4 GHz machine.
Materials and methodsLet s  s0s1. .. sn  1 be a string of length n over a finite alphabet R of size r. We use the following notation, assuming 0 i j < n: si denotes the i  1th symbol of s, si. .. j the substring sisi  1. .. sj (called a factor of s), and s t the concatenation of strings s and t. Our algorithm, ORCOM, follows the ancient paradigm of external algorithms: distribute the data into disk bins and then process (i.e. compress) each bin separately. Still, the major problem with this approach in reads compression concerns the bin criterion: how to detect similar (overlapping) reads, in order to pass them into the same bin? Our solution makes use of the idea of minimizers (), a late bloomer in bioinformatics, cf.(). Minimizers are a simple yet ingenious notion. The minimizer for a read s of length r is the lexicographically smallest of its all r  p  1 p-mers; usually it is assumed that p ( r. This smallest p-mer may be the identifier of the bin into which the read is then dispatched. Two reads with a large overlap are likely to share the same minimizer. In the next paragraphs we present the details of our solution. Assume the alphabet size r  5 (ACGTN). A reasonable value of p is about 10, but sending each bin to a file on disk would require 5 10  9:77 M files, which is way too much. Reducing this number to 4 10  1 (all minimizers containing at least one symbol N, which are rare, are mapped to a single bin, labeled N) is still not satisfactory. We solved this problem in a radical way, using essentially one (In fact, there is one extra file, with metadata, yet this one is of minor overall importance and we skip further description.) temporary file for all the bins, using large output buffers. To fetch the bin data in a further stage, the file has to be opened to read and the required reads extracted to memory from several locations of the file. As DNA sequences can be read in two directions: forwards and backwards (with complements of each nucleotide), we also process each read twice, in its given and reverse-complemented form. Additionally, we introduce a 'skip zone', that is, do not look for minimizers in read suffixes of (default) length z  12 symbols. This allows for some improvement in read ordering in the next step. The minimizers are thus sought over 2r  z  p  1 resulting p-mers. We call them canonical minimizers. However, a problem with strictly defined minimizers is uneven bin distribution. This not only increases the peak memory use, but also hampers parallel execution as the requirement for load balancing is harder to fulfill. To mitigate these problems we forbid some canonical minimizers, namely those that contain any triple AAA, CCC, GGG or TTT or at least one N (some of them, especially minimizers with runs of three or more As, are frequent). The allowed canonical minimizers are further called signatures, a term that we also used (with a slightly different definition) for the minimizers used in KMC 2, a k-mer counting algorithm (). In the next step, when the disk bins are built, we reordered the reads in bins to move overlapping reads possibly close to each other. From a few simple sort criteria tried out, the one that worked best was to sort the reads s i , for all i, according to the lexicographical order of the string s i j. .. r  1 s i 0. .. j  1, where j is the beginning position of the signature for the read s i. Such a reordering has a major positive impact on further compression. The reason is that overlaping reads are with high probability close to each other in the reordered array. The size of the skip zone should be chosen carefully. When too small, some signatures will be found close to the end of the read and the first factor of the sorting criterion, s i j. .. r  1, will be too short to have a good chance of placing the read among those that overlap it in the genome. On the other hand, with the zone being too long many truly overlapping reads will be forbidden. The last phase is the backend compression on bin-by-bin basis. We devised a specialized processing method, which produces several (interleaving) streams of data, finally compressed with either a well-known context-based compressor PPMd () or a variant of arithmetic coder () (We use a popular and fast arithmetic coding variant by Schindler (http:// www.compressconsult.com/rangecoder/), also known as a RC.). How we process the bins in detail, including careful mismatch handling, is presented in the next paragraphs.
LengthsRead lengths are stored here (1 byte per length in the current implementation, but a simple byte code can be used to handle the general case). The five streams: lettersN, lettersA, lettersC, lettersG, lettersT (These are used only if 'Flag' is f ex ; f mis or f oth .) 'LettersN' stores (i) all mismatching symbols from the current read where at the corresponding position of the referenced read there is symbol N, and (ii) all trailing symbols from the current read beyond the match (i.e. C and C in the example above). 'LettersX', for X 2 fA; C; G; Tg, stores all mismatching symbols from the current read where at the corresponding position of the referenced read there is symbol X (in our running example, the mismatching C would be encoded in the stream 'lettersG'. Note that the alphabet size for any 'LettersX' stream is 4, that is, fA; C; G; T; NgnfXg. Prev (Used only if 'Flag' is f ex ; f mis or f oth .) Stores the location (id) of the referenced read from the buffer. Shift (Used only if 'Flag' is f ex, f mis or f oth. ) Stores the offsets of the current reads against their referenced read. The offset may be negative. For our running example, the offset is  2. Matches (Used only if 'Flag' is f oth. ) Stores information on mismatch positions. For our running example, the matching area has 13 symbols, but 4 of them belong to the signature and can thus be omitted (as the signature's position in the current read is known from the corresponding value in the stream 'Shift'). A form of RLE (run-length encoding) is used here. Namely, each run of matching positions (of length at least 1) is encoded with its length on 1 byte, and if the byte value is less than 255 and there are symbols left yet, we know that there must be a mismatch at the next position, so it is skipped over. 'Unpredicted' mismatches are encoded with 0. For our example, we obtain the sequence: 1, 7 (match of length 1; omitted mismatch; match of length 11, which is 7 plus 4 for the covered signature's area). HReads (Used only if 'Flag' is f diss .) Here the 'hard' reads (not similar enough to any read from the buffer) are dispatched. They are stored almost verbatim: the only change in the representation is to replace the signature with an extra symbol (.). This helps a little for the compression ratio.
RevContains binary flags telling if each read is processed directly or first reverse-complemented. Some of the streams are compressed with a strong general-purpose compressor, PPMd (http://compression.ru/ds/ppmdj1.rar), using switches-o4-m16m (order-4 context model with memory use up to 16 MB), others with our range coder (RC), also of order-4. Namely, the streams 'Flags' and 'Rev' are compressed with order-4 RC, the stream 'LettersX' with order-4 RC, where the context is formed of the four previous symbols, and all the other streams are compressed with PPMd. The description presented above is somewhat simplified. We took some effort to achieve high processing performance. In particular, the input data (read from FASTQ files, possibly gzipped) are processed in 256 MB blocks (block size configurable as an input parameter) and added to a queue. Several worker threads find signatures in them, perform the necessary processing and add to an output queue, whose data are subsequently written to the temporary file. Also further bin processing is parallelized, to maximize the performance.
ResultsWe tested our algorithm versus several competitors on real and simulated datasets, detailed in
Real datasetsThe experimental results with real read data are presented in the upper parts of Tables 2 and 3. Apart from the proposed compressor Disk-based compression of data from genome sequencingORCOM, we tested DSRC 2 (), Quip (), FQZComp (), Scalce (), SRcomp () and BWT-SAP (). All these competitors, with the exception of BWT-SAP and SRcomp, are FASTQ compressors, and all of them present compression results of the separate streams. Inwe also present the result of ReCoil () on one dataset, copied from. ReCoil is too slow to be run on all our data in reasonable time. As we can see in, ORCOM wins on all datasets, in an extreme case (Musa balbisiana) with almost twice better compression ratio than the second best compressor, BWT-SAP.confirms the intuition that the performance of our algorithm improves with growing coverage.presents the compression times and RAM consumptions. Our compressor is also usually the fastest, with rather moderate memory usage (up to 14 GB). We point out that the first phase, distributing the data into bins, is not very costly, for example, it takes less than 25% of the total time for the largest dataset, Homo sapiens 2. In the memory use the most frugal is BWT-SAP (which is another disk-based software), spending only 3 MB for each dataset. One should remember that compression times are related to the number of used threads: Quip, FQZComp, SRcomp and BWT-SAP are sequential (one thread), whereas DSRC 2, Scalce and ORCOM are parallel and use eight threads here. Moreover, ORCOM, BWT-SAP and SRcomp compress the DNA stream only, whereas the remaining compressors have full FASTQ files on the input (with fake remaining streams in case of simulated reads presented in Section 3.2), what hampers their performance in compression speed and memory use (the compression ratios are however given for the DNA stream only). For these reasons, the results fromshould not be taken too seriously; they are given mostly to point out promising performance of our software. ORCOM's compression performance depends on two parameters: the signature length and the skip zone length. How varying these parameters affects the compression ratio is shown inand 3, respectively, on the example of two datasets. It seems that choosing the signature length from {6, 7, 8} is almost irrelevant for the compression ratio, but with longer signature the ratio starts to deteriorate. The impact of the skip zone length depends somewhat on the chosen signature length, yet from our results we can say that any zone length between 8 and 16 is almost equally good. We also show how replacing the straight minimizers with signatures affects the compression ratio and memory consumption (). The compression gain is slight, up to 2.3% on real data (H.sapiens 2) and up to 6.9% on simulated data (H.sapiens 3). Fortunately, the improvement is greater in memory reduction, sometimes exceeding factor 2. As we can see, in two cases using signatures required more memory than with minimizers, but this is for two relatively small datasets. Using signatures generally leads to more even data distribution across bins. The bin size distribution is still far from perfect though, as shown in. Finally, inthe sizes of individual streams after compression, for three datasets, are given. As one can see, the stream of hard reads is hardest to compress, which we think justifies its name.
Simulated datasetsIn the experiments for simulated datasets the reads were obtained by randomly sampling H.sapiens reference genome (HG 37.3). The number of non-N-symbols in the reference is approximately 2859 M. The H.sapiens 3 dataset contains 1.25 G reads of length 100 bp reads (to have the genome coverage like for H.sapiens 2). Half of them were obtained directly from the reference and another half were reverse complemented. The reads in H.sapiens 4 dataset were obtained from H.sapiens 3 dataset by modifying each base with a probability 1% (the probability is independent from the base position). It is important to stress that such a simulation of errors is far from what happens in real experiments (e.g. in most sequencers the quality of bases depends on the base position). Nevertheless, this simple error model allows us to compute the theoretically possible compression ratio and compare theNotes: Compressed ratios, in bits per base. The results of our approach are presented in the rightmost column. The best results are in bold. 'NS' means that the compressor was not examined as it does not support variable-length reads in a dataset. ReCoil was not examined in our experiments due to very long running times [the only result comes from. results of existing compressors with the estimated optimum and check what improvement is still possible in the reads compression area. The obtained compression ratios are presented in two bottom rows of. We note that 'standard' FASTQ compressors achieve compression ratios similar to the ones on real reads, which is perhaps no surprise. BWT-SAP achieves a substantial improvement on H.sapiens 3, as the noise in the real data must have broken many long runs in the BWT-related sequence and have hampered the compression. Yet, even more improvement, close to 2-fold, is observed for ORCOM. This can be explained by the local search for similar reads in our solution: once an error affects a read's signature area, the read is moved to another bin. On the noisy H.sapiens 4 dataset all compression ratios are, as expected, inferior. It is also not surprising that the standard FASTQ compressors, unable to eliminate most of the redundancy of the DNA reads, lose less here than ORCOM and Scalce do. The compression of clean data (H.sapiens 3) is also faster (). It is interesting to compare the ratios with estimations on how good compression ratio is possible. In theory, it is possible to perform a de novo assembly and to reproduce the genome from the reads. The reads from H.sapiens 3 dataset can be reordered according to the position of the read in the assembled genome. Thus, to encode the dataset it is sufficient to encode the assembled genome and for each read also: @BULLET the position of the read in the assembled genome, @BULLET the length (in a case of variable-length reads); for our data it is unnecessary as all reads are of length 100 bp, @BULLET the read orientation, that is, whether the read maps the genome directly or must be reverse complemented.Notes: Times are in thousands of seconds. RAM consumptions are in GBs. The best results are in bold. 'NS' means that the compressor was not examined as it does not support variable-length reads in a dataset.The assembled genome can be encoded using 2 bits per base (there is no N symbols), so for 2859 Mb we need 5718 Mbit. Then, for each read it is necessary to use 1 bit for the orientation, that is, 1250 Mbit in total. The read positions are ordered but are not unique, so to encode the positions we need to store a multisubset of size 1250 M from a set of size 2859 M, which is equivalent to storing 1250 M unique and ordered integers from the range h0; 1250M  2859M  h0; 4109M. The number of bits necessary to encode m unique and ordered integers from the range h0; n isFor n  4109  10 6 and m  1250  10 6 we obtain 3642.12 Mbit. Thus, in total we need 10 610.12 Mbit, so the compression ratio expressed in bits per base is 0.085. In case of reads with 1% of wrong bases we need to encode also the bases in the reads and the positions of the differences between the reads and the assembled genome. There are 1250 Mbases to encode, but this time it is enough to use log 2 3 bits per base as we are sure that the actual base differs to the base in the genome, so the total size of these data is 1981.20 Mbit. To encode the positions, we can conceptually concatenate the reads and encode the ordered and unique positions of wrong bases. We now apply Equation (1) with parameters n  125  10 9 and m  0:01n and obtain 10 099.14 Mbit. Thus, in total, to encode 1.25 G reads of length 100 bp with 1% of wrong bases, we need 22 690.46 Mbit, which translates into 0.182 bpb. We can notice that the obtained results with simulated reads are much worse (roughly, by factor 2 for H.sapiens 3 and factor 3 for H.sapiens 4) than the estimated lower bounds. This is basically due to two reasons. One is that the proposed read grouping method belongs to crisp ones, that is, one read belongs to one and only one bin. In this way, reads with relatively small overlaps are likely to be scattered to different bins and their cross-correlation cannot be exploited. Moreover, even reads with a large overlap has some (albeit rather small) chance of landing in different bins. This harmful effect of separating similar reads is stronger for noisy data. The other reason is the simplicity of our modeling, in which read alignment is performed only in pairs of reads and thus some long matches may be prematurely truncated. Overcoming these limitations of our algorithm is an interesting topic for further research.
Conclusions and future workWe presented ORCOM, a lightweight solution for grouping and compressing overlapping reads in DNA sequencing data. We showed that the obtained compression ratio for large datasets is much better the one from the previously most successful, BWT-based, approach. Our algorithm is based on the recently popular idea of minimizers. For the human dataset comprising reads of 100 bp, with 44.5-fold coverage, we obtain 0.317 bpb compression ratio. This means that the 134.0 Gb dataset can be stored in as little as 5.31 GB. Also for the other tested datasets ORCOM attains, to our knowledge, compression ratios better than all previously reported. ORCOM, as a tool, may be improved in a number of ways. Its performance depends, albeit mildly, on two parameters: signature length and skip zone length. Currently their default values are set ad hoc, while in the future we are going to work out quite a robust automated parameter selection procedure. Also, our plans include fine-tuning the backend modeling (e.g. the distance function between reads is rather crude now). More importantly, perhaps, a memory-only mode can be added, convenient for powerful machines, but with more compact internal data representations affordable also for standard PCs, at least on small to moderate sized genomes. On the other hand, in the diskbased mode the memory use may be reduced, at least as a trade-off (less RAM, but also fewer threads, thus slower compression and/or somewhat worse compression ratio). From the algorithmic point, a more interesting challenge would be to come closer to the compression bounds estimated in Section 3.2. Finally, our ideas could be incorporated in a full-fledged FASTQ compressor, together with recent advances in lossy compression of the quality data, to obtain unprecedented compression ratios for FASTQ inputs in an industryoriented massively parallel implementation.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
S.Grabowski et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from We maintain a buffer (sliding window) of m previous reads, storing also the position of the signature in each read. For each read, we seek the read from the buffer which maximizes the overlap. The distance between a pair of considered reads depends on the number of elementary operations transforming one into another. For example, if the pair of reads is: AACGTXXXXCGGCAT, CCTXXXXCGGCATCC, where XXXX denotes a signature, we match them after a (conceptual) alignment: AACGTXXXXCGGCAT, CCTXXXXCGGCATCC, to find that they differ with one mismatch (G versus C) and 2 end symbols of the second read have to be inserted, hence the distance is c m  1  c i  2, where c m and c i are the mismatch and the insert cost, respectively. The default values for the parameters are: c m  2 and c i  1, and they were chosen experimentally. In our example, the final distance is thus 2  1  1  2  4. The read among the m previous ones that minimizes such a distance, and is not greater than max dist, set by default to a half of read length, is considered a reference for the current read. Next, the referential matching data are sent into a few streams. Flags Values from ff copy ; f diss ; f ex ; f mis ; f oth g, with the following meaning:  f copy the current read is identical to the previous one,  f diss the read is not similar to any read from the buffer; more precisely, the similarity distance exceeds a specified threshold max dist ,  f ex the read overlaps with some read from the buffer without mismatches (only its trailing symbols are to be encoded),  f mis the read overlaps with some read from the buffer with exactly one mismatch at the last position of the referenced read,  f oth the read overlaps with some read from the buffer, but not in a way corresponding to flags f ex or f mis.
S.Grabowski et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
