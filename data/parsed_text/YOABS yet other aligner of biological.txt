Motivation: Explosive growth of short-read sequencing technologies in the recent years resulted in rapid development of many new alignment algorithms and programs. But most of them are not efficient or not applicable for reads 200 bp because these algorithms specifically designed to process short queries with relatively low sequencing error rates. However, the current trend to increase reliability of detection of structural variations in assembled genomes as well as to facilitate de novo sequencing demand complimenting high-throughput short-read platforms with long-read mapping. Thus, algorithms and programs for efficient mapping of longer reads are becoming crucial. However, the choice of long-read aligners effective in terms of both performance and memory are limited and includes only handful of hash table (BLAT, SSAHA2) or trie (Burrows-Wheeler Transform-Smith-Waterman (BWT-SW), Burrows-Wheeler Alignerr-Smith-Waterman (BWA-SW)) based algorithms. Results: New O(n) algorithm that combines the advantages of both hash and trie-based methods has been designed to effectively align long biological sequences (200 bp) against a large sequence database with small memory footprint (e.g. âˆ¼2 GB for the human genome). The algorithm is accurate and significantly more fast than BLAT or BWT-SW, but similar to BWT-SW it can find all local alignments. It is as accurate as SSAHA2 or BWA-SW, but uses 3+ times less memory and 10+ times faster than SSAHA2, several times faster than BWA-SW with low error rates and almost two times less memory. Availability and implementation: The prototype implementation of the algorithm will be available upon request for non-commercial use in academia (local hit table binary and indices are at
INTRODUCTIONDevelopment of sensitive local alignment algorithms was started in late 1980 with several pioneering tools such as FASTA () and BLAST (). For alignments of highly similar sequences to genomes, they were followed later by a new generation of faster methods, e.g. MegaBLAST (), SSAHA2 (), BLAT () and PatternHunter (). Next-generation sequencing technologies pushed development of new algorithms even further for efficient processing of millions of short (100 bp) reads. These ultra-fast tools were orders of magnitude faster and included SOAP (), MAQ (), Bowtie (), BWA (), Stampy (), etc. However, emerging single molecule sequencing technologies are constantly pushing read lengths into longer and longer realm (1K base pairs and more). Most of these ultra-fast short read tools do not perform well on these not so short reads as the tools were exclusively designed for reads 100 bp. But efficiently aligning long reads (200 bp) against a long reference sequence (1 Gb, like e.g. the human genome) has different overall objectives and hence represents a different challenge to the development of alignment tools. In contrast to short-read alignment when the best match is deduced by the end-to-end mapping of the query to the reference that minimizes a number of mismatches, long-read alignment is often based on several local matches and thus is being able to detect both structural variations in the query and erroneous assemblies in the reference. Additionally, short-read aligners are optimized for ungapped alignment and introduction of even limited number of short (several base pairs) gaps impose heavy performance penalties on these short-read algorithms. Long-read aligners on the contrary should be able (and optimized) to deal with arbitrary number of gaps of arbitrary size each. The majority of currently available long-read alignment algorithms may be classified as either using hash table indexing, like in BLAT () or in SSAHA2 (), or using some sort of compressed trie indexing based on Burrows Wheeler transform (BWT) (), for example, in BWT-SW () or in BWA-SW (). But in spite of using different indexing strategies all the above long alignment algorithms follow the seed-andextend paradigm, i.e. they first search for one or more of the so called seeds (either short exact matches, as in SSAHA2 and BLAT, or longer gapped matches in unique regions, as in BWASW). The found seeds are then extended to cover the whole query sequence using the SmithWaterman algorithm (BWA-SW uses this algorithm for identifying long gapped seeds as well). This extension algorithm is computationally expensive and although long-read aligners introduce various heuristic accelerations to limit use of this computationally penalizing phase by reducing unnecessary seed extensions especially in highly repetitive regions, the resulting tollremains heavy. Even in currently fastest heuristically accelerated BWT-based algorithms (e.g. BWA-SW) this toll is indirectly present through a large constant associated with each BWT operation. This article outlines a new long alignment algorithm, yet other aligner of biological sequences (YOABS), that does not use the seedand-extend paradigm and, hence, does not bear those computational expenses imposed by the SmithWaterman algorithm (As a matter of fact, it does not use the dynamic programming at all). The algorithm is designed to combine the advantages of both hash-and trie-based algorithms. Similar to hash-based algorithms it uses a series of look ups to build a correspondence between a query and a reference and, hence, has low-associated computational overhead. Similar to compressed trie algorithms it compresses highly repetitive regions and suppresses short repetitive matches that poison the performance of hash-based algorithms. The high accuracy, the low computational complexity as well as low memory requirements make the algorithm a candidate for specialty implementations with graphics processing units (GPUs) or field-programmable gate arrays (FPGAs). The article also presents some preliminary evaluation of algorithm's possible practical performance using work-in-progress test implementation along with BWA-SW and SSAHA2 on both simulated and real data.
METHODS
Reference indexYOABS starts with building several forward and backward indices for the reference sequence. The indices are organized in list type structures to combine the advantages of both hash-based (BLAT, SSAHA2) and trie-based (BWT-SW, BWA-SW) algorithms. In, the schematic example of single step of index building is shown. The forward index (shown at the top part of) is organized as a lexicographically sorted array of l bp prefixes. Each prefix entry is pointing to a lexicographically sorted array of m bpsuffixes. In turn, each suffix entry is associated with a numerically sorted array of l scaled k-bit masked locations (i.e. locations/l modulo 2 k ) of each of these l + m bp indexed entries. An optimal choice of l,m and n parameters probably depends on a size and a composition of reference sequence, but for human genome with 3 billions bp the parameters l = m = 7 bp and k = 8 bit seem to work well and were adopted as a feasibility checkpoint in all the results reported below using test implementation of this article. The size of this index for the human genome is roughly 3 billions bp / 7 bp  8 bit  400 MB. It looks natural to build similar index for backward direction as well but doing this will actually be bad choice as the combination of these indices will perform poorly, for example several errors clamped in the middle sections of the sequence shown inwill neither produce any hits with the forward index nor with the backward one. The better choice would be to build two backward indices with gaps: one with l = 7 bp gaps and the second with 2l = 14 bp gaps (as shown at the bottom of). As a result, these three indices (one forward and two backward) applied in concert will produce at least one hit for any 4l = 28 subsequence with 2 or less single base errors, that is with uniform error density of 7% or less. The purpose of splitting l +m bp indices into l-bp prefix and m-bp suffix is not just for conserving memory. Both the prefix and the suffix parts are lexicographically sorted, therefore, they provide not only an index (or hash), but also can work as a forward or backward tree, thus allow fast unwinding of low complexity/low error rate regions (as described in Section 2.2). An adaptation of k = 8 bit mask to store the locations naturally creates compressed index, as many highly repetitive parts of the reference will be collapsed into a single index entry with the same prefix, suffix and masked location.
V.L.GalinskyA pseudo-code of the index building step is sketched as Algorithm 1. (A list of notations used in algorithms is summarized in). Outlined so far indices will allow to record hits between the query and the reference, but would not give the exact location of those hits, therefore, some additional data structures are needed to store any information required to decode the complete location, and hence to decompress (or to resolve collisions, i.e. to distinguish between different locations collapsed into the same 2 k-masked entry) in the highly repetitive regions of the index. For reported reference implementation it resulted in total addition of 500MB of data and will be described in Appendix.
Query sequenceUsing indices described in the previous section the process of finding alignments between the query and the reference sequences starts with recording all local hits between them. The hits are organized in a table by a distance in a query (modulo l) versus a difference in distances in a reference and in a query (scaled by l and modulo 2 k ). Again size of this table depends on the choice of parameters l,m and k and can be expressed as l 2 k , that is 7  256 for the case reported here. (Actually the algorithm fills up two of these tables, the second table is for the reverse compliment query sequence.)A pseudo-code of the local hit table building step is sketched as Algorithm 2. The time complexity of the algorithm is O(2 k q), where q is the length of the query, i.e. for k = 8 it is O(256q). An illustrative example that outlines the first and the last steps of filling typical hit table is shown infor human reference genome and q = 84 bp query sequence. The hit table includes not only consecutive l +mmer matches (14-mer in this case), but matches with l and 2l gaps as well. Therefore, the perfect match at the first step (in this case first 28 bp subsequence) should result in the total number of hits not <6 plus at least 3 new hits for each next perfectly matched l bp segment. The six hits for the perfect match of the first 4l bp segment could be understood from the arrows in the querylet (), with three hits from the forward index, two hits from the backward index with l bp gap and one hit from the backward index with 2l bp gap. Extending the first 4l bp subsequence by the next l bp segment will produce one hit for each of the three indices, that is three new hits. The number of possible l bp extensions for a q bp query is (qq mod l)/l 4, where subtraction of the number 4 takes into account the first 4l subsequence. Therefore, an expression for the number of hits of perfectly matched q bp query is Number of hits(q) = 6+3((qq mod l)/l 4)Hence, for the perfect match of q = 84 bp query sequence the hit table will contain at the last step at least one entry with the number) The top panel schematically illustrates that the query is being processed sequentially from left to right with two querylet snapshots corresponding to two states in the local hit table. The left table shows a small number of hits recorded at different values of 2 k-masked position as the querylet moved through the first l bases of the query. Several random hits were recorded with at least one prefixsuffix pair (shown by the arrows in the querylet) at 2, 3, 4, 5 and 6 position in the query and one perfect match hit was recorded at the cell (9,4). The perfect match means that the same 2 k-masked position (row 09 in this example) has been recorded for all six combinations of prefixsuffix in querylet (shown by arrows). The right hit table shows the final state as the querylet reached the end of the query (The table entries produced by hits with reverse compliment of the query sequence are not shown for simplicity). of hits equals to 30, as example inshows. Presence of errors or SNPs in a query sequence will decrease this number of hits, but on the contrary multiple hits at the same 2 k-masked locations especially for highly repetitive subsequences will increase this number. The entries with highest number of hits will be candidates for the best alignment of the query to the reference. Presence of single well separated maximum in the hit table clearly indicates the unique alignment. For a set of chosen parameters (l = m = 7 and k = 8) a difference of 4 or 5 between max and second max entries in the hit table is good enough to rule out random hits that may arise due to short period of the l-scaled 2 k-masked location for k = 8. A construction of full local hit table for the query sequence creates convenient and straightforward way of searching for significant alignments with small but arbitrary gaps as well as for detection of chimeric reads. An example inshows how the content of the table for the same 84 bp query sequence will be modified if a small 5 bp deletion is introduced. In this case, the leading and the trailing portions of the sequence roughly of 40 bp each will produce two maximums with 3((4040 mod 7)/74)+6 = 9 hits. Those maximums are located at cells (9,4) and (a,6), that is they separated by four consecutive cells without hits or with low random hit counts [cells (9,3), (9,2), (9,1) and (9,0)]. In general, n bases. The right table that corresponds to the final stage includes all hits produced by the query section after the gap as well. The single maximum that was in cell (9,5) innow occupies two cells. The first is the same (9,4) and the second corresponds to the trailing portion of the query (the portion after the gap) and is located in the cell (9+(gap size1+l 4)/l,(4gap size+l) modulo l), that is they are separated by gap size less one cells with random hits. deletion produces n1 empty cells in the rightleft and then top down direction with respect to the original cell. On the contrary, n bases insertion does it in reverse, it adds n1 empty/low noise cells in the leftright downtop direction. Thus, local hit table provides easy way of finding the total size of gap or gaps between local subalignments as well as types of these gaps (insertion or deletion) by analyzing the maximums that were formed at different 2 k-masked locations. For chimeric read the hit table will contain several maximums as well but the separation between them both by the 2 k-masked location and by the full distance may in general be arbitrary large. The presence in the query sequence highly repetitive areas (like for example multiple TTTG subsequences at the trailing part of real 101 bp single end Illumina read presumably from Chromosome 1 shown in) complicates the picture, especially when combined with errors, SNPs or indels. But even in this case signatures of both relatively unique 65 bp leading partmatches and the leftright topdown pattern for the reverse matches. The linear buffer entries is then partitioned in two classes, one corresponding to the possible hits and the second to the random background hits. Several rules are used for partitioning, the most important two rules are: three sigma rule (i.e. the entry is assumed to be a possible hit candidate if it is separated by >3 sigma from the mean) and the maximum change rule (i.e. the entry is classified as a hit candidate if it has number of hits larger than the entry with the biggest change in the sorted linear buffer). The set of hit candidates is then processed in greedy order, selecting the entry with largest number of hits, decoding the full reference position (see Algorithm 2 in Appendix) using any three consecutive perfect matches from the list, unwinding low error regions (one or two base errors) using the reference index as a tree and scavenging the neighboring maxima in the local hit table that have correct encoded positions and hence may correspond to insertions or deletions. The process stops when a single entry is formed that clearly exceeds all other entries as well as the remaining hit candidates. The pseudocode of the algorithm is sketched as Algorithm 3 (it should be noted that several simplifications are used in the sketch, e.g. the pseudocode does not show resolving of collisions, i.e. multiple 2 k-masked locations, see Appendix).
Final alignmentOne of the most important difference of presented algorithm from the majority of long read alignment methods lies in the dismissal of seed-and-extend paradigm that is routinely employed by the most of current long read aligners. The existing algorithms (both hash and trie based) first search for the alignment seeds, but limit their number or size and keep several non-overlapped 1112 bp fixed size seeds (BLAT, SSAHA2) or one 2535 bp variable size (possibly with gaps) seed (BWA-SW) as candidates for further processing. Their next step involves extending seed alignments to the rest of the query sequence using the dynamic programming approaches,usually the SmithWaterman algorithm. Giving the remaining length of the query q and the size of the part of the reference used for alignment r = q+g (allowing for possible gap or gaps of the total length g) the typical time complexity of this dynamic programming step is O(qr) = O(q 2 +gq). Instead of extending relatively short seed area to the entire query sequence with this expensive (quadratic in time) dynamic programming step, the presented algorithm chooses to apply different strategy, which scales linearly O(q) with the size of the query q. When the entire query sequence has been processed and candidate entries from the hit table for the final alignment have been identified the last processing step involves decoding the unmasked location of the hits in the reference (may be resolving collisions due to finite period of 2 k-masked location if present in the hits) and glueing those hits together. Because of the presence of single or multiple base errors, SNPs or indels there will be areas in the query sequence where no local hits are detected, thus the glueing stage should provide a way of filling all these holes. When the hole is surrounded by the local hits withThe procedure uses gap size g and type (deletion) obtained from the local hit table and finds the gap position iteratively using some cooling schedule ( i ), gap/mismatch interaction potential/force (F i ) and virtual gap mass (M g ). the same difference between the query and the reference coordinates the filling is trivial and involves simple O(n) (where n is the length of the hole, n q) transition through all bases in the hole in order to find and record all mismatches. Theoretically it may be possible that adding equal number of equal length insertions and deletions may lower the total score, practically it is highly unlikely, giving the relatively high gap penalty used in most current algorithms and small size of the holes, especially in resequencing as well as in long read de novo assembly projects. The major advantage of the algorithm emerges when the hole is located in the area between local hits with different values of the query and the reference coordinate differences (as shown in examples in). This indicates that gap (either insertion or deletion) should be introduced somewhere in the hole to allow the transition from the leftmost to the rightmost hits. As it was shown above the local hit table allows to deduce the total size as as well as the type of the gap, but the exact position of this gap (or gaps) in the query sequence relative to the reference still needs to be determined. It would be tempting to simply align the part of the query without local hits using the SmithWaterman algorithm, assuming relatively short size n q of these holes, but the end result will have quadratic O(n(n+g)) complexity and may still hurt the overall performance when many of these small holes are present or when their size has increased. Besides, using quadratic algorithm would be an overkill and a complete waste of resources as more optimal linearly scaling approach can be used in this case. This alternative approach is illustrated in simplistic form inusing the query sequence from Chromosome 1 that was used before in. The illustration shows how the exact position of g = 4 bp gap (deletion) in the query sequence can be found using simulated annealing type algorithm with O(n) time complexity (similar strategy can be applied to find a position of insertion by placing the gap in the reference instead). The gap that is inserted initially at an arbitrary position in the hole region of the query is assumed to be able to move freely anywhere in the region. Its position is updated under an influence of attractive force acting on the gap from each mismatch site in the region, thus providing iterative procedure with O(n) time complexity for finding an optimal gap location. The performance (i.e. rate of convergence) of simulated annealing type optimization is implementation dependent and can be controlled or fine tuned by changing various parameters, e.g. annealing (cooling) schedule (i.e. the rate and the pattern of increase or decrease in the mobility of the gap with respect to the same applied force), type of gap/mismatch interaction potential (e.g. dependenceof the force on the gap/mismatch separation), effective gap mass and so on. The detailed comparative study of performance and accuracy of the above sketched procedure versus the SmithWaterman algorithm (as well as study/search for the parameters of simulated annealing that provide the best performance/accuracy trade-off) will be conducted and reported elsewhere. But simple proof of concept used in test code showed promising overall results.
YOABSan efficient nucleotide aligner
AccelerationAlthough processing the entire query sequence to completely fill the local hit table up (i.e. including all local hits between the query and the reference) seems fast enough to provide computationally competitive implementation, straightforward acceleration has been implemented in the test code. The acceleration involved introduction of additional hit table and filling both of the tables simultaneously going from the leftmost and the rightmost parts of the query toward each other. The process is terminated as soon as single ungapped or gapped entry in the run-time union of both tables can clearly be identified as a single significant alignment and the rest of the entries is at the level of noise created by random hits. When the query may be aligned at several locations the algorithm will behave exactly like in non-accelerated case and fill the complete local hit table up. For the test cases reported below this resulted in 22.5 speedup factor on long low error rate queries without deterioration of accuracy.
RESULTS
Performance evaluationFor the purposes of preliminary testing the YOABS algorithm has been prototyped using l = m = 7 and k = 8, thus resulting in 2 GB maximum run-time memory usage in all runs reported below.
Mapping quality:The concept of mapping quality based on estimation of the probability of a query sequence being placed at a wrong position has been introduced by. Both SSAHA2 and BWA-SW reports the mapping quality. To estimate the mapping quality of YOABS alignment an empirical formula, similar to the formula used in BWA-SW has been used: 250(S1S2)/S1, where S1 is the score of the best alignment, S2 the score of the second best alignment.
Simulated data:The data was generated using SAMtools package ().shows the CPU time, fraction of confidently aligned reads and alignment error rates for BWA-SW (version 0.5.9), SSAHA2 (version 2.5.1) and both non-accelerated and accelerated YOABS given different read lengths (from 200 bp to 2000 bp) and error rates (2%, 5%, 10%). No special optimization or fine tuning of the parameters has been used and in all runs the default command-line options of each aligner have been chosen (except 200 bp SSAHA2 runs, where '454' option was added). Fromone can see that non-accelerated test version of YOABS performs comparably to BWA-SW (slightly faster on low error rate reads) and both of them are faster than SSAHA2. On the other hand the accelerated YOABS version is significantly faster than BWA-SW on low error rate reads. For query lengths >500 bp YOABS shows that performance at both low error rate (2%) and high error rate (10%) ends are better than in the middle (5%) range, especially for accelerated version of the algorithm. In general, this is good property as it allows to characterize the worst performance of YOABS for any given query length. This behavior seems to indicate that local hit table method employed by the algorithm for quickly identifying top hits coupled with acceleration is well suited for low error rate regime and at the same time can be expected to perform reasonably well and do not play the role of show stopper at high error rate limit.
Real data (454):SRR003161 454 dataset (total of 1 376 694 reads) was used for performance evaluation. The results (shown in) are mostly consistent with the analysis of randomly selected 10% of the reads by, where 1200 plausible different mappings between BWA-SW and SSAHA2 were detected, i.e. either mapped by only one aligner with high score or mapped differently with high score (Q20 or above) by
V.L.Galinsky
Overall comparisonCurrent test implementation of YOABS shows best usage of memory, that can be seen from. These preliminary results combined with relatively low algorithmic complexity of YOABS (number of simple look ups tied with simulated annealing versus compressed BWT indexing tied with dynamic programming) clearly indicate compelling nature of the algorithm for use in long sequence realignment projects.
CONCLUSIONYOABS is an efficient algorithm (both memory-and performancewise) for aligning a several hundred or more base pairs query sequence to a long reference genome. It has high sensitivity and specificity (especially given a long query or a query with low error rate). The accuracy of YOABS is comparable with the most accurate long sequence aligners so far (e.g. BWA-SW or SSAHA2). By design YOABS is well suited to detect arbitrary gaps and chimeras, therefore it can be used to facilitate detection of structural variations or reference misassemblies. In contrast to the majority of long sequence alignment algorithms (e.g. BWA-SW, SSAHA2 or BLAT) YOABS does not use the seed-and-extend paradigm. Instead it records all local hits between all l(prefix)+m(suffix) base pairs index entries for the reference sequence (organized as a forward and a backward tries) and all l +m base pairs subsequences (including l and 2l gapped) of the query sequence. The local hits are stored as a table of l-scaled modulo 2 k query subtracted location in the reference versus modulo l location in the query. As a result, the algorithm avoids using the expensive dynamic programming stage (the SmithWaterman algorithm) altogether replacing it with linearly scaling simulated annealing type of procedure. The overall complexity of the algorithms is bounded by the complexity of the local hit table building step, that is O(2 k q) (where q is the query length) or O(256q) for k = 8 used in prototype implementation, hence it does not depend on the size r of the reference. It would be interesting to estimate the value of a constant in the complexity expression but I would expect it to be much lower than r 0.628 /256, taking into account relatively low cost of lookup operations that comprise most of the local hit table construction efforts when comparing with O(r 0.628 q) complexity expressions for BWA-SW or BWT-SW (), or with O(rq) of the dynamic programming step in general. This low complexity also makes the algorithm compelling for GPU and/or FPGA implementation. An important difference of the algorithm from various band accelerated modifications of the SmithWaterman algorithm (that is from approaches maintaining a small fraction of the dynamic programming matrix and, hence, allowing better than O(rq) scaling at the expense of missing some of the possible matches, for example for gaps larger than chosen band size) is that it records all the local hits and therefore will not miss any of the true matches. Other interesting projects to pursue consist in detailed comparison of performance and accuracy of the simulated annealing stage of the algorithm with the dynamic programming approach for ranges and errors typical for resequencing projects, as well as introducing a query indexing to make it sublinear complexity suitable for de novo sequencing.
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
