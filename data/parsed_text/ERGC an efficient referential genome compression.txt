Motivation: Genome sequencing has become faster and more affordable. Consequently, the number of available complete genomic sequences is increasing rapidly. As a result, the cost to store, process, analyze and transmit the data is becoming a bottleneck for research and future medical applications. So, the need for devising efficient data compression and data reduction techniques for biological sequencing data is growing by the day. Although there exists a number of standard data compression algorithms, they are not efficient in compressing biological data. These generic algorithms do not exploit some inherent properties of the sequencing data while compressing. To exploit statistical and information-theoretic properties of genomic sequences, we need specialized compression algorithms. Five different next-generation sequencing data compression problems have been identified and studied in the literature. We propose a novel algorithm for one of these problems known as reference-based genome compression. Results: We have done extensive experiments using five real sequencing datasets. The results on real genomes show that our proposed algorithm is indeed competitive and performs better than the best known algorithms for this problem. It achieves compression ratios that are better than those of the currently best performing algorithms. The time to compress and decompress the whole genome is also very promising. Availability and implementation: The implementations are freely available for non-commercial purposes. They can be downloaded from
IntroductionNext-generation sequencing (NGS) technologies are producing millions to billions of short reads from DNA molecules simultaneously in a single run within a very short time period, leading to a sharp decline in whole genome sequencing costs. As a result, we are observing an explosion of genomic data from various species. Storing these data is an important task that the biologists have to perform on a daily basis. To save space, compression could play an important role. Also, when the size of the data transmitted through the Internet increases, the transmission cost and congestion in the network also increase proportionally. Here again compression could help. Although we can compress the sequencing data through standard general purpose algorithms, these algorithms may not compress the biological sequences effectively, since they do not exploit inherent properties of the biological data. Genomic sequences often contain repetitive elements, e.g. microsatellite sequences. The input sequences might exhibit high levels of similarity. An example will be multiple genome sequences from the same species. Additionally, the statistical and information-theoretic properties of genomic sequences can potentially be exploited. General purpose algorithms do not exploit these properties. In this article, we offer a novel algorithm to compress genomic sequences effectively and efficiently. Our algorithm achieves compression ratios that are better than the currently best performing algorithms in this domain. By compression ratio, we mean the ratio of the uncompressed data size to the compressed data size.The following five versions of the compression problem have been identified in the literature: (i) genome compression with a reference: here we are given many (hopefully very similar) genomic sequences. The goal is to compress all the sequences using one of them as the reference. The idea is to utilize the fact that the sequences are very similar. For every sequence other than the reference, we only have to store the difference between the reference and the sequence itself; (ii) reference-free genome compression: this is the same as Problem 1, except that there is no reference sequence. Each sequence has to be compressed independently; (iii) reference-free reads compression: it deals with compressing biological reads where there is no clear choice for a reference; (iv) reference-based reads compression: in this technique, complete reads data need not be stored but only the variations with respect to a reference genome are stored; and (v) metadata and quality scores compression: in this problem, we are required to compress quality sequences associated with the reads and metadata such as read name, platform and project identifiers. In this article, we focus on Problem 1. We present an algorithm called ERGC (Efficient Referential Genome Compressor) based on a reference genome. It employs a divide and conquer strategy. At first it divides both the target and reference sequences into some parts of equal size and finds one-to-one maps of similar regions from each part. It then outputs identical maps along with dissimilar regions of the target sequence. The rest of this article is organized as follows: Section 2 has a literature survey. Section 3 describes the proposed algorithm and analyses its time complexity. Our experimental platform is explained in Section 4. This section also contains the experimental results and discussions. Section 5 concludes the article.
A survey of compression algorithmsWe now survey some of the algorithms that have been proposed in the literature to solve Problem 1. In referential genome compression, the goal is to compress a large set S of similar sequences. The core idea of reference-based compression can be described as follows. We first choose the reference sequence R. Then we compress every other sequence s 2 S by comparing it with R. The target (i.e. the current sequence to be compressed) is first aligned to the reference. Then mismatches between the target and the reference are identified and encoded. Each record of a mismatch may consist of the position with respect to the reference, the type (e.g. insertion, deletion or substitution) of mismatch and the value.have used various coders like Golomb (), Elias () and Huffman () to encode the mismatches. Wang and Zhang (2011) have presented a de novo compression program, GRS, which obtains variant information by using a modified Unix diff program. The algorithm GReEn () employs a probabilistic copy model that calculates target base probabilities based on the reference. Given the base probabilities as input, an arithmetic coder was then used to encode the target. Recently, another algorithm, namely, iDoComp () has been proposed which outperforms some of the previously best known algorithms like GRS, GReEn and GDC. GDC () is an LZ77-style compression scheme for relative compression of multiple genomes of the same species. In contrast to the algorithms mentioned above,have proposed the DNAzip algorithm that exploits the human population variation database, where a variant can be a single-nucleotide polymorphism (SNP) or an indel (an insertion or a deletion of multiple bases). Some other notable algorithms that employ VCF (Variant Call Format) files to compress genomes have been given byThese algorithms have been used in the 1000 Genomes project to encode SNPs and other structural genetic variants. Next we explain elaborately some of the best known algorithms in this domain.
GRSGRS is a reference-based genome compression tool exclusively dependent on the Unix program diff as mentioned above. Specifically, the primary step of GRS is to find longest common subsequences in two input strings. The auxiliary Unix program diff is employed to calculate a similarity measure between a target genomic sequence and a reference genomic sequence. If the similarity score exceeds a predefined threshold, the difference between the target and reference genomic sequences is encoded using Huffman encoding. If the similarity score is below the threshold, the target and reference sequences are split into smaller blocks and the computation is restarted on each pair of the blocks. It is to be noted that GRS does not require any additional information about the sequences, e.g. a reference SNPs map. If there exists an excessive difference between the target and reference sequences, GRS will not be able to compress the target sequence effectively.
GDCGDC is a LZ77-style () compression algorithm closely related to RLZopt () where GDC performs a non-greedy parsing of the target into the reference by hashing. On the contrary, RLZopt uses a suffix array. The main difference between GDC and the other reference-based compression tools is that it can choose a suitable reference (or, more than one reference) sequence among the set of genomic sequences from the same species using a heuristic and use it to compress the rest. It also introduces a clever trick to encode approximate matches. The algorithm slightly alters the original Lempel-Ziv parsing scheme by considering trade-offs between the length of matches and distance between matches. Compression is performed on input blocks with shared Huffman codes by enabling random access of the reference.
GReEnGReEn is also a reference-based genome compression tool. It encodes the target sequence using an arithmetic encoder. At first it generates statistics using the reference sequence and then performs the compression of the target by employing arithmetic coding. Arithmetic encoder uses the previously computed statistics to encode the target. From experimental results, it is evident that GReEn outperforms both GRS and the non-optimized RLZ. Similar to the non-referential compression scheme XM (), GReEn introduces a copy expert model. This model tries to find identical k-mers between the target and reference sequences. Raw characters in the form of arbitrary ASCII characters are encoded with arithmetic encoding. However, there is a special case where target and reference sequences have equal length. Although not justified, GReEn assumes that the sequences are already aligned and can be distinguished by SNPs.
iDoCompThe basic functioning of iDoComp can be summarized in three main steps: (i) mapping generation: in this stage, the target genome is expressed in terms of the reference genome. It uses suffix arrays to parse the target into the reference; (ii) post-processing: the postprocessing looks for consecutive matches that can be merged together and converted into an approximate match and (iii) entropy encoding: entropy encoder compresses the mapping and generates the compressed file.
Methods
Our algorithmWe have developed a reference-based genome compression algorithm called ERGC. It performs better than the best known algorithms existing in the current literature. Our algorithm runs in stages. Each stage is independent of the previous stage(s). In this setting, it can be readily transferred from in-core to out-of-core model and single-core to multi-core environment. We will discuss these enhancements later in this section. Details of our algorithm follow. Assume that R is the reference sequence and T is a target sequence to be compressed. At first ERGC divides the entire reference and target genomes into parts of equal sizes and processes each pair of parts sequentially. If the parts in R and T are r 1 ; r 2 ;. .. ; r q and t 1 ; t 2 ;. .. ; t q , respectively, then r 1 and t 1 are processed first, r 2 and t 2 are processed next and so on. Let r 0 ; t 0  be the pair processed at some point in the algorithm (where r 0 comes from the reference genomic sequence R and t 0 comes from the target genomic sequence T). To find the similarities between r 0 and t 0 , we need to align t 0 onto r 0. Similar regions between two sequences can be found globally aligning t 0 onto r 0 using NeedlemanWunsch algorithm as the sequences in the query set are similar and of roughly equal size. Since the time complexity of the global alignment algorithm is quadratic and thus based on dynamic programming, it is a very time and space intensive procedure especially when the length of the sequences is very large. In this context, we have devised our own greedy alignment algorithm to find similar regions between two sequences with high confidence (it is applicable when the sequences of interest are highly similar, e.g. two genomic sequences of the same species). Now we describe our greedy algorithm next. Our greedy alignment algorithm is based on hashing. At first, the algorithm generates all the k-mers from r 0 and hashes them into a hash table H (for some suitable values of k). It then generates k-mers from t 0 one at a time and hashes them to H until one of these k-mers collides with an entry in H. If none of the kmers collides with an entry in H, the algorithm generates another set of k 0-mers (where k 0 < k) from r 0 and hashes them into a hash table H 0. In a similar way, it then generates k 0-mers from t 0 one at a time and hashes them to H 0 until one of these k 0-mers collides with an entry in H 0. We employ a predefined set of values for k and try these values one at a time until a collision happens. The reason for taking a range of kmer values is that the occurrences of substitutions, insertions and/ or deletions can be more frequent in some parts of r 0 and t 0 than in the others. A range of values for k ensures that for at least one value a collision will occur. If there is no such collision, it is not possible to align t 0 onto r 0. If none of the values of k from this set results in a collision, then the algorithm extends the length of r 0 on both sides and a similar scheme is followed as described above. If all of the above mentioned techniques fail, then t 0 is saved as a raw sequence. Otherwise we align r 0 and t 0 with the k-mer that causes a collision as the anchor and extend the alignment beyond that position until there is a mismatch between r 0 and t 0. We record the matching length and the starting position of this stretch of matching in the reference genome. At this point, we delete the matching sequences from r 0 and t 0 and align the rest using our greedy algorithm as described above until the length of r 0 or t 0 becomes zero or there can not be any further alignment possible. This is how the algorithm proceeds iteratively. Next we describe how ERGC takes care of unmatched sequences. As there can be substitutions, insertions and/or deletions in the reference and target genomes, some portions of the genomes between two alignments will not be matched perfectly. In this case, we align those sequences using edit scripting. If the edit distance is large enough to exceed the cost to store the unmatched sequence of the target genome, we discard the edit script and store the raw sequence. The information generated to compress the target sequence is stored in an ASCII formatted file. After having processed all the parts of r 0 and the corresponding parts in t 0 , we compress the starting positions and matching length using delta encoding. The resulting file is further compressed by using PPMd lossless data compression algorithm. It is a variant of prediction by partial matching algorithm and an adaptive statistical data compression technique based on context modeling and prediction. For more details, the reader is referred to. Some recent implementations of PPMd are effective in compressing text files containing natural language text. The seven-zip open-source compression utility provides several compression options including the PPMD algorithm. Details of the algorithm are shown as Algorithm 1. Values of parameters such as set K, q and s have been optimized to get the best results. In our experiments, we have used default values of K and q where s is chosen dynamically. The set K contains two fixed values, i.e. K  f21; 9g. At first ERGC tries to align using 21-mers (i.e. k  21). If it fails, k  9 is picked to align the parts. The value of q is chosen in such a way that each part is composed of 20 000 nucleotides approximately. If the unaligned substrings from the reference and target are approximately equal and the memory needed to store the cost of edit distance information exceeds the memory needed to store the raw sequence, ERGC discards the edit distance information and stores the raw sequence as an ASCII formatted text file. Again, to speed up the proposed algorithm we have used several techniques.
Algorithm 1: ERGCInput: Reference sequence R, target sequence T, a threshold s, a set K of values for k. The set K contains two fixed values K  f21; 9g. s is the memory needed to store the raw sequence of interest Output: Compressed sequence T C begin 1 Divide R and T into q equal parts. Let these be; t q , respectively; 2 for i : 1 to q do 3 Hash the k-mers (for a suitable value of k from K) of r i into a hash table H; 4 Generate one k-mer at a time from t i and hash it into H; 5 If there is no collision try different values of k from K and repeat lines 3 and 4; 6 If all the different k-mers have been tried with no collision, extend the length of r i and go to line 3; 7 When a collision occurs in H, align r i and t i with this common kmer as the anchor; 8 Extend the alignment beyond the common k-mer until there is a mismatch; 9 Record the matching length and the starting position of this match in the reference genome R; 10 Compute the edit distance between unmatched subsequences (one each from r i and t i ); 11 If the edit distance d i is !s, store the raw (unmatched) subsequence of t i ; 12 Otherwise store the edit script information; 13 Compress the stored information using delta encoding; 14 Encode the stored information using PPMD encoder; 15 Return the compressed sequence T C
An illustrative exampleLet us illustrate our algorithm with a suitable example in brief. Please seefor visual details. Suppose r 0 ; t 0  is the pair processed at some point in the algorithm. As described above, r 0 comes from the reference genomic sequence R, and t 0 comes from the target genomic sequence T. Let a 1 a 2. .. a jr 0 j and b 1 b 2. .. b jt 0 j be nucleotide positions in r 0 and t 0 , respectively. At first, we hash the k-mers (for a suitable value of k from K) of r 0 into a hash table H. In this procedure, similar k-mers fall into the same bucket in the hash table H. We record the position of occurrence of each k-mer. Next we generate one k-mer at a time from t 0 and hash it into H. Let a specific k 0-mer starting at position b p in t 0 collide with an entry of H. As a number of identical k 0-mers can be found across the genomic sequence, the bucket can have multiple positions of identical k 0-mers. Next we retrieve the k 0-mer from the bucket which has the least position among all the identical k 0-mers in the same bucket. Let the position be a i in r 0. The proposed method then aligns t 0 onto r 0 using b p and a i and extend the alignment beyond the common k 0-mers until a mismatch is found. While extending, the first mismatch occurs in a j1 and b q1 of r 0 and t 0 , respectively. So, b p. .. b q can be represented with respect to r 0 by recording the position of a i and the length of b p. .. b q. The same procedure is repeated again. The unaligned substring b q1. .. b r1 is aligned with a j1. .. a k1 by considering some heuristics. At this point, three cases are possible.
Case 1: mutations in r 0 and t 0In this case, the unaligned substring of t 0 is aligned with r 0 employing edit distance calculations. In our example, this case arises while we attempt to align unmatched substring b q1. .. b r1 onto a j1. .. a k1. If the lengths of b q1. .. b r1 and a j1. .. a k1 are approximately equal and the memory needed to store the edit distance information between them is less than for the raw sequence b q1. .. b r1 , we store b q1. .. b r1 with respect to a j1. .. a k1 by recording the starting position of a j1 and edit distance information. Otherwise we store the raw sequence b q1. .. b r1 .
Case 2: insertions in r 0In this case, nucleotides are inserted in positions a l1. .. a m1 of r 0. We align b s1 onto a m and extend it until we find any mismatch using a similar procedure and record the positions of a m and jb s1 .. . b t j as described above.
Case 3: insertions in t 0Case 3 arises when nucleotides are inserted in positions b t1. .. b u1 of t 0. In this special case, we store the raw sequence b t1. .. b u1 and the starting position of b t1 as there is no other choice left.
Time complexity analysisConsider a pair of parts r and t (where r comes from the reference and t comes from the target). Let jrj  jtj  '. We can generate k-mers from r and hash them in O'k time. The same amount of time is spent, in the worst case, to generate and hash the k-mers of t. The number of different k-values that we try is a small constant and hence the total time spent in all the hashing that we employ is O'k. If a collision occurs, then the alignment we perform is greedy and takes only O' time. After the alignment recording the difference and subsequent encoding also takes linear (in ') time. If no collision occurs for any of the k-values tried, t is stored as such and hence the time is linear in '. Put together, the run time for processing r and t is O'k. Extending this analysis to the entire target sequence, we infer that the run time to compress any target sequence T of length n is O(nk) where k is the largest value used in hashing. It is easy to see that our algorithm can be implemented in a single pass through the data and thus can be employed in an out-of-core setting by using an appropriate value for the length of r and t. This can be ensured by choosing the length of r and t to be HM where M is the size of the core memory. The performance of any outof-core algorithm is measured in terms of the number of I/O operations performed. A single pass through the data refers to the number of I/O operations needed to bring each data item exactly once into the core memory. As a result, ERGC is optimal in terms of out-of-core computing.
Results and discussion
Experimental environmentWe have compared our algorithm with the best known algorithms existing in the referential genome compression domain. In this section, we summarize the results. All the experiments were done on an Intel Westmere compute node with 12 Intel Xeon X5650 Westmere cores and 48 GB of RAM. The operating system running was Red Hat Enterprise Linux Server release 5.7 (Tikanga). ERGC
.. bqis aligned onto a i. .. a j using greedy alignment algorithm, we only need to store the position of a i and the length of the matching alignment, i.e. ja i. .. a j j. The next alignment begins at a k and b r from r 0 and t 0 , respectively. The unmatched sequences in between are a j1. .. a k1 and b q1. .. b r1. b q1. .. b r1 can be saved as a raw sequence or using edit scripting. In a similar fashion, the sequence information of br. .. bs ; bs1. .. bt and bu. .. bv are stored using a k. .. a l ; am. .. an and an1. .. ao , respectively. Since bt1 .. . bu1 could not be aligned, it is stored as a raw sequence compression and decompression algorithms are written in standard Java programming language. Java source code is compiled and run by Java Virtual Machine (JVM) 1.6.0.
DatasetsTo measure the effectiveness of our proposed algorithm, we have done a number of experiment using real datasets. We have used hg18 release from the UCSC Genome Browser, the Korean genomes KOREF 20090131 (KOR131 for short) and KOREF 20090224 (KOR224 for short) () and the genome of a Han Chinese known as YH (). Since to compress a genomic sequence we need a reference genome, we have randomly chosen five pairs of target-reference sequences from the above benchmark datasets. We have taken chromosomes 122, X and Y chromosomes (i.e. a total of 24 chromosomes) for comparison purposes. Please seefor details about the datasets we have used.
DiscussionNext we present details on the performance evaluation of our proposed algorithm ERGC with respect to both compression and running time. We have compared ERGC with two of the three best performing algorithms namely GDC and iDoComp using several standard benchmark datasets. GReEn is another state-of-the-art algorithm existing in the literature. But we could not compare it with our algorithm, as the site containing the code was down at the time of experiments. GDC, GReEn and iDoComp are highly specialized algorithms designed to compress genomic sequences with the help of a reference genome. These are the best performing algorithms in this area as of now. Given a reference sequence, our algorithm compresses the target sequence by exploiting the reference. So, it needs the reference sequence at the time of decompression also. We use the target and reference pairs of sequences illustrated insion ratios. But it may not be possible to find variation files for every species and these algorithms will not work without variation files. Our algorithm does not employ variation files and so it can compress any genomic sequence given a reference. As a result, we feel that algorithms that employ variation files form a separate class of algorithms and are not comparable to our algorithm. Again our proposed algorithm is devised in such a way that it is able to work with any alphabet used in the genomic sequence. Every other algorithm works only with valid alphabets intended for genomic sequence e.g. P fA; a; C; c; G; g; T; t; N; ng. The characters most commonly seen in sequences are in P but there are several other valid characters that are used in clones to indicate ambiguity about the identity of certain bases in the sequence. It is not uncommon to see these 'wobble' codes at polymorphic positions in DNA sequences. It also differentiates between lower-case and upper-case letters. GDC, GReEn and iDoComp can differentiate between upper-case and lower-case letters specified in P but previous algorithms like GRS or RLZ-opt only work with A, C, G, T and N in the alphabet. iDoComp replaces the character in the genomic sequence that does not belong to P with N.Specifically, ERGC will compress the target genome file regardless of the alphabets used and decompress the compressed file which is exactly identical to the target file. This is the case for GDC and iDoComp also but GReEn does not include the metadata information and output the sequence as a single line instead of multiple lines. Effectiveness of various algorithms including ERGC is measured using several performance metrics such as compression size, compression time, decompression time, etc. Gain measures the percentage improvement over the compression achieved by ERGC with respect to GDC and iDoComp. Comparison results are shown in. Clearly, our proposed algorithm is competitive and performs better than all the best known algorithms. In Tables 3 and 4, we show a comparison between compressed size (from different algorithms) and the actual size of individual chromosomes for some datasets. Memory consumption is also very low in our algorithm as it only processes one and only one part from the target and reference sequences at any time. Please note that we did not report the performance evaluation of GDC for every dataset, as it ran at least 1 h but did not able to compress a single chromosome for some datasets. As stated above, ERGC differentiates upper-case and lowercase characters. It compresses target file containing the genomic sequence to be compressed and metadata if any with the help of a reference. The decompression procedure produces exactly the same file as the input. It does not depend on the alphabets and is universal in this sense. Consider dataset D 1 where the target and reference sequences/chromosomes are from YH and hg18, respectively (). In this setting, GDC runs indefinitely. iDoCompfor details). Now consider dataset D 2 where the target and reference sequences are from YH and KO224, respectively. The compressions achieved by GDC and iDoComp are roughly equal, whereas ERGC is about 3 better than them. GDC's compression time is longer than both of iDoComp and ERGC, but it decompresses the sequences very quickly. ERGC's compression is approximately 2:5 and 7:5 faster than iDoComp and GDC, respectively. Next consider D 5. GDC runs indefinitely for this dataset. The percentage improvement ERGC achieves with respect to iDoComp is 90.73%. Specifically, ERGC takes 11  fewer disk space compared to iDoComp for this particular dataset. ERGC is also faster than iDoComp in terms of both compression (2) and decompression (6) times.shows a comparative study of different algorithms including ERGC with respect to compression ratio, compression and decompression time. In brief, the minimum and maximum improvements observed from datasets D 1  D 5 were 27.97% and 90.73% with respect to iDoComp, respectively. The minimum and maximum improvements over GDC observed were 57.9% and 75.24%, respectively. ERGC compresses at least 2:12 and at most 5:21 faster than iDoComp. Although it is better than iDoComp and GDC in compression time for every dataset, it is slower than GDC with respect to decompression for datasets D 2  D 4 .
ConclusionsData compression is a very important problem in biology especially for NGS data. Five different NGS data compression problems have been identified and studied. In this article, we have presented a novel algorithm for one of these problems, namely, reference-based genome compression to effectively and efficiently compress genomic sequences. From the experimental results, it is evident that our algorithm indeed achieves compression ratios that are better than those of the currently best known algorithms. The compression time is also better than that of state-of-the-art algorithms in this domain. Although GDC is better than ERGC in terms of decompression time, the time ERGC takes to decompress the genomic sequences is also very promising.
FundingThis research has been supported in part by the NIH grant R01-LM010101 and the NSF grant 1447711.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
S.Saha and S.Rajasekaran at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Best values are shown in bold face. A.size and R.size refer to actual size in MB and reduced size in KB, respectively. C.time and D.time refer to the compression time and decompression time in seconds, respectively.
