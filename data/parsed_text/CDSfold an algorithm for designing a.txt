Motivation: An important problem in synthetic biology is to design a nucleotide sequence of an mRNA that confers a desirable expression level of a target protein. The secondary structure of protein coding sequences (CDSs) is one potential factor that could have both positive and negative effects on protein production. To elucidate the role of secondary structure in CDSs, algorithms for manipulating secondary structure should be developed. Results: We developed an algorithm for designing a CDS with the most stable secondary structure among all possible ones translated into the same protein, and implemented it as the program CDSfold. The algorithm runs the Zuker algorithm under the constraint of a given amino acid sequence. The time and space complexity is O(L 3) and O(L 2), respectively, where L is the length of the CDS to be designed. Although our algorithm is slower than the original Zuker algorithm, it could design a relatively long (2.7-kb) CDS in approximately 1 h. Availability and implementation: The CDSfold program is freely available for non-commercial users as stand-alone and web-based software from
IntroductionProtein expression levels are reportedly affected by various types of mRNA features, such as codon usage (), rare codon clusters (), secondary structures in untranslated regions () and protein-coding sequences (CDSs; see below), Kozak motif () and Shine-Dalgarno sequence (). Among them, secondary structure is difficult to handle because of the need to consider base pair interactions between distant nucleotides and complex energy parameters assigned to each part of the secondary structure. This may be one of the reasons that some recent methods for designing CDSs do not consider secondary structural features (). The secondary structure of CDSs, however, can have substantial effects on protein production as described below, although the mechanisms by which secondary structure affects protein production are not understood fully, especially in eukaryotes. Previous studies have found that secondary structures near the start codon tend to be unstable in both prokaryotes and eukaryotes (), suggesting that secondary structures have negative effects on protein expression levels. Indeed, in prokaryotes, it was shown that a stable secondary structure around the start codon reduced protein expression levels, possibly by blocking the access of the ribosome to the ribosome binding site (). Also, in eukaryotes, a previous study demonstrated that the secondarystructure around the start codon strongly reduced protein expression levels (). This was confirmed by a recent study based on the large-scale measurements of protein abundance for over 2000 sequence variants in yeast (). Therefore, it may be possible to decrease protein expression levels by artificially inserting a stable secondary structure near the start codon in both prokaryotes and eukaryotes. Secondary structures far downstream of the start codon may also have effects on protein production. It is commonly believed that the secondary structures in CDSs impede translation elongation, resulting in a reduction of protein production. It has, however, been pointed out that slow elongation may not result in decreased protein production as long as there is sufficient space between elongating ribosomes (). Moreover, it has been suggested that slow elongation can assist in proper co-translational protein folding (). Therefore, slow elongation does not necessarily decrease protein expression levels. Moreover, it cannot be ruled out that the secondary structures in CDSs have positive, rather than negative, effects on protein production by protecting mRNAs from various types of negative factors such as RNase digestion, down-regulation by microRNAs, and unintended interactions with other mRNA molecules. Interestingly, recent studies based on genome-wide measurements of RNA secondary structure in yeast (), found a high correlation between secondary structure and protein expression levels (); mRNAs of strongly expressed genes tend to form a more stable secondary structure. Although still arguable, these studies suggest a causal relationship between protein expression levels and the stability of the secondary structures of CDSs. Therefore, it is worth investigating whether (and to what degree) artificially stabilized secondary structures in CDSs decrease or enhance protein expression levels. To elucidate the effect of secondary structures in CDSs as well as utilize the features of secondary structures to control protein expression levels, algorithms for handling the secondary structures of CDSs should be developed. Currently, however, there are very few tools for stabilizing the secondary structures of CDSs. Gaspar et al. recently developed the mRNA optimiser (), which is based on a simulated annealing algorithm. Although the method was intended to remove secondary structures from CDSs, it can also be used to stabilize the secondary structures. Here, we developed a different approach that was based on a dynamic programming algorithm. It designs the CDS with the most stable secondary structure among all possible ones translated into the same protein. In our algorithm, the Zuker algorithm () is executed under the constraint of a given amino acid sequence. Although our algorithm uses larger DP matrices than the original Zuker algorithm, the fundamental procedure of both algorithms is the same. Therefore, as with the Zuker algorithm, the time and space complexity of our algorithm is O(L 3 ) and O(L 2 ), respectively, where L is the length of the CDS to be designed.
MethodsWe start with a description of the simplified version of our algorithm, which designs a CDS with the maximum number of base pairs. The algorithm executes the Nussinov algorithm () under the constraint of a given amino acid sequence. The original Nussinov algorithm is as follows:
Nussinov algorithmWe are given a nucleotide sequence. Let L be the length of this sequence. Among the numerous secondary structures that can be formed for the nucleotide sequence, the maximally base-paired structure can be obtained by the following algorithm:where ci; j is the maximum number of base pairs that can be formed for a sub-sequence from position i to j, and dhi; ji takes 1 if the nucleotides in positions i and j can form a base pair, or 0 otherwise. The diagonal elements of the c matrix and their neighboring elements, ci; i  1, are initialized to be 0. Then, the Nussinov algorithm recursively calculates ci; j until c1; L is obtained. The value of c1; L is the number of base pairs in the maximally base-paired structure. The positions of the base-paired nucleotides in the maximally base-paired secondary structure can be obtained by tracing back the c matrix, beginning from c1; L (seefor a concise explanation).
Nussinov algorithm under amino acid constraintsWe are given an amino acid sequence. Let L be the length of the CDS to be designed. Let N i be the set of possible nucleotides at the i th position of the CDS. Let n i be the realization of a nucleotide at position i. The size of N i varies from 1 to 4 depending on the amino acid residue and its codon position. Specifically, 1 or 2 nucleotides are allowed in the first and second codon positions of all amino acid residues, whereas 2 or 4 nucleotides are allowed in the third position in most cases. For some amino acid residues, there is a 'dependency' in their codons. For example, serine is coded for by 6 codons: AGU, AGC, UCU, UCC, UCA and UCG. If the first codon position of serine is A, then the second position must be G. To cope with such dependencies, let N i jn be the set of allowable nucleotides at position i after nucleotide n. Similarly, let N i ^ n be the set of allowable nucleotides at position i before nucleotide n. For leucine and arginine, there are nucleotide dependencies between the first and third codon positions. As described later in this section, we can convert the non-adjacent nucleotide dependencies in leucine and arginine into adjacent ones. Here, we temporarily assume that there are no such nucleotide dependencies in leucine and arginine. The algorithm for designing a CDS with the maximum number of base pairs is as follows:where c ni;nj i; j retains the maximum number of base pairs among the maximally base-paired secondary structures of the sub-sequences CDSfoldin which the first and last nucleotide is n i and n j , respectively, and d 0 hn i ; n j i takes 1 if n i and n j can form a base pair, or 0 otherwise. Similar to the original Nussinov algorithm, the diagonal elements and their neighboring elements, c ni;ni1 i; i  1, are initialized to be 0 for all allowable n i and n i1. In addition, c ni;nj i; j elements for all unallowable n i and n j under amino acid constraints are initialized and fixed to be-1. Then, Algorithm 1 recursively calculates c ni;nj i; j until c n1;nL 1; L is obtained for all possible n 1 and n L. The maximum value of c n1;nL 1; L over all possible n 1 and n L is the maximum number of base pairs among the maximally base-paired secondary structures of all possible CDSs translated into the given amino acid sequence. Note that multiple c elements in each i, j position, which are indexed by n i and n j , are not needed for the amino acid residues other than serine, leucine and arginine. If a given amino acid sequence does not contain serine, leucine, or arginine (in other words, all codon positions are independent), a single c element in each i, j is sufficient to calculate the maximum number of base pairs over all possible CDSs. The use of multiple c elements, however, is relevant when we extend Algorithm 1 to energy minimization based on the energy model obtained by the Turner group (), in which various types of energetic contributions are determined according to the adjacent nucleotides.
Obtaining the nucleotide sequence of a CDS by backtrackingIn the original Nussinov algorithm, the maximally based-paired secondary structure can be obtained by tracing back the c matrix. In the Nussinov algorithm under amino acid constraints, the nucleotide sequence of a CDS with the maximum number of base pairs, as well as its maximally based-paired secondary structure, can be obtained by a similar backtracking algorithm. Let c n1 ^ ; nL ^ 1; L be the maximum value of c n1;nL 1; L for all possible n 1 and n L. The pseudocode of the backtracking algorithm is described as Algorithm 2.last nucleotide, respectively. 5: while stack is not empty do 6: pop(i; j; n i ; n j ) 7: if i ! j then 8: continue; 9: for all n i1 2 N i1 jn i do 10: if c ni;nj i; j  c ni1;nj i  1; j then 11: cdsi  1 n i1 12: push (i  1; j; n i1 ; n j ) 13: continue; 14: for all n j1 2 N j1 ^ n j do 15: if c ni;nj i; j  c ni;nj1 i; j  1 then 16: cdsj  1 n j1 17: push (i; j  1; n i ; n j1 ) 18: continue; 19: for all n i1 2 N i1 jn i and n j1 2 N j1 ^ n j do 20: if c ni;nj i; j  21: c ni1;nj1 i  1; j  1  d 0 hn i ; n j i then 22: cdsi  1 n i1 23: cdsj  1 n j1 24: if d 0 hn i ; n j i  1 then 25: Record i, j as base-paired position 26: push (i  1; j  1; n i1 ; n j1 ) 27: continue; 28: for all k such that i < k < j do 29: for all n k 2 N k and n k1 2 N k1 jn k do 30: if c ni;nj i; j  31: c ni;n k i; k  c n k1 ;nj k  1; j then 32: cdsk n k 33: cdsk  1 n k1 34: push (i; k; n i ; n k ) 35: push (k  1; j; n k1 ; n j ) 36: continue;Starting from c n1 ^ ; nL ^ 1; L element, the algorithm finds 1 or 2 elements from which c n1 ^ ; nL ^ 1; L is derived. We use the word derived when the equality in line 10, 15, 20, or 30 holds. For example, if the equality in line 10 holds, c ni;nj i; j is derived from c ni1;nj i  1; j. Then, the algorithm recursively finds 1 or 2 elements from which each of the newly found elements is derived. As 2 elements at most are derived in each recursion (see line 30), the stack data structure is used to store them. The nucleotide sequence of a CDS is obtained by recording 1 or 2 nucleotides in each recursion. For example, in line 10, if c ni;nj i; j is derived from c ni1;nj i  1; j, the algorithm records n i1 as the i  1th nucleotide in line 11. The position of a base pair in the maximally base-paired secondary structure is obtained by recording base-paired positions in line 25 if d 0 hn i ; n j i  1 and c ni;nj i; j is derived from c ni1;nj1 i  1; j  1 in line 20.
Introducing extended nucleotidesFor leucine and arginine, there are nucleotide dependencies between the first and third codon positions. For example, leucine is coded for by 6 codons: UUA, UUG, CUU, CUC, CUA and CUG. If the first position is U, the third position is restricted to A or G. Algorithms 1 and 2 can cope with the dependency between adjacent nucleotides, but cannot consider the dependencies between the first and third positions. Fortunately, by introducing extended nucleotides, we can convert the non-adjacent nucleotide dependencies in leucine and arginine into adjacent ones. For leucine, we classified the nucleotide U in the second codon position into 2 different Us based on the nucleotide in the third position (). The second position is denoted by U AG and U CU if the third position is G or A and C or U, respectively. If the first position is C, then the second position can be both U AG and U CU. The extended nucleotides we used here and their dependencies are summarized in.
Zuker algorithm under amino acid constraintsIn the Zuker algorithm (), the most stable secondary structure in terms of the Turner energy model can be calculated for a given nucleotide sequence. Although the Zuker algorithm is more complex than the Nussinov algorithm, thecleotides. For example, U CU in leucine can be followed by C or U fundamental procedure of both algorithms is the same; namely, the optimal secondary structure is obtained from that of shorter sub-sequences. We extended the Nussinov algorithm under amino acid constraints so it can execute the Zuker algorithm under amino acid constraints. It is the Zuker version of the algorithm that was implemented in the CDSfold program.where F ni;nj i; j retains the smallest minimum free energy (MFE) over a set of sub-sequences in which the first and last nucleotide is n i and n j , respectively. The recursion equations of Algorithm 3 are almost the same as those of Algorithm 1; the only difference is that the third equation is replaced by C ni;nj i; j, which retains the smallest MFE provided that n i and n j form a base pair. When calculating C ni;nj i; j, we must consider the following 5 cases: nucleotides n i and n j form a base pair that 1. immediately follows another base pair, 2. encloses a hairpin loop, 3. encloses a bulge loop, 4. encloses internal loops, 5. encloses a multi-loop.
Case 1: Two consecutive base pairsIn the first case, C ni;nj i; j is obtained by considering the energy of 2 consecutive base pairs; this energy is commonly called stacking energy. For a particular base pair between n i and n j , we must consider all possible base pairs between N i1 and N j1. Therefore, the smallest MFE when a base pair n i and n j immediately follows another base pair is obtained as follows: min n i1 2 N i1 jn i n j1 2 N j1 ^ n j C ni1;nj1 i  1; j  1  E stacking hn i ; n j ; n i1 ; n j1 i  where E stacking is a function that calculates the stacking energy depending on a base pair between n i and n j that immediately follows a base pair between n i1 and n j1. For example, a G:C base pair that follows C:G is far more stable (3.4 kcal/mol) than A:U following U:A (0.9 kcal/ mol). The stacking energy is assumed to be 1 if a base pair cannot be formed either between n i and n j or between n i1 and n j1 .
Case 2: Hairpin loopIn the second case, nucleotides n i and n j enclose a hairpin loop. An example of a hairpin loop is shown in. In the Turner energy model, the energy of a hairpin loop depends on the nucleotides in the 4 positions indicated in. The smallest MFE when n i and n j enclose a hairpin loop is as follows:min n i1 2 N i1 jn i n j1 2 N j1 ^ n j E hairpin hn i ; n j ; n i1 ; n j1 ; v h i h iwhere E hairpin is a function that calculates the energy of a hairpin loop depending on the 4 nucleotides and the length of the hairpin loop v h  j  i  1. The energy of the hairpin loop is assumed to be 1 if a base pair cannot be formed between n i and n j. In the Turner energy model, there is a special table specifying the energy parameters for small hairpin loops of sizes 5, 6 and 8-nt (including a closing base-pair). For those hairpins, all nucleotides in the hairpin loop influence the free energy. To take this into account, we enumerate all possible 5, 6, 8-mers starting from each position of a CDS before running the recursion, and check whether there can be the special hairpin loops between position i and j when j  i  1  5 ; 6 or 8.
Case 3: Bulge loopIn the third case, n i and n j enclose a bulge loop.is an example of a bulge loop that is located between position i and p. The smallest MFE when n i and n j enclose a bulge loop is: min i  1 < p < j  1 n p 2 N p n j1 2 N j1 ^ n j C np;nj1 p; j  1  E bulge hn i ; n p ; n j1 ; n j ; v l i  where E bulge is a function that calculates the energy of a bulge loop depending on the 4 nucleotides indicated inand the length of the bulge loop v l  p  i  1. The energy of the bulge loop is assumed to be 1 if a base pair cannot be formed either between n i and n j or n p and n j1. The smallest MFE when a bulge loop is located on the right side of the stem can be calculated similarly (see Supplementary Methods).
Case 4: Internal loopsIn the fourth case, n i and n j enclose internal loops (). In the Turner energy model, the energy of the internal loops depends on the 8 positions indicated in. The smallest MFE when a base pair formed by n i and n j encloses internal loops is as follows:where Wn i ; n p ; n q ; n j  is a set of possible nucleotides in the 8 positions, provided that n i , n j , n p and n q are given. E intloop is a function that calculates the energy of the internal loops depending on w, as well as v l and v r , which are the length of the left and right side of the internal loops, respectively. The energy of the internal loops is assumed to be 1 if a base pair cannot be formed either between n i and n j or n p and n q .CDSfold
Case 5: Multi-loopIn the last case, n i and n j enclose a multi-loop. A multi-loop is a loop structure enclosed by 3 or more base pairs. An example of a multiloop enclosed by 3 base pairs is shown in. The smallest MFE when n i and n j enclose a multi-loop is as follows:where M ni1;nj1 i  1; j  1 is the smallest MFE of sub-sequences from n i1 to n j1 that are a part of a multi-loop. ML closing is the energetic penalty imposed when a base pair between n i and n j encloses a multi-loop. The calculation of M ni1;nj1 is slightly complicated and involves yet another DP matrix (for details, see Supplementary Methods). Once all values in the DP matrices are calculated, a traceback algorithm similar to Algorithm 2 can be used to obtain the nucleotide sequence of a CDS with the most stable secondary structure. For conciseness, the traceback algorithm and the complete details of Algorithm 3 are described in the Supplementary Methods. In Algorithm 3, the energy of dangling ends is not taken into account, because considering it makes our algorithm much more complicated and slower. Therefore, the current version of CDSfold does not consider dangling energy. However, we show the algorithm that can consider dangling energy in the Supplementary Methods.
Comparison with simulated annealingAs a baseline method for comparison, we consider a more straightforward approach based on the simulated annealing algorithm. It iteratively optimizes the secondary structure of a CDS by successive mutations under amino acid constraints. The procedure is as follows:1. An initial CDS is generated randomly that is used as a template. In addition, the number of iterations, denoted by i, is set to 0. 2. The MFE of the template is calculated in kcal/mol (denoted by e). 3. A single nucleotide in the template is randomly mutated under the amino acid constraints. i is increased by 1. 4. The MFE of the mutated CDS is calculated in kcal/mol (denoted by e 0 ). 5. If e!e 0 , the template is updated to the mutated CDS and e is also updated to e 0. Otherwise, the template and e are updated with the following probability:where T is a temperature parameter that takes 0 < T < 1. The T i value (T with exponent i) approaches 0 as the number of iterations i increases, which means that P update is also close to 0 as i increases. Thus, the larger i becomes, the more unlikely the template is updated. c is another parameter that is set to c  1000 in this study to make P update close to 1 when i is small. Processes 35 are repeated until a predefined criterion is satisfied. In this study, we terminated the algorithm if the MFE (e value) is the same during 1000 successive iterations or the running time exceeds 100 h. For the calculation of MFE, we used the RNAfold program in Vienna RNA Package version 2.1.1 (). We used RNAfold with the-d 0 option to use the 'no-dangle model'. The difference between our simulated annealing approach and mRNA optimiser is an objective function to be optimized. The mRNA optimiser uses a 'pseudo-MFE' as an objective function of simulated annealing, which is proposed to have a good correlation with the real MFE ().
Computational environmentAll computational experiments were performed on the Chimera cluster system at AIST, which had 176 Intel Xeon E5550 CPUs (2.53 GHz).
Results and discussion
Running time for real biological sequencesThe running time of our algorithm is affected by the amino acid composition of the input sequence, as well as the length of the CDS to be designed. If an input sequence contains more residues coded for by more codons, our algorithm spends more time assessing all nucleotide combinations that affect the energy of the secondary structure. To estimate empirically the influence of different amino acid compositions and evaluate the applicability of our method to real biological data, we measured the running time of CDSfold using proteins in the UniProt database (). We obtained amino acid sequence segments of the same length from the start codon of 100 randomly selected proteins. Here, we obtained sequence segments with lengths of 100, 300, 500, 700, 900, 1100, 1300 and 1500 amino acids, separately.shows the mean and standard deviation (SD) of the running time for each length. On average, it takes less than 1 h to design a CDS of length 2.7 kbp. As more than 95% of the sequences in the UniProt database are shorter than this length, our algorithm can design a CDS within 1 h for the majority of proteins. Theshows the SD of the running time is approximately 1020% of the mean, indicating that amino acid composition has a modest effect on running time.If an exceptionally long CDS must be designed, we can reduce the running time by limiting the maximum distance between basepaired nucleotides (denoted by W). If W is limited, time complexity becomes O(W 2 L), indicating that the running time increases only linearly on L.also shows the running time when W  500 bp.
1000
Comparison with simulated annealingAs a baseline method for comparison, we developed a more straightforward approach based on simulated annealing (see Section 2). We randomly selected 100 human proteins from the UniProt database () and stabilized the secondary structure of their CDSs by both CDSfold and simulated annealing. The temperature parameter T of simulated annealing was set to 0.99. The MFE obtained by CDSfold was lower than that of simulated annealing, as expected (). The difference of the MFE becomes larger as the length of the CDS becomes longer (note that long CDSs generally have lower MFEs, and see also Supplementarythat shows the MFE of even longer CDSs). It should also be noted that the running time of CDSfold was much shorter than that of simulated annealing; in most cases, CDSfold was 10100 times faster than simulated annealing.shows a list of the 100 genes examined and the running time for each gene. The optimization result of simulated annealing may vary depending on the temperature parameter T. However, when we used different parameter values (T  0.9 and 0.999), the same overall tendency was observed, although a slightly improved MFE of short CDSs was seen with T  0.999 (Supplementary). Therefore, using straightforward simulated annealing, it may be difficult to obtain the optimum solution, especially for long CDSs.
SoftwareCDSfold is available as standalone software written in C as well as a web-based application. As an example, we designed the CDS of enhanced green fluorescent protein, EGFP (GenBank KM042177.1), which is often used to evaluate protein expression levels.shows the result page when the maximum distance between basepaired nucleotides W is limited to 50 bp. Under this limitation, the designed CDS forms the most stable secondary structure among all possible CDSs translated into the same EGFP. The MFE of the optimized CDS sequence is lower (363.7 kcal/mol) than that of the original CDS obtained from GenBank (238.90 kcal/mol).
Practical use of CDSfold
Avoidance of certain codonsIn practical gene design, rare codons are often avoided because they are suspected to reduce translation elongation. Our software can be used to design an optimal CDS without rare codons. Users can indicate a set of codons that should be avoided.
CDSfold sequenceas a starting point for heuristic optimizations A CDS designed by CDSfold may be effectively used as a starting point for heuristic optimizations. As an example, we designed a CDS having high Codon Adaptation Index (CAI) () as well as stable secondary structure, using simulated annealing described in the Section 2. For this purpose, we defined a new energy score in which both CAI and MFE are taken into account.where k is a weight parameter associated with CAI. The larger k is, the greater the contribution of CAI is. Supplementaryshows the optimization results of a CDS encoding EGFP. By using various k values, we could obtain a set of CDSs having different CAI and MFE. It is interesting that, when the CDSfold sequence was used as a starting point, we could obtain better CDSs than when a randomly generated CDS was used as a starting point. In this example, CAI was calculated using top 1000 highly expressed genes in S. cerevisiae () as a reference gene set.CDSfold
Design of (partially) unstable structureTo evaluate the effect of secondary structure, it is important to design unstable secondary structures as well as stable ones. In this study, we developed a fast heuristic approach for designing a CDS with unstable structure, based on a pseudo-MFE similar to the one developed by Gaspar et al. (2012) (see Supplementary Methods). The web-application has radio buttons for switching between energy minimization by the dynamic programing and energy maximization by the heuristic approach. The effect of the secondary structure may vary depending on the position on a CDS. Therefore, we developed a two-step procedure for designing a CDS with partially unstable secondary structure and implemented it in CDSfold. In the first step, energy minimization by the dynamic programing is performed under the assumption that nucleotides in a given interval do not form base-pairs. Specifically, we set C ni;nj i; j in Eq. 3 to be 1 when i and/or j is within the interval. Note that a CDS designed under this assumption can have base-pairs in the interval when this assumption is removed. Therefore, in the second step, the heuristic pseudo-MFE maximization is performed on the interval to remove secondary structure. Users can indicate an interval where the secondary structure should be unstable.
ConclusionWe developed an algorithm for designing a CDS with the most stable secondary structure in terms of the Turner energy model. It was shown that CDSfold can design CDSs of most genes within 1 h. It was also shown that our algorithm can design CDSs with a more stable secondary structure than the method based on simulated annealing, especially when a CDS is long. The algorithm is useful for investigating the effect of the secondary structure of a CDS as well as utilizing features of the secondary structure to control protein expression levels. Note that, by changing the secondary structure of a CDS, potential binding sites for other regulatory proteins or factors might be also changed, which might be responsible for the change in expression level. Therefore, the effect of the secondary structure should be investigated using at least several different proteins.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
G.Terai et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
