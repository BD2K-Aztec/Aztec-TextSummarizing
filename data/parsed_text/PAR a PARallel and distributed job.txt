Bioinformaticians are tackling increasingly computation-intensive tasks. In the meantime, workstations are shifting towards multi-core architectures and even massively multi-core may be the norm soon. Bag-of-Tasks (BoT) applications are commonly encountered in bioinformatics. They consist of a large number of independent computation-intensive tasks. This note introduces PAR, a scalable, dynamic, parallel and distributed execution engine for Bag-of-Tasks. PAR is aimed at multi-core architectures and small clusters. Accelerations obtained thanks to PAR on two different applications are shown. Availability: PAR is released under the GNU General Public License version three and can be freely downloaded (http://download. savannah.gnu.org/releases/par/par.tgz).
INTRODUCTIONBioinformaticians are significant high-performance computing users, in particular for simulations of biologic phenomena. On the other hand, the available hardware is not only getting faster but also much more parallelized (Intel publicly reported working on 80 cores prototype chips in 2007). In this context, most bioinformaticians could benefit from an easy-to-use software to harness such computing power. The focus of this note is Bag-of-Tasks (BoT) applications execution. As the name suggests, BoT applications can be seen as a bag, filled with tasks to do, each being independent from all the others. A middle-ware for BoT applications is called a job crusher. It has to consist of at least a server component connected to a set of clients. This note introduces PAR, a parallel and distributed job crusher working in pull mode and inspired by desktop grid platforms. Workers join the computation and can be added dynamically at run-time; the server delivers tasks to workers available at a given moment. PAR is actually a transposition of some concepts and features from previous distributed middle-ware to small HPC clusters and multi-core workstations. This article is organized as follows: Section 2 presents an overview of related projects and technologies used in bioinformatics. Section 3 presents two examples using PAR to illustrate scalability. The last section lists upcoming enhancements. * To whom correspondence should be addressed.
RELATED PROJECTSA wide variety of tools and technologies have been used over the last two decades in bioinformatics. While PAR is a user-level tool with its own niche, it has some limitations. At the cost of a little more complexity, some of the tools listed hereafter allow fair share of resources, stronger reliability and even faster job or data throughput. At the programming level, the Message-Passing Interface [MPI,], CORBA (Object Management) or even MapReduce () are noteworthy technology candidates. MPI has become the de facto standard for programming highly parallel applications. It has been used in computational genomics () and in molecular dynamics (). For applications following a client-server model, CORBA can be used. Handling of genome maps has successful examples (). For data-intensive applications, MapReduce and its open source implementation Hadoop (http://hadoop.apache.org) are more appropriate. They unleash operations over huge amounts of data and were used recently in sequence alignment (). However, at the application level, Desktop Grids (DG) are closer to the focus of this note. A server distributes tasks to workers located on machines that do not communicate with each other, potentially anywhere on the Internet. Condor (), XtremWeb () and BOINC () are three platforms for highly parallel, multi-user applications. One of the best-known DG project in bioinformatics is probably Folding@home (). Like Hadoop and unlike most DG, PAR is designed to be used exclusively on private resources. PAR's ideal scale is then smaller than what DG systems usually target, but this permits a lower latency. For simplicity, PAR uses pull-driven task distribution. This removes the need for a complex software component (called a scheduler) and also allows to scale smoothly even in large, dynamic and heterogeneous environments. In addition, PAR never requires administrator privileges and is only run on-demand.
EXAMPLE USEThe first example experiment consists of computing Alpha Carbons Root Mean-Square Deviation after optimal superposition, noted C  RMSD opt hereafter, on one thousand ab initio generated structures for the protein target 256B. Distances between proteins are computed using the software from (). The second experiment performs molecular replacement (MR), amethod of solving the phase problem in X-ray crystallography using homologous structures, on a set of 192 decoys for the protein target 1m6t. We present the time elapsed with and without using PAR. PAR in parallel mode uses several cores of a given computer while the distributed mode uses distinct computers. The current implementation of PAR is known to work well with up to 16 and 64 CPUs in parallel and distributed mode, respectively. Prior to timing experiments, needed programs and data were copied to each machine by the user. During experiments, PAR was started in server mode with a list of commands to execute. Workers were started soon after the server, but could have joined the computation later if we were not interested in the shortest completion time. The Unix 'time' command was used and averaged over two trials to measure the real time spent by PAR to complete all tasks. Unlike previous job crushers, PAR server's life cycle is only tied to the application's execution time (no Unix daemon involved) and PAR runs only in user space. Results are shown in. The first bar is the real time elapsed when not using PAR. The second bar is the time spent when using PAR in parallel mode, and the following bars are durations in distributed mode. On a CPU-intensive task and when using 16 CPUs, the speedup obtained by PAR can be as high as 14.01 in the parallel case and 15.54 in the distributed one. Lower performance of the parallel version is attributed to Python's problem with multi-thread applications (the Python interpreter uses a global lock mechanism shared by all threads). We can see that the application scales remarkably well. The overhead due to communications between workers and the master is very small, and this allows for an effective use of the parallel hardware with minimum effort required on the user's side.
FURTHER DEVELOPMENTSPAR can be used on network of Unix-like workstations. It can take advantage of a Network shared File System (NFS). However, because of poor NFS performances, data-intensive tasks should be computed on top of a Distributed File System (DFS). As DFS are still rare even within clusters, we envisage to plug in such a functionality into PAR. A prototype has been implemented but is still in experimental stage. PAR should integrate fault-tolerance policies, in order to be used safely even with more workers over longer periods, and with minimal overhead. Furthermore, compression could be added to speedup communications. Encryption would be similarly easy to add and would allow PAR to be used over untrusted networks. Finally, features can be added for large-scale experiments. For example, requesting groups of jobs instead of one at a time would lower the load on the server part. Allowing PAR to run both as a server and as a client would allow it to be deployed in layers, which could be used to connect several clusters together and increase scalability. Requests and contributions from users are also considered.
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
