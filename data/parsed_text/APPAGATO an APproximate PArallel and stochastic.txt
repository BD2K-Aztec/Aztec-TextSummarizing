Motivation: Biological network querying is a problem requiring a considerable computational effort to be solved. Given a target and a query network, it aims to find occurrences of the query in the target by considering topological and node similarities (i.e. mismatches between nodes, edges, or node labels). Querying tools that deal with similarities are crucial in biological network analysis because they provide meaningful results also in case of noisy data. In addition, as the size of available networks increases steadily, existing algorithms and tools are becoming unsuitable. This is rising new challenges for the design of more efficient and accurate solutions. Results: This paper presents APPAGATO, a stochastic and parallel algorithm to find approximate occurrences of a query network in biological networks. APPAGATO handles node, edge and node label mismatches. Thanks to its randomic and parallel nature, it applies to large networks and, compared with existing tools, it provides higher performance as well as statistically significant more accurate results. Tests have been performed on protein–protein interaction networks annotated with synthetic and real gene ontology terms. Case studies have been done by querying protein complexes among different species and tissues. Availability and implementation: APPAGATO has been developed on top of CUDA-C þþ Toolkit 7.0 framework. The software is available online http://profs.sci.univr.it/$bombieri/APPAGATO.
IntroductionTechnological advances have led to the inference and the validation of structured interaction networks involving genes, proteins, drugs, phenotype and diseases (). According to the data type, such networks are referred to as (i) proteinprotein interaction (PPI) networks representing either physical or functional interactions among proteins; (ii) gene regulatory networks that express how the activity of genes is regulated; (iii) metabolic networks describing biochemical reactions between chemical compound of cells; and (iv) signalling networks representing inner/outer cell communications. A typical example that highlights the advantages and possibilities of analysing interaction relationships is protein function prediction. Although sequence homology is commonly used to functionally annotate proteins, a great amount of them remained uncharacterized (). In disease studies, genes showing similar phenotypes tend to be neighbours in protein interaction networks and their aggregation in connected sub-networks is effective to detect biomarkers (). Also, finding similar functional and topological sub-networks helps analysing the conservation among species (). In all these applications, graphs serve as the underlying structures for representing biological networks (For the sake of clarity, in this article, we use the terms graph and network indistinctly.) and graph algorithms solve problems such as network alignment, network querying, motif extractions and network perturbation (; Malod-Dognin and Pr zulj, 2015;). In this article we address the problem of approximate network querying, which finds, in a target network, similar occurrences of a so-called query network. The notion of similarity takes into account both the similarities between target nodes and query nodes, and a cost measuring the differences of nodes and their connections. An approximate network querying algorithm has to find the query occurrences, among all possible, with the maximum combined similarity. Querying tools that deal with similarities are effective in biological network analysis because they provide results also in case of noisy data. They are also suitable in the case of partial knowledge of users when formulating queries. Furthermore, they can be used to compare data from different species where some fundamental and functional structures are partially preserved. Solving approximate network querying implies applying instances of subgraph isomorphism, which is a NP-complete problem (). In literature, several heuristics have been proposed to solve such a problem in reasonable running time. Examples include restricting the topology of queries to paths or trees (), applying network alignment strategies (), dealing with node similarities and ignoring the query topology (), fixing the topology and computing differences of node labels (). Other methods consist of building indexes to reduce the query time (); filtering the set of possible similar target data (); to find only exact occurrences of the query in the network (); finding the largest part of the query exactly contained in the target graph and replace the query edges not present in the target with paths (). We have created APPAGATO, a tool that relies on an iterative sampling method (), to compute functional and topological similarities between a query and a target network. Through a matching probability matrix and a weighted sampling procedure, it selects a seed from which the querytarget matching starts. Then, by associating a cost to each approximation, it iteratively extends the match by selecting the approximations with the lowest possible cost. The algorithm runs K times and returns a set of K approximate matches. APPAGATO performs approximate network querying by considering the topology of query, taking into account node and edge deletions together with differences on node labels.To speed-up the querying process in large biological networks, APPAGATO has been implemented to run on graphics processing units (GPUs). Owing to their low cost, high-performance and easy integration to any personal computer, GPUs have been increasingly applied to accelerate bioinformatics problems (). Our aim is to handle large biological networks in a reasonable time yielding accurate results. We compare APPAGATO with RESQUE () and NeMa () because, to the best of our knowledge, they are the most efficient and stable tools in literature close to APPAGATO on both the problem they address and on the approximation concept they assume. We run the tools with different PPI networks as input and compared nodes by using similarities of protein sequences and functional gene ontology annotations. We extensively compare the tools in terms of running time, costs of returned matches and accuracy in finding protein complexes among different species. The results show that APPAGATO outperforms the other two tools, yielding more accurate results on large PPI networks.
Materials and methods
Definitions and notationsA graph G is a pair (V, E), where V is the set of nodes and E V  V is the set of edges. If u; v 2 E, we say that v is a neighbour of u. G is undirected iff 8u; v 2 E; then v; u 2 E, i.e. u is a neighbour of v and vice versa. The degree of a node u, Deg(u), is the number of its neighbours. Given a set of labels A, the function Lab : V ! A assigns a label to each node of G. We assume that graphs are undirected and labelled only on nodes.
Exact SubGraph IsomorphismLet Q  V; E and T  V 0 ; E 0  be two graphs, named query and target, respectively. The exact SubGraph Isomorphism (SUBGI) problem aims to find an injective function, M : V ! V 0 , which maps each node in Q to a unique node in T, such that 8u; v 2 E: (i) Mu; Mv 2 E 0 ; (ii) Labu  LabMu; (iii) La bv  LabMv. A solution of the SUBGI problem can be represented as the set m  fv 1 ; Mv 1 ; v 2 ; Mv 2 ;. .. ; v jVj ; Mv jVj g, called a match of Q in T. Q may have different maps m i in T.
Inexact SubGraph Isomorphism and matching costsIn this article, we deal with the Inexact SubGraph Isomorphism (ISUBGI) problem (Here called also approximate subgraph querying.), which is a variant of the SUBGI problem, and in which we admit node and edge mismatches. A mismatch occurs when (i) two nodes with different labels are mapped through a similarity function, or (ii) a query edge or (iii) a query node is missing in the target graph. The absence of a node implies mismatches for all its edges. A cost c is associated to each mismatch. For the sake of simplicity, the same cost c  1 is associated to each of the three types of mismatch. We denote with C  P c the total cost of mismatches between Q and T. The goal of the ISUBGI problem is to find an injective function M : V ! V 0 , such that C is minimized. In this case, a solution for the ISUBGI, m  fv 1 ;, the nodes and the edges in Q, respectively, that have not been matched in m. Let S jVjjV 0 j be the label similarities between each node q 2 Q and t 2 T. The label similarity values belong to the interval 0; 1. The computation of S is application dependent. In the case of PPI networks, the similarity can be based on sequences, functional or structural protein similarity. For example, establishing the conservation of a protein-complex CO of the species A within the species B consists of searching the subgraph Q CO , extracted from the PPI of A (named G A ), into the PPI of B (named G B ). The two PPIs may have different proteins (i.e. nodes with different names), but with similar function, detectable by looking at sequence similarities. An ISUBGI algorithm must search for occurrences of Q CO in G B that minimize sequences and topology differences. We conclude that CO is conserved in B if we find highly similar occurrences. The total matching cost C is obtained by summing all node and edge costs and by normalizing them over the number of query elements, as follows: Sq; Mq  jV mj  jE mj jVj  jEj (1)
The APPAGATO algorithmThe method consists of the following three main phases.
Phase 1: Computation of matching probability matrixBefore starting the search, APPAGATO computes a matrix P of matching probabilities between all possible node pairs < q; t > (q 2 Q and t 2 T), by combining (i) the label similarity S(q, t), (ii) the degree similarity D(q, t) and (iii) the breadth-first similarity BFS Sim q; t. The label similarity has been defined in Section 2.1.2. In APPAGATO, the label similarity matrix, S, may be provided as input by the user. Alternatively, APPAGATO computes a Boolean similarity function to compare node labels. It assigns 1 if labels are identical, 0 otherwise. The degree similarity is a binary function D(q,t)  1 if Degq Degt, otherwise it is 0. BFS Sim q; t is computed by performing breadth-first visits (BFSs) of the query and target graphs by starting from q and t and evaluating label and degree similarities of the visited nodes, level by level. The maximum depth of the BFS visits is a user-defined parameter l max , with l max ! 1. Given a node x, and a level l l max we denote with BFS l x the set of nodes at level l in the BFS tree rooted at x. An edge e  u; v in the BFS tree of q is defined matchable iff there exists an edge e 0  u 0 ; v 0  in the BFS tree of t such that Su; u 0  and Sv; v 0  are not 0 and Du; u 0   Dv; v 0   1. We denote with MaxMatchBFS l q; BFS l t a maximal set of matchable edges in the BFS tree of q at level l, with respect to the BFS tree of level l rooted in t. The BFS similarity between q and t assumes values in 0; 1 and is defined as follows:BFSEquation (3) ensures that P t2T Pq; t  1. In phase 2, the probability matrix is used as a transition matrix within an iterative sampling to extract the best possible matches. The upper side ofshows an example of such a matrix computation.
Phase 2: Seed selectionAPPAGATO searches the first pair of nodes to be matched by randomly selecting q and t according to the probabilities defined in Equation (3) (see the example of).
Phase 3: ExtensionGibbs sampling is used to navigate within a Markov chain, where each state represents a possible query-target node match. The initial state corresponds to the seed selected in phase 2. The sampling method iteratively performs a transition from a state to another, by replacing the querytarget nodes pair with a new one, according to a properly defined transition probability. As an example,shows the first two iterations of the extension phase. Transition probabilities are defined by starting from similarity scores, and by taking into account the connections of candidate nodes with already matched nodes. Let Q m and T m be the set of querytarget matched nodes at a certain step of the extension process. We denote with Q m i (T m i) the i-th query (target) node added to the partial match. Let q be a query node neighbour to at least one node in Q m and t be a target node neighbour to at least one node in T m. We represent the set of connections between q and the nodes in Q m through a bit vector CP(q) of jQ m j elements, called connection profile of q, where the i-th element is defined as follows:. The APPAGATO approximate matching algorithm
Parallel and stochastic searchWe define CP(t) in the same way. The connection profile similarity between q and t is the corresponding number of equal bits in the connection profiles of q and t: CP Sim q; t  jf1 i jCPqj : CPqi  CPtigj jCPqjThe overall similarity score is MScoreExtq; t  Sq; t  CP Sim q; t. The result value is normalized to obtain the final transition probability (Notice that MScore is not used in the extension phase. MScoreExt strongly influences the convergence of the approach ().):After a number of iterations, n, which is a user-defined parameter, the algorithm returns the reached match between the query and the target node. The quality of such a match is evaluated by summing the costs of node and edge mismatches between Q and T. APPAGATO does not require any user-defined threshold for the maximum allowed cost of a match. In, the approximate match has only a label mismatch, v Q 2 , whose label C is mapped with v T 0 having label D, and the cost of the match is C  0.1, computed by applying Equation (1). APPAGATO iterates K times phases 2 and 3 and, in each iteration, it starts the sampling procedure from a different seed. Each run of APPAGATO always returns K solutions (approximate matches), each one with the corresponding cost.
The APPAGATO parallel implementation for GPUsAPPAGATO has been implemented to take advantage of massively parallel GPU architectures. All the processing phases presented in Section 2.2 have been implemented through different CUDA kernels (http://www.nvidia.co.uk/object/cuda-parallel-computing-uk.html), which are invoked by the host CPU. This allows performing the most compute-intensive tasks of the search algorithm on the GPU device. As for the parallel implementation paradigm for GPUs, each kernel is executed in parallel by several blocks of threads. Thread blocks spread and run concurrently and independently over streaming multiprocessors. Threads of the same block efficiently cooperate through fast shared memory and by synchronizing their execution through extremely fast (i.e. HW implemented) barriers. Groups of 32 threads of the same block are called warps. Each warp executes one kernel instruction at a time in parallel on different data (i.e. single instruction multiple data-SIMD architecture) over the many stream processors (cores) of the GPU device. A warp scheduler efficiently switches between warps with the aim of hiding the latency of thread accesses to the memory. Given the query and the target graphs, Q and T, the three phases have been implemented as follows (see).
Phase 1: Parallel computation of matching probability matrixComputing the matching probability matrix is one of the most computation-intensive part of the whole algorithm. It requires jVj jV 0 j computations of Equation (3) and, in particular, OjVj  jV 0 j BFSs over Q and T and the corresponding comparisons between the visited edges (). APPAGATO implements such a phase through a customized version of BFS-4K (), a parallel implementation of BFS for GPU architectures. BFS-4K relies on the concept of frontier () (i.e. a FIFO queue that contains the nodes to be visited at each BFS iteration) to implement the graph visit. Through the frontier-based visiting, BFS-4K allows Equation (3) to be performed over two levels of parallelism: Each parallel warp of a block is mapped to each node of the frontier, and each parallel thread of a warp is mapped to each outgoing edge from a frontier node. APPAGATO extends the BFS visit over a third level of parallelism, by running a total number of jVj  jV 0 j independent BFSs in parallel, one for each node of Q and T. This is done by allocating one block of threads per BFS. The block allocation is automatically done at runtime. A total number of jVj thread blocks perform, in parallel, jVj BFSs (of depth l max ) for the query graph. The result consists of sourcedestination matrices, one per node, which are stored in the global memory (the left-most side ofshows an example, assuming l max  2). Each matrix contains information on the labels of such edges visited during the BFS from the node along l max levels. In the example of, the V Q 0 matrix contains information on the edges of the first-level BFS (A  B, A  C, A  D) as well as the edges of the second-level BFS (B  A, B  C, C  A, C  B, D  A). Similarly, and concurrently, a total number of jV 0 j thread blocks perform the BFSs for the target graph. The result consists of a set of. The parallel search of APPAGATO on the GPU device sourcedestination arrays, one per node, which are stored in the device shared memory. This allows an extremely fast memory access for the following comparisons between the generated node structures. The array data structure has been chosen, as it allows to represent in a more compact way the sourcedestination information of T in the limited shared memory. In contrast, the matrix data structure has been chosen as it guarantees a faster access to the sourcedestination information of Q, to be stored in the larger global memory. Finally, jV 0 j thread blocks compare, in parallel, their own sourcedestination array stored in the local shared memory with all the sourcedestination matrices in global memory. Such a data structure organization over the GPU memory hierarchy allows the complexity of Equation (3) to be reduced from OjVj  jV 0 j as for the sequential algorithm, to a parallel complexity of O(1). The result of Phase 1 is the matrix P jVjxjV 0 j , which is stored in the device global memory (see centre part of).
Phase 2: Parallel seed selectionAPPAGATO emulates the Gibbs sampling to select the K seeds for the successive extension phase. The emulation relies on two parallel primitives, prefix-sum () and weighed random number generation (https://developer.nvidia.com/ curand), which are efficiently implemented in the literature for GPUs. Given the similarity value of each querytarget node pair p xy of P jVjjV 0 j , APPAGATO performs the parallel prefix-sum of such values through jVj  jV 0 j threads (i.e. one thread per similarity value). The result is a prefix-sum array, in which each element is associated to a thread and the corresponding similarity value. As an example,shows the prefix-sum array of four threads, t 01 ; t 02 ; t 03 and t 04 , having similarity value 0:1; 0:9; 0:8 and 0.2, respectively. The array elements have been depicted through different sizes to better represent the corresponding similarity values. Then, all the threads generate a random sequence of K values in the interval 0; P p xy  (i.e. 0; 2 in the example). The parallel primitive for the random number generation allows the threads to share the generation seed and, as a consequence, to generate the same sequence of random values. This allows the threads to concurrently recognize whether the own boundaries in the prefix-sum array include any randomly generated value. In the example, the sequence of random values K 1  1:25 and K 2  0:15 leads to the pair of nodes vto threads t 03 and t 02 , respectively, to be selected for the extension phase.
Phase 3: Parallel extensionThe extension phase has been implemented through primitives of BFS, prefix-sum, weighed random number generation over different levels of parallelism. As a first level, the K query-target nodes selected in phase 2 are mapped to thread blocks (i.e. one pair of query-target nodes per block). They are concurrently processed as follows. Given a node pair (e.g.) the two nodes are processed in parallel by two thread warps (second level of parallelism). The two warps perform a one-step parallel BFS (third level of parallelism) on Q and T, respectively, to visit the neighbour nodes (i.e. candidate connections) of v Q 0 and v T 3. The result is two frontiers of neighbours ({vin the example). One step of extension over Q performs through a random selection of a node (connection) from the first frontier (v Q(SupplementaryS3), we assess the robustness of APPAGATO over query construction (Supplementary Figs S4 and S5) and the efficiency of both sequential and parallel versions of APPAGATO (Supplementary Figs S6 and S7).
PerformanceFor the physical interaction networks, we report the comparison results only between APPAGATO and NeMA, as RESQUE does not support such a large dataset.shows the average running times of the two tools on the D.rerio network. In the total running time of NeMa, we distinguish the target preprocessing and the querying time. Note that APPAGATO does not perform any preprocessing step. The results show that APPAGATO is at least three times faster than NeMA in case of small queries (i.e. 4, 8, 16 nodes). The performance difference sensibly increases with larger queries. The plots clearly show that the APPAGATO running time is almost constant when increasing the query size and the number of labels. We do not report the comparison results on M.musculus and H.sapiens because, in those networks, the running time difference is even more evident (i.e. NeMa requires >10 000 s for the preprocessing phase and >6000 s for the execution phase, while APPAGATO always requires around 2 s). Supplementaryin Section 3 reports the details on the APPAGATO running time in all the physical interaction networks, by showing its efficiency varying the number of labels, query size and network size.reports the comparison of APPAGATO with RESQUE on the functional interaction networks. For the sake of clarity, we do not include the NeMa results in the comparison because in this kind of networks, RESQUE outperforms NeMa. The performance of RESQUE mainly depends on the size of query and target and on the number of possible candidates for each query node. RESQUE requires, as an input, a similarity matrix between query and target nodes. Such a matrix can be partially defined and this affects the quality of the results. If the similarity matrix is fully defined, then the algorithm execution becomes infeasible (i.e. RESQUE takes hours for a single query run). Therefore, we run several tests by changing the percentage of target nodes that can match to a specific query node. Given a threshold t, we set all entries in the similarity matrix with values less than t to 0 (i.e. making them not possible candidates). We then normalized each row by the row maximum value. We chose the percentages 10%, 5% and 1% to obtain reasonable RESQUE running times (i.e. 14, 5 and 1 s, respectively. APPAGATO always requires around 0.69 s). The RESQUE running time rapidly rises as the t threshold increases. In contrast, the APPAGATO running times are always <1 s.shows a comparison of the average response costs of APPAGATO and NeMA on the D.rerio physical PPI network. We removed the duplicated matches from the results of APPAGATO to avoid the bias coming from low-cost matches. Both algorithms are executed to return the best 10, 50, 100 matches. As expected, both algorithms are highly dependent on the query size. However, there is a clear difference in their output quality. The cost of NeMa results are often close to 1, which means they involve a high number of mismatches. In contrast, the averages of the APPAGATO costs range from 0.1 to 0.55. Supplementary Figures S9 and S10 in Section 3 confirm the accuracy of APPAGATO, also on H.sapiens and M. musculus. We measured the statistical significance of the differences between the APPAGATO and NeMa performance. We computed the P-values with a Wilcoxon rank-sum test together with a false discovery rate correction for multiple testing. Supplementaryin Section 3 shows that APPAGATO significantly outperforms NeMa. The number of tested queries having lower P-values increases as the output size becomes larger, particularly when the number of required output matches increases.
Quality measurements of matches
Querying protein complexes among different speciesWe compared APPAGATO and RESQUE using 10 human protein complexes taken from CORUM and queried on the functional interaction dataset composed by M.musculus, H.sapiens, Drosophila. Running times of APPAGATO and RESQUE on the functional interaction networks. Results are grouped by the similarity thresholds. The running time of RESQUE highly depends on the number of target nodes that can be matched with a query node (i.e. on the similarity threshold t). Average costs (and their standard deviations) by taking into account the set of distinct output matches. Analysis have been performed on the physical interaction PPI of D.rerio. Results are grouped with respect to the number of target labels and query size melanogaster and S.cerevisiae networks (seeand Supplementary). We test RESQUE using two similarity threshold values, 1% and 100%. RESQUE shows the main performance limitation with a similarity threshold equal to 1% on every target network, while it provides better performance by increasing the cut-off. In all cases, APPAGATO outperforms RESQUE even on the quality of the results. To confirm this, we run the Wilcoxons rank-sum tests (see Supplementary). For low similarity thresholds (from 1% to 10%), APPAGATO provides Pvalues close to 1  10 12. Better P-values (between 1  10 5 and 1  10 6 ) are shown when we defined the whole similarity matrix. Nevertheless, this turned out to be unfeasible from the running time point of view. Supplementaryin Section 4 shows the functional coherence of results with respect to gene ontology. We computed the average P-value for both algorithms obtained by querying the 10 protein complexes for each of the four species. APPAGATO outperforms RESQUE on every type of target networks and similarity threshold. We refer the reader to Supplementary Sections 4 and 5 (S17) for details and further application of APPAGATO to compare disease modules over tissue-specific protein interaction networks.
ConclusionsWe have developed APPAGATO, a stochastic and parallel algorithm to find approximate occurrences of a query in biological networks. APPAGATO deals with node, edge and node label mismatches. It is implemented for GPUs. The choice of such devices is motivated by their accessible costs, high-performance and widespread availability on any personal computer. All above features allow APPAGATO to compute efficiently functional and topological node similarity together with fast searching of a large number of query matching within the target graph. The results show that APPAGATO outperforms the existing tools in terms of running time and result accuracy and, unlike competitors, it scales also on large PPI networks.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
V.Bonnici et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
in the example). For such a node, APPAGATO generates the connection profile through a one-step parallel BFS. Such a connection profile strongly affects the extension over T, which is performed as follows. Starting from all the nodes of the second frontier, APPAGATO (i) runs one step of parallel BFS (one per node), (ii) generates the connection profiles of the visited nodes and (iii) generates the connection profile similarity of each of such nodes with the connection of Q. Through an emulation of the Gibbs sampling similar to that implemented in phase 2, APPAGATO selects the new connection for T. The algorithm iterates over the new pair of nodes (i.e. connection of Q and connection T) for a total number n  jVj iterations. 2.4 Datasets Physical Interaction Networks. We used the PPI networks taken from the STRING v10.0 databases (Szklarczyk et al., 2011) of three species: Mus musculus, Homo sapiens and Danio rerio. These networks differ significantly in size (number of nodes and edges) and density (i.e. the average number of neighbours per node). For each network, we used up to 250 synthetic labels and gene ontologies annotation downloaded from BioDbNet (http://biodbnet.abcc.ncifcrf. gov). This yielded 12 different PPIs (i.e. three species, each one labelled in four different ways). We constructed the queries by randomly extracting sets of 100 connected subgraphs, from each network, by varying the size of the queries up to 128 nodes. In this dataset, the similarities matrix S jVjxjV 0 j q; t  1 if Labq  Labt, otherwise is set to 0. Functional Interaction Networks. The STRING database reports, among two proteins and beside the direct physical interactions used above, indirect functional relations such as structural similarity, similarity between the transcript sequences encoding them and functional correlations. It gives a score, ranging from 0 (namely no relation is known) to 999, which combines physical and functional (i.e. co-expression data analysis) interactions. We constructed a second dataset by taking into account such a combined score. We extracted four PPI networks related to the species M.musculus, H.sapiens, D.rerio and Saccharomyces cerevisiae. We fixed the interaction score threshold at 998 to get few but highly functional related interactions within each network. As queries, we used 10 human protein complexes taken from the CORUM database (Ruepp et al., 2010). Because CORUM only reports the set of proteins belonging to a given complex, and not their interactions, we reconstructed the topology of the complex by taking into account the interactions reported in the full STRING database with respect to the H.sapiens species. Finally, we labelled target and query nodes with the protein sequences. We computed the query-target node similarities matrix S jVjxjV 0 j , by making use of CUDASW (http:// cudasw.sourceforge.net), which implements a parallel version for GPUs of the Smith-Waterman algorithm for local alignment of sequences. We normalized the matrix by row to set to 1 the maximum similarity of the target and query node. We used this dataset to investigate the biological significance of the results. The approximate subgraph matching algorithms were capable to identify functional conservation of protein complexes among different species. We refer the reader to Supplementary Section 1 and Tables S1S2 for more details. 3 Results and discussion We compared APPAGATO with NeMA (Khan et al., 2013) and RESQUE (Sahraeian and Yoon, 2012) on both the physical and functional datasets described in Section 2.4. All the tools solve ISubGI by taking into account the query topology. Unless differently specified, with the term APPAGATO we refer to its implementation on top of CUDA. In the Supplementary, Section 2, we report details on the APPAGATO implementation and tuning of parameters Parallel and stochastic search
