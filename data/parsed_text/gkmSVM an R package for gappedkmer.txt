We present a new R package for training gapped-kmer SVM classifiers for DNA and protein sequences. We describe an improved algorithm for kernel matrix calculation that speeds run time by about 2 to 5-fold over our original gkmSVM algorithm. This package supports several sequence kernels, including: gkmSVM, kmer-SVM, mismatch kernel and wildcard kernel.
IntroductionWe recently introduced a gapped-kmer-SVM classifier (gkmSVM) () to detect functional sequence elements in regulatory DNA which has been applied to interpret a wide range of genomic datasets (). While we released a version of our earlier kmer-SVM () as a webserver (), gkmSVM was only released as C  source code. Here, we present an R package, gkmSVM-R, with several improvements to facilitate easier implementation and broader use. Our original gkmSVM-1.3 implementation used a tree algorithm to compute the kernel matrix (. In this paper, we describe a new algorithm, iDL-bound, that speeds up kernel matrix computation. We have implemented the algorithm in C  and our R package is easily accessible on different platforms. Our package also includes fast implementations of other kernels (). We refer the C  code implementing the faster iDL kernel calculation as gkmSVM-2.0.shows an overview of the gkmSVM analysis pipeline. Given two sets of sequences, the goal is to build a predictive model to classify the two sets. For example, in () a gkmSVM is trained to detect regulatory DNA elements active in a cell type by using chromatin accessible DNA sequences as the positive set and a set of GC matched inaccessible DNA sequences as negative set. The model then can score and predict the accessibility of any DNA sequence. The first step is to build the kernel matrix (the pairwise similarity scores for all the sequences in the positive and negative sets). This is done using gkmsvm_kernel function: gkmsvm_kernel(posfn, negfn, kernelfn); where posfn and negfn are the input file names for the positive and negative sets (FASTA format) and kernelfn is the output file name for the kernel matrix. The second step is to train the SVM model, using: gkmsvm_train(kernelfn, posfn, negfn, svmfnprfx);where svmfnprfx is the output file name prefix for the SVM model (support vectors). Finally to classify/score a sequence, gkmsvm_classify is used: gkmsvm_classify(testfn, svmfnprfx, outfn);
Usagewhere testfn is the sequence input file and outfn is the output. We have also included new functions genNullSeqs to sample the genome to generate a GC, length and repeat fraction matched negative sequence set and extract FASTA sequences, and gkmsvm_delta to score the impact of a variant () as described in the tutorial (Supplementary Data).
IDL-bound algorithmThe original algorithm in (), calculated the mismatch profile for all pairs of k-mers with up to D mismatches using a single depth first search (DFS) traversal of the k-mer tree. This is fast for small values of D, but search time exponentially grows with D. Here, we implement an alternative approach that divides the search into n independent passes. Each pass can be truncated, speeding the overall search. To elaborate,shows an example of two strings of length L  10, denoted by u  u 1 ,.. .,u L and v  v 1 ,.. .,v L. We want to check if they differ in at most D  3 places. One approach is to start from the left and compare the two strings in a left to right order. We stop the search when we observe 4 mismatches or reach the end of the string. Alternatively, we can make the comparison in two passes, from left to right and right to left. If the strings have at most 3 mismatches, then in one of the two passes there is at most 1 mismatch in the first half of the search. So we can stop when we observe more than 1 mismatch, which can greatly reduce search time. LEMMA 1 Given string length L, and maximum mismatch D, there exists L predetermined passes (each pass is a permutation of 1,.. .,L) where for any pair of strings with at most D mismatches, the number of mismatches in the first i comparisons is bounded by iD=L b c in at) when C  1. Our faster algorithm allowed optimizing over C (shown), but this yields insignificant improvement in AUC least one of the passes. The L passes can be generated by circular shifting of 1,.. .,L.To compare two strings, we compare them in L different passes (orders of letters), and at each pass stop the search if the number of mismatches exceeds iD=L b c at the ith step. Lemma 1 guarantees that if the two strings have D or fewer mismatches, at least one of the passes will reach the end, which we here prove graphically, similar to Raney's problem in (). Given two strings u and v, we plot the mismatch curve by starting from the origin, and for each position i, if u i and v i match, we move one unit in x, and if they do not we move one unit in x and one unit in y. If u and v have D mismatches, the mismatch curve will end at point (L,D), and the line segment between the two ends has slope a  D/L (). Now if we repeat u and v and continue the mismatch curve it will also pass (2L,2D) as shown. If we shift the y  ax line in y so that the mismatch curve lies entirely below it, the corresponding shift (x*) gives the cyclic shift that satisfies the iDL-bound. In gkmSVM-2.0, we divide the search into n  2L passes, L of them given by the L circular shifts of 1.L, and the other given by L circular shifts of the reverse of the scrambled permutation defined as follows:wise, q  L=D b c, r  L  qD.shows the 2L permutations used for L  7 and D  3 as an example. In practice, we generate all the possible patterns of mismatches (all the binary strings of length L with at most D ones) and assign each mismatch pattern d to the pass p that gives the minimum cost:Here, w i is the square of the number of nodes at depth i in the k-mer tree, and p  1/b, where b is the size of the alphabet (e.g. b  4 for DNA). This equation generally assigns each mismatch pattern to the pass that visits most of the match positions first and mismatch positions toward the end of the search. We then build a k-mer tree using all the mismatch patterns assigned to each pass and use that to prune the DFS search in that pass. Since this new algorithm involves independent passes, we can easily multithread by running each pass on a separate thread, following (Lee, 2016).
ResultsTo evaluate the algorithm performance, we applied it to CTCF and EP300 datasets described in ().shows running times for different values of L and D. We observe an average improvement of two fold using a single thread and up to 20-fold using 8 threads. LS-GKM (), designed for training on very large datasets, is typically two times slower. With the faster iDL algorithm we were also able optimize the SVM C parameter for the 467 Chip-seq datasets analyzed in (). We reproduce the results of gkmSVM-1.3 with gkmSVM-R when C  1, and when C is optimized, as shown in, there is minimal improvement. We therefore recommend running with C  1.
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
M.Ghandi et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
