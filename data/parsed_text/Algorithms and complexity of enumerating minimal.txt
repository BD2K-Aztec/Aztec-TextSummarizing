Motivation: In the context of studying whole metabolic networks and their interaction with the environment, the following question arises: given a set of target metabolites T and a set of possible external source metabolites S, which are the minimal subsets of S that are able to produce all the metabolites in T. Such subsets are called the minimal precursor sets of T. The problem is then whether we can enumerate all of them efficiently. Results: We propose a new characterization of precursor sets as the inputs of reaction sets called factories and an efficient algorithm to decide if a set of sources is precursor set of T. We show proofs of hardness for the problems of finding a precursor set of minimum size and of enumerating all minimal precursor sets T. We propose two new algorithms which, despite the hardness of the enumeration problem, allow to enumerate all minimal precursor sets in networks with up to 1000 reactions. Availability: Source code and datasets used in our benchmarks are freely available for download at
INTRODUCTIONWe recently introduced the concept of a minimal precursor set which corresponds to a set of metabolites that an organism may obtain from its environment and that enables it to produce a set of metabolic targets of interest (seefor the initial definition of this concept). In this model, we propose a definition of precursor set which does not consider the stoichiometry of reactions. Indeed, the values given for such stoichiometry may often not be accurate. For instance, 51% of the reactions in the Kyoto Encyclopedia of Genes and Genomes (KEGG) were considered to be unbalanced in 2004 () and solving these cases may become challenging for more complex reactions (). To overcome this problem, we propose instead a model based only on the topology of a metabolic network, that is that considers the set of substrates and products of each reaction without considering the amounts involved. The collection of precursor sets defined should therefore be considered as potential/candidate solutions which could be confirmed or discarded a posteriori by other sources of information. The method we developed into enumerate all minimal precursor sets for a given set of targets was then applied into a relatively complex symbiotic system. In this case, the environment was represented by an insect. Homalodisca coagulata, which hosts within its cells two bacteria, respectively, Baumannia cicadellinicola and Sulcia muelleri. The identification of the precursor sets for the sets of metabolites each bacterium gives to the symbiotic system (host and co-resident endocytobiont), enabled to refine the analysis that had been done previously () of the complementarity between the metabolisms of the two bacteria and their host. It also suggested that both B. cicadellinicola and S. muelleri might be completely independent of the metabolites output by the co-resident endocytobiont to produce the carbon backbone of the metabolites provided to the symbiotic system. The algorithms in Cottret et al. (2010a) and Cottret et al.(2008) suffered of a memory problem due to the necessity to construct a huge treecalled the 'replacement tree'. Moreover, the enumeration procedure followed using such a tree was not the most efficient way either to enumerate all minimal precursor sets. For small networks (5250 nodes), the previous method runs in a acceptable time, but for bigger networks it usually runs out of memory. In this article, we present new algorithms for enumerating all minimal precursor sets that address both memory requirements and time efficiency (Section 4). We also provide full proofs for the complexity results that were just indicated in(Section 3). We use for this a simpler characterization of a *To whom correspondence should be addressed. y The authors wish it to be known that, in their opinion, the first two authors should be regarded as joint First Authors.precursor set that makes the concept, and the subsequent proofs, formally easier to grasp (Section 2). Finally, we show by extensive tests that the new algorithms are indeed able to deal with much larger networks, up to 1000 reactions (Section 5).
DEFINITIONS AND CHARACTERIZATIONSA metabolic network is modelled as a directed hypergraph G  C; R with C the set of vertices corresponding to metabolites (also called compounds) and R the set of hyperarcs corresponding to reactions. A directed hyperarc of a reaction r 2 R is an ordered pair of metabolite sets r  Subsr; Prodr; where Subs(r) is the set of substrates of r and Prod(r) is the set of products of r. Reactions are supposed to be irreversible: each originally reversible reaction is replaced by two irreversible reactions of opposite direction. We consider also a set of sources S C representing the metabolites that are potentially available in infinite external supply. Sources used as substrates of reactions produce other metabolites, thereby increasing the set of available ones. In addition, the set T C denotes the target set, that is a set of metabolites that it is interesting to produce. Given a source set S and a target set T of metabolites, the aim is to find subsets of S which are able to produce all metabolites of T. We need now to formally define the meaning of: being able to produce the target. When stoichiometric information is missing or not (fully) reliable, two definitions have been proposed to model this concept that can give different solutions to a particular instance. Before comparing the two approaches, we introduce some notation. Let M be a set of metabolites of C. We define Reac(M) as the set of reactions that can be fired when the metabolites in M are present. In other words, ReacM  fr 2 R j Subsr Mg: For a given set of reactions R R, we define the sets SubsR  [ r2R Subsr and ProdR  [ r2R Prodr.
Sequencial production of the targetThe forward propagation of M, denoted by Fwd(M), is the set of metabolites successively produced from M using the reactions of the network. Formally, Fwd(M) is the result of the recursion M i1  M [ ProdReacM i  starting from M 0  M and until a fixed point is reached. For instance, in the network of, if M 0  fa; b; cg then M 1  fa; b; c; eg; M 2  fa; b; c; e; hg and so on until the fixed point fa, b, c, e, h, i, t} is reached. Thus, Fwd(fa, b, c})  fa, b, c, e, h, i, t}. Romero and Karp (2001) considered a subset X of the sources S as a precursor set of a target T, when T FwdX. For instance, the set of sources X  fa, b, c} is a precursor set of the target set T  ft} since Fwd(fa, b, c}) contains t. This iterative way to calculate what is available from X may however not be enough to model some real cases. Indeed, the network could have cycles whose metabolites need to be consumed and produced all at the same time. For instance, inreactions r 1 and r 2 form a cycle that consumes metabolites c and d to produce f and g. However, Fwd(fc, d})  fc, d}, that is it contains neither f nor g.
Including cycles in the target productionIn our work, we used the model proposed inwhich defines a precursor set using a different approach. Instead of starting the propagation from a subset of the sources, the authors allow from the beginning the inclusion of other metabolites (called internal supply) provided that such metabolites are produced by some reaction in a future step of the forward propagation (besides production of the target). Formally, the authors define Fwd Z M, the forward propagation of M with Z (as internal supply), as the result of the recursion M i1  M [ ProdReacM i [ Z starting from M 0  M and until a fixed point is reached. A subset X of the sources is a precursor set of T if T and Z are both included in Fwd Z X. For instance, in the network of, Fwd ffg fc; dg  fc; d; f; g; e; h; i; tg. Thus, it produces t but also re-produces f to maintain the cycle working. DEFINITION 1. A set of sources X S is a precursor set of T C if there exists a set Z C such that T [ Z Fwd Z X. In this case, we say that Z is an internal supply of the precursor set X. Of course, the internal supply may be not unique for a given precursor set. In, both Z  f f } and Z  fg} are internal supplies for the precursor set X  fc, d }. Observe also that any set of metabolites which is a precursor set by the Romero and Karp definition will continue being a precursor set for this definition just considering Z  ;. Suppose now that the target is a set of metabolites whose production we want to avoid. In this case, we can define the notion of a precursor cut set or simply cut set, that is a subset X of sources such that, if they are not present, then the target cannot be produced by any combination of the remaining sources. This concept has a biological application, for instance, in the case where we want a bacterium to avoid producing some given metabolite while providing it with a maximal set of resources that enables it to continue doing its other specific tasks. As an example, in, the set fa, d} is a cut set of ft}. DEFINITION 2. A set of sources X S is a cut set of T C if and only if the set S n X is not a precursor set of T.If the target contains more than one metabolite, a cut will avoid the production of the whole target set but could stillAlgorithms and complexity of enumerating minimal precursor sets produce some of their elements (a strict subset of T). If we want to block each element of the target, we can modify slightly the network in the following way: given T  ft 1 ;. .. ; t ' g, we can define a new target metabolite t target and reactions r t1 ;. .. ; r t' with Subsr ti   ft i g and Prodr ti   ft target g. Clearly, a cut set of the new target T 0  ft target g must block the production of each metabolite in T.
New characterization using factoriesWe give now a simpler and more natural way to grasp the characterization of a precursor set X of T by considering, instead of metabolites, a set of reactions F R that connects X with T. Clearly, the reactions must verify these two properties: 1. (Feasibility of reactions) Each substrate of the reactions in F is contained in X or is produced by some reaction in F; 2. (Production of target) Each metabolite in the target T (which is not in X) is produced by some reaction in F.These two conditions can be summarized in one: T [ SubsF X [ ProdF. In this case, we say that F is a factory from X to T. THEOREM 1. A set of sources X S is a precursor set of T C if and only if there exists a factory from X to T. PROOF. If X is a precursor set of T, there exists Z C such that T [ Z Fwd Z X  X [ ProdReacFwd Z X. The set of reactions F  ReacFwd Z X is such that T X [ ProdF and SubsF Fwd Z X X [ ProdF. Therefore, F is a factory from X to T. Inversely, let F be a set of reactions such that T [ SubsF X [ ProdF. Defining Z  Subs(F), we have Fwd Z X  X [ Prod ReacFwd Z X [ SubsF which clearly contains X [ ProdF. Therefore, T [ Z Fwd Z X. oeIn the example of, the set fc, d} is a precursor set of ft}, since the set of reactions F  fr 1 ; r 2 ; r 3 ; r 6 g is such that ftg [ fc; d; f; g; hg fc; dg [ ff; g; h; i; tg.
COMPLEXITY RESULTSGiven a metabolic network G  C; R with S C a set of sources and T C a set of target metabolites, we address the theoretical complexity of the following three problems: MINIMALPS(T): find a minimal precursor set X S of T. MINSIZEPS(T): find a minimum size precursor set X S of T. ALLPS(T): enumerate all minimal precursor sets X S of T.We also consider the analogous problems where what is searched are precursor cut sets: MINIMALPCS, MINSIZEPCS and ALLPCS.
Finding a minimal precursor set and a minimal cut setGiven a set X S of sources, we can compute the maximal set of reactions F max that satisfy the first condition of the factory definition (feasibility of reactions). Thus, to decide whether X is a precursor set of a given T, we can compute F max of X and check whether T is included in the products of F max. To obtain this set, we use the following recursion: starting from the whole set of reactions F 0  R, compute the set F i1  ReacX [ ProdF i  until a fixed point is reached. Defining K  max r2R jSubsrj  jProdrj, we have the following result. THEOREM 2. Given a subset X S of sources and a target set T C, we can decide in polynomial time OjCjjRj  jRj 2 K whether X is a precursor set of T. PROOF. We show the maximality of F max. Let F 0 be another set of reactions such that SubsF 0  X [ ProdF 0 . Clearly, if F 0 F i then F 0 ReacX [ ProdF 0  ReacX [ ProdF i   F i1 , Since we start with F 0  R, we conclude that F 0 F max .The algorithm iterates at most jRj  jF max j times. Computing F i takes OjCj  jRjK time. Therefore, the running time of the whole procedure is OjCjjRj  jRj 2 K. oeThis method provides also a way to find a minimal precursor set of T. Starting from X  S, we successively check if removing a metabolite of X the target is still produced, maintaining in X only those that are needed to produce T. We obtain a minimal precursor set in jSj iterations. A similar procedure is also valid to find a minimal cut set starting from X 0  ; and adding sources while the target is not produced. The set X  S n X 0 is a minimal cut set. COROLLARY 3. Both MINIMALPS(T) and MINIMALPCS(T) can be solved in polynomial time OjCjjRjjSj  jRj 2 jSjK.
Minimum size precursor set and cut setAlthough finding one minimal precursor set of a target is easy, obtaining a (minimal) precursor set of minimum size is NP-hard. This result is proved by a reduction from the NP-complete problem HITTINGSET (): given a finite set of elements U and a collection of subsets I  fI 1 ;. .. ; I n g of U, find a minimum cardinality subset of elements H U such that H intersects all the subsets in I. THEOREM 4. The problem MINSIZEPS(T) is NP-hard. PROOF. We show hardness by proving completeness of the decision version where we ask if a precursor set of size at most k exists. Theorem 2 implies that this decision version is in NP.We make a polynomial time reduction from the decision version of HITTINGSET, asking if there exists a hitting set of size at most k. Consider H; I and k a hitting set instance with I  fI 1 ;. .. ; I n g. For each element h in H, we create a vertex h in C, and for each set I j in I , we create a vertex I j in C (). We create an extra vertex t in C. For each h 2 I j , we create in R an arc r hj going from h to I j. Moreover, we create the hyperarc r t having Subsr t   fI 1 ;. .. ; I n g and Prodr t   ftg. We define t to be the only target metabolite, and we define the vertices corresponding to the elements of H as the sources S of G. oeObserve that in the above reduction, there is a one-to-one relation between hitting sets and precursor sets, and a related pair is of the same size. This implies that MINSIZEPS is as hard to approximate in polynomial time as HITTINGSET, which is known to be APX-hard (). Namely, no polynomial time algorithm for MINSIZEPS can have approximation ratio olog n unless P  NP ().A similar proof shows NP-hardness for the problem of finding a minimum size cut set. We consider in this case the same reduction but with two modifications (, left): (i) replace the hyperarc r t (from fI 1 ;. .. ; I n g to t) by n separate reactions, from each I j to t, for j 2 f1;. .. ; ng and (ii) replace, for each I j , the set of reactions producing I j by a single reaction r j producing I j from the whole set of elements of I j. In this case, each hitting set corresponds to a cut set. Therefore, MINSIZEPCS(T) is NP-hard and APX-hard. Related hardness results are as follows:PROPOSITION 5. Given a precursor set X of T, the following two problems are NP-hard: 1. Find a minimum cardinality set of metabolites Z such that Z is an internal supply of X.2. Find a minimum cardinality set of reactions F such that F is a factory from X to T. PROOF. We modify the reduction presented in the proof of Theorem 4 as follows (, right): for each element h in H, we create another extra vertex h 0 in C, and two reactions r hh 0 and r h 0 h from h to h 0 and from h 0 to h, respectively, the set of sources S is empty and the remaining of the construction stays the same. It is easy to see that the only minimal precursor set of T is the empty set. Using similar arguments as in the previous reduction, we have that any possible set Z corresponds to a hitting set. Analogously, any possible factory F corresponds also to a hitting set. oe
Enumerating all minimal precursor sets and cut setsWe showed that MINIMALPSG; S; T can be solved in polynomial time. Nevertheless, if we are interested in finding all minimal precursor sets of T, the number of solutions can grow exponentially. We are therefore interested in knowing whether ALLPS can be solved in polynomial total time, that is, polynomial in the size of the input and output (). Given a boolean ^; _formula f (that is with no negation), a prime implicant is a minimal set of variables such that if they are all TRUE then f is TRUE (for instance, fp, s} is a prime implicant of f  p _ q ^ r _ p ^ s ^ s ). Enumerating the set of all prime implicants of f cannot be done in polynomial total time unless P  NP (). We show that this problem can be reduced to ALLPS. THEOREM 6. The enumeration problem ALLPS cannot be solved in polynomial total time unless P  NP. PROOF. Let f be an ^; _-formula. The set C of metabolites corresponds to the set of variables plus one metabolite for each conjunction and disjunction inside the formula (). The sources are the metabolites corresponding to each single variable. The set of hyperarcs is as follows: for each metabolite representing a conjunction c in f, there is a single hyperarc from the clauses of c to the metabolite c, and for each metabolite representing a disjunction d, there are arcs from each term of d to the metabolite d. The target set is a singleton containing the metabolite representing f. Clearly, a minimal precursor set of T corresponds to a prime implicant of f and vice versa. oeObserve that the reduction holds even in the case of networks without cycles (for any reasonable definition of cycle). This result is also valid if we consider the enumeration of all minimal precursor cut sets of T. Indeed, in the reduction of Theorem 6, a minimal cut set corresponds exactly to a prime implicate of the boolean function f, that is to a minimal set of variables such that if all are FALSE then f is FALSE. As for prime implicants, enumerating the set of prime implicates cannot be done in polynomial total time unless PNP (). Thus, the enumeration problem ALLPCS cannot be solved in polynomial total time unless P  NP.
Simultaneous enumeration of precursor sets and cut setsAlthough enumeration of minimal precursor sets and enumeration of minimal cut sets are both hard problems, we now show that the enumeration of both problems simultaneously can be done in quasi-polynomial total time (that is in time N OlogN c  for some c fixed and N the size of the input and output). Indeed, we can represent any set of sources X S as a vector of f0; 1g jSj. We denote by P T the collection of all minimal precursor sets ofAlgorithms and complexity of enumerating minimal precursor sets T, and by C T the collection of all minimal cut sets of T. We define the function F : f0; 1g jSj ! f0; 1g as F(X)  1 if X is a precursor set of T and F(X)  0 otherwise. It is easy to see that F is a monotone boolean function (although it is not explicitly expressed as a conjunction and disjunction of literals) whose prime implicants are exactly P T and whose prime implicates are exactly C T. In Gurvich and Khachiyan (1999), the authors show an incremental method to enumerate both prime implicants and prime implicates of a monotone boolean function at the same time. Roughly, given a collection P 0 [ C 0 of solutions already found (with P 0 P T and C 0 C T ), the method finds a set X S such that X is not superset of any minimal precursor set in P 0 and S n X is not superset of any minimal cut set in C 0. Since either X is a precursor set or S n X is a cut set, we have found a new solution not in P 0 [ C 0. The algorithm finds this new solution in On  n  m Olog m , where n is the number of variables, m the number of solutions already found and is the time to compute the value F(X). By Theorem 2, is OjCjjRj  jRj 2 K. Therefore, given m solutions in P T [ C T , we can obtain a new solution in time OjSjjCj 2  jSjjCjjRjK  jSj 2   m Olog m. COROLLARY 7. The collections P T and C T can be jointly enumerated in quasi-polynomial incremental (and hence total) time.Observe that applying the same method to enumerate only one collection (i.e. discarding the solutions of the other) can be very inefficient. Some instances can have exponentially more cut sets than precursor sets (that is jP T j5 5jC T j), and thus obtaining all precursor sets can take more than quasi-polynomial time compared with jP T j. Analogously, there are instances where jC T j5 5jP T j. In the next section, we present algorithms to enumerate all precursors sets by taking advantage of the network topology.
PRECURSOR SETS ENUMERATIONWe present two new algorithms that compute the collection of all minimal precursor sets of a target set T. To facilitate the exposition, we suppose that the metabolic network studied has the following properties: (i) each source x 2 S is not produced by any reaction and (ii) each reaction belongs to at least one factory from the sources to the target. It is not difficult to see that by applying the following steps, we transform any network in order to satisfy these conditions without changing the collection of precursor sets of a target T: 1. Sources are not products: rename as x 0 each x in S that is the product of at least one reaction. Then, add a new reaction with substrate a new metabolite labelled x and product x 0. The set of sources continues to be S.2. All reactions in a factory: compute the maximal factory (see proof of Theorem 2) and remove all reactions in the complement. Remove all unconnected metabolites.
Backtracking from the target to the sourcesThe general approach to enumerate P T (the collection of all minimal precursor sets of T) proceeds by backtracking: starting from the target, the method performs a kind of depth-first search on the hypergraph using reactions in opposite direction. In this way, the factories that produce T starting from any minimal source sets are covered. Since we are considering hyperarcs, each factory is composed by more than one path of the depth-first search from the target to the sources. We thus obtain the whole set of solutions only at the end of the algorithm, when all paths have been travelled. A similar idea was already presented in. The algorithm PITUFO was proposed to enumerate all minimal precursor sets by building a replacement tree which represented all paths obtained by going from T to the sources by using the reactions in reverse order. In a second step, this tree was compacted from the sources to the target until it reaches depth 2, on which the solutions were easily recognizable. The main problem of this method is the huge amount of memory needed to build the replacement tree, which made the algorithm useful only for small networks.
Decomposing into subproblemsWe decompose the problem into subproblems where each subproblem has M as target set. Starting from M : T, two kinds of subproblem decompositions are successively applied: 1. Target decomposition: given a target M  fm 1 ;. .. ; m k g and X a precursor set of M, then X can be written as X  [ k i1 X i , where each X i is a precursor set of M i  fm i g. Thus, we can enumerate P M by enumerating P fmg (the minimal precursor sets of fm}) for each metabolite m 2 M and taking all the corresponding unions of solution sets (one set from each collection). 2. Reaction decomposition: if the target is a singleton M  fm} and r 1 ;. .. ; r ' is the set of all reactions producing m (which is not empty if m is not a source), then X is a precursor set of M if and only if X is a precursor set of some M i  Subsr i  with i 2 f1;. .. ; 'g. Thus, to enumerate P fmg , we can enumerate P Subsr for all the reactions r that produce m, and then take the union of the collections.In both decompositions, solutions are obtained after discarding the possible non-minimal sets obtained. Successively alternating these decompositions, the aim is to have subproblems where the target is a singleton source fs}, which has the set fs} itself as the only precursor set, that is P fsg  ffsgg.
Including available metabolites in the inputThe difficulty in implementing the above described approach is given by the presence of cycles in the network. Indeed, cycles can make the algorithm enter into an endless loop. For this reason, we must include explicitly in the input of the subproblems the set of available metabolites, that is the metabolites already analysed in previous steps of the algorithm. In this way, we can avoid continuing the search for precursor sets of these metabolites. Thus, given a set A of available metabolites, we conveniently consider the following generalization of the precursor set definition. DEFINITION 3. Given a set of sources S, a target M and a set A of available metabolites, we say that a set X S is a precursor set of M when A is available if there is a factory from X [ A to M. Observe that, if P M A denotes the collection of all precursor sets of M when A is available, then P T ; is exactly the collection of all minimal precursor sets of T. Thus, starting from T and having A  ; available, we successively apply the target and reaction decompositions increasing, at each step, the set of available metabolites. We finally need to solve the subproblems P fmg A which are composed of one of these two base cases:(a) m is available: if m is in A, then P fmg A contains only the empty set as element, i.e. P fmg A  f;g.(b) m is not available but is a source: if m 2 S n A, then P fmg A  ffmgg.
Increasing the set of available metabolitesWe show how the set of available metabolites can be increased in each subproblem decomposition. Observe that increasing the set A of available metabolites is not only necessary to avoid cycling. The bigger is this set, the shorter are the factories that produce the given target when A is available, that is we can arrive faster to the base case (a). Thus, in each decomposition, we try to maximize the set of available metabolites that can be added without changing the solution of the original problem. As mentioned before, to enumerate the collection P M A, we can enumerate the collections P fmig A for each m i 2 M and compute all possible unions of its elements (one from each collection). In fact, in the enumeration of the solutions of P fmig A, we can include as available any other metabolite in M different from m i , that is P fmig A [ M n fm i g. Indeed, we know that these metabolites will be produced by the precursor sets given by the other parallel subproblems called. In the next lemma, for a given collection of sets X, minimalis the collection of all sets of X that are not supersets of any other set of X. LEMMA 8. Given the sets M  fm 1 ;. .. ; m ' g C and A C, we have the following relation:PROOF. Given X 2 P M A, there is a factory F such that M [ SubsF X [ A [ ProdF. Therefore, fm i g[ SubsF X [ A [ ProdF for all m i 2 M. Adding M n fm i g to the right side, we conclude that F is a factory from X [ M n fm i g [ A to fm i g for all m i 2 M.Conversely, given for all m i 2 M the sets X i 2 P fmig M n fm i g [ A, there exist sets F i such thatIn the case of reaction decomposition, computation of P fmg A (when we are not in one of the base cases) requires to compute P Subsr A for any reaction r producing m. Clearly, since r produces m, we can include m as available in the subproblems, that is P Subsr A [ fmg (which avoids getting into an endless loop). Furthermore, we can also include any other product of r, that is P Subsr ALEMMA 9. Given m 2 C and A C, if m = 2 S [ A, then we have the following relation:PROOF. Consider X 2 S and F R such that Subsr [ SubsF A [ Prodr [ X [ ProdF. Since m 2 Prodr, we have fmg [ Subsfrg [ F A [ X [ Prodfrg [ F. Hence, frg [ F is a factory from A [ X to fm}. Conversely, consider and F R a factory from X [ A to the target fm}. Then, F must contain a reaction r that produces m. Therefore, Subsr [ SubsF  SubsF A [ X [ ProdF A [ Prodr [ X [ ProdF. F is also a factory from X [ A [ Prodr to Subs(r). Hence, the collection of sets X having a factory from X [ A to the target fm} is the same as the collection of sets of X having a factory from X [ Prodr [ A to Subs(r) for any r producing m. By considering minimality on each side, we conclude the proof. oe
Pruning solutions by minimalityWhile performing reaction decomposition, there might exist reactions that can be a priori discarded because they do not give any minimal solution. Indeed, if r and r 0 produce m, and furthermore if the set of substrates of r that are not in A is a subset of the set of substrates of r 0 that are not in A, then for any solution to the subproblem defined on Subsr 0 , we have a solution smaller or equal on Subs(r). In other words, any solution given by r 0 is not minimal or is included in the solutions given by r. Therefore, we can avoid computing P Subsr 0  Prodr 0  [ A without losing minimal precursor sets. LEMMA 10. Let r and r 0 be two reactions producing m such thatBy hypothesis, Subsr Subsr 0  [ A, and then we can add Subs(r) to the left side of the previous equation: Subsr [ SubsF [ fr 0 g [ A A [ X 0 [ ProdF [ fr 0 g. By removing the union of A on the left and adding the union of Prod(r) on the right, we obtain Subsr [ SubsF [ fr 0 g A [ Prodr [X 0 [ ProdF [ fr 0 g. In other words, F [ fr 0 g is a factory from A [ Prodr [ X 0 to Subs(r). We conclude that there exists X X such that X 2 P Subsr ProdrThus, if we compute the solutions of P fmg A by using Lemma 9, we can first compute Subsr n A for all reactions r producing m and not consider those reactions where this set is not minimal.
Algorithms and complexity of enumerating minimal precursor sets
Algorithm TRD: targetreaction decompositionOur first algorithm, called TRD, consists in successively applying target and reaction decompositions using the procedures TDecomp and RDecomp below until reaching the base cases. The first method uses the subroutine CrossUnions(U, P m ) that computes the collection of all unions of one set of U and one set of P m. Running TDecomp(M, A), we obtain exactly all the minimal precursor sets of M when A is available. Algorithm TRD is therefore given by the execution of TDecomp(T,;). TDecomp(M C; A C): U : fg; For each metabolite m 2 M do If m is in A then P m : fg else if m is in S then P m : fmg else P m : RDecomp(m, A [ M n fmg);Return the collection minimalP.
Including factories as pseudo-reactionsA main limitation of TRD is the following. Method RDecomp(m, A) outputs all precursor sets of fm} when A is available. This means that, if X is a set included in the output, we know that there exists a factory from X [ A to fm}. If RDecomp is called again as a subproblem on the same metabolite m with a similar available set A 0 , then most of the successive decompositions will be repeated again until the base cases are reached. In this sense, the algorithm has no memory about the factories previously computed. We propose a new algorithm that, each time that a decomposition is finished, includes this information in the network by adding pseudo-reactions representing the previously computed factories. For instance, if in the network there is a factory from X [ A to fm} given by reactions r 1 and r 2 , then we include a pseudo-reaction r 12 with Subs r 12   X [ A and Prod r 12   fmg. Clearly, this operation is safe: the precursor sets of T do not change. Moreover, we do not want to lose the information about the remaining of the metabolites produced by the factory, which are used to increment the set A of available metabolites. For this reason, we associate to each pseudo-reaction r a set Int r of internal available metabolites which contains any metabolite produced by the reactions represented by r. Thus, if we use this reaction in a future decomposition, we can consider this set as available. If we define Intr  Prodr for any original reaction r of the network, then we do not need to distinguish between reactions and pseudo-reactions. In the previous example, we have then that Int r 12
Reaction replacementAdding new pseudo-reactions to the network decreases the number of reactions of the factories from X to fm}. However, to really decrease the time, we need to ensure that the algorithm will not consider again the original factory. Otherwise, if m is revisited, the algorithm would analyse both the original factory and the new one containing the new added reactions. To avoid this, we delete the original reaction producing m but while guaranteeing that the collection of minimal precursor sets of T is maintained. Suppose that we want to delete a reaction r producing m. Notice that any factory from X to m that contains r must also contain at least one reaction producing each substrate of r (except the sources). Thus, if r is merged with each set of such reactions then r can be removed without modifying the minimal precursor sets. More formally, given a reaction r, we say that a set of reactions R is a predecessor reaction set of r, if R produces all the substrates of r that are not sources, that is ProdR Subsr n S. Let R min r be the collection of all minimal predecessor reaction sets of r. Clearly, any factory containing r must also contain a set R 2 R min r. The following method Replace(r) removes reaction r and adds pseudo-reactions corresponding to the merge of r with every reaction set R 2 R min r (). Replace(r 2 R) Compute R min r  minfR R j ProdR Subsr n Sg; For each set R 2 R min do Add a new reaction r R to the network with Prod r R  : Prodr, Int r R  : IntR. Example of the application of Replace to reaction r 0. Left: reaction r 0 has internal production m and f (enclosed in a rectangle). The substrates of r 0 are s (which is a source), a and b. The collection R min r 0  contains the minimal sets of reactions that produce a and b, that is R min r 0   fr 1 ; r 3 g; fr 2 ; r 3 g. Right: we replace r 0 by new reactions corresponding to the merge of r 0 to each set of reactions of R min r 0 . Thus, reaction r 0 is replaced by reactions r 013 and r 023. Notice that the substrates of r 013 do not include substrates of r 3 since they are internally produced by r 1 and r 0 .
V.Acu a et al.LEMMA 11. Let r 2 R be a reaction of the network G and let G 0 be the network that results from applying the procedure Replace(r). Then, X is a precursor set of T in G if and only if X is a precursor set of T in G 0. PROOF. The factories in G which do not include r are factories also in G 0. Let F R be a factory from X to T in G which contains r. Clearly, F must contain a set R 2 R min r. Thus, the set F 0  F [ f r R g n frg is a factory from X to T in G 0. Conversely, if F 0 is a factory from X to T in G 0 containing the set R new  f r R1 ;. .. ; r Rk g of new reactions added by Replace(r), then F  F 0 n R new  [ frg [ S k i1 R i is a factory from X to T in G. oe
Algorithm NS: network shortcuttingWe define a new algorithm ns to compute all precursor sets of a target T based on reaction replacement. The following preprocessing of the network is required: a new metabolite t and a new reaction r t are created, such that Subsr t   T and Prodr t   ftg. Clearly, the minimal precursor sets of ft} are exactly the minimal precursor sets of T. Starting from r : r t , NS traverses the network in the same way that TRD does. However, instead of computing the minimal solutions, NS goes deep in the recursion until finding a reaction r satisfying the following two conditions: (a) not all substrates of r are in the base cases and (b) all substrates of all reactions in the next level of the recursion are in the base cases. When such a reaction is found, then it is replaced by new reactions. Successively removing and adding reactions in this way, we decrease the size of the factories from S to ft}. Finally, the last reaction removed is r t which is replaced by new reactions producing t and having only sources as substrates. The substrates of each reaction correspond exactly to a minimal precursor set of ft}. Running NS(r t ; ;) we obtain a network where the minimal precursor sets are exactly the substrate sets of all the reactions that produce t. The network can also contain many other reactions, but they are not even connected to t. NS(r 0 2 R; A C): M : Subsr 0 ; If M contains a metabolite not in A [ S then For each metabolite m 2 M n A [ S do NewA : A [ M n fmg; For each r producing m with Subsr n NewA minimal do NS(r, NewA [ Intr); Replace(r 0 );
PERFORMANCE ANALYSISExtensive tests were performed in order to measure the performance of the different algorithms on real metabolic networks. These algorithms were compared for several different singleton target sets (for instance, amino-acids, metabolites related to the synthesis of the cell wall, DNA, RNA, membranes, etc.) in seven networks of different sizes and topologies downloaded from MetExplore (). Ubiquitous metabolites were filtered out and the split reactions using pairs of co-factors option was chosen. We adopted an automatic process to define the set of sources based on the topology of the network. A metabolite m is considered a source if it satisfies one of these two conditions: (a) m is not the product of any reaction or (b) m is involved in only two reactions corresponding to both directions of an originally reversible reaction (i.e. m is substrate in one and product in the other). The target sets were chosen based on their role: amino-acids, metabolites related to the synthesis of the cell wall or DNA, etc.
Removing bad cyclesThere are some cycles that we know a priori that are not realistic since they are able to produce compounds outside the cycle without the need of any input. In particular, the two directions of an originally reversible reaction form a cycle which can produce its metabolites without using any external source. These bad cycles must be avoided in factories since they may create fake solutions in which an empty set of metabolites produces the target. In order to avoid bad cycles in factories, we preprocess the input network breaking this kind of cycles by removing some reactions. Specifically, starting from a set M of metabolites containing only the target and an empty set R of reactions, we include in R a randomly chosen reaction producing a metabolite of M unless its inclusion generates a bad cycle. The substrates of the added reactions are included in M. Successively repeating this process we obtain a network with no bad cycles. Notice that this process corresponds to a heuristic whose result depends on the order in which reactions are chosen to be included in R.presents an extract of the results for PITUFO, the algorithm described inand the two different algorithms described in this article (TRD and NS) with and without the test of minimality. The targets presented are those for which finding the minimal precursor sets required more time for the new algorithms with minimality check. The table shows, for each network, the size of the sets of metabolites and reactions, and for each target, the size of the preprocessed network, the number of precursor sets found and the time in seconds that each algorithm spent. All algorithms have been implemented in Java and the running times were collected using a cluster for the computation and setting a limit of 1 GB of RAM memory for each process. Although PITUFO may be fast for small networks, its use is limited since, as the size of the networks grows, the method takes a long time to finish, and for some targets, it does not finish in the given time limit of 24 h. This already justifies the new methods presented in this work, since they do not present the same behaviour for larger networks. Concerning the minimality check, we may observe that it is not necessarily true that it improves the running time. In some cases, doing the check may even lead to worse results (example Yeast, target FADH2, NS method), while in others it may have a strong positive impact on the execution time of the algorithm which becomes 700 times faster (example, Escherichia coli, target L-aspartate, TRD method).
Benchmarks
Algorithms and complexity of enumerating minimal precursor setsNotice also that as the size and complexity of the networks increase, the number of different minimal precursor sets found increases also, and it does this at a rate faster than the increase of the time needed to compute them.
Computing solutions for several preprocessed networksAs mentioned before, the network free of bad cycles that is given by the heuristic proposed depends on the order in which reactions are added to R. Thus, different orders can generate different minimal precursor sets. To recover as many solutions as possible, we can repeat the search for precursors on several different results of the preprocessing part. In order to analyse the effect of this heuristic on the algorithms, we successively repeated this random process while computing, at each repetition, the number of new precursor sets obtained. The process stopsAll methods were applied to the same preprocessed network on each target. In the cases marked '*', the algorithm did not finish within 24 h. For each target, the size of metabolites and reactions after bad cycle deletion is indicated.Each iteration corresponds to repeating the heuristical random preprocessing and computing the minimal precursor sets using trd with minimality. For each target, we show the iteration where the convergence is reached, the time required, the total number of different minimal precursor sets (at the convergence), and the iterations in which a given percentage of this total number of solutions is recovered.
V.Acu a et al.when no new precursor set is recovered in 10 consecutive repetitions. Analysing the results for three different targets of E. coli, this convergence criterium was reached in5100 iterations. In the three cases, 450% of the solutions were recovered in the first six repetitions and 480% in the first 50 iterations ().
CONCLUSIONDespite the proved hardness of enumerating all precursor sets of a given target, the algorithms presented in this article can find all solutions for networks of up to around a 1000 reactions. If we restrict ourselves to the benchmark built for this article, the TRD method with minimality check is the one that presented the best behaviour on average. However, the methods vary widely depending on the target chosen. Our benchmark does not allow us to conclude which algorithm has a better performance between TRD with a minimality test and NS with and without minimality test for bigger networks. This justifies the utility of each method individually and leaves an open space for further improvements. Funding: This work was partially funded by the following projects: the French project ANR MIRI BLAN08-1335497, the French project ANR NEMO ANR-08-BLAN-0304-01, the ERC Advanced Grant Sisyphe held by Marie-France Sagot, the INRIA Associated Team SIMBIOSI, the INRIA International Partnership AMICI, the Dutch NWO-CLS MEMESA project and the Chilean FONDAP 15090007 project. Conflict of Interest: none declared.
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
V.Acu a et al.
