Motivation: We introduce Pycellerator, a Python library for reading Cellerator arrow notation from standard text files, conversion to differential equations, generating stand-alone Python solvers, and optionally running and plotting the solutions. All of the original Cellerator arrows, which represent reactions ranging from mass action, Michales–Menten–Henri (MMH) and Gene-Regulation (GRN) to Monod–Wyman–Changeaux (MWC), user defined reactions and enzymatic expansions (KMech), were previously represented with the Mathematica extended character set. These are now typed as reaction-like commands in ASCII text files that are read by Pycellerator, which includes a Python command line interface (CLI), a Python application programming interface (API) and an iPython notebook interface. Results: Cellerator reaction arrows are now input in text files. The arrows are parsed by Pycellerator and translated into differential equations in Python, and Python code is automatically generated to solve the system. Time courses are produced by executing the auto-generated Python code. Users have full freedom to modify the solver and utilize the complete set of standard Python tools. The new libraries are completely independent of the old Cellerator software and do not require Mathematica. Availability and implementation: All software is available (GPL) from the github repository at https://github.com/biomathman/pycellerator/releases. Details, including installation instructions and a glossary of acronyms and terms, are given in the Supplementary information.
IntroductionCellerator describes biological interactions with a reaction-like arrow-based input language. Input strings are converted into differential equations and integrated to produce numerical time-course predictions using Mathematica (). Extensions include Cellzilla for two-dimensional tissue simulation () and KMech for exact enzymatic expansion (). There are many tools that convert reactions to differential equations and solve them, particularly in Python, but they do not use an arrow-based language in the same manner as Cellerator. Examples include PySCeS (), which has its own text modeling language; PyDSTool () (for hybrid systems); and pybrn (pybrn.sf.net, for SBML-like structures). Perhaps the closest conceptually to Pycellerator are PySB () and SBML shorthand (). PySB is a rule-based system with a collection of text language rules that are merged into Python commands; models are built as Python programs. SBML Shorthand is not a simulator; it is a pre-processor for converting models into SBML, in which each reaction is represented by a single line of text. In addition, a number of popular stochastic simulation tools are also implemented in Python.Pycellerator also provides a simulation, modelling, programming and analysis interface. In Pycellerator the modelling language corresponds to (and extends) the arrow language introduced in Cellerator. Each arrow corresponds to a Cellerator arrow, but it can now by reprsented with ASCII arrow-like characters. The Pycellerator library provides a command line interface (CLI), an application programming interface (API) and an iPython notebook interface (), so that users have a choice of Python programming environments. Mathematica is not required.
ApproachSimulations require a model file (Supplementary), which is a text file divided up into sections representing reactions, rate constants, initial conditions and functions. Alternatively, models may be generated from (or saved as) SBML () or as legacy Mathematica files. The model is parsed, converted to differential equations and Python code is generated to perform the simulation. This auto-generated code may either be run and plotted within the notebook () or from the command line, and is a completely stand-alone program (Supplementary).Additional text forms exist for all Cellerator arrows, e.g. catalyzed reactions, MMH, Hill, S-systems, GRN, user-defined arrows and all KMech reactions (see Supplementary Tables S1S3). Built-in functions allow the user to inspect the differential equations, generate simulation code and run a simulation or parameter scan. In addition, standard Python packages (e.g. pyplot, numpy, scipy, sympy) can be used to analyze the results of the simulation.
MethodsThe work flow is summarized in Supplementary. Input files are parsed using the pyparsing package, which allows the grammar to be specified in BNF. Reactions are converted into a Python reaction class that is used for all subsequent data processing. Conversion into differential equations utilizes the sympy symbolic processing package. Flux models use pulp, the Python linear programming toolkit. Simulation code is generated and saved as a Python program using the odeint solver in scipy. This solver is a wrapper for LSODA () and automatically switches between stiff (BDF) and non-stiff (Adams) methods, depending on the nature of the problem. The user has full access to the code and can change any desired parameter of the solver. This stand-alone code can be run as a separate program from the command line, wrapped within another program, or run automatically using eval. Default is to output a numpy array.
DiscussionPycellerator variables may be specified using an array index notation to represent multiple compartments or multi-stage cascades. A possible future extension to the software would be two and three dimensional tissue based implementations similar to Cellzilla (). Dynamical grammars can also be implemented using a more expressive notation that makes this modelling paradigm significantly more powerful (). Rule-based models, graph grammars and hybrid systems, for example, could be automaticallygenerated using the techniques we have described here.
ConclusionThe Cellerator arrow notation for specifying biological interactions has been implemented in a human-readable text-based language. Parsers could be written in any language. Extensible open source Python libraries are provided for CLI, API and notebook support. The iPython notebook provides Pycellerator with a very convenient front end for modelers who want to combine code, text, markup and figures together in single documents. This is particularly useful for training researchers. The libraries can be used either as a frontend to produce or interact with other solvers or as end-user solvers in of themselves.. Sample output (cutoff) for simulating oscillations in a MAP kinase cascade. This model is structurally identical to () with two modifications: time-dependent input and a competitive feedback reaction. A similar model was proposed by (), and oscillations have been observed in yeast by (). The model file and output code are shown in Supplementary Figures S1 and S4
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
B.E.Shapiro and E.Mjolsness at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
