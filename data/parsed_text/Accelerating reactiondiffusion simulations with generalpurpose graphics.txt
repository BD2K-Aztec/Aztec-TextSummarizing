We present a massively parallel stochastic simulation algorithm (SSA) for reaction-diffusion systems implemented on Graphics Processing Units (GPUs). These are designated chips optimized to process a high number of floating point operations in parallel, rendering them well-suited for a range of scientific high-performance computations. Newer GPU generations provide a high-level programming interface which turns them into General-Purpose Graphics Processing Units (GPGPUs). Our SSA exploits GPGPU architecture to achieve a performance gain of two orders of magnitude over the fastest existing implementations on conventional hardware. Availability: The software is freely available at
INTRODUCTIONTreating chemical reaction systems as spatially homogeneous is insufficient for many applications in a biological context. Often, spatial distributions play an important role in the dynamic evolution of biomolecular systems. The analysis of such systems requires accurate yet highly performant simulation algorithms that can handle spatially inhomogeneous reactiondiffusion (). Unfortunately, stochastic simulation methods for this problem are computationally extremely expensive and it thus becomes necessary to build parallel versions of existing algorithms (). GPGPUs can potentially provide high-performance computing resources to a broad audience and are consequently becoming increasingly popular for scientific computing. In the present article, we present a data-parallel GPGPU implementation of an SSA, which achieves significant performance gains over the fastest conventional implementations. To the best of our knowledge, this is the first time that a data-parallel GPGPU implementation of a quantitative SSA for spatially heterogeneous reaction-diffusion networks is reported. Several approaches to compute the stochastic time evolution of reactiondiffusion networks can be found in the literature, such as agent-based models (), first-passage kinetic * To whom correspondence should be addressed. Monte Carlo algorithms () or, on a mesoscopic level, compartment-based models, such as the Next-Subvolume Method (NSM) (). Not all these methods lend themselves equally well to a dataparallel implementation on GPGPUs. The standard algorithms, based on Gillespie's next reaction method (), perform an event-based simulation in which global communication is required to compute the next event time as well as to determine the corresponding reaction. Due to the high cost of global synchronization and inter-node communication, attempts to implement the Gillespie SSA directly on GPGPUs could only yield moderate performance gains (). Petzold andpursue a different approach by running many instances of the same model in parallel on a GPGPU. This technique allows immediate parallelization of sequential algorithms but cannot speed up individual runs and can thus only exploit the full hardware potential if a large number of simulations are required. For a full parallelization, methods that treat diffusion seperately from reactions appear to be more promising. Such methods are termed hybrid. One can distinguish between deterministic stochastic algorithms, where diffusion is handled in a deterministic manner (), and stochasticstochastic methods, which are preferable for cases where the diffusive species is not necessarily present in high densities. Two prominent examples of the latter type of hybrid algorithms are the Gillespie Multiparticle Method (GMP), first presented by, and the Multinomial Simulation Algorithm (MSA) (). In this article, we report a GPGPU implementation of GMP. Hybrid stochastic reactiondiffusion algorithms are an active and relatively recent field of research and no clear champion has emerged yet. Cellular automata methods are widely used to simulate reactiondiffusion systemsfor a comprehensive review]. In particular, the multiparticle lattice gas algorithm underlying GMP () has been successfully applied, for example, to problems in electrochemistry (). Its applicability to biochemical pathways has been shown in a number of studies, e.g. for the phosphoenolpyruvatedependent phosphotransferase (PTS) pathway in Escherichia coli (). We believe that MSA should in principle be just as well suited for a data-parallel implementation. However, the free availability of the source code made GMP our first choice. A detailed comparison of computational methods for reaction diffusion networks is given by. For completeness, we point out that the deterministic treatment of reactiondiffusion equations with GPGPUs has a long history in the context of computer graphics. The driving motivation behind
Reactiondiffusion simulations with GPGPUsthese efforts is to realistically reproduce naturally occuring textures, for example of animals 1 or skin desease effects. 2 Likewise, agentbased reactiondiffusion simulations on GPUs have been performed before (), but here the focus is, in contrast to our work, generally not on exact quantitative studies.
IMPLEMENTATION AND PERFORMANCEA detailed description of the algorithm and our parallelization approach can be found in the Supplementary Material. Here we can only give a brief overview. The computational domain of dimensionality d is divided into equally spaced, cubical subvolumes with sidelength . Each subvolume contains a number of particles of each species, which are assumed to be distributed homogeneously within the subvolume. In each time step, the diffusion part is treated separately from the reaction algorithm. This approach is termed operator-splitting (). During each diffusion time step t, every subvolume independently handles all reactions employing the standard direct method () until the simulation time for that particular subvolume exceeds t. One diffusion step is then simulated by redistributing particles among neighbouring subvolumes according to a probabilistic evolution rule whichproved to asymptotically reproduce the macroscopic diffusion equation.demonstrated that this method correctly reproduces the literature results for a generic gene expression model and a phosphoenolpyruvate:glucose phosphotransferase system. We parallelize this algorithm by assigning one thread to each subvolume of the computational domain. Each GPU thread executes the same C function, termed a kernel, at the same time. Threads are arranged into independent blocks, which cannot be synchronized globally. Blocks of threads implicitly divide the computational domain into rectangular spatial areas. Threads corresponding to subvolumes at the boundaries of such areas must communicate across blocks to exchange particles in a diffusion event. We need to return from the kernel to the host function to synchronize globally across block boundaries. The main loop is thus executed on the CPU once per diffusion time step t. It calls three different kernels on the GPU. After choosing the species to be diffused next, we first perform the reactions for each subvolume independently in the Gillespie kernel before diffusing the corresponding species in the Diffusion kernel. Finally, we need to update the block boundaries in the Update kernel. Implementation details of the kernels can be found in the Supplementary Material. We evaluate the performance gain of our implementation by comparing it to MesoRD (), the stochastic simulation compiler (SSC) (), which is a very efficient implementation of an SSA, and a serial implementation of GMP (). We use two different setups to perform the scaling tests: a diffusion problem without reactions and an A+B annihilation problem. We initialize both on a quadratic domain and vary the number of subvolumes per dimension, while keeping the subvolume size constant (for a detailed explanation of the problems and parameters see the Supplementary Material). The serial code (MesoRD and GMP) is compiled with GCC 4.4.INTEL E6550 dual core CPU at 2.33 GHz using the Linux operating system UBUNTU (Version 10.04 LTS). We run GPGMP on our GPU cluster (equipped with NVIDIA Tesla S1070 GPUs) and an ordinary workstation (an Apple MacBookPro with an Intel Core2 Duo CPU running at 2.5 GHz and a GeForce 8600M GT graphics card).shows the run time (in ms) for SSC (green, upward triangles), MesoRD (blue circles), serial GMP (magenta, downward triangles), GPGMP run on our GPU cluster (red squares), and GPGMP run on a workstation (red pentagons). GPGMP scales very well with the number of subvolumes. The Tesla T10 processor consists of 240 cores but, due to the thread-scheduling algorithm, no significant speed loss occurs until the total number of subvolumes exceeds 10 6. For the diffusion problem (left panel), with an integration domain consisting of 1024  1024 subvolumes, GPGMP outperforms the serial GMP implementation by a factor of 35. A test run with 4096  4096 subvolumes only takes about eight times longer than the same setup with 10241024 subvolumes. No comparison data can be given for this case, because the other implementations are unable to deal with such a large system size. We report similar speed gains for the homogeneous A+B annihilation problem (). GPGMP outperforms serial GMP by a factor of 39 and MesoRD by 175. However, these speed gains can be lower if the problem is highly inhomogeneous and the workload is unevenly shared between all GPU threads. On a workstation, GPGMP performs slightly better than on the GPU cluster for low number of subvolumes (N 10 5 ) but saturates earlier. For high N 10 5 , the Tesla T10 processor on the cluster outperforms the workstation graphics card. The initial performance advantage of the standard workstation appears to be due to the fact that its CPU is superior to the cluster node CPU and that the proportion of the workload performed by the CPU becomes negligible only for large subvolume numbers. GPGMP scales with the number of subvolumes N as expected. For low N 10 4 , the runtime decreases with increasing N since the total workload (combined reaction and diffusion events) is shared among more threads. For 10 4 N 10 6 , the total runtime plateaus until the number of concurrently running threads saturates and the runtime scales linearly with N. Note again that the saturation point is higher than the number of GPU cores (240 for a Tesla T10 GPU) Page: 290 288290
and run on an
A B
M.Vigelius et al.
sincethe the thread scheduler is very effective in hiding memoryaccess latency. After saturation, GPGMP scales linearly with N. On the other hand, MesoRD behaves as O(logN) and the runtime benefit of GPGMP decreases with increasing N. The saturation point can of course be shifted to higher N by using hardware with a larger number of cores, for example the next-generation NVIDIA Fermi architecture.
DISCUSSIONWe have described an implementation of the Gillespie Multiparticle Method (GMP) on GPGPUs. We report performance gains of two orders of magnitude compared with standard implementations of the (exact) inhomogeneous stochastic simulation algorithm and the (hybrid) serial implementation of GMP. Like any other hybrid method, GMP sacrifices some numerical accuracy for performance gains. This trade-off can in principle be arbitrarily adjusted through the choice of the diffusion time step. For a more detailed discussion, we refer the reader to Section 2.2.7 of the Supplementary Material. We provide a full simulation system (Inchman) that allows the user to run their models without any coding (on the Monash Sun Grid GPU cluster). Access to this system is via an easy-to-use web interface 3 that understands systems biology markup language (SBML) specifications, the lingua franca of systems biology. In addition, we provide a full implementation of the algorithm on our website. Researchers may use the C++ interface to construct their own reaction-diffusion model from scratch. The application programming interface (API) is designed to mimic the structure of SBML models, allowing the user to easily convert their models into GPGMP without having to deal with the internal details of the simulation algorithm. A variety of test problems that can be used as templates are part of the package. The full source code is included so the user can easily add the relevant GPU implementation into their own projects. Most scientific applications require a reasonable sample size to extract statistic information from the simulations. It is therefore necessary to perform multiple runs of the same problem, possibly with varying input parameters. We pursue a 2-fold approach to tackle this requirement. First, the standard implementation of GPGMP distributes the total number of runs over all available GPGPU cards. This works best if the host machine provides a one-to-one ratio of CPU cores to GPGPU cards. Second, we are integrating Inchman with Nimrod, 4 a toolkit to allow users to run parameter sweeps and parameter optimization and distribute runs over GPGPU clusters. This will become an integral part of the next release of Inchman.
The Author 2010. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
http://www.sci.utah.edu/~allen/reaction-diffusion.html 2 http://developer.download.nvidia.com/SDK/9.5/Samples/samples.html
at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
http://www.csse.monash.edu.au/~berndm/inchman/ 4 https://messagelab.monash.edu.au/Nimrod Our implementation is currently limited to a constant diffusivity and vanishing drift field. We are working on extending the algorithm to incorporate spatially inhomogeneous diffusivity and drift. Funding: Australian Research Council (ARC DP0879239). Conflict of Interest: none declared.
