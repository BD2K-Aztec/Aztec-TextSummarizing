Motivation: RNA sequence design is studied at least as long as the classical folding problem. Although for the latter the functional fold of an RNA molecule is to be found, inverse folding tries to identify RNA sequences that fold into a function-specific target structure. In combination with RNA-based biotechnology and synthetic biology, reliable RNA sequence design becomes a crucial step to generate novel biochemical components. Results: In this article, the computational tool antaRNA is presented. It is capable of compiling RNA sequences for a given structure that comply in addition with an adjustable full range objective GC-content distribution, specific sequence constraints and additional fuzzy structure constraints. antaRNA applies ant colony optimization meta-heuristics and its superior performance is shown on a biological datasets. Availability and implementation:
IntroductionEngineered RNA molecules are of growing importance with applications ranging from biotechnology to medicine and synthetic biology. In biotechnology, several applications use engineered RNAs as scaffolds to optimize reactions or to deliver drugs. For example, RNA aptamers can serve as protein-docking sites within scaffolds to organize intracellular reactions (). Or the bacteriophage phi29 DNA packaging motor can be used to generate RNA nanoparticles for delivering therapeutic compounds (). However, biotechnology applications are not restricted to scaffold design, but often involve intriguing RNA-based pathways. For instance, Penchovsky and Breaker (2005) computationally designed ribozymes to sense oligonucleotides. Last but not least, the application of the CRISPR/cas9 system for genetic engineering is emerging and complementing the well established RNAi technology. This requires the design of specific RNA-molecules, see the review of Terns and Terns (2014). Another important and growing area is RNA synthetic biology, as reviewed in (). Design examples include RNA-based regulators of translation (), a general, RNA-based framework for microbial engineering on the level of DNA, protein or mRNA (), sRNA-based cellular circuits (), the improvement of functional sRNAs by scaffold engineering () or the de novo design of synthetic, transcriptional riboswitches (). Many of these approaches use rational design, based on a secondary structure model of the targeted RNA molecule, and an increasing number of applications use computational methods for filtering the initial design. In principle, this is an instance of the inverse folding problem, which consists of finding a sequence that fits some secondary structure constraints. RNAinverse () pursues seed sequence generation with a subsequent optimization based on local search. The objective function is either to V C The Author 2015. Published by Oxford University Press.
3114This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/4.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com3121 doi: 10.1093/bioinformatics/btv319
Advance Access Publication Date: 27 May 2015 Original Papermaximize the similarity of the minimum free energy (MFE) structure to the target, or to maximize the probability of the target structure in the ensemble. Several other programs follow the idea of RNAinverse and try to provide better strategies for either finding seed sequences or the local refinement step. For instance, in InFoRNA () the seeding was improved by generating a sequence that is maximally stable for the target structure and thus has high probability to fold into that structure. RNA-SSD () extends this by using stochastic local search. In more recent approaches, new strategies have been used in order to find sequence solutions: NUPACK () is using efficient ensemble defect optimization; RNAfbinv () employs simulated annealing for a fragment-based design; fRNAkenstein () applies a genetic algorithm approach. Similarly, the approach by, MODENA () and ERD () also apply evolution inspired principles to solve the inverse folding problem. There are two necessary conditions an up-to-date inverse folding tool must fulfill. First, the tool must be able to handle sequence constraints, in order to capture specific elements like a ligand binding pocket in riboswitches or RNA aptamers binding a specific protein. This is provided by most methods available. But second, the tool has to provide a sequence with a defined guanine-cytosine (GC)-content since the GC-content has drastic influence on the function of the designed molecule. For example, it is known that CRISPR/cas9 elements with too low or too high GC-content do not function optimally (). Another example is given in (), where the authors engineered an RNAbased regulatory activator system for bacterial gene expression. They report that altering the GC-content and further increasing the stability of the designed element did result in a 19-fold activation. In contrast to this biological requirements, most of the first generation tools have an intrinsic GC-bias () that cannot be compensated by GC-filtering (see Supplementary Material). Recently, programs have been developed, which allow to declare a target GC-value or to constrain the GC-range for solution sequences. So far, the only known tools providing this functionality are RNASSD (), IncaRNAtion (), which is a seed sequence generator for RNAinverse, and RNAiFold (), a constraint programming approach. Here we introduce antaRNA, which uses the ant colony optimization (ACO) meta heuristic to solve the inverse folding problem of RNA to produce sequences with controlled target GCcomposition. Furthermore, sequence constraints are incorporated. Accessorily, the introduction and application of implicit structure constraints allows a design principle that enables the declaration of RNA structure in a 'fuzzy' mode. Sequences designed by antaRNA show high agreement of their MFE-structures with the targeted structures independently of the additional objective GC-content constraints.
MethodsantaRNA is based on the ACO heuristic, which was already successfully applied to solve a broad collection of classical optimization problems, such as routing (), scheduling (), assignment (), subset partitioning/clustering (), constraint satisfaction (), classification rules () and Bayesian networks (). Also directly biologically motivated problems such as protein structure folding () and docking simulations () as well as RNA secondary structure prediction methods () have been investigated with ACO. Generally, ACO is a self-adjusting local search strategy, which automatically adapts to the specific problem instance optimized. Because RNA structure formation is very sensitive to sequence changes, ACO should be able to learn the importance of local sequence features, which is an essential aspect when solving the RNA inverse folding problem. Thus in the following, we present the adaptation of ACO to the RNA inverse folding problem and describe the necessary basic RNA notations to subsequently describe the algorithm. The algorithm is depicted on a conceptual level. Please consult the supplement material for more detailed formal definitions.
Ant colony behaviorAnts, while foraging for food or exploring new terrain, use pheromones to indicate the quality of a certain path on their return. They apply a quality-dependent amount of pheromone to the just examined path (), while the quantity is defined by many (here abstracted) factors according to the situation: Does the path yield food? Is the amount of food large/small? What is the quality of the food? Other ants sense the pheromone on a path and are influenced in their decision whether to follow the same path or to continue exploring new paths (). The pheromone itself evaporates over time, such that, if no ant follows the indicated path and renews its pheromone trail, the path becomes 'silent' or 'unknown' to the colony (). The general principle of ACO (Dorigo and St tzle, 2004;) simulates an ant colony and its foraging behavior on a modeled terrain to solve optimization problems. Here, ACO is incorporated and exerted to the problem of RNA inverse folding to generate RNA sequences, which are optimized to fold into a targeted structure under additional constraints. In the developed application, the ants of a colony walk subsequently over the simulated terrain and assemble and evaluate RNA solution sequences. According to the quality of each solution, the solution generating parts of the terrain are marked with pheromone, such that the information of prior solutions contributes to the decisions of subsequent ants. Each pheromone update also covers 'environmental' exposure of the whole terrain, i.e. globally the pheromone information evaporates with a certain rate. Over time, one pheromone trail will dominate the terrain and will indicate the best solution, which is in accordance with the user defined constraints. The underlaying ACO principle of antaRNA is depicted within Algorithm 1. antaRNA: ant colony-based RNA sequence design
RNA inputThe aim of the heuristic is to obtain an RNA sequence S that is comprised of n nucleotides. Each sequence position S 1. .. S n derives from the RNA nucleotide alphabet R  fA; C; G; Ug. A base pair (i, j) is an interaction, in which hydrogen bonds between two nucleotides at sequence positions S i and S j within the sequence S were established. antaRNA considers canonical Watson-Crick and G-U base pairs. A set of base pairs defines a secondary structure P  fi; jji < jg of S. We consider only nested secondary structures, i.e. all base pairs fulfill 6 9i; j; k; l 2 P : i < k < j < l. In addition, a minimal loop size of 3 is enforced, i.e. 8i; j 2 P : j  i > 3. The user can define three types of constraints: The structure constraint C str is used to provide the explicit and implicit secondary structure constraints, which is encoded in an extended dot-bracket notation. The explicitly targeted structure parts define the base pairs and single stranded positions that have to be formed as they are defined. If the definition of an explicit structure is too rigid for a design problem, more 'fuzzy' implicit structural constraints can be encoded to restrict base interactions to specific regions. Those regions can be declared by capital letters within the extended dotbracket string. One region does not necessarily have to be formed by consecutive positions, but can also stretch over two or more disjoint areas (see). All base pairs emerging in the same type of region (same letter) are implicitly allowed and not penalized during structural distance evaluation (as discussed later). The sequence constraint C seq can restrict certain sequence positions to specific nucleotides. Furthermore, the GC-content constraint C GC 2 0; 1 provides the targeted GC-ratio within the sequence.
ACO of inverse-folded RNAantaRNADuring the optimization a large set of sequences S is assembled. The best solution sequence S sol is returned, if a termination criterion is reached. In order to obtain a sequence S, the ants search sequentially in the simulated terrain represented as a directed graph T  V; E. Each ant investigates one terrain path, which corresponds to a sequence assembly based on the visited vertices. The set of vertices V contains a non-emitting start vertex v and nucleotide (s 2 R) emitting vertices v is for each sequence position S i. These are connected by the set of directed edges E V  V, where each edge e is;js  v is ; v js 0  2 E resembles an available path within the terrain. The vertices v 1s are accessible from the start vertex v while vertices v is (1 < i n) can be reached from all preceding nucleotide emitting vertices v i1s. Each edge holds pheromonic (s) and heuristic (g) information. The resulting terrain graph contains jVj  1  jRjn vertices and jEj  jRj  jRj 2 n  1 edges when optimizing a sequence of length n.illustrates the composition of the terrain graph T.
Solution generation
Graph initializationBecause each solution sequences S is assembled by the ants according to the information embedded within the terrain, the terrain must encode the requested constraints. The constraint information is split into the dynamic pheromonic s and the static heuristic g contribution of the edges. Herein, we define the pheromonic contingent to be controlled by the structure and sequence constraints, C str and C seq , whereas the heuristic part is encoding the targeted GC-content C GC. The weight of an edge is the sum of both contingents weighted by two parameter a and b, respectively. The pheromone s initialization is of binary character. The pheromone value of an edge e is;js 0  is set to 0, if the emitted nucleotide s of the target vertex v js 0 is not in accordance with the sequence constraint C seq j at position j. Otherwise, we set se is;js 0    1. Note, we also encode implicit sequence constraints that arise from the combination of C str and C seq as follows. If a position is constrained by a specific nucleotide, e.g. C seq i  U, and also part of an explicitly requested base pair i; j 2 C str , we derive an implicit complementarity sequence constraint for the pairing partner, in our example C seq j 2 fA; Gg. The heuristic information g is defined for all edges with s > 0 by a target GC-content C GC dependent static edge weighting. Hereby, a differentiation between edges leading to AU-emitting nodes v jfAUg and edges leading to GC-emitting nodes v jfGCg is enabled. The heuristic contribution of an edge is defined by the deviation of C GC from a basis GC-value of 50% and depends on the edge's target node.
Sequence assemblyEach ant compiles a solution sequence S. This is achieved by the ant's walk over the terrain. Starting from vertex v , n edges are traversed and n vertices in the graph are visited. An edge e is;js 0  is selected according to it's probability pe is;js 0  . The probability of an edge is the relative weight of its terrain information among all edges originating in its start vertex v is , as given in Equation (1).. Terrain T  V; E: Starting from vertex v, an ant selects probabilitydependent an outgoing edge until it reaches a final node v ns. Hereby, all visited vertices v is emit the encoded nucleotide s to the respective sequence position S i. The assembled solution sequence S is evaluated and the pheromone information of the corresponding path in the graph is updated according to the solution's qualityEach visited vertex v is emits its assigned nucleotide, i.e. the solution sequence position is updated by S i  s (see).
Sequence evaluationThe actual evaluation of the assembled sequence is done via a combination of different measures: a structural distance d str , a GCcontent aberration distance d GC and a sequence distance d seq are transformed into a score, with which the terrain is updated. The structural distance d str computation is based on the program RNAfold of the ViennaRNA-package v2.1.3 (). In a first step RNAfold calculates the MFE-structure P sol of the sequence S. Given P sol , next a solution dependent target structure P C is composed, since C str allows for explicit and implicit structure constraints. Initially, P C contains all explicitly requested base pairs from C str. In the following, the handling of lonely base pairs, implicit structure constraint and sequence constraint contributions are discussed. During the evaluation, explicitly requested lonely base pairs are temporarily removed from P C , since they are usually energetically unfavorable and thus counteract the MFE-based design principle. For their 'soft' integration into the design, a distance penalty is added for each lonely base pair that cannot be formed by the current solution sequence S. Lonely '2 base pair stacks' are handled equivalently for the same reason. The 'fuzzy' implicit structure constraint allows for all base pairs that are within one of its defined regions (see). Thus, all base pairs of the current solution structure P sol that are confined to such blocks of implicit structure are temporarily added to the target structure P C. Finally, in some cases, the sequence constraint C seq induces base pairs under certain structural folding context. If both positions S i and S j of a base pair of the current solution i; j 2 P sol are constrained by C seq , this base pair is added to the target structure P C. In a final step, the length-normalized base pair distance d str between P sol and the compiled target structure P C is determined. The GC-aberration d GC between the objective and the actual GC-content of S is determined by subtracting the actual from the target GC value. Due to the discrete nature of sequence lengths, it is often not possible to precisely reach the objective GC-content C GC. Thus, sequence length dependent correction terms are added to the actual GC value for d GC computation. The sequence constraint distance d seq encodes the violation of the sequence constraint C seq given the current solution sequence S. It reflects the ratio of sequence positions that do not respect C seq. The overall quality score Q of the sequence's features is the weighted sum of the inverted distance measures. Thus, lower distances result in higher quality estimates.
Pheromone updateGiven the quality Q of a solution S, the pheromone information of the solution-associated edges in the terrain graph is increased by Q. Hereby, only those edges are rewarded that correspond to positions where the structure information is identical between the resulting solution P sol and the target structure P C. In order to limit the memorization and influence of previous solutions, a global evaporation of pheromone is applied. According to the evaporation rate q, the pheromone information of all edges is reduced. The pheromone information encodes the compliance of paths in the terrain with all constraints. This way, the solution sequence assembly of subsequent ants is tuned towards correct sequence designs, since the local decisions are based on the combination of pheromone and heuristic information (see earlier).
TerminationAlthough the ants walk over the terrain, edges, which have been involved in good solutions get promoted over those, which have not contributed to good solutions. This solidifying behavior results in convergence towards optimal or suboptimal quality in respect to the given constraints. antaRNA uses three termination criteria to stop the ACO: maximal number of generated solutions, a termination potential and a reset potential. The termination potential is initialized and increased every time subsequent solutions show a structural distance of zero. As soon as a termination threshold is exceeded, the algorithm is stopped and the best solution according to Q is returned. Another possibility to terminate is based on a maximal number of internal terrain resets. The terrain and all initial values are reset, if the reset potential exceeds the reset threshold. The reset potential is increased, if the structural distance of a current solution is not zero but the GC quality is within a margin of the momentarily best solution, i.e. d GC 1:5  d bestSoFar GC .
DatasetsThe underlaying dataset of this study is an extract from the Rfam database v11.0 (). A training subset has been used to evaluate and adjust antaRNA's parameters. A distinct and larger test set was used to benchmark and compare antaRNA with other tools. We evaluated the behavior of the algorithms concerning different complexities of structure and sequence constraints and their influence and impact on the solution sequences and their characteristics. For each selected Rfam family, structure and sequence information of conserved positions within the respective Rfam family's seed alignment were extracted to define C str and C seq. We applied the following protocol to derive the dataset. For each Rfam seed-alignment with at least 20 entries, the shortest ungapped sequence was selected. Subsequently, the alignment's consensus structure was mapped to that sequence. The obtained structure defines the explicit structure constraint C str. No implicit structural constraints were derived. We further ensured a minimal structural confinement, i.e. a family was discarded, if the fraction of base pair forming positions within C str was below 20%. For each position i within such a structure, a sequence constraint C seq i was set depending on a minimal conservation ratio MR. If a nucleotide in the according column of the seed alignment shows a relative abundance larger than MR, the nucleotide is used as sequence constraint. Otherwise, the position is unconstrained (C seq i  N). A family-specific MR threshold was used such that the fraction of C seq-constrained sequence positions was in the range of 2030%. The GC-content of the C seq-constrained positions was not allowed to exceed 15%, to ensure enough flexibility within the sequence constraint to reach the targeted GC-values of the benchmark. In total, this resulted in 83 derived targets from the Rfam database. The lengths of the obtained constraints range from 34 to 274 nucleotides with varying constraint complexities. The training subset contains constraints with lengths not longer than 200 nucleotides and length differences of at least five nucleotides to the rest of all antaRNA: ant colony-based RNA sequence designtraining set members. The remaining entities define the test set. The training set contains 20, the test set 63 entities. Further information about the sets can be found in the (Supplementary Materials).
Results and DiscussionIn order to identify the best default parameter values and to study their robustness, we investigated antaRNA performance for various settings using a grid search on the training data set. Within the grid search we optimized: the weighting factors a and b of the path weight computation, the evaporation rate q, the three distance weighting factors for solution quality Q calculation, and the termination parameters (see Supplementary Materials for details). For each parameter setting, we designed for each test set family 10 sequences with and without sequence constraint C seq targeting three different objective target GC values C GC of 25, 50 and 75%. The resulting 1200 sequences (20  10  2  3) were used to calculated a benchmark score for the parameterization. The score sums the mean structural distance, the mean GC aberration and a mean of the normalized runtime, i.e. it is in the range 0; 3. The parameter set with the lowest score (0.219) was chosen as default parameter set for antaRNA and was used for all following comparisons. The values are listed in the Supplementary Material.
Targeting arbitrary GC-content distributionsThe parameter optimization revealed for antaRNA a high precision concerning targeted GC values while it also robustly fulfills structural and sequence constraints. Thus, we investigated antaRNA's potential to produce pools of sequences, whose GC values are resembling a user defined distribution rather than a single value. A possible application is the design of sequences that show a GCdistribution similar to prototype sequences or the organism of interest. Here, the application is exemplified and tested for a uniform (1540% GC-content) and a normal distribution (l  60%; s  6%) and compared with a fixed value (70%) sampling. For each given GC-content target distribution, a set of individual target GC values is sampled from the distribution and antaRNA is run for each.presents the results. In all three cases, the achieved distributions agree very well with their respective targets. Only the single target shows a small bias towards lower GC-content values.Distribution distortions derive from the limited sample size and the aforementioned length-dependence of achievable GC value (see GC distance computation).
Comparison to existing toolsAll recent RNA inverse folding tools are able to design sequences for a given structure with or without sequence constraints. In contrast to that, RNA-SSD, IncaRNAtion and RNAiFold are, beside antaRNA, the only known tools so far that can also constrain the GC-content at the same time. Here, we compare IncaRNAtion, RNAiFold and antaRNA and benchmark their design quality for various target GC values with and without sequence constraints using our test dataset. RNA-SSD is not included into this comparison, since Reinharz et al. (2013) have shown its inferiority compared with IncaRNAtion. Please note, the presented RNAiFold data has been kindly computed externally by the maintainers of RNAiFold, since a local installation and application was not possible. antaRNA and IncaRNAtion have been run locally on the same computer cluster. Note further, RNAiFold is based on the ViennaRNA-package v1.8.5. Hence, we used the same version to compute the MFEstructures in order to evaluate the structural distance d str of the corresponding predictions. Both, antaRNA and IncaRNAtion employ the ViennaRNA-package v2.1.3 that was applied for d str evaluation accordingly. Finally, RNAiFold requires the definition of an allowed range around the targeted GC value, which was set to 2% to ensure correct designs. Due to these different setups, only limited comparisons can be made. For each structural constraint C str , three different objective GCcontent target values C GC 2 f25; 50; 75%g have been addressed in this benchmark, each targeted with and without sequence constraint C seq. To illustrate length-dependencies, the test dataset was separated into length categories (L1:1100, L2:101200 and L3:201 300 nucleotides) for visualization. Each tool was executed 100 times per constraint set, to enable statistics. Different time limitations were used: maximal 1 hour for RNAiFold and 10 min for antaRNA/ IncaRNAtion per single sequence design. We observe a length dependency for the runtimes of antaRNA and IncaRNAtion (see Supplementary Materials), i.e. longer sequences require more time, which is expected. The current antaRNA implementation is about one order of magnitude slower compared with IncaRNAtion. This might result from the different programming languages used. antaRNA is completely encoded in Python, while IncaRNAtion uses the C-based RNAinverse for the time expensive optimization and only generates seed sequences in Python. A runtime comparison to RNAiFold is not possible due to the external computations. When investigating the effect of sequence constraints on runtime, we observe a target GC dependency. Although predictions with low target GC values (25%) seem to be slightly faster when sequence constraints are applied, the countereffect is observed for high GC target values (75%). For moderate GC-values no effect is found. We encountered strong differences in the success rate of the different tools, i.e. the rate of successful design attempts that produce a solution sequence within the given time limits. Both antaRNA and IncaRNAtion always provide a solution sequence, independent from time limits, since they are heuristic optimization approaches that successively improve solutions. RNAiFold, in contrast, is based on constraint programming techniques, which produce only solutions that completely comply with all given constraints. Otherwise no solution is produced at all. Furthermore, solution generation in. The 75% target value can be found on the right side. The respective achieved values are given as histograms: uniform distribution (left/1), gaussian distribution (middle/2), and single target GC value (right/3) constraint programming frameworks strongly depends on the used search heuristics, which directly influence the runtime behavior.depicts the limited success rates for RNAiFold. It becomes clear that some constraint sets seem to be too confining to enable a sequence design for RNAiFold within 1 h. Notably, for some categories the tool fails completely in its design attempts. To evaluate the tools' structure and sequence compliances, we compare the individual distributions of structural distances d str , GC aberrations d GC and sequence distances d seq .summarizes the measured structural distances d str for all three tools. If no sequence constraint is applied, all tools show a very good compliance with the target structure. When sequence constraints are applied, the tools show different behaviors. antaRNA still shows d str medians of 0 deviation; except for the L3 sequences, where the median is 2 and the upper quartile is about 4. In comparison, the deviations of IncaRNAtion always show a median of $2%, but their upper quartiles vary between 2 and 4%. With increasing target GC values, IncaRNAtion shows increasing variance in its distributions. RNAiFold also exhibits good structure compliance in the sequence constrained cases, if solution sequences have been returned. In the case of C GC  75% and 50%, RNAiFold fails to return sequences () that fulfill the specified constraints.presents the observed GC aberrations d GC. The sequences designed by antaRNA show a very good target C GC compliance (mean jd GC j  0:02%). Only for the extreme setting C GC  75% including sequence constraints C seq , the median d GC drops to 0.7% and the corresponding lower quartile is at 1.8%. The results for RNAiFold are all within the allowed 2% variance around the respective C GC while it slightly deviates in almost all cases (mean jd GC j  0:7%). Almost all IncaRNAtion designs do not fulfill the target C GC constraint (mean jd GC j  7:1%). Only one constraint set (C GC  50%, no C seq ) shows a d GC median of zero. All sets show wide distributions (interquartile ranges are about 58% d GC ) and in most cases the interquartile range does not even come close the targeted C GC. In extreme cases, the d GC median deviate up to 10%. The sequence constraints C seq are completely respected by antaRNA and RNAiFold. Both only design sequences that totally comply with the respective C seq (d seq  0). The sequences designed by IncaRNAtion do not always comply with their constraints (mean d seq  0:9%; data not shown). So far, we only studied the constraint compliance of the designed sequences. In the following, we evaluate the sequence diversity of the designed sequences. This is an important feature to enable further successive filtering of the designs, e.g. for experimental use. To this end, we computed the mean Shannon-Entropy for each sequence position over all according sequences. Positions constrained by C seq have been excluded. The resulting mean mononucleotide entropy is presented infor designs with and without C seq. Here, a high entropy implies that for unconstrained positions, most of the possible sequence combinations have been used. Low entropy implies a sequence bias, which is a undesired feature for a design tool. antaRNA shows the highest entropy if no sequence constraint is applied, followed by IncaRNAtion. This is swapped in the presence of C seq , but still very high for both tools. antaRNA sequences have a mean entropy of 1.95 (of maximally 2) in the sequence unconstrained setup and 1.72 among C seq-constrained sequences. For IncaRNAtion the respective values are 1.87 and 1.77. Thus, both tools produce very diverse sequences. In contrast, RNAiFold shows mean entropy of 1.01 in the unconstrained setup and 0.9 for sequence constrained instances. In general, the respective entropies decline, if sequence constraints are applied. A manual inspection of the sequences produced by RNAiFold revealed stretches of common subsequences, which is depicted by dinucleotide entropies in). That is, instead of single positions the entropy of neighbored position pairs was measured. Again, IncaRNAtion and antaRNA both show high entropy values (>3 of maximally 4) with and without sequence constraints revealing the same relations observed for mononucleotide entropy. That is, both tools show high diversity also concerning dinucleotides. In contrast, the dinucleotide entropies of RNAiFold range below 2 bits, indicating that the respective sequences have a bias towards common subsequences. Furthermore, note that the dinucleotide entropy is in relation even lower compared with the mononucleotide entropy, which even highlights the observation. We expect this to be an artifact of the constraint programming framework applied within RNAiFold.
ConclusionWithin this work we present antaRNA, which solves the RNA inverse folding problem for given secondary structures under additional side constraints using an ACO approach. Besides the explicit target structure features, specific target GC-content values, sequence constraints, and newly developed implicit structural constraints are incorporated and presented. Target GC-content constraints allow to request sequences with a desired specific GC-content or from arbitrary controlled GC-content distributions, while the latter is unique to antaRNA. The results show that the tool produces on averageantaRNA: ant colony-based RNA sequence designsequences that exactly show the targeted GC-content, even when additional sequence constraints are enforced. The MFE-structures of the designed sequences respect the provided structural constraints for almost all targets tested. This holds for a broad range of targeted GC values with and without sequence constraints. The program was optimized, compared and evaluated on various sets of constraints derived from the Rfam database. The assessment revealed the superior quality of antaRNA produced sequences over IncaRNAtion and RNAiFold. The prime feature of a sequence and its biological functionality is the structure. Thus, it should be the central objective for sequence design tools. IncaRNAtion does not achieve this objective and produced on average high structural distances in our experiments. Although it was tailored to enable specific GC-content optimization, it also shows poor performance in fulfilling the targeted GC values. Only its high-sequence diversity partially outperforms other compared methods. IncaRNAtion applies a two stage-optimization approach that first produces GCoptimized seed sequences that are subsequently optimized towards the target structure by RNAinverse. Thus, often the GC-unaware RNAinverse MFE-structure optimization counters the GCoptimization. In contrast, the sequences designed by RNAiFold and antaRNA show both very good structural as well as GC compliance. Although qualitative comparable on the level of constraint violation, the tools show significant differences concerning reliability and sequence diversity. RNAiFold is not always producing sequence solutions within the allowed runtime. This might be due to the used constraint programming techniques and results in missing sequence designs for many constraint sets. In contrast, antaRNA is based on ACO and applies a parallel optimization of all constraints. Thus, it always reports a solution sequence with no qualitative loss. Furthermore, antaRNA produces more diverse sequence sets compared with RNAiFold, which shows a trend to non-diverse subsequences. Summarizing, the capability of antaRNA to reliably produce highly diverse sequences for a given structure, coupled with the precise GC targeting, will help to explore the sequence space for RNA design problems. The introduced implicit structure constraints enable the user to define parts of the structure in a very vague way. This can be of use when the structural context of a specific design target is less important as long as it does not interact with the important and maybe explicitly defined structure domains. The improvement and application of the 'fuzzy' constraint concept (e.g. details about position or constraint type specific weighting) is a focus of our ongoing work. In total, the results are promising and encourage further work, which will include runtime optimization e.g. based on parallelization approaches. In addition, the implicit structure constraint is of great use in future work when modeling multi-structure constraints or pseudo-knot structures. Furthermore, improving and developing new internal scoring mechanisms and evaluation patterns is subject of ongoing work, such that the tool can also handle more complex input structures and their constraints in an adequate way. This inevitably results in potentially new parameter setups for which we have to update our understanding of their synergistic effects on antaRNA.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
R.Kleinkauf et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
