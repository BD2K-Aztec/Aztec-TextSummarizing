Motivation: Rapid advances in next-generation sequencing (NGS) technology have led to exponential increase in the amount of genomic information. However, NGS reads contain far more errors than data from traditional sequencing methods, and downstream genomic analysis results can be improved by correcting the errors. Unfortunately, all the previous error correction methods required a large amount of memory, making it unsuitable to process reads from large genomes with commodity computers. Results: We present a novel algorithm that produces accurate correction results with much less memory compared with previous solutions. The algorithm, named BLoom-filter-based Error correction Solution for high-throughput Sequencing reads (BLESS), uses a single minimum-sized Bloom filter, and is also able to tolerate a higher false-positive rate, thus allowing us to correct errors with a 40Ã‚ memory usage reduction on average compared with previous methods. Meanwhile, BLESS can extend reads like DNA assemblers to correct errors at the end of reads. Evaluations using real and simulated reads showed that BLESS could generate more accurate results than existing solutions. After errors were corrected using BLESS, 69% of initially unaligned reads could be aligned correctly. Additionally, de novo assembly results became 50% longer with 66% fewer assembly errors.
INTRODUCTIONRecent advances in next-generation sequencing (NGS) technologies have made it possible to rapidly generate high-throughput data at a much lower cost than traditional Sanger sequencing technology (). NGS technologies enable cost-efficient genomic applications, including de novo assembly of many non-model organisms (), identifying functional elements in genomes (), and finding variations within a population (). In addition to short read length, a main challenge in analyzing NGS data is its higher error rate than traditional sequencing technology (), and it has been demonstrated that error correction can improve the quality of genome assembly () and population genomics analysis (). Previous error correction methods can be divided into four major categories (): (i) k-mer spectrum-based (), (ii) suffix tree-/array-based (, b), (iii) multiple sequence alignment (MSA)-based () and (iv) hidden Markov model (HMM)-based (). However, none of these previous methods has successfully corrected errors in NGS reads from large genomes without consuming a large amount of memory that is not accessible to most researchers (see detailed discussions in the Supplementary Methods). Previous evaluations showed that some error correction tools require4128 gigabyte (GB) of memory to correct errors in genomes with 120 Mb, and the others need tens of GB of memory (). For a human genome, previous approaches would need hundreds of GB of memory. Even if a computer with hundreds of GB of memory is available, running such memoryhungry tools degrades the efficiency of the computer. While the error correction tool runs, we cannot do any other job using the computer if most of the memory is occupied by the error correction tool. This can be a critical problem for data centers, where a large amount of data should be processed in parallel. In several works, Bloom filters () or counting Bloom filters () were used to save a k-mer spectrum, which includes all the strings of length k (i.e. k-mers) that exist more than a certain number of times in reads (, b). Although Bloom filter is a memory-efficient data structure, the memory reduction by previous Bloom filter-based methods did not reach their maximum potential because of the following four reasons: (i) The size of a Bloom filter should be proportional to the number of distinct k-mers in reads, and the number of distinct k-mers was conservatively estimated, thus could be much higher than the actual number. (ii) They could not remove the effect of false positives from Bloom filters. To make the false-positive rate of the Bloom filters small, the size of Bloom filters were made large. (iii) Because they could not distinguish error-free k-mers from erroneous ones before a Bloom filter was constructed, both of the k-mers needed to be saved in Bloom filters. (iv) Multiple Bloom filters (or counting Bloom filters) were needed to count the multiplicity of each k-mer. Besides the large memory consumption of the existing methods, another problem encountered during the error correction process is that there exist many identical or very similar subsequences in a genome (i.e. repeats). Because of these repeats, an erroneous subsequence can sometimes be converted to multiple error-free subsequences, making it difficult to determine the right choice. In this article, we present a new Bloom filter-based error correction algorithm, called BLESS. BLESS belongs to the k-mer spectrum-based method, but it is designed to remove the aforementioned limitations that previous k-mer spectrum-based solutions had. Our new approach has three important new features:(1) BLESS is designed to target high memory efficiency for error correction to be run on a commodity computer. The k-mers that exist more than a certain number of times in reads are sorted out and programmed into a Bloom filter.(2) BLESS can handle repeats in genomes better than previous k-mer spectrum-based methods, which leads to higher accuracy. This is because BLESS is able to use longer k-mers compared with previous methods. Longer k-mers resolve repeats better.(3) BLESS can extend reads to correct errors at the end of reads as accurately as other parts of the reads. Sometimes an erroneous k-mer may be identified as an error-free one because of an irregularly large multiplicity of the k-mer. False positives from the Bloom filter can also cause the same problem. BLESS extends the reads to find multiple k-mers that cover the erroneous bases at the end of the reads to improve error correction at the end of the reads.To identify erroneous k-mers in reads, we need to count the multiplicity of each k-mer. Counting k-mers without extensive memory is challenging (). BLESS uses the disk-based k-mer counting algorithm like Disk Streaming of k-mers (DSK) () and k-mer Counter (KMC) (). However, BLESS needs to save only half of the k-mers that DSK does in hash tables, because it does not distinguish a kmer and its reverse complement. To evaluate the performance of BLESS, this study used real NGS reads generated with the Illumina technology as well as simulated reads. These reads were corrected using BLESS as well as six previously published methods. Our results show that the accuracy of BLESS is the best while it only consumes 2.5% of the memory usage of all the compared methods on average. Our results further show that correcting errors using BLESS allowed us to align 69% of previously unaligned reads to the reference genome accurately. BLESS also increased NG50 of scaffolds by 50% and decreased assembly errors by 66% based on the results from Velvet ().
METHODS
Overview of the BLESS algorithmBLESS belongs to the k-mer spectrum-based error correction category (). A k-mer is called solid if it exists more than M, the k-mers multiplicity threshold, times in the entire reads, and weak otherwise. If a k-mer extracted from a read is a weak k-mer, it can be considered as having sequencing errors.depicts the high-level diagram of BLESS. To convert weak k-mers to solid k-mers, we need to save the list of the solid k-mers and to query a k-mer to the list efficiently. In Step 1, k-mers in reads are distributed into multiple files, and the multiplicity of k-mers in each file is counted. In Step 2, only solid k-mers are programmed into a Bloom filter, and errors in reads are corrected using the Bloom filter. Finally, in Step 3, BLESS restores the false corrections made by the false positives from the Bloom filter.
Step 1: Counting the multiplicity of k-mersThe first step in BLESS is to count the multiplicity of each k-mer, followed by finding the solid k-mers, and programming those solid k-mers into a Bloom filter. By counting the multiplicity of k-mers, we can sort out the solid k-mers that are needed for further analysis. We can also create a k-mer multiplicity histogram to be used to determine the multiplicity threshold M, if M is not predetermined by the user. The total number of solid k-mers is used to determine the size of the Bloom filter. Supplementaryin the Supplementary Document shows how to count the multiplicity of each k-mer. First, all the k-mers in the reads are distributed into N (default 100) files to reduce the required memory for this process. In BLESS, a k-mer and its reverse complement are treated as the same k-mer, which is called a canonical k-mer. If the middle base of a k-mer is A or C (k is always an odd number), the k-mer can be used as a canonical k-mer of itself. If the middle base is G or T, the reverse complement of the k-mer becomes the canonical k-mer of the original k-mer. A hash value is calculated for each canonical k-mer, and the file that the k-mer will be written into is determined by using the hash value. Next, the k-mer is written to the file. After this process, all the identical k-mers and their reverse complements are written into the same file. The next step is to open each file that contains k-mers and count the number of k-mers using a hash table. After all the k-mers in the file are updated in the hash table, we check the multiplicity of each k-mer in the hash table. If the multiplicity of a particular k-mer is larger than M, it is a solid k-mer and is subsequently written to the solid k-mer list file F s. If M is not given by the user, the k-mer multiplicity histogram is generated, and M is determined using the histogram. The process of determining M using the k-mer multiplicity histogram is explained later (see Section 2.5). After completing this process for all the N files, we can create the solid k-mer list file F s and determine the number of distinct solid k-mers N s. The time complexity of counting the multiplicity of k-mers is O(RL), where R is the number of reads and L is the read length.
Step 2: Correcting errors using a Bloom filterTo convert weak k-mers into solid k-mers, we must know the solid k-mer list. If this list was stored in file F s , it would be impossible to rapidly check whether a k-mer is in the list or not. BLESS solves this problem by recording all the solid k-mers in a Bloom filter, which supports fast membership test while using little memory. An open source C Bloom filter library (http://www.partow.net/downloads/OpenBloomFilter.zip) is used in BLESS. When implemented, the size of the bit vector and the number of hash functions in the Bloom filter are determined using N s and a target false positive probability. After constructing the Bloom filter, all the solid k-mers in F s are programmed into the Bloom filter. The weak k-mers are then converted into solid ones using this Bloom filter. Let read r be a sequence of symbols {A, C, G, T} with length L. The i-th base of read r is denoted by r, where 0 i L  1. The form ris a substring from the i-th base to the j-th base of r. The pseudo code of the correction process for a read r is shown in Supplementary. This process is initiated from finding all the solid k-mer islands in r. A solid k-mer island consists of consecutive solid k-mers, which is in neighborhoods with weak k-mers or the end of the read. To find them, all the k-mers from r[0, k  1] to r[L  k, L  1] are converted to their canonical forms and the canonical forms are queried to the Bloom filter. If the Bloom filter output for a k-mer is true, then the k-mer is solid. If a solid k-mer island has a solid k-mer with quality scores 510, the k-mer is removed from the solid k-mer island. The relation between solid k-mer islands and weak k-mers is shown in Supplementary. Weak k-mers have errors, but the errors cannot be in the bases that overlap solid k-mers. This is because the errors that are in the overlapped bases would make the solid k-mers erroneous, while we assume that solid k-mers do not have errors. Therefore, a weak k-mer can be converted to a solid one by modifying bases that do not overlap with solid k-mers. The weak k-mers that exist between two consecutive solid k-mer islands SI i and SI i1 can be corrected by using the rightmost k-mer of SI i and the leftmost k-mer of SI i1. This makes all the corrected bases between SI i and SI i1 covered by k consecutive solid k-mers. If an erroneous base exists in the first or last k  1 bases of a read, it is not possible to get consecutive k-mers covering the erroneous base. BLESS solves this problem by extending a read on both ends. When there is no solid k-mer island in a read, BLESS tries to change the first k-mer to a solid one by substituting low quality bases with different bases. If the first k-mer is successfully converted to solid k-mer(s), the solid k-mer(s) are traced to the right. The detailed explanation and examples of the BLESS error correction algorithm can be found in the Supplementary Document.
Step 3: Restoring corrections caused by false positives
RESULTSTo assess the performance of BLESS, we corrected errors in five different read sets from various genomes using BLESS and six other error correction methods. All the evaluations were done on a server with two Intel Xeon X5650 2.67 GHz processors, 24 GB of memory and Scientific Linux. The version and parameters of all tools used in the experiments can be found in the Supplementary Document.
Datasets used in the evaluationWe used three datasets generated by the Illumina sequencing technology and two simulated read sets. The characteristics of each read set are summarized in. The first read set, labeled D1, is the fragment library of Staphylococcus aureus used in the Genome Assembly Gold-standard Evaluations (GAGE) competition (). The second genome (D2) is high coverage (160) low error rate (0.5%) Escherichia coli reads. The third read set is the fragment library of human chromosome 14 (D3) reads that were also used in the GAGE competition. To check the scalability of BLESS, we also used simulated reads generated from GRCh37 human chromosome 1 (D4). The reads were generated using simLibrary and simNGS (http://www.ebi.ac.uk/goldman-srv/simNGS), after all Ns in the reference sequence were removed. The head of each read indicates the index of the reference sequence where the read is from. Using the information, we also generated an error-free version of D4 (D4 Error-Free hereafter). The last dataset D5 was generated to evaluate the improvement of de novo assembly results after error correction. Four read sets with 1040 of read coverage and their error-free versions were generated from the first 10 Mb of the reference sequence for D4 using simNGS. Because D5 can be treated as a subset of D4, we only report de novo assembly results for D5 here, and all the other evaluation results for D5 are in the Supplementary Document. To provide a controlled assessment of the accuracy of corrections made by BLESS, errors in the input read sets are identified using the error correction evaluation toolkit (ECET) (). ECET first aligns reads to the reference sequence using BWA () and identifies a set of differences between the reads and the reference. ECET evaluates corrected reads by counting how many differences in the set are removed. In our evaluations, insertions and deletions were not included in the set because insertions and deletions can be corrected by substitutions and ECET regards these substitutions as wrong modifications. For example, if a genome sequence contains ACGT and a read from the genome has one insertion between C and G (i.e. ACAG), the insertion error can be corrected by substituting the third (fourth) base A (G) with G (T). ECET counts the third and fourth bases as wrong modifications.
Error correction accuracyWe compared BLESS with the following existing error correction tools: Quake (), Reptile (), HiTEC (), ECHO () and Musket (). We chose these tools to compare mainly because they cover the three major categories of error correction methods see the review by, i.e. k-mer spectrum-based, suffix tree-based and MSA-based methods. To the best of our knowledge, PREMIER () is the only HMM-based error correction tool for DNA reads, and it was not included in our comparison because its source code is not available. In addition, we also considered Bloom filter-based methods that were previously published. We selected DecGPU () to compare with BLESS because it is the only Bloom filter-based method that can run without a GPU. The comparison results of BLESS and the other six error correction tools are summarized in. The outputs of the error correction tools were converted to target error format (TEF) files using the software in ECET to measure the accuracy of theNote:Length of genomes without Ns,Number of reads after all paired reads that contain Ns are removed. To use the software in ECET, all the reads containing Ns were removed using the program in ECET. The software removes reads without considering the paired-end information, but this may cause problems in our evaluation process because several evaluations use the paired-end information. To keep the paired-end information intact, both reads in a pair were removed if either of them contained Ns;corrected reads. In each dataset, we counted the following: erroneous bases successfully corrected (true positive, TP), correct or erroneous bases erroneously changed (false positives, FP), erroneous bases untouched (false negatives, FN) and the remaining bases (true negative, TN). Then, sensitivity, gain and specificity were calculated using these four values. Sensitivity, defined as TP/(TP  FN), shows how many errors in the input reads are corrected. Gain, defined as (TP  FP)/(TP  FN), represents the ratio of the reduction of errors to the total number of errors in the original reads. Gain can be negative if the number of newly generated (FP) errors is greater than the number of corrected errors. Specificity, defined as TN/(TN  FP), shows the fraction of error-free bases left unmodified. DecGPU and Quake cut bases that they cannot correct, and these trimmed bases are considered as FPs in ECET. In our evaluation, trimmed bases were excluded from FPs and thus not used to calculate sensitivity, gain and specificity because considering trimmed bases as FPs made gain of DecGPU and Quake worse than what they really were. While some error correction tools such as HiTEC are able to independently choose appropriate parameters, the error correction quality of other tools depends on parameters that have to be set by the users. We generated the corrected read sets that provided the best gain using each error correction tool to compare the best results from the methods. To generate such read sets, the values of all the key parameters of each tool were scanned in a continuous fashion within their respective ranges until the gain of each tool reached the maximum. The parameters that were used to generate outputs can be found in the Supplemental Document. BLESS, Musket, Quake, Reptile and DecGPU were able to generate results for all the four datasets. ECHO did not complete the error correction for D2 even after 60 h of running, so we could not produce ECHO results for D2 and larger datasets (i.e. D3 and D4). HiTEC also failed to correct errors in D3 and D4 because it ran out of memory. As shown in, BLESS consistently outperforms the other correction tools for all the input datasets. For D1D4, the sensitivity of BLESS is higher than that of the other methods, whereas the difference between sensitivity and gain of BLESS is smaller than those of the other methods. This suggests that BLESS can correct more errors in the reads and that the results from BLESS always have fewer errors than those from other tools. The results for D5 are summarized in Supplementary Table S1 in the Supplementary Document. The higher accuracy of BLESS comes from its ability to use longer k-mers. If k is too short, an erroneous k-mer may be recognized as solid, because it is more probable that a short erroneous k-mer exists in other parts of the genome. Even though an erroneous k-mer is recognized as a weak k-mer, it may be possible to convert it to multiple solid k-mers if k is too short. Supplementaryshows how the number ofNote: Sensitivity, gain and specificity are defined as TP/(TP  FN), (TP  FP)/(TP  FN) and TN/(TN  FP), respectively. The best value for each data is shown in bold. For each tool, many different combinations of parameters were applied, and the output that showed the best gain was chosen. distinct k-mers changes and approaches N ideal in the reference sequence of D2 and D4 as k increases. N ideal represents the number of distinct k-mers in the reference sequence when all the k-mers in it are distinct.More repeats can be differentiated by using longer k, which is helpful in removing ambiguities in the error correction process. The number of distinct k-mers for E.coli becomes 96% of N ideal , when k is 15. However, the same ratio for human chromosome 1 is only 50% for the same k value. When k becomes 31, this ratio for human chromosome 1 surpasses 90%. Note that a longer k value does not always guarantee better error correction results, as the average multiplicity of k-mers decreases as k increases. However, if k is too short, it would be more difficult to differentiate solid k-mers from weak ones and k should be increased until a sufficient average k-mer multiplicity is guaranteed. In the NGS reads that were generated using the Illumina technology, errors are usually clustered at the 3 0 end of the reads. Therefore, correcting errors in that region is an important feature of error correction methods, although correcting such errors is more difficult than correcting errors in the middle of the reads. BLESS can correct errors at the end of the reads as accurately as in other parts through a reads extension. To assess the number of corrected errors in each position of the reads, we calculated the number of TPs and sensitivity at each position.shows the number of TPs in each corrected read set for D1. In this graph, Reference refers to the number of errors in each position of the original reads, which rapidly increases at the 3 0-end of the reads.shows the ratio of TPs to the number of errors (i.e. sensitivity) in each position of the reads in D1. We observed that BLESS maintains high sensitivity even in the regions where most of the errors are clustered, as indicated by the overall flat contour of the line shown in the figure. The figures for the other inputs can be found in Supplementary.
Memory usageThe peak memory usage and runtime of each method is also displayed in. The average memory usage of BLESS is only 2.5% of the other methods. On average, BLESS consumes 5.6% of the memory that DecGPU does, which is another Bloom filter-based method. DecGPU programs k-mers into a counting Bloom filter, which helps the multiplicity of k-mers to be saved with small memory with a certain false-positive probability. BLESS requires less memory than previous Bloom filter-based methods for the following reasons. First, BLESS can count the multiplicity of k-mers and find out the list of solid k-mers without constructing Bloom filters. Therefore, we eliminate the need to estimate the number of distinct k-mers. We also do not need to program weak k-mers into the Bloom filter. Second, BLESS uses a Bloom filter instead of a counting Bloom filter. Previous methods use counting Bloom filters to count the multiplicity of k-mers, and this information is then used to identify solid k-mers. In BLESS, however, we already know the list of solid k-mers. Therefore, it is not necessary to know the multiplicity of k-mers to identify solid k-mers anymore, and solid k-mers can be programmed into a Bloom filter instead of a counting Bloom filter. Finally, BLESS is able to remove false corrections that are generated by false positives from the Bloom filter. Therefore, the target false-positive probability of the Bloom filter used in BLESS does not need to be very small, which helps to reduce the size of the Bloom filter.also compares the runtime of BLESS with the other methods. This is discussed in more detail in the Supplemental Document.
AlignmentTo evaluate the impact of error correction on read mapping, we compared the number of reads that could be aligned to the reference sequence with Bowtie () before and after error correction. In, each column denotes the percentage of exactly aligned reads out of all the reads. We used the paired-end alignment capability of Bowtie, and the reads that could not be aligned uniquely in the reference sequences were counted. The detailed Bowtie parameters used can be found in the Supplemental Document. All error correction methods reduced the number of unaligned reads, but BLESS outperformed the others for all the four inputs. After errors were corrected using BLESS; 81% of the entire reads and 69% of the initially unaligned reads could beNote: Alignment was performed using the paired-end alignment of Bowtie. The best value for each column is shown in bold.Result for D4 Error-Free. When we ran Bowtie, the maximum and minimum values of insert length were set, and this prevented 19.7% of Error-Free reads from being aligned to the reference sequence.aligned to the reference on average without any mismatches. This ratio was higher than the ratio of the other methods. D4 is a simulated read set, and we know where each read should be aligned. For each aligned read in the BLESS output, we compared the aligned position and the position where it originated. In all, 99.94% of the aligned reads were aligned to the correct positions. Even though this evaluation could not be done for D1D3, the percentage of D1D3 will not be very different from the D4 result because the same strict Bowtie options were used for all the datasets. The alignment results for D5 can be found in Supplementary Table S2.
De novo assemblyError correction can improve not only read alignment but also de novo assembly results. To compare the effect of error correction methods on de novo assembly, scaffolds were generated using two de Bruijn graph (DBG)-based assemblers Velvet () and SOAPdenovo () with four D5 read sets (10, 20, 30 and 40 read coverage). A string graph-based assembler SGA () was also used to show the effect on non-DBG-based assemblers. Scaffolds were also made using the output reads of each error correction tool, and all the scaffold sets were compared with one another. The output quality of Velvet and SOAPdenovo is sensitive to the choice of k. Therefore, all the odd numbers between 35 and 89 were applied to Velvet and SOAPdenovo as k for each input read set. The k value that gave the longest corrected scaffold NG50 was selected. NG50 is the length of the longest scaffold, S, and that the sum of the lengths of scaffolds whose lengths are greater than or equal to S is greater than or equal to half the length of the genome length (). For SGA, since the most important parameter is the minimum overlap, all the numbers from 50 to 90 were tested for each dataset to find the value that generated the longest corrected scaffold NG50. The parameters used for each dataset are described in Supplementary Tables S3S5. Each scaffold set was evaluated using the GAGE assembly evaluation toolkit ().shows the Velvet assembly results for D5 (40). Corrected NG50 is equal to NG50 except that corrected NG50 is calculated after the scaffolds are broken at places where assembly errors occur (). The GAGE software generates contigs by splitting scaffolds whenever a run of Ns are found. Errors in contigs include single mismatches, indels, inversions and relocations. Errors in scaffolds are the summation of indels, inversions and relocations. Genome coverage shows how many bases in the reference sequence are covered by the scaffolds. Error-Free row shows the assembly results for D5 Error-Free (40). The assembly results of BLESS were better than the others in terms of assembly length and accuracy. Corrected NG50 was improved from 670 to 1004 kb after errors were corrected by BLESS. BLESS also reduced the number of errors in the contigs from 1321 to 449, and improved genome coverage from 99.5 to 99.8%. The complete de novo assembly results of Velvet, SOAPdenovo and SGA can be found in Supplementary Tables S3S5.
Removing false positives caused by the Bloom filterBloom filter may return incorrect querying results that cause false positives (). In BLESS, we designed two processes to remove such false positives. The first process is done simultaneously with the error correction. It is possible that a weak k-mer can be converted to another weak k-mer that is recognized as a solid k-mer because of a false positive from the Bloom filter. To prevent this, BLESS modifies a base only when all the k k-mers that overlap the modified base are solid k-mers. As the second process, we check the multiplicity of k-mers that include modified bases. The multiplicity of the k-mers is checked using the hash tables that were built to find solid k-mers in reads. If the multiplicity of a k-mer is smaller than M, the modified base in the k-mers is restored. The second column of Supplementaryshows the number of corrections made by BLESS. Detected false positives in the third column are the number of FPs that were made by the false positives from the Bloom filter and detected in the final checking process. The ratio of the third column to the second was at most 0.0001%, whereas the target false positive probability of the Bloom filter in BLESS was set to its default value (i.e. 0.1%) for all the input sets. This number comes from the fact that BLESS makes a correction only if the querying results of k (or 5 at the end of reads) consecutive k-mers that cover the corrected base are true. These results demonstrate that our prefiltering method successfully prevents most of FPs made by the false positives of the Bloom filter.
Choosing parameters automaticallyIn BLESS, M affects the output quality, and BLESS can automatically choose this value. Supplementaryshows how close the values chosen by BLESS are to the best M that makes the gain of BLESS's output the highest. The second column represents the best M; the third column is the corresponding gain when M is the value in the second column. The fourthNote: The best value for each column is shown in bold.Assembly results for D5 Error-Free (40). An inversion error means that part of a contig or scaffold comes from a different strand with respect to the true genome. A relocation means that part of a contig or scaffold is matched with a different part within a chromosome.and fifth columns represent M chosen by BLESS and the corresponding gain. For D1 and D3, the values that BLESS chose were the same as the best M in the second column. For D2 and D4, there are small differences between M chosen by BLESS and the best M. However, the difference between the third and fifth column was 0.001 and 0, respectively. Therefore, BLESS's auto M selection capability achieves the best gain or the nearly best gain in all the four input sets.
DISCUSSIONCurrent NGS technologies produce errors in reads, which can influence the quality of downstream analysis. Many methods have been developed to correct such sequencing errors. However, most previous methods cannot correct errors in large genomes. Even if a few methods succeeded in correcting large genomes, their outputs still contain many uncorrected errors. In addition, the memory requirement for the existing tools has been still too large for most researchers, who might only have access to computers with a moderate amount of memory. In this work, we present a novel error correction algorithm for NGS reads, called BLESS, which has two novel features: (i) BLESS consumes much less memory than previous methods. BLESS can sort out minimum k-mers needed to correct errors, and program the k-mers in a minimum-sized Bloom filter. This makes BLESS consume much less memory than any other error correction method including previous Bloom filter-based ones. (ii) BLESS also generates more accurate results for reads from genomes with many short repeats. This is mainly because BLESS is not limited by the choices of the length of the k-mer (see Software options in the Supplementary Document for details). While the maximum k is usually 2030 in other methods, BLESS is able to remove ambiguities in the error correction process by choosing large numbers for k without increasing memory usage. Furthermore, BLESS is efficient at correcting errors close to the ends of the reads. BLESS corrects errors at the ends of the reads by extending the ends. BLESS was compared with previous top performers using real and simulated reads. The experimental results showed that BLESS generated more accurate results than previous algorithms while consuming only 2.5% of the memory usage of the compared methods on average. Moreover, running BLESS improved the length and accuracy of de novo assembly results for all the three widely used assemblers, Velvet, SOAPdenovo and SGA. BLESS also made 69% of unaligned reads exactly aligned to reference sequences. As pointed out before, BLESS can choose large values for k. The only drawback to large k values is that the average multiplicity of such k-mers drops. If the average multiplicity of k-mers is too low, we cannot precisely distinguish erroneous k-mers using their multiplicity. Nevertheless, it is important to note thatbecause the DNA sequencing cost keeps dropping and the throughput keeps increasing, we expect to solve this problem by increasing the depth of reads. The memory usage of BLESS is proportional only to the number of solid k-mers. Because the solid k-mers eventually represent the k-mers that exist in the genome sequence, the number of solid k-mers remains constant even as the number of input reads escalates. Therefore, memory consumption of BLESS will not increase even when read depth increases as shown in Supplementary Table S1. There are two future avenues to pursue. First, although the runtime of BLESS is already competitive as shown in, supporting multiple threads will improve BLESS's runtime further. BLESS's wall-clock time decomposition for D4 is depicted in Supplementary. Most of the time is spent counting the number of distinct solid k-mers and correcting errors. The runtime of both processes can be improved through parallelization. In the counting step, k-mers are distributed into N files, and each file is processed in succession. This step can be parallelized without degrading memory usage. The error correction process of a read is independent of other reads, and therefore the error correction part can be easily parallelized. Second, developing a method to automatically choose k may be added. Recent work () showed that a k-mer multiplicity histogram can be made in a short time by sampling reads and an optimal k value can be found using the histograms. This sampling-based approach will also work for BLESS. It will be helpful to reduce the runtime because it can prevent users from running BLESS multiple times with different k values.
The Author 2014. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Although it would be rare, it is still possible that BLESS could change an erroneous base to a wrong one because of the false positives from the Bloom filter. Therefore, BLESS has a step to remove all the corrections caused by the false positives from the Bloom filter. To achieve this, BLESS first extracts candidate k-mers that contain modified bases and counts their multiplicity to check whether their multiplicity values are higher than the threshold M. After all the candidate k-mers are extracted, they are split into N files using the same hash function that was used for splitting k-mers in the original reads into N files. We have already saved the hash tables containing the multiplicity of k-mers in a hard disk; the hash tables are reloaded into memory, and the multiplicity of each candidate k-mer is checked. If the multiplicity of a candidate k-mer is smaller than M, we may conclude that the modification for the k-mer is made based on false positives, and the correction is reversed. The time complexity of this step is proportional to the number of corrected bases, and it can be expressed as O(RL). 2.5 Determining parameters Output quality of BLESS is affected by the choice of the k-mer multiplicity threshold, M. The distribution of k-mer multiplicity in the original reads is the mixture of error-free k-mers and erroneous k-mers. The multiplicity of error-free k-mers is known to follow the Poisson distribution and the multiplicity of erroneous k-mers can be fit to the gamma distribution (Kelley et al., 2010; Yang, 2011). The histogram of the multiplicity of k-mers usually has the curve like the red line in Supplementary Figure S4 if k is in a reasonable range. Such a histogram can be decomposed into the histogram of error-free k-mers (blue line) and erroneous k-mers (gray line). If M is too small, many erroneous k-mers may be recognized as solid k-mers (i.e. larger false positives and smaller false negatives). On the other hand, if M is too large, many error-free k-mers become weak k-mers (i.e. larger false negatives and smaller false positives). We define the optimal value of M, M optimal , as the M value that minimizes the sum of false positives and false negatives. In BLESS, the histogram like the red line in Supplementary Figure S4 can be easily generated because BLESS already calculated the multiplicity of each k-mer. In the histogram, the sum of false positives and false negatives becomes the minimum when M is the valley point of the U-shape curve with the following two assumptions: (i) as M increases from the value point, the corresponding value of the gray line becomes smaller and the corresponding value of the blue line becomes larger and (ii) as M decreases from the valley point, the corresponding value of the gray line becomes larger and the corresponding value of the blue line becomes smaller. This is a reasonable assumption if error-free k-mers and erroneous k-mers can be fit into the Poisson and gamma distribution, respectively, and two distributions are away from each other. If we assume that the current M value is the valley point and M moves to the right, the sum of false positives and false negatives increases even though the number of false positive decreases. Similarly, if M moves to the left, the sum of false positives and false negatives also increases even though the number of false negatives decreases. Therefore, the sum of false positives and false negatives becomes its minimum when M is the valley point of the histogram of the multiplicity of k-mers. Choosing the appropriate k is also needed to get more accurate results from BLESS. If k is too long, the average multiplicity of solid k-mers becomes smaller. On the other hand, if k is too short, there may be too many unnecessary paths in the error correction process (see the Supplementary Document). This will increase not only the probability that wrong corrections are made but also BLESS's runtime. Unfortunately, BLESS currently cannot automatically determine the optimal k value. However, our empirical analysis shows that the k value that satisfies the following two conditions usually generates the results close to the best one: (i) N s /4 k 0.0001 where N s represents the number of unique solid k-mers (BLESS reports N s ) and (ii) number of corrected bases becomes the maximum at the chosen k value. Fig. 1. The high level block diagram of BLESS. The cylinders and the rectangle with extra lines depict data written to disk and memory, respectively
Y.Heo et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
