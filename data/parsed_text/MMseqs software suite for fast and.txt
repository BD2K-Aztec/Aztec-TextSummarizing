Motivation: Sequence databases are growing fast, challenging existing analysis pipelines. Reducing the redundancy of sequence databases by similarity clustering improves speed and sensitivity of iterative searches. But existing tools cannot efficiently cluster databases of the size of UniProt to 50% maximum pairwise sequence identity or below. Furthermore, in metagenomics experiments typically large fractions of reads cannot be matched to any known sequence anymore because searching with sensitive but relatively slow tools (e.g. BLAST or HMMER3) through comprehensive databases such as UniProt is becoming too costly. Results: MMseqs (Many-against-Many sequence searching) is a software suite for fast and deep clustering and searching of large datasets, such as UniProt, or 6-frame translated metagenomics sequencing reads. MMseqs contains three core modules: a fast and sensitive prefiltering module that sums up the scores of similar k-mers between query and target sequences, an SSE2-and multi-core-parallelized local alignment module, and a clustering module. In our homology detection benchmarks, MMseqs is much more sensitive and 4â€“30 times faster than UBLAST and RAPsearch, respectively, although it does not reach BLAST sensitivity yet. Using its cascaded clustering workflow, MMseqs can cluster large databases down to $30% sequence identity at hundreds of times the speed of BLASTclust and much deeper than CD-HIT and USEARCH. MMseqs can also update a database clustering in linear instead of quadratic time. Its much improved sensitivity-speed trade-off should make MMseqs attractive for a wide range of large-scale sequence analysis tasks. Availability and implementation: MMseqs is open-source software available under GPL at https:// github.com/soedinglab/MMseqs
IntroductionDuring the last 8 years, sequencing costs have come down from 10 000 000$ to less than 1000$ for a human genome at 30 times coverage (http://www.genome.gov/sequencingcosts). As a consequence, protein sequence databases such as the UniProt () database have been growing by a factor of 2 every two V C The Author 2016. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com years (), leading to longer search times, inflated and redundant results list, large memory requirements and saturating or decreasing sensitivities for informative sequence matches (). A solution is to compute a representative subset of sequences by clustering them by their similarity and selecting one representative per cluster. Such clustering schemes achieve a more even sampling, leading to better sensitivities in sequence searches (). UniRef provides representative subsets of UniProtKB clustered at 100%, 90% and 50% sequence identity (). Clustering schemes are also used in metagenomics projects to reduce the size and redundancy of the ever larger amounts of sequence data (). Several tools for clustering protein sequence databases have been developed. BLASTclust from the NCBI BLAST package is sensitive but slow. It uses greedy single-linkage clustering based on all-versusall blastp searches (). The fast tools CD-HIT, (), USEARCH () and kClust () share several similarities. First, they employ the same incremental, greedy clustering scheme, in which each database sequence (the 'query') is compared with the representative sequences of already established clusters. If one of the representative sequences is sufficiently similar, the query is added to this cluster or otherwise becomes the representative of a new cluster. Second, all three tools employ a k-mer word-based similarity prefilter that drastically reduces the number of slow but accurate Smith-Waterman alignments. The prefilters in CD-HIT and USEARCH count the number of common, identical k-mer words between sequences, with k  5 or 6 for USEARCH and k between 2 and 5 for CD-HIT. To obtain a sufficient number of common k-mers between sequences with only 50% residue-wise sequence identity, CD-HIT has to lower k to 2. But this leads to a high probability $ 1=20 k for chance k-mer matches. Therefore, the number of chance matches in an all-against-all comparison of N sequences of average length L is around NL 2 =20 k , which becomes huge for small k. Since each chance match costs a constant amount of time to process, short words lead to an enormous slow-down. kClust employs a k-mer-based prefilter that can even detect pairs at 2030% sequence identity at high speed. To keep the probability for chance matches low and speed high, it uses long words with k  6 or 7. But to increase sensitivity at the same time, it detects similar instead of just identical k-mers. For each k-mer in the query sequence, it computes a list of all k-mers with a BLOSUM62 bit score above a certain cut-off and finds identical matches to these similar k-mers in the database sequences. The prefilter then scores each database sequence by the sum of similarity scores of similar k-mers. A further challenge arising from the rapid progress in highthroughput sequencing is the need for sensitive but fast protein sequence search methods. A large fraction of metagenomics reads cannot be mapped to any known sequence from a cultivated organism anymore, because it has become too costly to search through the entire UniProt database using a sensitive but slow tool such as BLASTX (): It would take approximately 2398 CPU years to search with all 6-frame translated sequences from 2 10 9 reads of length 150 nucleotides through the current UniProt database using BLASTX. Instead, in most projects, much smaller databases are searched, such as KEGG GENOME (), a collection of high-quality genome sequences, or the MetaPhlAn () database of unique clade-specific marker genes (). This carries the risk of missing some of the most interesting matches, which do not conform to prior expectations. To address this challenge, a number of fast protein sequence search tools have been developed: Tachyon (), PAUDA (), PSimScan (), RAPsearch2 (), Lambda (), UBLAST () and DIAMOND (). The latter five, which are the most sensitive in this list, find exact matches of (spaced) k-mers and extend the alignment around them. MMseqs addresses the need for a clustering and search tool that is both fast and sensitive enough to be able to detect sequence matches down to $30% residue-wise sequence identity. While it uses the same core prefiltering algorithm as kClust, it has various important advantages: (i) Its organization into modules (prefiltering, alignment, clustering) and workflows increases flexibility and facilitates future extensions. (ii) Its search workflow can perform sequence searches. With a speed 1000 times faster than BLAST it finds similarities down to 30% sequence identity and is much more sensitive than similarly fast search tools. (iii) Its cascaded clustering workflow achieves much deeper clustering than kClust in a shorter time. (iv) Its database updating workflow adds sequences to a previously clustered set in linear time, obviating the need for frequent reclustering in quadratic time. (v) MMseqs is implemented highly efficiently, using SIMD (single-instruction-multiple-data) instructions to vectorize time-critical loops. (vi) It is parallelized using OpenMP to run on multi-core CPUs (vii) To save memory, the database can be divided into several parts and processed consecutively. (viii) Its prefilter uses a novel Z-score statistic for higher sensitivity and a score correction for compositionally biased sequence regions. (ix) It offers the greedy set cover algorithm for clustering, in addition to the simple, incremental algorithm used by kClust, USEARCH and CD-HIT, enabling deeper clusterings. (x) It performs exact SmithWaterman alignment based on the striped SIMD algorithm () instead of the approximate k-mer dynamic programming algorithm developed for kClust.
MethodsMMseqs contains three core modules: (i) The prefilter module computes a k-mer-based similarity score between all sequences from the 'query' set with all sequences from the 'target' set. (ii) The alignment module can read prefiltering results and computes Smith-Waterman alignments between query-target pairs that pass a prefilter Z-score threshold. (iii) The clustering module reads in the results of the alignment module, for which a sequence set must have been compared to itself (query set  target set), and groups sequences into clusters, using user-specified thresholds on sequence similarity, alignment coverage and E-value. In addition to the modules, three workflows for sequence searching, clustering and updating a clustering facilitate the most common tasks for the non-expert.
Prefilter module
Prefilter scoreThe prefilter module is crucial for the speed and sensitivity of MMseqs as it needs to reduce the number of sequences to be aligned with the relatively slow Smith-Waterman algorithm from millions to tens or hundreds per each query sequence while compromising sensitivity as little as possible. For each query sequence it computes a raw prefilter similarity score with each target sequence. This prefilter score S pref is the sum of similarity scores for all pairs of k-mer words (x, y) whose similarity score S k x; yevaluated with the BLOSUM62 () substitution matrix surpasses a minimum score threshold S min : S pref query; target  X x2query;y2target;S k x;y!Smin S k x; y:This score, first introduced with kClust, has a fundamental advantage over the prefiltering score used in CD-HIT and USEARCH, which counts the number of identical k-mers: We can increase the sensitivity of the search while still maintaining relatively high specificity of the k-mer matches by lowering the minimum similarity threshold S min while keeping the word length fixed and high (e.g. k  6). In contrast, to maintain a sufficient number of k-mer matches in homologous sequence pairs with low similarity, CD-HIT needs to shorten k down to 2, thereby loosing specificity of k-mer matches and thus incurring dramatically increased run times.
Z-scoreThe expected 'background score' for a pair of non-homologous sequences of lengths L q and L t is proportional to the number of expected chance k-mer matches, which is roughly proportional to the number of k-mers in the target sequence, L t  k  1. We subtract the expected background score from the raw prefilter score to improve the discrimination of true and false positives. Since some queries tend to generate more chance k-mers than others, we estimate the expected background score by acquiring match statistics on a small, randomly sampled subset of target sequences for each query sequence prior to the actual search. To account for the variance of the background score we divide the background-corrected score by the expected standard deviation, assuming a Poisson distribution for the number of k-mer matches. These results in the final prefilter Z-score (see Supplemental Material).
Local compositional bias correctionSequence regions with biased amino acid composition, such as transmembrane helices, coiled coils or disordered regions, may cause artificially elevated rates of chance k-mer matches between unrelated proteins, leading to high-scoring false positive sequence matches. To reduce this risk, we add to the k-mer score S k x; y a correction X jk ij1 DS i x i  that depends on the amino acids x i composing the query k-mer x. DS i x i  is minus the average BLOSUM62 score between x i and the amino acids within 620 residues from x i (except x i itself) plusa, the expected BLOSUM62 score of x iwith a random amino acid a assuming background frequencies f(a). Thus, amino acids that are similar to amino acids enriched in the local sequence neighbourhood receive lower scores (see Supplemental Material).
Core algorithmFor each query sequence (for-loop 1 in) and each overlapping kmer x in the query (for-loop 2), a list of similar k-mers and their scores, L sim x  fy; S k x; y : S k x; y > S min g, is generated (orange box in). For each similar k-mer y (loop 3), we look up in a precomputed index table (blue box) the list L IDs y of target sequence IDs that contain the k-mer y (green box). In the most time-critical, innermost loop 4, we add S k x; y to the score of each of the target sequences t 2 L IDs y: S pref t S k x; y. The index table is computed by the prefilter module prior to the actual search. It consists of the 21 k lists L IDs y of target sequence IDs, one list for each of 21 k k-mers y (green box) and an array of 21 k pointers to the lists (black box). The 21st letter X represents unknown amino acids. After having processed all k-mers of a query, we extract the small fraction of target sequences with non-zero scores by checking in parallel using SSE2 instructions if any of the 8 short integer scores differs from 0. This manual vectorization speeds up extraction by around 8-fold. IDs of sequences with non-zero scores are written into a list and final Z-scores are computed.
Time complexityLet us define N q , N t , L q and L t as the numbers of sequences in the query and target sets and their average lengths, respectively. Let l sim  E x jL sim xj denote the average length of the lists of similar k-mers, and let l IDs  E y jL IDs yj be the average length of the lists of target IDs. It can be estimated as l IDs  N t L t =20 k , since the target set contains approximately N t L t k-mers distributed over 20 k k-mers. The total time for the prefilter is then approximatelyThe first term is the time to build the index table, N q L q l sim T sim is the time for generating the lists L sim x. The term N q L q l sim l IDs T match  N q L q N t L t l sim =20 k describes the contribution of adding the k-mer similarity scores to the target sequence scores in the innermost loop, which dominates the runtime when searching large databases with intermediate or high sensitivity. N t T extract is the time to extract for each query the target sequences with the most significant scores. It is desirable to choose k and S min such that the average list length l IDs % N t L t =20 k does not drop below 1, because otherwise much time is lost in generating lists of similar k-mers that do not lead to a k-mer match. We should therefore choose k  7 for N t L t ! 5  20 7 % 6  10 9 and k  6 below that limit. Here, we have used k  6 throughout, and, when setting k  7, further improvements in sensitivity-speed trade-off are possible for large databases such as UniProt (for which N t L t % 2  10 10 ). The main parameter to control the sensitivity-speed trade-off in MMseqs is the minimum k-mer score S min , which determines the average length l sim. This trade-off can be set by the MMseqs sensitivity parameter S using option '-s hSi'.The prefilter is the time-limiting module for searching and clustering large databases. It can run on multiple cores (Supplementary) thanks to OpenMP parallization of for-loop 1 in(Supplementary).
Memory requirementsThe index table requires 21 k  16B (bytes) to store the array of pointers and the list lengths, which amounts to 654 MB for k  6. The dominating contribution however is to store the lists of sequence IDs in the index table. Each ID is encoded with 4 B, which sums up to a total of N t L t  4B. For the UniProtKB containing N t  54M sequences of average length L t % 350 we need around 70 GB of main memory. To run MMseqs with a much smaller main memory, the prefilter module can split the target set into equal-sized chunks, only one of which needs to be held in main memory at a time. After all chunks have been processed the results are combined to yield the same results as if done in a single search. This can come at a cost in run time if the average list length l IDs drops below $5 (see Section 11.1 of user guide for details).
Alignment moduleThis module computes exact, unbounded Smith-Waterman alignments with affine gap penalties for all query-target sequence pairs that pass a user-specified prefilter Z-score. We extended the striped SIMD algorithm () by adding a back-tracing procedure to extract the optimal aligments. We keep the three dynamic programming matrices in memory (using 2 B per cell) and trace back from the cell of maximum score by choosing the previous cell whose score is equal to the score in the current cell minus its match score minus gap penalties if applicable. The trace-back stops when it arrives at a cell with score 0. The alignments are multi-core parallelized using OpenMP over the loop of query-target pairs to be aligned.
Clustering moduleThis module clusters the sequences based on user-specified criteria: sequence identity, E-value (to ensure homology) and alignment coverage. A high coverage threshold (0.8 is default in MMseqs) is critical to ensure that all proteins within one cluster have a very similar domain structure. Otherwise, two unrelated families of single-domain proteins composed of domain A or B, respectively, could get clustered together with proteins each containing both domains A and B, leading to a corrupted sequence cluster. The greedy set-cover algorithm chooses at each step the sequence with the most remaining neighbours. Neighbours are sequences that satisfy the user-specified clustering criteria. The 'representative' sequence and its neighbours are added to a new cluster, removed from the remaining sequences and the next best representative sequence is picked until all sequences belong to one cluster. MMseqs also offers the greedy incremental clustering algorithm implemented in CD-HIT, USEARCH and kClust. The time and memory requirements of clustering are typically much lower than for the other two modules. The time and memory complexity are both ON t K where K is the average number of neighbours per sequence. A stand alone version of our set-cover implementation is available at https://github.com/martin-steinegger/setcover.. MMseqs workflows are designed to facilitate the most frequent use cases: (A) batch sequence searching with one query set through a target set, (B) clustering a set of sequences by similarity and other criteria starting from the raw sequence file, (C) an efficient cascaded clustering procedure for deep clustering and (D) updating a clustering of a sequence set by adding new sequences and deleting deprecated sequences
Workflows
Sequence search workflowThis workflow searches with each sequence in the query set through all sequences in the target set by running prefilter and alignment modules (). It outputs an ffindex database with one file of search results per query sequence. (See Supplementary Material for an explanation of the ffindex file format.)
Clustering workflowThe clustering workflow clusters sequences starting from a raw sequence file of input sequences (). It first performs an all-versus-all sequence comparison using the prefilter and alignment modules (with query  target set) and then runs the clustering module on the results. The clustering workflow also implements a powerful three-step cascaded clustering (). In the first step, the sequences (blue) are clustered using the basic clustering workflow with a fast but low-sensitivity setting (option ' s 1'). The representative sequences from this clustering (R1) are then used as input set (red dots) for a second clustering step with intermediate speed and sensitivity. The resulting representative sequences (R2) are clustered with high sensitivity in the third step. Finally, all sequences in the input set are assigned to one of the clusters of the third clustering step through the intermediate cluster assignments, yielding results formatted as if the clustering had been done in a single step. Cascaded clustering achieves better sensitivity at comparable speeds. Also, in contrast to single-step clustering it can generate clusters that are much larger than the maximum number of reported sequence matches. This threshold is set to 300 by default to keep the maximum size of the results files manageable.
Updating workflowIt has become impractical to frequently update clustered versions of large sequence databases, such as UniRef (), due to the quadratic scaling of the runtime with the number of sequences. Our updating workflow can update an existing clustering in linear time and with stable cluster identifiers by adding new sequences and deleting deprecated ones that are no longer contained in the new database version. The updating workflow takes as input a clustering of a previous version of a sequence set ('query DB') and a new version of the sequence set (). The workflow deletes sequences from the clusters that do not appear in the new sequence set anymore (grey disk, grey crossed-out dot) and compares the newly added sequences (black) to the sequences in the current clusters (blue) using the prefilter and alignment modules. A new sequence is added to the cluster with the most similar representative sequence that satisfies all specified criteria (e.g. E-value, alignment coverage, similarity). Those new sequences that do not get recruited to any existing cluster are then clustered amongst themselves and the resulting clusters are added to the clustering.
Results
Sensitivity and speed of protein searches
Benchmark datasetWe downloaded the sequences of the SCOP/ASTRAL database version 1.75 () filtered to 25% maximum pairwise sequence identity () ('SCOP25') and removed sequences from the nonstandard class e, folds b.67b.70 and those with inserted domains. Taking each of the 7616 sequences in this set as a query, we searched for homologous sequences in the uniprot20 database (version 03/2013) using a single search iteration of HHblits () with default parameters (E-value threshold 0.001). The resulting multiple sequence alignments of the query with its matched sequences were filtered using HHblits options 'qid 30 id 80 diff 50', which ensured a minimum sequence identity of 30% to the query, low redundancy, and a maximum of 50 sequences per query. The sequences passing the filtering were labeled with the same SCOP family as the query sequence and pooled into a set of 283406 sequences ('scop25db set'). We created a query fragment set by sampling one randomly chosen fragment of 50 residues length from each of the 7616 sequences in SCOP25.
Benchmarked toolsWe compared SWIPE (), an exact, vectorized implementation of Smith-Waterman alignment, gapped BLAST (), MMseqs with high and low sensitivity setting, 's 7' (MMseqs-sens) and 's 4' (MMseqs-fast), respectively, DIAMOND and DIAMOND-sens (), UBLAST () and RAPsearch2 (). For the ROC5 analysis, we needed to encourage the tools to report at least 5 false positives. We therefore set the E-value threshold to 10 for all tools, and we increased the maximum number of reported matches to 1000 for all tools except UBLAST, since UBLAST does not have such a limit. The detailed command line options are listed in the Supplementary Material.
Speed measurementsSince there is a trade-off between speed and sensitivity, measuring the speed is important to get the complete picture. Because the size of our scop25db set is too small to extrapolate to the speeds for searching large sequence sets such as UniProt, we measured the speed by searching with the full-length and fragments query sets through the UniProtKB with 54.79 M sequences. We specified 16 cores for all tools and measured the time to build the index structure of the database and the times to complete the search with the 7616 query sequences (). The searches were run on all 16 cores of a server with two 2.7 GHz Intel Xeon E5-2680 CPUs and 128 GB RAM.
Searching with short peptide readsFirst, we wanted to assess the ability of fast sequence search tools to find nontrivial homologous matches for short peptide fragments oflength 50, a length that is typical of hypothetical protein fragments derived from Illumina short read sequences of 150200 nucleotides. We created a query fragment set by sampling one random fragment of 50 residues length from each of the scop25 sequences, searched with each query fragment the scop25 set and analyzed the results using a standard ROC5 analysis (S ding and): Each matched sequence that came from the same SCOP family as the query fragment was considered a true positive match, each match from a different SCOP fold was considered a false positive, all other matches were ignored. For each query fragment, the area under the curve (AUC) of the receiver operating characteristic (ROC) curve up to the fifth false positive match (AUC5) was calculated (e.g. when all true positives in the scop25db set are found before the first false positive this yields an AUC5 of 1.0). The cumulative distribution of the 7616 AUC5 values inreflects the sensitivity of a tool, e.g. the area under this curve is the average AUC5 over all queries. SWIPE is more sensitive than BLAST and both are substantially more sensitive than the other tools. MMseqs-sens is by far the most sensitive of the fast tools even though it is 500 time faster than BLAST while the DIAMOND, UBLAST and RAPsearch are only 300, 124 and 59 times faster than BLAST. MMseqs-sens is, somewhat surprisingly, about 12% more sensitive than MMseqs-fast while only being twice slower. The strongest differences are observed for the most difficult cases, as is evident from the fraction of true positive pairs found before the fifth false positive match, plotted for different sequence identity bins (as determined by SWIPE) (). MMseqs-sens is 8 times faster than UBLAST and 16 times faster than RAPsearch2 but finds 22% more homologs than UBLAST and 15% more than RAPsearch2. MMseqs-sens detects 44% more TP than DIAMOND while being 1.7 times faster.
Searching with full-length SCOP25 sequencesWe then repeated the same analysis as before using the full-length sequences in SCOP25 (average length  166 residues).shows the results of the AUC5 analysis for this query set. All tools achieve better performance, since the longer query sequence contain more information to link them to their homologs. The tools' performance relative to each other is similar as before, although the performance gap between UBLAST and MMseqs-fast has closed. Again, the increased sensitivity of MMseqs-sens over UBLAST and RAPsearch2 is most apparent at low sequence identities ().
Clustering performanceWe used the scop25db set containing 283 406 sequences together with the SCOP25 set of 7616 sequences described above to test the ability of clustering tools to cluster similar sequences together. These single-domain sequences are on average about half as long as full-length sequences. However, since we demand the alignments to cover at least 80% of the longer sequence, the problem of non-transitivity that one faces when clustering multi-domain sequences is largely precluded. We therefore expect this dataset to yield results approximately comparable to those we would obtain when clustering multi-domain sequences.compares three variants of MMseqs clustering with each other: simple one-step clustering with the greedy algorithm also used by CD-HIT and USEARCH ('MMseqs greedy'), one-step clustering using the greedy set-cover algorithm ('MMseqs set cover'), three-step cascaded clustering using the greedy set-cover algorithm at each step ('MMseqs 3-step') and three-step cascaded clustering with high sensitivity ('s 7' instead of 's 4', 'MMseqssens 3-step'). We performed clustering runs with five different minimum sequence identity thresholds, 0.3, 0.4, 0.5, 0.6, 0.7, and. Sensitivity of sequence search tools and clustering performance. (A) AUC5 analysis for short peptide queries: Each of 7616 query fragments of length 50 sampled from SCOP25 was searched against the 283 406 sequences of the scop25db set and the area under the ROC curve up to the fifth false positive match (AUC5) was computed. A true positive (TP) match is from the same SCOP family, a false positive (FP) match from a different SCOP fold. The plot shows the cumulative distribution of AUC5 scores for the 7616 queries. The numbers in the legend indicate the search speed relative to BLAST. (B) Fraction of true positives found for sequence identity bins [0.3,0.4[, [0.4,0.5[, [0.5,0.6[ and [0.6,0.7[. (C, D) Same as A and B, respectively, but using the full length sequences in SCOP25 as queries. Numbers of clusters for various versions of MMseqs (E) and other tools (F) obtained by clustering the scop25db set with 291 022 sequences compared the performance reflected by the number of clusters found at the given threshold. Clearly, the greedy set-cover algorithm performs much better than the simple greedy algorithm, even though its speed is comparable. Not surprisingly, the more sensitive sequence comparisons in MMseqs-sens 3-step lead to deeper clustering in comparison with MMseqs 3-step. The 3-step cascaded clustering improves over 1-step clustering by a remarkable margin both in terms of sensitivity and speed. The reason is that reducing the number of sequences from, say, N 0 to N 1 speeds up the following clustering step by N 0 =N 1  2. In other words, in single-step clustering all true-positive sequence pairs are detected at the maximum level of sensitivity, which is costly, whereas in cascaded clustering most sequence pairs are detected at a lower and faster sensitivity level. We compared MMseqs 3-step and MMseqs-sens 3-step with popular tools for clustering protein sequence sets: BLASTclust from the BLAST NCBI package (), CD-HIT, (), kClust () and USEARCH (Edgar, 2010;). Since all tested tools compute either an exact SmithWaterman local alignment or a banded version, their E-values are either worse or very similar to the E-value for the best Smith-Waterman alignment. For this reason, all clustering tools produce clusterings with a similarly low number of false positive pairs, i.e. non-homologous sequence pairs within the same cluster (see Supplementary). We can therefore assess the sensitivity of the clustering tools through the number of clusters they produce at a given maximum sequence identity per cluster and by the speed of clustering. A speed comparison on the clustered dataset does not make sense since it is too small for a meaningful speed benchmark. The results on clustering quality therefore have to be viewed in the context of the clustering speeds measured on the full UniProt database (Supplementary) For all tools a minimum coverage threshold of the longer sequence of 0.8 was used, and all tools except the unparallized kClust and USEARCH were told to use 16 cores. (See Supplementary Material for the command-line options.) All clustering tools except CD-HIT are faster than BLASTclust by a factor of 1000 or more at all clustering thresholds. For high clustering thresholds, the tools achieve similar sensitivity, as it is simple to find the pairs with high sequence similarities. For a low threshold of 0.3, differences become quite dramatic. Usearch produces 3.5 times more clusters than MMseqs 3-step while running at similar speed, MMseqs-sens 3-step and BLASTclust beat USEARCH in clustering depth by a factor 7. Remarkably, MMseqs-sens 3step reaches sensitivities similar to BLAST over the entire range of thresholds despite being hundreds of times faster (See Supplementary2). To gain a more detailed view of the clustering results of the various tools, Supplementaryshows the cumulative size distributions of clusters for threshold of 0.3, corresponding to the leftmost point in. These distributions quite closely reflect the different performances of the underlying sequence similarity searches. To test the updating workflow in, we randomly divided the scop25db sequence set into 10 equally sized parts, clustered the first part by cascaded clustering and then successively updated it using the second, third etc. up to the tenth part of the sequence set. Supplementarycompares the size distribution of the resulting clusters with the size distribution obtained by applying cascaded clustering with default parameters to scop25db. The ten-step updating resulted in slightly fewer and larger clusters. Finally, we measured the speed and number of clusters obtained when clustering the UniProt database with 54 790 250 sequences down to various sequence identities. We clustered UniProt with MMseqs and USEARCH, the only two tools that are able to cluster such a large database down to the sequence identities of 50% and below. USEARCH requires 11 days and 2 hours for the clustering and produces 9 822 910 clusters, i. e. an average of 5.5 sequences per cluster. MMseqs requires 8 days and 17 hours for the clustering and produces 6 374 156 clusters, i. e. an average of 8.5 sequences per cluster. From an estimate of the runtime of BLASTclust, this is 2000 times faster than BLASTclust (see Supplementary Material Section 2.3 andfor full results).
Discussion and outlookThe core of MMseqs is its prefiltering algorithm, to which it owes its favourable combination of high speed and sensitivity. In contrast to most fast search tools, MMseqs does not follow the seed-andextend paradigm. Instead of depending on a local high similarity, MMseqs' prefilter aggregates evidence for the homology of sequence pairs over their entire length, explaining its success. But this algorithm also makes the prefilter inherently less sensitive to detect short local similarities in relatively long sequences. Since most pairwise alignments above 30% sequence identity will be homologous over most of their length, this is not a severe limitation yet. In the future, we have plans to improve the sensitivity of the prefilter enough to reach sensitivities of BLAST at several hundred times their speed. This will only be possible with a prefiltering algorithm that scores alignment similarities in a more local way and by eliminating the random memory accesses in the innermost loop. We are also working on extending MMseqs to profile searches and to nucleotide sequence comparisons. We hope that MMseqs will be able to facilitate and improve the analysis of large sequence sets as produced by massive genome sequencing and metagenomics experiments.
Bioinformatics, 32(9), 2016, 13231330 doi: 10.1093/bioinformatics/btw006 Advance Access Publication Date: 6 January 2016 Original Paper at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
M.Hauser et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
