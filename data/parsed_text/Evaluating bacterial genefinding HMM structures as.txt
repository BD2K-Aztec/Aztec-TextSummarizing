Motivation: Probabilistic logic programming offers a powerful way to describe and evaluate structured statistical models. To investigate the practicality of probabilistic logic programming for structure learning in bioinformatics, we undertook a simplified bacterial gene-finding benchmark in PRISM, a probabilistic dialect of Prolog. Results: We evaluate Hidden Markov Model structures for bacterial protein-coding gene potential, including a simple null model structure, three structures based on existing bacterial gene finders and two novel model structures. We test standard versions as well as ADPH length modeling and three-state versions of the five model structures. The models are all represented as probabilistic logic programs and evaluated using the PRISM machine learning system in terms of statistical information criteria and gene-finding prediction accuracy, in two bacterial genomes. Neither of our implementations of the two currently most used model structures are best performing in terms of statistical information criteria or prediction performances, suggesting that better-fitting models might be achievable. Availability: The source code of all PRISM models, data and additional scripts are freely available for download at: http://github .com/somork/codonhmm.
INTRODUCTIONProtein coding potential has long been recognized as the most important signal for automated gene finding (). The introduction of Hidden Markov Models (HMMs) for gene finding bysparked the production of a large number of HMMbased, single-sequence gene finders that capture this signal and other signals (). * To whom correspondence should be addressed.Restricting our survey to the simplest case of bacterial genefinding, the basic codon structure of protein-coding genes has so far been modeled using the following structures: The Ecoparse gene finder introduced byis based on a standard HMM architecture with a silent state governing codon distributions via transitions to 64 separate three state submodels where each state of the codon submodels had fixed emissions of a single character.introduced the Generalized Hidden Markov Model (GHMM), a type of HMM with duration offering the possibility of emissions of sequences rather than just characters from each state (). Most single sequence de novo gene finders have since been based on GHMM's using either emissions of codons according to a three-periodic inhomogeneous Markov Chain () or using higher ordered emissions, typically fifth ordered () or variable ordered emissions (). The single character emitting HMM based gene finder models has subsequently been elaborated by also using higher ordered emissions (), as well as using Acyclic Discrete Phase type length modeling (), in Easygene and Agene (). A large number of different HMM architectures have been developed during the recent decades including profile-HMMs (), pair-HMMs (), input output HMMs or transducers (), factorialHMMs () and mixed memory HMMs (). These models each combine different numbers of emitted sequences, hidden state chains, delete and insert states and different conditioning schemes for emission probabilities and transition probabilities. Employing as efficient model structures as possible for biological sequence analysis is paramount for coping with the vast amounts of sequence data currently being generated. The structure space of possible different combinations is large and exploring it for efficient models for biological sequence analysis is limited by the time-consuming development of dedicated machine learning algorithms and benchmarking procedures. Additionally, efforts to directly compare models are clouded by implementation differences and the heuristic fine-tunings developed through the decades that optimize the models in terms of the sequence analysis task at hand. To overcome these challenges, we use the probabilistic logic programming language and machine learning system PRISM. PRISM offers a generic representation of a large number of diverse model types that subsumes HMMs, SCFGs and Bayesian Networks. The PRISM machine learning system uses a general setPage: 637 636642
Probabilistic logic programsof algorithms to perform machine learning tasks for all models (). Using this approach, we can directly compare the performance of the underlying model structures of various gene finders without differences due to training procedures, the inclusion of different kinds of additional signals, pre/post-processing of data or other implementation differences. The generalized nature of PRISM programs allows the formulation of all types of model structures previously used as well as non-standard conditioning schemes (such as mixed memory HMM's) and the ability to export those conditioning schemes to other types of models [such as pairHMMs, factorial-HMMs and Stochastic Context Free Grammars (. An alternative approach for using PRISM for evaluating gene finder programs based on artificially generated datasets is given in Christiansen and Dahmcke (2007).
APPROACHTo keep things as simple as possible, our preliminary benchmark uses the well-studied test case of bacterial gene finding. We use Escherichia coli as a test bed for our model structure comparisons, due to the availability of experimentally verified annotations and textbook gene structures. To test the robustness of the performance of the models, we have duplicated the experiments using a distantly related (and less well annotated) Bacillus subtilis genome. We evaluate the performance of the models based on learning statistics from learn sessions on the complete experimentally verified E.coli dataset as well as on prediction performances based on 5-fold crossvalidation experiments for both genomes. In order to compare the performances of different gene finder model structures, we have implemented the first HMM-based gene finder model structure (ecoparse), the two most common current model structures that capture protein coding potential: a structure with fifth ordered emissions and one with inhomogeneous three-periodic Markov chain like emissions, as well as two new types of structures consisting of a model based on a amino acid hidden state sequence and a model based on a mixed memory HMM. In addition to the basic model structures, we have also included two straightforward extensions of the model structures: the first extension involves length modeling, an important feature of contemporary gene finders. Since the codon usage of highly expressed, normally expressed and laterally transferred/phage genes are known to differ (), the second extension are three-state versions of the models that encode these three separate classes of genes.
METHODS
PRISMPRISM is a logic programming language and machine learning system (). The earliest general-purpose engine for bioinformatics automata was implemented in Prolog by; PRISM is effectively a probabilistic dialect of B-prolog, allowing a pure declarative approach that unifies the description of model and data. The distinguishing feature of PRISM is the build-in predicate msw/2, that represents discrete random variables. This allows Prolog's abducible facts to be assigned probabilistic parameters. Executing a query using a tabled variant of the prologs SLD resolution produces a tabled search treean explanation graph (corresponds to a dynamic programming matrix), enabling efficient parameter estimation using a generic expectationmaximization algorithm running on explanation graphs as reviewed in Sato (2009). The usefulness of HMM's is based on a small set of algorithms for 'decoding' a sequence, i.e. calculating the most probable path * and its probability P( * )(the Viterbi algorithm), the total probability of a sequence (the Forward algorithm or the Backward Algorithm) and the posterior probability that a specific character at a given position is emitted by a certain state (a combination of the Forward and Backward algorithms) and training models on data (the BaumWelch algorithm) (). These algorithms are subsumed by the graphical EM algorithm that PRISM runs on the proof tree-like structures generated by a PRISM model, which means that as soon as one has formulated a PRISM model, one can parameterize it via EM from training data, calculate various probabilities of interest, use the parameterized model to decode data as well as generate simulated data from the parameterized model (). In addition to the standard EM algorithm and a Deterministic Annealing EM algorithm () that produces estimates of the maximum likelihood parameter values of a model, PRISM also offers a variational Bayes EM algorithm () and a Deterministic Annealing Variational Bayes EM algorithm ().
HMMsAn HMM is fully characterized by a set of transition probabilities between unobserved states and a set of emission probabilities of observed characters emitted from states. The structure of an HMM can be identified from the factorization scheme used to calculate the joint probability P(O,,) of an observed sequence O and a hidden state path. Given an observed sequence O = x 1 ,x 2 ,...,x n and a path =  1 , 2 ,..., n , the transition probabilities a kl are defined for position i and states k and l, as:and the emission probabilities e k (b) are defined for path , character x in position i, state k and character b, as:The joint probability of observing the sequence X and the path is:The PRISM equivalent of a HMM is a collection of " values " predicates, declaring the values that can be taken by various random variables. These random variables represent the outcome spaces for probabilistic transitions and emissions. A recursive structure, with predicates for initiation and termination, connects these random variables to the state and emission sequences, specifying the partitioning scheme of the joint probability. The following is the complete source code of a 2 state DNA HMM (% marks comments) % parameters: values(transition(state(begin)),[state(1),state(2),). values(transition(state(1)),[state(1),state(2),). values(transition(state),[state(1),state(2),). values(emission(state% initiation: model(Observables) :recursion(state(begin),Observables).
S.Mrk and I.Holmesa sequence into samples once, get_samples(1,model(X),Samples). Since the outcome spaces are shared for transitions and emissions a more compact program would be the replacement of the parameters section with:where the underscore denotes 'the anonymous variable' which is simply a placeholder for any logic variable. Note that except for the values and msw predicates that are special PRISM predicates, the names of the remaining predicates and variables are arbitrary and replacing them with single letters would result in a program with the exact same properties (consisting of a single line of code with 138 characters including 5 white spaces). The elegant brevity of the source code for a HMM given as a PRISM program and its close structural resemblance with the model architecture makes it very easy to produce novel models via small changes, e.g. changing the emission probabilities to:and the recursive formula to: recursion(state(Si),P1,):msw(emission(state(Si),P1),Xi), msw(transition(state(),NS), recursion(NS,Xi,Rest). transforms a standard HMM into a second-order HMM with emissions conditioned on the present state and the previous emission, whereas changing to:).
withrecursion(state(Si),P1,):msw(emission(state(),Xi), msw(transition(state(),P1),NS), recursion(NS,Xi,Rest). is a second order like mixed memory HMM with transitions conditioned on present state and previous emission. In the following, we will use such model extensions to develop novel model structures suitable for modeling protein coding potential.
Models of protein coding potential@BULLET iid.psm is an IID like zeroth order emission HMM with a single state that emits over the alphabet of {acgt}. The model captures base frequencies and has a geometric length distribution. This type of model has traditionally been used as null model or as a model of intergenic sequences. @BULLET mc5.psm is a fifth order Markov chain like HMM, with a single state and emissions conditioned on state and five previous emissions. The model captures di-codon preferences of coding regions. @BULLET i3pmc.psm is a inhomogeneous three-periodic Markov chain with three sequential states with the emission of the first state conditioned on state, the emission of the second state conditioned on state and the previous emission, and the emission of the third state conditioned on state and the two previous emissions. All states emits from {acgt}. @BULLET eco.psm the ecoparse architecture with three consecutive states with single symbol emissions for each codon combination and a single silent state to control the codon distribution. @BULLET aa.psm has 20 hidden states corresponding to the 20 amino acids that emits synonymous codons. The hidden state path corresponds to the translated amino acid sequence of the encoded protein. aa models(b)codon bias and amino acid sequence composition of the encoded protein simultaneously. The model assigns higher probability to synonymous than non-synonymous sequences, hence it is capable of attaining higher likelihood if the genes have more similar amino acid sequences than nucleotide sequences. The amino acid frequencies are governed by transitions from a silent state. @BULLET mm.psm is a three state mixed memory HMM () with higher ordered transitions, i.e. with transitions conditioned on the previous emissions. The model recognizes start and stop codons via making the transition probabilities conditional on the previous two and the present emission. Triplet emissions with first position conditioned on state, second position conditioned on state and previous emission and third emission conditioned on state and previous two emissions. All models (except iid.psm that is only used as null model) comes in three variants: a standard version as outlined above, an Acyclic Discrete Phase Type (ADPH) length modeling version, and a three-state version with three separate states that cannot transition to each other (e.g. once there is a transition to one of the states, the state path stays in that state until the end state) that corresponds to the three classes of bacterial genes: highly expressed genes, normally expressed genes and laterally transferred/phage genes. ADPH versions are created via adding six lines of code to the models and the three-state versions by adding two lines of code to the models. A graphical presentation of the standard version model structures are given in.
Page: 639 636642
Probabilistic logic programs
EXPERIMENTS AND RESULTS
Training dataThe E.coli genome used is the Refseq NC_000913.2 wild-type K12 strain MG1665 genome (). The E.coli training set comprise the 2413 experimentally verified E.coli MG1665 genes from the ecocyc annotation () with canonical start and stop codons and no frameshift mutations. The complete verified ecocyc training set comprises a total of 2.487.654 nucleotides. The Bacillus training set used is the Refseq NC_000964 B.subtilis subsp. subtilis str. 168 (). The complete Bacillus training set comprise 4155 genes with canonical start and stop codons and no frameshift mutations from the .gbk annotation (3.695.139 nt in total). The E.coli test set comprises all 68.826 potential ORFs from canonical start codon (ATG, GTG, TTG) to canonical stop codon (TAA, TAG, TGA) with a length over 60 nt (13.554.717 nt in total). The Bacillus test set comprises the equivalent 63.198 potential ORFs (11.438.079 nt in total). Training sets for all crossvalidation studies were produced by randomly assigning the genes of the full training set into five subsets. The E.coli cross-validation training sets contains  500 genes each (see Supplementary Material for exact dataset sizes). Each cross-validation training sets were removed from the test sets and golden standards for the prediction performance evaluations. All sequence sets were converted to a format compatible with the PRISM models, i.e. a collection of e.g.: 'model([a,t,g,a,a,a,t,a,a]).'. Prediction performances were evaluated using the complete training sets as golden standards.
Training algorithmsAll models are written as .psm files (available in for download). An additional prolog file default_setting.pl contains code for batch execution and settings of learning modes. The models were trained on the training datasets using learn with standard settings of VBEM [see default_setting.pl andfor instructions and other available options] with learning statistics and parameter values stored in separate files. Viterbi probabilities were calculated using viterbi.
Learning statisticsPRISM reports the following information relevant for model selection: the size of the explanation graph, the size of the table space used, the number of EM iterations, the total time of learning, the number of parameters, the number of parameter instances and the variational free energy values obtained after VB-EM learning. The variational free energy score is an approximation of log of the marginal likelihood (like the Bayesian Information Criterion), and is explained in detail in.shows a summary of the statistics from the learning sessions.
Prediction accuracyPrediction accuracy was obtained using log-odds values obtained from the Viterbi probabilities of all potential open reading frames with a length over 60 nt for a given model and its null model (iid.psm). The log odds scores of the potential ORFs sequence were divided into a positive set (according to the golden standard) and a negative set. Confusion matrices and prediction performance metrics were calculated using all observed log odds scores of the positive set as thresholds. In order to ensure that a choice of log odds thresholdis not biased in favor of any particular model, the prediction metrics example reported is the one that for each model maximizes the difference between true positive rate (TPR) and false positive rate (FPR), corresponding to the intercept of the ROC curve with the parallel to the no-discrimination line. Performance measures are all based on accurate prediction of stop codon position only, since discovery of novel genes is more interesting than correctly annotating the starting position of an already known gene. Prediction performance was determined by TPR (sensitivity/precision), FPR (Recall) and ROC curve area under the curve (AUC) value. AUC values were calculated from the pairs of TPRs and FPRs using the trapezoidal rule, which given the large number of points should be a relatively close approximation (). Subsequently, the significance of the ranking of the models based on AUC were calculated through pairwise paired t-tests in R. The receiver operator characteristics (ROC) curves from the E.coli cross-validation experiments is given for the standard versions of the models in. (ROC curves for all the cross-validation experiments are available in Supplementary Materials.)
S.Mrk and I.Holmes
RESULTSThe performance of the models both in terms of statistical fit ranked as per the variational free energy value after training on the complete training set and in terms of prediction performance evaluated via cross-validation experiments suggests the following general ranking: aa >= eco >= mm > i3pmc > mc5. Interestingly, the model structures that performed the worst were the the two currently most popular model structures: the fifth order Markov chain model (mc5) and the three-periodic inhomogeneous Markov chain model (i3pmc). With a single exception (mm), ADPH length modeling has an averse effect on the prediction performance, whereas using the three-state versions dramatically improved the performance of all models. Even though the difference inFor each of the model versions, values are reported for comparisons within class only. Alternative hypothesis is that row entries are greater than column entries.
DISCUSSIONThe findings of this study have been based on very architecturally simple models of protein coding potential only. We have used bacterial gene finding as a test environment favoring a thorough comparative test of the most prominent current single sequence bacterial gene finder model structures. Our results are not directly comparable to prediction performances of current state of the art gene finders in absolute terms, since we do not employ the heuristics that have been carefully developed through the last decades. However, as more and more data amasses we need as powerful models as possible. We propose that systematic testing of underlying model structures in a language where the model is foregrounded is a valuable approach to constructing reliable models for real-world applications.
CONCLUSIONWe have developed and tested a number of both new and existing gene finder architectures for modeling protein coding potential inPage: 641 636642For each of the model versions, values are reported for comparisons within class only. Alternative hypothesis is that row entries are greater than column entries. a generalized framework that permits direct comparisons of the performance of the underlying model structures. Our approach demonstrates that there are very efficient model structures hidden in the vast structure space of non-standard HMMs. Specifically, the novel structures presented here seems promising candidates for advancing gene finding and additional biological sequence analysis tasks that rely on protein coding potential. Additionally, the general approach that we have used for exploring HMM structures for capturing protein coding potential is a promising route to exploring and discovering efficient models used for more complex biological sequence analysis tasks (such as RNA structure prediction or modeling viral genomes). Lastly, we have shown thatthe probabilistic logic programming language, PRISM, is a capable framework for the rapid prototyping and benchmarking of statistical models in bioinformatics, up to datasets the size of small (bacterial) genomes.
Probabilistic logic programs
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
% recursion structure: recursion(state(Si),[Xi|Rest]) :msw(emission(state(Si)),Xi), msw(transition(state(Si)),NS), recursion(NS,Rest). % termination: recursion(end,[]). This fully functional PRISM program can be parameterized, decoded to or sampled from using built-in PRISM functions. For example, to fit the model to a sequence 'aaagt', one could use learn([model([a,a,a,g,t])]).; to Viterbi-decode that same sequence, viterbif(model([a,c,g,t])).; and to sample
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Table 3. P-values from pairwise paired t-tests of the ranking of the standard models of the AUC values of the ROC curves from the E.coli verified ecocyc cross-validation experiments > aa_ s/3/a eco_ s/3/a i3pmc_ s/3/a mc5_ s/3/a mm_ s/3/a aa 2.048e-05 9.768e-06 2.095e-05 1.676e-05 eco 1 1.848e-06 3.612e-05 1.393e-05 i3pmc 1 1 4.526e-05 1 mc5 1 1 1 1 mm 1 1
