Motivation: Determining the interaction partners among protein/domain families poses hard computational problems, in particular in the presence of paralogous proteins. Available approaches aim to identify interaction partners among protein/domain families through maximizing the similarity between trimmed versions of their phylogenetic trees. Since maximization of any natural similarity score is computationally difficult, many approaches employ heuristics to evaluate the distance matrices corresponding to the tree topologies in question. In this article, we devise an efficient deterministic algorithm which directly maximizes the similarity between two leaf labeled trees with edge lengths, obtaining a score-optimal alignment of the two trees in question. Results: Our algorithm is significantly faster than those methods based on distance matrix comparison: 1 min on a single processor versus 730 h on a supercomputer. Furthermore, we outperform the current state-of-the-art exhaustive search approach in terms of precision, while incurring acceptable losses in recall.
INTRODUCTIONThe vast majority of cellular functions are exerted by combinations of interacting gene products. As a result, 'preservation of functionality' among proteins and other gene products typically implies 'preservation of interactions' across species. It is well established that proteinprotein interactions (both physical interactions as well as co-occurence of domains) are preserved through speciation events [see Lovell and Robertson (2010);and the references therein]. A major implication of this is that the evolutionary trees behind two interacting protein families can look near-identical. As interacting proteins have a tendency to co-evolve, it may be possible to assess the potential of two or more proteins (or other gene products) being interaction partners by measuring how similarly they evolve across related species. For this purpose, a number of computational strategies have been developed. Such strategies aim to compare the phylogenetic trees of two (or more) protein or protein-domain families, where paralogs and orthologs are represented with leaves with appropriate labels and internal vertices can be interpreted as either speciation or duplication events. Among these strategies we will focus on mirrortree approaches, which explicitly or implicitly map leaves of a pair of trees (belonging to two distinct proteins or gene products) onto one another such that the leaves that are mapped to each other would be identified as potential interaction partners. Mirrortree approaches aim at an overall quantification of 'family similarity' via a measure of tree similarity. Typically, these approaches do not aim to modify the specific topology of the underlying phylogenetic trees and thus are different from tree reconciliation approaches (). They are also distinct from phylogenetic profiling methods (), which aim to measure the phylogenetic profiles of proteins or domains to check for potential interaction partners. The first mirrortree approach was proposed to discover protein protein (rather than domaindomain) interactions and was based on comparing the distance matrices 1 resulting from the multiple alignment members of each protein family (). Note that one can interpret this as mapping leaves onto one another, as will be explained below. Since this study, a number of mirrortree approaches have been developed; almost all of these approaches are again based on comparing distance matrices rather than the trees directly (see the introductory paper byand Pazos and Valencia (2008) for more references). In fact, direct comparison of gene trees has been considered as '... a problem yet to be fully resolved.' (. In this article, we consider a fresh approach to the problem of predicting protein or other gene product interactions by comparing gene trees directly, without the aid of a distance matrix. Note that such a distance matrix is a byproduct of the underlying phylogenetic tree: popular multiple sequence alignment methods typically align sequences in the order imposed by their phylogenetic tree and the 'distances' in the matrix correspond to the distances in the phylogenetic tree. As a result our method should be considered as a more direct approach to mirroring trees. In the case where there are no paralogs of any gene, assessing tree similarity is both computationally straightforward and reliable (). More specifically, if there is at most one family member per species, the mapping problem reduces to
Aligning phylogenetic treesthe problem of finding out species where the interaction is lost; after removal of such species, the topologies of the two trees will be identical, i.e. the leaf representing a particular species in one tree will correspond to the leaf representing the same species in the other tree. In the presence of paralogous genes (and thus proteins or gene products), however, the mapping problem becomes much more complex. For example, if we have n paralogs per tree for one of the species, we may need to evaluate more than n! many potential mappings (n! is the number of mappings where each paralog from one tree pairs with a paralog from the other tree. In addition, there are mappings where one has to remove non-interacting paralogs. As was pointed out in, protein interaction can be preserved during duplication, while interaction can be lost during speciation.). Thus, the number of potential mappings is superexponential in the number of paralogs per species, implying a significant computational challenge. There are a number of mirrortree approaches which address the presence of paralogs and aim directly at inferring the correct mapping of leaves; these approaches typically aim to 'align' the distance matrices by shuffling and eliminating the rows (and corresponding columns) so as to maximize the similarity between the matrices. The similarity between two aligned matrices is defined in the form of root mean square difference (), correlation coefficient (), informationtheoretic 'total interdependency' of multiple alignments (), Student's t () or the size of the largest common submatrix (). Because an exact solution to the matrix alignment problem, where the goal is to maximize any of these notions of similarity (by determining the right mapping of rows and columns), is hard to compute, many available approaches employ heuristics based on swapping pairs of rows/columns in a greedy fashion. These methods also commonly perform column/row elimination from the 'larger' matrix only, and not the other (). We are aware of one exception by (), which aims to determine the largest common (i.e. within a threshold) submatrix and removes the remainder of the columns and rows from both matrices. Similarly the only approach which directly compares the tree topologies themselves is by, which uses a Metropolis algorithm to heuristically travel 'tree automorphism' space. However, this approach cannot handle trees of different sizes. See Lovell and Robertson (2010);; andfor references on mirrortree approaches which do not necessarily relate to the mapping problem in the presence of paralogs. In this article, we present polynomial-time algorithms that determine mappings of leaves which respect the topologies of the two trees compared. As input, we are given two 'gene trees' T and T of two protein/domain families known to interact with one another. T and T have labeled leaves where labels reflect species such that the presence of the same label at two different leaves reflects the presence of paralogs. We introduce and formally define the gene tree alignment problem, which aims to delete both leaves and inner vertices from both trees until the remaining trees are isomorphic, that is, one can map the vertices of the two remaining trees in a one-to-one fashion onto another such that ancestor relationships are preserved. This in particular implies a one-to-one mapping of the remaining leaves, which we present as output. Clearly, there are many different possible choices of such one-to-one mappings of leavesour algorithms determine the score-optimal such alignment where different deletion operations are penalized in different ways, depending on how they transform the topologies of the trees. Note that our algorithm depends on some (user-defined) cost parameters, that can be used to impose constraints on the alignment. We describe the nature of our scoring scheme in detail in the following; please see Section 3 for full details and precise notations. Note that the algorithm only outputs one uniquely determined, score-optimal alignment of subsets of leaves of T ,T. Note further that we do not perform an exhaustive search since we never consider mappings of leaves which imply mappings of internal vertices that do not preserve ancestor relationships of the gene trees T ,T and thereby contradicts their topologies. Our method can be viewed as an extension of tree-edit distance approaches. Alternative constraints leading to polynomial time solvable variants on the tree edit distance is surveyed in Zhang (1996). For further, more recent work see alsothat address the subtree homeomorphism problem, which, given a 'text' tree T and a 'pattern tree' P as the input, asks to find a subtree t in T such that P is homeomorphic to t. Now, two trees T 1 ,T 2 are said to be homemorphic if one can remove degree 2 vertices from T 1 ,T 2 such that T 1 and T 2 are isomorphic. Another recent work () considers homeomorphic alignment of 'weighted' but unlabeled trees. Here the goal is to obtain a homeomorphic mapping between vertices of two trees such that the differences between the weights of 'aligned' edges is minimized. While being related to our approach, the method described inis not applicable to our problem as the trees they consider are not leaf labeled. We refer the reader tofor a general and gentle overview of further related work on tree edit distance, tree alignment and tree inclusion. The main technical contribution of this article is a novel deterministic mirrortree algorithm that directly compares tree topologies. The algorithm is optimal within the constraints we impose and is provably efficient. We compare our algorithm with the most recent, state-of-the-art heuristic search approach () that aims to maximize the similarity between distance matrices, where distances reflect lengths of shortest paths in neighbor-joining trees. In our comparisons, we use precisely the same trees to be able to juxtapose a distance matrix-based heuristic search method to our topology-based, deterministic method without introducing further biases.
PRELIMINARIES AND NOTATIONSLet T = (V ,E,w) be a tree with weighted edges as given by a nonnegative weight function w : E  R +. We denote the leaves of T by L ={ 1 ,..., n }, the internal nodes of T (excluding the root) by U ={u 1 ,...,u m } and the root of T by r. In particular, let n be the number of leaves and m be the number of internal vertices without the root. Note that a tree T is binary and rooted if and only if deg(r) = 2 and deg(u) = 3 for all internal vertices u  U; this will imply that m = n2 and |E|=2n2. In our setting, edge weights w(v i ,v j ) reflect the evolutionary distance between adjacent vertices v i ,v j. Note that leaves refer to gene products whereas internal vertices can be interpreted as speciation and/or duplication events. For a given vertex v  V , we define (v) as the evolutionary distance
I.Hajirasouliha et al.between the root and v. In other words, (v) is the sum of the edge weights in the unique path from the root to v. In rooted trees, there is a natural partial order v i  v j  v i is an ancestor of v jon the vertices of T. Hence, the edges have a natural orientation and each vertex v i induces a unique subtree T (v i ). This partial order is crucial for our algorithmwhich cannot be applied to unrooted trees in a straightforward manner. For processing unrooted (e.g. neighborjoining) trees, consider the pair of proteins/domains (one from each tree) which are known to interact. We root the two trees at these vertices in order to apply our algorithm. Provided such a pair exists (which is typically the case), our algorithm optimally aligns the trees as it does not assume any order among the many sibling vertices. In a tree T which is rooted at r, we call vertex u the parent of a vertex v if u and v are connected by an edge and u is closer to r than v. The height of a rooted tree is defined as max{d(r,, i ) | i = 1,...,n} where d(v 1 ,v 2 ) is the length of the shortest path between vertices v 1 and v 2 without considering edge weights, that is the maximum (unweighted) distance of the root to a leaf. We denote a bijection (i.e. a one-to-one and onto alignment) of subsets of vertices of T ,T by Mand writefor the pairs of mapped vertices. Note that in such a bijection, not all vertices of T are necessarily mapped to a vertex in T and vice versa. We refer to vertices which are not mapped as deleted by M. We only consider alignments which satisfy the following: (i) the alignment preserves the ancestor relationship of T and T ; (ii) only leaves with identical labels are mapped onto one another; and (iii) upon deletion of vertices, where deletion of an internal vertex v leads to new edges joining the parent of v with the children of v, the two tree topologies are isomorphic. Among the alignments satisfying the above conditions, we compute the alignment that has maximum score. For a formal definition of our scoring scheme, consider the internal vertices of T and T that are deleted. Among them, we distinguish between vertices v that have descendants x which are not deleted. We write N I for such vertices. We write N T for the remaining deleted vertices. Note that each vertex v  N T makes part of a subtree of T which has been deleted as a whole. The score of the alignment is then defined asThe individual score functions S M ,S N I and S N T will be formally defined in Section 3. As noted above, our algorithm, which maximizes the overall score of the alignment, can be viewed as an extension of the standard tree edit distance algorithm for unweighted trees (), to those with edge weights. Determining the tree edit distance is NP-complete () [in fact MAXSNP-hard (. Since the instances treated here are too large (trees have up to >200 leaves) we have to impose reasonable constraints when aiming at fast, polynomial-runtime solutions. Motivated by test runs (see numbers referring to C 1,2 in Sections 4 and 5), we chose to impose the additional constraintand (a 4 ,b 1 ). that a vertex u and its parent v cannot be deleted at the same time without deleting the entire subtree rooted at v. That is we disallow to have both a parent v and a child u in N I. Note, however, that deletion of two internal siblings is permissiblewe found that such deletions can lead to favorable alignments. As the operation of deleting entire subtrees does not lead to runtime issues, does not perturb the topology of the remaining trees and also reflects the biologically reasonable assumption that interaction can be lost for entire subtrees, we allow it without additional restrictions.
METHODSGiven two rooted weighted-edge trees T and T , our algorithm aligns the trees by mapping a subset of leaves of T to a subset of leaves of T. In order to obtain this mapping, a series of (i) individual vertex deletions or (ii) subtree deletions (with specific penalties) are performed on each tree with the goal of obtaining two isomorphic treesshows two such rooted trees that are isomorphic; it also shows a mapping between the leaves. The specifics of vertex and subtree deletions on a tree T = (V ,E,w) are as follows.(1) Deleting an internal vertex v also deletes the edge (u,v), where u is the parent of v. Furthermore, it connects each child x of v to u by deleting the edge (v,x) and creating a new edge (u,x). The weight of this new edge, w(u,x) is set to w(u,v)+w(v,x). As mentioned earlier, it is not possible to delete both a node v and its parent u from T .(2) Deleting an entire subtree rooted at an internal vertex v deletes all descendants of v and their associated edges.In the remainder of this section, we will discuss the costs of the above deletion operations and the scores of the mapped vertices. As mentioned earlier, the overall score of the mapping will be the sum of the scores of the mapped vertices and the scores (negative costs) of the the deletion operations.
Scoring schemeLet T 1 and T 1 be the isomorphic trees which result from performing a series of deletion operations on T and T. The isomorphism : T 1  T 1 implies an alignment Mbetween the original trees T ,T. Let L 1 ,L 1 denote the sets of leaves that are mapped in T and T , respectively; because the mapping is a bijection, we must have |L 1 |=|L 1 |. We write SP :for the set of mapped pairs (we require that mapped leaves have identical labels hence the naming SP for 'species'). Recall that a mapping of two trees may involve deleting internal vertices or entire subtrees. We now distinguish between two types of internal vertex deletions.(1)deletion of only one child v of a vertex u. Let further x 1 ,x 2 be the two children of v. Isolated deletion of v also
Aligning phylogenetic treesimplies to also delete edges (u,v),(v,x 1 ),(v,x 2 ) and create new edges (u,x 1 ),(u,x 2 ). Note that after deletion v has three children.(2)deletion of both children (say x and y) of a vertex v. This implies deletion and creation of edges in a fashion analogous to that for isolated deletion. Note that after deletion v has four children. Accordingly, we further distinguish between isolated deleted vertices N I,iso and vertices which became deleted in parallel N I,par such that N I = N I,iso   N I,par. The idea behind distinguishing between isolated and parallel deletion is that parallel deletion reflects greater perturbation of tree topology at the same evolutionary point in time, and is less likely to occur. For a given,iso } be the set of edges which join isolated deleted vertices with their parents. Analogously, E P (M) is the set of edges that join deleted siblings with their parent. Seefor examples of isolated and parallel deletions. Given a pair of mapped leaves1leaves leaves1 ,  2  SP their alignment score,where C is a positive constant, providing a positive contribution to the overall score because of the mapping of two leaves with the same label while we subtract the difference between the distances of1of of1 and2and and2 from the root for penalizing the mapping between two leaves which have topologic differences. The total score S of an alignment Mas per the above definition is fully specified bywhere, with respect to the formulation in (3), the term in the first row is for v,v M S M (v,v ), the second row is forvN T S N T (v) is zero. E and F are user-defined constants that, respectively, penalize isolated deletion and parallel deletion of edges. Note that this penalty is proportional to the length of the edges joining the deleted vertices with their parents deletion of longer edges leads to a more severe perturbation of topology hence is more severely penalized. We set the cost of deleting a subtree (i.e. S N T ) to 0. Note, however, deleting subtrees is implicitly penalized by disregarding any potential good mappings of leaves in them. Given the above score function, the gene tree alignment problem can be formally stated as follows.Gene tree alignment problem. Given two rooted weighted-edge trees T ,T , determine subsets of leaves L 1  L,L 1  L of equal size such that the corresponding subtrees can be transformed by isolated and parallel deletion and subtree removal operations into trees T 1 ,T 1 , for which there is an isomorphism : T 1  T 1 that maximizes S(M).
A dynamic programming solutionThe gene tree alignment problem can be efficiently solved by a dynamic programming algorithm. Our algorithm runs in O(|V ||V |) time for two binary, rooted trees T ,T with vertex sets V ,V. In general, our strategy can be applied to arbitrary rooted trees with bounded maximum degree, max. Note that by allowing to delete internal vertices (i.e. contract the edges), the number of children of an internal vertex will be still bounded by a constant (4).
Initialization.As a first step, we remove all leaves that refer to species that are unique to each tree. Let n =|V | and n =|V |. For every pair of vertices v i  V and v j  V (i.e. for every i = 1,...,n and j = 1,...,n ), we compute the maximum alignment score for the subtrees rooted at v i from T [i.e. T (v i )](a)(b). A gene tree (a), with an isolated node deletion, A 5 (b) and a parallel deletion of the nodes, A 5 and A 6 (c). and v j from T [i.e. T (v j )]. We denote the maximum alignment score for T (v i ) and T (v j ) by S ij. Note that the computation of the maximum alignment score between rooted subtrees induce a mapping between their leaves. In our dynamic programming algorithm, we handle the 'base' cases, where one (or both) of T (v i ) or T (v j ) have three or fewer leaves, as follows. @BULLET If both v i  V and v j  V are leaves, then by definition, S ij = (v i ,v j ). @BULLET Without loss of generality, if v i is a leaf and v j is an internal vertex, S ij = max(S ij 1 ,S ij 2 ), where j 1 and j 2 correspond to the children of v j. @BULLET The remainder of the base cases have both v i and v j as internal vertices and are solved through exhaustive evaluation of all possible alignments.
Recursion. Internal vertices, each with at least four descendants, S ij will be computed through recurrence equations. These equations are based on the alignment scores between subtrees rooted at the children (or grandchildren) of v i and v j. Let i 1 (j 1 ) and i 2 (j 2 ) be the children of the vertex v i (v j ). Also, let i 11 , i 12 be the children of i 1 , and i 21 , i 22 be the children of i 2. Similarly, let j 11 , j 12 be the children of j 1 , and j 21 , j 22 be the children of j 2. We first give a high-level description of the recurrence equation. Suppose that the maximum alignment score between any subtree in T (v i ) and any subtree in T (v j ) has already been computed. In order to compute the alignment score S ij , we consider several cases: we can either delete one or both subtrees rooted at the children of v i and v j (deleting an entire subtree) or align the subtrees rooted at the children of v i and v j to each other. We can also delete one of the children of v i (either i 1 or i 2 ) together with one of the children of v j (either j 1 or j 2 ) and align the three resulting subtrees in T (v i ) to a permutation 2 of the ones in T (v j ). Finally, we have to consider the case where both children of the root [i.e.are deleted. In this case, we align four subtrees in T (v i ) (rooted at i 11 ,i 12 ,i 21 , i 22 ) to a permutation of the four resulting subtrees in T (v j ). The optimal alignment score of S ij will thus be the maximum alignment score provided by all of the cases above. Let e(v) denote the penalty for isolated deletion of an internal vertex v, which is the product of the constant E and the weight of the edge between v and its parent (see Section 3.1). Also, let f (v) denote the penalty for parallel deletion of both children of an internal vertex v. f (v) was defined as a constant
I.Hajirasouliha et al.F times the total weight of the edges that connect v to its children. The recurrence equation for S ij thus becomes the following0 (deleting both subtrees from each tree)where the permutation  =  1  2  3  4 ranges over all permutations of {j 11 ,j 12 ,j 21 ,j 22 }. Note that some cases are redundant but are still represented here for the sake of clarity. In case that several options yield the same, optimal score, the algorithm picks the first observed one. Now, given r and r , the roots of T and T , respectively, the alignment score S r 1 r 2 (i.e. the maximum alignment score of the rooted trees) can be computed using the above recurrence equation, providing a solution to the gene tree alignment problem. It is quite straightforward to prove that our algorithm correctly computes the maximum alignment score through a (strong) induction on the sum of the heights of the rooted trees. Note that the scores of internal vertex alignments can be computed through the scores of the alignments between their (grand)children and the recurrence precisely serves to satisfy the constraints. The base of the induction is trivial. If the minimum height of the trees is zero (i.e. one of the trees is just a single leaf), the optimal value of the alignment can be found using the definitions and simple case analysis. Given the subtrees T (v i ) and T (v j ), with heights h and h , respectively, we assume the induction hypothesis, that for all pairs of subtrees T (v p ) and T (v q ) with heights h p and h q such that h p +h q < h+h. It is easy to verify by case analysis that all cases in the recurrence equation will be reduced to a case in which the sum of the heights of the aligned (grand) children will be less.
Evaluation criteria. Wedetermine the maximum number of members of the two protein domain families under consideration that can be paired by following (): for each species we determine the paralogous members of the domain in the two trees that can be paired with one another (that is both members reside in the same protein) and determine the maximum number of pairs that can result from the respective potential pairings. Summing up these numbers yields the maximal size of a correct mapping. By the usual conventions, we denote this value as P. In other words, P is the size of the correct pairing. Among the P many potential correct pairs, we determine the ones which were inferred by the algorithm in use and refer to them as 'true positives', TP. Similarly, the number ofand the deterministic, treetopology-based approach (TreeTopology = C opt ). Baseline is determined as randomly pairing as many protein domain family members as possible. Runtimes for MatrixHeuristic and TreeTopology are 730 h and 1 min, respectively.domain pairs computed, where the respective members are not from the same protein, is referred to as 'false positives', FP. Recall (Sensitivity) is defined as Rec=TP/P and Precision (positive prediction rate) is defined as Prec=TP/(TP+FP). Note that Recall is referred to as accuracy in (). We determine Precision and Recall for each pair of trees individually. Values displayed in,
RESULTS
Data source and alternative methods.We benchmarked our algorithm against the most recent heuristic search method () for determining a mapping in the presence of paralogs on the large-scale data corpus described in the same study. This data set contains multiple alignments for 604 yeast protein domains among which 488 domain pairs are known to co-occur in the same protein. Those 488 domain family pairs are considered to be a particularly tough test () due to the presence of 6 paralogs per species on average. For all interacting domain family pairs, neighbor-joining trees were computed, using ClustalW () and the trees were rooted at the domains which are known to interact. Tree constraints. In order to appropriately assess the contribution of the different tree constraints as outlined in Section 3, we evaluated our algorithm by not allowing to delete internal nodes (C 0 ), allowing isolated node deletion (C 1 ) as well as further allowing parallel deletion of two sibling nodes (C 1,2 ), seeallow deletion of subtrees as a whole without penalty. The specific scores for these cases are as follows:
Aligning phylogenetic treesAmong the cases above C 1,2 gives the best results (seeand further comments below), implying that parallel deletions are beneficial. We experimented with several values of E and F, and noticed that it may be beneficial to impose a large penalty for parallel deletions in contrast to a relatively small penalty for isolated deletions. We concluded that an optimal choice of parameters would be E = 2,F = 50 (referred to as C Opt ), when C = 1. Note that the exact value of C is the function of neighbor-joining trees resulting from ClustalW multiple alignments alonefor different settings absolute values need to be put into perspective with orders of magnitude of edge weights of the trees under consideration. As outlined in Section 3, inducing tree constraints considerably reduces the search space, thereby allowing for an efficient and deterministic method. Given a pair of trees, let CP (constraint positives) denote the maximum number of correctly paired domains over all possible alignments of the trees. Note that one can compute, CP for any given pair of trees, by running our algorithm with a scoring scheme which assigns 1 to correctly paired domains and not penalizing any operation which the constraints allow us to do. 3 We compute RP = CP/P (relative positives) as the fraction of pairings that can still be inferred, and which measures the reduction of search space size due to imposing constraints. We further compute RelRec = TP/CP (Relative Recall) as a recall value which reflects how many of the correct pairings possible were inferred by the algorithm in question. The good RelRec values the tree topology approach achieves (0.59 versus 0.55 for the matrix-based approach, note that for the matrix-based approach this coincides with Recall since it does not impose any constraints), indicate that losses in Recall are due to imposing constraints, but not necessarily due to the scoring scheme.presents numbers of all 488 tree pairs for a canonical baseline procedure, which randomly pairs as many domain family members per species as possible, the heuristic matrix-based approach (MatrixHeuristic) and the deterministic tree-topologybased approach (TreeTopology = C opt ).furthermore presents numbers resulting from usage of different tree constraints. Following (), we also separate tree pairs according to the numbers of leaves of the larger tree and the product of the numbers of leaves of the two paired trees which, according to (), quantifies search space size. Seefor the respective results.
DISCUSSIONRuntime. The possibly most striking advantage of our topologybased approach is the drastic reduction of runtimewe can compute mappings for the 488 interacting domain families in roughly 1 min on a single CPUin comparison to 730 h on MareNostrum 4 needed for the Metropolis search performed by (). Note that there are rapidly growing large-scale phylogenetic databases such as ENSEMBL (http:// ensembl.org) or PhylomeDB (http://phylomedb.org), whose growth is further accelerated by next-generation sequencing projects (as of 12th August, 2011, PhylomeDB contains 482274 phylogenetic trees). The reduction in runtime delivered by our approach certainly overcomes a major obstaclewe render largescale mapping and, as a consequence, comparison of paralog-rich gene trees feasible. Note that this reduction has become possible by imposing both computationally and biologically reasonable constraints on the search space while at the same time allowing for an efficient scheme to find the global optimum within these constraints. Search space size/recall. Comparing C Opt with the method of () (heuristic) overall, clearly,achieve best recall. As pointed out above, this comes as no surprise since we cannot explore pairings that contradict the topologies of the paired trees. Quite surprisingly though, although usage of tree topology and neighbor-joining trees in particular have been discussed rather controversially (), we find that still the majority of pairings (54.6% with the strictest constraints and 61.2% for allowing isolated and parallel deletion) can be determined by a topology-based approach. These numbers may put usage of neighbor-joining tree topology in mirrortree approaches into a general perspective. Moreover, note that the fraction of correct domain pairs computed by our method over that of the heuristic search method is 0.7 (= TP(C opt )/TP(heuristic) = Recall(C opt )/Recall(heuristic) =
I.Hajirasouliha et al.of Precision than (), see Precision in. See alsofor a comparison with respect to search space sizerelated differences. Whileachieve excellent values on pairs of smaller trees, we outperform their approach on larger trees, with the most obvious differences on pairs of trees where the product of the numbers of leaves is large.
Conclusion.In summary, we have, for the first time, devised a deterministic and efficient, polynomial-runtime mirrortree approach which directly compares the gene trees, and not the distance matrices behind or giving rise to them. We have juxtaposed our approach with the most recent, state-of-the-art matrix-based heuristic search procedure without introducing further experimental biases. Most importantly, our tree topology-based algorithm lists efficiency as its decisive benefit. While recall is better for the heuristic search obviously due to that it does not impose any constraints on the search space, we only incur relatively mild losses. We achieve better results in precision, in particular when both of the mirrored trees are large. This leads us to the overall conclusion that the heuristic method remains the better choice for smaller trees and when runtime is not an issue. In case of larger trees and in particular for large-scale studies, our approach has considerable benefits. Note finally that we have been comparing neighbor-joining trees which have been repeatedly exposed as suboptimal choices of phylogenetic trees. We believe that our approach can gain from improvements in tree quality significantly more than the matrix-based approaches. Note finally that mapping domains can lead to ambiguous results due to that several homologous copies can co-occur in one protein. To resolve such issues is interesting future work.
The distance matrix of a gene tree is comprised of entries (i,j) which represent the distance between leaves i and j.
The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
We have to consider all the permutations because the trees are unordered (i.e. the order of siblings of an internal vertex is unimportant).
This scoring scheme assumes knowledge we are not allowed to use in the algorithm; we use this knowledge for the purpose of evaluation here.
MareNostrum is a supercomputer of the Barcelona Supercomputing Center, one of the largest machines in the world dedicated to science (Izarzugaza et al., 2008, p. 10).
