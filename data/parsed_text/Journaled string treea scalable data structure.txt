Motivation: Next-generation sequencing (NGS) has revolutionized biomedical research in the past decade and led to a continuous stream of developments in bioinformatics, addressing the need for fast and space-efficient solutions for analyzing NGS data. Often researchers need to analyze a set of genomic sequences that stem from closely related species or are indeed individuals of the same species. Hence, the analyzed sequences are similar. For analyses where local changes in the examined sequence induce only local changes in the results, it is obviously desirable to examine identical or similar regions not repeatedly. Results: In this work, we provide a datatype that exploits data paral-lelism inherent in a set of similar sequences by analyzing shared regions only once. In real-world experiments, we show that algorithms that otherwise would scan each reference sequentially can be speeded up by a factor of 115. Availability: The data structure and associated tools are publicly available at http://www.seqan.de/projects/jst and are part of SeqAn, the C++ template library for sequence analysis.
INTRODUCTIONNext-generation sequencing (NGS) has revolutionized biomedical research in the past decade and led to a continuous stream of developments in bioinformatics, addressing the need for fast and space-efficient solutions for analyzing NGS data. Especially since the sequencing efficiency of modern NGS technologies outpaced the improvement of storage capacities, which directly leads to a growing economical issue, as storing and sharing the generated information is now bounded by the available storage and network resources (). The same technology led to the generation of comprehensive catalogs for genetic variations of the human () and other organisms as well (e.g.). Moreover, the rapid advances in NGS made ambitious sequencing endeavors like the 1000 Genomes Project (), systematic studies of 425 000 cancerous genomes (The International Cancer Genome) or most eagerly the announced goal of the Personal Genome Project to sequence 100 000 human genomes () possible. Those resources then provide detailed information about the genetic diversity of entire populations, which will be important to the societal health sector to acquire better understandings of the correlation between clinical conditions and phenotypes and their corresponding genotypes. As a result, two major challenges need to be tackled. The first challenge clearly is to compress the available sequence data to relieve disk and network resources. Owing to the high redundancy of sequences originating from the same or related organism, referential sequence compression has been proven to be especially efficient for these kinds of data (e.g.). More recentlyexploited cross-sequence correlations to achieve profitable compression ratios for the data of the 1000 Genomes Project. The second challenge, however, is to devise algorithms and data structures that can handle the massive amounts of available data to incorporate those information in existing analyzing pipelines. Clearly, one solution would be to apply the algorithms sequentially to each sequence contained in the database, but the runtimes scale linearly to the number of sequences included. Thus, it is desirable to analyze the data in succinct form to archive runtimes proportional to the compressed size. This paradigm is also known as compressive genomics (). The FM-index () and the compressed suffix array (), for example, are succinct representations of indices that can be searched efficiently. Yet, indexing thousands of genomes with these data structures would still exceed currently available memory capacities by far. In the past 5 years, this problem was subject in several publications (). Here, the focus was moved from considering each sequence individually to exploiting similarities among the sequences to reduce the overall memory footprint, and to gain substantial speedups opposed to the sequential case.presented compression-accelerated BLAST and BLAT, both tools to search patterns in a non-redundant sequence library approximatively. These methods, however, require the compressed sequence library to be generated in a computationally intensive preprocessing phase.used as input a more general format consisting of a reference sequence and a set of variants for a collection of sequences, which is a common representation of the data produced by large sequencing endeavors such as the 1000 Genomes Project. Subsequently they built an index over the reference set exploiting the high *To whom correspondence should be addressed.  The Author 2014. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com similarities. Yet, the read-mapper BWBBLE () was the first practical tool capable of mapping reads against thousand genomes simultaneously. In their approach, they indexed a multi-genome reference sequence with the FM-index and adapted the Burrows-Wheeler Aligner (BWA) () to work on the indexed multi-genome. To construct the multi-genome, they needed a context size to determine the sequence context left and right of genomic regions harboring insertions or deletions; thus, the entire multi-genome and the accompanied index must be reconstructed on changes of the context size. However, there exists a plethora of algorithms for sequence analysis that are sequential in nature. That means they scan the sequences to be analyzed from left to right and perform some computation, e.g. compute an approximate matching or alignment of a query sequence to a reference sequence, or scan sequences in the context of a hidden Markov model (HMM) (e.g. De). There are many more applications such as filtering and verification algorithms in read mappers () or searching with position-specific scoring matrices (). After reading a character of the string, the algorithm will change its internal state and possibly report some results.gave an algorithm to solve the pattern matching problem with Hamming distance for a set of extremely similar sequences. In their model, they assumed that each sequence differs in around 10 positions to every other sequence within the set. To find all occurrences of a pattern within all sequences they searched first the reference sequence and used then some auxiliary tables to check if at the reported positions the pattern can be found for the other sequences too. Besides the impractical error model for real biological data, they did not provide any experiments to evaluate their method. Thus, to the best of our knowledge, we provide for the first time a general solution to generically speed up a large class of algorithms when working on sets of similar strings. We will mostly address the reduction of execution time and space of such algorithms by providing a data type, called journaled string tree (JST) that can be traversed similarly to a simple for-loop over all sequences while exploiting the high similarity. The algorithm must simply be able to store its state when asked, continue its computation from a stored state when presented with a new character and work locally, i.e. when scanning a sequence its current state solely depends on a fixed-size window of last seen characters, also called context. Our approach is based on a reference-based compression of shared sequence parts with some additional bookkeeping. For example, if lets say 1 Mb of a set of 100 genomes is shared and we want to compute a semiglobal alignment on all sequences, we will execute the alignment only once on this stretch of 1 Mb. For regions that exhibit differences, a corresponding sequence context is constructed on-thefly and then examined. We can show that our approach exhibits speedups of 4100 times when analyzing a set of 2185 sequences of chromosome 1 [two haplotypes of 1092 sequences from the 1000 genomes project () and a reference sequence] compared with running the algorithms sequentially while using only $3.8 GB of space. This speedup includes all overheads. The speedup in searching alone is up to a factor of 570.
METHODS
Wewill first give an informal description of the JST data structure and our traversal method using the example indepicting (a) three similar sequences and (b) the corresponding JST. In the example, we search for a string of length 4 using an exact string matching algorithm. In general, instead of iterating over all strings in the set sequentially, our method simultaneously traverses a set of strings from left to right. With this strategy, algorithms based on sequentially scanning a sequence can be easily extended to a large set of similar sequences, while only modest memory requirements are needed. The only additional and algorithm dependent information required is the length of the so-called sequence context, i.e. the window of last-seen characters that solely determine the internal state of the algorithm. For example, an online algorithm that searches a query of length n with up to k errors depends on a sequence context of length n + k, whereas inthe context length for exact pattern matching is the length of the query, which is 4 in this example. In our approach, we use the reference sequence r as the anchor coordinate system and store positions, so called branch-nodes, at which at least one other sequence has a "-event, i.e. a deletion of a substring of the reference sequence, an insertion of a string relative to the reference sequence or a replacement of a substring of the same length between a sequence in the set and the reference sequence. For example, in, the gray points labeled L, M, N, O are branch-nodes. The respective positions in the other sequences will be determined ondemand while scanning from left to right using a reference-based compressed representation of the sequences called journaled strings. We use a bitvector to denote which sequences have a "-event for a given reference position. During the traversal the method constructs the required sequence contexts on-the-fly using the bitvectors and respective journaled strings and presents them to the algorithm. Whenever a branch-node is encountered we store the state of the algorithm to continue computations later from that position. Once the deviating sequence part has been processed, the algorithm will be asked to restore its last state and continue with a new character. The algorithm can in addition signal after processing a character, whether it needs the information for which sequences the presented sequence context is valid, e.g. when a string matching algorithm found a match.depicts the general communication processes between the Journaled String Tree traversal and a sequential algorithm. The article is organized as follows. In Section 2.2, we describe our simple, yet fast, reference-based compression scheme; in Section 2.3, we describe how to traverse the set of strings simultaneously and apply any algorithm that sequentially streams over sequences with a limited sequence context.
DefinitionsA string s=s 0. .. s n1 is sequence of characters of an alphabet S. The length of a string is denoted as jsj=n. A substring of s is denoted as si : j=s i. .. s j1 , with 0 i5j n. The special case si : i+1 will be shortened to s. A "-event is a tuple s; i; r; j; x; " with " 2 fR; I; Dg describing the event that occurred in s at position i relative to position j in sequence r. x denotes the string associated with this event, i.e. if "=R, then x=si : i+jxj is the string replacing rj : j+jxj and if "=I, then x=si : i+jxj is the inserted string in s, otherwise if "=D, then x=rj : j+jxj represents the deleted string in r.
Journaled stringscompressed searchable stringsA journaled string is a referentially compressed version of a string s, which stores a pointer to a reference sequence r, an additional string ib, called insertion buffer, and a binary search tree J, called journal tree, over segments representing substrings of r or ib. We refer to such segments as journal entries. A journal entry is a tuple e=vp; pp; l;  2 N 3  f0; 1g, where indicates the source of the corresponding segment (0 ! r; 1 ! ib). We call an entry with = 0 an original entry and an entry with = 1 an insertion entry. vp denotes the virtual position, i.e. the begin position of this segment within the target sequence s. Accordingly, pp denotes the physical position referring to the begin position within r, if = 0, and ib otherwise. The length of e is denoted by the parameter l, and for any two journal entries e and e 0 we define e5e 0 , vp5vp 0. Generating journaled strings. Given a reference sequence r, a sequence s and n corresponding "-events sorted in ascending order, we can construct a journaled string in On time as follows. We create an original entry for each substring of r bounded by the end and begin coordinate of two adjacent "-events and cover each insertion by an insertion entry, while the inserted string is appended to the insertion buffer. Deletion events do not trigger the creation of a new entry but are covered by gaps between the physical end and begin position of two neighboring original entries, which can also be interleaved with insertion entries. Replacements are simply handled as an insertion followed by a deletion of the same size. Accessing journaled strings. To randomly access the journaled string at a position i, we first search the journal tree J for an entry vp; pp; l ;  with vp i5vp+l. The actual character can then be accessed at position pp+i  vp in the corresponding substring of this entry. Hence, the random access time is Olog jJj. Scanning the whole journaled string from left to right can be realized via an in-order traversal of the journal tree () in Ojj+jJj= Ojj time, i.e. a single sequential access requires amortized O1 time.
Traversing thousands of genomesIn the following section, we will give a formal description of the JST and describe the algorithm to traverse this data structure with any contextbased algorithm. Given a set of strings s 1 ;. .. ; s t and their sets of "-events D 1 ;. .. ; D t according to a common reference sequence r. To reduce the space required to store the "-events, we collapse all events shared by a set of strings into a single structure, called the branch-node. Formally, we say u=j; x; C; " is a branch-node of type " that occurs at branch-position j in the reference sequence r, with x being the corresponding string associated with the respective "-event and C f1;. .. ; tg being the set of the strings harboring this event. In the following, we will refer to C as the coverage. It holds that k 2 C , 9 i2N s k ; i; r; j; x; " 2 D k. W.l.o.g. we assume that none of the sequences has two different "-events at the same position j, and thus, the coverages of all branchnodes at the same branch-position j are disjoint. Let label(u), pos(u) and cov(u) be the values x, j and C, respectively, for any branch-node u. A JST T is a data structure consisting of an array of branch-nodes u 2 VT sorted in ascending order according to their branch-position pos(u), a pointer to the common reference sequence r and a set of journal strings 1 ;. .. ; t. The journaled strings are generated from the given set of all "-events, and the corresponding sequences in S as outlined in the Section 2.2. Basic traversal. For a sequential algorithm A with a context length w, the traversal over a JST T simply shifts a window over the reference sequence r. After every shift the current context is evaluated by an external algorithm A, which returns a shift length to move the window to the next required context. In addition, A can interact with the current state of the traversal, e.g. to request the positions of all strings that are valid for the current context. Whenever the window reaches into a branch-node u 2 VT, a new subtree, whose depth depends on the context length, is branched off. We iteratively traverse this subtree and use a stack S, which stores the current state of the traversal and A, for backtracking. In the following, we will describe how to generate all necessary subtree information on-thefly. First, we explain the branching strategy when the current window intersects with a branch-node and subsequently discuss step by step how to refine the subtree traversal, while maintaining the invariant that for each context explored by the traversal always a valid coverage is sustained. Branching. To proceed the traversal in the subtree starting at the branch-node u, it is obvious that the left and right sequence context flanking the respective "-event is needed to provide A with all necessary information. This can be achieved by transferring the current window to any journaled string harboring this event. A representative k can be simply selected from the coverage k 2 covu. To determine in Olog jJ k j time where the respective "-event occurs in k , we augment each journal entry e 2 J r  by the rank of the associated branch-node in a preprocessing step. Once the entry has been found, the begin and end position of the window in k can be computed from the respective begin position of the window within the reference and the branch-position pos(u). Moreover, the traversal over the current branch is stopped whenever the window exceeds the current "-event represented by u.depicts this pruning of the branches depending on the window length, which is 4 in the given example. Context-based subtree construction. So far we have only considered the simple case where the current branch is solely dependent on the branchnode it originates from. However, depending on the context length and the distribution of the branch-nodes, it might happen that multiple branch-nodes affect the current branch, resulting in an expanding subtree. For example, the branch-node O ininduces a split of the branch coming from N. We will refer to such branch-nodes inducing a split in the current branch as split-nodes to distinguish them from their original meaning. Accordingly, the node O 0 inrepresents the split-node induced by O. Let u be the branch-node of the current branch and v its successor. Then v induces a split in the branch coming from u if the following conditions are satisfied:(1) covu \ covv 6  1.The first and the second conditions ensure that there exists a subset of strings covering v that also covers u. Otherwise, the contexts for all strings covering u are either aware of the "-event represented by v or none of the strings harbor the respective "-event. The third condition checks that the current context is affected by the split-node. The current branch is split if all conditions are fulfilled, and hence, the coverage of the active branch is partitioned into the sets covu \ covv and covuncovv. Now the traversal is continued with the coverage set containing k, whereas the remaining set is stored on the stack S together with the current states of the traversal and A. Suppressing invalid sequences. In addition, we keep track of the coverages of all branch-nodes that currently fall into the window over the reference sequence, as well as the coverages of replacements and deletions that were encountered previously and still affect the current window. For example, the deletion represented by branch-node M inalso affects all windows starting at position 13 and 14 in r (denoted by the dashed lines below the tree). Whenever A requests for it, we on-demand compute the sequences the context is valid for using the auxiliary information. We also use this information to skip windows that have been examined already. In, for example, if the algorithm finished the branch at branch-node N and passes to the next branch-node O, it is clear that all windows beginning before the insertion in O have been searched already when processing N, as all sequences covering O also cover N. Hence, it is sufficient to move the context directly to the beginning of the insertion. Processing blocks. The traversal over the JST can be conducted blockwise. To do so, we partition the set of branch-nodes into blocks of size B4w, according to their positions within the reference sequence. Whenever we enter a new block, we load it into memory and discard it after processing all contained branch-nodes. In general, no more than two blocks are kept in memory at the same time. Dynamic updates. It is possible to add k sequences to the JST dynamically. To do so, the k sequences are represented as k single-sequence JSTs, i.e. each hosts one sequence only, referring to the common reference sequence. Then, the JSTs can be merged into the existing JST in Onklog k time, where n is the size of the largest branch-node array using a k+1-way merge step. During the merge, we either add the index of the currently processed sequence to the coverage set if the branch-node already exists or insert a new branch-node at the corresponding position. In a new traversal, the journaled strings for the recently added sequences are then constructed on-demand as described in the previous sections.
RESULTS
ImplementationWe implemented all data structures, programs and functions in SeqAn, the C++ software library for sequence analysis (D  oring et al., 2008). To memory efficiently represent the coverage information, each branch-node stores a packed bitvector. The binary search tree of the journaled string is realized as a sorted array, as the variants are incorporated in left-to-right scan manner. We used binary search to look up a given entry within the array. To make our JST data structure applicable to a wide range of algorithms, we implemented a templatized Finder object, which hides the traversal and the state management from the outer interfaces. The user can simply plug-in its own functor to this object and implement the functions getState() and setState() if necessary. As an example, we provide functors for the naive,, Shift-And and Shift-Or (Baeza) exact pattern search algorithms, as well as Myers' bitvector algorithm for approximate search (). To evaluate running times and memory consumptions, we implemented a benchmark application, which is available on request to the authors. Furthermore, we have implemented a tool to transform a vcf file into our own genome delta format called gdf. This format simply stores the variants in a compact form and the respective bit vectors for each variant ().
ExperimentsWe used data from the 1000 Genomes Project () to evaluate our traversal over the JST. We took the vcf file for chromosome 1 and transformed it into a gdf file for different sets of sequences. The gdf file storing 1092 genotypes without the reference sequence used only 446 MB instead of 87 GB needed for the vcf file. Note that the original size of chromosome 1 in fasta format is nearly 250 MB. In fact, we could compress the gdf file with gzip to 58 MB in only 14 s, suggesting that further studies of the compressibility of this format would yield good compression ratios.Although we made all analyses based on the gdf format, we could also process vcf files directly at the expense of longer I/O times. Reading the complete gdf file of chromosome 1 containing 2 993 910 variants for 1092 individuals took merely 4.2 s. For the runtime and memory evaluation, we generated different datasets from the vcf file representing the genotypes of 1, 32, 64, 128, 256, 512 and 1092 sequences and one set with 2184 sequences generated from both haplotypes of the 1092 sequences and additionally included the reference sequence itself. We performed the traversal on each set with the exact online-search algorithm Horspool and with Myers' bitvector algorithm for approximate pattern search. The experiments were conducted on a Debian GNU/Linux machine with 72 GB of RAM and a 2.67 GHz Intel(R) Xeon(R) CPU X5650 processor. The presented results for the JST are obtained with a block size of 100 000. Running time. The total running times are depicted in the columns under the respective heading infor Myers' algorithm and infor the Horspool algorithm. The total running time for the JST search includes loading the reference sequence and the gdf file as well as the generation of the journaled strings and the search itself. We compared the total running time with the sequential case, where we load at most 100 fasta sequences at a time into memory and then sequentially searched over the sequences. Except for the single reference search (the JST is empty) in row 1, the JST traversal is faster than the sequential processing for the same number of sequences for both algorithms. The factor column represents the speedup of the JST over the sequential search. The figures clearly reveal, that the more sequences are added the more the speedup grows, albeit there is a little decrease for 1093 sequences compared with 513 sequences. In addition, it can be seen that the running times for the Horspool algorithm are in general faster than for Myers' bitvector algorithm, while the speedup over the sequential case is smaller. Additionally, we measured the search time without any generation or loading times and compared again the running times of the JST traversal with the sequential search. All figures for the search time are presented in Tables 1 and 2 too. For two sequences, our approach is already faster than the sequential case. Moreover, the speedup for Myers' bitvector algorithm increases almost continuously up to a factor of 577 for 2185 sequences. Again, the running times for the Horspool algorithm are less than for Myers' bitvector algorithm, but the speedup is higher for the latter one.Note. Naive refers to the sequential processing of fasta sequences. aAt most 100 fasta sequences were loaded into memory at a time.Memory consumption. The last two columns of Tables 1 and 2 present the memory usage of both strategies. The measured memory consumptions are identical for both algorithms. Again we can see the same behavior as for the running times. In the sequential case, the memory consumption for searching solely the reference is slightly less than for the JST. However, with two sequences both methods use roughly the same amount of memory. For more sequences, the JST memory consumption increases only sublinear in the size of the contained sequences. The analysis of 2185 sequences requires 3.72 GB of RAM. Different block sizes. In addition to the block size of 100 k, we tested our approach with blocks of length 500 k and compared the performance with a version that loads all variants at once in memory. Clearly, the memory consumption increases with higher block sizes. One thousand ninety-three sequences require 4.73 GB of RAM with a block size of 500 k, and 17.06 GB if all variants are stored in memory. Thus, even for the setting with the largest memory consumptions, our approach stores 1093 sequences within 6% of the space the naive variant would require to store all sequences simultaneously. In addition, the measured running times for the 100 k blocks are slightly lower than using larger blocks. Different pattern sizes. The JST traversal strongly depends on the number of variants contained in the set because the more branch-points are available the more often the algorithm needs to split branches and update coverages. We simulated this behavior by increasing the size of the pattern and searching with each pattern the set of 1093 sequences. We measured only the search times because the generation times are not affected by the pattern size.depicts the behavior of the search time for different pattern sizes. The blue line represents the search with the Horspool algorithm. The search time increases slowly to 13.78 s for a pattern of size 256. The red line represents Myers' bitvector search. Here we can see a major increase when increasing the pattern size from 64 to 128. For patterns larger than the word size, which is 64 bits in our case, the algorithm has a more complex procedure, which results in longer running times. Yet, the search time of 55.21 s for a pattern of size 256 is still 55 times faster than searching the sequences sequentially.
DISCUSSION AND CONCLUSIONIn this article, we presented a data structure called the JST, to represent a set of sequences as a set of variants based to a common coordinate system given by a common reference sequence and a set of accompanied bitvectors. We used searchable referentially compressed strings, called journaled strings, to generate a succinct representation for any sequence from this set. Furthermore, we implemented a traversal over the JST, while searching regions shared by a subset of the sequences simultaneously. Moreover, we loaded parts of the journaled strings dynamically on-demand to decrease the memory consumptions tremendously, while the running time remained unchanged. During the traversal, we built only those parts of the JST that were necessary to evaluate the current context. These methods work dynamically for any window length and do not need any preprocessing phase. The results show that any algorithm that processes an input sequence with a given window length can greatly benefit from our approach. We tested our approach on different-sized sets of chromosome 1 sequences generated from the vcf file of the 1000 Genomes Project. All our experiments showed a better performance and memory consumptions compared with the sequential processing of the same number of sequences in fasta format. The only case our approach was slower and used slightly more memory was when we analyzed the reference sequence only. For two sequences we already measured a gain over the sequential case. We analyzed the search and the total times for an exact pattern search with the Horspool algorithm and an approximate pattern search with Myers' bitvector algorithm. Comparing the total times for different number of genomes revealed a growing speedup factor opposed to the sequential running time, except when performing the search on 1093 sequences. Here the speedup factor dropped a little bit compared with its previous trend. The same drop cannot be seen when comparing the respective search times for both algorithms, and hence, it must be a result of longer generation times for the journaled strings. This seems to be plausible, as when increasing the number of the sequences the number of variants contained in the set also increased. The figures in the second column ofshow the number of all variants contained in this set. For 1093 sequences, there were almost 1 million more variants contained in the set than for 513 sequences. This fact is supported by adding the running times for 2185 sequences to the comparison. We used both haplotypes of the 1092 sequences contained in the vcf file to generate the 2184 sequences plus the reference sequence. Hence, the number variants remains the same, while the number of sequences is again doubled. Here the speedup factor starts to grow again, with almost the same factor as it did before. We observed that loading variations block-wise with a block size of 100 k not only lowers the expected memory consumption but also shows slightly better running time results. This behavior can be explained by considering the binary lookup necessary to find the journal entry representing a branch-node. If the set to be searched is smaller, then the lookup will be faster. Additionally, generating journaled strings for larger block sizes results in higher memory consumptions, and hence, caching effects can slow down the overall generation time. We showed that our method scales in time as well as memory usage well with the number of sequences and the number of variants contained in the set. We gained speedups for 2184JST-Myers JST-Horspool. JST search time depending on the pattern size over 1093 genotypes of chromosome 1 sequences up to a factor of $577 for the search time and $115 for the total running time compared with the sequential case, while we used only 3.72 GB of RAM. Motivated by the low memory consumptions, we used an Apple MacBook Pro with 8 GB main memory to search the set of 1093 sequences with Myers' bitvector algorithm and a pattern of size 64. This took only 78.51 (9.4) s in total (search only) while using $2.2 GB of RAM. Currently, we are extending the traversal to support multi-core parallelism. We will implement and test two different coreparallel approaches: parallelizing the traversal over the branchnodes and splitting the search space over the reference into multiple chunks. In the first version, we implement a singleproducer-multiple-consumer strategy, where one producer thread iterates over the branch-nodes and adds the states necessary to conduct a valid traversal over the branches to a threadsafe queue. A team of consumer threads can then dequeue the states independently from the queue and traverse the preceding reference segment starting from the predecessor node to the current branch-node and the branch itself. In the second strategy, we divide the reference sequence into multiple chunks and let a team of threads process untouched chunks concurrently. To do so, we need a preprocessing step over the set of branch-nodes, which resolves possible conflicts between the coverage sets of two neighboring chunks. Imagine a deletion at the end of a chunk that also affects the first positions of the adjacent chunk right of it. If two threads process these two chunks in parallel, then the thread working on the affected chunk might report wrong results because its active coverage set does not reflect the deletion beginning in the previous chunk. Furthermore, we will modify the journaled strings to represent single-nucleotide polymorphisms more efficiently, as they account for the largest number of variants available in public databases. This will further lower the memory consumption. Given the promising results of our approach, we will extend the set of functors to allow more complex algorithms, e.g. filter and verification algorithms, and integrate them into existing tools such as read mappers and variant caller to make them applicable to large collections of sequences. Moreover, our approach would allow to immediately incorporate new reference sequences into the existing set or to assemble domain-specific reference sets dynamically from an external pool, opening the door to tailored medical applications.
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
R.Rahn et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Journaled string tree at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
