Motivation: String and de Bruijn graphs are two graph models used by most genome assemblers. At present, none of the existing assemblers clearly outperforms the others across all datasets. We found that although a string graph can make use of entire reads for resolving repeats, de Bruijn graphs can naturally assemble through regions that are error-prone due to sequencing bias. Results: We developed a novel assembler called StriDe that has advantages of both string and de Bruijn graphs. First, the reads are decomposed adaptively only in error-prone regions. Second, each paired-end read is extended into a long read directly using an FM-index. The decomposed and extended reads are used to build an assembly graph. In addition, several essential components of an assembler were designed or improved. The resulting assembler was fully parallelized, tested and compared with state-of-the-art assemblers using benchmark datasets. The results indicate that contiguity of StriDe is comparable with top assemblers on both short-read and long-read datasets, and the assembly accuracy is high in comparison with the others. Availability and implementation: https://github.com/ythuang0522/StriDe
IntroductionAlthough next-and third-generation sequencing technologies have been widely used to sequence and assemble genomes of many species in the biosphere (), many assembled genomes are still fragmented due to complex repetitive structure (). A fragmented assembled genome often introduces extra complexity into downstream processing, e.g. estimation of gene family size and comparative analysis. Recently, several evaluation projects (e.g. GAGE, GAGE-b and Assemblathon 1/2) have been conducted to assess the accuracy, contiguity and speed of state-of-the-art assemblers (). None of the existing assemblers clearly outperforms all the others across all benchmarks. The overlap-layout-consensus (OLC) and de Bruijn graphs are two models used by most assemblers. These two models represent the overlapping relation between reads in different ways. The OLCbased assemblers, including MIRA, Newbler and Celera assemblers, first identify all pairs of overlapping reads and construct a graph with vertices representing reads and with edges denoting two overlapping reads (). Next, the genome sequence is assembled by figuring out a feasible layout of reads from the graph. The OLC-based methods make good use of the entire read length for resolving repeats and chimeras; this approach is beneficial for sequencing platforms generating long reads (e.g. Sanger sequencing, Roche 454 and Pacific Biosciences). These assemblers, however, are computationally inefficient at assembling a massive amount of short reads because of the time-consuming overlap computation. Nowadays, de Bruijn graph assemblers, including Velvet, SOAPdenovo, ABySS and ALLPATHS, are the preferred choice for most sequencing projects (). These assemblers break each read into fixed-size k-mers, which do not require the overlap computation, and a graph is directly constructed where each vertex is a k-mer and each edge indicates two adjacent k-mers overlapping by k  1 letters. The construction of a de Bruijn graph is much more efficient. Nonetheless, the graph structure is more complex owing to repeats larger than k-mer. Recently, a paired de Bruijn graph assembler (SPAdes) overcame this limitation by building a graph by means of paired k-mers from paired-end reads (). Aside from these two graph models, there is a variant (called string graph) that is similar to the OLC graph without transitive edges (). The construction of a string graph from reads can be computed in linear time using an FM-index (). The first such assembler, called the String Graph Assembler (SGA), is capable of assembling mammalian-size genomes, but its contiguity is not better than that of de Bruijn graph assemblers according to several benchmark tests. The string graph shares many properties with the OLC and de Bruijn graphs, but their equivalence in terms of real sequencing data remains a subject of debate (). We found that the major difference lies in the ability to assemble through regions that are error-prone due to sequencing bias (e.g. high-GC regions; see Supplementary;). This article presents a novel assembler called StriDe, which adaptively decomposes reads within error-prone regions and extends paired-end reads into long reads using an FM-index. In addition, an improved error correction algorithm, overlap computation, specialized layout algorithms and full parallelization were implemented to make the assembler more practical.
MethodWe would like to emphasize two major features of this assembler before presenting the details (see). First, the original reads are adaptively decomposed into overlapping subreads within errorprone regions, in which the correct subreads (collected from different reads) can still be assembled (i.e. just as in a de Bruijn graph). Second, the paired-end reads are extended into long reads using an FM-index, which can resolve repeats longer than read length. In summary, the input reads are converted into short (overlapping) subreads, original reads, or extended long reads (). Therefore, a string graph that is constructed from these variable-length reads implicitly integrates de Bruijn and string graphs for assembly through error-prone and repetitive regions. Efficient construction of this assembly graph requires an FM-index built from variable-length reads; this problem was recently solved by Li's ropebwt2 algorithm (). The StriDe assembler uses Li's ropebwt2 for FM-index construction (see Supplementary Methods, Section 1.1). Below, we present the main ideas behind the major components of this assembler (see Supplementary). The other components and details can be found in Supplementary Methods.
Correction of errors by frequency turbulenceConventional methods for identification of errors usually select a kmer frequency cutoff depending on the underlying k-mer frequency spectrum, which is largely affected by repeats and the sequencing bias (see Supplementary). We found that the frequency differences between two adjacent k-mers are much smaller and are stable regardless of repetitive and low-coverage regions (e.g. for >98% of the regions, the frequency difference is less than 10). On the other hand, the large frequency differences are mainly due to sequencing errors (see(a)). Suppose an error occurs at the i  kth position. The frequency difference between the ith and i  1th k-mer drops significantly because the rightmost base of the i  1th k-mer represents the error base. In addition, the frequency difference between the i  k-and i  k  1th k-mer increases significantly because the leftmost base of the i  k  1th k-mer just left the error base. As a consequence, the error base is identified if any two adjacent k-mer frequencies differ by more than t (default: 10), which aims to match the expected error rate of Illumina platforms (see Supplementary Method, Section 1.2). After identifying the exact position of the error, we first try to replace the error with alternative alleles A, T, C, G and see whether the frequency turbulence is eliminated. On the other hand, indel errors and clustered errors cannot be corrected this way. In this case, an overlap correction algorithm is performed via alignment of overlapping reads using a conventional seed-and-extend approach (). The seeds are selected from regions flanking the errors,Note that the decomposed subreads still overlap with each other, and the correct subreads (collected from different reads) can still be assembledThe k-mer seeds are selected from the regions flanking the low-frequency region and are used for identifying potentially overlapping reads and banded dynamic programming is used to compute the exact overlap alignment (see Supplementary Method, Section 1.2). Note that in high-GC regions, the high density of sequencing errors still cannot be corrected by either method. The reads within these regions will be decomposed into subreads.
Extension of Paired-end reads by FM-index walkThe paired-end reads are extended inward into long reads by searching for feasible overlapping sequences between two ends. We consider the FM-index (constructed from all reads) as multiple (implicit) de Bruijn graphs of various k-mers. Given a paired-end read, the algorithm (called the FM-index walk) is aimed at finding feasible {A, T, C, G}-extensions from the first end to the other end by updating the suffix array (SA) intervals (). The major advantage of this approach is that each one-base extension becomes a simple update of an existing SA interval, which can be completed in O(1) time. The details of this algorithm are described below. The entire search space from first end (source) to second end (destination) is maintained by a search tree, with each tree node storing two SA intervals (for forward/reverse strands) of any feasible extension. Initially (see), the forward/reverse SA intervals of the source k-mer (e.g. ATC) are computed using the backwardsearch algorithm (). Subsequently, we recursively extend the implicit sequences for all possible {A,T,C,G}extensions by updating the SA intervals of leaves using the backward-search algorithm (see Supplementary Method, Section 1.3), until the arrival at the destination k-mer (e.g. AAC). Note that the destination k-mer is also a suffix of any feasibly extended sequence (e.g. GCAAC). This notion implies that the SA interval of any feasibly extended sequence is included within that of the destination k-mer (e.g. 772; 796 682; 886). Because the SA interval of destination k-mer can be computed in advance, the arrival at the destination for each newly extended sequence can be checked within O(1) time. The search process aborts if the search depth exceeds the maximum insert size, or the number of extensions exceeds the maximum leaf number (default: 32). Note that each update of the SA interval increases the implicit sequence as well as the implicit overlap between two reads. The implicit sequence and overlap will eventually exceed the maximum read length of the input reads, thus yielding no feasible extensions. Therefore, whenever none of the leaf nodes can be extended, we have to double-check whether the implicit sequence and overlap are too big. This task can be done by refining the SA interval that exactly corresponds to the k-mer suffix extracted from each leaf sequence. If any feasible SA interval is found after the refinement, we continue the extension using the new SA intervals. Otherwise, the entire search process is aborted because no feasible extensions can be found even though we shrunk the implicit sequence/overlap. The refinement of SA intervals when the implicit sequence/overlap exceeds read length takes extra O(k) time, whereas the remaining extensions take O(1) time. Because the read length is generally much greater than the k-mer size (e.g. 250-bp/300-bp reads are common in Illumina systems), the O(k) refinement cost can be amortized into the majority of O(1) extensions in the entire searching process. Therefore, the overall amortized cost of this algorithm is O(IL), where I is the search depth (corresponding to insert size) and L is the maximum number of leaves allowed. MaSurCa and ABySS implemented similar de Bruijn walks using hashtable and bloom-filter (Supplementary;). The implicit overlap of de Bruijn walks is fixed to the k-mer size. On the other hand, the implicit overlap of FM-index walks is dynamic and can be larger than k, which is able to walk through repeats larger than k.
Adaptive read decomposition in Error-prone regionsThe paired-end reads that failed to be extended into long reads are often prone to errors due to the sequencing bias (e.g. high-GC regions), which is common on the Illumina platforms. We decompose these reads into smaller overlapping subreads at each potential error base. Therefore, the corrected subreads (collected from different reads) can still be assembled at the final graph layout stage (and Supplementary). The details are described below. The decomposition algorithm identifies the breakpoints of subreads by checking all pairs of adjacent k-mers of a read (e.g. k  9 in). For each pair of adjacent k-mers, a breakpoint is identified if any of them contain alternative overlaps with other k-mers. Consider the example shown in. The only correct k-mer in R3 is also present in R2 and thus has two possible overlapping paths to the left (and to the right). Therefore, this k-mer subread is decomposed from R3 in order to ensure flexibility at the final graph layout stages, where erroneous subreads (in black boxes) are usually dead ends and can be easily detected/removed. The decomposed subreads must retain the overlap (k  1) bp with adjacent subreads in the original read because the correct layout of subreads is still uncertain at this stage. This algorithm may falsely decompose reads within different repeat copies, because such ambiguous k-mer overlap paths are encountered often due to independent mutations in each repeat copy. Therefore, we set an additional requirement that the k-mer frequencies for any breakpoint must be lower than a threshold ( 3 by default) because these error-prone regions are mainly due to the sequencing bias, where the sequencing coverage is relatively lower.
String and de Bruijn graphsThe worst result of the algorithm is decomposition of each read into (R L  k  1) k-mers, where the R L is read length; this situation is equivalent to a de Bruijn graph. In reality, only the reads within error-prone regions tend to be decomposed into short subreads, whereas the majority of reads still retain the contiguous information of entire sequences.
Overlap computation with SA-interval pruningThe string graph is composed of vertices and edges, where each vertex stands for a (decomposed or extended) read and each edge represents an overlap between two reads. The overlap computation is the most time-consuming step during graph generation. The exact overlap with respect to any read can be computed in linear time using an FM-index (). Nonetheless, to assemble a genome in error-prone regions in our algorithm, the error-prone reads are decomposed into shorter subreads with a k  1-mer overlap. The minimum overlap length has to be reduced to k  1 in order to maintain the connectivity among the subreads. This small-overlap requirement leads to a huge amount of edges in the graph owing to repeats ! k  1-mer; this situation greatly affects the disk/memory usage and reduces the efficiency. We introduced a pruning procedure into the overlap algorithm to reduce the number of false edges due to decomposed subreads. We found that if a long-extended read (e.g. 200 bp) possesses both a large and small overlap with other reads (e.g. overlaps of 160 and 30 bp), the small overlap can be usually discarded. These small-overlap edges are often transitive (i.e. replaceable by other larger-overlap edges) or form small repeats, which are not informative at the final graph layout stage. Therefore, if the length difference between the largest overlap and any smaller overlap is greater than a threshold L gap (default: half of read length), the smaller overlap is discarded (). In addition, because the sequencing coverage is limited, the influence of small repeats can be controlled by retaining the largest L max overlaps only, where L max equals sequencing coverage. This pruning procedure can effectively skip many repeat edges, while retaining the edges between decomposed subreads. In the implementation, multiple string graphs are concurrently constructed using the overlap-computation algorithm. The race conditions are resolved and described in Supplementary Method (Section 1.5).
Graph layout algorithmsThe layout algorithms are designed to identify unique paths of vertices in the graph for maximization of the assembly contiguity and accuracy. The major challenge at this stage is distinguishing true overlapping edges from chimeric/random edges for vertices with two or more ambiguous edges. Three features were selected from the OLC/string graphs for edge classification: overlap lengths, overlap ratio (overlap length normalized to read length) and overlap ratio differences on the same edge (Supplementary). Each feature requires determination of a reasonable cutoff (e.g. removal of edges with overlap length less than 80 bp). Because the sequencing quality varies a lot across different datasets, these cutoffs have to be adaptively determined. In the text below, we present the major novelties of our layout algorithms, i.e. the simple-path statistic in conjunction with the three features. Other details (e.g. the conventional bubble/ tip removal) are described in Supplementary Methods (Section 1.6).
Construction of the Simple-path statisticIn most OLC/string graph assemblers, vertices along the same simple paths are contracted to reduce the graph size; this approach throws away valuable information about these features, especially within the initial simple paths. In fact, the assembled sequences on the initial simple paths are usually correct (due to a lack of repeats/chimeras/errors). Therefore, the statistics on these features that are collected from initial simple paths form an empirical distribution for subsequent determination of a cutoff (Supplementary). For instance, if 95% of overlap lengths on the initial simple paths are greater than 80 bp, we can estimate that the removal of edges with an overlap less than 80 bp may yield a 5% error rate. Although any cutoff still faces a tradeoff, we can at least make decisions with statistical confidence using the simple-path statistic. The current implementation is designed to maintain (at least) 95% confidence for each cutoff.
Removal of apparent chimeric verticesThe graph structure surrounding the majority of chimeric vertices is usually complicated owing to small repeats within a chimera; these repeats cannot be easily removed by the conventional tip/bubble removal algorithms (Supplementary). Nevertheless, we noticed three features of chimeras in the graph. First, chimeric vertices have relatively shorter overlap length connecting to their neighbors because the chimeric read is composed of two distant DNA fragments, and the overlap cannot be greater than that of nonchimeric reads. Second, after tip/bubble removal and graph contraction, most vertices on simple paths are merged into larger vertices (i.e. longer sequences). On the other hand, due to the complex graph structure surrounding the chimeric vertices, they usually do not merge with others and remain as small vertices. Third, the k-mer frequency at the chimeric vertices is also relatively lower due to infeasible k-mers across the chimeric junction. Therefore, in conjunction with the simple-path statistic, the small (default: read length) and lowfrequency vertices (default: 3) with short overlap length (default: >95% confidence) to their neighbors are removed ()., only the top five SA indices (set by L max ) are retained, which are from the top two SA intervals (and). That is, only the overlap to reads D, E, F, G and H are retainedThe tips/bubble removal algorithms can then be re-applied to further simplify the graph (Supplementary).
Removal of edges with low overlap ratiosBecause the input reads were decomposed or extended, the overlap length alone is insufficient for distinguishing true overlapping edges. Instead of removing the entire vertex, we gradually remove lessconfident edges using the simple-path statistic of overlap ratios. For the example shown in (), overlap ratios of more than 95% of simple-path edges are greater than 0.8 in the dataset of A:hydrophila. Consequently, by requiring the overlap ratio greater than 0.8, we have 95% confidence that the removal of these unreliable edges is safe. After this removal operation, the complexity of the graph structure around the chimeric vertices can be further reduced and may turn into simple tips or bubbles. The algorithms of tip/bubble removal can be applied to simplify the graph.
Removal of edges with large overlap differencesWe found that the overlap ratio can still be biased to the size of a vertex because two vertex sizes flanking each edge may differ substantially (e.g. a decomposed subread and an extended long read). In other words, the overlap ratios that were computed using either vertex may be quite different although both of them are on the same edge. Again, during the analysis of the initial simple-path edges, we found that the two overlap ratios on the same edge are quite small, regardless of the size of the vertex. Therefore, a third feature, called overlap-ratio difference, is used to distinguish true overlapping edges (). For instance, the overlap differences in more than 95% of simple-path edges are less than 0.2. Similarly, we can remove more unreliable edges and break down the complex graph structure into tips and bubbles. Finally, the tip/bubble removal algorithms are invoked again to further simplify the graph.
ResultsThe new assembler (StriDe) was tested using GAGE-B benchmark datasets. GAGE-B provides 12 datasets of genome sequencing of different bacteria using Illumina HiSeq and MiSeq platforms. StriDe was compared with seven other wellknown assemblers: ABySS (v1.9.0), CABOG (6.0), MaSurCa (v3.1.3), SOAPdenovo (v2.04), SGA (v0.10.13), SPAdes (v3.5.0) and Velvet (v1.2.08). The QUality ASessment Tool (QUAST) was used to compute and compare various assembly metrics (e.g. N50 and misassembly;). The parameters k (k-mer size) and T (min. k-mer frequency) used by StriDe are fixed to 31 and 3 across all GAGE-b experiments, respectively.
Percentages of extended and decomposed readsThe two major features of the StriDe assembler are the decomposition and extension of paired-end reads prior to assembly.shows a comparison of the percentages of extended, decomposed, or unchanged reads in the 12 datasets. The median ratios of extended, decomposed and unchanged reads are 52%, 13% and 25%, respectively. An individual ratio varies a lot depending on the sequencing quality of different datasets. The extended ratio can be more than 70% for high-quality sequencing (e.g. A:hydrophila HiSeq). The majority of reads are extended to the length of the expected insert size (i.e. 200600 bp), and StriDe can take advantage of long reads, just as OLC/string graph assemblers can. On the other hand, the decomposed ratio can be as high as 90% for low-quality sequencing (e.g. R:sphaeroides MiSeq). This observation implies that most reads are decomposed into short subreads, and StriDe will act like de Bruijn graph assemblers. In general, the MiSeq datasets are of lower quality and are frequently decomposed in comparison with HiSeq datasets. Note that even in a single dataset, the sequencing quality still varies substantially across the entire genome because of the sequencing bias. The adaptive decomposition or extension of reads by StriDe is robust in the face of such quality variance within or between datasets.
Assembly results of Short-read datasetsStriDe was compared with the seven assemblers using eight shortread datasets in GAGE-b.lists the N50 values of eight short-read datasets (% 100 bp) assembled by all the assemblers. The results indicate that the StriDe assembler outperforms most assemblers in terms of contiguity. In general, MaSurCa, SPAdes and StriDe usually output the largest assembly across all datasets. The number of misassemblies, indel rates and other accuracy metrics arethe 12 datasets. The percentages of decomposed reads can be as high as 90% and as low as 10% owing to various sequencing quality listed inand Supplementary Tables S4S15. Note that only a subset of species is available with reference genomes. The results indicated that most assemblers (including StriDe) control misassembly (misassembled contigs) quite well, except for CABOG, MaSurCa and SOAPdenovo, which are slightly worse than the others. In terms of smaller assembly errors (e.g. mismatches/indels), the accuracy of most assemblers is high in general (Supplementary Tables S4S15). Although ABySS, CABOG, MaSurCa and SOAPdenovo are slightly worse on a few datasets (e.g. Vibrio cholerae HiSeq), the accuracy does not differ much.
Assembly results of long-read datasetsThe GAGE-B also provides four datasets of long reads (% 250 bp) from the Illumina MiSeq platform. We compared StriDe with the other assemblers on these datasets.This result is mainly due to lower sequencing quality of long reads on the MiSeq platform, where a greater number of error-prone reads is generated. Consequently, the read decomposition of StriDe greatly facilitates the assembly of error-prone reads.
Computation resourceAll the experiments were conducted on a Dell R816 server with 48 cores and 256 GB of RAM. The running time (including FM-index construction, error correction and overlap computation) was approximately 2040 min for completion of the assembly of each GAGE-B dataset. The memory consumption ranged from 1 to 2 GB across 12 datasets, due to compression of the FM-index and assembly graph (see Supplementary Methods, Section 1.1). The extra disk usage is much lower than that of input reads. The constructed FM-indices range from 27 to 237 MB, and graph sizes from 6 to 40 MB.
ConclusionThis article presents a novel assembler (StriDe) with advantages from string and de Bruijn graphs. Many essential components of an assembler were developed or improved. An initial test over various Illumina short-/long-read datasets showed that StriDe can assemble through error-prone and repetitive regions using decomposed and extended reads, respectively. The entire implementation is largely inherited from two open-source projects: Li's ropebwt2 and Simpson's SGA. The proposed assembler is still lacking a scaffolding module although third-party scaffolding programs can be incorporated.. The number of misassemblies by each assembler on short-read (HiSeq) or long-read (MiSeq) datasets
at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Y.-T.Huang and C.-F.Liao at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
