Motivation: RNAs play fundamental roles in cellular processes. The function of an RNA is highly dependent on its 3D conformation, which is referred to as the RNA tertiary structure. Because the prediction or experimental determination of these structures is difficult, so many works focus on the problems associated with the RNA secondary structure. Here, we consider the RNA inverse folding problem, in which an RNA secondary structure is given as a target structure and the goal is to design an RNA sequence that folds into the target structure. In this article, we introduce a new evolutionary algorithm for the RNA inverse folding problem. Our algorithm, entitled Evolutionary RNA Design, generates a sequence whose minimum free energy structure is the same as the target structure. Results: We compare our algorithm with INFO-RNA, MODENA, RNAiFold and NUPACK approaches for some biological test sets. The results presented in this article indicate that for longer structures, our algorithm performs better than the other mentioned algorithms in terms of the energy range, accuracy, speedup and nucleotide distribution. Particularly, the generated RNA sequences in our method are much more reliable and similar to the natural RNA sequences. Availability and implementation: The web server and source code are available at
INTRODUCTIONRNAs perform a wide range of functions in biological systems. The functional form of RNA frequently requires a specific tertiary structure. The scaffold for this structure is provided by secondary structural elements that are hydrogen bonds within the molecule. Therefore, the study and the analysis of RNA secondary structures are crucial to understanding their functional roles (). In this sense, it is of great interest to propose computational techniques for predicting the RNA secondary structure. Most of the existing computational approaches are based on thermodynamic models that predict the RNA secondary structure with the minimum free energy value (). Several other approaches are introduced based on maximizing the ensemble probability of the predicted RNA secondary structure (). An important problem in the RNA research area is the RNA inverse folding problem, in which the secondary structure of an RNA is given and the goal is to find a proper sequence that folds into the given structure. The RNA inverse folding problem can be used to design non-coding RNAs, which are involved in gene regulation, chromosome replication and RNA modification (). The designed sequences are also applicable to construct ribozymes and riboswitches, which may be used as drugs and therapeutic agents in research (), or for building self-assembling structures from small RNA molecules in nanobiotechnology (). In the RNA inverse folding problem, there are exponential number of sequences to be considered as candidates for the solution (). It is also suggested that the RNA inverse folding problem may be NP-Hard, i.e. finding an exact global solution would require exponential time (). Therefore, the heuristic search methods are widely used to address this problem (). RNAinverse, available as a part of the Vienna RNA package, is an original approach to solve this problem (). This algorithm uses a distance score to measure the distance between the structure of the designed sequence and the target structure. The goal of this algorithm is to minimize the distance score, as well as to maximize the probability of folding the designed sequence into the target structure. When the distance score is 0, the algorithm ends and the generated sequence is returned. The second algorithm, entitled RNA Secondary Structure Designer (RNA-SSD), tries to minimize the structural distance via recursive stochastic local search ().proposed another algorithm based on dynamic programming and local search, called INFORNA. This algorithm consists of two steps. In the first step, it generates an initial sequence using dynamic programming. In the second step, it uses a stochastic local search method to improve the quality of the initial sequence. Genetic algorithm is also used to solve the RNA inverse folding problem, both for RNA secondary structures () and pseudoknotted structures (introduced a new method *To whom correspondence should be addressed. based on a genetic algorithm entitled Frnakenstein, which is implemented in Python. This method allows multiple structures to be specified as target and has a variety of schemes for choosing mutation and recombination operations, or defining fitness and objective functions. The newest version of this method allows pseudoknotted structures to be specified as target or sequence motifs as input, contains parallelization and includes improved searching heuristics as well as multiple folding paradigms.used a dynamic programming approach (NUPACK) for designing the RNA sequence that is intended to adopt a target secondary structure at equilibrium. In this method, the sequence design problem is considered as an optimization problem with the goal of reducing the ensemble defect. The ensemble defect (for a sequence and a target secondary structure) is the average number of incorrectly paired nucleotides at equilibrium evaluated over the ensemble of secondary structures. Recently, a constraint programming) approach, entitled RNAiFold, was presented to solve the RNA inverse folding problem. This approach allows a wide range of design constraints to be specified (). It also introduces a large neighborhood search approach that allows larger instances at the cost of losing completeness, while retaining the advantages of meeting design constraints (motif, GC-content, etc.). It should be mentioned that the existing methods use a folding algorithm for evaluating and improving the accuracy and the quality of the generated sequences. It is well-known that the fold method of the Vienna RNA package requires On 3  operations; thus, using this algorithm over the whole sequence increases the overall running time. To resolve this problem, some structural decomposition schemes have been used in the previous studies to reduce the impact of the fold method. In this article, a different decomposition scheme is also used to produce the smaller sub-structures, and a new method based on evolutionary algorithms is presented to recursively solve and combine the obtained sub-structures. Our evolutionary algorithm designs an RNA sequence that folds into a given target structure. Any RNA secondary structure contains different structural components, each having a different length. Therefore, we first reconstruct RNA sub-sequences (pools) corresponding to different components with different lengths. Using the pools, we reconstruct an initial RNA sequence that is compatible (in which the base pairs are canonical) with the given target structure. Then we use an evolutionary algorithm to improve the quality of the sub-sequences corresponding to the components. The major contributions of our algorithm are using the natural RNA sequences, a different method for evaluating the sequences in each population and a different hierarchical decomposition of the target structure into smaller sub-structures. The rest of this article is organized as follows. In Section 2, the details of our approach are presented. Section 3 represents the results of our approach and the others, as well as the comparisons. Finally, the conclusion is presented in Section 4.
APPROACHIn this section, we introduce our evolutionary algorithm for designing an RNA sequence that folds into a given target structure. Any RNA secondary structure can be uniquely decomposed into its structural components (stems, hairpin loops, internal loops, bulge loops and multi-loops), each having a different length (this decomposition is referred to as component decomposition). Thus, we first construct the pools of RNA sub-sequences corresponding to different components with different lengths. Using these pools, we then construct an initial RNA sequence that is compatible with the given target structure. After that, the target structure is decomposed into smaller sub-structures (this decomposition is referred to as hierarchical decomposition). This decomposition is performed recursively, in positions where the multiloops occur. Then, for each sub-sequence corresponding to the sub-structure in the hierarchical decomposition, an evolutionary algorithm is used to improve the quality of that sub-sequence. Finally, the improved sub-sequences are combined level by level to yield the result (line 6 of Algorithm 2). The aforementioned steps are summarized in the following algorithms, where T, Is and P represent the target structure, RNA sequences and the population, respectively. The details of these algorithms are presented in the following subsections.Algorithm 3: Evolution (T, I) 1i best I; 2i T I foldI; 3i if (T 6  T I ) 4i P Generate-Population (T, T I , I, count); 5i do 6i f I 1 , I 2 , I 3 g three best solutions from P with respect to free energy; 7i f I 1 , I 2 , I 3 g three best solutions among fbest, I 1 , I 2 , I 3 g, increasingly ordered with respect to the Hamming distance; 8i best I 1 ; 9i P Generate-Population (T, T I1 , I 1 , count=3); 10i P P[ Generate-Population (T, T I2 , I 2 , count=3); 11i P P[ Generate-Population (T, T I3 , I 3 , count=3); 12i while (stopping condition is not satisfied); 13i end if. 14i return (best);Algorithm 4: Generate-Population (T, T I , I, count)
Pool reconstructionTo design the RNA sequences that are similar to the natural ones, we use the existing databases of RNA sequences [namely, The RNA secondary STRucture and statistical ANalysis Database (STRAND) (http://www.rnasoft.ca/strand/)] to construct the pools of natural RNA sub-sequences. To do this, for each sequence in the database, the fold method of the Vienna RNA package is executed to obtain its secondary structure. Then, using the component decomposition, this structure is decomposed into its structural components and the sub-sequences of the same type and length are gathered into the same pool. The distributions of the number of sub-sequences for different structural components with respect to their lengths are shown in, where for longer components, the corresponding pool may contain no sub-sequence. To increase the number of sub-sequences corresponding to the longer components, we artificially generate sub-sequences that fold into a desired structural component. To do this, we first analyze the natural RNA sequences to obtain the distribution of each nucleotide in different components as presented in. Then the artificial sequences are generated with respect to their types and lengths, as well as the natural distribution of nucleotides. For any longer stem, the sub-sequences of shorter stems are combined to produce a sub-sequence that is folding to that stem. For each longer loop component, an evolutionary algorithm is used to generate the corresponding sub-sequence. All generated sub-sequences are verified by using the fold method. For each type and length of the structural component, 300 subsequences are generated and stored in the corresponding pool for future use.
Construct the initial sequenceTo be consistent with the other parts of our algorithm, especially when we improve the quality of the sub-sequences corresponding to the components, we assign a compatible RNA sequence to the given target structure (line 1 of Algorithm 1). To do this, the target structure is decomposed into its structural components and based on the type and length of each component, a subsequence is randomly picked from the corresponding pool. These sub-sequences are then assembled to produce a compatible sequence for the target structure. It should be noted that this initial sequence is not guaranteed to fold into the target structure and therefore it should be considered for further improvements.
Hierarchical structure decompositionBecause the fold method requires On 3  operations, improving the whole initial sequence will increase the overall running time of any heuristic algorithm. On the other hand, decomposing the target structure into its structural components produces many small components and increases the number of iterations, and consequently increases the running time. To speed up the RNA design problem, we use the hierarchical decomposition scheme to decompose the target structure into its sub-structures (line 3 of Algorithm 2). This decomposition is done in positions where the multi-loops occur. Let the given structure consist of k multiloops M 1 , M 2 ,. .. , M k. For each p (1 p k), let M p contain q closing base pairs, sayWe define an order over the closing bases as follows:The minimum closing base pair in each multi-loop is called tag base pair, and the stem containing a tag base pair is called tag stem. Now, the minimum base pair (in tag stem with respect to the previously defined order) is marked as a breaking base pair, where the hierarchical decomposition is performed. The tag base pairs and the breaking base pairs are shown in. If several breaking base pairs are available, then the one whose resulting sub-structures have almost equal lengths is chosen. The process of decomposing the given structure is performed recursively to yield the hierarchy over the sub-structures (lines 45 of Algorithm 2). The decomposition is continued until a rooted binary tree of k leaves (i.e. 2k  1 nodes) is obtained. Here, the root node corresponds to the targetstructure, the leaves correspond to the sub-structures of at most one multi-loop and the intermediate nodes correspond to the sub-structures of more than one multi-loop. To preserve the affinity of the sub-structures at breaking position and to reduce the size of the sub-structures in the hierarchy, the substructure starting from any breaking base pair is replaced with a small structure of the form '((((.. .))))' with the fixed sequence 'GGGCAAAGCCC'. This extra sequence is eliminated after generating sub-sequences corresponding to the sub-structures (line 6 of Algorithm 2). The initial compatible sequence is also decomposed exactly at the same positions with respect to the corresponding sub-structure. Our hierarchical decomposition is different from the one proposed in RNA-SSD. While the result of our decomposition is a set of sub-structures, each containing at most one multi-loop, the RNA-SSD decomposition yields a set of sub-structures having lengths between 30 and 70 nt. The sub-structures and corresponding subsequences are given as input to our evolutionary algorithm for future improvements.
Evolutionary algorithmAfter constructing the pools of sub-sequences as well as the initial sequence, we use an evolutionary algorithm for each sub-sequence corresponding to the node in the hierarchical decomposition tree to improve its quality (Algorithm 3). The first step in our evolutionary algorithm is the construction of the initial population (Algorithm 4). To do this, we use the fold method over the initial sequence to determine its minimum free energy secondary(e)). Among these components, 15 components are selected randomly. For each selected component, its corresponding sub-sequence in the initial sequence is replaced with another subsequence from the appropriate pool, regarding its type and length (lines 56 of Algorithm 4). Then the newly obtained sequence is evaluated by using the energy_of_structure method (available as a part of the Vienna RNA package) to determine its thermodynamic free energy over the target structure (line 7 of Algorithm 4). Therefore, starting from the initial sequence, 15 sequences are generated and evaluated (count  15 in Algorithm 3). These new sequences are considered as the initial population (line 4 of Algorithm 3). To evaluate the quality of the sequences in the current population, several steps are taken in our algorithm. These sequences are sorted increasingly according to their energy values. Among them, three best sequences (with lowest energies) are selected for further evaluations (line 6 of Algorithm 3). The structures of these three sequences are determined by using the fold method. Then these three selected structures, as well as the best structure found, are considered, and the Hamming distances between the target structure and each of these structures are evaluated (line 7 of Algorithm 3). Again, the best three of them (lines 911 of Algorithm 3) are chosen as a basis for generating the next population (five sequences are produced from each one). The best one is also stored as the best solution till now (line 8 of AlgorithmNote: The closest probabilities to the natural ones are indicated in bold.. Average energies of sequences generated by ERD, INFO-RNA, MODENA, RNAiFold and NUPACK with respect to the natural energies for dataset A (left) and dataset B (right). The Euclidean distance is used to measure the closeness of generated sequences to the natural ones as indicated in front of each approach 3). It should be noted that in our evolutionary algorithm, we do not have crossover operation and the mutation operates at component level (not at nucleotide level). The stopping condition in our algorithm (line 12 of Algorithm 3) is either finding a solution whose Hamming distance with the target structure is 0 or continuing the aforementioned processes for at most 250 iterations (in this case, the final best solution is reported). The most expensive part of our algorithm is the fold method that requires On 3  operations. This method is performed three times, during each iteration of the Algorithm 3. For a structure of k multi-loops (k ( n in natural structures), the Evolution function (Algorithm 3) is recursively executed for at most 2k  1 times because of the decomposition scheme, which yields a rooted binary tree of 2k  1 nodes. Therefore, the overall time complexity of our algorithm is 3  250  2k  1  On 3 . In the worst case, if we consider k 2 On, the time complexity of our algorithm becomes On 4 . Our proposed evolutionary algorithm is different from MODENA and Frnakenstein approaches in three parts. First, we use the pools of natural RNA sequences, whereas MODENA and Frnakenstein use random sequences. Second, we evaluate the sequences by their energies, whereas MODENA and Frnakenstein use the fold method over the whole population to evaluate the sequences that will increase the overall running time. Third, we use the component-based mutation, whereas MODENA and Frnakenstein use the mutation over the nucleotides.
RESULTSTo test the accuracy and reliability of our algorithm, we use two different datasets. The first one is the dataset that is used in(dataset A). This dataset contains 24 sequences with length between 260 and 1475 nt. The structures of these sequences are determined by RNAfold and they are used as target structures in our comparison. The second dataset is chosen from Taneda, 2011, which contains 29 structures with length between 54 and 451 nt (dataset B). The existence of large loops in the structures of this dataset makes it difficult to design RNA sequences. We compare our algorithm with four other approaches, namely, INFO-RNA, MODENA, RNAiFold and NUPACK. Different measures are used in our comparison, as presented in the following subsections. All the results are obtained by a computer with Core2Duo (2.26 GHz) CPU, having 2 GB of memory and running Linux Ubuntu (11.04) as the operating system. The Vienna RNA Package (version 1.8.5) along with the Turner free energy parameters () is used in all approaches. Among these approaches, NUPACK is the only one that uses the ensemble defect as afitness function, where the threshold value is considered 0.01. For generating the results, the constraint programming version of RNAiFold is used without any constraint (default mode). Also in MODENA, the default parameters (50 for both population size and iterations) are used.
Stability and energy rangesFor any RNA structure, there are many compatible sequences with different levels of free energy. The difference between the highest and lowest free energy structure is considered as the energy range. Solutions of wider energy ranges are distributed more diversely in the solution space. From this point of view, our algorithm and MODENA produce sequences with wider energy ranges (using more diverse search) than the other approaches, as is understood from the energy ranges presented infor both datasets (the wider energy ranges are specified by the filled circles above them). This gives us an opportunity to select an RNA sequence in a wider range of free energies. On the other hand, the average energies of the sequences generated by our method are closer to the natural energies, compared with the other approaches, as presented in, where the Euclidean distance is used as a measure of closeness. This helps us to select an RNA sequence whose secondary structure has free energy closer to that of natural counterparts. The average Boltzmann probability of the designed sequences is also calculated and presented in Tables 2 and 3 for datasets A and B, respectively. The closest probabilities to the natural ones are indicated in bold. Dash in a cell indicates that the corresponding method could not generate any sequence for that instance. The Boltzmann probability of a structure S is defined by:where Z is the partition function, E(S) is the energy of the generated sequence over the structure S, R is the gas constant and T is the absolute temperature (). Comparing with the other methods, NUPACK is superior in generating sequences that have higher Boltzmann probabilities. However, it should be noted that the Boltzmann probabilities of natural sequences are low, as reported for Evolutionary RNA Design (ERD) and the other methods. The Boltzmann probabilities for ERD are also closer to the probabilities of natural sequences.
Accuracy and speedupThe accuracy and speed comparisons of our algorithm with other methods are presented in Tables 4 and 5 for datasets A and B, respectively, where the best results are indicated in bold. For each structure, all mentioned approaches are executed 50 times and the time limit for all approaches is considered 600 s (as it is used in RNAiFold). The success count (SC) indicates how often each approach successfully designs an RNA sequence (among 50 executions). The expected time (E t ) indicates how much time isrequired for successfully designing an RNA sequence for each structure and it is calculated as follows:This simple formula is mathematically equivalent to the expected time appeared in (). Because MODENA returns all correctly generated sequences among 50 sequences in its final population as results, the E t of MODENA is calculated by dividing its execution time by the number of correct solutions to be fair in comparison. As it is mentioned in Tables 4 and 5, our algorithm performs much better than MODENA, RNAiFold and NUPACK in all test samples. Comparing with INFORNA, our algorithm is superior especially for longer test samples.Note: The best results are indicated in bold.Note: The closest distributions to the natural ones are indicated in bold.
Nucleotide distributionThe final test we have done over the generated sequences is the nucleotide distribution. We would like to see which method produced RNA sequences with distribution closer to the natural distribution of nucleotides. To do this, we first found the natural distribution of different nucleotides appearing in different structural components. Then we analyzed the generated sequences for each method and extracted the distribution of each nucleotide for different components, as presented in. As shown in this table, the quality of the sequences generated by our algorithm is much closer to the natural distribution of nucleotides with respect to the other approaches. For example, all mentioned methods (except ERD and NUPACK) use mainly GC base pairs in generating sub-sequences corresponding to the stems. Here, ERD regards the natural distribution of nucleotides comparing with NUPACK. Also, MODENA and RNAiFold use almost always the nucleotide A for generating the sub-sequences corresponding to the loops, whereas ERD, INFO-RNA and NUPACK use the other nucleotides as well.
CONCLUSIONIn this article, a new evolutionary algorithm is proposed for solving the RNA inverse folding problem. Our algorithm is composed of several steps to design a reliable RNA sequence. The results presented in this article indicate that for longer structures, our algorithm performs better than the other mentioned algorithms in terms of accuracy, speedup and nucleotide distribution. Also, the produced energy ranges of our algorithm are comparable with those produced by MODENA. Therefore, our method could generate much more reliable sequences that have diverse stability in terms of energy range and are more similar to the natural RNA sequences. Although GC base pairs are energetically most favorable, the sequences generated by ERD do not have a high GC content. In the future, it is desirable to introduce sequence constraints in ERD to control the GC content and consequently the stability and the energy range of the designed sequence.
The Author 2014. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
A.Esmaili-Taheri et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
Evolutionary RNA design at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from
