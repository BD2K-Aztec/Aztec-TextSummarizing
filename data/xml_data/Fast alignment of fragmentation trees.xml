
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast alignment of fragmentation trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Franziska</forename>
								<surname>Hufsky</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Chair for Bioinformatics</orgName>
								<orgName type="institution">Friedrich-Schiller-University</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Max Planck Institute for Chemical Ecology</orgName>
								<orgName type="institution">Beutenberg Campus</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Kai</forename>
								<surname>Dührkop</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Chair for Bioinformatics</orgName>
								<orgName type="institution">Friedrich-Schiller-University</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Florian</forename>
								<surname>Rasche</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Chair for Bioinformatics</orgName>
								<orgName type="institution">Friedrich-Schiller-University</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Markus</forename>
								<surname>Chimani</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Algorithm Engineering</orgName>
								<orgName type="institution">Friedrich-Schiller-University</orgName>
								<address>
									<settlement>Jena</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Sebastian</forename>
								<surname>Böcker</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Chair for Bioinformatics</orgName>
								<orgName type="institution">Friedrich-Schiller-University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Fast alignment of fragmentation trees</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="265" to="273"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts207</idno>
					<note>Copyedited by: zaza MANUSCRIPT CATEGORY: [16:59 29/5/2012 Bioinformatics-bts207.tex] Page: i265 i265–i273 BIOINFORMATICS Contact: sebastian.boecker@uni-jena.de</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Mass spectrometry allows sensitive, automated and high-throughput analysis of small molecules such as metabolites. One major bottleneck in metabolomics is the identification of &apos;unknown&apos; small molecules not in any database. Recently, fragmentation tree alignments have been introduced for the automated comparison of the fragmentation patterns of small molecules. Fragmentation pattern similarities are strongly correlated with the chemical similarity of the molecules, and allow us to cluster compounds based solely on their fragmentation patterns. Results: Aligning fragmentation trees is computationally hard. Nevertheless, we present three exact algorithms for the problem: a dynamic programming (DP) algorithm, a sparse variant of the DP, and an Integer Linear Program (ILP). Evaluation of our methods on three different datasets showed that thousands of alignments can be computed in a matter of minutes using DP, even for &apos;challenging&apos; instances. Running times of the sparse DP were an order of magnitude better than for the classical DP. The ILP was clearly outperformed by both DP approaches. We also found that for both DP algorithms, computing the 1% slowest alignments required as much time as computing the 99% fastest.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Metabolomics deals with the identification and quantification of small compounds below 1000 Da, and has received increasing interest during the last years (<ref type="bibr" target="#b13">Last et al., 2007</ref>). All organisms, especially plants, fungi and bacteria, synthesize many different metabolites and a large portion of them is still unknown (<ref type="bibr" target="#b6">Fernie et al., 2004</ref>). The genome sequence usually does not reveal information about metabolite structure, as it does for protein structure. Newly identified metabolites often serve as leads in drug design (<ref type="bibr" target="#b16">Li and Vederas, 2009;</ref><ref type="bibr" target="#b25">Schmidt et al., 2007</ref>), in particular for antibiotics. For a high-throughput analysis of metabolites and other small molecules, mass spectrometry (MS) is the predominant technology (<ref type="bibr" target="#b5">Cui et al., 2008;</ref><ref type="bibr" target="#b6">Fernie et al., 2004;</ref><ref type="bibr" target="#b13">Last et al., 2007</ref>). Nuclear magnetic resonance reveals more information about the analyte, but is inapplicable for high-throughput analysis due to its low sensitivity. MS can be coupled with a separation method (gas chromatography, liquid chromatography or capillary electrophoresis) to analyze complex mixtures like cell extracts (<ref type="bibr" target="#b7">Fiehn, 2008;</ref><ref type="bibr" target="#b8">Halket et al., 2005</ref>). To obtain information beyond the compound mass, the analyte is usually fragmented, and fragment masses are recorded. Typically, collision-induced dissociation is combined with liquid chromatography–MS, whereas gas chromatography–MS uses electron impact fragmentation. The first attempt to develop computational methods for analyzing fragmentation spectra of * To whom correspondence should be addressed. metabolites has been the DENDRAL project in 1965 (<ref type="bibr" target="#b14">Lederberg, 1965</ref>). But the project was stopped after it became clear that automated structure elucidation using MS data could not be achieved at that time. Today, data analysis is still the major bottleneck in metabolomics (<ref type="bibr" target="#b18">Neumann and Böcker, 2010</ref>). Manual data analysis requires time and deep knowledge of the underlying chemistry (<ref type="bibr" target="#b27">Werner et al., 2008</ref>). Due to the limited reproducibility of the data, even library searches are difficult (<ref type="bibr" target="#b19">Oberacher et al., 2009</ref>). Additionally, spectral libraries are vastly incomplete. Methods for de novo sequencing of non-ribosomal peptides have recently been developed. But these methods rely on the fact that the analytes are structurally restricted polymers with predictable fragmentation. When manually analyzing tandem MS spectra, chemists try to annotate fragmentation peaks and identify relations between fragments, resulting in fragmentation pathways. This approach has been automated by<ref type="bibr" target="#b3">Böcker and Rasche (2008)</ref>. They calculate hypothetical fragmentation trees solely based on the MS data. Fragmentation tree nodes are annotated with the molecular formula of the fragments, whereas edges represent losses. To find a fragmentation tree that shows maximum agreement with the measured data, we search for a tree of maximum edge weight, comparable to prize-collecting Steiner trees (<ref type="bibr" target="#b17">Ljubi´cLjubi´c et al., 2005</ref>). Only lists of common and implausible losses are required as expert knowledge about fragmentation mechanisms. In<ref type="bibr" target="#b21">Rasche et al. (2011)</ref>, experts evaluated the calculated fragmentation trees and confirmed their excellent quality. Recently, methods to calculate fragmentation trees from multiple MS and gas chromatography– MS data have been developed (<ref type="bibr">Hufsky et al., 2012, manuscript;</ref><ref type="bibr" target="#b24">Scheubert et al. 2011</ref>). MS analysis of similar compounds results in similar fragmentation trees.<ref type="bibr" target="#b22">Rasche et al. (2012)</ref>proposed local tree alignments for the automated comparison of fragmentation trees and showed that this method is superior to spectral comparison. Fragmentation tree alignments even allow for inter-dataset comparisons for datasets measured on different instruments (<ref type="bibr" target="#b22">Rasche et al., 2012</ref>). A tree alignment may contain matches, mismatches, insertions and deletions, but respects the structure of the two trees. Fragmentation tree similarity is defined via edges (representing losses) and nodes (representing fragments). A local tree alignment contains those parts of the two trees where similar fragmentation cascades occurred. Tree alignments were introduced by<ref type="bibr" target="#b12">Jiang et al. (1995)</ref>and can be applied for RNA secondary structure comparison (<ref type="bibr" target="#b15">Le et al., 1989</ref>). RNA structure trees are ordered, that is, the children of any node have a fixed order. In contrast, fragmentation trees are unordered, as there cannot exist any sensible ordering for the sub fragments of some fragment. In this respect, fragmentation trees are more similar to phylogenetic trees than to RNA structure trees. Whereas efficient, polynomial-time algorithms exist for the alignment of ordered trees, the alignment of unordered trees is computationally hard, namely MAX SNP-hard (<ref type="bibr" target="#b12">Jiang et al., 1995</ref>). This implies that there exists no<ref type="bibr" target="#b0">Arora et al., 1998</ref>). In case both trees have fixed maximum out degree, an optimum alignment can be computed via dynamic programming (DP) in polynomial time (<ref type="bibr" target="#b12">Jiang et al., 1995</ref>). In comparison, computing the edit distance between two unordered trees remains MAX SNP hard even for bounded degrees (<ref type="bibr" target="#b28">Zhang and Jiang, 1994</ref>). An informal algorithm for aligning fragmentation trees was presented by<ref type="bibr" target="#b22">Rasche et al. (2012)</ref>, and join nodes were introduced to account for missing nodes in one of the trees compared. Missing nodes result from missing peaks in one of the spectra.<ref type="bibr" target="#b22">Rasche et al. (2012)</ref>do not give a correctness proof or running time analysis for the algorithm. As related work, we mention the TreeConstrained Bipartite Matching problem where either a node or any of its descendants may be part of the matching; this problem is also APX-hard (<ref type="bibr" target="#b4">Canzar et al., 2011</ref>). Our contribution: we modify the tree alignment algorithm from<ref type="bibr" target="#b12">Jiang et al. (1995)</ref>for edge similarities and local alignments, and analyze its running time. We then show how to integrate join nodes without increasing the worst-case running time. Next, we modify the algorithm to allow for sparse DP, a technique common in RNA folding (<ref type="bibr" target="#b1">Backofen et al., 2011</ref>). This does not only decrease the practical memory requirements of the method but, more importantly, also severely decreases running times in practice. Furthermore, we present an Integer Linear Program (ILP) for the fragmentation tree alignment problem, as ILPs often solve NP-hard problems swiftly in practice. We then evaluate all methods on real-world data, and find that the sparse DP approach dominates the classical DP, resulting in an 11-fold speed-up for one dataset. Somewhat unexpectedly, the ILP is clearly outperformed by both DP approaches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">ALIGNING FRAGMENTATION TREES</head><p>Let T = (V ,E) be a tree; the elements of V are called nodes. In the following, we assume all trees to be arboreal, that is, all edges in E are directed away from some root node. By uv, we denote a directed edge from node u to node v. Let p(v) be the parent node of some node v. A fragmentation tree is a tree T = (V ,E) together with an edge labeling : E → L. In more detail, nodes V correspond to fragments of a compound, whereas the labels L are (neutral or radical) losses: that is, both are molecular formulas over some fixed alphabet of elements (<ref type="bibr" target="#b3">Böcker and Rasche, 2008</ref>). Formally, molecular formulas are compomers or multi sets. The children of any node of a fragmentation tree are intrinsically unordered, as there is no sensible way to order the sub fragments of some fragment. In our presentation, we will not consider the molecular formulas of fragments, and concentrate on comparing losses only. As we will see below, comparing fragments instead or comparing both simultaneously requires only minor modifications. See<ref type="figure">Figure 1</ref>for two examples of fragmentation trees. We introduce some notation used throughout this article: Let</p><formula>T 1 = (V 1 ,E 1 ) and T 2 = (V 2 ,E 2 )</formula><p>be the two trees we want to align. We sometimes call T 1 the left tree and T 2 the right tree. Let C(v) denote the children (nodes) of any node v in T 1 or T 2. In the following, we usually assume that u is a node of T 1 , and v a node of T 2. For i = 1,2, let n i := |V i | be the number of nodes in T i , and let d i be the maximum out degree in T i. These maximum out degrees will be of particular interest to us, as the running time of our DP grows exponentially in d 1 ,d 2. Let δ = min{d 1 ,d 2 } and = max{d 1 ,d 2 }.<ref type="bibr" target="#b22">Rasche et al. (2012)</ref>introduce a similarity function σ : L×L → R for pairs of losses (molecular formulas). We do not repeat the details here, but note that this implies a similarity function σ : E 1 ×E 2 → R between edges of the two trees T 1 ,</p><formula>T 2 via σ (e 1 ,e 2 ) = σ ((e 1 ),,(e 2 )</formula><p>). They also introduce a similarity function for fragment molecular formulas, which induces a similarity function between nodes of the two trees. Furthermore, they also extend the definition of tree alignments by introducing a join operator [see<ref type="figure" target="#fig_0">Figure 2</ref>(In the left tree, the fragment after loosing H 3 N is missing (dashed edges and node), whereas the fragment after further loss of C 2 H 2 is observed. To account for missing fragments, we introduce the join operation. It allows to align the two successive losses H 3 N and C 2 H 2 in the right tree to a single loss C 2 H 5 N in the left tree (dotted edges). Fragments may be missing because the corresponding peak was not detected, for example p 1 by adding the corresponding losses (</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fast alignment of fragmentation trees</head><formula>e 1 )+(e 1 ) ∈ L.</formula><p>This means taking the sum of the respective compomers or the additive union of the corresponding multisets. We then assign a similarity between p 1 and any edge e 2 of</p><formula>T 2 as σ (p 1 ,e 2 ) = σ ((e 1 )+(e 1 ),,(e 2 )</formula><p>). Analogously, we can define a similarity for paths of length two in T 2. Obviously, this can be generalized to paths of arbitrary lengths but here, we will limit ourselves to paths of length two. For joining nodes in the alignment, we assume homogeneous join costs: The penalty for joining a node is σ join ≤ 0, independent of the node or edge that we want to join. Formally, this allows us to focus on the important aspects of our algorithms, and omit some technical details. Practically, we currently see no biologically reasonable way to assign different scores to different join nodes, as these usually correspond to the non-detection of a peak in one of the mass spectra. Let T 1 ,T 2 be two trees. We define a global alignment A of T 1 ,T 2 as follows (<ref type="bibr" target="#b12">Jiang et al., 1995</ref>): A is a tree where nodes are labeled with pairs from (V 1 ∪{–})×(V 2 ∪{–}). Here, '–' is the gap symbol [see<ref type="figure" target="#fig_0">Figure 2</ref>(a)]. If we restrict labels of A to the first coordinate and contract all edges that end in a node labeled '–', we end up with the tree T 1 ; if we do the same for the second coordinate, we end up with the tree T 2. (In fact, we have to replace the nodes of the restricted trees by their labels, we omit the simple technical details.) We say that A is a local alignment if the trees originating from contracting gap edges are induced subtrees of T 1 and T 2 , respectively. Different from<ref type="bibr" target="#b12">Jiang et al. (1995)</ref>, we want to score an alignment based on the edges of the two trees. To this end, for any node a of A but the root, let e 1 (a) be the unique edge in T 1 that ends in the first coordinate of the label of a, and let e 2 (a) be the unique edge in T 2 that ends in the second coordinate of the label of a. In case no such edge exists, we assume e 1 (a) = '–' or e 2 (a) = '–', respectively. Now, we define the score of A as non-root node a of A</p><formula>σ (e 1 (a),e 2 (a)).</formula><p>We define σ (T 1 ,T 2 ) as the maximum score of a local alignment of T 1 and T 2. Scoring node pairs and scoring edge pairs are closely related: We can push an edge score into its end node, or we can pull a node score into its unique incoming edge. The only difference is that the root node is not considered when scoring edge pairs. The two scorings can be combined by introducing a particular root scoring σ * : V 1 × V 2 → R for the root nodes of the alignment. In the following, we omit the simple but somewhat tedious details, and simply note that all algorithms presented here work both with node scoring, edge scoring, as well as a combination thereof. A local fragmentation tree alignment for two compounds from the Orbitrap dataset (see Section 6) can be found in<ref type="figure">Figure 1</ref>.is the best score of matching edge ua on edge vb, such that maximally the children A of u and B of v are used. (b) deleteL u,v<ref type="bibr">[A,B]</ref>is the best score for deleting edge ua, such that maximally the children A of u and B of v are used. A subset B ⊆ B of the children of v can now be matched to the children of a non-empty sets A ⊆ C(u) and B ⊆ C(v) we set<ref type="bibr">,B]</ref>,deleteR u,v<ref type="bibr">[A,B]</ref>where we define</p><formula>S u,v [A,B]=max 0,match u,v [A,B],</formula><formula>deleteL u,v [A</formula><formula>match u,v [A,B]:= max a∈A,b∈B S(a,b)+ S u,v A−{a},B−{b} +σ (ua,vb) deleteL u,v [A,B]:= max a∈A,B ⊆B S a,v [C(a),B ]+ S u,v [A−{a},B−B ]+σ (ua,–) deleteR u,v [A,B]:= max A ⊆A,b∈B S u,b [A ,C(b)]+ S u,v [A−A ,B−{b}]+σ (–,vb)</formula><formula>(2)</formula><p>Here, σ (ua,vb) denotes the score of the losses attached to arcs ua and vb, and σ (ua,–),σ (–,vb) accordingly. Recurrence (2) is the obvious modification of the recurrence presented in<ref type="bibr" target="#b12">Jiang et al. (1995)</ref>for global alignments and node similarities. Merging two losses in T 1 or T 2 requires two additional symmetric cases, namely join left and join right for merging in tree T 1 or T 2 , respectively. To speed up computations, we add an additional prejoin case for nodes that will be joined in the alignment. We set</p><formula>S u,v [A,B]=max 0,match u,v [A,B],</formula><formula>deleteL u,v [A,B],deleteR u,v [A,B],</formula><formula>joinL u,v [A,B],joinR u,v [A,B] (3)</formula><p>where we define, in addition to (2),</p><formula>prejoinL u,v [A,B]:= max a∈A,b∈B S(a,b)+ prejoinL u,v A−{a},B−{b} + σ (p(u)a,vb)+σ join joinL u,v [A,B]:= max a∈A,B ⊆B prejoinL a,v [C(a),B ]+ S u,v [A−{a},B−B ]</formula><p>(4)</p><p>Here, σ (p(u)a,vb) is the score for the combined losses on the path from p(u) to a with the loss of edge vb. Recall that σ join ≤ 0 is the penalty for joining a node. Again, we initialize joinL u,v [A,∅] = joinL u,v<ref type="bibr">[∅,B]</ref>=0 for all A,B. Analogously to (4), we can define recurrences for prejoinR u,v<ref type="bibr">[A,B]</ref>and joinR u,v<ref type="bibr">[A,B]</ref>. For bottom-up DP (<ref type="bibr" target="#b26">Sniedovich, 2006</ref>), we have to find an order in which the entries of the DP tables can be filled. Computation of match u,v<ref type="bibr">[A,B]</ref>, deleteL u,v<ref type="bibr">[A,B]</ref>and deleteR u,v<ref type="bibr">[A,B]</ref>only accesses entries S u ,v<ref type="bibr">[A ,B ]</ref>, such that u ∈{u}∪C(u) and v ∈{v}∪C(v). By processing nodes in postorder, we ensure that all S u ,v<ref type="bibr">[A ,B ]</ref>are previously computed for (u ,v ) = (u,v). For the remaining case, we iterate |A|+|B|=0,1,...,|C(u)|+|C(v)|. Similar arguments hold for the computation of join and prejoin nodes.</p><formula>Theorem 1. Let T 1 = (V 1 ,E 1 ) and T 2 = (V 2 ,E 2 )</formula><p>be two trees, σ : E 1 ∪{–}×E 2 ∪{–}→R a scoring function between edge pairs, and σ join ∈ R the penalty for joining a node. For i = 1,2 set n i := |V i |, and let d i be the maximum out degree in T i. The maximum score σ (T 1 ,T 2 ) of a local alignment of T 1 ,T 2 can be computed</p><formula>in O 3 ·2 δ ·δn 1 n 2 using recurrence (3) and equation (1), where := max{d 1 ,d 2 } and δ := min{d 1 ,d 2 }.</formula><p>The proof of the theorem is based on the following lemma:</p><formula>Lemma 1. Computing S u,v [A,B] for all A ⊆ C(u) and B ⊆ C(v) is possible using recurrence (3) in O(3 d u ·2 d v ·d v +2 d u ·3 d v ·d u ) time, where d u =|C(u)| and d v =|C(v)|.</formula><p>See the Supplementary Material for proofs of Lemma 1 and Theorem 1. Similarly to Theorem 1, we can show that any pairwise tree alignment that does not take joining nodes into account, can also be computed in this time. We leave out the straightforward details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fast alignment of fragmentation trees</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SPARSE DYNAMIC PROGRAMMING</head><p>Applying the above algorithm to real-world instances of aligning fragmentation trees, one can see that S(u,v) = 0 holds for many node pairs u,v. This can be attributed to two factors: First, we are computing local alignments, so we can always choose to end the alignment subtrees in the nodes u,v. Second, there are many different labels found at the edges (or nodes) of a fragmentation tree. A reasonable scoring scheme will assign negative scores to most non-matching edge (or node) labels, so it is rather the exception than the rule that we can find two nodes u,v with S(u,v) &gt; 0. The idea is to 'sparsify' our DP tables by storing only those table entries with positive values. Thereby, we face the following fact: If S u,v<ref type="bibr">[A,B]</ref></p><formula>&gt; 0 for A ⊆ C(u) and B ⊆ C(v) then S u,v [A ,B ] &gt; 0 holds for all supersets A ,B with A ⊆ A ⊆ C(u) and B ⊆ B ⊆ C(v).</formula><p>So, as soon as we have one non-zero entry in the table, then an exponentially large part of the table will be filled with non-zero entries, too. To negate this rather unfortunate effect, we modify our DP as follows: for A ⊆ C(u) and B ⊆ C(v), we define S u,v [A,B] to be the score of an optimum local alignment with subtrees rooted in u and v, respectively, such that exactly the children A of u and B of v are used in the local alignment. If no such alignment exists, we set S u,v<ref type="bibr">[</ref>for the maximum over all subsets of C(v) or C(u), respectively. For non-empty sets A ⊆ C(u) and B ⊆ C(v) we set</p><formula>S u,v [A,B]=max match u,v [A,B], deleteL u,v [A,B],deleteR u,v [A,B], joinL u,v [A,B],joinR u,v [A,B] (6)</formula><p>which, compared to (3), misses the lower bound 0 and uses the definitions:</p><formula>(8)</formula><p>To summarize, the central point is that we do not have to store any entries with S u,v [A,B]≤0: such entries will never lead to an optimal alignment, as we are better off removing all nodes A,B, plus everything below these nodes from the alignment. The only exception to this rule is that we store the entry S u,v [∅,∅] = 0. Furthermore, we do not have to store entries S u,v<ref type="bibr">[A,B]</ref>if there exist subsets A ⊆ A, B ⊆ B with (A ,B ) = (A,B) such that S u,v [A,B]≤ S u,v<ref type="bibr">[A ,B ]</ref>. In this case, we can replace an alignment that uses children A,B of u,v, by an alignment that uses only children A ,B and has better or equal score. We say that an entry S u,v [A,B] is dominated by entry S u,v<ref type="bibr">[A ,B ]</ref>. For a scoring scheme that assigns negative scores for non-matching edge (or node) labels, large parts of the tables have negative scores or are dominated by another entry. We do not actually have to forbid that dominated entries are stored, as they do not interfere with our computations; rather, we are free to leave out dominated entries when we encounter them. The resulting tables S u,v are sparsely populated, and for many vertices u,v, there are no entries with S u,v [A,B] &gt; 0. We can reduce the memory consumption of the method using hash maps instead of arrays. Hash map implementations like Cuckoo hashing (<ref type="bibr" target="#b20">Pagh and Rodler, 2004</ref>) or Hopscotch hashing (<ref type="bibr" target="#b9">Herlihy et al., 2008</ref>) can carry out all operations in constant (amortized) time. In practice, we find that memory consumption is usually not prohibitive. In this case, we can use lazy arrays that are not allocated until a first entry is stored. Resolving the recurrences: Now, it is time for our final trick: instead of computing the scores using recurrence (6–8), we apply a successive approximation procedure similar to Dijkstra's Algorithm for shortest paths (<ref type="bibr" target="#b26">Sniedovich, 2006</ref>). That is, instead of 'pulling' scores from previously calculated entries, we 'push' scores from entries that have been finalized. For example, assume that we have finalized the computation of some entry</p><formula>S u,v [A,B] for fixed A ⊆ C(u) and B ⊆ C(v). Also assume that S u,v [A,B] &gt; 0 as otherwise, S u,v [A,B] is dominated by S u,v [∅,∅] =</formula><p>0. Then, recurrence (7) tells us that we can update other entries of the table accordingly:</p><formula>if S u,v [A,B] &gt; S u,v [ * ,B]</formula><p>(which we assume to be incompletely calculated so far) then<ref type="bibr">B]</ref>. Regarding the recurrence for match , we iterate over all a ∈ C(u)\A</p><formula>S u,v [ * ,B]← S u,v [A,B]. Similarly, if S u,v [A,B] &gt; S u,v [A, * ] then S u,v [A, * ] ← S u,v [A,B], and if S u,v [A,B] &gt; S(u,v) then S(u,v) ← S u,v [A,</formula><formula>and b ∈ C(v)\B: If match u,v [A∪{a},B∪{b}] &lt; S(a,b)+S u,v [A,B]+ σ (ua</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>F.Hufsky et al.</head><p>match u,v<ref type="bibr">[A,B]</ref>then the entry match u,v<ref type="bibr">[A∪{a},B∪{b}]</ref>is dominated and we can remove it from the hash map. For all other cases, similar updates can be performed, which we only sketch here: For deleteL we iterate over all</p><formula>a ∈ C(u)\ A and B ⊆ C(v)\B; if deleteL u,v [A∪{a},B∪B ] &lt; S a,v [ * ,B ]+ S u,v [A,B]+σ (ua,</formula><p>–) then update it accordingly. Updates have to be performed as soon as an entry is finalized, that is, it cannot be changed by any future modifications. Finding finalized entries is similar to the order of computations in the previous section; we omit the technical details. The above algorithm has exactly the same worst-case running time complexity as the initial recurrence from Section 3. But in practice, we can get even faster, at least in cases where the arrays are very sparse: to this end, finalizing some entry deleteL u,v<ref type="bibr">[A,B]</ref>triggers updates for all subsets B ⊆ C(v)\B. But only those B can lead to relevant updates where S a,v [ * ,B ] &gt; 0 holds. Otherwise, the updated entry will be dominated by S a,v<ref type="bibr">[ * ,∅]</ref>= 0. If we iterate over the hash map for those B with S a,v<ref type="bibr">[ * ,B ]</ref>&gt; 0 then the worst-case running time increases to O 4 ·2 δ ·δn 1 n 2 , assuming constant time access to the hash map. However, in practice, running time decreases if the DP tables are sparsely populated. We stress that the sparse DP still guarantees to find the optimal solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">INTEGER LINEAR PROGRAMMING</head><p>ILPs are a classical approach for finding exact solutions of computationally hard problems. We now present an ILP for computing a pairwise unordered tree alignment. Again, let</p><formula>T 1 = (V 1 ,E 1 ),T 2 = (V 2 ,E 2 )</formula><p>be the input trees with V 1 ∩V 2 =∅. As the ILP is edge based, we have to introduce some additional notation: Let e ∈ E i , i ∈{1,2}, be any edge in one of the two given trees. We denote by D(e) the set of edges in the subtree rooted at the head of e, and by N (e) := E i \({e}∪D(e)) the non-descendant edges of e. For an edge e, we define p(e) to be the parent edge, and p * (e) := {p(e),p(p(e)),...} all of its ancestor edges. Finally, F (e) := D(p(e))∩N (e) is the 'extended family' of e, that is, all descendants of e's parent edge, except for e and its descendants. We start with the ILP without considering the join operation (ILP 1) and use the following binary variables: Iff an edge e ∈ (E 1 ∪E 2 ) appears in the aligned subtree, we have z e = 1; iff this edge is aligned to a gap, we have y e = 1. Finally, iff an edge e ∈ E 1 is aligned to an edge f ∈ E 2 , we have x {e,f } = 1. The constraints (10) ensure for each edge that we decide whether this edge is used in the alignment and if, how it is aligned. The inequalities (11) ensure that the subgraphs of T 1 (and T 2 ) are proper trees. Finally, (12) ensure that the obtained alignments are consistent: assume an alignment e,f then we cannot also align a descendant of e with a nondescendant of f and vice versa. The conditional term following the universal quantifier simply avoids redundancy. Based thereon, we can construct an ILP allowing join operations (ILP 2). Therefore, we require additional binary variables x</p><formula>(i) {e,f } (with i ∈{1,2},e ∈ E i ,f ∈ E 3−i )</formula><p>, which are 1 iff the joined edges (p(e),e) are aligned with f. Technically, we also require x {e,f } = 1 in such a case. Note that this amount of additional variables is necessary to compose a linear objective function, when the join costs cannot be computed only based on align-and gap costs. Furthermore, we introduce binary variables φ e , e ∈ (E 1 ∪E 2 ), which are 1 iff the edge e is used as a parent edge withinFragmentation trees were computed for all compounds. Only non-empty trees were considered for tree alignment. The maximum out degree of a single tree is denoted by out degree max. Number of alignments is given without self-alignments.</p><formula>a join (e.g., φ p(e) = 1 if the former x (i)</formula><p>{e,f } variable is 1). We use the shorthands</p><formula>σ (1) (e,f ) := σ (e+p(e),f )+σ join −σ (e,f ) and σ (2) (e,f ) := σ (e,f +p(f ))+σ join −σ (e,f )</formula><p>in the objective function. Constraints (15)–(17) are analogous to the former ILP. While (18) guarantees that joins are always separated from each other within an input tree, (19) ensures that at most one joined alignment may occur for any edge.<ref type="bibr">Inequalities (20)</ref>–(22) make sure that a parent edge e is only marked as a joined parent iff all its aligned children are joined with e. Finally, (23) guarantees that we do not align two joined edges with each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EXPERIMENTAL RESULTS</head><p>To evaluate our work, we used three different test datasets (<ref type="figure" target="#tab_1">Table 1</ref>). The Orbitrap dataset (<ref type="bibr" target="#b22">Rasche et al., 2012</ref>) contains 97 compounds, measured on a Thermo Scientific Orbitrap XL instrument. The</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fast alignment of fragmentation trees</head><formula>max e∈E 1 , f ∈E 2 σ (e,f )·x {e,f } + e ∈E 1 σ (e ,–)·y e + e ∈E 2 σ (–,e )·y e (9) s.t. y e + f ∈E 3−i x {e,f } = z e ∀i ∈{1,2},e ∈ E i (10) z e +z e ≤ 1+z e ∀i ∈{1,2},e ∈ E i ,e ∈ D(e),e ∈ F(e)</formula><formula>( 1 1 )</formula><formula>x {e,f } +x {e ,f } ≤ 1 ∀i ∈{1,2},e ∈ E i ,f ∈ E 3−i ,</formula><formula>(12)</formula><formula>e ∈ D(e),f ∈ N (f ),[if i = 2: f ∈ p * (f )] x {e,f } ,y e ,z e ∈{0,1} ∀ e ∈ E 1 ,f ∈ E 2 ,e ∈ (E 1 ∪E 2 ) (13)</formula><p>ILP 1: The ILP for pairwise unordered tree alignment without join operations max</p><formula>e∈E 1 , f ∈E 2 σ (e,f )x {e,f } + i∈{1,2} σ (i) (e,f )x (i) {e,f } + e ∈E 1 σ (e ,–)y e + e ∈E 2 σ (–,e )y e (14) s.t. y e +φ e + f ∈V 3−i x {e,f } = z e ∀i ∈{1,2},e ∈ E i (15) z e +z e ≤ 1+z e ∀i ∈{1,2},e ∈ E i ,e ∈ D(e),e ∈ F(e) (16) x {e,f } +x {e ,f } ≤ 1 ∀i ∈{1,2},e ∈ E i ,f ∈ E 3−i ,</formula><formula>(17)</formula><formula>e ∈ D(e),f ∈ N (f ),[if i = 2: f ∈ p * (f )] φ e +φ e ≤ 1 ∀e ∈ (E 1 ∪E2),e = p(e ) (18) x (1)</formula><p>{e,f } +xFor the Orbitrap and the MassBank dataset, we found that for over 98% of the instances, the running time was in the range of microseconds for both DP algorithms. For these datasets, we only evaluate total running times for all alignments. For MassBank, the classical DP (Section 3) finished in 4.2 s for an all-againstall alignment of 343 trees, whereas sparse DP (Section 4) only required 1.8 s. For Orbitrap, the classical DP finished in 5.4 s for the all-against-all alignment of 93 trees, whereas sparse DP required 0.6 s, a 9-fold speed-up. In contrast, the ILP needed 9.6 min for all alignments in the MassBank datasets and 14.5 min for all alignments in the Orbitrap dataset. The Hill dataset contains trees with much higher maximum out degree, so we performed a more detailed running time analysis. Classical DP required 13.9 min and sparse DP finished in 1.3 min, an 11-fold speed-up. Running times of the ILP could only be measured without allowing join operations. For 1241 instances, computations run into the memory limitation of 2 GB. For the remaining alignments, the ILP finished in 11.24 h. Hence, we excluded the ILP from our detailed analysis. To get an overview of the differences in the running times between hard and easy alignments, we sorted the instances by their running times in increasing order. This was done separately for each algorithm. See<ref type="figure" target="#fig_6">Figure 4</ref>(top) and<ref type="figure" target="#tab_2">Table 2</ref>. For both algorithms, we found that the 99% fastest alignments need nearly as much computing time as the remaining 1% slowest alignments. We further sorted all instances by the running time of the classical DP (see again<ref type="figure" target="#fig_6">Figure 4</ref>). We found that for every instance, sparse DP requires less time than the classical DP.</p><formula>(2) {e,f } ≤ x {e,f } ∀e ∈ E 1 ,f ∈ E 2 (19) x {e,f } −x (i)</formula><formula>{e,f } ≤ 1−φ e ∀i ∈{1,2},e ∈ E i ,e = p(e),f ∈ E 3−i (20) y e ≤ 1−φ e ∀i ∈{1,2},e ∈ E i ,e = p(e)</formula><formula>(21) x (i)</formula><formula>{e,f } ≤ φ e ∀i ∈{1,2},e ∈ E i ,e = p(e),f ∈ V 3−i (22) x (i)</formula><formula>{e,f } +φ f ≤ 1 ∀i ∈{1,2},e ∈ E i ,f ∈ E 3−i ,f = p(f ) (23) x {e,f } ,y e ,z e ,x (i) {e,f } ,φ e ∈{0,1} ∀ i ∈{1,2},e ∈ E 1 ,f ∈ E 2 ,e ∈ (E 1 ∪E 2 ) (24)</formula><formula>(a)</formula><p>(b)(a) Total running times when instances are sorted by individual running times. For any fraction x%, we calculate the total running time of the x%, instances for which the alignment was computed faster than for any of the remaining instances. For example at 50% one can find the running time that was needed to compute the 50% fastest instances. For each algorithm, instances were sorted separately. Note the logarithmic y-axis. (b) Individual running times for the 200 slowest instances of the classical DP algorithm. Instances are sorted by their running time for the classical DP algorithm. One can see that running times of the classical DP are outperformed by that of the sparse DP a large database requires tree alignments to be executed extremely fast. In this article, we have presented three exact algorithms for the alignment of fragmentation trees. We find that the sparse DP approach dominates the classical DP, resulting in an 11-fold speedup for one dataset. ILPs have an excellent record of providing fast algorithms for NP-hard problems. Thus, it is rather unexpected that, for the problem discussed here, the ILP is usually clearly outperformed by both DP approaches; still, it has the potential to solve those instances that are 'hard' for DP-based algorithms. Also, in such cases we may use the ILP as a heuristic, solving only its LP relaxation and applying some integer rounding algorithm, many of which are standard in state-of-the-art ILP solvers.When larger datasets become available, we expect the total running time of an all-against-all alignment to increase more than quadratic with dataset size: We have shown above that a large fraction of the total running time stems from a few 'hard' alignments which, in turn, correspond to a few trees in the dataset that are large and, in particular, have high out degrees. We conjecture that for larger datasets, the running time spent on computing the 99% fastest alignments will be significantly smaller than the running time spent on the 1% slowest alignments. Here, even faster methods for computing fragmentation tree alignments are sought. We will evaluate whether our ILP is capable of solving these 'hard' instances faster than a DP-based approach, as its running time is not directly dependent on the out degree of the trees. We have put particular focus on fragmentation trees that are hard to align, namely large trees with high out degrees. Small trees with low out degree seem to be less interesting since they often belong to small compounds (&lt;300 Da). Often, these compounds are 'knowns' (that is, reference measurements of the compound can be found in a spectral library) and can be identified by spectral comparison. Also, small fragmentation trees contain less information for, say, classifying an unknown compound. Nevertheless, we believe that we can also speed up alignments when one of the fragmentation trees is relatively small: this may be achieved using some preprocessing for small trees with, say, less than four losses. We conjecture that running time of the DP (Theorems 1 and 2) can be improved to</p><formula>O(2 d 1 +d 2 ·poly(d 1 ,d 2 )n 1 n 2 )</formula><p>using the Möbius transform (<ref type="bibr" target="#b2">Björklund et al., 2007</ref>), but this appears to be of theoretical interest only. In our evaluations, we have used a scoring function similar to the one by<ref type="bibr" target="#b22">Rasche et al. (2012)</ref>. Both scorings lack any statistical explanation and should be refined in the future using, say, log odds scores. Also, the effect of merging two or possibly even more nodes has to be investigated. Both questions were beyond the scope of this work. Another interesting question is whether polynomial-time methods for tree alignment of unordered trees, such as the constrained tree edit distance (<ref type="bibr" target="#b29">Zhang, 1996</ref>), can be used for aligning fragmentation trees: whereas the restrictions imposed by<ref type="bibr" target="#b29">Zhang (1996)</ref>have no sensible interpretation in the context of fragmentation trees, quality of results may still be sufficient for certain applications. Aligning fragmentation trees allows for an automated classification of unknown compounds into compound classes. Thus, large-scale compound screens can easily be searched for compounds of interest. This may be useful in the search for signaling molecules, biomarkers, or novel drugs and the identification of illegal drugs or toxins. In conjunction with other methods from i272</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fast alignment of fragmentation trees</head><p>systems biology, the concept can help to identify new metabolic pathways based on tandem MS experiments.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.2.</head><figDesc>Fig. 2. Two alignments of fragmentation trees based on edge similarities. Nodes represent molecular formulas of the fragments, edges represent molecular formulas of the losses. (a) A gap (–) is introduced for the missing CO loss in the left tree (dashed edge and node). Losses CO and CH 3 are aligned by a mismatch (dotted edges). (b) In the left tree, the fragment after loosing H 3 N is missing (dashed edges and node), whereas the fragment after further loss of C 2 H 2 is observed. To account for missing fragments, we introduce the join operation. It allows to align the two successive losses H 3 N and C 2 H 2 in the right tree to a single loss C 2 H 5 N in the left tree (dotted edges). Fragments may be missing because the corresponding peak was not detected, for example</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.3.</head><figDesc>Fig. 3. Representation of the match and the deleteL recurrences of the DP algorithm. (a) match u,v [A,B] is the best score of matching edge ua on edge vb, such that maximally the children A of u and B of v are used. (b) deleteL u,v [A,B] is the best score for deleting edge ua, such that maximally the children A of u and B of v are used. A subset B ⊆ B of the children of v can now be matched to the children of a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>Copyedited by: zaza MANUSCRIPT CATEGORY: [16:59 29/5/2012 Bioinformatics-bts207.tex] Page: i269 i265–i273</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>Copyedited by: zaza MANUSCRIPT CATEGORY: [16:59 29/5/2012 Bioinformatics-bts207.tex] Page: i271 i265–i273</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>ILP 2: The ILP for pairwise unordered tree alignment including join operations</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.4.</head><figDesc>Fig. 4. Running times for the Hill dataset with 5151 individual alignments. (a) Total running times when instances are sorted by individual running times. For any fraction x%, we calculate the total running time of the x%, instances for which the alignment was computed faster than for any of the remaining instances. For example at 50% one can find the running time that was needed to compute the 50% fastest instances. For each algorithm, instances were sorted separately. Note the logarithmic y-axis. (b) Individual running times for the 200 slowest instances of the classical DP algorithm. Instances are sorted by their running time for the classical DP algorithm. One can see that running times of the classical DP are outperformed by that of the sparse DP</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>Copyedited by: zaza MANUSCRIPT CATEGORY: [16:59 29/5/2012 Bioinformatics-bts207.tex] Page: i273 i265–i273</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>b)]: Given a path p 1 in T 1 of length two, let e 1 ,e 1 be the edges of p 1 .</figDesc><table>We can assign a loss to 

i266 Copyedited by: zaza 

MANUSCRIPT CATEGORY: 

[16:59 29/5/2012 Bioinformatics-bts207.tex] 
Page: i267 i265–i273 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>but this is not possible for the table S as the optimal alignments might not use all the children of a or b. To this end, we introduce</figDesc><table>A,B]=−∞. Then S 
u,v [∅,∅] = 0, but for all A,B =∅ we have 
S 
u,v [A,∅] &lt; 0, S 
u,v [∅,B] &lt; 0. Clearly, 

S(u,v) = 
max 

A⊆C(u),B⊆C(v) 

S 
u,v [A,B]. 
(5) 

We need one more trick in our recurrence: in (2) we have accessed 
entries S a,v [C(a),B ] and S u,b [A ,C(b)], S 
u,v [A, * ] := max 

B ⊆C(v) 


S 
u,v [A,B ] 


, 

S 
u,v [ * ,B]:= max 

A ⊆C(u) 


S 
u,v [A ,B] 


, 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>,vb) then update it accordingly. If match u,v [A∪{a},B∪{b}] ≤</figDesc><table>i269 Copyedited by: zaza 

MANUSCRIPT CATEGORY: 

[16:59 29/5/2012 Bioinformatics-bts207.tex] 
Page: i270 i265–i273 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 1. The three datasets used in this study</figDesc><table>Characteristics of the datasets 
Orbitrap 
MassBank 
Hill 

Number of compounds 
97 
370 
102 
Number of non-empty trees 
93 
343 
102 
Maximum out degree 
7 
6 
10 
Average/median out degree max 
3 
2 
5 
Number of alignments 
4278 
58 653 
5151 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="true"><figDesc>Table 2. Running times for the Hill dataset</figDesc><table>Algorithm All 
90% fastest 
99% fastest 
1% slowest 

DP 
833.3 s 133.5 s (16.0%) 437.9 s (52.6%) 395.4 s (47.4%) 
Sparse DP 75.3 s 
13.9 s (18.5%) 33.9 s (45.0%) 41.4 s (55.0%) 

Speed up 11-fold 10-fold 
13-fold 
10-fold 

We report running times in seconds and as fractions of the total running time for all 
instances (5151 alignments). We also report running time for the 90 and 99% fastest and 
for the 1% slowest alignments. For both algorithms, instances were sorted separately. 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> DYNAMIC PROGRAMMING We now present an algorithm to compute optimum fragmentation tree alignments that has reasonable running time in practice. Our algorithm is a modification of an algorithm by Jiang et al. (1995) for computing global alignments of unordered trees. The reason for these algorithms to be swift in practice is that fragmentation trees usually have comparatively small out degree: fragments rarely have more than, say, five child fragments. We can limit the inevitable exponential part of the running time to this out degree. We use DP to compute the maximal score σ (T 1 ,T 2 ) of a local alignment between two trees T 1 ,T 2. Let S(u,v) be the maximal score of a local alignment of two subtrees of T 1 ,T 2 , where the subtree of T 1 is rooted in u, and the subtree of T 2 is rooted in v. For A ⊆ C(u) and B ⊆ C(v), we define S u,v [A,B] to be the score of an optimal local alignment of subtrees rooted in u and v, respectively, such that maximally the children A of u and B of v are used in the alignment. Clearly, S(u,v) = S u,v [C(u),C(v)]. Furthermore, we have S u,v [A,∅] = S u,v [∅,B]=0 for all A,B. When all S(u,v) are known, we can compute the maximal score of a local alignment of T 1 ,T 2 as σ (T 1 ,T 2 ) = max u∈T 1 ,v∈T 2 S(u,v). (1) We present a recurrence for the computation of S u,v [A,B]. We initialize S u,v [A,B]=0 for A =∅ or B =∅. Recall that T 1 is the left tree and T 2 is the right tree. In the recurrence, we distinguish three cases, namely match (including mismatches), deletion left or deletion right, where the latter two are symmetric (Figure 3). For i267 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Theorem 2. A pairwise unordered tree alignment (global or local, scoring nodes or edges or both, with similarities or costs) of rooted trees T 1 ,T 2 can be computed in O 3 ·2 δ ·δn 1 n 2 time. Here, n i is the number of nodes in tree T i , and d i is the maximum out degree in T i , for i = 1,2; furthermore, := max{d 1 ,d 2 } and δ := min{d 1 ,d 2 }. i268 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">MassBank dataset (Horai et al., 2010) consists of 370 compounds measured on a Waters Q-Tof Premier spectrometer. The Hill dataset consists of 102 compounds measured on a Micromass Q-Tof, published by Hill et al. (2008). We omit the experimental details. Fragmentation trees were computed using ILP as described in Rauf et al. (2012). Self-alignments were excluded from the analysis. For our evaluations, we use a scoring function very similar to the one from (Rasche et al., 2012), evaluating pairs of losses and pairs of fragments. For losses nl 1 , nl 2 , we distinguish between size-dependent positive match scores σ (nl,nl) := 5 + number of non-hydrogen atoms and size-dependent negative mismatch scores σ (nl 1 ,nl 2 ) := −5 number of different non-hydrogen atoms. For fragments f 1 , f 2 , we use size-dependent positive match scores σ (f ,f ) := 5 + number of non-hydrogen atoms and sizeindependent negative mismatch scores σ (f 1 ,f 2 ) := −3. We allow insertion/deletions, as well as joining two subsequent losses, both without penalty. The idea behind this ad hoc scoring is to reward or penalize large losses stronger than small losses, whereas nonmatching fragments are penalized independent of size. See Rasche et al. (2012) for details. We implemented the DP algorithms in Java 1.6. For the sparse DP, we used lazy arrays to store the DP tables. We solved the ILP via branch and cut using CPLEX 12.1 in its default settings. Computation was done on two different but comparable computers, namely on a quad-core 2.2 GHz AMD Opteron processor with 5 GB of main memory for the DP algorithms, and on a quad-core Intel Xeon E5520 with 2.27 GHz in 32-bit mode for the ILP, using 2 GB RAM per job. For the DP algorithms, we repeated computations five times, reporting the minimum running time for each instance. i270 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="7"> CONCLUSION Fragmentation trees are a tool to overcome the limitations of spectral library search, as they, for the first time, enable us to retrieve not only exact hits, but also similar compounds from a spectral database. But performing the workflows proposed by Rasche et al. (2012) on i271 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank Aleš Svatoš (MPI for Chemical Ecology, Jena, Germany), Masanori Arita (University of Tokyo, Japan) and David Grant and Dennis Hill (University of Connecticut, Storrs, USA) for providing the MS datasets.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Proof verification and the hardness of approximation problems</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Arora</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="501" to="555" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Sparse RNA folding: time and space efficient algorithms</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Backofen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="12" to="31" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Fourier meets Möbius: fast subset convolution</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Björklund</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM Symposium on Theory of Computing</title>
		<meeting>ACM Symposium on Theory of Computing<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="67" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Towards de novo identification of metabolites by analyzing tandem mass spectra</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Böcker</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Rasche</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of European Conference on Computational Biology</title>
		<meeting>European Conference on Computational Biology</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="49" to="55" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">On tree-constrained matchings and generalizations</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Canzar</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of International Conference on Automata, Languages and Programming</title>
		<meeting>International Conference on Automata, Languages and Programming<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="98" to="109" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Metabolite identification via the Madison Metabolomics Consortium Database</title>
		<author>
			<persName>
				<forename type="first">Q</forename>
				<surname>Cui</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="162" to="164" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Metabolite profiling: from diagnostics to systems biology</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">R</forename>
				<surname>Fernie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Mol. Cell Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="763" to="769" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Extending the breadth of metabolite profiling by gas chromatography coupled to mass spectrometry</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Fiehn</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trends Analyt. Chem</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="261" to="269" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Chemical derivatization and mass spectral libraries in metabolic profiling by</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">M</forename>
				<surname>Halket</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Exp. Bot</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="page" from="219" to="243" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Hopscotch hashing</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Herlihy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Symposium on Distributed Computing</title>
		<meeting>Symposium on Distributed Computing<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="350" to="364" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Mass spectral metabonomics beyond elemental formula: chemical database querying by matching experimental with computational fragmentation spectra</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">W</forename>
				<surname>Hill</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Anal. Chem</title>
		<imprint>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="page" from="5574" to="5582" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">MassBank: a public repository for sharing mass spectral data for life sciences</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Horai</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mass Spectrom</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="703" to="714" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Alignment of trees: an alternative to tree edit</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">143</biblScope>
			<biblScope unit="page" from="137" to="148" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Towards the plant metabolome and beyond</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">L</forename>
				<surname>Last</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Mol. Cell Biol</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="167" to="174" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Topological mapping of organic molecules</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Lederberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci. USA</title>
		<meeting>. Natl. Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="1965" />
			<biblScope unit="page" from="134" to="139" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Tree graphs of RNA secondary structures and their comparisons</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">Y</forename>
				<surname>Le</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Biomed. Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="461" to="473" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<monogr>
		<title level="m" type="main">Drug discovery and natural products: end of an era or an endless frontier? Science</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">W</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">C</forename>
				<surname>Vederas</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="161" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Solving the prize-collecting steiner tree problem to optimality</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Ljubi´cljubi´c</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Algorithm Engineering and Experiments (ALENEX 2005), SIAM</title>
		<meeting>Algorithm Engineering and Experiments (ALENEX 2005), SIAM</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="68" to="76" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Computational mass spectrometry for metabolomics – a review</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Neumann</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Böcker</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Anal. Bioanal. Chem</title>
		<imprint>
			<biblScope unit="volume">398</biblScope>
			<biblScope unit="page" from="2779" to="2788" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">On the inter-instrument and inter-laboratory transferability of a tandem mass spectral reference library: 1. results of an Austrian multicenter study</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Oberacher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mass Spectrom</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="485" to="493" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Cuckoo hashing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Pagh</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<forename type="middle">F</forename>
				<surname>Rodler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="122" to="144" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Computing fragmentation trees from tandem mass spectrometry data</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Rasche</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Anal. Chem</title>
		<imprint>
			<biblScope unit="volume">83</biblScope>
			<biblScope unit="page" from="1243" to="1251" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Identifying the unknowns by aligning fragmentation trees</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Rasche</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Anal. Chem</title>
		<imprint>
			<biblScope unit="volume">84</biblScope>
			<biblScope unit="page" from="3417" to="3426" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Finding maximum colorful subtrees in practice</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Rauf</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Research in Computational Molecular Biology</title>
		<meeting>Research in Computational Molecular Biology<address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Computing fragmentation trees from metabolite multiple mass spectrometry data</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Scheubert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Research in Computational Molecular Biology</title>
		<meeting>Research in Computational Molecular Biology</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="377" to="391" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Revisiting the ancient concept of botanical therapeutics</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">M</forename>
				<surname>Schmidt</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Chem. Biol</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="360" to="366" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Dijkstra&apos;s algorithm revisited: the dynamic programming connexion</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Sniedovich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Control Cybern</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="599" to="620" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Mass spectrometry for the identification of the discriminating signals from metabolomics: current status and future trends</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Werner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Chromatogr. B</title>
		<imprint>
			<biblScope unit="volume">871</biblScope>
			<biblScope unit="page" from="143" to="163" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Some MAX SNP-hard results concerning unordered labeled trees</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="249" to="254" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">A constrained edit distance between unordered labeled trees</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="205" to="222" />
			<date type="published" when="1996-08-30" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>