
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:52+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Evolution of gene neighborhoods within reconciled phylogenies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Sèverine</forename>
								<surname>Bérard</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR AMAP</orgName>
								<orgName type="institution">Univ Montpellier2</orgName>
								<address>
									<postCode>F-34000</postCode>
									<settlement>Montpellier</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">LIRMM</orgName>
								<orgName type="institution" key="instit1">CNRS</orgName>
								<orgName type="institution" key="instit2">Univ Montpellier2</orgName>
								<address>
									<postCode>F-34392</postCode>
									<settlement>Montpellier</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Coralie</forename>
								<surname>Gallien</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">UMR AMAP</orgName>
								<orgName type="institution">Univ Montpellier2</orgName>
								<address>
									<postCode>F-34000</postCode>
									<settlement>Montpellier</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Bastien</forename>
								<surname>Boussau</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="laboratory" key="lab1">LBBE</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5558</orgName>
								<orgName type="institution">Université de Lyon 1</orgName>
								<address>
									<postCode>F-69622</postCode>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Department of Integrative Biology</orgName>
								<address>
									<addrLine>UC Berkeley 4163A Valley Life Sciences Bldg Berkeley</addrLine>
									<postCode>94720-3140</postCode>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Gergely</forename>
								<forename type="middle">J</forename>
								<surname>Szöll</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">˝</forename>
								<surname>Osi</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="laboratory" key="lab1">LBBE</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5558</orgName>
								<orgName type="institution">Université de Lyon 1</orgName>
								<address>
									<postCode>F-69622</postCode>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Vincent</forename>
								<surname>Daubin</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="laboratory" key="lab1">LBBE</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5558</orgName>
								<orgName type="institution">Université de Lyon 1</orgName>
								<address>
									<postCode>F-69622</postCode>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Eric</forename>
								<surname>Tannier</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="laboratory" key="lab1">LBBE</orgName>
								<orgName type="laboratory" key="lab2">UMR CNRS 5558</orgName>
								<orgName type="institution">Université de Lyon 1</orgName>
								<address>
									<postCode>F-69622</postCode>
									<settlement>Villeurbanne</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="institution">INRIA Rhône-Alpes</orgName>
								<address>
									<postCode>F-38322</postCode>
									<settlement>Montbonnot</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Evolution of gene neighborhoods within reconciled phylogenies</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="382" to="388"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts374</idno>
					<note>Copyedited by: MANUSCRIPT CATEGORY: [17:52 9/8/2012 Bioinformatics-bts374.tex] Page: i382 i382–i388 BIOINFORMATICS Contact: Severine.Berard@cirad.frorEric.Tannier@inria.fr Supplementary information: Supplementary material is available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Most models of genome evolution integrating gene duplications, losses and chromosomal rearrangements are computa-tionally intractable, even when comparing only two genomes. This prevents large-scale studies that consider different types of genome structural variations. Results: We define an &apos;adjacency phylogenetic tree&apos; that describes the evolution of an adjacency, a neighborhood relation between two genes, by speciation, duplication or loss of one or both genes, and rearrangement. We describe an algorithm that, given a species tree and a set of gene trees where the leaves are connected by adjacencies, computes an adjacency forest that minimizes the number of gains and breakages of adjacencies (caused by rearrangements) and runs in polynomial time. We use this algorithm to reconstruct contiguous regions of mammalian and plant ancestral genomes in a few minutes for a dozen species and several thousand genes. We show that this method yields reduced conflict between ancestral adjacencies. We detect duplications involving several genes and compare the different modes of evolution between phyla and among lineages. Availability: C++ implementation using BIO++ package, available upon request to Sèverine Bérard.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>A phylogenetic tree describes the kin relationships between a set of homologous objects. Non-homologous objects may have other types of relationships, such as interactions, functional relationships, co-expression or neighborhood between genes. Studying the pattern of descent of these relationships can be used to define homology between them, reconstruct ancestral relationships and build phylogenetic trees. The evolution of gene proximity or interaction has been the subject of numerous recent studies. It is for example a way to assess co-evolution between genes, even if often co-evolution is detected by searching for similarities in gene trees, but without modeling explicitly the relation that make the genes co-evolve (<ref type="bibr" target="#b19">Rodionov et al., 2011;</ref><ref type="bibr" target="#b23">Tuller et al., 2010</ref>). Closer to our study, (<ref type="bibr" target="#b17">Pinney et al., 2007</ref>) and (<ref type="bibr" target="#b7">Dutkowski and Tiuryn, 2009</ref>) or (<ref type="bibr" target="#b13">Ma et al., 2008</ref>) propose methods to reconstruct * To whom correspondence should be addressed. ancestral protein–protein interactions or gene neighborhoods based on a model of evolution allowing gene duplications. They, however, assume that the chronology of duplications is known, which often is not the case. (<ref type="bibr" target="#b16">Patro et al., 2011</ref>) define a general problem of network evolution without this assumption and give a heuristic solution for the comparison of two species. Our model considers the more specific problem of gene neighborhoods on chromosomes, but generalizes (<ref type="bibr" target="#b16">Patro et al., 2011</ref>)'s method in that it handles an arbitrary number of species and provides an exact solution to a less constrained problem. Several methods are aimed at building ancestral chromosomes (which can be seen as relationships between genes). Most of these methods, however, ignore duplications and losses and are limited to gene families which have exactly one representative in each studied species (<ref type="bibr" target="#b0">Alekseyev and Pevzner, 2009;</ref><ref type="bibr" target="#b3">Chauve and Tannier, 2008;</ref><ref type="bibr" target="#b4">Chauve et al., 2010;</ref><ref type="bibr" target="#b12">Ma et al., 2006;</ref><ref type="bibr" target="#b15">Ouangraoua et al., 2011</ref>). The number of such gene families becomes smaller and smaller as the number of species grows. Some methods take as input gene trees allowing duplications and losses (<ref type="bibr" target="#b11">Lajoie et al., 2010;</ref><ref type="bibr" target="#b14">Muffato et al., 2010</ref>) but do not model these events and treat them as noise that is removed for the construction of chromosomes by traveling salesman-like optimization methods. (<ref type="bibr" target="#b4">Chauve et al., 2010</ref>), (<ref type="bibr" target="#b15">Ouangraoua et al., 2011</ref>) or (<ref type="bibr" target="#b25">Zheng and Sankoff, 2011</ref>) model duplications only in the context of whole genome duplications. Here, we propose a method that takes a species tree and a set of gene trees as inputs, and models the gain and breakage of gene adjacencies along a pair of trees, taking duplications and losses into account. We consider two genes to be 'adjacent' if they are on the same chromosome in the same genome and no other gene is located between the two. We give an exact polynomial algorithm which minimizes the number of gains and breakages of adjacencies, or more generally, the gain/breakage cost of an evolutionary scenario for gene adjacencies. The result consists of sets of 'adjacency trees', which are phylogenetic trees describing the evolution of a family of homologous adjacencies (adjacencies that share a common ancestor and derived from it). We assume that adjacencies evolve independently from each other, so we do not model the rearrangement explicitly (inversions, translocations etc.), but model their effect on adjacencies, which thus can undergo gains and breakages. Doing this, we solve a problem that fits in the methodological program started by (<ref type="bibr" target="#b21">Sankoff and El-Mabrouk, 2000</ref>), which mixes rearrangements and reconciliations of phylogenetic trees (a reconciliation is an annotation of gene tree nodes by duplication or speciation events, according to a species tree). Algorithmically, the dynamic programming principle we use generalizes the Sankoff–Fitch (<ref type="bibr" target="#b9">Fitch, 1971;</ref><ref type="bibr" target="#b20">Sankoff, 1975)</ref>Copyedited by:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evolution of gene neighborhoods</head><p>parsimony algorithms on binary alphabets. Indeed, when there are no duplications nor losses in gene trees, adjacencies may be described by a binary character (presence or absence in a genome) evolving along the species tree, as in (<ref type="bibr" target="#b22">Tang and Wang, 2005</ref>) or (<ref type="bibr" target="#b8">Feijao and Meidanis, 2011</ref>). In our case, there is also a binary character (presence or absence of an adjacency), but evolving along pairs of reconciled gene trees. The description of the method requires that we formally introduce the three kinds of trees we handle (species, gene and adjacency trees), as well as the definition of the optimization problem we propose (Section 2). We detail some properties of the solutions, pointing at the possible advantages and drawbacks of this approach in Section 3. Then in Section 4, we describe the algorithm which solves the problem. Proofs are provided in the Supplementary Material. We implemented the algorithm and applied it to mammalian and plant genomes. We show that compared with other methods not explicitly modelling evolutionary events, we have more precise and less erroneous views at ancestral genome organization (Section 5). In addition, we are able to detect segmental duplications including several genes, and to visualize how much the modes of evolution are different according to the considered clades or lineages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">MODEL</head><p>All the trees in this article have one or more vertices, they are rooted and have maximum degree 3. A tree T induces a partial order on its nodes, where descendants are lower than ancestors. For a tree T , V (T ) denotes its vertex set and L(T ) is leaf set (vertices with no descendants, L(T ) ⊆ V (T )). For a node N of T , T (N ) is the subtree of T rooted at N. P(N ) is the parent of N (it is defined only if N is not the root). L(N ) is the set of leaves of T (N ). We consider all trees to be annotated, which means here that each node N of a tree is labeled by @BULLET A type of event E(N ). @BULLET A species S(N ). The events E(N ) are taken from {Extant,<ref type="bibr">Spec, GDup, GLos, ADup, ALos, Break}.</ref>These are abbreviations for 'Extant', 'Speciation', 'Gene duplication', 'Gene loss', 'Adjacency duplication', 'Adjacency loss' and 'Adjacency breakage'. Together with the 'Adjacency Gain' (abbreviated Gain, which never labels the nodes of the trees as there is exactly one gain per adjacency tree), they are all the evolutionary events we consider. 1 Note that ALos means the loss of an adjacency due to the concurrent loss of the two involved genes, while Break means the loss of an adjacency due to a rearrangement. In the objective function we only take Gain and Break into account, so both are given a cost C(Gain) and C(Break). All trees depend on a set of extant genomes, which are disjoint sets of genes plus binary relations on these sets of genes called 'adjacencies'. The two genes of an adjacency are called its 'extremities'. There are three types of trees (illustrated in<ref type="figure" target="#fig_0">Fig. 1</ref>), which have the following properties.</p><p>(1) A species tree T S describes the diversification of species. It is binary, and verifies E(N ) = Spec for all internal node N and, two gene trees (middle) and an adjacency tree (right). Blue dots are speciation nodes. Leaves are extant (species, genes, adjacencies), except the one labeled by a red cross (gene loss) or a red flash (breakage). Green squares are (gene or adjacency) duplication nodes. Gene labels refer to the species they belong to. Every node of the adjacency tree is labeled by a couple of nodes from gene trees E(N ) = Extant for all leaves N. All S(N ) are distinct species and if N is an internal node, S(N ) defines an ancestral species.</p><p>(2) A gene tree T G describes the evolution of a family of homologous genes along a species tree T S. All gene trees here are 'reconciled' with the 'LCA (Last Common Ancestor) reconciliation' (<ref type="bibr" target="#b10">Goodman et al., 1979</ref>) where all gene losses are represented by leaves, which means every node N verifies:</p><p>@BULLET If N is a leaf, then E(N ) ∈{Extant,GLos}, and if N is an internal node, then E(N ) ∈{Spec,GDup}.</p><p>@BULLET If E(N ) = Extant, then there is a gene G(N ) that belongs to S(N ) and all such genes are distinct. @BULLET If E(N ) = GDup then the children N 1 and N 2 of N are such that S(N 1) = S(N 2) = S(N )</p><p>@BULLET If E(N ) = Spec then the children N 1 and N 2 of N are such that there are two edges AA1 and AA2 of T S such that P(</p><formula>A1) = P(A2) = A and S(N ) = S(A), S(A1) = S(N 1), and S(A2) = S(N 2).</formula><p>@BULLET Let L be the set of leaves of T G (N ); Let S(L) be the set of all extant species which are descendants of some S(l), l ∈ L; Let now N S be the lowest node in T S such that S(L)</p><formula>⊆∪ l∈L(N S ) S(l); Then, S(N ) = S(N S ).</formula><p>(3) An adjacency tree T A describes the descent pattern of adjacencies. As adjacencies are pairs of genes, they follow the evolution of genes: if an adjacency AB descents from an adjacency CD, then A descents from C and B from D. So adjacency trees are defined given a set of reconciliated gene trees T G and have to follow their LCA reconciliations. Formally, every node N of an adjacency tree verifies @BULLET If N is a leaf, then E(N ) ∈{Extant,GLos,ALos,Break} and if N is an internal node, then E(N ) ∈ {Spec,GDup,ADup} @BULLET If E(N ) = Break, then there is a couple A(N ) = XY of gene tree nodes X and Y (possibly from two different gene trees) such that S(</p><formula>N ) = S(X ) = S(Y ). @BULLET If E(N ) = Extant, then G(X )G(Y ) is an adjacency. @BULLET If E(N ) = GLos, then E(X ) = GLos or E(Y ) = GLos (and not both). @BULLET If E(N ) = ALos, then E(X ) = E(Y ) = GLos. @BULLET If E(N ) = Spec, then E(X ) = E(Y ) = E(N )</formula><p>. In addition, N has two children N 1 and N 2 and either E(N 1) = Break</p><formula>(respectively, E(N 2) = Break)) or A(N 1) (respectively, A(N 2)</formula><p>) is a couple of children of X and Y .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i383</head><formula>@BULLET If E(N ) = ADup, then E(X ) = E(Y ) = GDup.</formula><p>In addition, N has two children N 1 and N 2 either E(N 1) = Break</p><formula>(respectively, E(N 2) = Break)) or A(N 1) (respectively, A(N 2)</formula><p>) is a couple of children of X and Y .</p><p>@BULLET If E(N ) = GDup, then E(X ) = GDup or E(Y ) = GDup (suppose it is Y ). In addition, N has only one child N 1 and either E(N 1) = Break or A(N 1) is a couple of genes composed of X and one child of Y .</p><p>An 'adjacency forest' is a set of adjacency trees, such that for two nodes N 1 and N 2 in this forest, A(N 1) = A(N 2), and such that for each adjacency A from any species, there exists a leaf L in the forest, which verifies A(L) = A. The cost of an adjacency tree T A , is</p><formula>C(T A ) =|{v ∈ V (T A ),E(v) = Break}| * C(Break)+Gain(T A ),</formula><p>where Gain(T A</p><p>) is computed in this way: if the root R of T A is such that A(R) = XY and either</p><formula>@BULLET P(X ) = P(Y ) or</formula><p>@BULLET X is the root of a gene tree, and either Y is also a root, or</p><formula>S(P(Y )) = S(Y )</formula><p>then Gain(T A ) = 0, else Gain(T A ) = C(Gain). The cases where Gain(T A ) = 0 are those arising from tandem duplications or those where the adjacency can have been gained earlier in the evolution. The cost of an adjacency forest is the sum of the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PROPERTIES</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The cost of a duplication or loss event</head><p>The optimization focuses only on breaks and gains of adjacencies. The dynamic programming technique we use does not allow to count duplication and loss events in the objective function. This is because we make the hypothesis of independent evolution of couples of genes, and as long as one gene has its own events and belongs to several couples, this independence is broken. Nevertheless, duplication events have an importance for the solutions. The duplication of an adjacency has the same cost as the independent duplication of two genes, but the events can still be discriminated because the two do not have the same effect: the independent duplications propagate only one adjacency, and the joint duplication propagates two. It is thus possible to catch the places where a joint duplication is advantageous in terms of gains and breaks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The linearity of genomes</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The chronology of duplications</head><p>No chronology of duplications is required in the input as in (<ref type="bibr" target="#b17">Pinney et al., 2007</ref>), (<ref type="bibr" target="#b7">Dutkowski and Tiuryn, 2009</ref>) or (<ref type="bibr" target="#b13">Ma et al., 2008</ref>). But a chronology can be derived from the output. Indeed an adjacency duplication means that two genes are duplicated together, while two nodes of an adjacency tree such that one is the descendant of the other and both are gene duplication events define a directed relation between the two duplications, even if they are not comparable from the gene trees (not in the same tree or not comparable in one tree). But this relation is not necessarily an order relation. There are examples where temporal relationships defined by adjacency trees contradict the partial order of the nodes of one gene tree: see such an example in<ref type="figure" target="#fig_0">Figure S1</ref>in Supplementary Material. (<ref type="bibr" target="#b16">Patro et al., 2011</ref>) proscribe this kind of conflict and propose a heuristic principle to get rid of it when it happens.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Tandem duplications</head><p>Tandem duplications are special types of duplications, where the two duplicates are adjacent. Here, tandem duplications are not modeled explicitly as a different event from ordinary duplications. However, tandem duplications of one gene are indirectly taken into account: they cost zero (as the gain of an adjacency between two children of a duplication node is costless; see Section 2), while a non-tandem duplication of one gene can cost one breakage plus two gains when one duplicate is inserted between two other genes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">The orientations of the genes</head><p>It is possible to take the orientation of the genes into account by duplicating each gene into two gene extremities and define adjacencies as relations between gene extremities instead of genes (the extremities of an adjacency are gene extremities in that case). The current implementation can be used in this way, it is just a matter of formatting the input. In this case, one gene extremity is supposed to participate in only one adjacency, and tandem duplications are not handled anymore, because there are no duplications of only one gene extremity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evolution of gene neighborhoods</head><p>2a). if G1 = G2, then there are two nodes N 1 ∈ G1,N 2 ∈ G2 such that S(N 1) = S(N 2) and A and C are descendants of N 1, while B and D are descendants of N 2. 2b). if G1 = G2, then the lowest common ancestor of A and B is the same node as the lowest common ancestor of C and D (it is necessarily a duplication node). This relation between adjacencies satisfying all conditions is an equivalence relation (reflexive, symmetric and transitive). Equivalence classes are treated independently. This is justified by the following lemma, whose proof stands in the Supplementary Material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 1. If there is a tree of adjacencies which contains adjacencies AB and CD, then AB and CD are in the same equivalence class.</head><p>In other words, if AB and CD are not in the same class they cannot be homologous. The converse is not true however. Solutions for one class may consist of several adjacency trees. This clustering allows to divide the problem into equivalence classes, which concern one or two gene trees. If in an equivalence class, adjacencies have extremities in the same tree, by definition of the classes, there is a common ancestor to all pairs of extremities of adjacencies. By removing this vertex, we get two trees rooted at its children, and all adjacencies have one extremity in each of these two trees. So we may restrict ourselves to this case where we have exactly two gene trees and all adjacencies are between these two trees. Moreover, we may suppose that each tree is rooted at the lowest common ancestor of all genes involved in adjacencies of the chosen class, because we may simply consider the subtree rooted at this vertex. This yields that the two roots are necessarily assigned to the same species.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Recurrence formulas</head><p>Formally, we have two gene trees T 1 G and T 2 G , extant adjacencies have one extremity in each tree, and if R 1 and R 2 are the respective roots of</p><formula>T 1 G and T 2 G , then S(R 1 ) = S(R 2 ). For a pair of nodes (v 1 ,v 2 ) ∈ V (T 1 G )×V (T 2 G ) such that S(v 1 ) = S(v 2 )</formula><p>, we compute two values, c 1 (v 1 ,v 2 ) and c 0 (v 1 ,v 2 ) by recurrence formulas described in the sequel. Remark that we only consider pairs of nodes annotated with the same species because an adjacency is always linking genes from the same genome. We prove that these numbers have the following properties (proofs are in the Supplementary Material, Appendix 2).In consequence, the minimum cost of an adjacency forest will be given by computing the minimum between</p><formula>c 1 (R 1 ,R 2 ) and c 0 (R 1 ,R 2 ).</formula><p>The recurrence for the computation of c 1 (v 1 ,v 2 ) and c 0 (v 1 ,v 2 ) follows a case analysis, according to the type of event associated to v 1 and v 2. The roles of v 1 and v 2 are symmetrical. We note ca(v) and cb(v) the two children of a node v.</p><formula>c 1 (v 1 ,v 2 ) = min ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ c 1 (ca(v 1 ),ca(v 2 ))+c 1 (cb(v 1 ),cb(v 2 )) c 1 (ca(v 1 ),ca(v 2 ))+c 0 (cb(v 1 ),cb(v 2 ))+C(Break) c 0 (ca(v 1 ),ca(v 2 ))+c 1 (cb(v 1 ),cb(v 2 ))+C(Break) c 0 (ca(v 1 ),ca(v 2 ))+c 0 (cb(v 1 ),cb(v 2 ))+2 * C(Break) c 0 (v 1 ,v 2 ) = min ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ c 0 (ca(v 1 ),ca(v 2 ))+c 0 (cb(v 1 ),cb(v 2 )) c 1 (ca(v 1 ),ca(v 2 ))+c 0 (cb(v 1 ),cb(v 2 ))+C(Gain) c 0 (ca(v 1 ),ca(v 2 ))+c 1 (cb(v 1 ),cb(v 2 ))+C(Gain) c 1 (ca(v 1 ),ca(v 2 ))+c 1 (cb(v 1 ),cb(v 2 ))+2 * C(Gain)</formula><formula>Case 6. E(v 1 ) = GDup and E(v 2 ) = GDup. In this case c 1 (v 1 ,v 2 ) = min(D1,D2,D12)</formula><p>where D1 is the cost in the case the v 1 duplication comes first, D2 is the cost in the case the v 2 duplication comes first, D12 is the cost in the case where the v 1 and v 2 duplications are simultaneous.</p><formula>D1 = min ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ c 1 (ca(v 1 ),v 2 )+c 0 (cb(v 1 ),v 2 ) c 0 (ca(v 1 ),v 2 )+c 1 (cb(v 1 ),v 2 ) c 1 (ca(v 1 ),v 2 )+c 1 (cb(v 1 ),v 2 )+C(Gain) c 0 (ca(v 1 ),v 2 )+c 0 (cb(v 1 ),v 2 )+C(Break) D2 = min ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ c 1 (v 1 ,ca(v 2 ))+c 0 (v 1 ,cb(v 2 )) c 0 (v 1 ,ca(v 2 ))+c 1 (v 1 ,cb(v 2 )) c 1 (v 1 ,ca(v 2 ))+c 1 (v 1 ,cb(v 2 ))+C(Gain) c 0 (v 1 ,ca(v 2 ))+c 0 (v 1 ,cb(v 2 ))</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S.Bérard et al.</head><formula>⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩ (1) c 1 (ca(v 1 ),ca(v 2 )) + c 1 (cb(v 1 ),cb(v 2 )) + c 0 (ca(v 1 ),cb(v 2 )) + c 0 (cb(v 1 ),ca(v 2 )) (2) c 1 (ca(v 1 ),ca(v 2 )) + c 1 (cb(v 1 ),cb(v 2 )) + c 0 (ca(v 1 ),cb(v 2 )) + c 1 (cb(v 1 ),ca(v 2 )) + C(Gain) (3) c 1 (ca(v 1 ),ca(v 2 )) + c 1 (cb(v 1 ),cb(v 2 )) + c 1 (ca(v 1 ),cb(v 2 )) + c 0 (cb(v 1 ),ca(v 2 )) + C(Gain)</formula><formula>(4) c 1 (ca(v 1 ),ca(v 2 )) + c 1 (cb(v 1 ),cb(v 2 )) + c 1 (ca(v 1 ),cb(v 2 )) + c 1 (cb(v 1 ),ca(v 2 )) + 2 * C(Gain) (5) c 1 (ca(v 1 ),ca(v 2 )) + c 0 (cb(v 1 ),cb(v 2 )) + c 0 (ca(v 1 ),cb(v 2 )) + c 0 (cb(v 1 ),ca(v 2 )) + C(Break)</formula><formula>(6) c 1 (ca(v 1 ),ca(v 2 )) + c 0 (cb(v 1 ),cb(v 2 )) + c 0 (ca(v 1 ),cb(v 2 )) + c 1 (cb(v 1 ),ca(v 2 )) + C(Gain) + C(Break)</formula><formula>(7) c 1 (ca(v 1 ),ca(v 2 )) + c 0 (cb(v 1 ),cb(v 2 )) + c 1 (ca(v 1 ),cb(v 2 )) + c 0 (cb(v 1 ),ca(v 2 )) + C(Gain) + C(Break)</formula><formula>(8) c 0 (ca(v 1 ),ca(v 2 )) + c 1 (cb(v 1 ),cb(v 2 )) + c 0 (ca(v 1 ),cb(v 2 )) + c 0 (cb(v 1 ),ca(v 2 )) + C(Break)</formula><formula>(9) c 0 (ca(v 1 ),ca(v 2 )) + c 1 (cb(v 1 ),cb(v 2 )) + c 0 (ca(v 1 ),cb(v 2 )) + c 1 (cb(v 1 ),ca(v 2 )) + C(Gain) + C(Break)</formula><formula>(10) c 0 (ca(v 1 ),ca(v 2 )) + c 1 (cb(v 1 ),cb(v 2 )) + c 1 (ca(v 1 ),cb(v 2 )) + c 0 (cb(v 1 ),ca(v 2 )) + C(Gain) + C(Break)</formula><formula>(11) c 0 (ca(v 1 ),ca(v 2 )) + c 0 (cb(v 1 ),cb(v 2 )) + c 1 (ca(v 1 ),cb(v 2 )) + c 1 (cb(v 1 ),ca(v 2 )) (12) c 0 (ca(v 1 ),ca(v 2 )) + c 1 (cb(v 1 ),cb(v 2 )) + c 1 (ca(v 1 ),cb(v 2 )) + c 1 (cb(v 1 ),ca(v 2 )) + C(Gain)</formula><formula>(13) c 1 (ca(v 1 ),ca(v 2 )) + c 0 (cb(v 1 ),cb(v 2 )) + c 1 (ca(v 1 ),cb(v 2 )) + c 1 (cb(v 1 ),ca(v 2 )) + C(Gain)</formula><formula>(14) c 0 (ca(v 1 ),ca(v 2 )) + c 0 (cb(v 1 ),cb(v 2 )) + c 1 (ca(v 1 ),cb(v 2 )) + c 0 (cb(v 1 ),ca(v 2 )) + C(Break)</formula><formula>(15) c 0 (ca(v 1 ),ca(v 2 )) + c 0 (cb(v 1 ),cb(v 2 )) + c 0 (ca(v 1 ),cb(v 2 )) + c 1 (cb(v 1 ),ca(v 2 )) + C(Break)</formula><formula>(16) c 0 (ca(v 1 ),ca(v 2 )) + c 0 (cb(v 1 ),cb(v 2 )) + c 0 (ca(v 1 ),cb(v 2 )) + c 0 (cb(v 1 ),ca(v 2 )) + 2 * C(Break) c 0 (v 1 ,v 2 ) = min ⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩</formula><p>Cases where the v 1 duplication comes first</p><formula>c 0 (ca(v 1 ),v 2 )+c 0 (cb(v 1 ),v 2 ) c 0 (ca(v 1 ),v 2 )+c 1 (cb(v 1 ),v 2 )+C(Gain) c 1 (ca(v 1 ),v 2 )+c 0 (cb(v 1 ),v 2 )+C(Gain) c 1 (ca(v 1 ),v 2 )+c 1 (cb(v 1 ),v 2 )+2 * C(Gain) Cases where the v 2 duplication comes first c 0 (v 1 ,ca(v 2 ))+c 0 (v 1 ,cb(v 2 )) c 0 (v 1 ,ca(v 2 ))+c 1 (v 1 ,cb(v 2 ))+C(Gain) c 1 (v 1 ,ca(v 2 ))+c 0 (v 1 ,cb(v 2 ))+C(Gain) c 1 (v 1 ,ca(v 2 ))+c 1 (v 1 ,cb(v 2 ))+2 * C(Gain)</formula><p>We do not examine the case E(</p><formula>v 1 ) = Extant and E(v 2 ) = Spec because in this case S(v 1 ) = S(v 2 ).</formula><p>The algorithm implements these recurrence formulas in an iterative way following a dynamic programming technique, by computing the costs in a post-order traversal of the couples of tree nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Backtracking</head><p>The recurrence formulas allow the construction of a cost matrix which rows are the nodes of the first gene tree, and columns are the nodes of the second gene tree. The nodes of the adjacency forest are constructed while backtracking on the cost matrix starting at min</p><formula>(c 1 (R 1 ,R 2 ),c 0 (R 1 ,R 2 )</formula><p>). The backtracking procedure classically follows each cost on the chosen line in the recurrence formulas, creating adjacency trees from root to leaves. A node N with A(N ) = v 1 v 2 is created each time c 1 (v 1 ,v 2 ) is chosen. The event labeling this node depends on the events labeling v 1 and v 2 : Extant for Case 1, GLos for Case 2, ALos for Case 3, GDup for Cases 4 and 6. (D1&amp;D2), Spec for Case 5 and ADup for Case 6 (D12). A node N with E(N ) = Break is created each time there is a C(Break) in the chosen formula. Edges between the nodes follow the pattern of descent between adjacencies: @BULLET Break nodes are leaves, and their parent are the nodes constructed in the formula where C(Break) occurs; @BULLET In Cases 4 and 6 (D1&amp;D2), there is an edge between v 1 v 2 and one of</p><formula>v 1 ca(v 2 ), v 1 cb(v 2 ), ca(v 1 )v 2 , cb(v 1 )v 2 , if c 1</formula><p>is chosen for either of them. @BULLET In Cases 5 and 6 (D12), there is an edge between v 1 v 2 and one or two of ca(</p><formula>v 1 )ca(v 2 ), cb(v 1 )cb(v 2 ), cb(v 1 )ca(v 2 ), ca(v 1 )cb(v 2</formula><p>) if c 1 is chosen for either of them (there can be arbitrary choices for equivalent solutions). Recurrence formulas imply that the backtracking procedure does not create twice the same node: each formula computes the cost for v 1 v 2 between pairs of nodes where at least one is a descendant of v 1 or v 2. An example of an algorithm input and output is drawn on<ref type="figure" target="#fig_5">Figure 2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Complexity</head><p>The algorithm takes as input a dataset composed by a species tree, several gene trees and a list of adjacencies. It first computes the equivalence classes of adjacencies. Then for each class it constructs two subtrees to compute c 0 and c 1 costs on their roots and applies the backtracking procedure. The algorithm outputs the adjacency forest resulting from the union of all adjacency forests built on each class. Let n be the number of gene trees and k be the maximum size of a tree. The algorithm runs in O(n 2 ×k 2 ). Indeed, the maximum number of adjacency equivalence classes is bounded by O(n 2 ), while for each equivalence class, every couple of node is examined with a constant-time case analysis. In practice, the number of equivalence classes is much closer to n than to n 2 and trees are small compared with the total number of genes. For all datasets we tested, including dozens of species and thousand of genes, the execution time was under 10 min.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">IMPLEMENTATION AND APPLICATION</head><p>We implemented the algorithm using the Bio++ platform (<ref type="bibr" target="#b6">Dutheil et al., 2006</ref>). The program, named DeCo (Detection of Co-evolution or DeCoration of trees), takes as input a species tree, a set of genes along with the species they are in, a set of adjacencies and a set of gene trees. We tested it on four datasets, with costs C(Gain) = C(Break) = 1. The first and second datasets are based on 5039 gene trees from the Ensembl database (release 57) restricted to mammalian assembled genomes (11 species). 2 The first set of trees are those provided in this</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evolution of gene neighborhoods</head><formula>C(Gain) = C(Break) = 1. All the costs c b (E i ,E j ) are computed for b ∈ 0,1, E ∈ A,B,C, i,j ∈[1..8], with E i in G 1 and E j in G 2. As a result c 0 (C 5 ,C 8 ) = 2 while c 1 (C 5 ,C 8 ) = 1.</formula><p>Therefore, the adjacency forest on the line Output contains C 5 C 8. The left tree has cost 0 while the right one costs C(Gain) = 1 for the gain of the adjacency B 1 B 3 database, made according to the TreeBeST pipeline (<ref type="bibr" target="#b24">Vilella et al., 2009</ref>). The second consists of the trees reconstructed by the PhylDog method (<ref type="bibr" target="#b2">Boussau et al., 2012</ref>), with an explicit model of duplication and losses of trees. Both sets of trees were reconciled according to the LCA method (<ref type="bibr" target="#b10">Goodman et al., 1979</ref>), which gives gene trees with the properties written in Section 2). Then, we computed ancestral adjacencies according to the method described here, and compared with the 'pairwise alternative', an implementation of the principles used by (<ref type="bibr" target="#b3">Chauve and Tannier, 2008</ref>), (<ref type="bibr" target="#b14">Muffato et al., 2010</ref>), (<ref type="bibr" target="#b1">Bertrand et al., 2010</ref>) or (<ref type="bibr" target="#b2">Boussau et al., 2012</ref>), in which adjacencies are constructed by comparing couples of species (the method is described in the Supplementary Material, Appendix 3) instead of all genomes together. We computed the degree of each ancestral gene, that is, the number of adjacencies which has it as an extremity. As shown in<ref type="figure" target="#fig_6">Figure 3</ref>, most ancestral genes have degree 2, which means the signal of linearity of the ancestral genomes is recovered. We can observe the gain obtained by using PhylDog trees instead of TreeBeST trees (red plain versus blue dotted line), and the gain obtained by using DeCo instead of the pairwise alternative (red plain versus green dashed line). These two gains are nearly equivalent, showing that to get better ancestral genomes, we need good trees as well as good adjacency inference algorithms. Better trees tend to give a better estimate of the ancestral gene content, minimizing the degree 0 (probably wrong) genes, while the adjacency inference algorithm may minimize the number of genes with degree &gt;2: convergent evolution can yield false ancestral adjacencies, which add to the two true ones. Convergent evolution is impossible to handle in a pairwise method. The third and fourth datasets are constructed from the Ensembl (release 65) and EnsemblPlant (release 12) databases, restricted to some assembled mammalian (11 species, 19 217 gene trees ones, preventing the reconstruction of some ancestral adjacencies. It is possible to envisage branch specific costs, where unassembled genomes would have low breakage cost, and then could be used in a dataset.with an average of 10 genes) and angiosperm (9 genomes, 35 182 gene trees, with an average of 9 genes) species. We chose these two clades for a phylogenetic comparison because the estiated divergence times are similar, and there are approximatively as many assembled genomes in both. We compared the number of segmental duplications involving more than one gene in these two datasets. In<ref type="figure" target="#fig_8">Figure 4</ref>, phylogenetic trees of mammals and angiosperms are drawn, in which branch length is the number of pairs of genes duplicated together over the total number of ancestral genes found in the same branch. We find that on average branch lengths are more than three times longer in plants, indicating genome architectures rapidly evolving compared with slow mammalian ones. Angiosperm genomes have been shaped by several whole genome duplications: at the basis of monocots, a triplication at the basis of dicots, plus one event on the Maize and Poplar lineages, and two on the Arabidopsis one. These events probably create a long branch in Poplar, or Glycine, but are not always visible (e.g. in Arabidopsis) due to differentiated losses which blurred the synteny signal. The difference in branch length can partly be due to whole genome duplications. But measuring the average size of the duplicated segments by computing #GDup #GDup−#Adup . we found no significant difference between the two phyla (= 1.08 on average among all branches for both), indicating that the changes in genome architectures following a whole genome duplication are not fully accessible to this method. The long branch at the basis of eutheria would deserve more studies to know to which extend it is artifactual and due to the quality of gene trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">PERSPECTIVES</head><p>The algorithm can easily be extended to handle other relations than adjacencies (interactions, regulations, co-expression or any functional relation which can evolve by gain or breakage like adjacencies). It can be seen as even more adapted to less constrained relations (without a linear organization). Indeed, if a gene is lost, i387no adjacency is automatically and freely gained between its two neighbors in this model. But the computation time should be higher for other relations, as the possible number of relations is a quadratic function of the number of genes, while the number of adjacencies only grows linearly. Possible extensions can be to include transfers (<ref type="bibr" target="#b5">Doyon et al., 2011</ref>), incomplete lineage sorting or gene conversion (<ref type="bibr" target="#b18">Rasmussen and Kellis, 2012</ref>) to the possible events. And also to allow other types of reconciliations than the LCA one. More flexible cost functions for duplications may also be desirable, but in this case the independent evolution between adjacencies is lost, and the use of dynamic programming does not seem generalizable.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Examples of a species tree (left), two gene trees (middle) and an adjacency tree (right). Blue dots are speciation nodes. Leaves are extant (species, genes, adjacencies), except the one labeled by a red cross (gene loss) or a red flash (breakage). Green squares are (gene or adjacency) duplication nodes. Gene labels refer to the species they belong to. Every node of the adjacency tree is labeled by a couple of nodes from gene trees</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>.</head><figDesc>This case has to be distinguished from the previous one for the backtracking procedure described in the following subsection.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>+C(Break) D12 = min (over all 16 following cases) i385 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from Copyedited by: MANUSCRIPT CATEGORY: [17:52 9/8/2012 Bioinformatics-bts374.tex] Page: i386 i382–i388</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.2.</head><figDesc>Fig. 2. Example of the application of the algorithm on two genes trees, G 1 and G 2 , a species tree S and an adjacency list shown on the line Input. The costs are C(Gain) = C(Break) = 1. All the costs c b (E i ,E j ) are computed for b ∈ 0,1, E ∈ A,B,C, i,j ∈[1..8], with E i in G 1 and E j in G 2. As a result c 0 (C 5 ,C 8 ) = 2 while c 1 (C 5 ,C 8 ) = 1. Therefore, the adjacency forest on the line Output contains C 5 C 8. The left tree has cost 0 while the right one costs C(Gain) = 1 for the gain of the adjacency B 1 B 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.3.</head><figDesc>Fig. 3. Proportion of genes having k neighbors, function of k. Red plain line is obtained with DeCo and PhylDog trees. Green dashed line is obtained with PhylDog trees and the pairwise alternative. Blue dotted line is obtained with TreeBeST trees and DeCo</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.4.</head><figDesc>Fig. 4. Angiosperm and mammalian phylogenies, where branch lengths are proportional to the number of adjacency duplications normalized by the number of genes. The scale is indicated at the bottom left of the two figures</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Theorem 1. @BULLET c 1 (v 1 ,v 2 ) is the minimum cost of an adjacency forest F for the adjacencies between two gene trees T 1 G (v 1 ) and T 2 G (v 2 ), such that there is a node N in F with A(N ) = v 1 v 2. @BULLET c 0 (v 1 ,v 2 ) is the minimum cost of an adjacency forest F for the adjacencies between two gene trees T 1 G (v 1 ) and T 2 G (v 2 ), such that there is no node N in F with A(N ) = v 1 v 2 .</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Case 4. E(v 1 ) ∈{Extant,Spec} and E(v 2 ) = GDup. c 1 (v 1 ,v 2 ) = min ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ c 1 (v 1 ,ca(v 2 ))+c 0 (v 1 ,cb(v 2 )) c 0 (v 1 ,ca(v 2 ))+c 1 (v 1 ,cb(v 2 )) c 1 (v 1 ,ca(v 2 ))+c 1 (v 1 ,cb(v 2 ))+C(Gain) c 0 (v 1 ,ca(v 2 ))+c 0 (v 1 ,cb(v 2 ))+C(Break) c 0 (v 1 ,v 2 ) = min ⎧ ⎪ ⎪ ⎨ ⎪ ⎪ ⎩ c 0 (v 1 ,ca(v 2 ))+c 0 (v 1 ,cb(v 2 )) c 0 (v 1 ,ca(v 2 ))+c 1 (v 1 ,cb(v 2 ))+C(Gain) c 1 (v 1 ,ca(v 2 ))+c 0 (v 1 ,cb(v 2 ))+C(Gain) c 1 (v 1 ,ca(v 2 ))+c 1 (v 1 ,cb(v 2 ))+2 * C(Gain) Case 5. E(v 1 ) = Spec and E(v 2 ) = Spec. Suppose without loss of generality that S(ca(v 1 )) = S(ca(v 2 )) and S(cb(v 1 )) = S(cb(v 2 )).</figDesc><table></table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="1"> Even if &apos;Extant&apos; is not an evolutionary event, it is included because it annotates some tree leaves.</note>

			<note place="foot">In extant genomes, one gene can participate in at most two adjacencies. We have not required this property in the input of the program because it is not used, and in this way we could easily adapt the problem to other kinds of relationships. The drawback of this is that there is no need that in ancestral genomes, genes participate to at most two adjacencies. (Feijao and Meidanis, 2011) prove that in a duplication-free framework, where Fitch&apos;s algorithm is applied on the presence and absence of adjacencies, choosing the absence whenever there is a choice to make ensures that the resulting genomes are linear. When there are duplications, it is not necessarily the case and it can be seen in the data, where some conflicts remain. But as we will see in the last section, the amount of conflict is reduced compared with other kinds of algorithms, and can be used to assess the quality of the gene trees, as well as the quality of the model.</note>

			<note place="foot" n="4"> ALGORITHM 4.1 Restriction to two gene trees We first restrict the problem to the comparison of two gene trees, without loss of generality. To do this, the extant adjacencies are clustered according to the following relation between two distinct adjacencies AB and CD: 1). A and C are in the same gene tree, noted G1, as well as B and D, in a tree noted G2 (the roles of A and B and of C and D may be exchanged). i384 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="2"> The parsimony framework practically makes it necessary to work with only assembled genomes, since we would count to many breaks for unassembled i386 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">i388 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENT</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Breakpoint graphs and ancestral genome reconstructions</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">A</forename>
				<surname>Alekseyev</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="943" to="957" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Reconstruction of ancestral genome subject to whole genome duplication, speciation, rearrangement and loss</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Bertrand</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of WABI&apos;10</title>
		<meeting>WABI&apos;10<address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="78" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title level="m" type="main">Genome-scale coestimation of species and gene trees</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Boussau</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>in. revision</note>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">A methodological framework for the reconstruction of contiguous regions of ancestral genomes and its application to mammalian genomes</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Chauve</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Tannier</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Yeast ancestral genome reconstructions: the possibilities of computational methods II</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Chauve</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1097" to="1112" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">) Models, algorithms and programs for phylogeny reconciliation</title>
		<author>
			<persName>
				<forename type="first">J.-P</forename>
				<surname>Doyon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="392" to="400" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Bio++: a set of c++ libraries for sequence analysis, phylogenetics, molecular evolution and population genetics</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Dutheil</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">188</biblScope>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Phylogeny-guided interaction mapping in seven eukaryotes</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Dutkowski</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Tiuryn</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">393</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">SCJ: a breakpoint-like distance that simplifies several rearrangement problems</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Feijao</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Meidanis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comp. Biol. Bioinf</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="1318" to="1329" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Toward defining the course of evolution: minimum change for a specified tree topology</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">M</forename>
				<surname>Fitch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sys. Zool</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="406" to="416" />
			<date type="published" when="1971" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Fitting the gene lineage into its species lineage, a parsimony strategy illustrated by cladograms constructed from globin sequences</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Goodman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Zool</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="132" to="163" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Inferring the evolutionary history of gene clusters from phylogenetic and gene order data</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Lajoie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="761" to="772" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Reconstructing contiguous regions of an ancestral genome</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1557" to="1565" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Dupcar: reconstructing contiguous ancestral regions with duplications</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1007" to="1027" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Genomicus: a database and a browser to study gene synteny in modern and ancestral genomes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Muffato</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1119" to="1121" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Reconstructing the architecture of the ancestral amniote genome</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Ouangraoua</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2664" to="2671" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Parsimonious reconstruction of network evolution</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Patro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of WABI&apos;11</title>
		<meeting>WABI&apos;11</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page">237249</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Reconstruction of ancestral protein interaction networks for the bzip transcription factors</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">W</forename>
				<surname>Pinney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Aca. Sa. USA</title>
		<meeting>. Natl. Aca. Sa. USA</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="20449" to="20453" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Unified modeling of gene duplication, loss, and coalescence using a locus tree</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">D</forename>
				<surname>Rasmussen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kellis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="755" to="765" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">A new, fast algorithm for detecting protein coevolution using maximum compatible cliques</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Rodionov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">17</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Minimal mutation trees of sequences</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Sankoff</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page">35</biblScope>
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Duplication, rearrangement and reconciliation Comparative Genomics: Empirical and Analytical Approaches to Gene Order Dynamics, Map alignment and the Evolution of</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Sankoff</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>El-Mabrouk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">of Computational Biology</title>
		<editor>Sankoff, D. and Nadeau, J.H.</editor>
		<meeting><address><addrLine>Boston ; London</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer Academic Press Kluwer Academic publishers Dordrecht</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="537" to="550" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Improving genome rearrangement phylogeny using sequence-style parsimony</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Tang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings 5th IEEE Conference on Bioinformatics and Bioengineering (BIBE 2005)</title>
		<meeting>5th IEEE Conference on Bioinformatics and Bioengineering (BIBE 2005)</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="137" to="144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Reconstructing ancestral gene content by coevolution</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Tuller</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="122" to="132" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Ensemblcompara genetrees: Complete, duplication-aware phylogenetic trees in vertebrates</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">J</forename>
				<surname>Vilella</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="327" to="335" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">On the pathgroups approach to rapid small phylogeny</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Zheng</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Sankoff</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">4</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>Suppl. . 1</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>