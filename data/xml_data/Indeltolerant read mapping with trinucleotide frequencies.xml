
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:38+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Indel-tolerant read mapping with trinucleotide frequencies using cache-oblivious kd-trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Md</forename>
								<forename type="middle">Pavel</forename>
								<surname>Mahmud</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">John</forename>
								<surname>Wiedenhoeft</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alexander</forename>
								<surname>Schliep</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">BioMaPS Institute for Quantitative Biology</orgName>
								<orgName type="institution">Rutgers University</orgName>
								<address>
									<region>New Jersey</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Indel-tolerant read mapping with trinucleotide frequencies using cache-oblivious kd-trees</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="325" to="332"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts380</idno>
					<note>Copyedited by: S.K. MANUSCRIPT CATEGORY: ECCB [17:27 9/8/2012 Bioinformatics-bts380.tex] Page: i325 i325–i332 BIOINFORMATICS Contact: pavelm@cs.rutgers.edu Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Mapping billions of reads from next generation sequencing experiments to reference genomes is a crucial task, which can require hundreds of hours of running time on a single CPU even for the fastest known implementations. Traditional approaches have difficulties dealing with matches of large edit distance, particularly in the presence of frequent or large insertions and deletions (indels). This is a serious obstacle both in determining the spectrum and abundance of genetic variations and in personal genomics. Results: For the first time, we adopt the approximate string matching paradigm of geometric embedding to read mapping, thus rephrasing it to nearest neighbor queries in a q-gram frequency vector space. Using the L 1 distance between frequency vectors has the benefit of providing lower bounds for an edit distance with affine gap costs. Using a cache-oblivious kd-tree, we realize running times, which match the state-of-the-art. Additionally, running time and memory requirements are about constant for read lengths between 100 and 1000 bp. We provide a first proof-of-concept that geometric embedding is a promising paradigm for read mapping and that L 1 distance might serve to detect structural variations. TreQ, our initial implementation of that concept, performs more accurate than many popular read mappers over a wide range of structural variants. Availability and implementation: TreQ will be released under the GNU Public License (GPL), and precomputed genome indices will be provided for download at http://treq.sf.net.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The possibility to re-sequence genomes rapidly and cost-efficiently using next generation sequencing (NGS) technologies has provided fascinating insights into the breadth and prevalence of human genetic variation (<ref type="bibr">The 1000</ref><ref type="bibr">Genomes Project Consortium, 2010</ref><ref type="bibr">The International HapMap Consortium, 2005</ref>), in particular the abundance of structural variants—we will jointly refer to them as insertion and deletions (indels) and not distinguish, for example between novel sequence insertions and duplications. Unfortunately, these structural variants, more exactly short indels, are complicating the first step in the analysis, mapping DNA sequencing reads to reference genomes. This is surprising, as approximate string matching, the theoretical problem underlying read mapping, is arguably one of the most fundamental problem in bioinformatics and a very well-studied * To whom correspondence should be addressed. area in data mining; for surveys see Boytsov (2011b); Navarro (2001). Mapping reads from DNA sequencing experiments requires solving approximate string matching problems for billions of short DNA sequences of length 20–500 bp against entire genomes. There have been a multitude of methods proposed—see for example the benchmarks performed by<ref type="bibr" target="#b18">Hach et al. (2010)</ref>—and the results and optimal choice of method depend strongly on the read length and the maximal edit distance allowed. Out of the variety of different approaches [see Boytsov (2011a) for a detailed taxonomy] proposed for approximate string matching, current read mappers rely on only three different paradigms (<ref type="bibr" target="#b30">Li and Homer, 2010</ref>): seed-and-extend (encompassing hash tables and q-gram filtering), prefix/suffix tries (using the Burrows– Wheeler transform) and one approach based on merge sort (<ref type="bibr" target="#b34">Malhis and Jones, 2010</ref>). Their computational efficiency depends on the existence of exact matches between the read and the genome. Intuitively, there cannot be an approximate match of small edit distance between a read and the genome if not one or several exact matches of length q exist. The relationship between the presence of such matching q-grams (sequence of length q) and the edit distance was revealed in a seminal paper by<ref type="bibr" target="#b53">Ukkonen (1992)</ref>: a lower bound for the edit distance between two strings is given by the L 1 distance between their count vectors of qgrams (for q = 3 these are the trinucleotide frequency vectors). This provides the basis for a seed-extend strategy of using efficient algorithms for finding one initial exact q-gram match, exploring whether additional exact q-gram matches support the existence of an approximate match,<ref type="figure">Figure 1</ref>(left), and then use an efficient alignment algorithm, such as Myers' bit-vector algorithm (<ref type="bibr" target="#b37">Myers, 1999</ref>), to verify and assess the quality of the match. Existing methods either implement this idea of q-gram filtering (<ref type="bibr" target="#b42">Navarro et al., 2005</ref>) directly (<ref type="bibr" target="#b57">Weese et al., 2009</ref>), or implicitly rely on it (<ref type="bibr" target="#b29">Li and Durbin, 2009</ref>). The running times depend on the maximal edit distance permitted: smaller maximal edit distance allows to chose larger q, thus there will be fewer exact q-gram matches and putative approximate matches to explore; indeed their probability decreases exponentially. If we think of patterns being derived from a match in the text through edit operations of technical nature (sequencing errors), or biological nature (genetic variants), the probability of hitting all q-grams and thus rendering q-gram filtering useless increases with the number of edits (<ref type="bibr" target="#b49">Sutinen and Szpankowski, 1998</ref>). Gapped q-grams (<ref type="bibr" target="#b10">Burkhardt and Kärkkäinen, 2002</ref>), requiring exact matches in a fixed pattern of q out of q &gt; q positions, are one way of addressing this. Most popular approaches, however, strictly limit the maximal edit distance and use heuristics to keep running time in check at the potential cost of missing best matches.<ref type="figure">1</ref>. Most approaches to approximate string matching using Ukkonen's q-gram lemma rely on the existence of reasonably large q-grams which are exact matches between pattern and text. These can be found efficiently with a number of techniques and yield putative hits, which are then evaluated using an alignment algorithm. For each pattern and each putative hit, the number of shared q-grams is evaluated de novo (left). We map both reads and genome locations to vectors of 2-gram frequencies and identify approximate matches finding nearest neighbors (right). This is accelerated by the use of a spatial index structure, e.g. a kd-tree, which is created by recursively partitioning the input space around the median value of a dimension.</p><p>In particular, the detection of indels suffers from the limits on edit distance of matches. As our results show, many of the existing methods have problems in mapping 100 bp reads with indels to the reference genome; longer reads improve the situation for some approaches. Consequently, the state-of-the-art in the detection of structural variants is the use of paired-end read libraries and advanced methods for performing downstream analysis after mapping the paired-end read libraries to reference genomes (<ref type="bibr" target="#b12">Chen et al., 2009;</ref><ref type="bibr" target="#b20">Hormozdiari et al., 2009</ref><ref type="bibr" target="#b21">Hormozdiari et al., , 2010</ref><ref type="bibr" target="#b25">Korbel et al., 2009;</ref><ref type="bibr" target="#b27">Lee et al., 2009</ref><ref type="bibr">). Nevertheless, Alkan et al. (2011</ref>noted that in particular detection of small, 5–50 bp indels, is a largely open problem, although our analysis reveals that one recent approach, Stampy (<ref type="bibr" target="#b33">Lunter and Goodson, 2011</ref>), provides excellent sensitivity. In the detection of such short indels, the deviations from mean insert length are measured, and thus, the sequencing coverage required to arrive at statistical significance is inversely proportional to the indel length. Our results will show that the detection of 1–16 bp indels from single reads is possible using L 1 distance. We pursue a different strategy from current read mappers, following ideas first proposed for protein sequences (<ref type="bibr" target="#b9">Bugnion et al., 1995</ref>) and generally referred to as vector space frequency distance methods (<ref type="bibr" target="#b8">Boytsov, 2011b</ref>), embedding strings as q-gram frequency vectors. These geometric embeddings have not yet made their way into read mapping, unlike other areas of bioinformatics, for example in the estimation of bacterial species phylogeny through oligonucleotide frequency distances (<ref type="bibr" target="#b50">Takahashi et al., 2009</ref>), under the name of k-spectra in classifying protein sequences using support vector machines (<ref type="bibr" target="#b28">Leslie et al., 2002</ref>) or in alignment-free sequence comparisons (<ref type="bibr" target="#b16">Goke et al., 2012;</ref><ref type="bibr" target="#b32">Liu et al., 2011;</ref><ref type="bibr" target="#b47">Reinert et al., 2009;</ref><ref type="bibr" target="#b56">Wan et al., 2010</ref>). We choose q = 3 and consider vectors of all trinucleotide frequencies, by embedding reads of length between 100 and 1000 bp as vectors in R 64. The problem of finding a minimal edit distance approximate match now becomes the problem of finding a nearest neighbor in a data set of vectors derived from a genome by sliding a window over the genome and mapping the sequence to a frequency vector,<ref type="figure">Figure 1</ref>(right). Finding (approximate) nearest neighbors, however, has been well studied and a large range of spatial index data structures have been proposed (<ref type="bibr" target="#b4">Berchtold et al., 1996;</ref><ref type="bibr" target="#b5">Bern, 1993;</ref><ref type="bibr" target="#b23">Katayama and Satoh, 1998;</ref><ref type="bibr" target="#b48">Sellis et al., 1987</ref>) generally leading to O(nlogn) complexity for construction of the spatial index and O(logn) complexity for nearest neighbor queries, where n denotes the number of points in the index. Empirical running times, however, vary widely based on the detailed structure of the problem instance, and thus, algorithm engineering is important for achieving competitive running times. The vector space frequency distance method introduced in<ref type="bibr" target="#b9">Bugnion et al. (1995)</ref>was not further pursued except in a small scale study focusing on different ways to map strings to vectors (<ref type="bibr">Ferhatosmanoglu, 2003, 2005</ref>). In recent years, researchers in databases, both multi-media and text, investigated indices in high-dimensional spaces (<ref type="bibr" target="#b6">Böhm et al., 2001;</ref><ref type="bibr" target="#b11">Bustos and Navarro, 2009;</ref><ref type="bibr" target="#b22">Houle and Sakuma, 2005;</ref><ref type="bibr" target="#b41">Navarro and Chávez, 2006;</ref><ref type="bibr" target="#b58">Yao et al., 2010</ref>), but the small alphabet size of DNA that leads to nonsparse frequency vectors preclude their use here. Boytsov (2011b) implemented and evaluated a range of different approaches in approximate string matching also on DNA datasets which are of small bacterial genome size (3.2 megabasepair). We found that his findings do not translate when the genome size increases by a factor of 1000. For instance the effects of cache or page misses, which motivate cache-oblivious data structures that guarantee minimum number of cache misses irrespective of cache size and memory hierarchy, are simply not observable on small data sets. During the development of the method, we used state-of-the-art kd-tree libraries (<ref type="bibr" target="#b35">Mount and Arya, 2010;</ref><ref type="bibr" target="#b36">Muja and Lowe, 2009</ref>) but found them to be lacking in performance once the index contained more than a few million points. Indeed, on genome-size problems, the ability to effectively implement data structures in a cache-oblivious manner is more important than computational complexity. In the following sections, we will show how L 1 distance serves as a lower bound for affine gap costs, introduces our methodology and implementation details and provides detailed analysis on both real and simulated data to show the advantages and drawbacks of geometric embeddings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>We use the usual notation, following (<ref type="bibr" target="#b17">Gusfield, 1997</ref>): A finite set of characters ={a,b,c,...} we will call an alphabet and a sequence s of characters from a string. We denote by |s| its length, by s i its i-th character, i &gt; 0, and by s<ref type="bibr">[i,j]</ref>the continuous sub-string starting at position i and ending in position j. We associate strings with vectors by computing the frequencies of all q-grams,</p><formula>c q (s) := |{i ∈{1,...,|s|−q+1}:s[i,i +q−1]=w}| w∈ q (1)</formula><p>which define a map from → R || q through s → c q (s). We assume that the q-words are in lexicographic order.Similarly we obtain a distance from the q-spectrum by considering the L 1 distance of the count vectors in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i326</head><formula>R || q , L 1 (s,t) := c q (s)−c q (t) .</formula><p>Theorem 1 (Ukkonnen (<ref type="bibr" target="#b53">Ukkonen, 1992)</ref>). For s,t ∈ q L 1 (s,t) ≤ 2q ED(s,t).</p><formula>(2)</formula><p>Note that the bound can become arbitrarily bad, for example when t is a rotation or transposition of s, see Ukkonen (1992).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The q-gram lemma revisited</head><p>Ukkonen's lemma states that L 1 ≤ 2qED, but this bound is dominated by the mismatches. It is worthwhile to consider the effects of mismatches and indels separately. Consider two strings S 1 and S 2 , where S 2 is derived by a single deletion of size d from S 1 or by insertion vice versa. Then the L 1 distance comprised two components. First, the number of q-grams spanning the gap in S 2 is q−1. Second, for S 1 , the first character in the deletion accounts for q deletions of q-grams; however, every consecutive character only accounts for one, as the other q−1 are already accounted for by deleting the left neighbor. Hence, the L 1 distance is bounded by L 1 ≤ 2q+d −2. As a single mismatch can affect at most 2q number of different q-grams, it follows that for m mismatches and g gaps of size d i , 1≤ i ≤ g,</p><formula>L 1 ≤ g i=1 (2q+d i −2)+2qm.</formula><formula>(3)</formula><p>As g i=1 d i +m = ED, we obtain</p><formula>L 1 ≤ ED+(2q−2)g +(2q−1)m (4)</formula><p>This shows that the number g of contiguous gaps (not the total number of gapped positions), provides a sharper bound than the number of mismatched positions. For example, if ED = 4 and q = 3, then L 1 ≤ 8 for a single indel of size 4, but L 1 ≤ 24 for four mismatches. Any algorithms based on nearest neighbors under L 1 distance is thus very well suited for mapping reads with large indels. A preference for large indels in alignments is biologically more meaningful than alignments with many small indels and generally addressed by using affine gap costs. The above formula naturally implies a scoring scheme for an affine edit distance AED(s,t). As</p><formula>L 1 ≤ (2q−1)g + g i=1 d i −g +2qm (5)</formula><p>we obtain</p><formula>L 1 ≤ AED := c o g +c e g i=1 d i −g +c s m (6)</formula><p>for gap opening cost c o := 2q−1, gap extension cost c e := 1 and substitution cost c s := 2q. For edit operations that affect positions q letters apart, it is easy to show that the inequality is sharp, that is L 1 gives the edit distance with affine gap costs. Consequently, finding matches of minimal L 1 prefers matches with fewer indels over matches with frequent substitutions. However, the lower bound can be still arbitrarily bad (see previous section), but the probability of catastrophic failure is small (see the Analysis in Supplementary Materials). Indeed the probability of L 1 distance being zero in the presence of one deletion of length k is</p><formula>P(L 1 (s,t) = 0|ED(s,t) = k, one deletion) ≤ (k −1)! k−1 4 ! 4 (P * 2 ) k−1 ,</formula><formula>(7)</formula><p>where P * 2 is the maximal transition probability in the Markov chain assumed to have generated reads and genome. See Supplementary Material for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Read mapping with cache-oblivious kd-trees</head><p>Efficient searches for exact or inexact nearest neighbors in high dimensions generally involve creating a tree-like index structure that recursively partitions the space. Their efficiency depends on the quality of the index and the geometric distributions of points. A comparative study (<ref type="bibr" target="#b24">Kibriya and Frank, 2007</ref>) showed that in a wide range of practical instances kd-trees outperform more advanced methods (<ref type="bibr" target="#b4">Berchtold et al., 1996;</ref><ref type="bibr" target="#b5">Bern, 1993;</ref><ref type="bibr" target="#b23">Katayama and Satoh, 1998;</ref><ref type="bibr" target="#b48">Sellis et al., 1987</ref>). In the index generation, for each sub-tree of the kd-tree, a dimension— usually the one with the highest variance—is chosen, and then the set of points under the sub-tree is partitioned using the median value of the chosen dimension as pivot. This process continues recursively and eventually completes in O(dnlogn) time for n d-dimensional points. During the search, a query point's coordinates are compared with the pivot, and a decision to search the left or right sub-tree is made. If there is no exact match to be found, the search procedure backtracks. As the index size gets larger, the effect of cache misses becomes very prominent and the running time increases substantially. As a result, over the last decade, many important data structures including kd-trees were made cache-oblivious (<ref type="bibr" target="#b0">Agarwal et al., 2003;</ref><ref type="bibr" target="#b14">Frigo et al., 1999</ref>). Our cacheoblivious kd-tree implementation stores the tree in sequential memory using the van Emde Boas layout (van Emde<ref type="bibr" target="#b54">Boas, 1975;</ref><ref type="bibr" target="#b55">van Emde Boas et al., 1976</ref>), which guarantees an optimal number of cache misses. We have implemented the following modification to the usual kd-tree construction. During index generation, we use pre-selected dimensions based on the entropy of the dimensions over the full data set, which makes the index building step O(nlogn) instead of finding the dimension with highest variance. The minimal axis-parallel hyper-rectangle containing all the points in the subtree defines a bounding box per subtree. These bounding boxes help to reduce the search space at the cost of increasing the index generation to O(dnlogn). In the search step, we compute lower bounds for the L 1 distance between the query point and all the points inside the bounding box of the left and right sub-tree in O(d ) time at every subtree. We proceed with the sub-tree giving the best lower bound and store the other sub-tree for future consideration. If no exact match is found the search process becomes expensive. We bound the number of alternate paths searched per query with the parameter β, which bounds the running time per query to O(βd logn). In the bottom levels, the running time overhead to find lower bounds using the bounding boxes is comparable with directly computing the L 1 distances. Thus, for the last τ levels, we do not create bounding boxes, and in the search step, we simply compute the L 1 distances between the query point and the points in the sub-tree (we use fast hardware accelerated L 1 distance computation). This also decreases memory requirement to store the tree by 2 τ times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Verification by Myers' Bitvector algorithm</head><p>Using Myers' bit-vector algorithm (<ref type="bibr" target="#b37">Myers, 1999</ref>), we compute the edit distance and the exact location for each read based on putative locations identified as nearest neighbors, adding a slack of 14 bp on each boundary. The best position is reported, breaking ties arbitrarily.and running times, as the lowest τ levels of the cache-oblivious kd-tree are not stored and rather direct L 1 distance computations are performed. To further reduce memory requirements, the genomic window is shifted by g base pairs to create d-dimensional (d = 4 q ) frequency vectors (final match positions are based on Myers' alignment). A third parameter α, determines number of vectors for which we only store the changes from a nearby point as they can be constructed with minimal overhead from their differences in few dimensions from the (2α +1)-th point which is actually stored (see Supplementary Material for a detailed explanation). In our experiments we have found g = 3, α = 2, β = 3000 and τ = 3 to be a good choice for the human genome, and unless otherwise stated these are the default parameter values for TreQ. Note that for a wide range of parameter choices TreQ's accuracy remains effectively the same (cf. Supplementary<ref type="figure" target="#fig_2">Figure S2</ref>). In contrast, most popular read mappers have large number of parameters, which are specifically tuned for typical datasets and often very difficult to optimize.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Parameter choices Parameter β,</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DISCUSSION</head><p>To evaluate TreQ and compare its performance, we ran a number of read mappers–Bowtie (<ref type="bibr" target="#b26">Langmead et al., 2009</ref>), BWA (<ref type="bibr" target="#b29">Li and Durbin, 2009</ref>), SOAP2 (<ref type="bibr" target="#b29">Li et al., 2009</ref>), mrFAST (<ref type="bibr" target="#b1">Alkan et al., 2009</ref>), Novoalign (http://www.novocraft.com), SSAHA2 (<ref type="bibr" target="#b43">Ning et al., 2001</ref>), LAST (<ref type="bibr" target="#b15">Frith et al., 2010;</ref><ref type="bibr" target="#b19">Hamada et al., 2011</ref>), Stampy (<ref type="bibr" target="#b33">Lunter and Goodson, 2011</ref>) and RazerS (<ref type="bibr" target="#b57">Weese et al., 2009</ref>)–on simulated and real read datasets (see Supplementary Tables S1 for version numbers). These read mappers were evaluated with their default and, in some cases, customized parameters for allowing maximal permissible edit distance. We also forced them to report one single best hit. For TreQ, parameters q = 3, d = 64(= 4 q ), g = 3 and k = 200 were fixed throughout the experiments. Currently, quality scores are ignored in the match evaluation phase of TreQ. For simulated data, we define accuracy as the percentage of reads mapped to the actual genomic locations from where they were sampled (<ref type="figure" target="#fig_2">Fig. 2</ref>). We use human genome HG18 build 36 as the reference for all the experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Simulated data</head><p>We simulated four different read data sets, comprising a set of different model parameters, each by sampling 10 000 reads from the human reference genome. Given read length , we have: @BULLET S1 0 to 15% single-nucleotide substitutions at random positions i328</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TreQ: Indel-tolerant read mapping</head><p>@BULLET S2 Indels of size 0–25 at 2% random locations in the read @BULLET S3 Indels of size 2 at 0–10% random locations in the read @BULLET S4 A single indel of size 0 to 17% at a random location</p><p>On top of that, we simulated sequencing error by estimating and interpolating an Illumina error profile. We estimated a first-order Markov chain of Phred score transitions from 1 million reads of length 101 from a Yoruba African individual (NA18507) for each of those 101 positions. To remove noise and simulate reads of lengths other than 101 bp, we used univariate spline interpolation to estimate the evolution of each entry of the matrix over the read sequence. These functions were then stretched or skewed for other read lengths, and new transition probabilities were derived by evaluating the spline function at the appropriate positions and rescale the rows, so that the matrix becomes stochastic. The resulting Phred score distributions of the reads simulated by iterating the new Markov chains were then verified to correspond to those of real data. As Phred scores correspond to actual error rates (<ref type="bibr" target="#b13">Ewing and Green, 1998</ref>), we used them to simulate position-dependent sequencing errors. Our evaluation shows that Stampy outperforms all other methods in terms of accuracy (<ref type="figure" target="#fig_2">Fig. 2</ref>). Its running time, however, depends on the type of read. For instance mapping all S1 reads of 500 bp length takes 1 h 35 min, in whereas mapping S2 takes 5 h (Supplementary<ref type="figure" target="#tab_1">Table S1</ref>). TreQ's running time ranges consistently at about 3.5 h. Stampy's running time also increases with read length, although it is mostly better than TreQ's. LAST performs in about the same accuracy range as TreQ but is not competitive in running time. In terms of accuracy, geometric embedding outperforms all suffix trie and seed-extend-based read mappers other than Stampy and LAST on almost all instances. The authors of both these programs argue that their accuracy is mainly due to the elaborate downstream analysis they perform after finding candidates. Our results are thus preliminary, as in essence we are comparing statistical alignment models of Stampy and LAST to a simple filter based on Levenshtein distance in our case. BWA can be customized to be competitive on S1 for shorter reads, at the cost of higher running times, but this improvement does not translate to S2–S4. Similarly, LAST outperforms TreQ on S1, but its performance is similar or worse than TreQ's on other conditions. Trie-based read mappers (Bowtie BWA and SOAP2) are very fast but do not perform well in general. Using a hybrid approach—in which SOAP's unmapped reads are mapped by TreQ—increases the accuracy for lower distances at the expense of slightly lower accuracy for higher distances, whereas drastically reducing the running time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Biological data</head><p>Following the evaluation in<ref type="bibr" target="#b18">Hach et al. (2010)</ref>, we compared TreQ to popular read mappers on a set of 1 million randomly selected 101 bp reads from Yoruba African individual (NA18507) (<ref type="bibr">The 1000</ref><ref type="bibr">Genomes Project Consortium, 2010</ref>). The running time and the percentage of reads mapped to the reference human genome HG18 build 36 within 3, 6, 12, and 18 edit distances are reported in<ref type="figure" target="#tab_1">Table 1</ref>. Times are for a single thread on a single core of a 2.2 GHz AMD Opteron processor. We have found suffix-trie-based read mappers, implemented using Burrows–Wheeler transform, to be very fast on the real dataset but, unsurprisingly, limited in their ability to map reads with higher edit distances. Seed-extend-based techniques in contrast usually map more reads at large edit distances but require more CPU time. Except LAST, Stampy and TreQ, none of the other read mappers that we have evaluated successfully maps reads at high edit distances, possibly containing indels, in a reasonable amount of time. TreQ does so at competitive running time compared with mrFAST, RazerS, SSAHA2 and BWA with customized parameters (BWA's default parameters are not competitive with respect to accuracy). The hybrid SOAP/TreQ approach, taking advantage of suffix-triebased read mappers' efficiency on low edit distances and TreQ's sensitivity at higher edit distances, uses less time and maps more reads within all edit distances considered. Although TreQ outperforms other read mappers on many mismatches or with large indels, its performance start to degrade gradually. As a result TreQ's specificity should drop at large edit distances. We have indirectly tested TreQ and other read mappers' specificity by combining the genome of human and chicken (a distant organism from human) and mapping the same one million real reads to this combined genome. We have found that BWA, BWA (customized), SOAP2, Novoalign, mrFAST and TreQ (within edit distance 18) map 87, 191, 65, 149, 189 and 187 reads, respectively, to the chicken genome. This experiment shows that TreQ's specificity is comparable with the other read mappers. For greater control over specificity, an optional maximum edit distance threshold m can be set in TreQ to discard any alignment with edit distance greater than m (default value l 4 , for read length l).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Memory requirements and multi-threading</head><p>The memory requirement for the cache-oblivious kd-tree and the d-dimensional vectors are</p><formula>d 2 log G g −τ and G g(2α+1) (d +2gα(α + 1)), respectively. As a result, TreQ requires about O dG g 1 2 τ + 1 α bytes</formula><p>of memory, given that 2gα(α +1) ≤ d. Here, G is the genome size, g is the offset by which the genomic windows are shifted,<ref type="figure">Figure 1</ref>(right), while creating d-dimensional q-gram vectors, 2α is the number of vectors for which we only store the changes from a nearby point and τ is the number of ignored lowest levels in the kd-tree. If we set τ = 4, α = 2 and g = 3, for d = 64 TreQ's memory requirement is around 40 GB (which is equivalent to using less than 1GB per core in a 48-core machine with the multi-threaded TreQ). Interestingly, these parameters have minor effects on accuracy and running time; for a detailed analysis, see Supplementary<ref type="figure" target="#fig_2">Figure S2</ref>. In addition, memory requirement can be further reduced by creating separate kd-trees for each chromosome and loading one kd-tree at a time in the memory. We have developed a multi-threaded version of TreQ and tested its performance by mapping 0.1 million randomly selected Illumina single end reads (Yoruba African individual, NA18507) on a 48-core AMD Opteron 2.2 GHz server with 256 GB memory. The performance of TreQ scales very well in the number of threads, within 84% of the achievable maximum up to 40 cores (<ref type="figure" target="#fig_5">Fig. 3</ref>).The percentages of reads mapped within a fixed edit distance (ED) by various read mappers are reported. As expected, trie-based read mappers are very fast but mostly fail to map reads with higher errors. BWA with customized parameters performs well but with significantly increased running time. Seed-extend-based methods have varied outcomes; mrFAST, RazerS and SSAHA2 take significantly more running time than others, Novoalign is comparably fast but fails to map reads with higher edit distances, whereas LAST (without LAMA option) and Stampy map almost similar amount of reads as TreQ. In contrast to most read mappers, TreQ is not restricted to few mismatches, small indels or few number of indels, and maps either an almost similar percentage of reads or more with various different parameter settings. TreQ's running time is significantly lower than mrFAST, RazerS and SSAHA2 and comparable with customized BWA; we stopped SSAHA2 after it did not finish running in 45 h. Additionally, Hybrid TreQ/SOAP outperforms most read mappers, whereas significantly reducing the required running time. Note that Bowtie only allows mismatches and is restricted to at most 3. All running times are based on running the read mappers single threaded on a single core of a 2.2 GHz AMD Opteron processor.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TreQ: Indel-tolerant read mapping</head><p>implemented in a cache-oblivious manner, which certainly can be improved upon. We are currently investigating a parallel distributed index, which will allow the use of TreQ on clusters. Generally, we expect further improvements in running times, and consequently in accuracy, from an spatial index tailored specifically to the high-dimensional, integer coordinate problem setting, e.g. an adaptation of X-trees (<ref type="bibr" target="#b4">Berchtold et al., 1996</ref>) or through the use of locality-sensitive hashing (<ref type="bibr" target="#b46">Paulevé et al., 2010</ref>). Additional improvements in terms of both memory and running time can be made by using batch processing for queries. The simplistic evaluation of putative matches using Levensthein distance will be replaced by a statistical, quality-score aware analysis following the lead of Stampy (<ref type="bibr" target="#b33">Lunter and Goodson, 2011</ref>) and LAST (<ref type="bibr" target="#b15">Frith et al., 2010;</ref><ref type="bibr" target="#b19">Hamada et al., 2011</ref>), which attribute their success to a large degree to the quality of their putative hit filtering. In our geometric embedding, quality scores can be used while searching for putative hits by using floating-point or fixed-point arithmetic and fractional count contributions for low-quality nucleotides. The approximate matching tasks differ depending on whether a read has one exact match, few matches of small Hamming or Levenshtein distance, few matches of large Levenshtein distance with large indels or many matches of arbitrary distance. The resulting running times and accuracies depend heavily on the exact composition of the read set with respect to the types of matches. This implies that for data sets which are expected to contain both reads with indels and reads with mutations, a hybrid approach might be the most sensible option, as exemplified by our hybrid method. Traditional read mappers that are fast on low-mutation reads can be used to filter the unproblematic reads and then use geometric embedding to map the remaining ones in an indel-tolerant fashion.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.</head><figDesc>Fig. 1. Most approaches to approximate string matching using Ukkonen's q-gram lemma rely on the existence of reasonably large q-grams which are exact matches between pattern and text. These can be found efficiently with a number of techniques and yield putative hits, which are then evaluated using an alignment algorithm. For each pattern and each putative hit, the number of shared q-grams is evaluated de novo (left). We map both reads and genome locations to vectors of 2-gram frequencies and identify approximate matches finding nearest neighbors (right). This is accelerated by the use of a spatial index structure, e.g. a kd-tree, which is created by recursively partitioning the input space around the median value of a dimension.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>the maximum number of different paths explored in the search, controls the running time and sensitivity of TreQ. However, this does not restrict the maximal edit distance of matches in contrast to trie-based methods which avoid exponential blow-up with such restrictions. A second parameter, τ influences the memory footprint</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Comparison of popular read mappers with TreQ. Accuracy is defined as the percentage of single best reads that are mapped to the exact genomic location they were drawn from in the simulation. Notice that TreQ outperforms most popular read mappers and is mostly on par with LAST</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.3.</head><figDesc>Fig. 3. Speed up achieved by the multi-threaded version of TreQ on the task of mapping a randomly selected 0.1 million 101 bp single end reads from Yoruba African individual (NA18507).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 1.</figDesc><table>One million randomly selected Illumina single end reads mapped to HG18 build 36 

Technique 
Algorithm 
Parameters 
Time (h:m) 
Mapped percentage ≤ ED 

≤ 3 
≤ 6 
≤ 12 
≤ 18 

Suffix trie 

Bowtie 
–best 
0:04 
85.22 
– 
– 
– 
–best -v 3 
0:04 
86.85 
– 
– 
– 

BWA 
default 
0:14 
87.31 
89.35 
– 
– 
-n 50 -o 10 -e 50 -M 1 -O 3 -E 1 
5:53 
87.35 
90.08 
92.39 
93.03 
SOAP2 
-v 50 -g 10 -r 1 
0:03 
84.87 
– 
– 
– 

Seed-extend 

mrFAST 
–best -e 6 
19:50 
87.54 
90.59 
– 
– 
Novoalign 
-l 0 -e 1 -r Random 
0:27 
83.68 
84.80 
85.18 
85.19 
SSAHA2 
–best -1 
45:36+ 
– 
– 
– 
– 
RazerS 
–unique 
14:45 
66.67 
79.41 
– 
– 

Stampy 
default 
1:57 
85.73 
88.32 
90.90 
92.15 
–bwa-options 
0:38 
90.37 
92.05 
93.81 
94.84 

LAST 

default 
1:32 
84.76 
87.66 
90.23 
90.78 
-d108 -e120 
1:35 
84.85 
87.77 
90.69 
91.69 
default, LAMA 
4:36 
68.74 
71.12 
73.26 
73.72 
-d108 -e120, LAMA 
4:39 
39.26 
40.60 
41.95 
42.42 

Geometric embedding 
TreQ 

τ = 1, β = 5000, α = 0 
7:00 
87.34 
90.12 
93.06 
94.67 
τ = 2, β = 4500, α = 0 
6:28 
87.27 
90.06 
93.01 
94.61 
τ = 3, β = 4000, α = 0 
6:36 
87.22 
90.04 
93.02 
94.62 
τ = 1, β = 5000, α = 2 
8:15 
87.32 
90.11 
93.04 
94.66 
τ = 2, β = 4000, α = 2 
7:44 
87.16 
89.93 
92.87 
94.50 
τ = 3, β = 3000, α = 2 
8:50 
86.90 
89.69 
92.66 
94.30 

Hybrid 
SOAP2 + TreQ 
τ = 3, β = 3000, α = 2 
2:06 
87.89 
90.50 
93.26 
94.83 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="4"> CONCLUSION We address the problem of mapping NGS reads in an indeltolerant manner by establishing geometric embedding as a promising paradigm, allowing identification of structural variants, including one or several indels of length 1–16 bp, from single read i329 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">experiments: We map reads and genomic locations to trinucleotide frequency vectors, embedding them in R 64. The L 1 distance between q-gram frequency vectors provides a lower bound for an edit distance with affine gap costs in which even long indels have small distance, improving the sensitivity of their detection. A probabilistic argument assuming reads, and genomes are generated from a Markov chain provides insight into the quality of the bound. The problem of approximate matching is thus transformed into one of computing nearest neighbors using a spatial index. The decision for kd-trees was based on their favorable performance in many real-world scenarios (Kibriya and Frank, 2007) and the fact that they can be easily implemented in a cache-oblivious manner (Arge et al., 2005), a major factor as memory accesses constitute the predominant bottleneck on modern CPU architectures. Apart from the mapping of reads to the q-gram frequency vectors, our method has running times and memory requirements, which are about constant for the operations involving the index in the length of the reads. In practice, because of word sizes on computers, we expect this to hold for sequences of length 100–1000 bp. Currently, SMP computers with many cores and 128 GB are the preferable platform for TreQ as the memory requirement is high, even when comparable with the state-of-the-art when measured in memory per core. Fortunately, SMP servers are approaching the prices of clusters with a comparable number of cores and main memory, which make the SMP platform the more versatile option at the same price point and memory usage a lesser issue. Also, the spatial index we used is a straight-forward kd-tree variant i330 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">i332 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank Martin Frith for helping us with LAST, Martin FarachColton for fruitful discussion on data structures and Rajat Roy for many useful suggestions about read mappers. We also thank the three anonymous reviewers for their helpful and constructive comments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict</head><p>of Interest: none declared.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Cache-oblivious data structures for orthogonal range searching</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">K</forename>
				<surname>Agarwal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the nineteenth annual symposium on Computational geometry, SCG &apos;03</title>
		<meeting>the nineteenth annual symposium on Computational geometry, SCG &apos;03<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="237" to="245" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Personalized copy number and segmental duplication maps using next-generation sequencing</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Alkan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="1061" to="1067" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Genome structural variation discovery and genotyping</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Alkan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="363" to="376" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Cache-oblivious data structures</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Arge</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Data Structures and Applications</title>
		<editor>Mehta,D. et al.</editor>
		<imprint>
			<publisher>CRC Press</publisher>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>chapter. 34</note>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">The x-tree : An index structure for high-dimensional data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Berchtold</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VLDB&apos;96, Proceedings of 22th International Conference on Very Large Data Bases</title>
		<editor>Vijayaraman,T.M. et al.</editor>
		<meeting><address><addrLine>Mumbai, India ; San Francisco</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1996-09-03" />
			<biblScope unit="page" from="28" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Approximate closest-point queries in high dimensions</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Bern</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process Lett</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="95" to="99" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Searching in high-dimensional spaces: Index structures for improving the performance of multimedia databases</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Böhm</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="322" to="373" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Indexing methods for approximate dictionary searching</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Boytsov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Exp. Algorithmics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Indexing methods for approximate dictionary searching: Comparative analysis</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Boytsov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Exp. Algorithmics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">A spatial index for approximate multiple string matching</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Bugnion</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Brazilian Chem. Soc</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="28" to="35" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Better filtering with gapped q-grams. Fundam</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Burkhardt</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Kärkkäinen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="page" from="51" to="70" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Improving the space cost of k-nn search in metric spaces by using distance estimators</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Bustos</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Multimedia Tools Appl</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="215" to="233" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Breakdancer: an algorithm for high-resolution mapping of genomic structural variation</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="677" to="681" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Base-calling of automated sequencer traces using phred. II. error probabilities</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Ewing</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Green</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="186" to="194" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Cache-oblivious algorithms</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Frigo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 40th Annual Symposium on Foundations of Computer Science, FOCS &apos;99</title>
		<meeting>the 40th Annual Symposium on Foundations of Computer Science, FOCS &apos;99<address><addrLine>Washington</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page">285</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Incorporating sequence quality data into alignment improves DNA read mapping</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">C</forename>
				<surname>Frith</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page">100</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Estimation of pairwise sequence similarity of mammalian enhancers with word neighbourhood counts</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Goke</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="656" to="663" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<monogr>
		<title level="m" type="main">Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">mrsfast: a cache-oblivious algorithm for short-read mapping</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Hach</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Method</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="576" to="577" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Probabilistic alignments with quality scores: an application to short-read mapping toward accurate snp/indel detection</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Hamada</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="3085" to="3092" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Combinatorial algorithms for structural variation detection in high-throughput sequenced genomes</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Hormozdiari</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1270" to="1278" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Next-generation variationhunter: combinatorial algorithms for transposon insertion discovery</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Hormozdiari</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="350" to="357" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Fast approximate similarity search in extremely highdimensional data sets</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">E</forename>
				<surname>Houle</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Sakuma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ICDE. IEEE Computer Society</title>
		<editor>Aberer,K. et al.</editor>
		<imprint>
			<biblScope unit="page" from="619" to="630" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Sr-tree: An index structure for nearest-neighbor searching of high-dimensional point data</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Katayama</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Satoh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sys. Comput. Japan</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="59" to="73" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">An empirical comparison of exact nearest neighbour algorithms Knowledge Discovery in Databases: PKDD</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Kibriya</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Frank</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>Kok, J. et al.</editor>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">4702</biblScope>
			<biblScope unit="page" from="140" to="151" />
			<date type="published" when="2007" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Pemer: a computational framework with simulation-based error models for inferring genomic structural variants from massive paired-end sequencing data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">O</forename>
				<surname>Korbel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">23</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short dna sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Modil: detecting small indels from clone-end sequencing with mixtures of distributions</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Lee</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="473" to="474" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">The spectrum kernel: a string kernel for svm protein classification</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Leslie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Pacific Symposium on Biocomputing</title>
		<meeting>Pacific Symposium on Biocomputing</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="564" to="575" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with burrows–wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">A survey of sequence alignment algorithms for nextgeneration sequencing</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Homer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="473" to="483" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">Soap2: an improved ultrafast tool for short read alignment</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1966" to="1967" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">New powerful statistics for alignment-free sequence comparison under a pattern transfer model</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Liu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Theo. Biol</title>
		<imprint>
			<biblScope unit="volume">284</biblScope>
			<biblScope unit="page" from="106" to="116" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">Stampy: A statistical algorithm for sensitive and fast mapping of illumina sequence reads</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Lunter</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Goodson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="936" to="939" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">High quality SNP calling using Illumina data at shallow coverage</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Malhis</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">J M</forename>
				<surname>Jones</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1029" to="1064" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<monogr>
		<title level="m" type="main">Ann: A library for approximate nearest neighbor searching Available at http://www.cs.umd</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">M</forename>
				<surname>Mount</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Arya</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010-07-18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<analytic>
		<title level="a" type="main">Fast approximate nearest neighbors with automatic algorithm configuration</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Muja</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">G</forename>
				<surname>Lowe</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Computer Vision Theory and Application (VISSAPP&apos;09)</title>
		<editor>Ranchordas, A. et al.</editor>
		<meeting><address><addrLine>Setubal, Portugal</addrLine></address></meeting>
		<imprint>
			<publisher>INSTICC Press</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="331" to="340" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title level="a" type="main">A fast bit-vector algorithm for approximate string matching based on dynamic programming</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="395" to="415" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b38">
	<analytic>
		<title level="a" type="main">A guided tour to approximate string matching</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="31" to="88" />
			<date type="published" when="2001-08-30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b39">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<editor>S.K. MANUSCRIPT CATEGORY: ECCB</editor>
		<imprint>
			<biblScope unit="volume">17278</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="332" to="325" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>bts380. .tex] Page</note>
</biblStruct>

<biblStruct   xml:id="b40">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Mahmud</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b41">
	<analytic>
		<title level="a" type="main">A metric index for approximate string matching</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Chávez</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theo. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">352</biblScope>
			<biblScope unit="page" from="266" to="279" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b42">
	<analytic>
		<title level="a" type="main">Indexing text with approximate q-grams</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="157" to="175" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b43">
	<analytic>
		<title level="a" type="main">Ssaha: A fast search method for large dna databases</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Ning</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1725" to="1729" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b44">
	<analytic>
		<title level="a" type="main">Effective indexing and filtering for similarity search in large biosequence databases</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Ozturk</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Ferhatosmanoglu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">BIBE</title>
		<meeting><address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="359" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b45">
	<analytic>
		<title level="a" type="main">Vector space indexing for biosequence similarity searches</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Ozturk</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Ferhatosmanoglu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Artificial Intel. Tool</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="811" to="826" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b46">
	<analytic>
		<title level="a" type="main">Locality sensitive hashing: a comparison of hash function types and querying mechanisms</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Paulevé</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Reco. Lett</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1348" to="1358" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b47">
	<analytic>
		<title level="a" type="main">Alignment-free sequence comparison (i): statistics and power</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Reinert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="1615" to="1634" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b48">
	<analytic>
		<title level="a" type="main">The r+-tree: A dynamic index for multi-dimensional objects</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">K</forename>
				<surname>Sellis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Conference on Very Large Data Bases</title>
		<meeting>the 13th International Conference on Very Large Data Bases<address><addrLine>San Francisco</addrLine></address></meeting>
		<imprint>
			<publisher>Morgan Kaufmann Publishers Inc</publisher>
			<date type="published" when="1987" />
			<biblScope unit="page" from="507" to="518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b49">
	<analytic>
		<title level="a" type="main">On the collapse of q-Gram filtration</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Sutinen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Szpankowski</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">FUN with Algorithms</title>
		<meeting><address><addrLine>Ottawa, ON, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="178" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b50">
	<analytic>
		<title level="a" type="main">Estimation of bacterial species phylogeny through oligonucleotide frequency distances</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Takahashi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genomics</title>
		<imprint>
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page" from="525" to="533" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b51">
	<analytic>
		<title level="a" type="main">A map of human genome variation from population-scale sequencing</title>
	</analytic>
	<monogr>
		<title level="m">The 1000 Genomes Project Consortium</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1061" to="1073" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b52">
	<analytic>
		<title level="a" type="main">A haplotype map of the human genome</title>
	</analytic>
	<monogr>
		<title level="m">The International HapMap Consortium</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="1299" to="1320" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b53">
	<analytic>
		<title level="a" type="main">Approximate string matching with q-grams and maximal matches</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ukkonen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">92</biblScope>
			<biblScope unit="page" from="191" to="211" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b54">
	<analytic>
		<title level="a" type="main">Preserving order in a forest in less than logarithmic time</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Van Emde Boas</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th Annual Symposium on Foundations of Computer Science</title>
		<meeting>the 16th Annual Symposium on Foundations of Computer Science<address><addrLine>Washington, DC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1975" />
			<biblScope unit="page" from="75" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b55">
	<analytic>
		<title level="a" type="main">Design and implementation of an efficient priority queue</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Van Emde Boas</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theo. Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="99" to="127" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b56">
	<analytic>
		<title level="a" type="main">Alignment-free sequence comparison (ii): theoretical power of comparison statistics</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Wan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1467" to="1490" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b57">
	<analytic>
		<title level="a" type="main">Razers fast read mapping with sensitivity control</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Weese</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1646" to="1654" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b58">
	<monogr>
		<title level="m" type="main">Approximate string search in spatial databases</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Yao</surname>
			</persName>
		</author>
		<editor>Li, F. et al.</editor>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b59">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">ICDE IEEE Computer Society</title>
		<imprint>
			<biblScope unit="page" from="545" to="556" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>