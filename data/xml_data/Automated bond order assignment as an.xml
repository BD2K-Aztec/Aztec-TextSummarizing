
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Structural bioinformatics Automated bond order assignment as an optimization problem</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011">2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Anna</forename>
								<forename type="middle">Katharina</forename>
								<surname>Dehof</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Bioinformatics</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<postCode>66041</postCode>
									<settlement>Saarbrücken</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alexander</forename>
								<surname>Rurainski</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Bioinformatics</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<postCode>66041</postCode>
									<settlement>Saarbrücken</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Quang</forename>
								<surname>Bao</surname>
							</persName>
						</author>
						<author>
							<persName>
								<forename type="first">Anh</forename>
								<surname>Bui</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Chair for Bioinformatics</orgName>
								<orgName type="institution">Friedrich-Schiller-University Jena</orgName>
								<address>
									<postCode>07743</postCode>
									<settlement>Jena</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Sebastian</forename>
								<surname>Böcker</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Chair for Bioinformatics</orgName>
								<orgName type="institution">Friedrich-Schiller-University Jena</orgName>
								<address>
									<postCode>07743</postCode>
									<settlement>Jena</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Hans-Peter</forename>
								<surname>Lenhof</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Bioinformatics</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<postCode>66041</postCode>
									<settlement>Saarbrücken</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Andreas</forename>
								<surname>Hildebrandt</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Bioinformatics</orgName>
								<orgName type="institution">Saarland University</orgName>
								<address>
									<postCode>66041</postCode>
									<settlement>Saarbrücken</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Structural bioinformatics Automated bond order assignment as an optimization problem</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">27</biblScope>
							<biblScope unit="issue">5</biblScope>
							<biblScope unit="page" from="619" to="625"/>
							<date type="published" when="2011">2011</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq718</idno>
					<note type="submission">Received on August 12, 2010; revised on December 7, 2010; accepted on December 22, 2010</note>
					<note>[14:36 2/2/2011 Bioinformatics-btq718.tex] Page: 619 619–625 Associate Editor: Burkhard Rost Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Numerous applications in Computational Biology process molecular structures and hence strongly rely not only on correct atomic coordinates but also on correct bond order information. For proteins and nucleic acids, bond orders can be easily deduced but this does not hold for other types of molecules like ligands. For ligands, bond order information is not always provided in molecular databases and thus a variety of approaches tackling this problem have been developed. In this work, we extend an ansatz proposed by Wang et al. that assigns connectivity-based penalty scores and tries to heuristically approximate its optimum. In this work, we present three efficient and exact solvers for the problem replacing the heuristic approximation scheme of the original approach: an A*, an ILP and an fixed-parameter approach (FPT) approach. Results: We implemented and evaluated the original implementation , our A*, ILP and FPT formulation on the MMFF94 validation suite and the KEGG Drug database. We show the benefit of computing exact solutions of the penalty minimization problem and the additional gain when computing all optimal (or even suboptimal) solutions. We close with a detailed comparison of our methods. Availability: The A* and ILP solution are integrated into the open-source C++ LGPL library BALL and the molecular visualization and modelling tool BALLView and can be downloaded from our homepage www.ball-project.org. The FPT implementation can be downloaded from</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Correct bond order information is essential for many algorithms in Computational Structural Biology and Theoretical Chemistry, since bonds do not only define the connectivity of atoms in a molecule but also define structural aspects like rotatability of individual parts. However, bond order information can often not be directly inferred from the available experimental data. Even important molecular databases, like the Protein Data Bank (PDB) (<ref type="bibr" target="#b4">Berman et al., 2003</ref>) and the Cambridge Structural Database (<ref type="bibr" target="#b0">Allen, 2002</ref>), are known to contain erroneous data for connectivity and bond * To whom correspondence should be addressed. order information (<ref type="bibr" target="#b18">Labute, 2005</ref>) or to even omit them entirely. For proteins and nucleic acids, bond orders can be easily deduced due to their building block nature, but this does not hold for other kinds of molecules like ligands. The problem is made much worse by the fact that quite often, the bond order assignment for a given molecule is not unique, even when neglecting symmetries in the molecule. The chemical reasons for this effect are complex and out of scope of this work; here we just want to state that the concept of integer bond orders is only an approximation to a full quantum chemical treatment, and cannot explain all effects occurring in molecules. Important examples are aromatic or delocalized bonds, leading to different resonance structures (cf.<ref type="figure">Fig. 1</ref>). In addition, formal charges are often not contained in the input files, but atoms carrying a formal charge will obviously show a different bonding pattern. One body of opinion tries to overcome these obstacles by hand curation, which clearly provides the highest reliability. On the other hand, manual data curation does not scale well to large numbers of molecules, and it does not help in conditions where modifications are systematically applied to molecules, e.g. in computational combinatorial chemistry. In the past decades, the problem of assigning bond orders automatically has been addressed by a number of different approaches. Early methods in the field strongly rely on the correctness of atomic coordinates and focus on reference bond lengths and valence angles (<ref type="bibr" target="#b3">Baber and Hodgkin, 1992</ref>) or additionally consider functional group detection (<ref type="bibr" target="#b13">Hendlich et al., 1997</ref>) and further molecular features like hybridization states and charges (<ref type="bibr" target="#b19">Lang et al., 1992;</ref><ref type="bibr">van Aalten et al., 1996;</ref><ref type="bibr" target="#b27">Zhao et al., 2007</ref>). The main drawbacks of those approaches are the dependence on correct atomic coordinates and the algorithms' heuristic nature. In contrast, exact solvers proposed previously represent the bond order assignment problem as a Maximum Weighted Matching for non-bipartite graphs (<ref type="bibr" target="#b18">Labute, 2005</ref>) or as an integer linear programming problem that generates valid Lewis structures (electron dot structures) with minimal formal charge on each atom (<ref type="bibr" target="#b7">Froeyen and Herdewijn, 2005</ref>). Recently,<ref type="bibr" target="#b24">Wang et al. (2006)</ref>have presented an elegant novel approach to the problem, which is implemented in the established Antechamber package, a suite of tools used for the preparation of input structures for molecular mechanics studies. In this approach, a chemically motivated, expert generated penalty function is used to score bond order assignments. This function is then heuristically optimized. However, this procedure has two drawbacks: the score of a resulting assignment is not guaranteed to be optimal and the algorithm provides only one solution while there can be more than one assignment with optimal score.<ref type="figure">Figure 1</ref>exemplarily<ref type="bibr">[</ref><ref type="figure">1</ref>. Top: different co-optimal bond order assignments. In the left structure, both NH 2 groups are connected via a single bond and thus freely rotatable. In the middle and right structure, one group is connected via a double bond. Bottom: heuristic and optimal bond order assignments. The left structure is the solution provided by Antechamber with a tps of 4. Its 5-ring does not fulfill the aromaticity criterion of AM1-BCC (<ref type="bibr" target="#b16">Jakalian et al., 2002</ref>). The right structure is the solution computed with our exact solvers. Its tps is 0 and the 5-ring meets the AM1-BCC aromaticity criterion.</p><p>shows two cases where theses two drawbacks may lead to a wrong interpretation of molecular properties (flexibility and aromaticity). Unfortunately, the optimization problem introduced by<ref type="bibr" target="#b24">Wang et al. (2006)</ref>is NP-hard (<ref type="bibr">Böcker et al., 2009</ref>). In this work, we propose three exact approaches that solve the problem to provable global optimality by discrete optimization techniques: we give an integer linear program (IPL) formulation, and an A* approach and a fixedparameter algorithm for enumerating all optimal or, if desired, all feasible solutions. In addition, our approach can easily be extended to, e.g. include structural information, add missing hydrogens or even missing bonds. The A* and ILP solution are integrated into the opensource C++ LGPL library BALL (<ref type="bibr" target="#b17">Kohlbacher and Lenhof, 2000</ref>) (<ref type="bibr" target="#b14">Hildebrandt et al., 2010</ref>) and the molecular visualization and modelling tool BALLView (<ref type="bibr" target="#b21">Moll et al., 2006</ref>) and can be downloaded from our homepage www.ball-project.org. The FPT implementation can be downloaded from http://bio.informatik .unijena.de/software/.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">SCORING BOND ORDER ASSIGNMENTS</head><p>The idea behind the bond order assignment algorithm proposed in<ref type="bibr" target="#b24">Wang et al. (2006)</ref>is to cast the problem into a discrete optimization problem. Finding the most probable consistent bond order assignment for a given molecule is addressed by minimizing a total penalty score tps, where each atom is assigned an atomic valence av that is defined as the sum over all bond orders bo of all bonds connected to the atom under consideration:</p><formula>av = con i=1 bo i</formula><p>Here, con denotes the number of bonded atoms. The distance of the calculated av to the atom's most desirable valence value is measured by the atomic penalty score aps: the possible valences of an atom and the corresponding distance penalty scores are stored in a penalty table that uses a rule-based atom type classification and was derived by<ref type="bibr" target="#b24">Wang et al. (2006)</ref>. The sum over all atomic penalty scores of a molecule now yields the total penalty score tps = n i=1 aps i where n denotes the number of atoms. The smaller the tps of a given bond order assignment, the more reasonable it is. Unfortunately, this problem is NP-hard (<ref type="bibr">Böcker et al., 2009</ref>). In<ref type="bibr" target="#b24">Wang et al. (2006)</ref>, minimization now proceeds in a heuristic and greedy manner.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Integer linear program (ILP)</head><p>To compute a bond order assignment with guaranteed globally minimal tps, we formulated the problem as an ILP (<ref type="bibr" target="#b23">Papadimitriou and Steiglitz, 1998</ref>) as described below. @BULLET A is the set of all atoms of the molecule under consideration. @BULLET B(a) is the set of bonds of atom a ∈ A and B denotes the set of all bonds of the molecule. @BULLET V (a) ⊂ N contains the possible valences of atom a ∈ A. @BULLET P(a,v) is the penalty value for atom a ∈ A and valence v ∈ V (a).</p><p>Our approach uses two different classes of variables. For each bond b ∈ B, we introduce indicator variables x b i ∈{0,1} symbolizing whether the corresponding bond b is set to the bond order i ∈{1,...,µ}, where µ is the maximum bond order considered (in the following, we will set µ to 3, allowing single, double and triple bonds). To ensure that each bond b ∈ B is assigned exactly one bond order, we add the linear constraints µ i=1 x b i = 1 for all b ∈ B. Then the sum over all bond orders of all bonds b ∈ B(a) can be computed as</p><formula>b∈B(a) µ i=1 x b i ·i .</formula><p>The second class of variables focuses onto the atomic valences: for all atoms a and corresponding possible valences v according to the penalty table P, we introduce indicator variables y a,v ∈{0,1}. Each y a,v symbolizes whether the corresponding valence is chosen or not, i.e. penalty P(a,v) contributes to the score if and only if y a,v = 1. Thus, the objective function of our score minimization problem can be formulated as a linear function in y with penalty prefactors:</p><formula>min a∈A v∈V (a) P(a,v)·y a,v .</formula><p>To ensure that each atom is assigned exactly one valence state, we add the additional linear constraints v∈V (a) y a,v = 1 for all a ∈ A. In addition, we have to ensure that the sum of its bond orders equals its chosen valence. These constraints can be formulated as</p><formula>v∈V (a) y a,v ·v = b∈B(a) µ i=1 x b i ·i</formula><p>for all a ∈ A, because the left-hand side evaluates to valence v if and only if y a,v = 1. The full resulting ILP can be found in the Supplementary Material. Additional solutions can be found if for each bond order assignment s = {x b i |x b i = 1} computed so far we add the constraint(s) x b i ∈s x b i ≤ k∀s where k denotes the number of bonds in the molecule. Please note that we used x b i ∈{0,1} instead of x b ∈{1,...,µ} to model the bond orders. This simplifies the enumeration of additional solutions. For the solution of ILPs to provable global optimality, several strategies can be chosen, like the popular pure branch and bound approaches or branch and cut methods (<ref type="bibr" target="#b23">Papadimitriou and Steiglitz, 1998</ref>). We employed the open source solver lp_solve (http://lpsolve.sourceforge.net), which uses a simplex algorithm-based branch and bound approach (<ref type="bibr" target="#b23">Papadimitriou and Steiglitz, 1998</ref>). In our experiments, we have seen a drastic increase in running time if more than one solution is computed. Thus, the ILP approach is not well suited for obtaining co-optimal or suboptimal bond order assignments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The A* approach</head><p>In order to be able to efficiently enumerate all feasible solutions—optimal and suboptimal ones—we formulated the bond order assignment problemPage: 621 619–625</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Automated bond order assignment</head><p>as an A* search algorithm. This allows enumeration of all assignments in the order of increasing penalty and hence, for instance, to compare the assignments of all solutions for a given molecule up to a user-defined penalty threshold. In addition, such an A* algorithm is simpler to implement, and often easier to extend, than an ILP approach; for instance, it is easily possible to influence the order in which solutions with equal score are computed. As a combinatorial optimization problem, the bond order assignment problem can be represented by a tree, where each layer stands for one of the decisions that have to be made. In our case, the tree has k layers, where k is the number of bonds that have to be assigned. A node at layer i has µ children, where µ is the number of possible bond orders, typically 3, and each edge is labeled with its corresponding order. Hence, by tracing the path from the root to a node w at layer i, we can determine the values of the first i bonds in this particular partial assignment represented by the node w. Thus, the root node corresponds to a completely unassigned molecule with only unknown bond orders, while the leave nodes correspond to complete bond order assignments. If we only add child nodes and if the resulting valence state is valid, the leaf nodes correspond to the feasible bond order combinations. In order to discriminate between the different combinations, each leaf is assigned its total penalty score. Visiting all nodes in the tree, the optimal bond order assignment can be found in a brute-force manner with exponential running time. If, additionally, all intermediate nodes are assigned the atomic penalty score of the partial bond order assignment they represent, a greedy search will yield an assignment with heuristically good (but not necessary optimal) total penalty score in linear running time. It can be shown that, if at each intermediate node more information is provided, finding an optimal solution can be guaranteed with greatly improved expected running time. This leads to the popular A*search algorithm (<ref type="bibr" target="#b12">Hart et al., 1968</ref>), which employs a search heuristic to guide the algorithm in descending the tree. More formally, the algorithm associates with each node w a function f (w) = g * (w)+h * (w), where g * (w) describes the score corresponding to the decisions already made and h * (w) is the so-called search heuristic. For the purposes of the A*-search algorithm, the search heuristic must be an admissible estimate of the score of the best leaf that can be reached starting from node w and descending further down the tree. Here, admissible means that it needs to be 'optimistic': for all nodes w, the estimated cost h * (w) may never be greater than the lowest real cost to reach a goal node. Given the additional information provided by h * , the A*search algorithm always expands one of the nodes with the most promising score, ensuring that the first leaf reached is optimal (roughly speaking, if the algorithm would visit a leaf with worse score first, the search-heuristic would have overestimated the penalty of the real optimal solution, which an admissible heuristic never does). To map the bond order assignment problem formally to an A*-search, we need further notations that are adapted to the partial bond order assignments corresponding to each node w in the search tree. We denote the set of all assigned bonds in the node w by W (B), the assigned bonds connected to atom a in node w by W (a), and the set of atoms for which all bonds are already assigned with a bond order by K. Then, the functions g * and h * can be defined by:</p><formula>g * = a∈K P a,v w (a) (1) h * = a∈A\K min i∈V (a) P a,i (2)</formula><p>where V (a) ⊂ N contains the possible valences of atom a ∈ A according to the penalty table P. The search heuristic given in (2) is far too optimistic and can be tightened significantly. Thus, we define the bond order of an assigned bond by bo(b). A partial bond order assignment induces a simple lower bound</p><formula>v w (a) := b∈W (a)</formula><p>bo(b) for the valence of atom a. Assuming a single bond for each unassigned bond of atom a, a tighter lower bound for the valence is given by</p><formula>lo(a) := v w (a)+ b∈B(a)\W (a) 1 = v w (a)+|B(a)\W (a)|</formula><p>Thus, we can formulate a tighter search heuristic by</p><formula>h * = a∈A\K min lo(a)≤i≤size(P(a)) P a,i (3)</formula><p>An even tighter version of the search heuristic would also take the already assigned bond orders of the neighboring atoms of a in w into account. The maximum order of an unassigned bond with respect to atom a is given by t(a) := max{V (a)}−lo(a)+1 Denoting by a 1 , a 2 the atoms connected by an unassigned bond b, its maximum bond order equals bo max (b) := min{t(a 1 ),t(a 2 )}, yielding an upper bound of the atomic valence of an atom a</p><formula>up(a) := min ⎧ ⎨ ⎩ max{V (a)}, v w (a)+ b∈B(a)\W (a) bo max (b) ⎫ ⎬ ⎭</formula><p>Thus, a tighter version of the search heuristic is given by:</p><formula>h * = a∈A\K min lo(a)≤i≤up(a) P a,i (4)</formula><p>The function g * sums the atomic penalties of all completely assigned atoms in the partial bond order assignment represented by node w, whereas h * considers all atoms with at least one bond of unassigned bond order. For the atoms in this set, we compute the minimal atomic penalty possible under the current partial assignment independently of the other atoms in the set: each atom can choose its preferred value for each unassigned bond without considering overall consistency. Obviously, h * is optimistic. All three heuristics are implemented in our code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">The fixed-parameter approach (FPT)</head><p>In this approach, we consider each molecule as a molecule graph G = (U,E), where each vertex represents an atom and each edge represents a bond. Given a molecule graph that is a tree, the bond order assignment problem can be solved in polynomial time using dynamic programming. We omit the details, and concentrate on the more general case of graphs that are 'tree-like': A tree decomposition of G = (U,E) consists of an index set I, a set of bags X i ⊆ U for i ∈ I and a tree T with node set I such that:</p><p>(1) every vertex u ∈ U is contained in at least one bag X i ;</p><p>(2) for every edge {u,v}∈E, there is at least one bag X i such that u,v ∈ X i ;</p><p>(3) for two nodes i,k of the tree T , if u ∈ X i and u ∈ X k then u ∈ X j also holds for all nodes j of the tree along the path from i to k in T .</p><p>The width of this tree decomposition equals ω −1 for ω := max{|X i ||i ∈ I}−1. The treewidth of G is the minimum width of any tree decomposition of G. The treewidth of a tree equals one. Given a molecule graph G, we first compute a tree decomposition of G. We will see below that the running time and the required space of our algorithm grow exponentially with the width of the decomposition. Unfortunately, computing a tree decomposition with minimum width is again an NP-hard problem (<ref type="bibr" target="#b2">Arnborg et al., 1987</ref>). Fortunately, there exist heuristic and exact algorithms to compute such tree decompositions efficiently in practice (<ref type="bibr" target="#b6">Bodlaender et al., 2006;</ref><ref type="bibr" target="#b8">Gogate and Dechter, 2004</ref>). To simplify the description of our algorithm, we use nice tree decompositions: Here, we assume the tree T to be rooted. A nice tree decomposition is a tree decomposition satisfying:(1) Every node of T has at most two children.</p><p>(2) If a node i has two children j and k,</p><formula>then X i = X j = X k ;</formula><p>in this case, i is called a join node.</p><p>(3) If a node i has one child j, then one of the following two conditions must hold:</p><p>(a) |X i |=|X j |+1 and X j ⊂ X i ; in this case X i is called an introduce node.</p><p>(b) |X i |=|X j |−1 and X i ⊂ X j ; in this case X i is called a forget node.</p><p>Here, introduce nodes and forget nodes are viewed as moving bottom-up from the leaves to the root. We can easily transform a tree decomposition into a nice tree decomposition, in time linear in the size of the tree decomposition.<ref type="figure" target="#fig_3">Figure 2</ref>illustrates a tree decomposition and a corresponding nice tree decomposition of a graph. It can be easily verified that the union of all bags in the tree decomposition as well as all bags in the nice tree decomposition contains every vertex of the graph, and every edge of the graph exists in at least one bag of the tree decompositions. Furthermore, all bags sharing a common vertex induce a connected subgraph in the tree decomposition. The tree T is rooted at an arbitrary bag. Above this root, we add additional forget nodes, such that the new root contains a single vertex. Let X r denote the new root of the tree decomposition and v r denote the single vertex contained in X r. Analogously, we add additional introduce nodes under every leaf of T , such that the new leaf also contains a single vertex. Let</p><formula>X i ={a i,1 ,a i,2 ,...,a i,k }</formula><p>be the atoms inside bag X i , where k ≤ ω. In our presentation below, we want to avoid double indices, so we refer to the atoms inside bag X i as a 1 ,a 2 ,...,a k. It should be understood that these are different atoms for each bag. For simplicity of presentation, we also assume that the molecular subgraph induced by a 1 ,a 2 ,...,a k is fully connected and, thus, contains all bonds a 1 a 2 ,a 1 a 3 ,...,a k−1 a k. Let Y i denote the atoms in the molecule graph G that are contained in the bags of the subtree of T below bag X i. To save memory in the dynamic programming below, we will not use the bond order˜border˜ order˜b i,j between atoms a i ,a j but instead, the free bond order b i,j := ˜ b i,j −1 ∈{0,1,2}. Then, the valence of an atom is the sum of free bond orders over all incident bonds, plus the degree of the atom in the molecule graph. We assign a score matrix D i to each bag X i of the tree decomposition: let D i [v 1 ,...,v k ; b 1,2 ,<ref type="bibr">...,b k−1,k ]</ref>be the minimum score over all valence assignments to the vertices in Y i \X i if for every l = 1,...,k, v l valences of atom a l have been consumed by the atoms in Y i \X i , and free bond orders b 1,2 ,.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>..,b</head><formula>={a 1 ,...,a k } and X i ={a 1 ,...,a k−1 }. Then D i [v 1 ,...,v k−1 ; b 1,2 ,...,b k−2,k−1 ]= min b 1,k ,...,b k−1,k ∈{0,1,2} v k ∈{0,...,max{V (a k )}−deg(a k )} P a k ,v k +deg(a k )+ k l=1 b l,k +D j [v 1 −b 1,k ,...,v k−1 −b k−1,k ,v k ; b 1,2 ,...,b k−1,k ]</formula><p>(</p><formula>= X j = X h. Then D i [v 1 ,...,v k ;b 1,2 ,...,b k−1,k ]= min v l =0,...,v l for l=1,...,k D j [v 1 ,...,v k ; b 1</formula><p>,2 ,.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>..,b k−1,k ]</head><p>+D h [v 1 −v 1 ,...,v k −v k ; b 1,2 ,.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>..,b k−1,k ]</head><p>(7)</p><p>For simplicity of the presentation of our algorithm, we assumed above that every two vertices in each bag of the tree decomposition are connected by an edge, but in reality, the degree of a vertex in a molecule graph cannot exceed the maximum valence d ≤ 7 of an atom in the molecule graph. Therefore, the number of edges in a bag is upper bounded by ωd. Given a nice tree decomposition of a molecule graph G, the algorithm described above computes an optimal assignment for the bond order assignment problem on G in time O(α 2ω ·3 β ·ω ·m), where α = 1+max a∈A {maxV (a)} is the maximum (open) valence of an atom plus one, m and ω −1 are size and width of the tree decomposition, d is the maximum degree in the molecule graph, and<ref type="bibr">Böcker et al., 2009</ref>).</p><formula>β := min{ ω 2 ,ωd} (</formula><formula>D j [v 1 ,...,v k ;b 1,2 ,...,b k−1,k ] with v l + j b l,j &gt; maxV (a l</formula><p>) for some l, because such entries will never lead to a feasible bond order assignment. Furthermore, we find that the following trick speeds up our algorithm in practice: we initialize an integer k = 0 and do not store matrix entries with score exceeding k. If the score of the optimal solution is at most k, this optimal solution will be found. Otherwise, we call our algorithm again with increasing k, until an optimal solution is found. If not only the optimal solutions but also a certain number of suboptimal solutions are required, we call our algorithm repeatedly with increasing k, until all required suboptimal solutions are found Page: 623 619–625</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Automated bond order assignment</head><p>or k arrives its upperbound a∈A max v∈V (a) P(a,v). Further details can be found in (<ref type="bibr">Böcker et al., 2009</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>For proteins and DNA, bond orders can be simply inferred by matching the given state to a database containing the bond orders for all amino acids and nucleotides. Hence, we focus the evaluation of our algorithms on small and medium-sized molecules (for instance, drug-like molecules). Such molecules can be found in large numbers in several established ligand databases, such as ZINC (<ref type="bibr" target="#b15">Irwin and Shoichet, 2005</ref>), ASTEX (<ref type="bibr" target="#b22">Nissink et al., 2002</ref>), KEGG Ligand and KEGG Drug (<ref type="bibr" target="#b9">Goto et al., 2002</ref>), the MMFF94 validation suite (<ref type="bibr" target="#b11">Halgren, 1996</ref>) or the Cambridge Structural Database (<ref type="bibr" target="#b0">Allen, 2002</ref>). But evaluating the correctness of our bond order algorithms poses certain constraints: we need ligand structures that contain not only the connectivity information but also preassigned bond orders and explicit hydrogens. As a further requirement, aromatic bonds should be given in kekulized form, i.e. replaced by a suitable pattern of single and double bonds. In contrast to structure-based bond assignment approaches, however, we can use databases that contain 3D ligand structures as well as those only storing structure diagrams or SMILES expressions. To provide a diverse test dataset fulfilling those constraints, we chose the MMFF94 validation suite and the KEGG Drug Database to provide our ground truth. The MMFF94 validation suite (<ref type="bibr" target="#b11">Halgren, 1996</ref>) provides 761 small drug-like molecules, mainly derived from the Cambridge Structural Database (<ref type="bibr" target="#b0">Allen, 2002</ref>). The molecules were thoroughly prepared by the authors of the MMFF94 force field by assigning bond orders, adding hydrogens where valences had to be completed, and minimizing the resulting complexes. The MMFF94 validation suite was originally designed to test the MMFF94 force field parameters, and thus yields a diverse set of molecules with hand-curated connectivity information, hydrogens and bond order assignment and 3D positions that we found very reasonable for testing bond order perception. The KEGG Drug Database (<ref type="bibr" target="#b9">Goto et al., 2002</ref>), provided by the Kanehisa Laboratories, offers a remarkable number of drug-like molecules for diverse applications in bioinformatics. The atoms molecular coordinates are 2D, which is suitable for representation by structure diagrams, but is unsuited for structure-based bond order assignment as performed by most of the former approaches. It thus represents a perfect test scenario for bond order assignment from topology alone. Unfortunately, hydrogens are missing in the KEGG data bases, and were added for our tests using standard rules for completing free valences as performed by OpenBabel (<ref type="bibr" target="#b10">Guha et al., 2006</ref>). Furthermore, 2550 files of the KEGG Drug set contain more than one molecule, and each molecule may appear in more than one file. To prevent a skewed analysis, we split up the dataset into unique connected components. Ignoring molecules with less than four atoms (e.g. water), this preparation led to a test set of 7424 molecules from the KEGG drug set. In Section 4.1, we compare the total penalty score tps of the results of our exact solvers with that of the results of the original Antechamber approach. In Section 4.2, we compare the results of the different approaches to the expert generated, hand-crafted reference assignments and study the implications of the ambiguity of two or more co-optimal solutions. All algorithms—A*, ILP, FPT and Antechamber—are applied to the two test sets such as MMFF94 and KEGG Drug. Computing all optimal solutions for all 761 molecules of the MMFF94 dataset, the total running time was 252.0 s for the ILP, 227.1 s for the A* algorithm and 24.9 s for the FPT algorithm. The antechamber heuristic took 7.9 s to compute one solution for all molecules (cf. Supplementary Material). All reported running times were averaged over 20 repetitions. Thus, the ability to provide all optimal exact solutions and to use user-editable SMARTS strings for penalty class assignment takes its toll: the heuristic antechamber approach is the fastest of the methods, about an order of magnitude faster than ILP and A*. Still, all running times are sufficiently small to allow the routine usage in high-throughput applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Comparison to Antechamber</head><p>In order to evaluate whether solving the optimization exactly makes a difference in practice, we first focus on the following properties:</p><p>(1) how often do manual, heuristic and exact approaches produce an optimally scored solution;</p><p>(2) how often do the exact approaches find a solution with a smaller tps than the heuristic;Evaluation on the MMFF94 validation suite (761 molecules in total) was done as follows: the Antechamber bond perception algorithm as well as our own algorithms—A*, ILP and FPT—were run for each input molecule. Note that all exact algorithms will in principle compute the same solutions, and only the order of cooptimal solutions can differ. If both Antechamber and our algorithms computed bond order assignments (i.e. none of the approaches failed), we compared these to test if the Antechamber assignment is optimal. For 734 molecules (96.45%), the solution found by the heuristic Antechamber approach is optimal. For nine molecules (1.18%), the exact algorithms indeed find bond order assignments with a total penalty score less than that of the solution provided by Antechamber (cf. the Supplementary Material). For 14 cases (1.83%), our algorithms computed an optimal bond order assignment, whereas the heuristic Antechamber bailed out. In four cases (0.53%), neither Antechamber nor our algorithms computed a bond order assignment, due to missing atom types in the penalty table. In no case, Antechamber computed a solution but our algorithms did not. In total, Antechamber bailed out in 18 cases (2.30%), and in 23 cases (3.02%) we improved upon Antechamber (no solution by Antechamber or better solution by our algorithms). The comparison of our algorithms to the Antechamber approach on the KEGG Drug set (7424 molecules in total) looks very similar. For 7202 molecules (97.01%), the bond order assignment found by Antechamber is optimal. For 13 molecules (0.18%) containing PO 4 , Antechamber reproducibly provided infeasible solutions, whereas our algorithms computed optimal assignments. For 27 cases (0.36%), our algorithms computed an optimal assignment but Antechamber bailed out. In 180 cases (2.42%), both approaches bailed out, as not all atom types are contained in the original penalty table given in<ref type="bibr" target="#b24">Wang et al. (2006)</ref>. In total, Antechamber bailed out in 207 cases (2.79%), and we improved upon Antechamber in 40 cases (0.54%).A complete comparison for both test sets is given in<ref type="figure" target="#tab_1">Table 1</ref>. Please note that the test datasets were chosen such that they are relatively wellsuited to the heuristic Antechamber approach, e.g. they contain relatively few large or complex ring systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Page: 624 619–625</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.K.Dehof et al.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Comparison to reference assignments</head><p>As a second step in the analysis, we compare the results produced by all approaches to the reference assignment. For our own solvers, which are able to enumerate all optimal (FTP, ILP) or even all feasible solutions (A*), we only recorded the first one. As can be seen in<ref type="figure" target="#tab_2">Table 2</ref>, our methods are able to significantly reproduce more bond order assignments of the MMFF94 validation suite than the original Antechamber approach. While Antechamber correctly recomputed 37.05% of the molecules, the exact methods reconstructed between 53.88% and 61.89% of the reference bond order assignments as the first solution. Similar results can be seen on the KEGG Drug set: Antechamber correctly reproduced 41.96% of the bond order assignments, compared to 49.95–56.9% for the exact methods. Obviously, all results returned by the exact solvers are optimal and hence, the differences in these numbers are due to systematic differences in the order in which each algorithm enumerates the solutions. In the case of the A* algorithm, this order can easily be tweaked by adapting the heuristic part of the scoring functions. By design, our A* heuristics tend to avoid the occurrences of larger bond orders, but this strategy could be further fine tuned. Note that the FPT algorithm can easily be modified to simulate this behaviour, as computing all optimal solutions does not significantly increase running times. For the ILP approach, in contrast, running times would increase considerably. In future, we plan to sort cooptimal solutions with respect to another objective function before writing the output. This might possibly further increase the quality of our results, and is the topic of ongoing research. Considering that bond order assignments need not be unique, it makes sense to provide the user not only with the first solution but with all optimal ones (or even some suboptimal ones). In this case, taking all optimal solutions into account, we find that our algorithms find the reference solution in 78.71% of the cases on the MMFF94 validation suite and in 85.21% on the KEGG Drug set. A complete comparison is given in<ref type="figure" target="#tab_2">Table 2</ref>. Obviously, the performance of all approaches is limited by the quality of the penalty table: the definition of the atom classes, their allowed valence states, and the choice of the valence state's penalties have a significant influence on the performance. As can be seen inThe third column denotes the number of molecules for which the algorithms return the original bond order assignment as first solution, the fourth column the number of molecules for which the algorithms return it at as any of their optimal solutions.<ref type="figure" target="#tab_1">Table 1</ref>, the current penalty table does not cover all molecules in the reference datasets—for four molecules in the MMFF94 set and for 180 in the KEGG set, the required atom classes are missing. Hence, in our own implementations, we use SMARTS expressions stored in an XML file to define the penalty classes, which allows a user to easily add atom types or tune the results to his needs. To guarantee a fair comparison between the solvers, we ensured that for all tests in this article, our implementation used exactly the same penalty classes as Antechamber. Improvements to the penalty table, and a systematic study of their influence, are the focus of future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>Automated bond order assignment is an important problem when working with user-generated molecules, molecular databases or computational combinatorial chemistry. Especially fully automated pipelines in high-throughput applications depend on reliable bond order assignments. The modern and extensible approach realized in Antechamber is based on sound chemical principles and has proven to be a very valuable tool. In this work, we have shown three different exact solvers as alternatives to the heuristic approach pursued by<ref type="bibr" target="#b24">Wang et al. (2006)</ref>: an A* algorithm, an ILP formulation and a fixed parameter approach. While we found in our evaluations that the heuristic solver works surprisingly well—roughly 97% of all cases in our tests—it still can be significantly improved using exact techniques. If we keep in mind that bond order assignments are in many cases non-unique—different resonance structures, for instance, might have the same probability to occur—the ability to systematically enumerate all solutions becomes an invaluable tool. When bond order assignments are important, it might be worthwhile to enumerate all optimal assignments, run whatever procedure is supposed to work with the results in the next step, and average over the results. Comparing the three different exact strategies, each of them has its advantages and disadvantages. If computational efficiency is required, the best choice is clearly the FPT, where running times are almost on par with the Antechamber heuristic. The A* algorithm, on the other hand, is even simpler to implement than the heuristic and can be very easily extended through the heuristic cost function. Both approaches can compute co-optimal</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Page: 625 619–625</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Automated bond order assignment</head><p>and sub-optimal solutions without significantly increasing running times, and geometric information can be employed to provide a more sensible ordering of the results. The ILP approach, finally, is trivial to implement when external solvers can be used. However, enumerating all solutions requires a certain sophistication and can easily spoil the running time. An additional advantage of our methods is their easy extensibility. For example, adding missing hydrogens or even bonds is possible but will require more elaborate, e.g. structure based, scoring to handle the exponential number of combinations. Such a scoring scheme only requires modifications of the tps definition. Algorithmically, the bond order assignment problem bears close resemblance to the side chain optimization problem, where similar solution strategies have been developed<ref type="bibr" target="#b1">[Althaus et al. (2002)</ref>; Leach and Lemon (1998);<ref type="bibr" target="#b25">Xu et al. (2005)]</ref>. Future work will study whether modern probabilistic approaches [see, e.g.<ref type="bibr" target="#b26">Yanover et al. (2008)]</ref>for this problem will also be appropriate for bond order assignment.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.</head><figDesc>Fig. 1. Top: different co-optimal bond order assignments. In the left structure, both NH 2 groups are connected via a single bond and thus freely rotatable. In the middle and right structure, one group is connected via a double bond. Bottom: heuristic and optimal bond order assignments. The left structure is the solution provided by Antechamber with a tps of 4. Its 5-ring does not fulfill the aromaticity criterion of AM1-BCC (Jakalian et al., 2002). The right structure is the solution computed with our exact solvers. Its tps is 0 and the 5-ring meets the AM1-BCC aromaticity criterion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>[14:36 2/2/2011 Bioinformatics-btq718.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.2.</head><figDesc>Fig. 2. A graph (top left) with a tree decomposition (bottom left) and a corresponding nice tree decomposition (right). Dashed lines illustrate connected components sharing common vertices.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>We implemented our algorithm in Java and used the method QuickBB in the library LibTW implemented by van Dijk et al. (http://www.treewidth. com) to compute the optimal tree decomposition of a molecule graph. After computing the optimal tree decomposition, we transformed it into a nice tree decomposition. Running times reported for the fixed-parameter approach (FPT) algorithm include the running times of computing the optimal nice tree decomposition. To save memory, we use hash maps instead of arrays to implement score matrices D. During the course of the dynamic programming algorithm, we do not have to compute or store entries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>(3)</head><figDesc>how often does each approach fail to find a feasible solution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>k−1,k are assigned to bonds a 1 a 2 ,a 1 a 3 ,...,a k−1 a k. Using this definition, we delay the scoring of any vertex to the forget node where it is removed from a bag. We can compute the minimum score among all assignments using the root bag X r ={a r } as min vr ∈V (ar ) {P(a r ,v r )+D r [v r ]}. Our algorithm begins at the leaves of the tree decomposition and computes the score matrix D i for every node X i when score matrices of its children nodes have been computed. We initialize the matrix D j of each leaf X j ={a 1 } with D j [v 1 ;·] = 0 if v 1 = 0, and D j [v 1 ;·] = ∞ otherwise. During the bottomup traversal, the algorithm distinguishes if X i is a forget node, an introduce node or a join node, and computes D i as follows: Introduce nodes: let X i be the parent node of X j such that X j = {a 1 ,...,a k−1 } and X i ={a 1 ,...,a k }. Then D i [v 1 ,...,v k ;b 1,2 ,...,b k−1,k ]= D j [v 1 ,...,v k−1 ; b 1,2 ,...,b k−2,k−1 ] if v k = 0, ∞ otherwise. (5) Forget nodes: let X i be the parent node of X j such that X j</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>6) where deg(a k ) denotes the degree of vertex a k. Join nodes: let X i be the parent node of X j and X h such that X i</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><figDesc>Table 1. Comparison of our exact solvers with the original heuristic implementation of Antechamber and the expert generated solutions ('reference solution') for the molecules of the MMFF94 validation set and the KEGG Drug set</figDesc><table>MMFF94 (%) 
KEGG (%) 

Heuristic solution is optimal 
734 
(96.45) 
7202 
(97.01) 
Heuristic solution is suboptimal 
9 
(1.18) 
15 
(0.20) 
Heuristic found no feasible solution 
18 
(2.37) 
207 
(2.79) 
Exact solvers found no feasible 
solution 

4 
(0.53) 
180 
(2.42) 

Optimal solution agrees with 
reference 

599 
(78.71) 
6326 
(85.21) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 2. Performance of the original Antechamber implementation and our exact solvers on the test sets using the penalty table as defined in Wang et al. (2006)</figDesc><table>Test set 
Method 
Reference is first 
Solver reproduces 
solution (%) 
reference (%) 

Antechamber 
282 (37.05) 
282 (37.05) 
MMFF94 
ILP 
471 (61.89) 
A  *  
455 (59.79) 
599 (78.71) 
FPT 
410 (53.88) 

Antechamber 
3115 (41.96) 
3115 (41.96) 
KEGG 
ILP 
4224 (56.90) 
A  *  
3708 (49.95) 
6326 (85.21) 
FPT 
3777 (50.88) 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENT</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">The Cambridge Structural Database: a quarter of a million crystal structures and rising</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<forename type="middle">H</forename>
				<surname>Allen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Crystallogr. B</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="380" to="388" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
	<note>Pt. 3 Pt 1</note>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">A combinatorial approach to protein docking with flexible side chains</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Althaus</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="597" to="612" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Complexity of finding embedding in a k-tree</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Arnborg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Algebra. Discr</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="277" to="284" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Automatic assignment of chemical connectivity to organic molecules in the cambridge structural database</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">C</forename>
				<surname>Baber</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">E</forename>
				<surname>Hodgkin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Chem. Inform. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="401" to="406" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Announcing the worldwide protein data bank</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Berman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Struct. Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">980</biblScope>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Computing bond types in molecule graphs</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Böcker</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Computing and Combinatorics Conference</title>
		<meeting>Computing and Combinatorics Conference</meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="297" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<monogr>
		<title level="m" type="main">On exact algorithms for treewidth</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">L</forename>
				<surname>Bodlaender</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
			<pubPlace>Utrecht, Netherlands</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Correct bond order assignment in a molecular framework using integer linear programming with application to molecules where only non-hydrogen atom coordinates are available</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Froeyen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Herdewijn</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Chem. Inf. Model</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="1267" to="1274" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">A complete anytime algorithm for treewidth</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Gogate</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Dechter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">UAI &apos;04: Proceedings of the 20th conference on Uncertainty in Artificial Intelligence</title>
		<meeting><address><addrLine>Arlington, Virginia</addrLine></address></meeting>
		<imprint>
			<publisher>AUAI Press</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="201" to="208" />
		</imprint>
	</monogr>
	<note>United. States</note>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">LIGAND: database of chemical compounds and reactions in biological pathways</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Goto</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="402" to="404" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">The blue obelisk-interoperability in chemical informatics</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Guha</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Chem. Inf. Model</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="991" to="998" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">MMFF VI. MMFF94s option for energy minimization studies</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Halgren</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comp. Chem</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="490" to="519" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">A formal basis for the heuristic determination of minimum cost paths</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">E</forename>
				<surname>Hart</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Syst. Sci. Cybernetics SSC4</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="100" to="107" />
			<date type="published" when="1968" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">BALI: automatic assignment of bond and atom types for protein ligands in the brookhaven protein databank</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Hendlich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Chem. Inform. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="774" to="778" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">BALL-Biochemical Algorithms Library 1.3</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Hildebrandt</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">531</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">ZINC–a free database of commercially available compounds for virtual screening</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">J</forename>
				<surname>Irwin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">K</forename>
				<surname>Shoichet</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Chem. Inf. Model</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="177" to="182" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast, efficient generation of high-quality atomic charges. AM1-BCC model: II. parameterization and validation</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Jakalian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Chem</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="1623" to="1641" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">BALL–rapid software prototyping in computational molecular biology</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Kohlbacher</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">P</forename>
				<surname>Lenhof</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="815" to="824" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">On the perception of molecules from 3D atomic coordinates</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Labute</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Chem. Inf. Model</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="215" to="221" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Automatic assignment of bond orders based on the analysis of the internal coordinates of molecular structures</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Lang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Anal. Chim. Acta</title>
		<imprint>
			<biblScope unit="volume">265</biblScope>
			<biblScope unit="page" from="283" to="289" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Exploring the conformational space of protein side chains using dead-end elimination and the A* algorithm</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">R</forename>
				<surname>Leach</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">P</forename>
				<surname>Lemon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="227" to="239" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">BALLView: a tool for research and education in molecular modeling</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Moll</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="365" to="366" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">A new test set for validating predictions of protein-ligand interaction</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">W M</forename>
				<surname>Nissink</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="457" to="471" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Combinatorial Optimization: Algorithms and Complexity United States PRODRG, a program for generating molecular topologies and unique molecular descriptors from coordinates of small molecules</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">H</forename>
				<surname>Papadimitriou</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Steiglitz</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">M</forename>
				<surname>Aalten</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Courier Dover Publications J. Comput. Aided Mol. Des</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="255" to="262" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Automatic atom type and bond type perception in molecular mechanical calculations</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Graph. Model</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="247" to="260" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">A tree-decomposition approach to protein structure prediction</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Xu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. IEEE Comput. Syst. Bioinform. Conf</title>
		<imprint>
			<biblScope unit="page" from="247" to="256" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Minimizing and learning energy functions for side-chain prediction</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Yanover</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="899" to="911" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Automatic perception of organic molecules based on essential structural information</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Zhao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Chem. Inf. Model</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="1379" to="1385" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>