
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:51+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SEQuel: improving the accuracy of genome assemblies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Roy</forename>
								<surname>Ronen</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Bioinformatics Graduate Program</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Christina</forename>
								<surname>Boucher</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>San Diego, La Jolla</addrLine>
									<postCode>92093</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Hamidreza</forename>
								<surname>Chitsaz</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Wayne State University</orgName>
								<address>
									<postCode>48202</postCode>
									<settlement>Detroit</settlement>
									<region>MI</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Pavel</forename>
								<surname>Pevzner</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>San Diego, La Jolla</addrLine>
									<postCode>92093</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">SEQuel: improving the accuracy of genome assemblies</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="188" to="196"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts219</idno>
					<note>Copyedited by: GS MANUSCRIPT CATEGORY: [16:44 29/5/2012 Bioinformatics-bts219.tex] Page: i188 i188–i196 BIOINFORMATICS Contact: ppevzner@cs.ucsd.edu</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Assemblies of next-generation sequencing (NGS) data, although accurate, still contain a substantial number of errors that need to be corrected after the assembly process. We develop SEQuel, a tool that corrects errors (i.e. insertions, deletions and substitution errors) in the assembled contigs. Fundamental to the algorithm behind SEQuel is the positional de Bruijn graph, a graph structure that models k-mers within reads while incorporating the approximate positions of reads into the model. Results: SEQuel reduced the number of small insertions and deletions in the assemblies of standard multi-cell Escherichia coli data by almost half, and corrected between 30% and 94% of the substitution errors. Further, we show SEQuel is imperative to improving single-cell assembly, which is inherently more challenging due to higher error rates and non-uniform coverage; over half of the small indels, and substitution errors in the single-cell assemblies were corrected. We apply SEQuel to the recently assembled Deltaproteobacterium SAR324 genome, which is the first bacterial genome with a comprehensive single-cell genome assembly, and make over 800 changes (insertions, deletions and substitutions) to refine this assembly. Availability: SEQuel can be used as a post-processing step in combination with any NGS assembler and is freely available at http://evpedia.info.
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The advent of next-generation sequencing (NGS) technologies, along with the development of new assembly algorithms has enabled the production of genome assemblies for a multitude of organisms at ever-decreasing costs (<ref type="bibr" target="#b13">Huang et al., 2009;</ref>). Robust assembly methods are imperative to the success of large de novo sequencing initiatives, such as the Genome 10K project that aims to sequence the genomes of 10 000 vertebrate species (Genome 10K Community of<ref type="bibr">Scientists, 2009</ref>) and the iK5 project where the objective is to sequence the genomes of 5 000 arthropods (<ref type="bibr" target="#b29">Robinson et al., 2011</ref>). NGS technologies produce short sequence reads [approximately 100–150 base pairs (bp) for Illumina technology] at increasingly high throughput, permitting assembly methods suited to these technologies to exploit the redundancy in the data in order to produce high-quality contigs (<ref type="bibr">Bankevich et al., 2008;</ref><ref type="bibr" target="#b33">Wheeler et al., 2008</ref>). Although these platforms have much higher throughput than Sanger sequencing platforms, assessment of short-read assemblies have shown them to be less accurate than the † The authors wish it to be known that, in their opinion, the first two authors should be regarded as joint First Authors. * To whom correspondence should be addressed.</p><p>finished genomes assembled using the previous technologies (<ref type="bibr" target="#b0">Alkan, et al., 2011</ref>). Earlier assembly algorithms developed for Sanger sequencing follow an 'overlap-layout-consensus' paradigm, where consensus refers to fixing errors in the contigs (<ref type="bibr" target="#b8">Ewing and Green, 1998;</ref><ref type="bibr" target="#b8">Ewing et al., 1998</ref>). Since this paradigm faces difficulties in short-read assembly, most NGS assemblers employ a de Bruijn graph approach that effectively deals with large amounts of data. However, most NGS assemblers neglect the consensus step, i.e. there exists no post-processing of the contigs in Velvet (<ref type="bibr" target="#b34">Zerbino et al., 2008</ref>) and many other popular assemblers. Relying on high and uniform coverage, NGS assembly algorithms push the burden of producing high-quality assemblies onto the construction of the de Bruijn graph. We argue that NGS assemblers can benefit from the use of a consensus step, particularly in the case of single-cell data that suffers from high error rates and non-uniform coverage (<ref type="bibr" target="#b4">Chitsaz et al., 2011</ref>). In the spirit of the consensus step, we propose an additional step to the NGS assembly process: refinement. We develop SEQuel, a tool that refines an initial assembly of short-read data by using approximate positions of reads in contigs. SEQuel takes as input an assembled contig, the paired-end reads that align to that contig and the approximate positions where they aligned, and returns a refined contig. We refer to the process implemented by SEQuel as positional reassembly. In Eulerian assembly (<ref type="bibr" target="#b14">Idury and Waterman, 1995;</ref><ref type="bibr" target="#b27">Pevzner et al., 2001</ref>), a de Bruijn graph is constructed with a vertex v for every (k −1)-mer present in a set of reads, and an edge (v,v ) for every observed k-mer in the reads with (k −1)-mer prefix v and (k −1)-mer suffix v. A contig corresponds to a non-branching path through this graph. See<ref type="bibr" target="#b5">Compeau et al. (2011)</ref>for a more thorough explanation of de Bruijn graphs and their use in assembly. Euler-SR (<ref type="bibr" target="#b25">Pevzner et al., 2008</ref>), Velvet (<ref type="bibr" target="#b34">Zerbino et al., 2008</ref>), SOAPdenovo (), ABySS (<ref type="bibr" target="#b31">Simpson et al., 2009</ref>) and ALLPATHS (<ref type="bibr" target="#b3">Butler et al., 2008</ref>) all use this paradigm for assembly. Most existing NGS assemblers follow the same general outline: break the (possibly error corrected) reads into k-mers, construct the de Bruijn graph on the set of resulting k-mers, simplify the de Bruijn graph, resolve repeats by using mate–pair information and construct contigs. Although the implementation of these steps varies widely between different assemblers, existing NGS assemblers return contigs recovered from the de Bruijn graph with little refinement. If every position in the genome was uniformly covered by errorfree reads, and the genome had few repeats, this would result in a simple de Bruijn graph. However, sequencing errors and repeats lead to highly complex graphs and force assemblers to rely on graph simplification. It is during this simplification process that errors in the assembly are introduced. Substitution errors and indels in the reads create undirected cycles called bulges and short tandem repeats lead to directed cycles called whirls (<ref type="bibr" target="#b26">Pevzner et al., 2004</ref>). There exist numerous methods for removing bulges and whirls SEQuel<ref type="figure">Fig. 1</ref>. An example of a bulge on eight vertices in a de Bruijn graph (k = 4) resulting from a sequencing error. During the process of bulge removal, the correct path (top: CCT-CTA-TAG-AGG-GGA) may be discarded, thus creating a substitution error in the final contig. This may occur if, for example, coverage is taken as a consideration, since the bottom path (CCT-CTT-TTGTGG-GGA), erroneous in this case, may have higher coverage due to k-mers originating from other parts of the genome but unfortunately, these methods potentially introduce errors in the contigs.<ref type="figure">Figure 1</ref>illustrates a scenario where a bulge in the de Bruijn graph is caused due to a sequencing error. Error correction of the reads prior to assembly can greatly simplify the assembly process by implicitly eliminating bulges from the de Bruijn graph (<ref type="bibr" target="#b16">Kelley et al., 2010;</ref><ref type="bibr">Medvedev et al., 2011;</ref><ref type="bibr" target="#b25">Pevzner et al., 2008</ref><ref type="bibr" target="#b27">Pevzner et al., , 2001</ref>). It is now established as a common pre-processing step before assembly, and used by several NGS assemblers, including Euler-SR (<ref type="bibr" target="#b25">Pevzner et al., 2008</ref>), ABySS (<ref type="bibr" target="#b31">Simpson et al., 2009</ref>) and ALLPATHS (<ref type="bibr" target="#b3">Butler et al., 2008</ref>). Although error correction eliminates the majority of errors in reads, in ∼1% of the cases it introduces, rather than corrects, errors (<ref type="bibr" target="#b25">Pevzner et al., 2008</ref>). This leads to the following trade-off in fragment assembly: either error correction of reads is performed, which may lead to errors in the contigs, or error correction is not performed and the complex de Bruijn graph has to undergo aggressive simplification that may lead to errors in the contigs. It is clear, however, that in both cases subtle and complex errors will arise. The accuracy of different assemblers varies widely. For example, our tests of Velvet produced contigs with 1–2 errors per 100 kb (for k-mer size 55), while SOAPdenovo produced contigs with 20–30 errors per 100 kb. Even the accuracy of Velvet deteriorates greatly when used in default mode with k-mer size 31. However, SOAPdenovo has some advantages over Velvet (e.g. the ability to handle larger genomes). Therefore, it is beneficial to design a refinement program that can be used in combination with any assembler. Decoupling the contig refinement problem from the assembly process removes the burden of re-implementing a positional reassembly process for each assembler. We show that NGS assemblies suffer from indels and substitution errors that are somewhat masked by common metrics for assessing assembly quality. Many of these errors can be corrected using SEQuel. We give an analysis of the types of complex errors that occur in NGS assembly, and that can be fixed by SEQuel, offering some insight into why positional reassembly is a necessity for obtaining accurate assemblies. We give a computational problem formulation for correcting errors in contigs, and present an algorithm for reassembly based on a graph structure referred to as the positional de Bruijn graph. We demonstrate the ability of SEQuel to improve the accuracy of assemblies generated from three assemblers: Euler-SR (<ref type="bibr" target="#b25">Pevzner et al., 2008</ref>), Velvet (<ref type="bibr" target="#b34">Zerbino et al., 2008</ref>) and Velvet-SC (<ref type="bibr" target="#b4">Chitsaz et al., 2011</ref>). Euler-SR performs error correction on the sequence reads prior to assembly (<ref type="bibr" target="#b25">Pevzner et al., 2008</ref>), whereas Velvet does not perform error correction (<ref type="bibr" target="#b34">Zerbino et al., 2008</ref>). Velvet-SC is a specialized assembler tailored to handle the dramatic fluctuations in coverage that are characteristic to single-cell data (<ref type="bibr" target="#b4">Chitsaz et al., 2011</ref>). Single-cell amplified DNA has been shown to suffer from amplification bias and low template quality (<ref type="bibr" target="#b4">Chitsaz et al., 2011;</ref><ref type="bibr" target="#b28">Raghunathan et al., 2005;</ref><ref type="bibr" target="#b30">Rodrigue et al., 2009</ref>), resulting in sequence data with highly non-uniform coverage by error-prone reads (<ref type="bibr" target="#b28">Raghunathan et al., 2005</ref>). Thus, assembly of such data is inherently more challenging and error-prone. Our experiments demonstrate that SEQuel is able to substantially reduce the number of errors in single-cell, and standard (multi-cell) assembly. Although we demonstrate the use of SEQuel with Euler-SR, Velvet and Velvet-SC, its use is not limited to these assemblers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">THE CONTIG REFINEMENT PROBLEM</head><p>We formalize the contig refinement problem and present an algorithm for positional reassembly that relies on the positional de Bruijn graph. A similar graph was previously proposed by<ref type="bibr" target="#b11">Hannenhalli et al. (1996)</ref>for Sequencing By Hybridization. Contrary to the de Bruijn graph where edges correspond to k-mers, the edges of the positional de Bruijn graph correspond to k-mers and their inferred positions on the contigs. Fragment assembly in the de Bruijn graph framework is often abstracted as a problem of finding a shortest string that explains the set of all k-mers from the reads, i.e. the Shortest Common Superstring Problem. We formulate the contig refinement problem in a similar manner; that is, as finding a string that explains all occuring positional k-mers. While both abstractions are limited in that they do not adequately address the assembly of repeat regions, they prove to be conceptually useful. The input to the contig refinement problem is the set of k-mers used to assemble a contig, and for each k-mer a position (or positions) where it is presumably contained in the contig, i.e. a multiset of pairs (s k ,p), where s k is a k-mer and p is the approximate position. We refer to these k-mer and position pairs (s k ,p) as positional k-mers. Given a parameter , we call a positional k-mer (s k ,p) valid with respect to a string S if s k appears in S at a position that is within of p. The contig refinement problem: given a multiset of positional k-mers and a parameter , find a shortest string S that maximizes the total number of valid positional k-mers. Due to indels in the contigs (relative to the genome), we expect the positions of k-mers in the assembled contig to differ from their positions in the correct contig. Therefore, since our goal is to assemble the correct contig, we assume the positions are an approximation to the position in the correct contig. Next, we demonstrate how positional information may be incorporated into the de Bruijn graph and used to refine contigs by positional reassembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R.Ronen and C.Boucher et al.</head><p>While the description of the method below is for a single contig, in practice it is applied to all contigs of an assembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Recruitment of reads to contigs</head><p>We refer to a read-pair as permissively aligned to a contig if either one or both of the reads in the read-pair uniquely align to a single contig in the assembly. If only one read aligns, the approximate position of the unaligned read is deduced using the expected insert size. After assembly, we extract the set of reads that permissively align to the contig and their approximate positions, which is then used in the construction of the positional de Bruijn graph. This is performed using BWA (version 0.5.9) in paired-end mode with default parameters (<ref type="bibr" target="#b19">Li et al., 2009</ref>), allowing detection of alignments with small indels as well as read-pairs where only one read is aligned. Although some assemblers (e.g. Velvet) output the assignment of reads to contigs, we obtain better refinement results using BWA. We note that using only the set of permissively aligned reads will lead to reduced coverage in certain regions, however, we see only a modest decline in average coverage and very few regions where coverage was significantly reduced (for bacterial genomes). Thus, the accuracy of SEQuel is improved at the expense of correcting fewer errors in these regions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Construction of the positional de Bruijn graph</head><p>From the set of reads that permissively aligned to the contig, we construct the set of positional k-mers. If a read r =[r 1 ...r n ] of length n is aligned to a contig at position i, we extract n−k +1 positional k-mers from r:</p><formula>[r 1 ...r k ],i , [r 2 ...r k+1 ], i +1 , ..., [r n−k+1 ...r n ]</formula><p>, i +n−k . We emphasize that different reads may give rise to the same k-mer with different inferred positions. Consequently, we cluster by position all positional k-mers that have the same k-mer sequence, and use the cluster centers when constructing the positional de Bruijn graph. This is a onedimensional clustering problem, where single-linkage clustering performs well. We refer to the multiplicity of a positional k-mer (s k ,p) as the number of occurrences where s k clustered at position p. For example, if the k-mer ACTA aligned to positions (42,43,43,44), and the corresponding positional k-mers all cluster to (ACTA,43), then the multiplicity of this positional k-mer equals 4. SEQuel removes clusters of low multiplicity since they are likely to represent erroneous k-mers. Lastly, the positional de Bruijn graph is constructed from the positional k-mers, as described below. The positional de Bruijn graph G k,, is defined for a multiset of positional k-mers and parameter , and is constructed in a similar manner to the traditional de Bruijn graph using an ABruijn graph framework from (<ref type="bibr" target="#b26">Pevzner et al., 2004</ref>). Given a k-mer s k , let prefix(s k ) be the first k −1 nucleotides of s k , and suffix(s k ) be the last k −1 nucleotides of s k. Each positional kmer (s k ,p) in the input multiset corresponds to a directed edge in the graph between two positional (k −1)-mers, (prefix(s k ),p) and (suffix(s k ),p+1). After all edges are formed, the graph undergoes a gluing operation. A pair of positional (k −1)-mers,</p><formula>(s k−1 ,p) and (s k−1 ,p</formula><p>), are glued together into a single vertex if s k−1 = s k−1 and p ∈[p −,p +]. Hence, two positional (k −1)-mers are glued together if their sequences are the same and their positions are within from each other. Finally, each edge is weighted by the multiplicity of the corresponding positional k-mer. In<ref type="figure">Figure 2</ref>, we show an example of a positional de Bruijn graph and a de Bruijn graph constructed from the same dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Whirl removal in the positional de Bruijn graph</head><p>Due to the fact that the positional de Bruijn graph is built on a substantially smaller dataset (i.e. only reads that permissively align to a certain contig) and incorporates the approximate position of each k-mer in the contig, it is significantly less complex than the standard de Bruijn graph for the same contig and far less complex than the de Bruijn graph of an entire assembly. The relative simplicity of the graph is important since it decreases the ambiguities associated with bulge and whirl removal. While whirls are a substantial problem in the de Bruijn graph, the occurrence of whirls in the positional de Bruijn graph is extremely rare; the number of whirls encountered by SEQuel while refining the assemblies of Escherichia coli with Euler-SR, Velvet and Velvet-SC was less than five for each assembly. Nonetheless, the occurrence of whirls is possible. We follow the whirl processing algorithm from<ref type="bibr" target="#b26">Pevzner et al. (2004)</ref>, since the logic of whirl processing in the positional de Bruijn graph is similar to that in the de Bruijn graph. Bulges are implicitly removed in the next step of the SEQuel algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Refined contig construction</head><p>The final step of SEQuel is to refine the original contig using the positional de Bruijn graph. We note that since only permissively aligned reads were used to construct the positional de Bruijn graph (rather than the complete set of reads) the graph may be disconnected, leading to the construction of several contiguous sequences. These smaller contiguous sequences may not cover the original contig entirely. However, this does not pose a problem because we are using these sequences to refine the original contig. We find the heaviest path in each of the connected components and construct the contiguous sequences corresponding to these paths. As previously mentioned, the weight of each edge is equal to the multiplicity of the corresponding positional k-mer and therefore, the heaviest path 'explains' the largest number of positional k-mers. We refer to the sequences constructed from the positional de Bruijn graph as partial contigs and denote the set of partial contigs as</p><formula>{c 1 ,c 2 ,...,c n }.</formula><p>The average weight of a partial contig is defined as the mean edge weight of the corresponding path. The partial contigs will be used to refine the original contig, denoted as C. Lastly, we denote the refined contig that is ultimately output as C r. In order to describe how C is refined using {c 1 ,c 2 ,...,c n } we need some additional notation. We denote u@BULLETv as the concatenation of strings u and v. Given a local alignment of strings</p><formula>u =[u 1 ...u n ] and v =[v 1 ...v m ]</formula><p>, where (i,i ) and (j,j ) are the respective start and end positions of the alignment on u and v, we denote u⊕v as u[1...</p><formula>(i −1)]@BULLETv[j...j ]@BULLETu[(i +1)...n]</formula><p>. The refinement process starts by setting C r equal to C. Next, for each partial contig c i ∈{c 1 ,c 2 ,...,c n }, we let C r be equal to C r ⊕c i. The order in that partial contigs are used to refine C r is important because the alignments of several partial contigs to C r may overlap. In positions where such an overlap occurs, any changes from previously used partial contigs will be overwritten by the last. When coverage is uniform we process the partial contigs in order of increasing length, however, when it is highly non-uniform we process them in order of increasing average weight. In both cases, ties are broken arbitrarily and alignments below a certain length<ref type="figure">Fig. 2</ref>. An example illustrating the positional de Bruijn graph (k = 4,, = 1) and de Bruijn graph on a set of aligned reads, with their corresponding sets of k-mers and positional k-mers. There exists a single sequencing error in the reads (shown in red). In the de Bruijn graph, the (k −1)-mer GCC appears as a single vertex, whereas, the positional de Bruijn graph separates the occurrence of GCC into two vertices. This additional information incorporated into the graph further constraints the gluing process and reduces complexity. Further, the positional k-mers (GCCT, 111) and (GCCT,975) have multiplicity 1 and 4, respectively, but the k-mer GCCT has multiplicity 5. This increases the weight of the incorrect path, and thus the likelihood of an error in the contig produced by the de Bruijn graph. Lastly, we note that in this example no vertex gluing operations occur but in more complex instances, vertex gluing will occur when equal k-mers align at adjacent positions are not considered. Thus, SEQuel has two user-defined modes corresponding to the described scenarios: standard and single-cell mode.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SEQuel</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Software implementation</head><p>SEQuel is implemented in Java 6.0, and can optionally be run as a multi-threaded application. All tests were performed on a PC with 32 cores (64-bit, 2.27 GHz) and 512 GB of RAM running Linux. Although benchmarking was performed on this computer, SEQuel can be run on a standard desktop; see Section 4.5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Datasets</head><p>In order to evaluate the performance of SEQuel, we use three different datasets described in<ref type="bibr" target="#b4">Chitsaz et al. (2011)</ref>. All datasets consist of paired-end 100 bp reads from E.coli, generated by Illumina, Inc. on the Genome Analyzer (GA) IIx platform. The first dataset consists of approximately 27 million paired-end reads, and was obtained from the NCBI Short Read Archive (accession ERA000206, EMBL-EBI Sequence Read Archive). As a measure of quality assurance, we aligned the reads to the E.coli genome using BWA version 0.5.9 (<ref type="bibr" target="#b19">Li et al., 2009</ref>) with default parameters. We call a read mapped if BWA outputs an alignment for it and unmapped otherwise. Analysis of the alignments revealed that 98% of the reads mapped to the reference genome, representing an average depth of approximately 600×; BLAST analysis against known contaminants revealed that the unmapped reads are attributed to minor contamination of the sample (<ref type="bibr" target="#b4">Chitsaz et al., 2011</ref>). The second dataset is a single-cell dataset consisting of approximately 29 million paired-end reads. Again, we aligned the reads to the E.coli reference genome and observed that 92% of the reads mapped to the reference genome, representing an average coverage of approximately 600×; unmapped reads have been attributed to contamination of the data (<ref type="bibr" target="#b4">Chitsaz et al., 2011;</ref><ref type="bibr" target="#b30">Rodrigue et al., 2009</ref>). The coverage in this dataset is non-uniformly distributed across the genome and fluctuates greatly.Added matches may originate from two sources: correcting substitution errors or correcting contig deletions. Lost matches may originate from the two sources: creating substitution errors or correcting contig insertions. Lastly, we used SEQuel to improve the genome assembly of an uncultured Deltaproteobacterium SAR324. This assembly represents a first draft of the genome of this marine bacterium (<ref type="bibr" target="#b4">Chitsaz et al., 2011</ref>). Sequence reads and assembly are both available for download at http://bix.ucsd.edu/singlecell/ and a detailed description of the assembly is given in (<ref type="bibr" target="#b4">Chitsaz et al., 2011</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i191</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Performance on standard E.coli Data</head><p>We generated the assemblies with Euler-SR v2.0 and Velvet v1.1 in paired-end mode with suggested parameters (i.e. k = 55 for EulerSR and k = 31 for Velvet). We generated an additional assembly with Velvet using k = 55. 1 All assemblers accurately assembled the majority of the E.coli genome, however, there was a range in terms of the accuracy of the contigs. We limited our attention to contigs of length ≥ 250 bp and ran SEQuel with default parameters of k = 50 and = 15. Contigs were aligned to the E.coli reference genome (NCBI Accession NC_000913.2) using BLAT (<ref type="bibr" target="#b17">Kent, 2002</ref>) and both mismatches and indels were counted and compared across contigs before and after the use of SEQuel. Both the Euler-SR and Velvet assemblies showed a decrease in the number of substitution errors and indels relative to the reference genome after the use of SEQuel. The Euler-SR assembly with SEQuel showed a significant decrease both in the number of positions mismatching the reference genome and in the number of indels. The number of indels of size ≤50 bp was reduced from 145 to 79, and the number of substitution errors was reduced from 155 to 104 with the use of SEQuel.<ref type="figure" target="#fig_1">Figure 3</ref>and<ref type="figure" target="#tab_1">Table 1</ref>illustrate these changes to the assembly. Similar results were obtained when applying SEQuel to the Velvet (k = 31) assembly (<ref type="figure" target="#fig_1">Fig. 3</ref>). The most significant change to this assembly was the sharp decrease in the number of substitution errors relative to the reference genome. Using SEQuel, the number of substitution errors went from 8937 to 452, correcting 94% of the total number of substitution errors in the assembly. The number of short indels in this assembly went from 979 to 342. The Velvet assembly with k = 55 showed a substantially smaller number of indels and substitution errors (e.g. 50 substitution errors in the complete assembly), leaving less room for improvement. Nevertheless, using SEQuel, the number of short indels in the Velvet assembly with k = 55 went from 3 to 2 and the number of substitution errors went from 50 to 8. 2</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Performance on single-cell E.coli data</head><p>Assembly of single-cell data is inherently more challenging due to the highly non-uniform coverage. Consequently, the contigs obtained from assembly of single-cell data using standard assembly tools are more error prone.<ref type="bibr" target="#b4">, Chitsaz et al. (2011</ref>developed Velvet-SC, a specialized assembler tailored to handle the dramaticAdded matches may originate from two sources: correcting substitution errors or correcting contig deletions. Lost matches may originate from the two sources: creating substitution errors or correcting contig insertions. fluctuations in coverage that are characteristic to single-cell data. In our single-cell experiments we used Velvet-SC and Euler-SR. We performed the assemblies in paired-end mode with k = 55. SEQuel was used in single-cell mode with k = 50 and = 15. Contigs were aligned to the E.coli reference genome (NCBI Accession NC_000913.2) using BLAT (<ref type="bibr" target="#b17">Kent, 2002</ref>) and both mismatches and indels were counted and compared across contigs before and after the use of SEQuel. Again, we restrict interest to contigs with length ≥250 bp. As expected, the quality of the Euler-SR assembly is substantially lower than the quality of the Velvet-SC assembly since the former is not equipped to deal with single-cell data. However, both the Euler-SR and Velvet-SC assemblies have a dramatic decrease in the number of substitution errors and the number of indels with the application of SEQuel. In the Euler-SR assembly, the number of indels of size ≤50 bp went from 908 to 379, and the number of substitution errors went from 221 to 109 with the use of SEQuel.<ref type="figure" target="#fig_3">Figure 4</ref>illustrates these changes to the assembly.<ref type="figure" target="#tab_2">Table 2</ref>gives the total number of matches added and lost, and the total number of substitution errors removed and created by SEQuel. Similar results to Euler-SR were obtained with Velvet-SC. The most significant change in the Velvet-SC assembly was the decrease in the number of indels in the assembly: the number of indels went from 47 to 18, and the number of substitution errors went from 152 bp to 73 bp.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Refinement of deltaproteobacterium SAR324 single-cell assembly</head><p>We ran SEQuel in single-cell mode with k = 50 and = 15. SEQuel made changes to 335 of the 602 contigs. Approximately 800 bp were changed overall: 191 substitutions, 584 insertions and 42 deletions. We can only report changes made to the assembly since there exists no reference genome for the bacteria. However, based on the results obtained with SEQuel on a single-cell E.coli assembly, we extrapolate that the majority of these changes represent a (positive) refinement to the assembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Practical considerations: memory and time</head><p>We evaluated the memory and time requirements of SEQuel. Since SEQuel is a multi-threaded application, its wall-time depends on the computing resources available to the user. For evaluation purposes we used four threads, a setting that is suitable for most current desktops. The memory requirements depend on a number of factors, including contig length, coverage depth and the level of parallelization. For the E.coli and Deltaproteobacterium SAR324 assemblies, SEQuel required a maximum of 6 GB and 1.5 h to complete (see<ref type="figure" target="#tab_3">Table 3</ref>). From a practical perspective, the time and memory requirements of SEQuel do not significantly increase upon those of most NGS assemblers, making it an easy and practical post-processing step. Further, due to the fact that it is performed contig-wise rather than genome-wise, our method should easily scale to larger genomes (i.e. mammalian genomes).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i193</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R.Ronen and C.Boucher et al.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Comparison between SEQuel and variation discovery tools</head><p>We compared SEQuel with a simpler method of error correction provided by extensions of variation discovery tools. We aligned the reads to the contigs using BWA, and then applied GATK base quality score recalibration, variation discovery (i.e. SNP and indel detection) and variant quality score recalibration (<ref type="bibr" target="#b6">DePristo et al., 2011;</ref><ref type="bibr" target="#b10">McKenna et al., 2010</ref>). We then incorporated these variants into the original contigs. We performed this process on both the single-cell and standard multi-cell E.coli assemblies considered in this article. Although this method is conceptually simpler and does not require the development of another tool, the performance was poor in comparison to that of SEQuel. This method corrected approximately one-third of the errors corrected by SEQuel, 3 and created 40–50% more errors than SEQuel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Assessment of errors corrected by SEQuel</head><p>We ran several experiments to better characterize the errors that SEQuel corrects. The assemblies produced by running Velvet (k = 31 and k = 55) on simulated, perfect reads generated from the reference E.coli genome (200 × coverage) had only a negligible number of errors (less than 10 for k = 31 and less than 5 for k = 55). Thus, almost all errors in the assembly of the E.coli genome originate from sequencing errors. These sequencing errors give rise to erroneous k-mers that correspond to spurious edges in the de Bruijn graph. Such spurious edges may cause whirls and bulges, which cannot always be reconciled correctly by the assembler. In this section, we show two examples of assembly errors that are caused by erroneous k-mers, and are corrected by SEQuel. Before going into these examples in detail, we give a general description of how erroneous k-mers can lead to complexity in the de Bruijn graph. Consider a read r sampled from a position i of the genome. Assuming i does not lie within a repeated region, k-mers from r should contribute only to contigs from the region proximal to i. In practice, k-mers from erroneous reads originating in one position may contribute to contigs from completely unrelated regions of the genome. For example, an erroneous 'read'AATACCC sampled from the genomic region AATGCCC (single substitution, from G to A) will contribute a k-mer (k = 4, ATAC) to the contig ...GGATACTT...., rather than the correct contig ...AATGCCC. This reallocation of k-mers may occur either within different regions of the same contig (second example below), or across different contigs (first example below). Both the following examples are from the Velvet (k = 31) assembly of standard E.coli reads. First, we focus our attention to a single contig (contig 170157) that illustrates how erroneous k-mers from reads that permissively align to a single contig can be responsible for complexities that the assembler cannot rectify. This contig has two insertions in alignment to the E.coli genome, both of which were corrected by SEQuel. We constructed the de Bruijn graph from only the set of reads that permissively aligned to this contig. As shown in<ref type="figure" target="#fig_5">Figure 5</ref>, this graph contains bulges and whirls in the exact locations corresponding to the gaps in alignment. In contrast, the positional de Bruijn graph on the same set of reads is significantly simpler (contains a single long path); the positional information constraints graph construction and eliminates many of the spurious edges. SEQuel corrected both insertions in contig 170157. Our second example illustrates how erroneous k-mers are recruited from distant regions of the de Bruijn graph and form spurious edges that eventually lead to assembly errors. We constructed the de Bruijn graph from the set of reads used to assemble contig 10362 and two other contigs from the same assembly. The de Bruijn graph built from only the reads that permissively aligned to contig 10362 is simple enough that it led to an error-free contig, but the de Bruijn graph built from the larger set of reads has whirls and bulges at the exact locations where deletions in the alignment occur (<ref type="figure" target="#fig_6">Fig. 6</ref>). The deletions likely occurred due to k-mers originating in erroneous reads associated with other contigs that were recruited to an incorrect region (that of contig 10362) in the de Bruijn graph. Since SEQuel builds the positional de Bruijn graph on only the set of reads that permissively align to a single contig (and not the complete set of reads), the complexity caused by erroneous k-mers being recruited from other regions in the graph is eliminated. The graphs shown in Figures 5 and 6 are only estimates of the relevant regions in the de Bruijn graph constructed by the assembler; the actual graph includes k-mers from the entire dataset (not just k-mers that aligned to a single or several contigs). Both examples reveal the complexity inherent to the de Bruijn graph even on a small set of reads and provide insight into possible causes of assembly errors. The positional de Bruijn graph constructed from the same reads is substantially less complex. The recruitment of k-mers from one contig to an unrelated contig (as shown in<ref type="figure" target="#fig_6">Fig. 6</ref>) presents a severe problem to NGS assemblers, since the position of k-mers cannot be ascertained prior to assembly. A post-processing step is needed to define relative position and reconcile the complexity of the original de Bruijn graph, thus the second example serves to illustrate the necessity of a post-processing step to assembly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSIONS</head><p>To the best of our knowledge, a post-processing step for obtaining more accurate NGS assemblies has not been previously considered. While Donmez and Brudno (2011) state 'The consensus sequence for each contig is generated using a greedy multiple sequence alignment', no further detail is given, and the effects of this process are not evaluated. Furthermore, it cannot be used in combination with another assembler. Additionally, there is some similarity between SEQuel and the approach implemented by the LOCAS re-assembly tool (<ref type="bibr" target="#b18">Klein et al., 2011</ref>), where positional information is used to partition reads into groups that will be assembled together. The novelty of our approach lies in the fact that we explicitly i194shows two deletions in the contig, having respective lengths 20 bp and 7 bp. The regions in the de Bruijn graph corresponding to the deletions in alignment are complex and contain bulges and whirls that likely lead to assembly errors incorporate the positions of k-mers into the graph theoretical model. While SEQuel significantly reduces the amount of assembly errors, it does not address the notoriously difficult problem of repeat separation in fragment assembly. Although significant efforts have been made to resolve this problem in Sanger sequencing (<ref type="bibr" target="#b15">Kececioglu and Yu, 2001;</ref><ref type="bibr" target="#b22">Myers, 2001;</ref><ref type="bibr" target="#b32">Tammi et al., 2002;</ref><ref type="bibr" target="#b35">Zhi et al., 2007</ref>), it remains poorly addressed in the context of NGS. The positional de Bruijn graph offers an opportunity to revisit this problem in future research. Our results demonstrate that a substantial number of small indels and substitution errors can be corrected in both single-cell and standard (multi-cell) assemblies. In particular, our results on singlecell assemblies further illustrate that high and uniform coverage is not a requirement for SEQuel. Lastly, we show that the corrections made by SEQuel can likely be accomplished only in post-processing of assembly, since the positional information cannot be inferred prior to assembly.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>Copyedited by: GS MANUSCRIPT CATEGORY: [16:44 29/5/2012 Bioinformatics-bts219.tex] Page: i190 i188–i196</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.3.</head><figDesc>Fig. 3. Illustration of the change in the number of short (≤ 50 bp) indels (a) and substitution errors (b) relative to the reference genome before and after the use of SEQuel. Standard reads were assembled using Euler-SR and Velvet. The assembly without SEQuel and with SEQuel is shown in blue and red, respectively</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.4.</head><figDesc>Fig. 4. Illustration of the change in the total number of short (≤50 bp) indels (a) and substitution errors (b) in assemblies before and after the use of SEQuel. Paired-end reads from a single-cell sample were assembled using Euler-SR and Velvet-SC. The assembly without SEQuel and with SEQuel is shown in blue and red, respectively</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.5.</head><figDesc>Fig. 5. The first illustration of the connection between assembly errors, and whirls and bulges in the de Bruijn graph. The alignment of a 1975 bp contig from the assembly with Velvet and k = 31 (contig number 170157), showing two insertions in the alignment, having respective lengths 1 bp and 15 bp. The de Bruijn graph constructed from the set of permissively aligned reads to this contig contains bulges and whirls at regions corresponding to the insertions in the contigs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.6.</head><figDesc>Fig. 6. The second illustration of the connection between assembly errors, and whirls and bulges in the de Bruijn graph. The alignment of a 725 bp contig from the assembly with Velvet and k = 31 (contig number 10362) shows two deletions in the contig, having respective lengths 20 bp and 7 bp. The regions in the de Bruijn graph corresponding to the deletions in alignment are complex and contain bulges and whirls that likely lead to assembly errors</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 1. Refinement statistics of assemblies from the standard E.coli dataset</figDesc><table>Refinement statistics 
Euler-SR Velvet (k = 31) Velvet (k = 55) 

Matches added (lost) 
754 (39) 17 010 (25) 
45 (2) 
Substitution errors removed 
(created) 

69 (18) 
8490 (5) 
44 (2) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 2. Refinement statistics of assemblies from single-cell E.coli reads</figDesc><table>Refinement statistics 
Euler-SR 
Velvet-SC 

Matches added (lost) 
3100 (200) 
93 (18) 
Substitution errors removed (created) 
126 (14) 
80 (1) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 3. Running time and memory usage of SEQuel on bacterial genomes</figDesc><table>Genome 
Genome size 
Time 
Memory 

Escherichia coli 
4.6 Mb 
55 min 
6 GB 
SAR324 
4.9–6.4 Mb 
87 min 
6 GB 

SAR324 has not been finished, thus the exact size of the genome remains unknown. 

</table></figure>

			<note place="foot" n="3"> ALGORITHM AND METHODS Fundamental to the algorithm behind SEQuel is the positional de Bruijn graph. The input to SEQuel is a multiset of positional kmers, and a set of contigs; the output is a set of refined contigs. i189 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="1"> Velvet generates assemblies that are substantially more accurate using k = 55, however this is a more advanced parameterization since it requires recompilation of the source code with a slight modification. Thus, typical use of Velvet by non-expert users would be with k = 31.</note>

			<note place="foot" n="2"> To illustrate that SEQuel can be used with any assembler, we further tested it with SOAPdenovo (Li et al., 2010) and SPAdes (Bankevich et al., 2012), a new NGS assembler (http://bioinf.spbau.ru/spades). On the multi-cell E.coli data, the SOAPdenovo (SPAdes) assembly had 1230 (199) substitution errors, and 27 (14) small indels totaling 590 (94) bp. SEQuel reduced the number of substitution errors in SOAPdenovo (SPAdes) by 95% (26%), and the total indel size by 80% (91%). The number of substitution errors in the SOAPdenovo assembly was dramatically reduced, illustrating that the application of SEQuel can improve this assembly so that it is nearly as accurate as that of Velvet, which is currently the most accurate assembler. i192 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> The largest number of corrections made was in the Velvet (k = 31) assembly of standard multi-cell data, and the number of corrections was 65% less than that of SEQuel.</note>

			<note place="foot">i196 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors would like to thank Glenn Tesler from the University of California, San Diego, for many insightful discussions. The authors wish to thank the reviewers for their insightful comments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R.Ronen and C.Boucher et al.</head><p>Conflict of Interest: none declared.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Limitations of next-generation genome sequence assembly</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Alkan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Meth</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="61" to="65" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">SPAdes: a New Genome Assembly Algorithm and its Applications to Single-Cell Sequencing</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bankevich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comp. Bio</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="455" to="477" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Accurate whole genome sequencing using reversible terminator chemistry</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Bentley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">456</biblScope>
			<biblScope unit="page" from="53" to="59" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">ALLPATHS: De novo assembly of whole-genome shotgun microreads</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Butler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="810" to="820" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of single-cell bacterial genomes from short-read datasets</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Chitsaz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Biotech</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="915" to="921" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">How to apply de Bruijn graphs to genome assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">E C</forename>
				<surname>Compeau</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Biotech</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="987" to="991" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">A framework for variation discovery and genotyping using next-generation DNA sequencing data</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Depristo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Gene</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="491" to="498" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Hapsembler: as assembler for highly polymorphic genomes</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Donmez</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Brudno</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">RECOMB 2011</title>
		<editor>Bafna,V. and Cenk,S.</editor>
		<meeting><address><addrLine>Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="38" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Base-calling of automated sequencer traces using Phred.II. ErrorProbabilities</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Ewing</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Green</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="186" to="194" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Base-calling of automated sequencer traces using Phred.I.Accuracy assessment</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Ewing</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="175" to="185" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">The genome analysis toolkit: a MapReduce framework for analyzing next-generation DNA sequencing data</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Mckenna</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1297" to="303" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Positional sequencing by hybridization</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hannenhalli</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CABIOS</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="19" to="24" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">A linear space algorithm for computing maximal common subsequences</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">S</forename>
				<surname>Hirschberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comm. A.C.M</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="341" to="343" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">The genome of the cucumber: Cucumis sativus L</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Huang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature Gen</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="1275" to="1281" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">A new algorithm for dna sequence assembly</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">M</forename>
				<surname>Idury</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">S</forename>
				<surname>Waterman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="291" to="306" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<monogr>
		<title level="m" type="main">Separating Repeats in DNA Sequence Assembly</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Kececioglu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Yu</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>ACM</publisher>
			<biblScope unit="page" from="176" to="183" />
			<pubPlace>New York, NY</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Quake: quality-aware detection and correction of sequencing errors</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Kelley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">116</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">BLAT – the BLAST-like alignment tool</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">J</forename>
				<surname>Kent</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="656" to="664" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">LOCAS–a low coverage assembly tool for resequencing projects</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Klein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">23455</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with BurrowsWheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">The sequence and de novo assembly of the giant panda genome</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">463</biblScope>
			<biblScope unit="page" from="311" to="317" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Optimally separating sequences</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Inform</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="165" to="174" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Error correction of high-throughput sequencing datasets with non-uniform coverage</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="137" to="141" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Genome 10k: a proposal to obtain whole-genome sequence for 10000 vertebrate species</title>
	</analytic>
	<monogr>
		<title level="j">Genome 10K Community of Scientists. J. Hered</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="659" to="674" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Short read fragment assembly of bacterial genomes</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="324" to="330" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">De novo repeat classification and fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1786" to="1796" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">An eulerian path approach to DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci</title>
		<meeting>. Natl. Acad. Sci</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9748" to="9753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Genomic DNA amplification from a single bacterium</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Raghunathan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Appl. Environ. Microbiol</title>
		<imprint>
			<biblScope unit="volume">71</biblScope>
			<biblScope unit="page" from="3342" to="3347" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Creating a buzz about insect genomes</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">E</forename>
				<surname>Robinson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="page" from="331" to="1386" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Whole genome amplification and de novo assembly of single bacterial cells</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Rodrigue</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">Separation of nearly identical repeats in shotgun assemblies using defined nucloetide positions, DNPs</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">T</forename>
				<surname>Tammi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="379" to="388" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">The complete genome of an individual by massively parallel DNA sequencing</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">A</forename>
				<surname>Wheeler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">452</biblScope>
			<biblScope unit="page" from="872" to="876" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">Correcting base-assignment errors in repeat regions of shotgun assembly</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Zhi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="54" to="64" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>