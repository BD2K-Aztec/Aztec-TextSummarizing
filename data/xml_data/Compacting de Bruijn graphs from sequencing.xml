
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:47+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Compacting de Bruijn graphs from sequencing data quickly and in low memory</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Rayan</forename>
								<surname>Chikhi</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">CNRS</orgName>
								<address>
									<settlement>CRIStAL, Lille</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Antoine</forename>
								<surname>Limasset</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="institution">ENS Cachan Brittany</orgName>
								<address>
									<settlement>Bruz</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Paul</forename>
								<surname>Medvedev</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">The Pennsylvania State University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Department of Biochemistry and Molecular Biology</orgName>
								<orgName type="institution">The Pennsylvania State University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="institution" key="instit1">Genome Sciences Institute of the Huck</orgName>
								<orgName type="institution" key="instit2">The Pennsylvania State University</orgName>
								<address>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Compacting de Bruijn graphs from sequencing data quickly and in low memory</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btw279</idno>
					<note>*To whom correspondence should be addressed.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: As the quantity of data per sequencing experiment increases, the challenges of fragment assembly are becoming increasingly computational. The de Bruijn graph is a widely used data structure in fragment assembly algorithms, used to represent the information from a set of reads. Compaction is an important data reduction step in most de Bruijn graph based algorithms where long simple paths are compacted into single vertices. Compaction has recently become the bottleneck in assembly pipelines, and improving its running time and memory usage is an important problem. Results: We present an algorithm and a tool BCALM 2 for the compaction of de Bruijn graphs. BCALM 2 is a parallel algorithm that distributes the input based on a minimizer hashing technique, allowing for good balance of memory usage throughout its execution. For human sequencing data, BCALM 2 reduces the computational burden of compacting the de Bruijn graph to roughly an hour and 3 GB of memory. We also applied BCALM 2 to the 22 Gbp loblolly pine and 20 Gbp white spruce sequenc-ing datasets. Compacted graphs were constructed from raw reads in less than 2 days and 40 GB of memory on a single machine. Hence, BCALM 2 is at least an order of magnitude more efficient than other available methods. Availability and Implementation: Source code of BCALM 2 is freely available at: https://github.com/ GATB/bcalm Contact: rayan.chikhi@univ-lille1.fr</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Modern sequencing technology can generate billions of reads from a sample, whether it is RNA, genomic DNA, or a metagenome. In some applications, a reference genome can allow for the mapping of these reads; however, in many others, the goal is to reconstruct long contigs. This problem is known as fragment assembly and continues to be one of the most important challenges in bioinformatics. Fragment assembly is the central algorithmic component behind the assembly of novel genomes, detection of gene transcripts (RNA-seq) (<ref type="bibr" target="#b12">Grabherr et al., 2011</ref>), species discovery from metagenomes, structural variant calling (<ref type="bibr" target="#b13">Iqbal et al., 2012</ref>). Continued improvement to sequencing technologies and increases to the quantity of data produced per experiment present a serious challenge to fragment assembly algorithms. For instance, while there exist many genome assemblers that can assemble bacterial sized genomes, the number of assemblers that can assemble a high-quality mammalian genome is limited, with most of them developed by large teams and requiring extensive resources (<ref type="bibr" target="#b11">Gnerre et al., 2011;</ref><ref type="bibr" target="#b23">Luo et al., 2012;</ref><ref type="bibr" target="#b33">Simpson et al., 2009</ref>). For even larger genomes, such as the 20 Gbp Picea glauca (white spruce), graph construction and compaction took 4.3 TB of memory, 38 h and 1380 CPU cores (<ref type="bibr" target="#b0">Birol et al., 2013</ref>). In another instance, the whole genome assembly of 22 Gbp Pinus taeda (loblolly pine) required 800 GB of memory and three months of running time on a single machine (<ref type="bibr" target="#b37">Zimin et al., 2014</ref>). Most short-read fragment assembly algorithms use the de Bruijn graph to represent the information from a set of reads. Given a set of reads R, every distinct k-mer in R forms a vertex of the graph, while an edge connects two k-mers if they overlap by k – 1 characters. The use of the de Bruijn graph in fragment assembly consists of a multi-step pipeline, however, the most data intensive steps are usually the first three: nodes enumeration, compaction and graph cleaning. In the first step (sometimes called k-mer counting), the set of distinct k-mers is extracted from the reads. In the second step, all unitigs (paths with all but the first vertex having in-degree 1 and all but the last vertex having out-degree 1) are compacted into a single vertex. In the third step, artifacts due to sequencing errors and polymorphism are removed from the graph. The second and third step are sometimes alternated to further compact the graph. After these initial steps, the size of the data is reduced gradually, e.g. for a human dataset with 45Â coverage, To overcome the scalability challenges of fragment assembly of large sequencing datasets, there has been a focus on improving the resource utilization of de Bruijn graph construction. In particular, k-mer counting has seen orders of magnitude improvements in memory usage and speed. As a result, graph compaction is becoming the new bottleneck; but, it has received little attention (<ref type="bibr" target="#b18">Kundeti et al., 2010</ref>). Recently, we developed a compaction tool that uses low memory, but without an improvement in time (<ref type="bibr" target="#b3">Chikhi et al., 2014</ref>). Other parallel approaches for compaction have been proposed, as part of genome assemblers. However, most are only implemented within the context of a specific assembler, and cannot be used as modules for the construction of other fragment assemblers or for other applications of de Bruijn graphs (e.g. metagenomics). In this paper, we present a fast and low memory algorithm for graph compaction. Our algorithm consists of three stages: careful distribution of input k-mers into buckets, parallel compaction of the buckets, and a parallel reunification step to glue together the compacted strings into unitigs. The algorithm builds upon the use of minimizers to partition the graph (<ref type="bibr" target="#b3">Chikhi et al., 2014</ref>); however, the partitioning strategy is completely novel since the strategy of<ref type="bibr" target="#b3">Chikhi et al. (2014)</ref>does not lend itself to parallelization. Due to the algorithm's complexity, we formally prove its correctness. We then evaluate it on whole-genome human, pine and spruce sequencing data. The de Bruijn graph for a whole human genome dataset is compacted in roughly an hour and 3 GB of memory using 16 cores. For the &gt;20 Gbp pine and spruce genomes, k-mer counting and graph compaction take only 2 days and 40 GB of memory, improving on previously published results by at least an order of magnitude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>The parallelization of de Bruijn graph compaction has been previously explored. In (<ref type="bibr" target="#b15">Jackson et al., 2010;</ref><ref type="bibr" target="#b18">Kundeti et al., 2010</ref>), the problem is reduced to the classic list ranking problem and solved using parallel techniques such as pointer jumping. Another recurrent MPI-based approach is to implement a distributed hash table, where the k-mers and the information about their neighborhoods are distributed amongst processes. Each processor then extends seed k-mers locally as far as possible to build sub-unitigs and then passes them off to other processors for further extension. Variants of this approach are used in (<ref type="bibr" target="#b9">Georganas et al., 2014;</ref><ref type="bibr" target="#b21">Liu et al., 2011;</ref><ref type="bibr" target="#b33">Simpson et al., 2009</ref>). Other papers have proposed using a parallelized depth-first search (<ref type="bibr" target="#b36">Zeng et al., 2013</ref>) or a small world asynchronous parallel model (<ref type="bibr" target="#b28">Meng et al., 2014</ref><ref type="bibr" target="#b27">Meng et al., , 2012</ref>). Before a de Bruijn graph can be compacted, it has to be constructed. Parallel approaches currently represent the state-of-the-art in this area. Many original efforts were focused on edge-centric de Bruijn graphs, where edges are represented by ðk þ 1Þ-mers. They required the identification of both all distinct k-mers and ðk þ 1Þmers (<ref type="bibr" target="#b14">Jackson and Aluru, 2008;</ref><ref type="bibr" target="#b15">Jackson et al., 2010;</ref><ref type="bibr" target="#b18">Kundeti et al., 2010;</ref><ref type="bibr" target="#b22">Lu et al., 2013;</ref><ref type="bibr" target="#b36">Zeng et al., 2013</ref>). More recent efforts have focused on the node-centric graph, which only requires the counting of k-mers (<ref type="bibr" target="#b5">Deorowicz et al., 2014;</ref><ref type="bibr" target="#b19">Li et al., 2013;</ref><ref type="bibr" target="#b22">Lu et al., 2013;</ref><ref type="bibr" target="#b24">Marc¸ais and Kingsford, 2011;</ref><ref type="bibr" target="#b26">Melsted and Pritchard, 2011;</ref><ref type="bibr" target="#b31">Rizk et al., 2013;</ref><ref type="bibr" target="#b33">Simpson et al., 2009</ref>). In genome assembly, the construction and compaction of a de Bruijn graph form only the initial stages. There are also alternate approaches that do not use the de Bruijn graph at all (e.g. greedy or string graph). Numerous parallel assemblers are available for use, including ABySS (<ref type="bibr" target="#b33">Simpson et al., 2009</ref>), SOAPdenovo (<ref type="bibr" target="#b23">Luo et al., 2012</ref>), Ray (<ref type="bibr" target="#b1">Boisvert et al., 2010</ref>), PASQUAL (<ref type="bibr" target="#b20">Liu et al., 2013</ref>), PASHA (<ref type="bibr" target="#b21">Liu et al., 2011</ref>), SAND (<ref type="bibr" target="#b29">Moretti et al., 2012</ref>), SWAPAssembler (<ref type="bibr" target="#b28">Meng et al., 2014</ref>). Other methods for parallel assembly have been published but without publicly available software (<ref type="bibr" target="#b7">Duan et al., 2014;</ref><ref type="bibr" target="#b8">Garg et al., 2013;</ref><ref type="bibr" target="#b10">Georganas et al., 2015;</ref><ref type="bibr" target="#b15">Jackson et al., 2010</ref>). There has also been work done in reducing the overall memory footprint de Bruijn graph assembly. This challenge is most pronounced for k-mer counters. However, when scaling to mammaliansized genomes, memory usage continues to be an issue in downstream steps such as compaction.<ref type="bibr">Chikhi</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Definitions</head><p>We assume, for the purposes of this paper, that all strings are over the alphabet R ¼ fA; C; G; Tg. A string of length k is called a k-mer. For a string s, we define its k-spectrum, sp k ðsÞ, as the multi-set of all k-mer substrings of s. For a set of strings S, we define its multi-set k-spectrum as sp k ðSÞ ¼ [ s2S sp k ðsÞ. For two strings u and v, we write u 2 v to mean that u is a substring of v. We write u½i::j to denote the substring of u from the ith to the jth character, inclusive. We define suf k ðuÞ ¼ u½juj À k þ 1; juj and pre k ðuÞ ¼ u½1::k. For two strings u and v such that suf k ðuÞ ¼ pre k ðuÞ, we define a glue operation as u k v ¼ u Á v½k þ 1::jvj. The binary relation u ! v between two strings denotes that suf kÀ1 ðuÞ ¼ pre kÀ1 ðvÞ. For a set of k-mers K, the de Bruijn graph of K is a directed graph such that the nodes are exactly the k-mers in K and the edges are given by the ! relation. Note that our definition of the de Bruijn graph is node-centric, where the edges are implicit given the vertices; therefore, we use the terms de Bruijn graph and a set of k-mers interchangeably. Suppose we are given a de Bruijn graph, represented by a set of k-mers K. Consider a path p ¼ ðx 1 ;. .. ; x m Þ over m ! 1 vertices. We allow the path to be a cycle, i.e. it is possible that x 1 ¼ x m. The endpoints of a path are x 1 and x m if it is not a cycle. A single-vertex path has one endpoint. A cycle does not have endpoints. The internal vertices of a path are vertices that are not endpoints. p is said to be a unitig if either jpj ¼ 1 or for all 1 &lt; i &lt; m, the out-and indegree of x i is 1, and the in-degree of x m and the out-degree of x 1 are 1. A unitig is said to be maximal if it cannot be extended by a vertex on either side. The problem of compacting a de Bruijn graph is to report the set of all maximal unitigs. We say that two strings u and v are compactable in a set S if u ! v and, 8w 2 S, if w ! v then w ¼ u and if u ! w then w ¼ v. That is, u is the only in-neighbor of v, and v is the only out-neighbor of u. The compaction operation is defined on a pair of compactable strings and replaces u and v by a single string u kÀ1 v. Consider some ordering of '-mers. We define the '-minimizer of a string x as the smallest '-mer substring of x. Given k &gt; ' and a string x with at least k characters, we define lmmðxÞ as the '-minimizer of the prefix ðk À 1Þ-mer, and rmmðxÞ as the '-minimizer of the suffix ðk À 1Þ-mer. We refer to these as the left and right minimizers of x, respectively. Two strings (u, v) are m-compactable in S if they are compactable in S and if m ¼ rmmðuÞ ¼ lmmðvÞ. The m-compaction of a set S is obtained from S by applying the compaction operation as much as possible in any order to all pairs of strings that are m-compactable in S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Algorithm overview</head><p>In this section, we give a high-level description of our BCALM 2 algorithm (Algorithm 1), leaving important optimizations and implementation details to Section 6. Recall that the input is a set of k-mers K and the output are the strings corresponding to all the maximal unitigs of the de Bruijn graph of K. If time and memory are not an issue, then there is a trivial algorithm: repeatedly find compactable strings and compact them until no further compactions are possible. However, such an approach requires loading all the data into memory, which is not feasible for larger genomes. Instead, BCALM 2 proceeds in three stages. In the first stage, the k-mers are distributed into buckets, with some k-mers being thrown into two buckets. In the second stage, each bucket is compacted, separately. In the third stage, the k-mers that were thrown into two buckets are glued back together so that duplicates are removed.<ref type="figure" target="#fig_1">Figure 1</ref>shows the execution of BCALM 2 on a small example.</p><p>In the first stage (lines 1–6 of Algorithm 1), BCALM 2 distributes the k-mers of K to files Fð1Þ;. .. ; Fð4 ' Þ. These are called bucket files. Each k-mer x 2 K goes into file FðlmmðxÞÞ, and if lmmðxÞ 6 ¼ rmmðxÞ, also in FðrmmðxÞÞ. The parameter ' controls the minimizer size (in our implementation, we set ' ¼ 8). In the second stage of the algorithm, we process each bucket file using the CompactBucket procedure (Algorithm 2). After the k-mer distribution of the first stage, the bucket file F(i) contains all the k-mers whose left or right minimizer is i. We can therefore load F(i) into memory and perform i-compaction on it. Since the size of the bucket is small, this compaction can be performed using a simple inmemory algorithm. The resulting strings are then written to disk, and will be processed during the third stage. At the end of the second stage, when all CompactBucket procedures are finished, we have performed all the necessary compactions on the data. At this stage of the algorithm, notice that the k-mers x 2 K with lmmðxÞ 6 ¼ rmmðxÞ exist in two copies. We call such k-mers doubled. We will prove in Section 5 that these k-mers are always at the ends (prefix or suffix) of the compacted strings, never internal, and they can be recognized by the fact that the minimizer at that end does not correspond to the bucket where it resides. We record these ends that have doubled k-mers by marking them 'lonely' (lines 4 and 5 of Algorithm 2), since they will need to be 'reunited' at the third stage of the algorithm. Strings that have no lonely ends are maximal unitigs, therefore they are output (line 8). At the third stage of the algorithm, we process the strings output by CompactBucket with the Reunite procedure (Algorithm 3). At a high level, the purpose of Reunite is to process each string u that has a lonely end, and find a corresponding string v that has a matching lonely end with the same k-mer. When one is found, then u and v are glued together (Algorithm 4), thereby 'reuniting' the doubled k-mer that was split in the k-mer distribution stage. The new string inherits its end lonely marks from the glued strings, and the process is then repeated for the next string u that has a lonely end. After Reunite() completes, all duplicate k-mers will have been removed, and the strings in the output will correspond to the maximal unitigs.1: Load F(i) into memory. 2: U i-compaction of F(i). 3: for all strings u 2 U do 4: Mark u's prefix as " lonely " if i 6 ¼ lmmðuÞ. 5: Mark u's suffix as " lonely " if i 6 ¼ rmmðuÞ. 6: if u's prefix and suffix are not lonely then 7: Output u. 8: else 9: Place u in the Reunite fileInput: the set of strings R from the Reunite file. 1: UF Union find data structure whose elements are the distinct k-mer extremities in R. 2: for all parallel u 2 R do 3: if both ends of u are lonely then 4: UF:unionðsuf k ðuÞ; pre k ðuÞÞ 5: for all parallel classes C of UF do 6: P all u 2 R that have a lonely extremity in C 7: while 9u 2 P that does not have a lonely prefix do 8: Remove u from P 9: Let s ¼ u 10: while 9 v 2 P such that suf k ðsÞ ¼ pre k ðvÞ do 11: s Glueðs; vÞ 12: Remove v from P 13: Output s</p><p>Algorithm 4. Glue(u, v) Input: strings u and v, such that suf k ðuÞ ¼ pre k ðvÞ. 1: Let w ¼ u k v. 2: Set lonely prefix bit of w to be the lonely prefix bit of u. 3: Set lonely suffix bit of w to be the lonely suffix bit of v. 4: return w</p><p>Compacting de Bruijn graphs from sequencing data quickly and in low memory i203</p><p>To perform these operations efficiently in time and memory, Reunite first partitions the strings of R so that any two strings that need to be reunited are guaranteed to be in the partition. Then, each partition can be processed independently. To achieve the partition, we use a union-find (UF) data structure of all k-mers extremities. Recall that a UF data structure is created by first assigning a set to each distinct element (here, an element is the k-mer extremity of a string). Then, the union operation replaces the sets of two elements by a single set corresponding to their union. Here, union is applied to both k-mer extremities of a string. After the UF is constructed, the set of strings to be reunited is partitioned such that k-mer extremities of sequences in a partition all belong to the same UF set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Proof of correctness</head><p>Recall that K is the input to the algorithm and let U be the strings corresponding to the set of all maximal unitigs of K. We will assume for our proof that U does not contain any circular unitigs. We note that since BCALM 2 outputs strings, it cannot represent circular unitigs in its output. Circular unitigs present a corner case for both the analysis and the algorithm itself, and, for the sake of presentation brevity, we do not consider them here. We prove the correctness of BCALM 2 by showing that it outputs U. We first give a Lemma that will allow us to show that the output is U by arguing about its k and k þ 1 spectrums. LEMMA 1. Let S and T be two sets of strings of length at least k such that sp kþ1 ðSÞ ¼ sp kþ1 ðTÞ and sp k ðSÞ ¼ sp k ðTÞ and all these spectrums are without duplicates. Then, S ¼ T. PROOF. We will prove that S T. The same argument will be symmetrically applicable to prove T S, which will imply S ¼ T. First, we show that for all s 2 S, there exists a t 2 T such that s 2 t. Let s 2 S and let p ¼ maxfi : 9t 2 T; s½1::i 2 tg, and let t be a string achieving the max. Note that p ! k þ 1 since every ðk þ 1Þmer of S is also in T. Suppose for the sake of contradiction that p &lt; jsj. Then the ðk þ 1Þ-mer s½p À k þ 1; p þ 1 must occur in either another location of t or another string t 0 2 T. Either way, this means that the k-mer s½p À k þ 1; p must also occur elsewhere besides at t½p À k þ 1; p. Since there are no duplicate k-mers in T, this is a contradiction. Now, we show that S T. Let s 2 S and let t 2 T such that s 2 t. By applying an argument symmetrical to the one above, there exists a s 0 2 S such that t 2 s 0. This means that s 2 s 0 , and, in particular, s½1::k 2 s 0. Since k-mers can only appear once in S, we must have that s ¼ s 0 and hence s ¼ t 2 T. h Next, we characterize the k and k þ 1 spectrums of U. Given a multi-set M, we denote by Set(M) as the set version of M, with all multiplicity information implicitly removed. When referring to a set, such as K, as a multi-set, we will mean that all the elements have multiplicity one. LEMMA 2. sp k ðUÞ ¼ K PROOF. Since every vertex is a single vertex unitig path, every vertex must be covered by some maximal unitig and hence Setðsp k ðUÞÞ ¼ K. It remains to show that the set of maximal unitigs never share a vertex. First, observe that a single unitig cannot visit a vertex more than once, otherwise that vertex will be an internal vertex at one of its occurrences but will have either multiple ins or outs. We therefore need to show that no two maximal unitig paths share a vertex. Let p ¼ ðv 1 ;. .. ; v jpj Þ and p 0 ¼ ðv 0 1 ;. .. ; v 0 jp 0 j Þ be two maximal unitigs that share a vertex. Because p is maximal, it cannot be a subpath of p 0 , and cannot be a single vertex. If p is a cycle, then all its vertices have in-and out-degree one so that the only other paths it can share vertices with are sub-paths of p, contradicting the fact that p is maximal. Hence, we can assume that p and, by symmetry, p 0 , is not a cycle. First, suppose that all shared vertices are internal to both paths. Consider such a vertex v i , for a maximal i. Because v i must have different out-neighbors on both paths, it has out-degree at least two, contradicting that it is an internal vertex. Therefore there must exist at least one shared vertex that is an endpoint of one of the paths. Suppose that v 1 is a shared vertex, and that it is not the first vertex of p 0 , If the previous vertex of p 0 is not on p, then p can be extended with it, contradicting its maximality. Otherwise, consider the first vertex at which p and p 0 diverge. That is, the smallest i &lt; jpjsuch that v i 2 p 0 but v iþ1 6 2 p 0. The last vertex of p 0 must be v i , otherwise it has out-degree at least two, contradicting that p is a unitig. Therefore, there can only exist one such vertex v i , and it must be the last vertex of p 0. h We define a ðk þ 1Þ-mer w as actionable if there exists x 2 K and y 2 K such that (x, y) are compactable in K and w ¼ x kÀ1 y. We define A as the multi-set of all actionable ðk þ 1Þ-mers, but note that it does not contain duplicates because there are no duplicate k-mers in K.First we note that neither A nor sp kþ1 ðUÞ have any multiple elements (by Lemma 2), and we do not need to consider multiplicities of the elements. Suppose that there exist two k-mers x and x 0 such that x kÀ1 x 0 2 A but is not in sp kþ1 ðUÞ. Because every vertex is part of some unitig, by Lemma 2 there must exist a unique unitig path p 2 U that contains x and a unique unitig path p 0 2 U that contains x 0. Note that because ðx; x 0 Þ are compactable, x 0 is the unique our-neighbor of x and x is the unique in-neighbor of x 0. Also, x must be the last vertex of p and x 0 must be the first vertex of p 0. We can therefore join p and p 0 by adding the edge from x to x 0 , obtain a unitig and contradicting the maximality of p and p 0. Now suppose that there exists k-mers x and x 0 such that x kÀ1 x 0 2 sp kþ1 ðUÞ but not in A. Let p be the unitig containing x kÀ1 x 0. Since x is not the last endpoint, it must have an out-degree of 1. Similarly, x 0 has an in-degree of 1. Hence, ðx; x 0 Þ is compactable, a contradiction. h Next, we characterize the effect that CompactBucket() has on the k and k þ 1 spectrums. Let B be the collection of all strings u that are either output at line 7 of Compactbucket or placed in the Reunite file at line 9. We can think of these as the sum output of the CompactBucket calls. LEMMA 4. sp kþ1 ðBÞ ¼ A and sp k ðBÞ is the same as K except every doubled k-mer has multiplicity of 2 in sp k ðBÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF.</head><p>During distribution of the k-mers into the bucket files, every k-mer is distributed to exactly one file except for doubled k-mers, which go into two files. The compaction operations that follow do not affect the k-spectrum. Thus, the statement about sp k ðBÞ holds. Initially, sp kþ1 ðKÞ ¼ 1. The compaction operation changes the k þ 1 spectrum by creating one new ðk þ 1Þ-mer. Hence, we will show that x kÀ1 y 2 A if and only if (x, y) gets compacted at some point. Consider an actionable ðk þ 1Þ-mer x kÀ1 y 2 A. Observe that the right minimizer of x is the same as the left minimizer of y. Denote it by i. Because (x, y) are compactable, they are also i-compactable. The bucket file F(i) will contain x and y. Because x does not have an out-neighbor that is not y in K, it will not have an outneighbor that is not y in F(i). Similarly, y will only have x as an inneighbor in F(i). Hence, (x, y) will be i-compacted in F(i). On the other hand, consider an i-compaction of x 2 K and y 2 K in F(i). Any out-neighbor of x in K must have i as a left minimizer and hence must be in F(i). Similarly, any in-neighbor of y in K must have i as a right minimizer and hence must also be in F(i). Because (x, y) are i-compactabile in F(i), x does not have an out-neighbor y 0 6 ¼ y in K and y does not have an in-neighbor x 0 6 ¼ x in K. Therefore, (x, y) are compactable in K and hence x kÀ1 y 2 A. h Next, we analyze the third stage of the algorithm. The following two Lemmas connect the notion of loneliness to doubled k-mers.Let x 2 K be a doubled k-mer. Then, x appears as a prefix of some string in R and as a suffix of some other string in R, and the ends where it appears are marked lonely. PROOF. Let i ¼ rmmðxÞ. Since x is a doubled k-mer, lmmðxÞ 6 ¼ i. Consider the fate of x in CompactBucket(i). Because CompactBucket only performs i-compactions, x will never be compacted from the left. Thus it will be a prefix of some string in U at line 2 of CompactBucket, and line 4 will mark the prefix end as lonely. The argument for the suffix is symmetrical. h LEMMA 6. Let x be a k-mer at a lonely end of a string in R. Then, x is a doubled k-mer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF.</head><p>The only way for x to be marked lonely in B would be in CompactBucket(i), for some i. Assume without loss of generality that this happens in line 4. The left minimizer of x is therefore not i, however, to have been placed into F(i), its right minimizer must be i. Hence, its left and right minimizers are different and it is a doubled k-mer. h</p><p>The next Lemma is helpful to establish that each string in R that has a lonely prefix will be examined by Reunite. LEMMA 7. Let u be a string in R with a lonely prefix. Then, there exists distinct strings v 1 ;. .. ; v a in R such that, letting v 0 ¼ u; suf k ðv i Þ ¼ pre k ðv iÀ1 Þ for 0 &lt; i a and v a has a non-lonely prefix. PROOF. By Lemma 6, the k-mer prefix x of u is doubled, therefore by Lemma 5 there exists a string v 1 in R such that x is the suffix of v 1. If the prefix of v 1 is not lonely, then set a ¼ 1 and the Lemma statement is satisfied. Hence, consider the case where the prefix of v 1 is lonely. We prove by an induction over the size of R that v 1 ;. .. ; v a exist and satisfy the conditions stated in the Lemma. For the base case, let R be of size 2. We will prove that the prefix of v 1 is not lonely. Assume for the sake of contradiction that it is. Applying Lemmas 6 and 5 again yields that the prefix of v 1 is the suffix of another string w. Given that R is of size 2, w must be u. Hence, u and v 1 have identical k-mers extremities, they therefore spelled an isolated cycle in the input de Bruijn graph. This contradicts our assumption that U is free of circular unitigs, and concludes the base case. Assume that the inductive hypothesis holds for sets of size strictly smaller than of R. Applying the hypothesis to v 1 in Rnfug, thereNext we analyze the effect that Reunite has on the k and k þ 1 spectrums. Let G be the final output of the algorithm.Let x 2 K be a doubled k-mer. Then x appears only once in G, either internal to a string or as a non-lonely end. PROOF. By Lemma 5, x appears as a lonely suffix of some string u 1 2 B and as a lonely prefix of another string u 2 2 B. As a consequence of the UF data structure, u 1 and u 2 belong to the same partition P at line 6 of Algorithm 3. We will show that u 1 and u 2 are consecutively selected at line 10 of the Reunite algorithm. Observe that in Reunite, strings selected at line 10 have a lonely prefix (as a consequence of Lemma 5), and strings selected at line 7 do not. If u 1 not does have a lonely prefix, u 1 must be selected at line 7 of Reunite. Then, u 2 is selected at the next execution of line 10. Now, assume that u 1 has a lonely prefix. Then by Lemma 7, there</p><formula>exists v 2 ;. .. ; v a such that suf k ðv i Þ ¼ pre k ðv iÀ1 Þ for 1 &lt; i a and v</formula><p>Compacting de Bruijn graphs from sequencing data quickly and in low memory i205 exists strings v 1 ;. .. ; v a such that suf k ðv i Þ ¼ pre k ðv iÀ1 Þ for 0 &lt; i a and v a has a non-lonely prefix. Then, since v a does not have a lonely prefix, v a is selected at line 7 of Reunite, and it follows that v aÀ1 ;. .. ; v 1 ; u 1 ; u 2 are consecutively selected at the following executions of line 10. We conclude that Glueðu 1 ; u 2 Þ is performed in all cases. The action of Glue reduces the multiplicity of x from 2 to 1, and furthermore x becomes either an internal k-mer or a non-lonely end of a string in G. h Let R final be the set of strings that might remain in R at the end of the algorithm. LEMMA 9. sp k ðGÞ has only single elements, and is equal to Set(B).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>PROOF.</head><p>The only difference between B and G [ R final is caused by executing the Glue function, which only affects the k-spectrum by changing the multiplicity of k-mer from 2 to 1. By Lemma 8, all kmers will have multiplicity one in G [ R final , and hence sp k ðG [R final Þ has only single elements and is equal to Set(B). It remains to show that R final is empty. All strings in R final have at least one lonely end, otherwise they would have been output at line 7 of CompactBucket(). By Lemma 6, such a lonely end must be a doubled k-mer. However, by Lemma 8, all doubled k-mers are either internal or non-lonely ends in G. Therefore, R final must be empty. h Finally, we are ready to prove the correctness of BCALM 2.We will show that the conditions of Lemma 1 are satisfied for G and U. The glue operation does not change the ðk þ 1Þ-spectrum, and R final ¼ 1, so sp kþ1 ðBÞ ¼ sp kþ1 ðG [ R final Þ ¼ sp kþ1 ðGÞ. Combining this with Lemma 3 and Lemma 4, we get that sp kþ1 ðGÞ ¼ sp kþ1 ðBÞ ¼ A ¼ sp kþ1 ðUÞ and that, because A is duplicate free by definition, these spectrums do not contain duplicates. Combining Lemma 4 and Lemma 9, we also get that sp k ðGÞ ¼ K and by Lemma 2, sp k ðUÞ ¼ K. h</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Optimizations and implementation</head><p>In this section, we describe some of the optimizations and important implementation details that we used to implement the pseudocode of Section 4. For the sake of brevity, we have only described the algorithm for the directed de Bruijn graph. In our implementation, we extend the algorithm to the bidirected graph model (<ref type="bibr" target="#b16">Kececioglu, 1992;</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experimental results</head><p>We evaluated the scalability of BCALM 2, and how it compares to other tools for compacting the de Bruijn graph. Experiments were run on a single machine equipped with an Intel Xeon CPU with 32 cores clocked at 2.76 GHz and 512 GB of memory. We used two human sequencing datasets from the GAGE benchmark (<ref type="bibr" target="#b32">Salzberg et al., 2011</ref>) and from and two larger datasets from the spruce and pine sequencing projects (<ref type="bibr" target="#b0">Birol et al., 2013;</ref><ref type="bibr" target="#b37">Zimin et al., 2014</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Human datasets</head><p>The first dataset is Illumina reads from a human chromosome 14 (36 million, 155 bp each, 2.9 GB compressed FASTQ). The second dataset is Illumina reads from the whole human genome NA18507 (1.4 billion, 100 bp each, 54 GB compressed FASTQ, SRA SRX016231).We first evaluate how BCALM 2 is affected by changes in the parameters k (k-mer size) and ' (minimizer length).<ref type="figure" target="#fig_9">Figure 2</ref>(a) shows that BCALM 2 has nearly identical running times for 6 ' 10, and across all tested k values. Shorter minimizers sizes such as ' ¼ 4 create fewer buckets, hence limit parallel speedups. Second, we evaluate how well BCALM 2 scales with multiple processors.<ref type="figure" target="#fig_9">Figure 2</ref>(b)</p><formula>(a) ( b)</formula><p>shows that compaction and Reunite steps scale almost linearly with the number of threads. There remains overheads related to disk I/O. We compare the performance of BCALM 2 to other available implementation of compaction algorithms: (i) our own previous serial compaction algorithm BCALM (<ref type="bibr" target="#b3">Chikhi et al., 2014</ref>), (ii) the parallel ABYSS-P step of the ABySS assembler (version 1.9.0), excluding bubble removal (<ref type="bibr" target="#b33">Simpson et al., 2009</ref>), (iii) the parallel compaction step of the Meraculous 2 assembler (version 2.0.5), executed from the mergraph to the contigs step (<ref type="bibr" target="#b9">Georganas et al., 2014</ref>) and (iv) the single-threaded unitig construction step of the Minia assembler (version 2.0.3) (<ref type="bibr" target="#b2">Chikhi and Rizk, 2012</ref>). There are other promising stand-alone tools that implement parallel de Bruijn graph compaction, but we found them to either not be publicly available (<ref type="bibr" target="#b15">Jackson et al., 2010</ref>) or unable to run on real mammalian data because of an upper bound of 31 on the k-mer size (<ref type="bibr" target="#b21">Liu et al., 2011;</ref><ref type="bibr" target="#b28">Meng et al., 2014</ref>). For BCALM, the datasets were first processed using the DSK kmer counting software (<ref type="bibr" target="#b31">Rizk et al., 2013</ref>) to generate the set of kmers. In addition to the results shown in<ref type="figure" target="#tab_1">Table 1</ref>, Minia took 27 h and 7 GB of memory on the whole human dataset (using identical k and abundance cutoff as in the table). For ABySS-P, the shown numbers include the k-mer counting step, which could not be extricated from the software. For the purposes of comparison, the k-mer counting step to generate the input for BCALM 2 completed in 46 mins and 2 GB of memory for the whole human dataset.<ref type="figure" target="#tab_1">Table 1</ref>shows that BCALM 2 outperforms existing techniques in terms of running time. Since multiple graph compactions are done in parallel, BCALM 2 requires more memory than BCALM, however it is more memory-efficient than Meraculous 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Pine and spruce datasets</head><p>We further evaluated BCALM 2 on two very large sequencing datasets: Illumina reads from the 20 Gbp Picea glauca genome (8.5 billion reads, 152–300 bp each, 1.1 TB compressed FASTQ, SRA056234) (<ref type="bibr" target="#b0">Birol et al., 2013</ref>), and Illumina paired-end reads from the 22 Gbp Pinus taeda genome (9.4 billion reads, 128–154 bp each, 1.2 TB compressed FASTQ, SRX016231). The k-mer counting step took around a day and &lt;40 GB of memory for each dataset.<ref type="figure">Table 2</ref>shows the performance of BCALM 2 on these two datasets, as well as unitigs statistics. Graph construction of the spruce dataset previously required 4.3 TB of memory and 2 days on a 1380-core cluster (<ref type="bibr" target="#b0">Birol et al., 2013</ref>), while the assembly of the pine dataset previously required 800 GB of memory and 3 months on a single machine (<ref type="bibr" target="#b37">Zimin et al., 2014</ref>). Another execution of BCALM2 on the same datasets using a value of k¼61 shows similar performance, see Supplemental<ref type="figure" target="#tab_1">Table 1</ref>. Although we used the same sequencing datasets, several parameters differ between these previous reports and our results (e.g. k value, abundance cutoff, and whether reads were error-corrected). Hence run time, memory usage, and unitigs statistics cannot be directly compared. However, it seems reasonable to infer that BCALM 2 would remain 1–2 orders of magnitude more efficient in time and memory. In addition, we tested the robustness of BCALM 2 to an even larger number of erroneous k-mers by reducing the k-mer abundance cutoff to 2. The k-mer counting and compactions steps completed also within 2 days and 40 GB of memory. The resulting unitig file was much larger (resp. 67 GB and 107 GB). This is expected, due to a large number of sequencing errors resulting in erroneous k-mers being incorporated into the graph (roughly 2 billion k-mers in both cases, i.e. %2k Â 10 9 ¼ 62 Gbp of new unitigs). A non-negligible amount of sequencing errors is also likely present in the data presented in<ref type="figure">Table 2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Discussion</head><p>In this paper, we present BCALM 2, an open-source parallel and lowmemory tool for the compaction of de Bruijn graphs. BCALM 2 constructed the compacted de Bruijn graph of a human genome sequencing dataset in 76 mins and 3 GB of memory. Furthermore, k-mer counting and graph compaction using BCALM 2 of the 20 Gbp white spruce and the 22 Gbp loblolly pine sequencing datasets required only 2 days and 40 GB of memory each. BCALM 2 is different from previous approaches in several regards. First, it is a separate module for compaction, with the goal that it can be used as part of any other tools that build the de Bruijn graph. While parallel genome assemblers offer impressive performance, there are many situations where differences in data require the development of a new assembler, and hence it is desirable to buildFor BCALM 2 and BCALM we used k ¼ 55, and ' ¼ 8 and ' ¼ 10, respectively; abundance cutoffs were set to 5 for Chr 14 and 3 for whole human. We used 16 cores for the parallel algorithms ABySS, Meraculous 2 and BCALM 2. Meraculous 2 aborted with a validation failure due to insufficient peak k-mer depth when we ran it with abundance cutoffs of 5. We were able to execute it on chromosome 14 with a cutoff of 8, but not for the whole genome. ( Ã )For the whole genome, we show the running times given in<ref type="bibr" target="#b9">Georganas et al. (2014)</ref>. The exact memory usage was unreported there but is less than &lt;1 TB. Meraculous 2 was executed with 32 prefix blocks.The k-mer size was 31 and the abundance cutoff for k-mer counting was 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Compacting de Bruijn graphs from sequencing data quickly and in low memory i207</head><p>modular components. Second, we do not aim at a method that can be distributed on a cluster over thousands of nodes. While clearly powerful, such machines are not usually accessible to a biology lab, and we believe that a tool that uses a shared memory multi-core machine is more applicable. Methods that are designed for multi-node clusters will often consume a prohibitive amount of memory when run on multiple threads of a shared memory machine.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>et al. (2014) used minimizers to compact the de Bruijn graph of a human whole-genome dataset in under 50 MB of memory, but the algorithm did not improve the running time. Wu et al. (2012) propose an approach based on dividing the assembly problem into mutually independent instances. Ye et al. (2012) exploit the notion of graph sparseness for reducing memory use. Kleftogiannis et al. (2013) perform a comparative analysis and propose several memory-reducing strategies. Chikhi and Rizk (2012) use Bloom filters to reduce memory usage. Movahedi et al. (2012) propose a divide-and-conquer approach for compacting a de Bruijn graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Algorithm1.</head><figDesc>BCALM 2(K) Input: the set of k-mers K. 1: for all parallel x 2 K do 2: Write x to FðlmmðxÞÞ. 3: if lmmðxÞ 6 ¼ rmmðxÞ then 4: Write x to FðrmmðxÞÞ. 5: for all parallel i 2 f1;. .. ; 4 ' g do 6: Run CompactBucket(i) 7: ReuniteðÞ Algorithm 2. CompactBucket(i)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Algorithm3.</head><figDesc>Reunite()</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.1.</head><figDesc>Fig. 1. Execution of BCALM 2 on a small example, with k ¼ 4 and ' ¼ 2. On the top left, we show the input de Bruijn graph. The maximal unitigs correspond to the path from CCCT to TCTA (spelling CCCTCTA), and to the k-mers CCCC, CCCA, CTAC, CTAA. In this example, minimizers are defined using a lexicographic ordering of '-mers. In the top right, we show the contents of the bucket files. Only five of the bucket files are non-empty, corresponding to the minimizers CC, CT, AA, AC and CA. The doubled k-mers are italicized. Below that, we show the set of strings that each i-compaction generates. For example in the bucket CC, the k-mers CCCT and CCTC are compacted into CCCTC, however CCCC and CCCT are not compactable because CCCA is another out-neighbor of CCCC. The lonely ends are denoted by @BULLET. In the bottom half we show the execution steps of the Reunite algorithm. Nodes in bold are output</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><figDesc>a has a non-lonely prefix. Furthermore, y ¼ suf k ðv 2 Þ ¼ pre k ðv 1 Þ and x ¼ suf k ðv 1 Þ ¼ pre k ðuÞ. In addition, all strings u; v 1 ;. .. ; v a must be distinct, else duplicates will yield circular unitigs. h</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig.2.</head><figDesc>Fig. 2. BCALM 2 wall-clock running times with respect to (a) parameters ' and k (using 4 cores) and (b) number of cores (using k ¼ 55 and ' ¼ 8), on the chromosome 14 dataset</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. Running times (wall-clock) and memory usage of compaction algorithms for the human datasets.</figDesc><table>Dataset 
BCALM 2 

BCALM 

ABySS-P 
Meraculous 2 

Chr 14 
5 mins 
15 mins 
11 mins 
62 mins 
400 MB 
19 MB 
11 GB 
2.35 GB 
Whole human 
1.2 h 
12 h 
6.5 h 
16 h Ã 
2.8 GB 
43 MB 
89 GB 
unreported Ã 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 2. Performance of BCALM 2 on the loblolly pine and white spruce datasets.</figDesc><table>Dataset 
Loblolly pine 
White spruce 

Distinct k-mers (Â10 9 ) 
10.7 
13.0 
Num threads 
8 
16 
CompactBucket() time 
4 h 40 m 
3 h 47 m 
CompactBucket() mem 
6.5 GB 
6 GB 
Reunite file size 
85 GB 
140 GB 
Reunite() time 
4 h 32 m 
3 h 08 m 
Reunite() memory 
31 GB 
39 GB 

Total time 
9 h 12 m 
6 h 55 m 
Total max memory 
31 GB 
39 GB 

Unitigs (Â10 6 ) 
721 
1200 
Total length 
32.3 Gbp 
49.0 Gbp 
Longest unitig 
11.2 kbp 
9.0 kbp 

</table></figure>

			<note place="foot">R.Chikhi et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Medvedev et al., 2007), in the natural way, to handle the doublestranded nature of DNA. To compute minimizers, we do not use a lexicographical ordering of &apos;-mers, as this has been previously shown to lead to unbalanced bucket files and increased memory usage (Chikhi et al., 2014; Deorowicz et al., 2014). Deorowicz et al. (2014) proposed to use the lexicographic order but to forbid certain well known frequent &apos;-mers from being minimizers (e.g. the poly-A). We use frequency based minimizers, which we proposed in an earlier work (Chikhi et al., 2014). In this approach, an initial &apos;-mer counting step is performed on the data and &apos;-mers are ordered by increasing frequency. Because &apos; is small, the time and memory for this step is negligible. Buckets are organized into groups, in order to introduce natural checkpoints in BCALM 2 in between parallel sections. BCALM 2 iterates sequentially through the groups, but parallelizes the processing within a group. The For loop at line 1 of Algorithm 1 is executed in parallel within a group, with each thread given a subset of K. k-mers are distributed only to those buckets that are in the group, with other buckets being ignored. Bucket files are implemented as threadsafe queues, as opposed to physical files on disk. The statements at lines 2 and 4 of Algorithm 1 enqueue x into the appropriate queue, and Algorithm 2 dequeues them at line 1, instead of reading them from disk. After the k-mers are distributed, buckets from a group are compacted in parallel. The CompactBucket routines are independent of each other, and hence we run CompactBucket(i) in parallel using all available processors. After a BCALM 2 finishes processing a group, it moves on to the next group. To reduce memory of the UF data structure, we created a minimal perfect hash function (MPHF) (Cormen, 2009) of all distinct k-mer extremities in the Reunite file (denote their number as d). The UF structure is therefore implemented as a vector v of MPHF indices, of total size dlogd. The UF class of a given k-mer is therefore v½x, where x is the MPHF index of the k-mer. The BCALM 2 algorithm takes as input a set of distinct k-mers. However, in our implementation, BCALM 2 is developed using the GATB library (Drezen et al., 2014), allowing it to seamlessly integrate GATB&apos;s k-mer counter. Therefore, the BCALM 2 software takes reads as input, and executes this k-mer counter prior to compaction. This is a disk-based algorithm inspired by KMC2 (Deorowicz et al., 2014) and DSK (Rizk et al., 2013). In this k-mer counter, k-mers are divided into partitions according to their minimizer, then each partition is counted independently. We modified the GATB k-mer counting algorithm so that partition files correspond exactly to bucket groups. We obtained further optimizations by representing strings using two bits per character.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank Kamesh Madduri for helpful discussions, Colleen O'Rourke and Guillaume Rizk for code contributions. We used computing resources from the ICS@PSU and GenOuest infrastructures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This work has been supported in part by NSF awards DBI-1356529, CCF1439057, IIS-1453527 and IIS-1421908 to PM. Conflict of Interest: none declared.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Assembling the 20 gb white spruce (Picea glauca) genome from whole-genome shotgun sequencing data</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Birol</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1492" to="1497" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Ray: simultaneous assembly of reads from a mix of high-throughput sequencing technologies</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Boisvert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1519" to="1533" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Space-efficient and exact de Bruijn graph representation based on a Bloom filter</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Chikhi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Rizk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<publisher>WABI Springer</publisher>
			<biblScope unit="volume">7534</biblScope>
			<biblScope unit="page" from="236" to="248" />
			<date type="published" when="2012" />
			<publisher>WABI Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">On the representation of de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Chikhi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In: Research in Computational Molecular Biology</title>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="page" from="35" to="55" />
			<date type="published" when="2014" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">H</forename>
				<surname>Cormen</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>MIT Press</publisher>
			<pubPlace>Cambridge</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title level="m" type="main">Kmc 2: Fast and resource-frugal k-mer counting. arXiv Preprint</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Deorowicz</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">GATB: genome assembly &amp; analysis tool box</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Drezen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="2959" to="2961" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Hipga: A high performance genome assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Duan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE IPDPSW 2014</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="576" to="584" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Ggake: Gpu based genome assembly using k-mer extension</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Garg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE HPCC_EUC 2013</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1105" to="1112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Parallel de bruijn graph construction and traversal for de novo genome assembly</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Georganas</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis</title>
		<meeting>the International Conference for High Performance Computing, Networking, Storage and Analysis</meeting>
		<imprint>
			<publisher>IEEE Press</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="437" to="448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Hipmer: an extreme-scale de novo genome assembler</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Georganas</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis. ACM</title>
		<meeting>the International Conference for High Performance Computing, Networking, Storage and Analysis. ACM</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<monogr>
		<title level="m" type="main">High-quality draft assemblies of mammalian genomes from massively parallel sequence data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gnerre</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<publisher>PNAS</publisher>
			<biblScope unit="page">1513</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Full-length transcriptome assembly from RNASeq data without a reference genome</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">G</forename>
				<surname>Grabherr</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="644" to="652" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">De novo assembly and genotyping of variants using colored de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Iqbal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="226" to="232" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Parallel construction of bidirected string graphs for genome assembly</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">G</forename>
				<surname>Jackson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Aluru</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ICPP&apos;08. 37th International Conference on Parallel Processing</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="346" to="353" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Parallel de novo assembly of large genomes from high-throughput short reads</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">G</forename>
				<surname>Jackson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE IPDPS</title>
		<imprint>
			<publisher>IEEE</publisher>
			<biblScope unit="page" from="1" to="10" />
			<date type="published" when="2010" />
			<publisher>IEEE</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<monogr>
		<title level="m" type="main">Exact and Approximation Algorithms for DNA Sequence Reconstruction</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Kececioglu</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
			<pubPlace>Tucson, AZ, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Comparing memory-efficient genome assemblers on stand-alone and cloud infrastructures</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Kleftogiannis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PloS One</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">75505</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient parallel and out of core algorithms for constructing large bi-directed de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<forename type="middle">K</forename>
				<surname>Kundeti</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">560</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Memory efficient minimum substring partitioning</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VLDB Endowment</title>
		<meeting>. VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="169" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Pasqual: parallel techniques for next generation genome sequence assembly</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Liu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel Distributed Syst</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="977" to="986" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Parallelized short read assembly of large genomes using de bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Liu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">354</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<monogr>
		<title level="m" type="main">Gpu-accelerated bidirected de bruijn graph construction for genome assembly</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Lu</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>Web Technologies and Applications Springer</publisher>
			<biblScope unit="page" from="51" to="62" />
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<monogr>
		<title level="m" type="main">SOAPdenovo2: an empirically improved memory-efficient short-read de novo assembler</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Luo</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Marc¸ais</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Kingsford</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="764" to="770" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<monogr>
		<title level="m" type="main">Computability of models for sequence assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2007" />
			<publisher>WABI</publisher>
			<biblScope unit="page" from="289" to="301" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Efficient counting of k-mers in DNA sequences using a Bloom filter</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Melsted</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">K</forename>
				<surname>Pritchard</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">333</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Small world asynchronous parallel model for genome assembly</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Meng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Network and Parallel Computing</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="145" to="155" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<monogr>
		<title level="m" type="main">SWAP-Assembler: Scalable and efficient genome assembly towards thousands of cores</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Meng</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<publisher>RECOMB-Seq</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">A framework for scalable genome assembly on clusters, clouds, and grids</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Moretti</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Parallel Distributed Syst</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="2189" to="2197" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">De novo co-assembly of bacterial genomes from multiple single cells</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">S</forename>
				<surname>Movahedi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE BIBM 2012</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">DSK: k-mer counting with very low memory usage</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Rizk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="652" to="653" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">GAGE: a critical evaluation of genome assemblies and assembly algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">Tiger: tiled iterative genome assembler</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<forename type="middle">L</forename>
				<surname>Wu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">18</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">Exploiting sparseness in de novo genome assembly</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Ye</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">1</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<monogr>
		<title level="m" type="main">Improved parallel processing of massive de bruijn graph for genome assembly</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Zeng</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>Web Technologies and Applications Springer</publisher>
			<biblScope unit="page" from="96" to="107" />
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title level="a" type="main">Sequencing and assembly of the 22-gb loblolly pine genome</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Zimin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">196</biblScope>
			<biblScope unit="page" from="875" to="890" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>