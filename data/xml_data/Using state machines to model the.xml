
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:34+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Using state machines to model the Ion Torrent sequencing process and to improve read error rates</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2013">2013</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">David</forename>
								<surname>Golan</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Statistics and Operations Research</orgName>
								<orgName type="department" key="dep2">School of Mathematical Sciences</orgName>
								<orgName type="institution">Tel-Aviv University</orgName>
								<address>
									<postCode>69978</postCode>
									<settlement>Tel-Aviv, Israel</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Paul</forename>
								<surname>Medvedev</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Biochemistry and Molecular Biology</orgName>
								<orgName type="institution">The Pennsylvania State University</orgName>
								<address>
									<postCode>16802</postCode>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Using state machines to model the Ion Torrent sequencing process and to improve read error rates</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">29</biblScope>
							<biblScope unit="page" from="344" to="351"/>
							<date type="published" when="2013">2013</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btt212</idno>
					<note>BIOINFORMATICS</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>Contact: davidgo5@posttauacil</keywords>
			</textClass>
			<abstract>
				<p>Motivation: The importance of fast and affordable DNA sequencing methods for current day life sciences, medicine and biotechnology is hard to overstate. A major player is Ion Torrent, a pyrosequencing-like technology which produces flowgrams – sequences of incorporation values – which are converted into nucleotide sequences by a base-calling algorithm. Because of its exploitation of ubiquitous semiconductor technology and innovation in chemistry, Ion Torrent has been gaining popularity since its debut in 2011. Despite the advantages, however, Ion Torrent read accuracy remains a significant concern. Results: We present FlowgramFixer, a new algorithm for converting flowgrams into reads. Our key observation is that the incorporation signals of neighboring flows, even after normalization and phase correction , carry considerable mutual information and are important in making the correct base-call. We therefore propose that base-calling of flowgrams should be done on a read-wide level, rather than one flow at a time. We show that this can be done in linear-time by combining a state machine with a Viterbi algorithm to find the nucleotide sequence that maximizes the likelihood of the observed flowgram. FlowgramFixer is applicable to any flowgram-based sequencing platform. We demonstrate FlowgramFixer&apos;s superior performance on Ion Torrent Escherichia coli data, with a 4.8% improvement in the number of high-quality mapped reads and a 7.1% improvement in the number of uniquely mappable reads. Availability: Binaries and source code of FlowgramFixer are freely available at: http://www.cs.tau.ac.il/$davidgo5/flowgramfixer.html.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The importance of fast and affordable DNA sequencing methods for current day life sciences, medicine and biotechnology is hard to overstate. Ion Torrent's semiconductor sequencing technology, as implemented in its Personal Genome Machine (PGM), has been gaining popularity as a fast and affordable sequencing platform since it's debut in 2011 (<ref type="bibr" target="#b9">Merriman et al., 2012;</ref><ref type="bibr" target="#b13">Rothberg et al., 2011</ref>). Semiconductor sequencing has several advantages compared with other high-throughput sequencing platforms, including lack of optics, use of natural, unmodified dNTP molecules and exploitation of ubiquitous semiconductor technology. These advances make Ion Torrent a serious player in the sequencer market, providing reads several hundred bases long and reducing sequencing costs (<ref type="bibr" target="#b4">Eisenstein, 2012</ref>). Ion Torrent is a pyrosequencing-like platform, similar to 454. In every sequencing step, or flow, the chip is washed over with a specific nucleotide. The nucleotide in the flow is incorporated by all consecutive complementary nucleotides 'hanging' at the end of each template—this is called incorporation. Each incorporation releases an ion, so that the change in pH level indicates whether incorporation occurred and, if so, the number of consecutive bases incorporated. The nucleotide that is washed during each flow is pre-determined and is composed from several repetitions of a shorter sequence of nucleotides known as the 'wash cycle'. The default wash cycle for 454 is 4 nt long: TACG, whereas Ion Torrent's PGM uses a more complicated wash cycle that is 32 nt long. The resulting read is then specified in terms of a flowgram—a sequence of incorporation values, one for each flow.<ref type="figure">Figure 1</ref>gives an overview of the process. Despite its advantages, Ion Torrent read accuracy remains a significant concern. Errors are produced during base-calling, a process by which the noisy signal from the sequencer is converted into a sequence of nucleotides. Base-calling errors can especially pose challenges for re-sequencing projects, where they can be confused with SNPs. In fact, a recent comparative study found that Ion Torrent's PGM still suffers from high– false-positive rates in SNP calling, relative to Illumina data (<ref type="bibr" target="#b10">Quail et al., 2012</ref>). There is a large body of work on base-calling algorithms [see<ref type="bibr" target="#b7">Ledergerber and Dessimoz (2011)</ref>for a survey], and there have been several techniques developed specifically for pyrosequencing data (<ref type="bibr" target="#b2">Beuf et al., 2012;</ref><ref type="bibr" target="#b8">Lysholm et al., 2011;</ref><ref type="bibr" target="#b11">Quince et al., 2011;</ref><ref type="bibr" target="#b12">Quinlan et al., 2008;</ref><ref type="bibr" target="#b14">Vacic et al., 2008</ref>). These techniques have mostly focused on correcting 454's well-documented (<ref type="bibr" target="#b0">Balzer et al., 2010</ref>) errors in long homopolymer runs or alignment of their flowgrams. However, there has been little work done in correcting base-calling errors in Ion Torrent data. Ion Torrent's base-calling algorithm, after performing phasecorrection and normalizing to handle signal decay, simply translates the rounded values of each flow into the corresponding number of consecutive nucleotides. In essence, it is a memoryless algorithm that makes a call for each flow independent of information from previous or following flows. Our key observation is that the signals of neighboring flows carry considerable mutual information and are important in making the correct base-call. We propose that base-calling of flowgrams should be done on a read-wide level, rather than one flow at a time. To this end, we design a linear-time method that combines a state machine with a Viterbi algorithm to find the nucleotide sequence that maximizes the likelihood of the observed flowgram. Our algorithm is applicable to any flowgram-based sequencing platform and is implemented in a publicly available tool called FlowgramFixer. We demonstrate FlowgramFixer's superior performance on Ion Torrent Escherichia coli data, with a 4.8% improvement in the *To whom correspondence should be addressed. ß The Author 2013. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com number of high-quality mapped reads and a 7.1% improvement in the number of uniquely mappable reads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND AND MOTIVATING EXAMPLES</head><p>We denote the set of possible DNA sequences by 'nt-space', i.e. the space of possible combinations of the four nucleotides A, C, G and T. The Ion Torrent platform does not provide us directly with the read in nucleotide space, but instead, we observe the incorporation signal at each flow. It is, therefore, useful to define 'flow-space', as the vector of incorporation signals (flowgram) obtained per flow by a perfect (noiseless) sequencing process. For example, if the flow nucleotides are two repetitions of the wash cycle 'ACGT', and the sequence itself is GCCT, then the flowspace representation is (0,0,1,0,0,2,0,1). The actual signal is noisy; therefore, the observed flowgram is not a sequence of integers, but rather a sequence of non-negative real values. The noise is due to a range of artifacts. First, Ion Torrent's platform uses discrete time measurements from the pH sensors at the bottom of each well to fit a theoretical physical model of a continuous time process (nucleotide incorporation). The process of nucleotide incorporation is random by nature and is affected by various factors ranging from random changes of dNTP molecule concentration to random fluctuations in fluiddynamics because of bubbles or turbulences. And so, the theoretical physical model does not capture the full complexity of the sequencing process and does not always fit the observed signals perfectly, resulting in noisy signal. Second, the signal decays over time, as at each flow a small fraction of the template clones attached to each bead are terminated and no longer incorporate additional nucleotides (this phenomenon is known as 'drooping'). Thus, the actual signal observed at each flow decays over time. Although this phenomenon is not by itself a source of noise, the decay of the signal decreases the signal-to-noise ratio, making correct calling harder as the sequencing process progresses. Finally, some of the template clones drop out of phase as the sequencing progresses. Even when the current nucleotide in the flow should be incorporated by all template clones, clones might not, by chance, incorporate it (for example, if no dNTP molecule is found in the physical vicinity of the template). These clones would incorporate the nucleotide at the next flow of the same nucleotide. Hence, the signal becomes unphased—the observed signal is a superposition of lagged copies of the true signal, where the lags depend on the wash cycle and the underlying sequence itself. As the initial step of its base-calling software, Ion Torrent performs phase-correction and signal decay normalization algorithms. A typical flowgram, after this correction, is shown in<ref type="figure" target="#fig_3">Figure 2</ref>. The resulting incorporation values are still noisy, and, to convert them to nucleotide space, Ion Torrent rounds them to the nearest integer. Although this last step is effective and scalable, we find that it is suboptimal for several reasons. First, rounding the signal flow-by-flow might result in an 'impossible' sequence of signals. Consider the following toy example, where the first nucleotide is T and the wash cycle is ACGT. The expected signal is (0,0,0,1)—no incorporation in the first three flows, and an incorporation of a single nucleotide in the fourth flow. Next, imagine that because of noise, the measured signal is (0.1,0.05,0.08,0.4). Rounding the signal would result in (0,0,0,0). Such a flow-sequence implies that the first nucleotide cannot be A, C, G or T—an impossibility. However, by observing the whole sequence of incorporation values together, we would have been able to deduce that the fourth incorporation of 0.4 should be rounded up, not down. Second, the probability of observing an incorporation event depends on the incorporation signals of previous and next flows. Assume, for example, the same flow order as before, and assume that we have seen incorporations in the first three flows. This implies that the sequence starts with ACG, and that the next base in the sequence is not G (otherwise we would have seen two incorporation events in the third flow). Therefore, there are three possible candidates for the next nucleotide—A, C and T. Next, assume a different scenario—an incorporation event happened only in the second flow, with no incorporation in the first and third flows. In this case, the sequence starts with C, and the second nucleotide cannot be G (otherwise we would have seen an incorporation in the third flow), and it cannot be C (otherwise we would have seen two incorporations in the second flow). Hence, there are only two candidates for the next nucleotide—A and T. In the first scenario, the previous probability of observing an incorporation in the fourth flow is 1 3 , as T is one of three possible nucleotides, whereas in the second scenario, the previous probability is 1 2 , as T is one of only two possible nucleotides. Simply rounding the signal at each flow to the nearest integer ignores the previous probability obtained by considering the incorporations at previous flows. Future flows also carry useful information regarding a current flow in a similar manner.<ref type="figure">1</ref>. Ion sequencing work flow. The overall workflow is shown in (a). A genome library is prepared by fragmenting and size-selecting DNA, followed by the ligation of forward and reverse adapters (b). Each adapter-ligated template is clonally amplified onto a bead, so that each bead contains many copies of the same DNA template (c). Sequence on the chip, sequencing primers and DNA polymerase are then bound to the beads, which are pipetted into wells on the chip (d). The chip is then repeatedly flooded by nucleotides, which, when binding to the complementary nucleotide on a template, release an ion. At each flow, the electrical signal at each well is measured, indicating the number of incorporations<ref type="bibr">[</ref>Finally, rounding signals ignores other previous information regarding the genome, such as GC-content and the lower frequencies of longer homopolymers. One can think of the rounding method as setting a threshold of 0.5 and calling an incorporation event when the incorporation signal is higher than the threshold. When sequencing genomes that are known to be GC-rich, it is reasonable to use different thresholds for flows with different washed nucleotides. For example, when the flow is either G or C, an incorporation event is more likely before observing the signal, compared with flows of A or T. Similarly, longer homopolymers are less likely; therefore, the threshold for calling 0mer versus 1mer need not be the same threshold as the one used in calling 5mer versus 6mer [similar to what is done for 454 reads by<ref type="bibr">Quinlan</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">METHODS</head><p>Motivated by the examples of the previous section, we develop a method that finds a nucleotide sequence that maximizes the likelihood of the observed flowgram. We start by describing the underlying state machine that captures the sequencing process. We then define the distributions necessary for calculating the likelihood. Finally, we describe two dynamic programming algorithms—a Viterbi algorithm to find the maximum likelihood nucleotide sequence, and a forward algorithm to obtain maximum-likelihood estimates of the noise-model parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">State machine model</head><p>To connect flow-space and nucleotide-space, one can ask, at each flow, what are the different possibilities for the next nucleotide. For instance, at the first flow, we have no information at all, and the first base of the sequence could be A, C, G or T. If the first flow presents no incorporation, the possible candidates become C, G and T and so forth. This process is illustrated on our previous toy example in<ref type="figure" target="#tab_1">Table 1</ref>. More generally, we define a deterministic state machine (<ref type="bibr" target="#b5">Hopcroft and Ullman, 1979</ref>). There are 15 states, corresponding to the 2 4 À 1 ¼ 15 possible sets of candidate nucleotides. Each state represents the possible nucleotides for the next position, in nucleotide-space. It is convenient to think of the binary representation of the number as indicating which nucleotides are candidates, or, alternatively, as an actual set containing the appropriate subset of base letters. The initial state is fA, C, G, Tg. Given a flow nucleotide, a state s can transition to at most two states, one where an incorporation occurs, denoted s þ , and one where no incorporation occurs, denoted s À. For example, when the state is s ¼ fA, C, Tg, and the flow nucleotide is A, the next state can be either s þ ¼ fC, G, Tg (if there is an incorporation event, A is now the only noncandidate) or s À ¼ fC, Tg (if there is no incorporation event, A is no longer a candidate). When the flow nucleotide is not one of the candidates given by the current state, there is no incorporation transition. Thus, each state has at most eight outgoing transitions. A path in the state machine is a sequence of transitions from the initial state. Given a wash cycle, a flow-sequence defines a path in the state machine in the obvious manner.<ref type="figure" target="#fig_5">Figure 3</ref>illustrates the transitions of a state machine on a simple wash cycle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Problem formulation</head><p>Let O ¼ o 1 ,. .. o n denote the observed (normalized and phase-corrected) incorporation values, with F ¼ f 1 ,. .. , f n being the true (noiseless) values in flow-space. F defines a path in the state machine,Note: Here, the wash cycle is ACGT and the sequenced string is GCCT. Initially, any nucleotide is possible—the candidates are ACGT. The first flow (A) produces no incorporation signal; therefore, the candidates for the next nucleotide are CGT. After an incorporation event, as in flows 3 and 6, the candidate nucleotides for the next base in the sequence are all the nucleotides except for the one that was just incorporated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i346</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.Golan and P.Medvedev</head><p>S ¼ s 0 , s 1 ,. .. , s n , s nþ1 , where s i is the state after the application of flow f i. We let s 0 be the initial state before any incorporations, i.e. s 0 ¼ fA, C, G, Tg. The likelihood of the flows F given the observed values O is given by:</p><formula>LðFjOÞ ¼ Y n i¼1 Pðs iÀ1 ! s i Þ' , i ðo i jf i ÞÁ Á À Ifs þ iÀ1 ¼ s i gIf f i 40gð f i Þ þ Ifs À iÀ1 ¼ s i gIff i ¼ 0g Á ,</formula><p>where Pðs iÀ1 ! s i Þ is the probability of transition from state s iÀ1 to state s i , is a previous distribution over the lengths of homopolymers in the genome and ' , i is the probability density at flow i of o i given that the number of incorporations is f i , governed by a set of parameters. The indicator functions I, in the second line of the equation, are used to determine whether the state transition dictates an incorporation event, and whether the incorporation value f i matches the incorporation value dictated by the state transition. Thus, impossible state transitions, or incorporation values that are impossible, given the state transition get a likelihood of 0. For example, if s À i ¼ s iþ1 , then f i must be 0, otherwise the likelihood is 0. For ease of notation, we define the distribution of f i , conditional on the state transition:</p><formula>0 ðf i js i , s iþ1 Þ ¼ Iff i ¼ 0g s iþ1 ¼ s À i ð f i Þ s iþ1 ¼ s þ i 0 otherwise 8 &lt; : 0 replaces</formula><p>both the indicator functions and the previous. It is also defined for all state pairs, yielding 0 when the state pair is not a pair of legitimate consecutive states. Using this notation, we can rewrite the likelihood equation:</p><formula>LðFjOÞ ¼ Y n i¼1 Pðs iÀ1 ! s i Þ 0 ðf i js iÀ1 , s i Þ 4' , i ðo i jf i Þ:</formula><p>We now proceed to define the three distributions necessary to evaluate this equation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Transition probabilities</head><p>The probability of transitioning from one state to the next depends on the size of the state (number of candidate nucleotides) and the probability of observing a given nucleotide in the genome. These depend on the nucleotide used in the i'th flow, which we denote as w i. Given p GC , the probability of observing a G or C nucleotide in the genome in question (i.e. the GC-content of the genome), we denote</p><formula>p C ¼ p G ¼ 1 2 p GC and p A ¼ p T ¼ 1 2 À 1 2 p GC</formula><p>the probabilities of individual nucleotide types. When the GC-content of the genome is not known, we use p GC ¼ 0:5. The transition probabilities are then given by:</p><formula>Pðs ! s þ Þ ¼ pw i P x2s px w i 2 s 0 w i = 2 s 8 &lt; : : Pðs ! s À Þ ¼ 1 À PðS iþ1 ¼ s þ jS i ¼ sÞ</formula><p>For the simple case of p GC ¼ 0:5, we get:</p><formula>PðS iþ1 ¼ s þ jS i ¼ sÞ ¼ 1 jsj w i 2 s 0 w i = 2 s : &amp;</formula><p>Note that invalid transitions have zero probability, e.g. an incorporation of a T in state fA, C, Gg is impossible and has zero probability because w i ¼ T = 2 fA, C, Gg. In this case s À ¼ s, as no incorporation leaves the state machine at the same state. Similarly, the incorporation of a T in state fTg is much more likely than in state fA, C, G, Tg. Thus, these probabilities capture most of the intuition presented in the motivating examples of Section 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Homopolymer length distribution () The likelihood frame</head><p>work allows for an easy integration of , the previous information regarding the distribution of homopolymers' lengths in the genome. One appropriate prior that we use is the geometric distribution: Pðf i ¼ mÞ ¼ p mÀ1 wi ð1 À p wi Þ, where p wi is the proportion of the current flow nucleotide w i in the genome. If no previous information exists on the GC-content of the genome, as is the case for the standard 454 base-calling algorithm (<ref type="bibr" target="#b7">Ledergerber and Dessimoz, 2011</ref>), then p wi can be set to 1 4. Another possibility is to use the non-informative flat prior. Although the flat prior is an improper prior, for all practical purposes it can be used in this scenario. The immediate interpretation of this prior is that we have no information at all regarding the distribution of homopolymer sizes. Alternatively, other priors can be specified, for example, an empirical Bayes prior as in<ref type="bibr">Quinlan et al. (2008). 3.2.3 Noise model (' , i</ref>) Finally, we specify the noise model. We denote the standard deviation of the noise model at flow i by i , and</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i347</head><p>Improved base-calling for Ion-Torrent via state-machines we denote the set of parameters that governs the behavior of i. Let ' , i be the probability density function at flow i given the parameters. Hence, ' , i ðo i 4j 4f i Þ is the probability density of o i given that the number of incorporations is f i , that the flow cycle is i and that the parameter set is. We assume a double exponential distribution around the true number of incorporated nucleotides, i.e. the probability density of observing the incorporation value o i when the true number of incorporations is f i and the flow cycle is i is given by:</p><formula>1 ffiffi ffi 2 p i e À ffi ffi 2 p jf i Ào i j i :</formula><p>Note the non-standard parameterization using the standard deviation instead of the usual rate parameter. We use this parameterization to allow easy interpretation of the parameters in terms of standard deviations. To allow i to increase with the progression of the sequencing process, we assume a linear dependency of i on the flow cycle index i:</p><formula>i ¼ 0 þ 1 i,</formula><p>where 0 is the intercept term, giving the standard deviation at the first flow cycle, and 1 is the trend term, giving the increment in the standard deviation of the noise from one flow cycle to the next. Thus, ¼ ð 0 , 1 Þ. Although richer noise models are conceivable, a simple noise model is required to maintain a reasonable running time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Dynamic programming algorithms</head><p>Having fully defined the likelihood function (given a set of noise model parameters ), we now seek to find the series of true incorporation values (F) that would maximize the likelihood of the observed incorporation values (O). To this end, we apply the standard Viterbi dynamic programming algorithm (<ref type="bibr" target="#b3">Durbin et al., 1998</ref>). The Viterbi algorithm works by constructing a table where each element V i, j is the maximum log-likelihood of observing flows o 1 ,. .. , o i , given that the last state of the state machine is s i ¼ j. The maximum log-likelihood of O is then given by the arg max s2S V s, n , where S is the set of 15 possible states. To construct the table, we apply the standard Viterbi recurrence relation to the log our likelihood function:</p><formula>V iþ1, j ¼ max s2S, f2Zþ V i, s þ log Pðs ! jÞ þ log 0 ð f js, jÞ þ log ' , i ðo i j f Þ,</formula><p>Intuitively, we wish to compute the log-likelihood of the max-likelihood path of length i þ 1 ending at state j, given the log-likelihoods of the maxlikelihood paths ending at the previous flow i (given by V i, 1 ,. .. , V i, 15 ). We iterate over all possible previous states and all possible incorporation values and for each such pair ðs, fÞ update the log-likelihood to account for the additional state transition, the additional flow value and the additional observed value. We then set V iþ1, j to be maximal value over all such pairs. However, whenever s 0 = 2 s þ , s À the probability Pðs ! s 0 Þ is 0. This is the case for most state pairs and can be used to greatly accelerate the algorithm. Specifically, it is enough for the recurrence to only consider values of s such that j 2 fs þ , s À g. Moreover, not all values of f are possible for all state transitions. If j ¼ s þ i , then f 6 ¼ 0, and if j ¼ s À i , then f ¼ 0. Given these simplifications, we can rewrite the recurrence as V þ iþ1, j ¼ max s s:t: s þ ¼j, f40 V i, s þ log Pðs ! jÞ þ log ðfÞ þ log ' , i ðo i j f Þ, V À iþ1, j ¼ max s s:t: s À ¼j V i, s þ log Pðs ! jÞ þ log ' , i ðo i j0Þ,</p><formula>V iþ1, j ¼ maxfV þ iþ1, j , V À iþ1, j g</formula><p>That is, we optimize separately for the case of incorporation (V þ iþ1, j ) and for the case of no incorporation (V À iþ1, j ), taking the maximal value of the two. In theory, one still needs to iterate over all possible value of f when computing V þ iþ1, j. However, one can assume that all homopolymers are shorter than a certain length M. The Ion Torrent software sets M ¼ 13. As the running time of the algorithm is linear in M, we chose an adaptive approach; we set a different value for each flow, given by M i ¼ maxf o i d e þ 2, 4g. This reduces the value of M i for most flows, thus greatly reducing the overall running time. To obtain the maximum likelihood path, one only has to keep track of the values of s and f that are used to maximize each recurrence. We can then start with the optimal last state (arg max s2S V s, n ) and work our way backward using the standard dynamic programming backtracking procedure. The running time of the algorithm is linear in n. The dynamic programming table contains n rows and jSj ¼ 15 columns. To compute the value of each cell, we must consider two values for s and M i values for f. The backtracking algorithm is also linear in the size of the table. Therefore, the time complexity of the algorithm is O(nM), where M ¼ max M i. The space complexity is O(n), which is the size of the table.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">Estimating the noise-model parameters</head><p>The likelihood of a set of noise model parameters can be calculated efficiently using the forward algorithm (<ref type="bibr" target="#b3">Durbin et al., 1998</ref>); thus, the maximum likelihood estimators of the parameters can be used in the Viterbi. The forward algorithm is similar in spirit to the Viterbi algorithm. Given a value of the parameter set , we define L i, j ðÞ as the likelihood of observing flows o 1 ,. .. , o i , given that the last state of the state machine is s i ¼ j. The likelihood of the specific set of parameters is then given by LðÞ ¼ P s2S L s, n ðÞ. A table is constructed in a similar manner to the Viterbi algorithm, with the major differences being using likelihoods instead of log likelihoods and summing over all previous states rather than using only the maximal previous state:</p><formula>L iþ1, j ðÞ ¼ X s2S, f2Zþ L i, s ðÞPðs ! jÞ Â 0 ð f j s, jÞ' , i ðo i j f Þ:</formula><p>As in the case of the Viterbi algorithm, the specific state machine set-up enables faster computations by taking into account only possible state transitions and possible incorporation values. As the likelihood of a set of parameters can be computed by the aforementioned forward algorithm, a reasonable approach would be finding the maximum likelihood estimator of and plugging it into the Viterbi algorithm. Although this approach is appealing, for every value of , the likelihood needs to be re-evaluated, resulting in a considerable increase in running time. We, therefore, suggest applying this procedure to a subset of flowgrams and use the mean value of as the parameter for the rest of the flowgrams. The maximization itself can be carried out using an exhaustive grid search. However, we found that using the greedy algorithm obtained similar results to the grid search (results not shown) while requiring only a fraction of the likelihood evaluations. Both methods are implemented in FlowgramFixer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.2">Relationship to a hidden Markov model</head><p>Finally, we wish to note the resemblance of our method to a hidden Markov model (HMM) technique (<ref type="bibr" target="#b1">Baum and Petrie, 1966</ref>). In fact, our model can be expressed as an HMM by representing every consecutive pair of states as a singlehidden state and constructing transition and emission probabilities accordingly. However, we find the presentation via state machine to be more intuitive and straightforward.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i348</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.Golan and P.Medvedev</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>We demonstrate our method using a publicly available dataset from Ion Torrent's webpage, namely, C11-278. C11-278 is a resequencing experiment of E.coli DH10B, using the PGM with an Ion 318 chip. We extracted the normalized and phase-corrected incorporation signals from the SFF files. The file contained 6 742 759 flowgrams and 1.65 Gb, respectively. The PGM was run using a wash cycle of 32 bases: TACGTACGTCTGAGCATCGATCGATGTACAGC, and used 520 flows. We note this is the default Ion Torrent wash cycle. We first ran the default calling algorithm, which is equivalent to rounding the signals in the SFF file. We use this algorithm as a baseline for our comparisons. We then ran FlowgramFixer, which took $4 h on a single CPU (Xeon E7-8837 @ 2.67 GHz) with inconsequential memory use (510 Mb). This run included a preliminary step of estimating the optimal noise-model parameters for a subset of 20 384 flowgrams, using a greedy algorithm, computing the mean intercept and trend and running the Viterbi on the entire dataset using the mean parameters. To ensure reproducibility, the subset of flowgrams we used originated from a 200-by-200 wells region from the chip, which were pre-specified by Ion Torrent and available on their website as an exploratory dataset. The mean intercept and trend were 0.0377 and 1:766 Â 10 À4 , respectively. The output of each algorithm is a list of integer-valued flowgrams, which we converted to reads and aligned to the reference with bowtie2 (<ref type="bibr" target="#b6">Langmead and Salzberg, 2012</ref>) using default parameters. First, we compared the number of uniquely aligned reads. The baseline rounding method yielded 3 537 723 uniquely mapped reads, whereas FlowgramFixer yielded 3 788 697—an increase of 250 974 reads (7.1%). Second, we counted how many reads (hard clipped at 200 bp) were mapped uniquely with highmapping quality (<ref type="figure">Table 2</ref>). FlowgramFixer outperformed the baseline rounding method for all quality thresholds, with a 2.8–4.8% increase in the number of high-quality aligned reads. We wanted to study the effect of the position along the wash cycle on error rates. For each flowgram corrected by the baseline method, we converted the aligned-to part of the reference genome to a flowgram and noted the flow positions that had a mismatch. We then averaged the error rates of flows that are identical mod 32 (the length of the wash cycle) (<ref type="figure" target="#fig_6">Fig. 4</ref>). It is evident that different positions along the wash cycle display remarkably different error rates. This can partially be explained by patterns in the wash cycle. For example, positions 9–11 contain the nucleotides T, C and T. Because of the first T, the probability of observing incorporation at the second T is much lower; therefore, more flows have no incorporations. As no incorporations are easier to call, the error rate at the second T is much lower as well. A similar situation occurs at positions 25–27, containing T, G and T. Positions 11 and 27 are highlighted in red in<ref type="figure" target="#fig_6">Figure 4</ref>. The opposite effect can also be observed, such as the A at position 13. As there is a large gap between the appearance of the previous A (position 6), there is a higher probability of incorporation and, hence, of error. A similar situation occurs with the C at position 29. These positions are highlighted in green in<ref type="figure" target="#fig_6">Figure 4</ref>. Next, we investigated the dependence of the error rate on the flow position. The average error-rates per flow of the rounding algorithm are portrayed in<ref type="figure">Figure 5</ref>. It is clear that the vast majority of errors occur at the ends of the flowgrams, and that such a high-error rate renders the ends of Ion Torrent reads useless. As this is the case for most, if not all, high-throughput sequencing technologies, most real-life applications involve a step of 'clipping'—removing the 3 0-end of each read—either by setting a pre-defined length (hard clipping) or using a reference genome to determine the optimal cut-off point (soft clipping). We, therefore, applied soft clipping to the 3 0-end of each read using bowtie2 (using the local parameter) and re-estimated the</p><formula>T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C 0 5 10 15 20 25 30 0.2 0.4 0.6 0.8 1.0 1.2 1.4</formula><p>Position within wash cycle Average error rate (%)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i349</head><p>Improved base-calling for Ion-Torrent via state-machines per-flow error rates. The rounding algorithm had an average error rate of 0.88% per flow (<ref type="figure">Fig. 6</ref>). We note that this is probably the most common pipeline used in re-sequencing experiments. Running FlowgramFixer yielded an average error rate of 0.7%, a reduction of % 21% compared with the baseline. To test the robustness of this analysis to the choice of clipping method, we also tried hard clipping the reads at 200 and 300 nt.</p><p>In these cases, FlowgramFixer reduced the error rate by 17 and 21%, respectively. We then compared the error rates of the two methods, per position (<ref type="figure">Fig. 7</ref>). Although the maximum obtained difference is as high as 3.4%, there are other positions where rounding actually does slightly better than FlowgramFixer. We believe that this may be because the variability in the noise at some positions of the wash cycle increases as the sequencing process progresses. We discuss possible solutions in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>We have focused on developing a general inference framework without making it overly reliant on the current intricacies of Ion Torrent's platform. However, there are several possible extensions that, although making the approach less robust to technology changes, could improve its performance on today's datasets. We discuss several such ideas later in the text. Our noise model relies on a intercept and trend model for the standard deviation (SD) parameter. One might suggest richer models, including more complicated dependency of the SD on the flow index, dependency of the SD on the number of incorporated nucleotides and a dependency on the position along the basic 32-nt wash cycle. We briefly experimented with these ideas and were not able to find a richer model that improved the results while maintaining a reasonable running time. However, exploring these ideas further seems worthwhile. Additionally, we suggest that additional accuracy gains might be gained by adding a spatial structure to the noise model, as nearby wells experience similar artifacts during the sequencing process. G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G TFig. 7. Error rate difference between the rounding method and FlowgramFixer (baseline error rate À FlowgramFixer error rate). The average difference of error rate grows as the sequencing process progresses, as expected because of the noisier signal obtained at later flows. Although at some flows, the error rate decreases by as much as 3.4%, at other flows the error rate actually increases. Interestingly, the error rate difference also displays a dependency on the position in the wash cycle<ref type="figure">Fig. 6</ref>. Per-flow error rates of the rounding algorithm, using soft clipping. As expected, the error rate increases as the sequencing process progresses, even after clipping. The dependency of the error rate on the position in the wash cycle is also evident. Similarly to<ref type="figure" target="#fig_6">Figure 4</ref>, flows that are 11th or 27th within a cycle (marked red) display a considerably lower error rate, whereas flows that are 13th within a cycle (marked green) display considerably higher error rates T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G<ref type="figure">Fig. 5</ref>. Per-flow error rates of the default calling algorithm used as a baseline for comparison. The error rate clearly increases with the flow number, with a dramatic increase beginning around flow 380 i350</p><formula>C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G</formula><formula>G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G 0 100 200 300 400 0 2 4 6 8 Flow # Error rate (%)</formula><formula>A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A C A G C T A C G T A C G T C T G A G C A T C G A T C G A T G T A</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>D.Golan and P.Medvedev</head><p>Our approach has the advantage that phase correction is done by Ion Torrent's software before our analysis, thus reducing running times. However, one can think of combining the phasing and the calling algorithms into one probabilistic framework. Such a framework could help eliminate some of the artifacts introduced by the phasing algorithm and improve the quality of both the phasing and base-calling. The use of smarter priors and better parameters can also improve the accuracy. Some Ion Torrent reads contain test fragments of pre-determined DNA sequence, which can be used to optimize parameter values, such as our. Furthermore, our maximum-likelihood framework allows for easy inclusion of priors on GC-content and homopolymer lengths. We suspect that incorporating an empirical Bayes before as in<ref type="bibr" target="#b12">Quinlan et al. (2008)</ref>would increase the accuracy of our method. The impact of such priors would be greatest for genomes where the GCcontent is different from 0.5, unlike E.coli. The dynamic programming approach allows for other relevant extensions. For example, a forward–backward algorithm, similar to the forward algorithm, can be used to compute the marginal distributions of the flow values and derive statistically sound quality scores. Finally, we note that our approach is embarrassingly parallelizable and low-memory. We, therefore, believe it could be run in a matter of minutes on a multi-core machine. Moreover, if incorporated into the Ion Torrent pipeline, it could be run 'live' as the sequencing process happens, making the running time inconsequential. In fact, the running time of our algorithm is similar to the running time of the subsequent alignment step; therefore, we believe that as long as the running time of our method remains reasonable, it should not be a bottleneck for end-users.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>Although we are encouraged by the results of FlowgramFixer presented here, we recognize the quick pace at which technology evolves. As Ion Torrent continues to improve its sequencing technology (e.g. its new Ion Proton sequencing platform), it is likely that important parameters, such as the wash cycle, will evolve and the specific error profiles we observe today will evolve as well. However, we believe our major innovation— that inference should and could be done efficiently on the whole flowgram rather than flow-by-flow—will remain relevant for any future flowgram-based technology. Such technologies have been a major workhorse of the scientific community for several years, and it is likely they would remain relevant in upcoming years.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.</head><figDesc>Fig. 1. Ion sequencing work flow. The overall workflow is shown in (a). A genome library is prepared by fragmenting and size-selecting DNA, followed by the ligation of forward and reverse adapters (b). Each adapter-ligated template is clonally amplified onto a bead, so that each bead contains many copies of the same DNA template (c). Sequence on the chip, sequencing primers and DNA polymerase are then bound to the beads, which are pipetted into wells on the chip (d). The chip is then repeatedly flooded by nucleotides, which, when binding to the complementary nucleotide on a template, release an ion. At each flow, the electrical signal at each well is measured, indicating the number of incorporations [Figure adapted from Rothberg et al. (2011)]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>Fig. 1. Ion sequencing work flow. The overall workflow is shown in (a). A genome library is prepared by fragmenting and size-selecting DNA, followed by the ligation of forward and reverse adapters (b). Each adapter-ligated template is clonally amplified onto a bead, so that each bead contains many copies of the same DNA template (c). Sequence on the chip, sequencing primers and DNA polymerase are then bound to the beads, which are pipetted into wells on the chip (d). The chip is then repeatedly flooded by nucleotides, which, when binding to the complementary nucleotide on a template, release an ion. At each flow, the electrical signal at each well is measured, indicating the number of incorporations [Figure adapted from Rothberg et al. (2011)]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>et al. (2008) and others].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.2.</head><figDesc>Fig. 2. Typical flowgram. We show the normalized and phase-corrected signal of a single flowgram. The actual nucleotide in each flow is indicated by the appropriate letter. Ideal signals are expected to be integers, indicating exactly how many nucleotides were incorporated during each flow. However, the actual signal at each flow is noisy, and the noise increases as the sequencing process advances</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.3.</head><figDesc>Fig. 3. Illustration of state machine transitions. In this example, the flow is composed of repetitions of the wash cycle ACGT and the state machine starts from the state {A,C,G,T}. Each layer of the figure illustrates the possible states at that flow index. Incorporation and no incorporation transitions are marked by solid and dashed edges, respectively. Note that nodes with a single nucleotide dictate incorporation in the next flow and have no outgoing dashed edges</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.4.</head><figDesc>Fig. 4. Dependence of error rate on wash cycle. Average error rates along the 32-nt long wash cycle, for the rounding method. The actual nucleotide in each flow is indicated by the corresponding letter. We used the first 320 flows to calculate the rates and discarded the first cycle to cancel the effect of the sequencing adapter. Note the high dependence of the error rate on the position in the wash cycle—positions 13 and 27 (colored red) display a considerably low error rate, whereas positions 11 and 29 (colored green) display a considerably high error rate. These changes in error rate can be partially explained by patterns in the wash cycle</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. Representing the set of possible nucleotides after each flow</figDesc><table>Flow No. 
Flow 
nucleotide 

Candidates 
Remaining 
sequence 

Signal 

1 
A 
ACGT 
GCCT 
0 
2 
C 
C G T 
G C C T 
0 
3 
G 
GT 
GCCT 
1 
4 
T 
ACT 
CCT 
0 
5 
A 
AC 
CCT 
0 
6 
C 
C 
T 
2 
7 
G 
A G T 
T 
0 
8 
T 
A T 
— 
1 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 2.</figDesc><table>Number of reads (hard clipped at 200 bp) mapping with quality 
above the given thresholds 

MAPQ ! 20 
MAPQ ! 30 
MAPQ ! 40 

Baseline 
5 463 391 
4 867 523 
4 857 829 
FlowgramFixer 
5 617 599 
5 098 930 
5 088 117 
Difference 
154 208 
231 407 
230 288 
Improvement (%) 
2.8 
4.8 
4.7 

Note: We used 20, 30 and 40 as MAPQ thresholds, corresponding to mis-alignment 
probabilities of 0.01, 0.001 and 0.0001, respectively. FlowgramFixer is able to 
accurately map up to 4.8% more reads than the baseline. 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors thank Saharon Rosset and four anonymous reviewers for helpful comments and Robert Harris for assistance with the implementation of FlowgramFixer.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Characteristics of 454 pyrosequencing data—enabling realistic simulation with flowsim</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Balzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="420" to="425" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Statistical inference for probabilistic functions of finite state markov chains</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Baum</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Petrie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Math. Stat</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="1554" to="1563" />
			<date type="published" when="1966" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Improved base-calling and quality scores for 454 sequencing based on a Hurdle Poisson model</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Beuf</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">303</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title level="m" type="main">Biological Sequence Analysis: Probabilistic Models of Proteins and Nucleic Acids</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, UK</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">The battle for sequencing supremacy</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Eisenstein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1023" to="1026" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title level="m" type="main">Introduction to Automata Theory, Languages and Computation</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">E</forename>
				<surname>Hopcroft</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Ullman</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1979" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with Bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Base-calling for next-generation sequencing platforms</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Ledergerber</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Dessimoz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="489" to="497" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">FAAST: flow-space assisted alignment search tool</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Lysholm</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">293</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Progress in Ion Torrent semiconductor chip based sequencing</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Merriman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Electrophoresis</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="3397" to="3417" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">A tale of three next generation sequencing platforms: comparison of Ion Torrent, Pacific Biosciences and Illumina MiSeq sequencers</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Quail</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genomics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">341</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Removing noise from pyrosequenced amplicons</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Quince</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">38</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Pyrobayes: an improved base caller for SNP discovery in pyrosequences</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">R</forename>
				<surname>Quinlan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="179" to="81" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">An integrated semiconductor device enabling non-optical genome sequencing</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">M</forename>
				<surname>Rothberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">275</biblScope>
			<biblScope unit="page" from="348" to="352" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">A probabilistic model for small RNA flowgram matching</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Vacic</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Pacific Symposium on Biocomputing</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="75" to="86" />
		</imprint>
	</monogr>
	<note>i351. Improved base-calling for Ion-Torrent via state-machines</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>