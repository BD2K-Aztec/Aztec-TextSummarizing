
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:47+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sequence analysis BatMis: a fast algorithm for k-mismatch mapping</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Chandana</forename>
								<surname>Tennakoon</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">NUS Graduate School for Integrative Sciences and Engineering, (CeLS)</orgName>
								<address>
									<addrLine>28 Medical Drive</addrLine>
									<postCode>#05-01, 117456</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Rikky</forename>
								<forename type="middle">W</forename>
								<surname>Purbojati</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">NUS Graduate School for Integrative Sciences and Engineering, (CeLS)</orgName>
								<address>
									<addrLine>28 Medical Drive</addrLine>
									<postCode>#05-01, 117456</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Wing-Kin</forename>
								<surname>Sung</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">NUS Graduate School for Integrative Sciences and Engineering, (CeLS)</orgName>
								<address>
									<addrLine>28 Medical Drive</addrLine>
									<postCode>#05-01, 117456</postCode>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alex</forename>
								<surname>Bateman</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">School of Computing</orgName>
								<orgName type="laboratory">Computational Biology Lab</orgName>
								<orgName type="institution">National University of Singapore</orgName>
								<address>
									<addrLine>21 Lower Kent Ridge Road</addrLine>
									<postCode>119077</postCode>
									<country>Singapore, Singapore</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sequence analysis BatMis: a fast algorithm for k-mismatch mapping</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="issue">16</biblScope>
							<biblScope unit="page" from="2122" to="2128"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts339</idno>
					<note type="submission">Received on December 6, 2011; revised on May 27, 2012; accepted on June 6, 2012</note>
					<note>Copyedited by: SK MANUSCRIPT CATEGORY: ORIGINAL PAPER [18:49 19/7/2012 Bioinformatics-bts339.tex] Page: 2122 2122–2128 Associate Editor: Availability and implementation: BatMis is written in C/C++ and is freely available from http://code.google.com/p/batmis/ Contact: ksung@comp.nus.edu.sg Supplementary Information: Supplementary information is available from Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Second-generation sequencing (SGS) generates millions of reads that need to be aligned to a reference genome allowing errors. Although current aligners can efficiently map reads allowing a small number of mismatches, they are not well suited for handling a large number of mismatches. The efficiency of aligners can be improved using various heuristics, but the sensitivity and accuracy of the alignments are sacrificed. In this article, we introduce Basic Alignment tool for Mismatches (BatMis)—an efficient method to align short reads to a reference allowing k mismatches. BatMis is a Burrows–Wheeler transformation based aligner that uses a seed and extend approach, and it is an exact method. Results: Benchmark tests show that BatMis performs better than competing aligners in solving the k-mismatch problem. Furthermore, it can compete favorably even when compared with the heuristic modes of the other aligners. BatMis is a useful alternative for applications where fast k-mismatch mappings, unique mappings or multiple mappings of SGS data are required.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Second-generation sequencing (SGS) technologies generate a high volume of sequencing data economically and this abundance of data has introduced new possibilities to genomic studies. Applications such as whole-genome sequencing (<ref type="bibr" target="#b5">Hillier et al., 2008</ref>), gene expression profiling (<ref type="bibr" target="#b15">Mortazavi et al., 2008</ref>) and ChIPseq (<ref type="bibr" target="#b14">Mikkelsen et al., 2007</ref>) have benefited from it. All these applications need to map the SGS reads to a reference genome. Due to the differences between the sampled genome and the reference genomes and the errors introduced during the sequencing process, the mapping needs to be done allowing a reasonable number of errors. Mapping SGS reads in general require the ability to map indels. However, for platforms like Illumina and SOLiD, most of the reads can be aligned allowing mismatches only. In fact, some popular aligners like Bowtie (<ref type="bibr" target="#b8">Langmead et al., 2009</ref>) only † The authors wish it to be known that, in their opinion, the first two authors should be regarded as joint First Authors. * To whom correspondence should be addressed. consider mismatches in alignment, while many others consider only mismatches by default (<ref type="bibr" target="#b9">Lin et al., 2008;</ref><ref type="bibr" target="#b17">Weese et al., 2009</ref>). There are many experiments where a large number of mismatches are allowed, sometimes along with indels (<ref type="bibr" target="#b3">Eckerle et al., 2010;</ref><ref type="bibr" target="#b13">Markljung et al., 2009</ref>). Therefore, the k-mismatch problem, i.e. mapping a short read allowing k-mismatches to a reference genome, is an interesting problem in bioinformatics. Although the general k-mismatch problem can be solved heuristically with generic aligners like BLAST (<ref type="bibr" target="#b0">Altschul et al., 1990</ref>) or exactly with aligners like BWT-SW (<ref type="bibr" target="#b7">Lam et al., 2008</ref>), they are not practical solutions to handle tens of millions of reads produced by SGS. Therefore, specialized aligners for short read mapping are needed and the existing aligners can be broadly categorized into two classes. The first class uses a variety of hashing methods or the indexing data structure BWT to index the reference genome (<ref type="bibr" target="#b8">Langmead et al., 2009;</ref><ref type="bibr" target="#b10">Li and Durbin, 2010</ref>). Others use hashing methods to index the reads (<ref type="bibr" target="#b9">Lin et al., 2008;</ref><ref type="bibr" target="#b11">Li et al., 2008</ref>). Then, by enumerating possible mismatch patterns, the reads are aligned onto the genome. When the number of mismatches is not high, these aligners are very efficient. However, the running time will increase rapidly when the number of mismatches increases. The hashing-based methods become slow since they need to look up many hash table entries as the number of allowed mismatches increases. BWT-based aligners, since they simulate suffix/prefix tree traversal, become slow due to the rapid increase of branches that needs to be traversed as the number of mismatches increases. As shown in Section 3, the current aligners are slow or inadequate to handle even moderate numbers of mismatches. To overcome the slowdown with large mismatches, aligners use various heuristic methods. A common solution is to use seeding methods [e.g. BWA, Bowtie and ELAND (<ref type="bibr" target="#b2">Cox, 2006)]</ref>. In these methods, selected seed regions of a read are aligned to the reference allowing a small number of mismatches and these alignments are extended allowing k mismatches. Some specialized methods like RazerS (<ref type="bibr" target="#b17">Weese et al., 2009</ref>) can guarantee to find a given percentage of correct alignments. These methods cut down the alignment time dramatically. However, applying these heuristics to solve the k-mismatch problem will result in a loss of sensitivity and accuracy. Different types of experiments require different types of mappings. The most basic type of alignment reports the first hit of a read satisfying a given mismatch threshold. However, in some experiments, hits are required to satisfy some form of a uniqueness criterion. For example, in ChIP-seq experiments, scientists might prefer to map reads uniquely for better accuracy. Other situations require multiple hits for each read. For example, RNA-seq pipelines like Tophat (<ref type="bibr" target="#b16">Trapnell et al., 2009</ref>) need an external aligner to</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fast algorithm for k-mismatch mapping</head><p>produce mappings of a given read, which are then post-processed for splice junctions. These pipelines usually require multiple mappings of a given read, since the first or the unique hits may map the read to pseudo-genes or map a read covering a splice junctions to a contiguous region in the genome. Although an aligner can be designed to perform extremely well for a first hit search, it might perform relatively slow for multiple and unique mappings. Therefore, it is preferable to have a mapping algorithm that can efficiently handle these common requirements. This article introduces a new exact method BatMis (Basic Alignment T ool for Mismatches) that solves the k-mismatch problem much faster than existing methods. BatMis does not use heuristics. It is an exact method that aligns a read to the reference genome with the minimum number of mismatches. BatMis can align a read allowing up to 10 mismatches in the whole read. Our benchmarks show that BatMis is at least as fast as the current aligners. It also shows that in many cases, BatMis can compete favorably even when compared with the heuristic modes of other aligners.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The k-mismatch problem</head><p>Let X and Y be two strings of equal length. The Hamming distance between X and Y measures the number of mismatches between X and Y and is denoted by d(X,Y ). Consider a genome T and a string R. The k-mismatch problem is to find all positions i such that d(R<ref type="bibr">[1..|R|]</ref>,T [i..i+|R|−1]) ≤ k. This article is also interested in reporting the occurrences in the order of increasing mismatches, i.e. we report i before i if d(R<ref type="bibr">[1..|R|]</ref>,T [i..i+|R|− 1]) &lt; d(R<ref type="bibr">[1..|R|]</ref>,T [i. .i +|R|−1]).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Suffix array and SA ranges</head><p>Suffix array is an index for exact string matching which was first introduced by<ref type="bibr" target="#b12">Manber and Myers (1990)</ref>. Let T [1..n] be a genome of length n where the nucleotides are represented by characters taken from the alphabet = {a,c,g,t}. We assume a special character $ appears at the end of T , and it is assumed to be lexicographically smaller than all characters in. We use the notation T * to denote the string constructed by reversing T [1..n−1] and appending $ to its end. The empty string is denoted by ε. The suffix array SA T [1..n] of T is a permutation of {1,...,n} such that, for any i &lt; j, the suffix starting at position SA T<ref type="bibr">[i]</ref>is lexicographically smaller than the suffix starting at position SA T<ref type="bibr">[j]</ref>. Let P be a string. Suppose SA T<ref type="bibr">[i]</ref>and SA T<ref type="bibr">[j]</ref>are the lexicographically smallest and largest suffixes, respectively, having P as a prefix. We define the interval<ref type="bibr">[i,j]</ref>as the SA T range of P. The length of the SA T range of P is j −i+1. In general, we will call SA T ranges and SA T * ranges as SA-ranges.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Exact matches with BWT</head><p>The BWT, or the Burrows–Wheeler transformation (<ref type="bibr" target="#b1">Burrows and Wheeler, 1994</ref>) B T of a string T is an easily invertible permutation of T. B T and SA T are related by the formula B T<ref type="bibr">[i]</ref><ref type="bibr" target="#b4">Ferragina and Manzini, 2000</ref>). The result of a backward search will not be a proper interval when the SA T range does not exist. We can find the SA T range of any pattern P by starting off with the empty string, whose SA T range is<ref type="bibr">[1,n]</ref>, and compute the SA T range of P<ref type="bibr">[i..n]</ref>using Lemma 2.1 for i = n down to 1. We call this the backward search for P in T. We further use the backward search for P * in T * to simulate the forward search for P in T. Both types of searches will find all occurrences of the pattern P in T , but the forward search is more natural when the pattern is searched from left to right, and the backward search is the natural choice when the pattern is searched from right to left. If an SA T range<ref type="bibr">[i,j]</ref>is returned after a backward search for P in T , P occurs at locations SA T<ref type="bibr">[p]</ref>,p = i,...,j, in T. If an SA T * range<ref type="bibr">[i,j]</ref>is returned after a forward search for P in T , P can be found at locations n−SA T *<ref type="bibr">[p]</ref>,p = i,...,j, in T. As an illustration, for the string T = acaactta$, we have</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B T = atc$aaatc, B T * = acca$atta</head><p>and SA T = (9,8,3,1,4,2,5,7,6),SA T * = (9,8,5,6,1,7,4,3,2).</p><p>When performing a backward search for ac in T by Lemma 2.1, we iteratively obtain the SA T ranges of c and ac, which are<ref type="bibr">[6,</ref><ref type="bibr">7]</ref>and<ref type="bibr">[4,</ref><ref type="bibr">5]</ref>, respectively. When performing a forward search for ac in T , we will search for ca in B T * using backward search, i.e. we iteratively obtain the SA T * ranges of a and ca, which are<ref type="bibr">[2,</ref><ref type="bibr">5</ref>] and<ref type="bibr">[6,</ref><ref type="bibr">7]</ref>, respectively. These will translate to Locations 1 and 4 in T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Description of the algorithm</head><p>Consider a reference T. Let R be a read and K be a mismatch threshold. Our aim is to find the set of all strings x in T such that d(x,R) ≤ K. Let H k R be the set of all substrings x in T such that d(x,R) = k for k = 1,...,K. Our aim is equivalent to computing</p><formula>either d(R l ,R l ) ≤ (k −1)/2 or d(R r ,R r ) ≤ (k −1)/2.</formula><p>Proof. When k is even, from the pigeon hole principle, we have the cases</p><formula>d(R l ,R l ) ≤ k/2 or d(R l ,R l ) &gt; k/2.</formula><p>In the first case, the proof is obvious. In the second case we have</p><formula>d(R r ,R r ) ≤ k −d(R l ,R l ) ≤ k −k/2−1 = k/2−1.</formula><p>Hence Case 1 follows. Similarly, we can show that Case 2 is true.</p><p>We can now re-state the algorithm as follows. When k is even, we extend patterns in</p><formula>k/2 i=0 H i R l ∪ k/2−1 i=0 H i</formula><p>Rr to obtain all k-mismatch patterns of R.</p><p>When k is odd, we extend patterns in</p><formula>(k−1)/2 i=0 H i R l ∪ (k−1)/2 i=0 H i</formula><p>Rr to obtain all k-mismatch patterns of R. The Phase 2 of the algorithm where the extension of patterns are performed is done using the procedures PExt and SExt. Given a set X of substrings of T , PExt(X,R,k) performs prefix extension of the strings x in X to form another set Y of strings y = x ·α of T until every string y ∈ Y satisfies either (1) |y|=|R| and d(y,R) ≤ k or (2) d(y,R<ref type="bibr">[1..|y|]</ref>) = k +1. Similarly, SExt(X,R,k) performs suffix extension of the strings x in X to form another set Y of strings y = α·x of T until every y ∈ Y satisfies either (1) |y|=|R| and d(y,R) ≤ k or (2) d(y,R<ref type="bibr">[|R|−|y|+1..|R|]</ref>) = k +1. The procedures use the following recurrences and their pseudocode is shown in<ref type="figure" target="#fig_0">Figure 1</ref>SExt({σ ·x},R,k), otherwise</p><p>Given these two procedures, the k-mismatch patterns of R can be computed as follows. When k is even, we report {x ∈ PExt</p><formula>k/2 i=0 H i R l ,R,k ∪ SExt k/2−1 i=0 H i Rr ,R,k ||x|=|R|,d(x,R) = k}. When k</formula><p>is odd, we report {x ∈</p><formula>PExt (k−1)/2 i=0 H i R l ,R,k ∪SExt (k−1)/2 i=0 H i Rr ,R,k ||x|=|R|,d(x,R) = k}.</formula><p>The above procedure not only computes all k-mismatch patterns of R, but also reports them in the increasing order of the number of mismatches. However, it is slow since it performs a lot of redundant computations. We can modify the seed extension routine to avoid redundant computations. We divide our seed extension procedure into K +1 iterations. For the kth iteration where k = 0,1,...,K, our procedure tries to obtain H k R , i.e. all kmismatch patterns of R. In the 0th iteration, we set H 0 R ={R} if R exists in T ; and H 0 R =∅ otherwise. For the remaining iterations, we will not generate H k R starting from scratch. Instead, our routine will check all the unsuccessfully extended patterns from the (k −1) st iteration and see if they can be extended and become a k-mismatch pattern of R. Precisely, the kth iteration is divided into two stages. The first stage tries to extend those unsuccessfully extended patterns from the (k −1) st iteration. The second stage tries to recover the remaining k-mismatch patterns by extending a special set of seeds that guarantees to generate all the remaining k-mismatch patterns with no redundancy. Before we give the details of Phase 2, we need some definitions to describe the set of unsuccessfully extended patterns from the (k −1) st iteration. By Lemma 2.2, if k −1 is odd, we need to extend the patterns in (k−2)/2</p><formula>i=0 H i R l ∪ (k−2)/2 i=0 H i</formula><p>Rr to obtain all the (k −1)-mismatch patterns of R. If k −1 is even, we need to extend the patterns in</p><formula>(k−1)/2 i=0 H i R l ∪ (k−3)/2 i=0 H i</formula><p>Rr to obtain all the (k −1)-mismatch patterns of R. When the extended patterns accumulate k mismatches, their extensions are stopped and are marked as unsuccessfully extended patterns. These unsuccessfully extended patterns are included in PRE k R and SUF k R depending on whether they have k mismatches with a prefix or a suffix of R, respectively. Formally, they are, defined as follows. (Note that k/2−1 = (k −2)/2 if k −1 is odd and (k −1)/2 if k −1 is even. In addition, k/2−1 = (k −2)/2 if k −1 is odd and (k −3)/2 if k −1 is even.) @BULLET Let PRE k R be the set of substrings x in T such that d(x,R<ref type="bibr">[1..|x|]</ref>) = k,</p><formula>x[|x|] = R[|x|] and d(x[1..|R l |],R l ) ≤≤k/2−1.</formula><p>@BULLET Let SUF k R be the set of substrings x in T such that d(x,R[|R|−|x|+</p><formula>1..|R|]) = k, x[1] = R[|R|−|x|+1] and d(x[|x|−|R r |+1..|x|],R r ) ≤ k/2−1.</formula><p>Intuitively, PRE k R contains a subset of the shortest substrings of T having exactly k mismatches with a prefix of R and SUF k R contains a subset of shortest substrings of T having exactly k mismatches with a suffix of R. The following lemma states how to compute the sets</p><formula>H 1 R ,PRE 2 R , and SUF 2 R. Lemma 2.3. Consider a read R. Let P = PExt(H 0 R l ,R,1) and S = SExt(H 0 Rr ∪ SUF 1 R ,R,1). a) H 1 R ={x ∈ P ∪S | d(x,R) = 1}. b) PRE 2 R ={x ∈ P | d(x,R[1..|x|]) = 2}. c) SUF 2 R ={x ∈ S | d(x,R[|R|−|x|+1..|R|]) = 2}.</formula><p>Proof. By Lemma 2.2, for any string R which has 1 mismatch with R,The following two lemmas state the recursive formulas to compute</p><formula>we have either R l = R l or R r = R r. Hence, H 1</formula><formula>H k R ,PRE k+1 R and SUF k+1 R for k ≥ 2.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2.4. Consider a read R and suppose k is odd. Let P</head><formula>= PExt(PRE k R ,R,k) and S = SExt(H k/2 Rr ∪SUF k R ,R,k). a) H k R ={x ∈ P ∪S | d(x,R) = k}. b) PRE k+1 R ={x ∈ P | d(x,R[1..|x|]) = k +1}. c) SUF k+1 R ={x ∈ S | d(x,R[|R|−|x|+1..|R|]) = k +1}.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fast algorithm for k-mismatch mapping</head><p>Proof. Let R be any string in T such that d(R ,R) = k, where k is odd. By Lemma 2.2, we have either</p><formula>(1) d(R l ,R l ) ≤ (k −1)/2 ==k/2−1 (i.e. R l ∈ k/2−1 i=0 H i R l ) or (2) d(R r ,R r ) ≤ (k −1)/2 ==k/2 (i.e. R r ∈ k/2 i=0 H i Rr ). If R satisfies (1)</formula><p>, there should be some λ, where |R l |≤λ ≤|R |, such that d(R</p><formula>[1..λ],R[1..λ]) = k, with R [λ] = R[λ]. By definition, R ∈{x ∈ P | d(x,R) = k}; if R satisfies (2), R ∈{x ∈ S | d(x,R) = k}. Hence, H k R ⊆{x ∈ P ∪S | d(x,R) = k}. Since H k</formula><p>R contains all k-mismatch stings of R in T , we have H k R ⊇{x ∈ P ∪S | d(x,R) = k}. From the last two relations, the first identity can be obtained. By definition, PRE k+1 R</p><formula>equals {x ∈ PExt(∪ (k+1)/2−1 i=0 H i R l ,R,k) | d(x,R[1..|x|]) = k +1} = {x ∈ PExt(∪ k/2−1 i=0 H i R l ,R,k) | d(x,R[1..|x|]) = k +1} = { x ∈ P | d(x,R[1..|x|]) = k +1}</formula><p>Using similar arguments, we can prove the third statement.) iteratively for k = 2,...,K (see lines 8−17). Finally, the program reports H k R for k = 0,...,K.</p><formula>P = PExt(H k/2 R l ∪ PRE k R ,R,k) and S = SExt(SUF k R ,R,k). a) H k R ={x ∈ P ∪S | d(x,R) =</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Details of implementation</head><p>We need to find all occurrences of strings corresponding to</p><formula>H i R l ,H i Rr ,PRE j R</formula><p>and SUF j R for 0 ≤ i ≤≤K/2,0 ≤ j ≤ K. Furthermore, we need an efficient way to extend them. To solve this problem, we build two BWT indexes B T andare represented by their SA T-ranges, where 0 ≤ i ≤≤K/2,0 ≤ j ≤ K. The extension of SA T *-ranges are done using forward search. Similarly, the extension of SA T-ranges is done using backward search. The strings in H k R will in general contain a mixture of SA T and SA T *ranges, and it might be necessary to convert SA T ranges to SA T * ranges or vice versa. This conversion is done by taking the string corresponding to SA T ( or SA T * ) range and performing a forward (or backward) search on it. To speedup pattern searching, we also build a table containing the SA-ranges of all substrings of length at most 6. This table can be used to calculate the SA-ranges corresponding to the first few bases of a string quickly. BatMis concatenates individual chromosomes of a genome into a single genome. The exact algorithm is run on this single genome. It might happen that a read will align to a chromosome boundary. These boundary errors occur very rarely, for example in the datasets we tested in Section 3 at most two such errors occurred per dataset. This accuracy is quite sufficient for practical purposes, but we have included a post-processing script to thoroughly resolve reads with boundary errors. The algorithm is implemented in C/C++. We use the BWT routines from BWT-SW (<ref type="bibr" target="#b7">Lam et al., 2008</ref>) program. After each SA range is obtained, the corresponding locations in the genome have to be decoded. The decoding algorithm is based on<ref type="bibr" target="#b6">Hon et al. (2004)</ref>. To facilitate the decoding, we store SA T<ref type="bibr">[i]</ref>for every i which is a multiple of some fixed length κ. To computeSA T<ref type="bibr">[i]</ref>, the algorithm counts the number of steps s needed to arrive at a sampled point B T<ref type="bibr">[s]</ref>by inverting the Burrows–Wheeler transform starting at B T<ref type="bibr">[i]</ref>. Then, SA T<ref type="bibr">[i]</ref>=SA T<ref type="bibr">[s]</ref>−s is computed. SA T * needs to be sampled as SA T * ranges need to be decoded as well. We improve this decoding step further in the following way. During the extension step, if the string being extended occurs uniquely in T and the corresponding SA-range was sampled, we save this SA-range. We next count the number of steps s needed to complete the extension. With this information, the location in the genome can be calculated using the formula above. In the actual implementation, since storing the sampled SA-ranges takes a lot of memory, the implementation can optionally convert all SA T ranges to SA T * ranges (or vice versa) and use only one sampling. For the human genome, if only one sampling is used with sampling length κ = 8, the decoding algorithm can be run under 4 GB of RAM. Furthermore, the recursions are unrolled for efficiency. For mismatch thresholds less than 5, the algorithm is implemented as stated. When scans are performed allowing a large number of mismatches, storing SUF i R and PRE i R requires a lot of memory. To reduce memory usage, for k &gt; 5, the set of k-mismatch hits, H k R , is computed directly based on Lemma 2.2. Although this approach reduces the memory required to store SUF i R and PRE i R for i &gt; 5, it will also generate duplicate hits. Post-processing steps are performed to remove the duplicate hits. When mapping SOLiD reads, the reference genome is converted to color space. To convert color space reads to nucleotide space, the algorithm given in BWA is used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>There are a vast number of sequence aligners that can perform exact k-mismatch alignment. Different aligners have different policiesfairly, we use datasets without uncalled bases. We test each program's ability to report the least mismatch hits, the unique hits and multiple hits. By the least mismatch hit of a read R in the reference T , we mean any position i such that d(R,T [i..i+|R|−1]) ≤ k, and for any other position j we have</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.Tennakoon et al.</head><formula>d(R,T [j..j +|R|−1]) ≥ d(R,T [i..i+|R|−1]</formula><p>). By a unique hit of a read R in the reference T , we mean a unique lowest mismatch hit of R in T. For comparison with our algorithm, we chose BWA (version 0.5.9-r16) to represent aligners of the BWT family, RazerS2 to represent q-gram methods and ZOOM (Linux64 demo version 1.5.5.20120225072719) to represent methods that use gapped seeds. We believe that these programs are among the best in the literature for handling a large number of mismatches. All the experiments were done on a Linux server running on 2×6-Core Intel Xeon X5680 Processors (3.33 Ghz), with 144 GB RAM. Each aligner was run in a single core, and the user time was reported. All tested programs were run in their default settings with appropriate options for ignoring indels and enabling exact mapping set as needed. The demo version of ZOOM is only fully sensitive up to four mismatches. Because of this limitation, ZOOM was run allowing up to four mismatches only. Both BatMis and RazerS2 can report least mismatch hits and unique hits. For BWA, the default setting will report a unique hit if it exists or will otherwise report a random least mismatch hit. For ZOOM, the default mode outputs only the unique hits; it was made to output least mismatch hits with the-mk option. BWA, ZOOM and BatMis used the same reference genome where uncalled bases in the genome were replaced with a random nucleotide. For BWA and BatMis, the total time for the alignment and decoding the output is reported. For BatMis, postprocessing was done to recover hits with boundary errors, and this time was added to the total time reported. All the command line parameters to obtain each table are described in the Supplementary material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Ability to detect mismatches</head><p>In this section, we examine the robustness of mismatch mappings of the selected aligners. We randomly extracted two sets of 51 bp and 100 bp reads from regions of hg18. Each dataset contained 100 000 reads. New k-mismatch datasets were created by introducing exactly k mismatches uniformly at random to all reads in the original dataset for k = 0,1,2,3,4,5,8 and 10. If an aligner performs k-mismatch mapping correctly, it must be able to map all k-mismatch reads to the reference genome allowing k-mismatches. Supplementary<ref type="figure" target="#tab_1">Table 1</ref>summarizes these results. BWA missed some hits with a large number of mismatches for 100 bp reads. It was able to map all the reads with up to five mismatches, but was only able to map 97 291 and 15 124 of reads having 8 and 10 mismatches, respectively. Other aligners were able to map back all the reads. This result suggests that BatMis, ZOOM and Razers2 can detect k-mismatches effectively but BWA might miss some hits when k is large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Mapping real data</head><p>This section studies the performance of different algorithms using real data. We first check the performance of each aligner when reporting the least mismatch hits. Many biologists prefer to have unique hits as a criteria to filter out noise. Therefore, we also measure the performance of different aligners on finding unique hits in real data. The evaluation used the Illumina sequencing datasets ERR000577 and ERR024201 taken from the European Nucleotide Archive. The datasets contained reads of lengths 51 bp and 100 bp, respectively. These datasets are paired end reads, and we chose the datasets containing the forward reads. Reads containing uncalled bases were filtered out, and the first 1 000 000 reads were selected for benchmarking. These sets of reads were mapped to the reference genome hg18 allowing different numbers of mismatches. ZOOM and Razers2 produce a small number of false mappings. The results of these mappings are given in Tables 1 and 2.In general, all aligners report a similar number of hits for both 51 bp and 100 bp reads. However, BWA will report significantly less number of hits compared with the other aligners when the number of mismatches is large. For all the reads where another aligner can find a least mismatch hit, BatMis will also report a least mismatch hit. In addition, BatMis will report all the correct unique hits found by other aligners.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Fast algorithm for k-mismatch mapping</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Multiple mappings</head><p>We benchmarked the time taken by each aligner to produce multiple mappings of a given read. We used the 100 bp real life dataset that were used in the previous section. BatMis and BWA have options to scan all possible hits with less than k mismatches. For ZOOM and Razers2, since such a mode is not present, the mapping was done to produce the first 100 000 hits for a given read. ZOOM and BWA gave a small number of false hits mainly due to boundary errors. The results are given in<ref type="figure" target="#tab_3">Table 3</ref>. BatMis reports all the true hits found by other aligners and is faster than them when performing multiple mappings. All aligners report about the same number of hits, although Razers2 and BWA reports less number of hits compared with the other aligners when the number of mismatches is large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Comparison against heuristic methods</head><p>Instead of searching for the exact solution, BWA and RazerS2 can employ heuristics to speed up mapping. BWA will first find hits in a seed region allowing at most two mismatches and extend the rest of the read allowing a given number of mismatches in the full read. RazerS2 has a heuristic mode where the reads can be mapped with 99% accuracy. Heuristics may miss some hits. This will result in incorrectly calling uniquely mapped reads.<ref type="figure" target="#tab_4">Table 4</ref>shows the speed and the number of true unique hits recovered using heuristics modes of BWA and RazerS2 against the exact algorithm of BatMis. The mapping procedure was similar to that in Section 3.2, except that BWA was run in its seeding mode and RazerS2 was run with its default sensitivity of 99%. The results show that BatMis is much faster than RazerS2 in all cases. BWA performs very well in its seeded mode on real data for long reads. For 51 bp reads, BatMis is faster than BWA and produces more mappings. For 100 bp reads, BatMis is faster than BWA for up to five mismatches. At 8 and 10 mismatches the speeds are similar, with BatMis again producing more hits. The false unique hits reported by the aligners in their heuristic modes are negligible, and a reasonable number of correct unique hits were recovered. Supplementary<ref type="figure" target="#tab_2">Table 2</ref>shows the statistics for obtaining all kmismatch hits with BWA in its heuristic mode and with BatMis. RazerS2 was not considered as it is slow even for finding uniqueBWA and RazerS2 were run in their heuristic modes. Entries in bold produce false hits, and the number of false hits is shown inside the brackets. hits. We can see that for both types of reads, BatMis is faster or has comparable speed with BWA. The heuristics of BWA can produce exact results up to two mismatches. For the 100 bp reads, BWA misses between 2 and 9% hits, and for 51 bp reads it will miss 11 and 30% hits when there are 3–5 mismatches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.Tennakoon et al.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>The solution for the k-mismatch mapping is important to secondgeneration sequencing. We introduced a new algorithm BatMis that can solve the k-mismatch problem exactly and efficiently. We checked the ability to find least mismatch hits, unique hits and multiple hits of some of the current state of the art aligners. Our results show that some aligners cannot reliably map reads with a large number of mismatches. On the other hand, BatMis was able to recover all the hits and was faster. Finally, BatMis is faster or has a comparable performance with the heuristic methods of other aligners. These results show that BatMis is a robust aligner that performs well at all mismatch thresholds. One limitation of BatMis is that it cannot handle paired-end reads and indels. We believe that BatMis is a useful alternative for mapping SGS reads when we want to perform multiple mapping, unique mapping or when we want to tolerate a large number of mismatches.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. The procedures PExt and SExt perform prefix and suffix extensions, respective, of a set of strings X.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. The BatMis algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>Copyedited by: SK MANUSCRIPT CATEGORY: ORIGINAL PAPER [18:49 19/7/2012 Bioinformatics-bts339.tex] Page: 2126 2122–2128</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>Copyedited by: SK MANUSCRIPT CATEGORY: ORIGINAL PAPER [18:49 19/7/2012 Bioinformatics-bts339.tex] Page: 2127 2122–2128</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>Copyedited by: SK MANUSCRIPT CATEGORY: ORIGINAL PAPER [18:49 19/7/2012 Bioinformatics-bts339.tex] Page: 2128 2122–2128</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>Funding: This work was supported in part by the Ministry Of Education, Singapore's AcRF Tier 2 funding R-252-000-444-112. Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>=T [SA T [i]−1] for SA T [i] &gt; 1; and B T [0]=$. Let P be a substring of T whose SA T range is known. Lemma 2.1 (Backward Search). Consider a string T. Given B T and the SA T range [i,j] of P, we can compute the SA T range of yP in O(1) time. (</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>and R r = R[[|R|/2+1..|R|] to be the left and right halves of R, respectively. We propose the algorithm BatMis, which is a seed-and-extend method. It has two phases. Phase 1 finds all substrings in T which look similar to R l and R r by recursion. Precisely, it computes H k R l and H k Rr for a set of values of k not exceeding K/2. In Phase 2, the patterns found in Phase 1 are extended to get all k-mismatch patterns of R. The pigeon hole principle stated in Lemma 2.2 provides us with a minimal set of H k l and H k r guaranteed to find all k-mismatch patterns of R with this algorithm. ) ≤ k, where k ≥ 1. We have two cases. @BULLET Case 1: k is even. We have either d(R l ,R l ) ≤ k/2 or d(R r ,R r ) ≤ k/2− 1. @BULLET Case 2: k is odd. We have</figDesc><table>K 
k=0 H k 
R . 
We define R l = R[1..|R|/2] Lemma 2.2. Consider a read R and a string R of equal length such that 

d(R,R </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>. @BULLET If |X| &gt; 1, PExt(X,R,k) = x∈X PExt({x},R,k) Copyedited by: SK = k +1 σ∈ x·σ∈T PExt({x ·σ},R,k), otherwise @BULLET If |X| &gt; 1, SExt(X,R,k) = x∈X SExt({x},R,k) @BULLET If X ={x}, SExt({x},R,k) = {x}, if |x|=|R| or d(x,R[|R|−|x|+1..|R|]) = k +1</figDesc><table>MANUSCRIPT CATEGORY: ORIGINAL PAPER 

[18:49 19/7/2012 Bioinformatics-bts339.tex] 
Page: 2124 2122–2128 

C.Tennakoon et al. 

@BULLET If X ={x}, PExt({x},R,k) = 
{x}, if |x|=|R| or d(x,R[1..|x|]) σ∈, 
σ·x∈T 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>R contains all strings in P ∪S whose patterns have exactly 1 mismatch with R. The equations for PRE 2 R and SUF 2 R follow by definition.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Lemma 2.5. Consider a read R and suppose k is even. Let</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><figDesc>k}. b) PRE k+1 R ={x ∈ P | d(x,R[1..|x|]) = k +1}. c) SUF k+1 R ={x ∈ S | d(x,R[|R|−|x|+1..|R|]) = k +1}. Proof. The proof is similar to that of Lemma 2.4. which computes all k-mismatch patterns of a read R for 0 ≤ k ≤ K. The first phase (lines 1−2) divides R into two equal halves R l and R r and it recursively calls BatMis(R l ,K/2) and BatMis(R r ,(K −1)/2) to compute H k R l and H k Rr for 0 ≤ k ≤≤K/2 and 0 ≤ k ≤≤(K −1)/2, respectively. The second phase iteratively computes H k R for k = 0,...,K. It first computes H 0 R (line 3), H 1 R ,PRE 2 R and PRE 2 R by</figDesc><table>Using Lemmas 2.3–2.5, Figure 2 gives the final BatMis algorithm 
BatMis(R,K), Lemma 2.3 (lines 5−7). Then, the program 
applies Lemmas 2.4 and 2.5 to compute (H k 
R ,PRE k 
R ,SUF k 
R </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><figDesc>B T * . All strings in H i R l and PRE j R are represented as SA T *-ranges, while all strings in H i Rr and SUF j R</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><figDesc>Table 1.</figDesc><table>Statistics for finding least mismatch hits of 1 000 000 reads taken from the 51 bp dataset ERR000577 and the 100 bp dataset ERR024201 allowing 
different numbers of mismatches 

51 bp 
0-mis 
1-mis 
2-mis 
3-mis 
4-mis 
5-mis </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><figDesc>Table 2.</figDesc><table>Statistics for finding the unique hits of 1 000 000 reads taken from the 51 bp dataset ERR000577 and 100bp dataset ERR024201 allowing different 
numbers of mismatches 

51 bp 
0-mis 
1-mis 
2-mis 
3-mis 
4-mis 
5-mis – 
– 
RazerS2 871 712 
31 580 
881 586 
30 195 
887 948(1) 31 867 
892 701(3) 26 616 
903 579(2) 69029 
909 362(2) 118 050 

Entries in bold produce false hits, and the number of false hits is shown inside the brackets. ZOOM, RazerS2 and BWA were run in their exact modes. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><figDesc>Table 3.</figDesc><table>Statistics for finding multiple hits of 1 000 000 reads taken from the 100 bp dataset ERR024201 allowing different numbers of mismatches 

1-mis 
2-mis 
3-mis 
4-mis 
5-mis 

Program No. of Hits 
Time 
No. of Hits 
Time 
No. of Hits 
Time 
No. of Hits 
Time 
No. of Hits 
Time 

BatMis 
12 709 391 
85 
31 001 496 
208 
59 121 695 
412 
96 502 481 
1023 
143 315 831 
1803 
BWA 
12 709 417(26) 172 
31 001 544(48) 411 
59 121 789(94) 
2601 
96 501 738(124) 20 390 143 186 148(168) 163 479 
ZOOM 
12 709 421(30) 1581 
31 001 568(72) 1703 
59 121 802(107) 2307 
96 502 628(147) 2771 
– 
– 
RazerS2 12 709 391 
30 778 31 000 921 
31 956 591 19 338 
32 340 96 498 204 
32 747 143 309 572 
26 770 

Entries in bold produce false hits, and the number of false hits is shown inside the brackets. ZOOM, RazerS2 and BWA were run in their exact modes. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><figDesc>Table 4.</figDesc><table>Statistics for finding the unique hits of 1 000 000 reads taken from the 51 bp dataset ERR000577 and 100 bp dataset ERR024201 allowing different 
numbers of mismatches 

51 bp 
2-mis 
3-mis 
4-mis 
5-mis 

Program 
No. of Hits 
Time (s) 
No. of Hits 
Time (s) 
No. of Hits 
Time (s) 
No. of Hits 
Time (s) 

BatMis 
817 844 
38 
843 466 
55 
856 383 
125 
863 707 
191 
BWA 
817 844 
191 
841 850 (467) 
397 
852 875 (1400) 
438 
858 635 (2540) 
445 
RazerS2 
816 536 (119) 
10 567 
842 838 (107) 
10 669 
855 989 (185) 
11 817 
863 604 (93) 
16 049 

100 bp 
2-mis 
3-mis 
4-mis 
5-mis 

Program 
No. of Hits 
Time (s) 
No. of Hits 
Time (s) 
No. of Hits 
Time (s) 
No. of Hits 
Time (s) 

BatMis 
881 586 
44 
892 698 
96 
903 577 
805 
909 360 
1389 
BWA 
881 207 (48) 
257 
887 122 (167) 
484 
810 186 (1592) 
764 
904 356 (2782) 
922 
Razers2 
881 586 
34 387 
887 947 
23 575 
903 569 (4) 
26 244 
909 347 (22) 
36 688 

</table></figure>

			<note place="foot">© The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Basic local alignment search tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="403" to="410" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">A block-sorting lossless data compression algorithm</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Burrows</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Wheeler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital System Research Center</title>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title level="m" type="main">Eland: efficient local alignment of nucleotide data</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Cox</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Infidelity of sars-cov nsp14-exonuclease mutant virus replication is revealed by complete genome sequencing</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Eckerle</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS pathogens</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">1000896</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">Opportunistic data structures with applications</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Whole-genome sequencing and variant discovery in c. elegans</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Hillier</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="183" to="188" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Practical aspects of compressed suffix arrays and fm-index in searching dna sequences</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Hon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ALENEX/ANALC</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Compressed indexing and local alignment of dna</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Lam</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="791" to="797" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short dna sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Zoom! zillions of oligos mapped</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Lin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="2431" to="2437" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Fast and accurate long-read alignment with burrows-wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="589" to="595" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Mapping short dna sequencing reads and calling variants using mapping quality scores</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1851" to="1858" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Suffix arrays: a new method for on-line string searches</title>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Manber</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the first annual ACM-SIAM symposium on Discrete algorithms</title>
		<meeting>the first annual ACM-SIAM symposium on Discrete algorithms</meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="319" to="327" />
		</imprint>
	</monogr>
	<note>Society. for Industrial and Applied Mathematics</note>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Zbed6, a novel transcription factor derived from a domesticated dna transposon regulates igf2 expression and muscle growth</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Markljung</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Biol</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">1000256</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Genome-wide maps of chromatin state in pluripotent and lineage-committed cells</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Mikkelsen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">448</biblScope>
			<biblScope unit="page" from="553" to="560" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Mapping and quantifying mammalian transcriptomes by rna-seq</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Mortazavi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="621" to="628" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Tophat: discovering splice junctions with rna-seq</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Trapnell</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1105" to="1111" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Razersfast read mapping with sensitivity control</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Weese</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Research</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1646" to="1654" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>