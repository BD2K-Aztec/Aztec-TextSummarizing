
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:54+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ExSPAnder: a universal repeat resolver for DNA fragment assembly</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Andrey</forename>
								<forename type="middle">D</forename>
								<surname>Prjibelski</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<settlement>St. Petersburg, Russia</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Irina</forename>
								<surname>Vasilinetc</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<settlement>St. Petersburg, Russia</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Anton</forename>
								<surname>Bankevich</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<settlement>St. Petersburg, Russia</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alexey</forename>
								<surname>Gurevich</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<settlement>St. Petersburg, Russia</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Tatiana</forename>
								<surname>Krivosheeva</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<settlement>St. Petersburg, Russia</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Sergey</forename>
								<surname>Nurk</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<settlement>St. Petersburg, Russia</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Son</forename>
								<surname>Pham</surname>
							</persName>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>San Diego</addrLine>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Anton</forename>
								<surname>Korobeynikov</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<settlement>St. Petersburg, Russia</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Department of Mathematics and Mechanics</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alla</forename>
								<surname>Lapidus</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<settlement>St. Petersburg, Russia</settlement>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Theodosius Dobzhansky Center for Genome Bioinformatics</orgName>
								<orgName type="institution">St. Petersburg State University</orgName>
								<address>
									<settlement>St. Petersburg</settlement>
									<country key="RU">Russia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Pavel</forename>
								<forename type="middle">A</forename>
								<surname>Pevzner</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Algorithmic Biology Lab</orgName>
								<orgName type="institution">St. Petersburg Academic University</orgName>
								<address>
									<settlement>St. Petersburg, Russia</settlement>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<addrLine>San Diego</addrLine>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">ExSPAnder: a universal repeat resolver for DNA fragment assembly</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="page" from="293" to="301"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu266</idno>
					<note>BIOINFORMATICS</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Next-generation sequencing (NGS) technologies have raised a challenging de novo genome assembly problem that is further amplified in recently emerged single-cell sequencing projects. While various NGS assemblers can use information from several libraries of read-pairs, most of them were originally developed for a single library and do not fully benefit from multiple libraries. Moreover, most assemblers assume uniform read coverage, condition that does not hold for single-cell projects where utilization of read-pairs is even more challenging. We have developed an exSPAnder algorithm that accurately resolves repeats in the case of both single and multiple libraries of read-pairs in both standard and single-cell assembly projects. Availability and implementation: http://bioinf.spbau.ru/en/spades Contact: ap@bioinf.spbau.ru</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Most of existing next-generation sequencing (NGS) platforms generate read-pairs—pairs of reads (called mates) that are sequenced from different ends of a genomic fragment with approximately known length (called the insert size). Because the insert size usually exceeds the length of a single read, readpairs may match up unique regions surrounding repeats that are longer than the read length. A combination of several libraries of read-pairs with different insert sizes is often used to produce high-quality assemblies (<ref type="bibr" target="#b3">Butler et al. 2008;</ref><ref type="bibr" target="#b2">Bresler et al., 2012</ref>). Paired-end libraries usually have insert size 51 kb and are used for resolving relatively short repeats. Jumping libraries are characterized by an average insert size of anywhere from 1 to 20 kb and are helpful in resolving longer repeats and contig scaffolding (inferring the order of contigs in the genome). However, because of a high insert size variation, information from jumping libraries is rather difficult to use for the purpose of assembly. The problem of using multiple read-pair libraries was previously addressed by ALLPATHS-LG (<ref type="bibr" target="#b7">Gnerre et al., 2011</ref>), Ray (<ref type="bibr" target="#b1">Boisvert et al., 2010</ref>), Velvet (<ref type="bibr" target="#b19">Zerbino and Birney, 2008</ref>) and some other assemblers. However, these tools are designed for standard (mutlicell) assemblies and do not perform well on single-cell datasets. On the other hand, the single-cell assemblers ESC (<ref type="bibr" target="#b4">Chitsaz et al., 2011</ref>), IDBA-UD (<ref type="bibr" target="#b14">Peng et al., 2012</ref>) and SPAdes (<ref type="bibr" target="#b0">Bankevich et al., 2012</ref>) are designed for a single read-pair library. In addition, the recently proposed Paired de Bruijn Graph algorithms for repeat resolution (<ref type="bibr" target="#b13">Medvedev et al., 2011;</ref><ref type="bibr" target="#b16">Pham et al., 2013;</ref><ref type="bibr" target="#b18">Vyahhi et al., 2012</ref>) also focus on a single library and it remains unclear how to extend them to multiple libraries. We present EXSPANDER algorithm that works with both single and multiple libraries in standard and single-cell assembly projects. EXSPANDER uses a simple path extension approach for repeat resolution that was originally proposed in the Ray assembler [and later used in Telescoper (<ref type="bibr" target="#b2">Bresler et al., 2012)]</ref>and combines it with some ideas from the Rectangle Graph approach (<ref type="bibr" target="#b0">Bankevich et al., 2012;</ref><ref type="bibr" target="#b18">Vyahhi et al., 2012</ref>). Given a set of paths in the assembly graph (<ref type="bibr" target="#b0">Bankevich et al., 2012</ref>) (i.e. simplified de Bruijn graph (<ref type="bibr" target="#b5">Compeau et al., 2011;</ref><ref type="bibr" target="#b15">Pevzner et al., 2001</ref>) of k-mers in reads after removal of bulges, tips and chimeric edges), EXSPANDER attempts to extend each path with the goal to generate longer paths. For a path P ending in a vertex v, we consider all edges starting at v (referred to as extension edges) and compute Score P (e) for each extension edge. To compute Score P (e) we analyze all reads that map to path P and whose mates map to e. Thus, Score P (e) reflects our confidence that an extension of the path P by the edge e is correct. We note that to properly map read-pairs and calculate Score P (e), the total length of path P and edge e should be longer than the insert size. In addition to function Score P (e), EXSPANDER uses a decision rule Extend(P) that either chooses one of the extension edges to extend the path P or makes the decision to stop growing this path beyond the ending vertex of P. The procedure is iterated over all the paths until no path can be further extended. To initiate this algorithm one can start with a set of single-edge paths formed by all sufficiently long edges in the assembly graph. The resulting paths are output as contigs after removing the paths that are contained within other paths as well as removing non-informative overlaps (i.e. suffixes of paths that represent prefixes of other paths). This simple approach is merely a framework and, depending on the specifics of the scoring function and the decision rule, it can be either efficient (like in the Ray assembler) or disastrous. The authors of Telescoper made an attempt to improve on Ray's scoring function and to substantiate it with rigorous statistical analysis. However, scoring functions in both Ray and Telescoper are not universal, e.g. they assume the uniform genome coverage by reads, condition that does not hold for single-cell data. We demonstrate that EXSPANDER works well on single-cell datasets with multiple libraries. We also show that EXSPANDER *To whom correspondence should be addressed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>y</head><p>The authors wish it to be known that, in their opinion, the first two authors should be regarded as Joint First Authors. ß The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com [implemented as a part of SPAdes (<ref type="bibr" target="#b0">Bankevich et al., 2012)</ref>] improves on existing assemblers on standard bacterial datasets and outperforms such popular assemblers as ABySS (<ref type="bibr" target="#b17">Simpson et al., 2009</ref>), Ray (<ref type="bibr" target="#b1">Boisvert et al., 2010</ref>), SOAPdenovo (<ref type="bibr" target="#b11">Li et al., 2010</ref>) and Velvet (<ref type="bibr" target="#b19">Zerbino and Birney, 2008</ref>). ALLPATHS-LG (<ref type="bibr" target="#b7">Gnerre et al., 2011</ref>) is an excellent assembler whose applications, however, are limited to specially constructed read-pair libraries. On such libraries EXSPANDER and ALLPATHS-LG generate comparable results (EXSPANDER generates longer contigs but ALLPATHS-LG generates longer scaffolds).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">ANALYSIS OF READ-PAIR LIBRARIES</head><p>As we mentioned in the introduction, jumping libraries present additional challenges for genome assembly owing to their high variations in the insert size. Additionally, jumping libraries have high rate of chimeric read-pairs—read-pairs that either have abnormal insert size or incorrect orientation. Chimeric read-pairs further complicate utilization of such libraries while resolving repeats. Below we present analysis of the insert size distributions for the following data: Brachybacterium faecium isolate dataset (read length 150 bp) and Staphylococcus aureus single-cell dataset (read length 101 bp). Both datasets contain one paired-end and one jumping library. To analyze read-pair libraries we aligned reads to the B.faecium and S.aureus reference genomes using Bowtie 2 (<ref type="bibr" target="#b9">Langmead and Salzberg, 2012</ref>) and computed the chimeric readpair rates and insert size distributions. As<ref type="figure">Figure 1</ref>and<ref type="figure" target="#tab_1">Table 1</ref>demonstrate, both isolate and singlecell paired-end libraries have small variations of the insert size. In contrast, the jumping library from the B.faecium dataset has a much higher variation in the insert size and higher rate of chimeric read-pairs (<ref type="figure" target="#tab_1">Table 1</ref>). At the same time, in addition to the large insert size variations, S.aureus jumping library contains only 22% of all read-pairs aligned with the proper reverse– forward orientation. Thirty-six percent of all read-pairs have incorrect forward–reverse orientation (correspond to the left peak in<ref type="figure">Fig. 1d</ref>) and 14% are classified as chimeric read-pairs of other types. Forward–reverse read-pairs in jumping libraries represent an artifact of the sample preparation and are common for datasets of different types. Despite the fact that various artifacts of jumping libraries make it difficult to incorporate them into existing assembly tools, EXSPANDER uses jumping libraries to generate high-quality assemblies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EXSPANDER ALGORITHM</head><p>EXSPANDER uses an assembly graph constructed by SPAdes (<ref type="bibr" target="#b0">Bankevich et al., 2012</ref>) and a set of read-pair libraries. For each library, we map read-pairs to the long edges of the assembly graph and estimate the average insert size along with its confidence interval—a shortest insert size interval that contains at least 80% of properly aligned read-pairs. These estimates are used as parameters of the scoring function and the decision rule.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The decision rule</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Single library</head><p>Given a path P, we define a winner as an edge e with the maximal score Score P (e) among all extension edges for P. Similarly, a contender is defined as an extension edge with the second best score. The winner edge is called the strong winner if (i) Score P (winner) 4Â and (ii) Score P (winner)4C Á Score P (contender), where Â and C are parameters of the algorithm, which are discussed below. If the path P has a single extension edge (which is obviously the winner), only the first condition is used. The decision rule is defined as follows:</p><p>ExtendðPÞ= e; if edge e is the strong winner for path P ;; if there is no strong winner for path P (</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Multiple libraries</head><p>The decision rule described above can be generalized for several read-pair libraries. Consider M readpair libraries, which are sorted in the order of increasing insert<ref type="figure">Fig. 1</ref>. Plots of the insert size distributions for B.faecium isolate (a) paired-end and (b) jumping library, and S.aureus single-cell dataset with (c) paired-end and (d) jumping library. The distributions were computed by mapping reads to the B.faecium str. DSM4810 (<ref type="bibr" target="#b10">Lapidus et al., 2009</ref>) and S. aureus str. USA300 substr. FPR3757 (<ref type="bibr" target="#b6">Diep et al., 2006</ref>) reference genomes, respectively. All plots are in the logarithmic scalesizes and the associated decision rules Extend i (P) for 1 i M. We process the libraries in this order because our analysis revealed that the smaller is the insert size of a library (and its variation), the more reliable is the decision rule for this individual library. We thus select the library with the smallest index i that has the strong winner and define the decision rule for multiple libraries Extend(P) as simply Extend i (P). If neither library has a strong winner, we define ExtendðPÞ=;.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The scoring function</head><p>3.2.1 The support function We first consider an idealized case when the genome defines a genomic path in the assembly graph. We say that an edge e 0 follows edge e at a distance D if the distance between starts of these edges in the genomic path is D. We define a boolean function Support D (e,e 0 ) that reflects our confidence that edge e 0 follows edge e in the genome at distance D. Below we describe how to calculate Support D (e,e 0 ). Let I and [I min ,I max ] be the mean and the confidence interval of the insert size for a read-pair library formed by reads of length ReadLength. Consider consecutive edges e and e 0 in the assembly graph and a read-pair (r,r 0 ) such that read r maps to e at position x 0 and read r 0 maps to e 0 in position y 0 (<ref type="figure" target="#fig_5">Fig. 2a</ref>). We say that the read-pair (r,r 0 ) connects edges e and e 0 .<ref type="figure" target="#fig_5">Figure 2b</ref>shows a rectangle formed by the edges e and e 0<ref type="bibr">[</ref>Thus all 'ideal read-pairs' mapping to edges e and e 0 form a set of integer points on the 45 line y = x– d within the rectangle (<ref type="figure" target="#fig_5">Fig. 2c</ref>). Because the read-pairs from the real sequencing data have variations in the insert size, their corresponding points are typically scattered in the strip between the 45 lines y = x – d min and y = x – d max , where d min =LengthðeÞ À I min +ReadLength;</p><formula>d max =LengthðeÞ À I max +ReadLength:</formula><p>This strip in the rectangle is further referred to as the confidence strip (<ref type="figure" target="#fig_5">Fig. 2d</ref>). Let F(x) be the empirical distribution of the insert size and S be a set of all integer points within the confidence strip in the rectangle (e,e 0 ). We define the expected number of read-pairs within the confidence strip (under the assumption of the uniform coverage) aswhere Iðx; yÞ=LengthðeÞ À x+y+ReadLength represents the insert size of a read-pair that corresponds to the point (x, y). We also define Points(e,e 0 ) as the total number of read-pairs (from the real dataset) that correspond to the points within the confidence strip. The notion of density is defined as</p><p>Densityðe; e 0 Þ= Pointsðe; e 0 Þ Expectedðe; e 0 Þ :</p><p>We set Density(e,e 0 ) = 0, if Expected(e,e 0 ) = 0. The points outside the confidence strip may represent read-pairs with somewhat larger deviations from the mean insert sizes or chimeric readpairs. Our analysis revealed that being conservative (e.g. limiting analysis to the confidence strip) allows one to avoid most of the assembly errors caused by chimeric read-pairs, particularly in single-cell projects. We distinguish between notions of genome-consecutive and graph-consecutive edges and emphasize that graph-consecutive edges are not necessarily genome-consecutive. The decision about which graph-consecutive edges are genome-consecutive is an important part of any assembler.<ref type="figure" target="#fig_5">Figure 2d</ref>and e illustrate how rectangles help us to make such decisions: both rectangles correspond to graph-consecutive edges, but only rectangle in<ref type="figure" target="#fig_5">Figure 2d</ref>where É is a parameter of the algorithm, which is automatically computed for each read-pair library based on the chimeric readpair rate (see below). For the standard isolate datasets this parameter corresponds to the coverage cutoff for read-pairs. For single-cell datasets this parameter is usually set to be very low to retain the regions with low coverage, which are typical for single-cell projects. If Support D (e,e 0 ) = 1, we say that the rectangle (e,e 0 ) is supported by the read-pairs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">The naive scoring function</head><p>To explain the intuition behind EXSPANDER, we first introduce the naive scoring function. We further modify the naive scoring function to arrive to the advanced scoring function used in the real EXSPANDER implementation. A path P = (p 1 ,. .. ,p m ) and its extension edge e can be represented as a composite rectangle formed by m simple rectangles (p j ,e) containing points that correspond to read-pairs connecting edges of P and e.</p><formula>P = (p 1 , p 2 , p 3 ) and P 0 =ðp 1 ; p 0 2 ; p 3 Þ and its extension edges e 1 ,e 2. Let (p 1 , p 2 , p 3 , e 1 ) and ðp 1 ; p 0 2 ; p 3 ;</formula><p>e 2 Þ be the true (but unknown) genomic paths.<ref type="figure" target="#fig_9">Figure 3b</ref>shows the composite rectangle for path P and its correct extension e 1 , in which points within the confidence strip are rather evenly distributed resulting in</p><formula>P 0 =ðp 1 ; p0 2 ; p 3 Þ.</formula><p>Because the defined scoring function does not linearly depend on read coverage, it is well suitable for both single-cell and standard sequencing projects. At the same time, considering only readpairs with insert size in [I min ,I max ] (which correspond to points within the confidence strip) allows one to filter out most of the chimeric read-pairs (common for single-cell datasets) and to minimize their influence on the scoring function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.3">The advanced scoring function</head><p>The naive scoring function Score P (e) described above works well in many cases but may be too conservative when the path P contains repetitive edges (edges that are visited more than once by the genomic traversal).</p><formula>P = (p 1 , p 2 , p 3 )</formula><p>be a path we aim to extend. We first calculate scores of all extension edges using the composite rectangles (<ref type="figure" target="#fig_12">Fig. 6a</ref>–c) and form a set of active edges A=fe 1 ; e 2 ; e 3 g based on their scores (marked red in<ref type="figure" target="#fig_12">Fig. 6d</ref>). Because Support D3 ðp 3 ; e i Þ=1 for i = 1, 2, 3, edge p 3 is classified as repetitive and is removed from further consideration (<ref type="figure" target="#fig_12">Fig. 6e</ref>). We now recalculate scores for the extension edges in A ignoring repetitive edge p 3 (<ref type="figure" target="#fig_12">Fig. 6f</ref>–h) and remove non-active edge e 3 from A (<ref type="figure" target="#fig_12">Fig. 6i</ref>). Using the updated set A=fe 1 ; e 2 g we again proceed to the repeat detection step and mark edge p 2 as repetitive because Su pport D2 ðp 2 ; e i Þ=1 for i = 1, 2 (<ref type="figure" target="#fig_12">Fig. 6j</ref>). Finally, we once again recalculate scores of the extension edges in A (<ref type="figure" target="#fig_12">Fig. 6k</ref>–m) and remove e 2 as non-active (<ref type="figure" target="#fig_12">Fig. 6n</ref>). The extension edge e 1 remains the only active edge in and is used to extend path P. Extensive tests of the advanced scoring function revealed that it works well across diverse datasets including single-cell jumping libraries with high variations in the insert size, extremely nonuniform coverage and large number of chimeric reads and chimeric read-pairs (see Section 4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Scaffolding</head><p>After all paths are constructed, we consider all pairs of paths that form composite rectangles with non-zero number of points (<ref type="figure" target="#fig_13">Fig. 7</ref>). For each such pair of paths P and P 0 we can check whether points in the corresponding composite rectangle are scattered around a certain 45 line using SPAdes distance estimation procedure (<ref type="bibr" target="#b12">Nurk et al., 2013</ref>). When SPAdes provides the estimated distance D between P and P 0 , we use EXSPANDER to verify the conjecture that P 0 follows P at distance D. If this conjecture is supported and does not contradict to any other conjectures about these paths, we extend the path P by P 0 (the scaffolding step). We estimate the gap length between the paths as D À LengthðPÞ and insert the appropriate number of 'N' symbols (unspecified nucleotide) between end of P and start of P 0. If paths P and P 0 overlap, we construct their overlap alignment to correct distance D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Choice of the parameters</head><p>3.4.1 The scoring function We select the parameter É as a threshold for the density of the read-pairs within the confidence strip. We therefore assume that rectangles with the density below É contain mostly chimeric read-pairs and should be ignored while calculating the score of an extension edge. To select É for a particular read-pair library, we estimate the distribution of the densities for rectangles that contain only chimeric readpairs (false rectangles) and for rectangles that contain only nonchimeric read-pairs (true rectangles). To partition all read-pairs into chimeric and non-chimeric, one needs the complete genome that is unavailable. To get around this, we identify a subset of chimeric reads using the long edges in the assembly graph (e.g. edges longer than N50) that can be</p><formula>(a) (b) ( c)</formula><formula>i297 ExSPAnder (a) (d) (f) (b) (g) ( h)</formula><formula>(i) (k) ( l)</formula><formula>(n) (m) (j) (c) (e)</formula><formula>D Ã = argmax D Points D ðe 1 ; e 2 Þ: When (e 1 ,e 2 )</formula><p>is a false edge-pair, D * defines a confidence strip S trip D Ã ðe 1 ; e 2 Þ with the maximum number of chimeric read-pairs. To compute the threshold É, we assume this worst-case scenario for all pairs of uni-edges (within the same long edge) by using distance D * (rather than the known genomic distance) for calculating the densities Density D Ã ðe 1 ; e 2 Þ. For a certain value of É we define false positives (false negatives) as the false (true) edge-pairs that have density higher (lower) than É 0. Figures 8a and b illustrate how false-positive rate (green) and false-negative rate (blue) depend on the parameter É. EXSPANDER selects É that corresponds to the intersection point of the false-positive and false-negative plots. Our benchmarking revealed that such choice of the parameter É allows one to filter out the rectangles containing only chimeric reads-pairs based on their densities. Additional analysis revealed that estimating the parameter É is an important step in the EXSPANDER algorithm because varying this parameter may significantly affect the assembly quality (see Section 3 in Appendix).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4.2">The decision rule</head><p>Our analysis revealed that varying parameters C and Â within specified ranges (see Section 3 of the Appendix) hardly affects the quality of the resulting assemblies. However, selecting inappropriate C and Â may result in a deteriorated performance of EXSPANDER. Thus, we arbitrarily select these parameters within the ranges specified in Section 3 of Appendix (analysis of diverse sequencing datasets supports the default values C = 1.5 and Â = 0.5).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.1">Datasets We have compared EXSPANDER (coupled with</head><p>SPAdes assembler) with several popular assemblers on the B.faecium isolate dataset (genome size 3.6 Mb) and the S.aureus single-cell dataset (genome size 2.9 Mb). For each dataset we have generated assemblies of (i) only paired-end library and (ii) both paired-end and jumping libraries. Section 1 of Appendix provides a detailed description of both datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.2">Benchmarking assemblies</head><p>ABySS 1.3.6, Ray 2.0.0, Velvet, Velvet-SC and SOAPdenovo 2.0.4 were run with k-mer size 55. IDBA-UD 1.1.1 was run in its default iterative mode. The authors of (<ref type="bibr" target="#b14">Peng et al., 2012</ref>) released this new version of IDBA-UD that is capable of using several paired-end libraries, but there is no manuscript yet covering this new development. ALLPATHS-LG was run with the default parameters; however, we down-sampled jumping library for the B.faecium dataset to generate 100Â coverage required by ALLPATHS-LG. SPAdes 2.4 (previous version of SPAdes that did not include EXSPANDER and did not support multiple libraries) was run in its default iterative mode with k = 21, 33, 55, 77 for the B.faecium dataset and k = 21, 33, 55 for the S.aureus dataset. EXSPANDER (coupled with SPAdes) was run using the default parameters. To analyze the resulting assemblies we used QUAST 2.2 (<ref type="bibr" target="#b8">Gurevich et al., 2013</ref>) that reports various parameters including NG50 (similar to N50, but is calculated with respect to the reference genome size), the total number of contigs/scaffolds, the length of the longest assembled contig/scaffold, the number of misassemblies and the fraction of genome mapped. QUAST defines a misassembly breakpoint as a position in the contig/ scaffold, such that its left and right flanking sequences either align to the reference genome over 1 kb away from each other, or overlap by41 kb, or align on opposite strands or different chromosomes (<ref type="bibr" target="#b8">Gurevich et al., 2013</ref>). To compare assemblers we used both contigs and scaffolds of length exceeding 500 bp.ExSPAnder</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tables 2 and 3 show the benchmarking results for</head><p>the B.faecium isolate dataset. Interestingly, the single-cell assemblers (IDBA-UD and EXSPANDER coupled with SPAdes) as well as ABySS performed well on the B.faecium isolate dataset and produced contigs with the largest NG50 in the case of a single library. While AbySS generated the assembly with the maximal genome fraction, manual inspection revealed that it reflects the specifics of ABySS and QUAST reporting (mapping each repeat to a single position in the genome) rather than real superiority of ABySS by this metric. In the case of two libraries, EXSPANDER produced the best contigs while ALLPATHS-LG produced the best scaffolds. The complexity of using jumping libraries is reflected in a deteriorated performance of ABySS and Ray (reduction in NG50) as well as Velvet and Velvet-SC (dramatic increase in the number of misassemblies). Tables 4 and 5 compare various assemblers on the S.aureus single-cell dataset. This comparison highlights the complexity of both (i) assembling single-cell datasets and (ii) using jumping libraries. For example, SOAPdenovo produced assemblies of poor quality for single-cell data (we decided not to include it in Tables 4 and 5). Similarly, ABySS produced assemblies with high number of misassemblies for the single-cell data. Velvet and Velvet-SC are not included in the benchmark experiment for jumping libraries testing because they also produce low-quality assemblies when both paired-end and jumping libraries are used simultaneously. IDBA-UD performed well on a single pairedend library, but produced an assembly of lower quality when both libraries were provided (decreased NG50). EXSPANDER produced assemblies with the highest NG50 and largest assembled contig/scaffold. Using only paired-end library IDBA-UD, SPAdes 2.4 and EXSPANDER recovered the largest fraction of the genome (498.5%). However, the highest genome fraction of the assemblyNote: NG50 is given in kb; number of scaffolds is the total number of scaffolds 4500 bp; largest stands for the length (in kb) of the longest scaffold assembled; number of mis is the number of misassemblies; GF stands for the fraction of genome mapped given in percent. In each column, the best value is indicated in bold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>generated by SPAdes 2.4 reflects the specifics of SPAdes 2.4 and</head><p>QUAST reporting (some artifacts with reporting of repetitive regions) rather than real advantage of SPAdes 2.4 with respect to this parameter. When using both libraries simultaneously, EXSPANDER produced assemblies with the highest genome fraction exceeding 99%, the largest genome fraction we saw across dozens of single-cell datasets assembled with SPAdes in the past 2 years. Moreover, Tables 4 and 5 show that EXSPANDER successfully deals with the high rate of the chimeric read-pairs and relatively high variations in the insert size.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>We have presented EXSPANDER algorithm for resolving repeats using either a single or multiple read-pair libraries with different insert sizes, which is applicable for both single-cell and isolate bacterial datasets. Benchmarks across eight popular assemblers demonstrate that EXSPANDER produces high-quality assemblies for datasets of different types. Additionally, as illustrated by recent integration of Illumina and PacBio reads in SPAdes 3.0, EXSPANDER is a flexible approach that can be easily modified to work with diverse types of sequencing data.Note: NG50 is given in kb; number of scaffolds is the total number of scaffolds 4500 bp; largest stands for the length (in kb) of the longest scaffold assembled; number of mis is the number of misassemblies; GF stands for the fraction of genome mapped given in percent. In each column, the best value is indicated in bold.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i301</head><p>ExSPAnder</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>further simply referred to as rectangle (e,e 0 )] with the read-pair (r,r 0 ) represented as a point (x 0 ,y 0 ) within the rectangle. If edges e and e 0 represent consecutive regions in the genome, then the genomic distance from the start of read r to the start of read r 0 equals to LengthðeÞ À x 0 +y 0 , where Length(e) stands for the length of edge e. Therefore, in the case of an 'ideal read-pair' (r,r 0 ) (e.g. a read-pair with the exact insert size I), y 0 =x 0 À d, where d=LengthðeÞ À I+ReadLength.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>is formed by the pair of genome-consecutive edges. The described notions of Expected(e,e 0 ), Points(e,e 0 ) and Density(e,e 0 ) (defined for the case when edges e and e 0 are genome-consecutive) can be generalized for the case when e and e 0 are not consecutive genomic edges under the assumption that genomic distance between them is D. In this case the confidence strip [further referred to as Strip D (e,e 0 )] is bounded by the lines y = x – d min and y = x – d max , where d min =D À I min +ReadLength; d max =D À I max +ReadLength: Points D (e,e 0 ) similarly represents the number of points within strip Strip D (e,e 0 ). Expected D (e,e 0 ) and Density D (e,e 0 ) are defined</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.2.</head><figDesc>Fig. 2. (a) Reads r and r 0 form a read-pair mapping to consecutive edges e and e 0 in the assembly graph at positions x 0 and y 0 , respectively. (b) Representation of a read-pair (r,r 0 ) as a point in a rectangle (e,e 0 ). (c) 'Ideal read-pairs' with the exact insert size I connecting edges e and e 0 form a 45 line within a rectangle. (d) Read-pairs from the real sequencing data with variations in the insert size represented as points within a rectangle. Most points are located within the confidence strip providing the evidence that edges e and e 0 are supported by the read-pairs and are genome-consecutive. (e) A rectangle formed by a pair of edges that has few points falling into the confidence strip revealing that e and e 0 are not genome-consecutive edges</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>:</head><figDesc>Figure 3b shows an example of a composite rectangle, which is formed by a path (p 1 , p 2 , p 3 ) and its extension edge e 1 and consists of three simple rectangles. The notion of the confidence strip remains (it now consists of up to m substrips within simple rectangles), except that it is bounded by the lines y = x – d min and y = x – d max , where d min =LengthðPÞ À I min +ReadLength; d max =LengthðPÞ À I max +ReadLength: For an edge p j from the path P we define the expected number of points in the confidence substrip within the simple rectangle (p j ,e) as Expected Dj ðp j ; eÞ, where D j is the distance between start of p j and start of e according to the path P (i.e. D j = P m i=j Lengthðp i Þ). We consider rectangles ðp j ; eÞ; j=star t;. .. ; end such that Expected Dj ðp j ; eÞ40 and introduce the function Score P (e) as the fraction of the total number of expected read-pairs in these rectangles with Support Dj ðp j ; eÞ=1:We set Score P (e) = 0 if all simple rectangle have zero expected read-pairs. Figure 3a shows paths</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>Score P (e 1 ) = 1. Figure 3c shows the composite rectangle for path P = (p 1 , p 2 , p 3 ) and its incorrect extension edge e 2. Because ðp 1 ; p 0 2 ; p 3 ; e 2 Þ is a genomic path, density of the points in the sectors of the confidence strip corresponding to edges p 1 and p 3 is high. However, edge p 2 of the path P does not support extension edge e 2 because there are few points in the rectangle (p 2 , e 2 ). Additionally, Figure 3d and e shows composite rectangles for all possible extension edges for path</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><figDesc>Figure 4 illustrates the case when the path P has a repetitive edge and motivates the need for further improvements in the scoring function. Figure 4a shows an assembly graph with four unique edges (p, p 0 , e and e 0 ) and a single repetitive edge p r with multiplicity 2. We assume that paths (p,p r ,e) and (p 0 ,p r ,e 0 ) are genomic and paths (p,p r ,e 0 ) and (p 0 ,p r ,e) are non-genomic. Our goal is to design an algorithm that correctly extends genomic paths (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig.3.</head><figDesc>Fig. 3. (a) An example of an assembly graph with the genomic paths (p 1 , p 2 , p 3 , e 1 ) and ðp 1 ; p 0 2 ; p 3 ; e 2 Þ. (b, e) The composite rectangles for correct genomic extension of each path: in these cases the points are evenly distributed within the confidence strip and the resulting score is equal to 1. (c, d) The composite rectangles that correspond to incorrect extensions edges of these two paths. In each of these cases, at least one simple rectangle contains few points within the confidence strip</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig.4.</head><figDesc>Fig. 4. Scoring a path that contains repetitive edges. (a) An example of the assembly graph with a repetitive edge p r. (b) A composite rectangle for the correct extension e of path (p,p r ). (c) A composite rectangle for the incorrect extension e 0 of the path (p,p r )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig.5.</head><figDesc>Fig. 5. An example of the assembly graph with repetitive edges p 2 and p 3</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig.6.</head><figDesc>Fig. 6. A step-by-step example of the EXSPANDER algorithm. (a–c) Forming a set of active edges {e 1 , e 2 , e 3 } (marked red) for the path P = (p 1 , p 2 , p 3 ) using the corresponding composite rectangles. (d, e) Classifying of edge p 3 as repetitive and removing it from further consideration (marking gray). Edges that are not classified as repetitive are colored in blue. (f–h) Recalculating scores of the extension edges and updating the set of active edges. (i, j) Removing repetitive edge p 2. (k–m) Recalculating scores for the remaining active edges {e 1 , e 2 } and removing e 2 as non-active. (n) Selecting the only active edge e 1 as an extension for the path P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig.7.</head><figDesc>Fig. 7. An example of a composite rectangle formed by paths (p 1 , p 2 , p 3 ) and ðp 0 1 ; p 0 2 ; p 0 3 Þ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig.8.</head><figDesc>Fig. 8. Plots of the false-positive (green) and false-negative (blue) rates for (a) B.facium and (b) S.aureus paired-end libraries</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><figDesc>Note: NG50 is given in kb; number of contigs is the total number of contigs4500 bp; largest stands for the length (in kb) of the longest contig assembled; number of mis is the number of misassemblies; GF stands for the fraction of genome mapped given in percent. In each column, the best value is indicated in bold. i300 A.D.Prjibelski et al.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Table 1.</figDesc><table>Information on the B.faecium isolate dataset and the S.aureus 
single-cell dataset 

Dataset 
B.faecium 
S.aureus 

Library 
Paired-end Jumping Paired-end Jumping 
Number of reads 
13 M 
41 M 
38 M 
41 M 
Average coverage 
400Â 
1100Â 
1050Â 
1050Â 
Coverage span 
210–570Â 0–3000Â 0–3500Â 
0–3500Â 
Insert size 
270 bp 
7.5 kb 
210 bp 
1.8 kb 
Insert span 
150–400 bp 6–10 kb 180–230 bp 0.5–4 kb 
Chimeric read-pairs (%) 1 
9 
3 
50 
Unaligned read-pairs (%) 16 
10 
6 
28 

Note: Insert span is the shortest insert size interval that contains at least 95% of 
properly aligned read-pairs. Unaligned reads refer to the percentage of read-pairs 
that have at least one read unaligned. Chimeric read-pairs refer to the percentage of 
chimeric read-pairs among all read-pairs. All statistics was obtained using Bowtie 2 
(Langmead and Salzberg, 2012). Coverage span is the smallest coverage interval that 
includes a least 95% of all genomic positions 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 2. Comparison of contigs for the B.faecium isolate dataset</figDesc><table>Assembler 
NG50 Number 
of contigs 

Largest Number 
of mis 

GF 

Only paired-end library 
ABySS 
203 
40 
672 
0 
99.9 
Ray 
114 
51 
436 
1 
98.9 
SOAPdenovo 
20 
333 
61 
0 
98.8 
Velvet 
144 
47 
550 
0 
99.4 
Velvet-SC 
163 
46 
550 
0 
99.4 
IDBA-UD 
202 
39 
483 
0 
99.4 
SPAdes 2.4 
361 
24 
635 
1 
99.7 

EXSPANDER 

380 
22 
672 
1 
9 9 . 5 
Both paired-end and jumping libraries 
ABySS 
203 
40 
672 
0 
9 9 . 9 
ALLPATHS-LG 
313 
21 
686 
0 
99.5 
Ray 
87 
88 
416 
2 
96.8 
SOAPdenovo 
20 
333 
61 
0 
98.8 
Velvet 
103 
75 
242 
11 
99.0 
Velvet-SC 
253 
40 
545 
15 
99.8 
IDBA-UD 
207 
41 
483 
0 
99.4 

EXSPANDER 

3268 
2 
3268 
1 
99.9 

Note: NG50 is given in kb; number of contigs is the total number of contigs 
4500 bp; largest stands for the length (in kb) of the longest contig assembled; 
number of mis is the number of misassemblies; GF stands for the fraction of 
genome mapped given in percent. In each column, the best value is indicated 
in bold. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 3.</figDesc><table>Comparison of scaffolds for the B.faecium isolate dataset 

Assembler 
NG50 Number of 
scaffolds 

Largest Number 
of mis 

GF 

Only paired-end library 
ABySS 
383 
24 
676 
0 
99.9 
Ray 
204 
31 
553 
1 
98.9 
SOAPdenovo 
477 
26 
724 
0 
99.3 
Velvet 
477 
28 
724 
0 
99.4 
Velvet-SC 
477 
28 
724 
0 
99.4 
IDBA-UD 
250 
30 
671 
0 
99.4 
SPAdes 2.4 
361 
22 
671 
1 
99.7 

EXSPANDER 

380 
22 
672 
1 
99.5 
Both paired-end and jumping libraries 
ABySS 
250 
30 
739 
1 
99.9 
ALLPATHS-LG 3610 
7 
3610 
1 
99.5 
Ray 
106 
75 
416 
2 
96.8 
SOAPdenovo 
480 
28 
810 
2 
99.4 
Velvet 
2651 
14 
2651 
78 
99.1 
Velvet-SC 
945 
102 
1381 
500 
98.9 
IDBA-UD 
1002 
9 
1692 
0 
99.4 

EXSPANDER 

3268 
2 
3268 
1 
99.9 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 4.</figDesc><table>Comparison of contigs for the S.aureus single-cell dataset 

Assembler 
NG50 Number of 
contigs 

Largest Number 
of mis 

GF 

Only paired-end library 
ABySS 
27 
914 
91 
262 
98.0 
Ray 
21 
306 
108 
14 
88.7 
Velvet 
10 
538 
56 
2 
93.2 
Velvet-SC 
9 
616 
56 
4 
94.2 
IDBA-UD 
75 
390 
161 
7 
98.6 
SPAdes 2.4 
98 
400 
230 
8 
99.1 

EXSPANDER 

148 
366 
275 
3 
98.6 
Both paired-end and jumping libraries 
ABySS 
27 
914 
91 
262 
98.0 
ALLPATHS-LG 
15 
283 
75 
26 
79.9 
Ray 
100 
178 
486 
21 
93.5 
IDBA-UD 
47 
415 
161 
7 
98.6 

EXSPANDER 

314 
322 
603 
9 
99.3 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 5. Comparison of scaffolds for the S.aureus single-cell dataset</figDesc><table>Assembler 
NG50 Number of 
scaffolds 

Largest Number 
of mis 

GF 

Only paired-end library 
ABySS 
28 
910 
91 
270 
98.2 
Ray 
21 
306 
108 
14 
88.7 
Velvet 
10 
538 
56 
2 
93.2 
Velvet-SC 
10 
620 
56 
5 
94.2 
IDBA-UD 
88 
382 
161 
8 
98.2 
SPAdes 2.4 
99 
391 
230 
8 
99.2 

EXSPANDER 

148 
357 
426 
4 
98.6 
Both paired-end and jumping libraries 
ABySS 
30 
852 
91 
275 
98.0 
ALLPATHS-LG 
40 
165 
132 
69 
79.9 
Ray 
100 
169 
486 
25 
93.5 
IDBA-UD 
55 
397 
161 
9 
98.6 

EXSPANDER 

314 
302 
603 
9 
99.3 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The B.faecium sequencing data were produced by the Joint Genome Institute in collaboration with the user community. The S.aureus dataset was provided by the Human Microbiome Project (bioproject ID PRJNA236734).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">SPAdes: a new genome assembly algorithm and its applications to single-cell sequencing</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bankevich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="455" to="477" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Ray: simultaneous assembly of reads from a mix of highthroughput sequencing technologies</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Boisvert</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1519" to="1533" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Telescoper: de novo assembly of highly repetitive regions</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Bresler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="311" to="317" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">ALLPATHS: de novo assembly of whole-genome shotgun microreads</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Butler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="810" to="820" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of single-cell bacterial genomes from short-read data sets</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Chitsaz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="915" to="921" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">How to apply de Bruijn graphs to genome assembly</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Compeau</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="987" to="991" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Complete genome sequence of USA300, an epidemic clone of community-acquired meticillin-resistant Staphylococcus aureus</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Diep</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lancet</title>
		<imprint>
			<biblScope unit="volume">367</biblScope>
			<biblScope unit="page" from="731" to="739" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">High-quality draft assemblies of mammalian genomes from massively parallel sequence data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gnerre</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1513" to="1518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">QUAST: quality assessment tool for genome assemblies</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Gurevich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1072" to="1075" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Complete genome sequence of Brachybacterium faecium type strain (Schefferle 6-10)</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Lapidus</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Standards Genomic Sci</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="3" to="11" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Assembling single-cell genomes and mini-metagenomes from chimeric MDA products</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Nurk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1" to="24" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Paired de bruijn graphs: a novel approach for incorporating mate pair information into genome assemblers</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1625" to="1634" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">IDBA-UD: a de novo assembler for single-cell and metagenomic sequencing data with highly uneven depth</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1" to="8" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">An Eulerian path approach to DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA, 98</title>
		<meeting>. Natl Acad. Sci. USA, 98</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9748" to="9753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Pathset graphs: a novel approach for comprehensive utilization of paired reads in genome assembly</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Pham</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="259" to="371" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">From de Bruijn graphs to rectangle graphs for genome assembly</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Vyahhi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on Algorithms in Bioinformatics 2012</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="200" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>