
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:29+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">GRASS: a generic algorithm for scaffolding next-generation sequencing assemblies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Alexey</forename>
								<forename type="middle">A</forename>
								<surname>Gritsenko</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">The Delft Bioinformatics Lab</orgName>
								<orgName type="department" key="dep2">Department of Mediamatics</orgName>
								<orgName type="institution">Delft University of Technology</orgName>
								<address>
									<addrLine>Mekelweg 4</addrLine>
									<postCode>2628 CD</postCode>
									<settlement>Delft</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">Platform Green Synthetic Biology</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Kluyver Centre for Genomics of Industrial Fermentation</orgName>
								<address>
									<postBox>P.O. Box 5057</postBox>
									<postCode>2600 GA</postCode>
									<settlement>Delft</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Jurgen</forename>
								<forename type="middle">F</forename>
								<surname>Nijkamp</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">The Delft Bioinformatics Lab</orgName>
								<orgName type="department" key="dep2">Department of Mediamatics</orgName>
								<orgName type="institution">Delft University of Technology</orgName>
								<address>
									<addrLine>Mekelweg 4</addrLine>
									<postCode>2628 CD</postCode>
									<settlement>Delft</settlement>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Kluyver Centre for Genomics of Industrial Fermentation</orgName>
								<address>
									<postBox>P.O. Box 5057</postBox>
									<postCode>2600 GA</postCode>
									<settlement>Delft</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Marcel</forename>
								<forename type="middle">J T</forename>
								<surname>Reinders</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">The Delft Bioinformatics Lab</orgName>
								<orgName type="department" key="dep2">Department of Mediamatics</orgName>
								<orgName type="institution">Delft University of Technology</orgName>
								<address>
									<addrLine>Mekelweg 4</addrLine>
									<postCode>2628 CD</postCode>
									<settlement>Delft</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">Platform Green Synthetic Biology</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Kluyver Centre for Genomics of Industrial Fermentation</orgName>
								<address>
									<postBox>P.O. Box 5057</postBox>
									<postCode>2600 GA</postCode>
									<settlement>Delft</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Dick</forename>
								<surname>De Ridder</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">The Delft Bioinformatics Lab</orgName>
								<orgName type="department" key="dep2">Department of Mediamatics</orgName>
								<orgName type="institution">Delft University of Technology</orgName>
								<address>
									<addrLine>Mekelweg 4</addrLine>
									<postCode>2628 CD</postCode>
									<settlement>Delft</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="laboratory">Platform Green Synthetic Biology</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Kluyver Centre for Genomics of Industrial Fermentation</orgName>
								<address>
									<postBox>P.O. Box 5057</postBox>
									<postCode>2600 GA</postCode>
									<settlement>Delft</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">GRASS: a generic algorithm for scaffolding next-generation sequencing assemblies</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="issue">11</biblScope>
							<biblScope unit="page" from="1429" to="1437"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts175</idno>
					<note type="submission">Sequence analysis Advance Access publication April 6, 2012 Received on March 27, 2012; revised on March 27, 2012; accepted on April 2, 2012</note>
					<note>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [16:26 7/5/2012 Bioinformatics-bts175.tex] Page: 1429 1429–1437 Associate Editor: Michael Brudno Contact: a.gritsenko@tudelft.nl Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: The increasing availability of second-generation high-throughput sequencing (HTS) technologies has sparked a growing interest in de novo genome sequencing. This in turn has fueled the need for reliable means of obtaining high-quality draft genomes from short-read sequencing data. The millions of reads usually involved in HTS experiments are first assembled into longer fragments called contigs, which are then scaffolded, i.e. ordered and oriented using additional information, to produce even longer sequences called scaffolds. Most existing scaffolders of HTS genome assemblies are not suited for using information other than paired reads to perform scaffolding. They use this limited information to construct scaffolds, often preferring scaffold length over accuracy, when faced with the tradeoff. Results: We present GRASS (GeneRic ASsembly Scaffolder)— a novel algorithm for scaffolding second-generation sequencing assemblies capable of using diverse information sources. GRASS offers a mixed-integer programming formulation of the contig scaffolding problem, which combines contig order, distance and orientation in a single optimization objective. The resulting optimization problem is solved using an expectation–maximization procedure and an unconstrained binary quadratic programming approximation of the original problem. We compared GRASS with existing HTS scaffolders using Illumina paired reads of three bacterial genomes. Our algorithm constructs a comparable number of scaffolds, but makes fewer errors. This result is further improved when additional data, in the form of related genome sequences, are used. Availability: GRASS source code is freely available from https://github.com/ymatts/D3Ml.
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>High-throughput sequencing (HTS) technologies, such as Illumina (Illumina, Inc., San Diego, CA), 454 (Roche Applied Science, Penzberg, Germany) and SOLiD and IonTorrent (Life Technologies, * To whom correspondence should be addressed.</p><p>Carlsbad, CA) produce millions of short DNA reads of typical lengths of 36–500 bp at low cost, making them attractive for de novo sequencing applications. With the aid of assembly algorithms (<ref type="bibr" target="#b19">Miller et al., 2008;</ref><ref type="bibr" target="#b26">Peng et al., 2010;</ref><ref type="bibr" target="#b30">Zerbino and Birney, 2008</ref>), short reads can be joined together into longer sequences called contigs. However, contigs are typically shorter than the sequenced DNA molecules, as genomic repeat regions longer than the read length cannot be unambiguously assembled using the read sequences alone. Scaffolding, the process of using additional data to place contigs in the right order, orientation and at the right distance in longer (gapped) supercontigs called scaffolds, is a crucial step in obtaining high-quality draft genome sequences. Paired reads (mate pair or paired end reads, depending on the sequencing protocol), i.e. reads of known relative orientation, order and approximate physical distance, are often used for scaffolding. Additional information, including reference sequences of related organisms, restriction maps (<ref type="bibr" target="#b22">Nagarajan et al., 2008</ref>) and RNA-seq data, can be used to derive more accurate contig placement (<ref type="bibr" target="#b14">Kent and Haussler, 2001;</ref><ref type="bibr" target="#b27">Pop et al., 2004</ref>), thereby reducing the cost of finishing experiments and allowing for more reliable downstream analyses. However, most existing scaffolding algorithms are not able to utilize such information for scaffolding. To our knowledge, only Bambus (<ref type="bibr" target="#b27">Pop et al., 2004</ref>) and SOPRA (<ref type="bibr" target="#b5">Dayarian et al., 2010</ref>) can make use of additional data sources, although the latter was not originally designed for this purpose. Generally, the contig scaffolding problem (CSP) is finding a linear ordering and orientation of contigs that minimizes the number of unsatisfied scaffolding constraints. These constraints are derived from the available data through translation of the inherent distance, order and orientation constraints onto the contigs. The derived constraints can be mutually exclusive, which makes the problem of minimizing the number of unsatisfied constraints NP-hard (<ref type="bibr" target="#b10">Huson et al., 2002;</ref><ref type="bibr" target="#b13">Kececioglu and Myers, 1995</ref>). Consequently, practical scaffolding algorithms only approximately solve this problem: Bambus (<ref type="bibr" target="#b27">Pop et al., 2004</ref>) separately finds contig orientation and order and uses greedy heuristics to remove inconsistent constraints; SSPACE (<ref type="bibr" target="#b3">Boetzer et al., 2011</ref>) greedily extends scaffolds using a heuristic stopping criterion; and SOPRA (<ref type="bibr" target="#b5">Dayarian et al., 2010</ref>) uses an iterative procedure to identify a subset of contigs with consistent scaffolding constraints. Notable exceptions are OPERA (<ref type="bibr" target="#b7">Gao et al., 2011</ref>) and the MIP Scaffolder (<ref type="bibr" target="#b29">Salmela et al., 2011</ref>), which simplify the CSP by dropping types of constraints. OPERA implements an algorithm for finding an exact CSP solution without minimumcontig distance constraints; the MIP Scaffolder (<ref type="bibr" target="#b29">Salmela et al., 2011</ref>) couples a Mixed-Integer Programming (MIP) formulation of the CSP that does not enforce order constraints with an algorithm heuristically dividing the original problem into subproblems to be solved exactly. We propose a novel GeneRic ASsembly Scaffolding (GRASS) algorithm that can be applied to any type of scaffolding information. Our work is similar to<ref type="bibr" target="#b29">Salmela et al. (2011)</ref>, as we propose a MIP formulation of the scaffolding problem. However, we combine contig orientation, order and distance in a single quadratic optimization objective. Similar to<ref type="bibr" target="#b5">Dayarian et al. (2010)</ref>, we employ an iterative procedure to select a consistent subset of contigs. However, we apply an expectation–maximization strategy to maximize the objective function that identifies inconsistent constraints rather than contigs, thereby retaining more scaffolding information. We implemented the algorithm in C++ and tested it on de novo assemblies of paired read data for the bacteria Eschrichia coli, Pseudoxanthomonas suwonensis, and Pseudomonas syringae and compared it with the SSPACE, OPERA and MIP scaffolders. GRASS produces a competitive number of scaffolds with fewer scaffolding errors, particularly when combining various sources of scaffolding information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Data representation</head><p>Scaffolding constraints on contig distance, order and orientation are derived from the data in a manner depending on the data type. For example, the known relative orientation, relative order and approximate distance of paired reads that map to different contigs can be translated into relative contig orientation, order and approximate contig distance by taking mapping orientations and positions into account; similarly, physical distance, relative order and orientation of two contigs mapping to the same reference sequence can be translated into corresponding constraints. However, different data types eventually define the same type of pair-wise contig constraints, which can be conveniently represented as arcs (i.e. directed edges)</p><formula>l j = (a l j ,b l j ) ∈ E of weight ω l j in a digraph G = V ,E</formula><p>defined over the set of contigs V (<ref type="bibr" target="#b7">Gao et al., 2011;</ref><ref type="bibr" target="#b10">Huson et al., 2002;</ref><ref type="bibr" target="#b27">Pop et al., 2004</ref>). The weight can be chosen to reflect information source importance and consistency. A relative order r l j , relative orientation e l j and approximate distance suggested by the pair-wise constraints, are then associated with every arc l j. The approximate distance is recorded as mean μ l j and its SD σ l j. This form is a natural choice for capturingThis abstract definition is illustrated in<ref type="figure">Figure 1</ref>. It allows capturing any combination of contig order, distance and orientation, including constraints derived from paired end reads, mate pair reads and contig mapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Contig link bundling and erosion</head><p>We create a single contig link for every available piece of evidence (e.g. pair of reads) and by default set its importance weight to one (a parameter adjustable per information source). For high-coverage HTS data this procedure creates a large number of links. Contig link bundling is used to reduce the number of links, and thereby the complexity of the problem. For every ordered pair of contigs (u,v), arcs (u,v) ∈ E that agree on contig distance, order and orientation are combined into one or more contig links as in<ref type="bibr" target="#b10">Huson et al. (2002)</ref>. The weight of a link after bundling is equal to the sum of weights of links bundled together to create it. Our definition of contig links permits having links that agree on all constraints, yet cannot be bundled together because they are oppositely directed in G. To enable bundling of such links, we re-set r l j relative to one of the end points of l j to make sure that all links connecting a pair of contigs have the same directionality. Finally, contig links with importance weight smaller than a pre-defined erosion threshold e are removed from the graph. This assumes that erroneous links are rare.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Optimization formulation</head><p>We present a mixed-integer quadratic programming (MIQP) formulation of the CSP. Our formulation is equivalent to the traditional one<ref type="bibr">[</ref>to the optimization problem. These values are sufficient to puzzle contigs into scaffolds. For every contig c i , i = 1,...,n the following variables are defined, as illustrated in<ref type="figure">Figure 2</ref>. @BULLET t i = 0, c i comes from the forward strand of the scaffold 1, c i comes from the reverse strand of the scaffold is used to define contig orientation in the scaffold. @BULLET x i ∈ R + corresponds to the 5 position of c i in the scaffold (when input contigs and the constructed scaffold are viewed as having a 5 to 3 orientation).</p><p>Naturally x i should be an integer variable, but it is relaxed to simplify the optimization problem and is rounded to the nearest integer when the solution is converted into scaffold nucleotide sequences. Additionally, with every link l j , j = 1,...,m the following variables are associated:As distance and order constraints are influenced by the orientation, different slack variables are required for both orientations. We omit orientation arrows above slacks ξ l j and l j when the contig pair orientation is not important, or is clear from the context. Contig links impose scaffolding constraints, which can be modeled as MIQP optimization constraints. We demonstrate here how such constraints can be derived from paired read data; the same type of constraints can be derived in a similar way from other sources of scaffolding information (for example, see Section 3.2). Distance constraints are expressed as:</p><formula>|d(a l j ,b l j )−μ l j | σ l j ≤ ξ l j , (1)</formula><p>where d(a l j ,b l j ) is the distance between contigs a l j and b l j , and ξ l j is a distance slack variable. This inequality captures uncertainty in the distance by measuring the difference with the mean in SDs. We derive contig distance d(a l j ,b l j ) from the paired read insert size as the gap size plus the contig lengths. The calculation then depends on the order and orientation of contigs connected by l j. It can be fixed by assuming that the contigs have relative orientation and order suggested by l j. For example, for the case of (e l j = 0∧r l j = 0) shown in<ref type="figure">Figure 2</ref>, the distance expression depends on contig pair orientation through t a l j :</p><formula>d(a l j ,b l j ) = x a l j −x b l j +len(a l j )+len(b l j ), t a l j = 0 d(a l j ,b l j ) = x b l j −x a l j +len(a l j )+len(b l j ), t a l j = 1.</formula><p>Combined with (1) the following constraints are obtained:</p><formula>⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩ x a l j −x b l j ≤ σ l j → ξ l j +μ l j −len(a l j )−len(b l j ) x a l j −x b l j ≥ −σ l j → ξ l j +μ l j −len(a l j )−len(b l j ) x b l j −x a l j ≤ σ l j ← ξ l j +μ l j −len(a l j )−len(b l j ) x b l j −x a l j ≥ −σ l j ← ξ l j +μ l j −len(a l j )−len(b l j )</formula><p>,</p><formula>(2)</formula><p>where different slack variables are used for the two contig pair orientations. The expressions for other combinations of e l j and r l j are derived similarly. Order constraints are derived from read order constraints (i.e. if c j follows c i , then they should not overlap and c j must be upstream of c i ), which additionally can be relaxed. The relaxation is necessary because (i) assembled contigs may overlap (<ref type="bibr" target="#b27">Pop et al., 2004</ref>); (ii) in some cases the order constraints on data are not valid when extended to contigs, as illustrated in<ref type="figure" target="#fig_1">Figure 3</ref>. Translating order constraints into optimization constraints as</p><formula>⎧ ⎨ ⎩ x a l j −x b l j ≥ −len(b l j )· → l j , t a l j = 0 x b l j −x a l j ≥ −len(a l j )· ← l j , t a l j = 1 (3)</formula><p>(formulas shown for e l j = 0 ∧ r l j = 0) discourages overlaps while still allowing the order constraint to be violated when l j &gt; 1. These slack variables are weighed by the length of the downstream contig to allow measuring them on a single scale. As for the distance optimization constraints, it is assumed that the relative contig orientation is correct. Orientation constraints are modeled in the optimization objective function, which is designed to attain larger values when more orientation constraints are satisfied. The function is given by a polynomial</p><formula>g(t) = e l j =0 j=1,...,m q a l j b l j ω l j + e l j =1 j=1,...,m (1−q a l j b l j )ω l j ,</formula><p>where q ab = t a +t b −2t a t b ≡ 0, a and b are equally oriented 1, otherwise .</p><p>It is equal to the sum of weights of contig links with satisfied orientation and serves as a basis for the optimization objective that is further penalized proportionally to slack variables. Slack penalties: the distance and order constraints are added to the optimization problem through slack variable penalization. The penalty is proportional to the importance weight of the corresponding contig link and to the value of the slack variable. To avoid situations when a low-weight violated constraint results in a large penalty, a maximum penalty of half of the importance weight is enforced, after which the constraint is considered disabled. Doing this has the additional benefit of equalizing the influence of order and distance constraints. To this end we penalize as follows</p><formula>ω l j 2 · min(ξ l j ,S ξ ) S ξ , (4)</formula><p>where ξ l j is chosen as</p><formula>→ ξ l j or ← ξ l j ,</formula><p>according to the contig pair orientation and S ξ is the maximum slack threshold (after which the slack is disabled). Because the expression min(ξ,S ξ ) is not suitable for direct use in a MIP, it is unrolled using the switch variables as</p><formula>[α l j ξ l j +(1−α l j )S ξ ]</formula><p>. Similar penalties with variables l j and β l j , and maximum slack threshold S are used for the order constraints. We set S ξ = 6 (i.e. six SDs) as in<ref type="bibr" target="#b7">Gao et al. (2011)</ref>; Li and Durbin (2009); and S = 1, as at this value of slack the physical order constraint is not satisfied anymore. Further, only the slacks for the appropriate contig pair orientation have to be penalized. This is achieved by penalizing</p><formula>(1−t a l j ) → ξ l j +t a l j ← ξ l</formula><formula>h(t,α,ξ,S ξ ) = e l j =0 j=1,...,m q a l j b l j ω l j 2S ξ (1−t a l j ) → ξ l j +t a l j ← ξ l j + + e l j =1 j=1,...,m (1−q a l j b l j ) ω l j 2S ξ (1−t a l j ) → ξ l j +t a l j ← ξ l j .</formula><p>Expansion of this function leads to a fourth degree polynomial, containing only terms that consist purely of binary variables, or one continuous and up to three binary variables. To construct a MIQP formulation, using the big-M formulation (<ref type="bibr" target="#b23">Nemhauser and Wolsey, 1988</ref>), these terms can be replaced by a single new auxiliary variable each at the expense of introducing new optimization constraints. Putting it all together: we maximize</p><formula>f (x,t,α,β,ξ,,) ≡ g(t)−h(t,α,ξ,S ξ )−h(t,β,,,S ),</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Problem splitting</head><p>We tackle this intractability with an expectation–maximization (EM) like procedure. The maximization step assumes the contig orientations are known (i.e. t i and q ab are fixed). Knowing t i allows us to choose the slack variables (</p><formula>→ ξ l j or ← ξ l j , and → l j or ← l j )</formula><p>depending on the contig pair orientations, and to select contig links with satisfied relative orientation before the optimization problem is constructed, significantly reducing the number of optimization constraints and the complexity of the optimization problem:</p><formula>f (x,α,β,ξ,,) = g−h(α,ξ,S ξ )−h(β,,S ) g = ω l j ≡ const, h(α,ξ,S ξ ) = min(ξ l j ,S ξ )· ω l j 2S ξ .</formula><formula>(5)</formula><p>This fixed optimization problem, however, is still NP-hard due to the binary variables α l j and β l j involved in expansion of the min terms. We obtain an approximate solution to this problem by first exactly solving its continuous relaxation, choosing α l j and β l j according to the slack values in the relaxation solution and finally, re-solving the problem with these values fixed. The relaxation is obtained by replacing h(α,ξ,</p><formula>S ξ ) by h(ξ,S ξ ) = 1/2S ξ ω l j ξ l j in (5)</formula><p>. This eliminates all binary variables, allowing the use of efficient optimization algorithms (<ref type="bibr">Dantzig, 1988</ref>). The solution for the relaxed problem gives us optimal values for slacks ξ l j and l j , which are used to</p><formula>choose α l j and β l j as α l j = 0, ξ l j &gt; S ξ 1, ξ l j ≤ S ξ , β l j = 0, , l j &gt; S 1, , l j ≤ S ,</formula><p>and allows us to re-solve problem (5). The rationale behind is that, since the majority of link information is assumed to be correct, large slack values will be associated with incorrect constraints that have to be disabled. The total penalty for l j is memorized (initially set to zero) for use in the expectation step as</p><formula>l j ← min(ξ l j ,S ξ ) 2S ξ ω l j + min( l j ,S ) 2S ω l j .</formula><p>The expectation step is used to obtain the expected contig orientations t i , which maximize the objective function for the previously observed penalties. Consider the MIQP problem when penalties associated with the links are known (i.e. l j , ξ l j , α l j and β l j are fixed), and the optimal contig orientation is sought. In this problem, when a contig link is enabled, its weight is penalized by the associated slack l j. We can, therefore, consider an equivalent problem where all slacks are zero and link weights are modified as˜ωas˜ as˜ω l j ← ω l j − l j. The problem is then to maximize</p><formula>f (t) ≡ g(t) = e l j =0 j=1,...,m q a l j b l j ˜ ω l j + e l j =1 j=1,...,m (1−q a l j b l j ) ˜ ω l j (6)</formula><p>free of any constraints. This is an unconstrained binary quadratic programming (UBQP) problem (<ref type="bibr" target="#b2">Beasley, 1998</ref>), the problem of maximizing a function c(t) = t t Ct, where x is a binary vector of length n and C is an n×n real matrix. Consider a vector of orientations t ∈{0,1} n and a matrix C of size n. Starting from a zero matrix, C = (c ij ) can be obtained by updating it for every link l j = (a,b) as</p><formula>c aa ← (−1) e l j ˜ ω l j +c aa , c bb ← (−1) e l j ˜ ω l j +c bb c ab ← (−1) e l j +1 ·2˜ω·2˜ ·2˜ω l j +c ab .</formula><p>The functions f (t) and c(t) will then differ by a constant and, therefore, reach maxima for the same t. Solving a UBQP is known to be an NP-hard, but well-studied problem with efficient heuristic algorithms available (<ref type="bibr" target="#b18">Merz and Katayama, 2004;</ref><ref type="bibr" target="#b24">Nesterov, 1997;</ref><ref type="bibr" target="#b25">Pardalos et al., 2008</ref>). Thus, the UBQP formulation of the problem is preferred over (6) for obtaining values of t i. The EM steps are iterated while contig orientations change. The algorithm can be viewed as an iterative UBQP approximation of the original MIQP problem. In practice, it converges to a solution within seven iterations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Scaffold extraction and post-processing</head><p>Repeat contigs in the contig link graph G are connected by ambiguous links, hindering a confident positioning in scaffolds. In a pre-processing step, we detect such contigs using a modification of the A-statistic (<ref type="bibr" target="#b20">Myers et al., 2000</ref>) proposed by<ref type="bibr" target="#b31">Zerbino (2009)</ref>, and prevent their incorporation in scaffolds by removing all links from G incident to them. The connected components of G correspond to separate subproblems, which are solved independently. After optimization, each solution tuple (x,t,α,β) and corresponding subgraph G are converted into one or more scaffolds. First, contig links with disabled constraints (i.e. α l j = 0∨β l j = 0) are removed from G to minimize the chance of incorrectly incorporating contigs in the same scaffold. Every connected component of the resulting G is used to construct a single nucleotide sequence. Contigs are processed in order of their downstream end coordinates. The left end of the first contig is put at the start of the sequence; every new contig is added to the scaffold such that the gap between two consecutive contigs is preserved. When consecutive contigs are predicted to overlap (i.e. have a negative gap size), the new contig is pushed upstream to eliminate the overlap. Because resolving contig overlaps in this way potentially leads to erroneous sequence reconstruction, we also explore an optional postprocessing approach that performs global sequence alignment on consecutive contigs to find the best overlap. Global alignment is performed using a divideand-conquer version of the Needleman–Wunsch algorithm (<ref type="bibr" target="#b9">Hirschberg, 1975</ref>). Algorithm implementation from the NCBI C++ Toolkit was used (National Center for Biotechnology Information, 2011). For every consecutive pair of contigs predicted to have a gap of μ bp, all gap sizes of at most d = 100 bp away from the predicted value are examined. Negative gap sizes indicate overlaps. For each gap size g, global alignment of overlapping contig ends is performed (match score of p match = 2, mismatch penalty of p mismatch =−3). The best gap size is then chosen based on the alignment score S and proximity to the predicted gap size μ by maximizing</p><formula>S g·p match · d −|g−μ| d . (7)</formula><p>With the (mis)match scores chosen as above, this expression takes values in<ref type="bibr">[−1.5;1]</ref>. Due to computational complexity only overlaps of no more than 1500 bp are considered (gap sizes with longer overlaps are assigned a score of −1). The decision to join two contigs, to leave a gap between them or to</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GRASS: generic assembly scaffolder</head><p>split the scaffold is then made:</p><p>@BULLET If none of the considered gap sizes suggest overlaps, the two contigs are positioned in a scaffold with a gap of μ bp. @BULLET If value of expression (7) for the chosen gap size g passes a quality threshold of 0.8, the contigs are positioned to have an overlap of g bp. The overlap is replaced with the alignment consensus sequence, where mismatches are masked with unknown nucleotides. @BULLET If the chosen gap size does not pass the quality threshold and is shorter than 50 bp, the two contigs are positioned successively one following another with no overlap. @BULLET Finally, if the chosen gap size suggests a longer overlap, the currently constructed scaffold is split into two with a new scaffold starting from a contig that was predicted to lie upstream.</p><p>In principle, the proposed post-processing step with scaffold splitting allows for construction of more accurate scaffolds compared with the naïve scaffold extraction. We refer to the combination of GRASS and post-processing as GRASS+.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Evaluation criteria</head><p>Similar to assemblies, scaffolds are evaluated based on accuracy and contiguity. Scaffold accuracy can be assessed by comparing scaffolds to available reference sequences. We adopted the evaluation criteria from<ref type="bibr" target="#b5">Dayarian et al. (2010)</ref>;<ref type="bibr" target="#b7">Gao et al. (2011)</ref>and counted the number of scaffold breakpoints, i.e. consecutive contig pairs in the scaffold that do not agree with the reference on contig distance, order or orientation. We perform local alignment of scaffolds to the reference and count the number of breakpoints within each scaffold. Two consecutive alignments are counted as a breakpoint if any of these hold: (i) they align to two different chromosomes in the reference; (ii) their relative orientations in the scaffold and in the reference do not match; (iii) their relative orders in the scaffold and in the reference do not match; (iv) the difference in distance in the scaffold and in the reference is larger than. We used = 10 kb and = 500 bp to asses contig distance correctness at low and high resolution, respectively. MUMmer (<ref type="bibr" target="#b6">Delcher et al., 2002</ref>) was used to align scaffolds to references. Best hits for each position in the scaffold were computed. Only hits with at least 90 aligned bases (alignment length × alignment identity), were taken into account. In practice, very few alignments do not pass this cutoff. The alignments are also used to calculate the percentage of the scaffold bases and the reference bases that are aligned (<ref type="bibr" target="#b29">Salmela et al., 2011</ref>). These numbers capture scaffold accuracy and completeness. Finally, scaffold completeness and contiguity are captured as in sequence assembly, calculating total length of all scaffolds, number of scaffolds, maximum scaffold length and the N50 statistic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">IMPLEMENTATION</head><p>GRASS source code is available under the GNU GPL v3 license. It was developed in C++ and tested on Linux. GRASS consists of linker and scaffolder modules. The linker takes contigs and the available information sources as input and produces linking and coverage data, which is then used by the scaffolder module. It filters out repeat contigs and uses the remaining data to produce scaffolds. Scaffolds are output both as lists of contigs with assigned coordinates and orientations, and as linear FASTA sequences with gaps.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Paired read data processing</head><p>To obtain contig links from paired read data, the linker module performs single-end mapping of the reads to contigs. The algorithm used for mapping depends on the data type: BWA (<ref type="bibr" target="#b16">Li and Durbin, 2009</ref>) for Illumina reads, NovoAlign (http://www.novocraft.com/) for 454 data. The aligners are set to output all mapping locations, including non-unique hits, as a SAM file (<ref type="bibr" target="#b16">Li et al., 2009</ref>), which is then converted to BAM for further processing. This process is applied to each paired read library. Read alignments are pre-processed to remove read pairs with low quality and ambiguous alignments. As a rule, only unique hits with no mismatches and minimum read length of 30 bp are kept. The filtered alignments are then scanned for paired reads that align to different contigs. Each such read pair mapping is used to create a single contig link with distance, order and orientation constraints derived from the mapping and the given read pairing method (i.e. paired ends or mate pairs). The BamTools API (<ref type="bibr" target="#b1">Barnett et al., 2011</ref>) is used for filtering and processing read alignments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Related genome data processing</head><p>An available reference sequence, such as the genome of a related organism, can be used for guiding the scaffolding process. For this purpose, contigs are aligned to the reference sequence. For every contig, a position in the reference sequence is obtained from contig tiling constructed from local alignments using MUMmer. Contig links are then created for every pair of consecutive contigs aligning to the same reference sequence, with relative orientation and order derived from the tiling. To capture alignment quality, weights for links</p><formula>l j = (a l j ,b l j ) are set to I a l j ×I b l j ×C a l j ×C b l j ×W , where I a l j and I b l j are alignment identities, C a l j and C</formula><p>b l j are alignment coverages reported by MUMmer for the corresponding contigs, and W &gt; 0 is a weight assigned to the reference sequences as a scaffolding information source. This procedure is applied for each available reference sequence to create links, which are then used together in the optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Optimization problem solution</head><p>The EM procedure proposed for solving the MIQP formulation of the CSP splits it into a continuous linear programming (LP) problem, and an UBQP problem. Although more efficient algorithms for solving UBQPs are available (<ref type="bibr" target="#b24">Nesterov, 1997;</ref><ref type="bibr" target="#b25">Pardalos et al., 2008</ref>), a memetic algorithm from Merz and Katayama (2004) was chosen for ease of implementation. Usually, contig link graphs are sparse due to the linear scaffold structure that they encompass. Memetic algorithms improve individual solutions through local search, which in turn is well-suited for smooth search landscapes (as in the case of sparse contig link graphs). Graph sparsity is further exploited by implementing sparse matrix operations as in<ref type="bibr" target="#b18">Merz and Katayama (2004)</ref>. We use the C++ Concert API for the CPLEX Optimizer (IBM ILOG, 2011) to solve LPs. CPLEX is freely available for academic use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS AND DISCUSSION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Experimental setup</head><p>We have evaluated GRASS on de novo HTS assemblies of three bacterial genomes: E.coli K12, substr. MG1655; P.suwonensis 11-1; and P.syringae B728a. For these organisms, finished genome sequences and HTS data from resequencing experiments are available. Presence of a finished genome sequence allows for reliably evaluating the algorithm and comparing it to other scaffolders in a de novo setup. This is achieved by using the reference sequence only in scaffold evaluation (thus not as an additional information source in the scaffolding process). The available test data is summarized in<ref type="figure" target="#tab_1">Table 1</ref>. Insert size and coverage were obtained from paired read mapping using BWA and BEDTools (<ref type="bibr" target="#b28">Quinlan and Hall, 2010</ref>). Velvet (<ref type="bibr" target="#b30">Zerbino and Birney, 2008</ref>) was used to assemble reads into contigs. All assemblies had a coverage cutoff of 6 and were not scaffolded by the assembler. Only contigs longer than 150 bp were kept. Repeat resolution was disabled (i.e. no expected coverage was provided). For each organism, the k-mer length was chosenby performing assemblies for various k and choosing one based on assembly contiguity, length, percentage of mapped single reads, and percentage of properly paired reads (<ref type="bibr" target="#b16">Li and Durbin, 2009</ref>) (Supplementary Tables S1, S2 and S3). For E.coli, P.suwonensis and P.syringae, k = 31, k = 59 and k = 23 were chosen, respectively. This way of choosing k reflects real-life de novo assembly scenarios, yielding a realistic algorithm evaluation. Final assemblies are characterized in Tables 2–4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Comparison to other scaffolders</head><p>We compared GRASS with SSPACE, MIP and OPERA scaffolders. Where required, insert size estimates from<ref type="figure" target="#tab_1">Table 1</ref>were used. Tables 2–4 show evaluation metrics calculated for these scaffolders and the available test data. Unless stated otherwise, all scaffolders were run with default parameter settings. BWA was used to map reads to scaffolds and produces SAM files required by the MIP Scaffolder. As in<ref type="bibr" target="#b29">Salmela et al. (2011)</ref>, at most two mismatches were allowed in read mapping. For SSPACE and OPERA, reads were aligned with Bowtie (<ref type="bibr" target="#b15">Langmead et al., 2009</ref>) using scripts provided with the scaffolders. GRASS used an erosion cutoff of 4 (although better results can be obtained by tuning this parameter) and coverage estimates obtained from exact mapping of the reads to the assembly contigs. The latter is available from output of the linker module. The SSPACE maximum distance parameter was set to 6 SDs for each paired library. Libraries were input in order of increasing insert size. The MIP Scaffolder was also provided with coverage estimates computed from exact read mapping. Following the original publication, we tried different filtering parameters (ω,p) and chose those which gave the highest N50 value. Settings (36,0.8), (70,0.4) and (50,0.6) were selected for the E.coli, P.suwonensis and P.syringae data, respectively. Maximum partition sizes were set to 100 for the E.coli scaffolds and 50 for the P.suwonensis and P.syringae scaffolds. Maximum and minimum insert sizes were chosen by adding and subtracting 6 SDs to the mean insert size. OPERA does not allow using multiple read sets. It was applied to each read library separately, and in the case of P.suwonensis, also to a join of the available read sets, as they have the same insert size. The minimum contig length was set to 150 bp, i.e. the contig length cutoff parameter used in Velvet. We used the default PET parameter value whenever possible and increased it to the minimum value that allowed OPERA to finish without triggering a timeout abort. Cutoff values 6 and 7 were used for the E.coli dataset; cutoffs 27, 5 and 5 were used for the P.suwonensis dataset; and 11 was used for the P.syringae dataset (values are given in the order of the experiments in Tables 2–4). SOPRA was applied to assembly graphs produced by Velvet. However, when used with parameters chosen in accordance to the manual provided, SOPRA produced highly fragmented scaffolds compared with results from<ref type="bibr" target="#b29">Salmela et al. (2011)</ref>. To allow for a fair comparison, its results were not taken into account.As a scaffolder, Velvet was provided with mean insert size and SD for each library. The data was reassembled with repeat resolution (expected coverage estimated automatically) and scaffolding turned on. Its performance was used as a baseline over which all scaffolders improved on P.syringae data and only SSPACE and GRASS improved on E.coli and P.suwonensis data. Tables 2–4 contain the results. Note that the minimum number of breakpoints is one, due to the circular structure of bacterial genome. Breakpoints at = 10 kb and = 500 bp differ only slightly, suggesting that gap lengths are estimated with high precision. SSPACE produced the longest scaffolds for E.coli. It also produced the smallest number of scaffolds for E.coli and P.suwonensis. The longest scaffolds and the smallest number of scaffolds on the P.syringae dataset are achieved by the MIP Scaffolder. Similar scaffold and reference coverage percentages were achieved by all scaffolders. However, GRASS+ has the smallest number of breakpoints for all considered organisms. Additionally, for the case of P.suwonensis, GRASS constructed the longest scaffolds and GRASS+ produced breakpoint-free scaffolds while providing a 2-fold reduction in the number of contigs. Scaffolds produced by the MIP Scaffolder and OPERA are either very fragmented or have a large number of breakpoints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GRASS: generic assembly scaffolder</head><p>When constructing scaffolds, scaffolding algorithms balance between scaffold contiguity and scaffold accuracy. This tradeoff is captured in<ref type="figure">Figure 4</ref>by plotting the number of breakpoints (at = 10 kb) against the number of scaffolds. A good scaffolder would be located in the lower left corner of such a plot. In many cases, GRASS combines a smaller number of breakpoints with a small number of scaffolds, compared with other scaffolders. The MIP Scaffolder and SSPACE can achieve smaller numbers of scaffolds, but at the cost of (much) larger numbers of breakpoints. Clearly, GRASS and SSPACE represent two possible choices of scaffolding algorithms, with GRASS being more accurate with respect to the number of breakpoints and SSPACE constructing longer scaffolds. This behavior of the two algorithms is consistent over all datasets. We also measured scaffolding running times, these are depicted in<ref type="figure">Figure 4</ref>using marker size. Exact numbers, as well as read mapping running times are available in<ref type="figure" target="#tab_4">Table S4</ref>. Like most scaffolders, GRASS spends a majority of its time on read alignment, making running times of different scaffolders comparable and running time of the core scaffolding part of GRASS on the considered datasets negligible. Based on simulation results, we do not expect computation to become a bottleneck for large genomes. Nevertheless, to reduce computational load it is always possible tosplit the contig graph into graphs of manageable size by increasing the erosion parameter e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.A.Gritsenko et al.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Using additional information</head><p>To demonstrate the ability of GRASS to utilize various scaffolding information sources, we used two related genomes (see<ref type="figure" target="#fig_4">Fig. 5</ref>) to help scaffold the E.coli assembly: DH10B and BW2952. These genomes were used individually, together and in combination with paired reads. When combining several information sources, care has to be taken in choosing the weights W r and the erosion threshold parameter e. In individual genome experiments, W = 100 and e = 80 were chosen to remove links derived from low-quality alignments. In the experiment using only two related genomes (thus no links derived from paired read data) a higher weight was given to the more closely related strain: e = 70 and W DH10B = 80, W BW2952 = 100 were used for the DH10B and BW2952 strains correspondingly. For experiments combining a single genome with paired reads, W = 10 and e = 4 were chosen. Finally, W DH10B = W BW2952 = 3 and e = 5 were used in the experiment combining all data (including the paired read constraints) to emphasize use of links supported by at least two information sources. When used in the experiment, paired read link weights were set to 1. An SD of 3000 bp was used for links derived from related genomes. Interestingly, using just related genomes GRASS constructs a smaller number of scaffolds than when only paired reads are used.<ref type="figure" target="#tab_5">Table 5</ref>shows, however, that this is achieved at the expense of scaffold accuracy: besides having an increased number ofbreakpoints, scaffolds constructed based on related genomes alone have a high-total assembly length and, as a consequence, a lowscaffold coverage. The higher than anticipated total assembly length is due to differences in contig distances (i.e. physical distances obtained by aligning contigs to a genome sequence) between the MG1655 strain and the related strains. This is also the reason for the large differences observed between breakpoints at = 10 kb and = 500 bp: while relative order and orientation have been preserved for large parts of the genomes of the considered strains, the exact physical distances have not. This situation is partially alleviated when information from the two genomes is combined, because (i) consistent links (derived from the two genomes) get higher weights after link bundling, and (ii) the more closely related strain BW2952 was given a higher weight. In this case, GRASS is able to further reduce the number of scaffolds without introducing new breakpoints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>GRASS: generic assembly scaffolder</head><p>Combining paired read data with information from individual related genomes allows for construction of a smaller number of scaffolds with fewer breakpoints than when using these data individually. The results vary between repeated runs of the algorithm, due to inconsistencies between linking information provided by paired reads and related genomes, combined with the stochastic nature of the optimization strategy used for solving the MIQP formulation. Depending on the intermediate solutions found, different contig links are disabled in the optimization process, leading to different final solutions and, thereby to different scaffolds.<ref type="figure" target="#tab_5">Table 5</ref>, hence, shows a range of scaffold and breakpoint counts, and other results as averages over five repeated runs. This variability is smaller when all data is combined, since a 'voting' approach can be implemented by setting W and e in such a way that all links supported by only a single information source have low weights and are ignored. Using all available information, GRASS reduced the number of scaffolds by 40% compared with just using paired reads, at the expense of introducing a single new breakpoint. The increase in the number of breakpoints is not surprising, as the de novo scaffolding information is augmented with links derived for a different (related) organism. The best result on combined data is shown in<ref type="figure">Figure 4a</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>We presented GRASS, a generic scaffolding algorithm suitable for combining multiple information sources, as well as GRASS+, incorporating a post-processing scaffolding step. Its use was demonstrated by scaffolding genomes based on paired read data and information in related genome sequences, both individually and combined. GRASS achieves the best results when all available scaffolding information is used, as this allows conflicting information from a single source to be ignored when the majority of sources do not support it. Such a mode of operation is supported by the possibility of choosing weights for the individual information sources, combined with the contig link erosion threshold. We compared GRASS with a number of state-of-the-art scaffolders (SSPACE, MIP and OPERA) on three datasets. GRASS constructs the most accurate scaffolds on all datasets, while keeping the number of scaffolds low. Only SSPACE consistently produces lower numbers of scaffolds, but these are significantly less accurate. The accuracy/contiguity tradeoff displayed by GRASS puts it in a unique niche compared with existing scaffolders. The current implementation of GRASS supports the use of paired read information and related genomes for scaffolding. However, the algorithm is not limited to any particular set of information sources. We will extend GRASS to allow use of other sources, such as optical restriction maps, RNA-seq and EST data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEGEMENT</head><p>We would like to thank Bas Dutilh for fruitful discussion and the anonymous reviewers for comments which helped improve the manuscript.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig</head><figDesc>Fig. 2. Optimization variables x a l j , x b l j , t a l j and t b l j associated with contigs. Example for e l j = 0∧r l j = 0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.3.</head><figDesc>Fig. 3. Contigs a and b are not in the order predicted by mapped paired reads l and r, although the paired reads are in the correct order</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [16:26 7/5/2012 Bioinformatics-bts175.tex] Page: 1435 1429–1437</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [16:26 7/5/2012 Bioinformatics-bts175.tex] Page: 1436 1429–1437</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.5.</head><figDesc>Fig. 5. Phylogenetic tree showing evolutionary distance between the E.coli MG1655 strain and two related strains. Genome sequences were obtained from GenBank</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [16:26 7/5/2012 Bioinformatics-bts175.tex] Page: 1437 1429–1437</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><figDesc>Funding: Plant Green Synthetic Biology Consortium and Kluyver Centre for Genomics of Industrial Fermentation, subsidiaries of the Netherlands Genomics Initiative (NGI). Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Fig. 1. Examples of contig links l j between contigs a l j and b l j and their corresponding relative orientation (e l j ), relative order (r l j ) and distance (μ l j ± σ l j ) constraints</figDesc><table>Copyedited by: TRJ 

MANUSCRIPT CATEGORY: ORIGINAL PAPER 

[16:26 7/5/2012 Bioinformatics-bts175.tex] 
Page: 1430 1429–1437 

A.A.Gritsenko et al. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>. 2. Optimization variables x a l j , x b l j , t a l j and t b l j associated with contigs. Example for e l j = 0∧r l j = 0 variation in contig distances derived from the paired read insert size. It is also suitable for scaffolding constraints without (reliable) distance estimates, for example constraints derived from paired RNA-seq data of an organism with abundant intron splicing, or by mapping contigs to genome of a distant relative. Such constraints can use a large σ l j to reflect the uncertainty in the data source. We refer to l j , its importance weight ω l j , and the corresponding contig pair-wise constraints as a contig link, and to G as the contig link graph. For succinct notation, for every contig link constraints are recorded as @BULLET e l j = 0, a l j and b l j are from different strands 1, a l j and b l j are from the same strand @BULLET r l j = 0, a l j follows b l j 1, b l j follows a l j given that a l j has forward orientation.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>@BULLET Slack variables for distance constraints, ξ l j ={ → ξ l j , ← ξ l j }∈R + ×R + , and order constraints, l j ={ → l j , ← l j }∈R + ×R + , for forward (t a l j = 0)</figDesc><table>and reverse (t a l j = 1) orientations of the contig pair, respectively. By 
design these variables reflect the degree to which the corresponding 
constraints are violated. They are penalized in the optimization 
objective f . 

@BULLET Switch variables for distance constraints, α l j ∈{0,1}, and order 
constraints, β l j ∈{0,1} (0, constraint is disabled; 1, enabled) used for 
disabling contig link constraints with high penalties. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>j in place of ξ l j in (4). This expression 'chooses' which</figDesc><table>slack variable to penalize depending on the contig pair orientation. Finally, 
the constraints have to be penalized only when they are meaningful (i.e. 
the relative contig orientation e l j is assumed to be satisfied). The resulting Copyedited by: TRJ 

MANUSCRIPT CATEGORY: ORIGINAL PAPER 

[16:26 7/5/2012 Bioinformatics-bts175.tex] 
Page: 1432 1429–1437 

A.A.Gritsenko et al. 

function looks as follows: 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><figDesc>Table 1.</figDesc><table>Available datasets NCBI/EBI accession numbers are given for reference sequences and read sets. In all cases reads were produced by the Illumina 
sequencing platform. 

E.coli 
P.suwonensis 
P.syringae 

Genome size 
4.64 Mb 
3.42 Mb 
6.09 Mb 
Reference 
NC_000913.2 
CP002446.1 
NC_007005.1 

Dataset 
SRR001665 
SRR001666 
SRR097515 
SRR191848 
ERR005143 
Read count 
2×10 408 224 
2×7 047 668 
2×23 960 004 
2×19 789 425 
2×3 551 133 
Read length 
36 bp 
36 bp 
76 bp 
76 bp 
36 bp 
Coverage 
160× 
107× 
709× 
824× 
38× 
Insert size 
216±10 
488±18 
189±17 
189±17 
401±33 

(a) 
( b) 
( c) 

Fig. 4. Scaffold accuracy and contiguity tradeoff on the available datasets. Marker size indicates scaffolding running time in minutes, exact numbers are given 
in Table S4. GRASS+ using paired reads and two related genomes is shown in (a) as 'GRASS+ (all)'. (a) E.coli data. Running time ranges in [8 s;27 min 49s]. 
(b) P.suwonensis data. Running time ranges in [13 s;8 min 19s]. (c) P.syringae data. Running time ranges in [1 s;72 min 22 s] 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="false"><figDesc>Table 2. Contiguity and accuracy statistics of the initial assembly of E.coli and its scaffolds</figDesc><table>Scaffolder 
Breakpoints 
Breakpoints 
Number of 
N50 
Maximum 
Total 
Reference 
Scaffolds 
= 10 kb 
= 500 bp 
scaffolds 
length (bp) 
length (bp) 
covered (%) 
covered (%) </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="true"><figDesc>Table 4. Contiguity and accuracy statistics of the initial assembly of P.syringae and its scaffolds</figDesc><table>Scaffolder 
Breakpoints 
Breakpoints 
Number of 
N50 
Maximum 
Total 
Reference 
Scaffolds 
= 10 kb 
= 500 bp 
scaffolds 
length (bp) 
length (bp) 
covered (%) 
covered (%) 

Velvet contigs 
1 
1 
1560 
8599 
46 055 
5 902 217 
96.41 
99.78 
Velvet scaffolds 
25 
27 
200 
122 286 
683 615 
6 012 535 
97.78 
99.37 

SSPACE 
21 
26 
192 
87 996 
520 403 
5 946 936 
96.61 
99.09 
GRASS 
22 
25 
243 
85 493 
618 916 
5 931 679 
96.57 
99.38 
GRASS+ 
6 
7 
266 
77 945 
460 726 
5 945 096 
96.56 
99.01 
MIP Scaffolder 
37 
47 
167 
94 327 
279 875 
5 943 358 
96.58 
99.17 
OPERA 
14 
14 
705 
18 108 
76 357 
5 950 236 
96.58 
99.17 

Results with the smallest number of breakpoints or scaffolds are shown in bold. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="true"><figDesc>Table 5. Contiguity and accuracy statistics of E.coli scaffolds obtained with GRASS+ using additional data</figDesc><table>Reads 
DH10B 
BW2952 
Breakpoints 
Breakpoints 
Number of 
N50 
Maximum 
Total 
Reference 
Scaffolds 
used 
used 
used 
= 10 kb 
= 500 bp 
scaffolds 
length (bp) 
length (bp) 
covered (%) 
covered (%) 

Yes 
No 
No 
2 
2 
120 
112 254 
268 030 
4 546 640 
97.53 
99.55 

No 
Yes 
No 
10 
66 
105 
425 724 
1 948 314 
5 047 825 
97.51 
89.65 
No 
Yes 
4 
65 
90 
843 564 
1 099 102 
4 773 879 
97.52 
92.64 
Yes 
Yes 
6 
70 
81 
612 889 
1 315 367 
4 763 935 
97.52 
94.80 
Yes 
Yes 
No 
3–6 
40–49 
72–120 
≈ 273 503 
≈ 850 450 
≈ 4 804 124 
≈ 97.52 
≈ 94.99 

No 
Yes 
2–7 
51–55 
67–80 
≈ 497 383 
≈ 1 077 789 
≈ 4 569 001 
97.53 
≈ 99.06 

Yes 
Yes 
3 
44–46 
71–73 
≈ 363 105 
≈ 988 508 
≈ 4 583 534 
97.53 
≈ 98.75 

The '≈' sign indicates mean values over 10 repeated runs in cases, when variation was observed. Results with the smallest number of breakpoints or scaffolds are shown in bold. 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Standard operating procedure for calculating genome-to-genome distances based on high-scoring segment pairs</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">F</forename>
				<surname>Auch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Stand. Genomic Sci</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="142" to="148" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">BamTools: a C++ API and toolkit for analyzing and managing BAM files</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">W</forename>
				<surname>Barnett</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1691" to="1692" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Heuristic algorithms for the unconstrained binary quadratic programming problem</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">E</forename>
				<surname>Beasley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Management School, Imperial College</title>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Scaffolding pre-assembled contigs using SSPACE</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Boetzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="578" to="579" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">Linear Programming and Extensions</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">B</forename>
				<surname>Dantzig</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
			<publisher>Princeton University Press</publisher>
			<pubPlace>Princeton, NJ, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">SOPRA: scaffolding algorithm for paired reads via statistical optimization</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Dayarian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">345</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Fast algorithms for large-scale genome alignment and comparison</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">L</forename>
				<surname>Delcher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="2478" to="2483" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Opera: reconstructing optimal genomic scaffolds with highthroughput paired-end sequences</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1681" to="1691" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Whole-genome prokaryotic phylogeny</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">R</forename>
				<surname>Henz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="2329" to="2335" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">A linear space algorithm for computing maximal common subsequences</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">S</forename>
				<surname>Hirschberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="341" to="343" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">The greedy path-merging algorithm for contig scaffolding</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="603" to="615" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Application of phylogenetic networks in evolutionary studies</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Bryant</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="254" to="267" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title level="m" type="main">ILOG CPLEX: high-performance software for mathematical programming and optimization. Available at http://www.ilog.com/products/cplex</title>
		<author>
			<persName>
				<forename type="first">Ibm</forename>
				<surname>Ilog</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011-04-06" />
		</imprint>
	</monogr>
	<note>Last. accessed date</note>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Combinatorial algorithms for DNA sequence assembly</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">D</forename>
				<surname>Kececioglu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="7" to="51" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Assembly of the working draft of the human genome with GigAssembler</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">J</forename>
				<surname>Kent</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Haussler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1541" to="1548" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with BurrowsWheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">The Sequence Alignment/Map format and SAMtools</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2078" to="2079" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Memetic algorithms for the unconstrained binary quadratic programming problem</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Merz</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Katayama</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BioSystems</title>
		<imprint>
			<biblScope unit="volume">78</biblScope>
			<biblScope unit="page" from="99" to="118" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Aggressive assembly of pyrosequencing reads with mates</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">R</forename>
				<surname>Miller</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="2818" to="2824" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">A whole-genome assembly of Drosophila</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">287</biblScope>
			<biblScope unit="page" from="2196" to="2204" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Biological Sequence Data Model</title>
	</analytic>
	<monogr>
		<title level="m">The NCBI C++ Toolkit Book (Internet)</title>
		<editor>Vakatov,D.</editor>
		<meeting><address><addrLine>Bethesda, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Scaffolding and validation of bacterial genome assemblies using optical restriction maps</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Nagarajan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1229" to="1235" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<monogr>
		<title level="m" type="main">Integer and combinatorial optimization</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">L</forename>
				<surname>Nemhauser</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">A</forename>
				<surname>Wolsey</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>Wiley-Interscience</publisher>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Quality of semidefinite relaxation for nonconvex quadratic optimization. CORE Discussion Papers</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Nesterov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Center for Operations Research (CORE)</title>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Global equilibrium search applied to the unconstrained binary quadratic optimization problem</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">M</forename>
				<surname>Pardalos</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Optim. Meth. Softw</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="129" to="140" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">IDBA – a practical iterative de Bruijn graph de novo assembler</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="149" to="159" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Hierarchical scaffolding with Bambus</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="149" to="159" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">BEDTools: a flexible suite of utilities for comparing genomic features</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">R</forename>
				<surname>Quinlan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<forename type="middle">M</forename>
				<surname>Hall</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="841" to="842" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Fast scaffolding with small independent mixed integer programs</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Salmela</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="3259" to="3265" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">Genome assembly and comparison</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Bioinformatics Institute</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>