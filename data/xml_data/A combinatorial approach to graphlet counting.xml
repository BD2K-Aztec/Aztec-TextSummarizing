
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:46+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Data and text mining A combinatorial approach to graphlet counting</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Tomaž</forename>
								<surname>Hoč</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Faculty of Computer and Information Science</orgName>
								<orgName type="department" key="dep2">Associate Editor: Igor Jurisica</orgName>
								<orgName type="institution">University of Ljubljana</orgName>
								<address>
									<postCode>SI-1000</postCode>
									<settlement>Ljubljana</settlement>
									<country key="SI">Slovenia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Janez</forename>
								<surname>Demš</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Faculty of Computer and Information Science</orgName>
								<orgName type="department" key="dep2">Associate Editor: Igor Jurisica</orgName>
								<orgName type="institution">University of Ljubljana</orgName>
								<address>
									<postCode>SI-1000</postCode>
									<settlement>Ljubljana</settlement>
									<country key="SI">Slovenia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Data and text mining A combinatorial approach to graphlet counting</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="issue">4</biblScope>
							<biblScope unit="page" from="559" to="565"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btt717</idno>
					<note type="submission">Received on August 30, 2013; revised on November 29, 2013; accepted on December 6, 2013</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Small-induced subgraphs called graphlets are emerging as a possible tool for exploration of global and local structure of networks and for analysis of roles of individual nodes. One of the obstacles to their wider use is the computational complexity of algorithms for their discovery and counting. Results: We propose a new combinatorial method for counting graph-lets and orbit signatures of network nodes. The algorithm builds a system of equations that connect counts of orbits from graphlets with up to five nodes, which allows to compute all orbit counts by enumerating just a single one. This reduces its practical time complexity in sparse graphs by an order of magnitude as compared with the existing pure enumeration-based algorithms. Availability and implementation: Source code is available freely at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Following the advent of high-throughput methods more than a decade ago, analysis of complex network data has assumed the central role among computational methods in bioinformatics. The huge size of such networks on one hand and the computational intractability of the related methods on the other have spawned a number of innovative analytic approaches. Przˇulj<ref type="bibr" target="#b17">Przˇulj et al. (2004)</ref>described an approach focused on small induced subgraphs called graphlets. Owing to combinatorial explosion, such analysis is usually limited to the 30 graphlets with 2–5 nodes (<ref type="figure" target="#fig_0">Fig. 1</ref>). The number of appearances of graphlets in the network provides a description of the network's structural properties. On a local level, counting how many times a particular node participates in each kind of graphlet induced in the network gives a topological signature of the node's neighbourhood represented as a 30-dimensional vector. For a finer description, the nodes of every graphlet are partitioned into a set of automorphism groups called orbits (<ref type="bibr" target="#b16">PrzˇuljPrzˇulj, 2007</ref>). Two nodes belong to the same orbit if they map to each other in some isomorphic projection of the graphlet onto itself. Nodes of graphlets on 2–5 points are grouped into 73 orbits shown by numbers and node colors in<ref type="figure" target="#fig_0">Figure 1</ref>. For instance, the five nodes from G 14 belong to three different orbits, marked with different colors and numbers; the black (as well as the grey) nodes have symmetric positions in the graphlet and thus belong to the same orbit (31 for the black, 32 for the grey), and the white node belongs to the orbit 33. By counting the number of times a node of a graph appears in each orbit, the node can be described by a 73-dimensional vector of orbit counts, which reflects its position with respect to the local structure and gives insight into its role in the network. Existing methods for counting the graphlets and orbits are based on direct enumeration: to count them, they need to find all their embeddings in the network. We propose a new method, Orbit Counting Algorithm (Orca), which reduces the time complexity by an order of magnitude by computing the orbit counts using the relations between them and directly enumerating only smaller graphlets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Motivation</head><p>Graphlets are used for different kinds of analyses in bioinformatics. Milenkovicánd PrzˇuljPrzˇulj (2008) designed a method for comparing node neighbourhoods based on graphlets and demonstrated that clusters of nodes in protein–protein interaction (PPI) networks, obtained with their graphlet-based distance measure, share common protein properties. They showed how to use this approach to predict functions of proteins and their memberships in protein complexes, subcellular compartments and tissue expressions. Milenkovicét al. (2010b) studied the relation between cancer genes and their network topology. They examined several clustering methods based on a graphlet similarity measure and found a difference between the PPI network structure around the cancer and non-cancer genes. Around 80% of the predicted cancer gene candidates have been validated in the literature. Similarly, cost functions for network alignment that are based on graphlet degree vectors show superior results in comparison with other state-of-the-art methods. In particular, MilenkovicétMilenkovicét al.<ref type="bibr">(2013)</ref>showed how alignment between the PPI networks of Saccharomyces cerevisiae, Drosophila melanogaster and Caenorhabditis elegans with the human PPI network can be used for identification of genes related to aging, which are difficult to observe directly for humans due to our long lifespans. Milenkovicét al. (2011) also applied graphlets to estimate node's topological centrality. Their graphlet degree centrality measure is based on graphlet degree vectors and captures density and complexity of a node's extended neighbourhood. They showed that the genes participating in key biological processes also reside in complex and dense parts of networks.<ref type="bibr" target="#b2">Hayes et al. (2013)</ref>argue that to understand the biological networks, we need to find the mathematical models describing their structure, even though this may not be of direct predictive use. Przˇulj<ref type="bibr" target="#b17">Przˇulj et al. (2004)</ref>showed that although the network structure may be unstable in regions with low edge-density, high-density regions are suitable for network comparison using graphlet degree distributions. Graphlets can also assist in other analytic methods, such as global network alignment. GRAph ALigner (GRAAL) (<ref type="bibr" target="#b7">Kuchaiev et al., 2010</ref>) is an algorithm for aligning arbitrary networks based solely on their topology, which uses a local topology similarity measure based on graphlet degree vectors. The technique was used to show the large amount of shared network topology between yeast and human PPI networks, which can be used to predict biological functions of aligned proteins or reconstruct phylogenetic trees. H-GRAAL (<ref type="bibr">Milenkovicét al., 2010a</ref>) aligns networks by reducing the problem to a weighted bipartite matching that can be solved with Hungarian algorithm. Finally, MI-GRAAL (<ref type="bibr" target="#b6">Kuchaiev and PrzˇuljPrzˇulj, 2011</ref>) integrates multiple sources of node similarity information, including the graphlet degree vectors.<ref type="bibr" target="#b20">Solava et al. (2012)</ref>extended the use of graphlets by defining the orbits for graphlet edges and demonstrated their use with a new clustering method that is not limited to locally similar edges and allows some overlap between clusters. As a practical result, they predicted new pathogen-interacting proteins from clusters in the human PPI network that represent drug target candidates. Therefore, graphlet analysis is a useful tool for bioinformatics, and with the increase of available data there is also a growing need for fast graphlet counting tools.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Related work</head><p>We will denote the explored graph as G ¼ ðV, EÞ. Let ¼ jVj and e ¼ jEj be the number of vertices and edges, and let d denote the maximal node degree. Let N(u) denote the set of vertices adjacent to vertex u. In numbering the graphlets and orbits, we follow PrzˇuljPrzˇulj (2007); we refer to the j-th graphlet and i-th orbit by G j and O i , respectively. Counting subgraphs is a computationally intensive task. Common approaches to speed it up include sampling (<ref type="bibr" target="#b3">Kashtan et al., 2004;</ref><ref type="bibr" target="#b18">PrzˇuljPrzˇulj et al., 2006;</ref><ref type="bibr" target="#b22">Wernicke, 2006</ref>), exploiting pattern symmetries (<ref type="bibr" target="#b21">Stoica and Prieur, 2009</ref>) or using reconfigurable hardware accelerators based on Field-Programmable Gate Array (FPGA) chips (<ref type="bibr" target="#b0">Betkaoui et al., 2011</ref>). The method described in this article is related to the approach developed by<ref type="bibr" target="#b4">Kloks et al. (2000)</ref>, who constructed a system of equations that allows computing the number of occurrences of all six induced four-node subgraphs by knowing the count of any of them. The time complexity of setting up the system equals the time complexity of multiplying two square matrices of size n. We extend this approach to counting how many times each node participates in each orbit. Our method also works on five-node graphlets and scales better on sparse graphs.<ref type="bibr" target="#b5">Kowaluk et al. (2011)</ref>generalized the result by<ref type="bibr" target="#b4">Kloks et al. (2000)</ref>to count subgraph patterns of arbitrary size. There are several programs for graphlet counting and motif detection that are used in bioinformatics. Fast Network Motif Detection (FANMOD) (<ref type="bibr" target="#b23">Wernicke and Rasche, 2006</ref>) is a network motif detection tool based on sampling random subgraphs and comparing their counts with those from random network models. Besides implementing a novel sampling algorithm (<ref type="bibr" target="#b22">Wernicke, 2006</ref>), it also provides a full enumeration procedure for graphlets on 2–8 nodes. Whelan and So¨nmezSo¨nmez (2012) developed GraphletCounter, which works as a Cytoscape plugin and merges graphlet analysis with visual inspection of the network. GraphCrunch (<ref type="bibr">Milenkovicét al., 2008</ref>) is a tool for large network analysis. It includes a function for computing orbit signatures of every graph node for graphlets of up to five nodes using an enumeration procedure with correction for over-counting some of the graphlets. A well-organized enumeration method imposes constraints that eliminate the need for isomorphism testing except for distinguishing between a few different graphlets; this is further accelerated by comparing the number of edges and individual node degrees. GraphCrunch has been extended with a new method for topological network alignment and with<ref type="bibr">2007</ref>). Colors are chosen arbitrarily; nodes of the same color belong to the same orbit within that graphlet, e.g. both black nodes in G 14 belong to orbit 31 comparison of the networks with some additional mathematical models (<ref type="bibr" target="#b6">Kuchaiev et al., 2011</ref>). The graphlet counting procedure in the new version remained essentially the same. Rapid graphlet enumerator (RAGE) (<ref type="bibr" target="#b9">Marcus and Shavitt, 2012</ref>) takes a different approach to counting four-node graphlets. Instead of counting the induced subgraphs directly, it reconstructs them from counts of non-induced subgraphs. For computing the latter, it uses specifically crafted methods for each of the six possible subgraphs (G 3 to G 8 in<ref type="figure" target="#fig_0">Fig. 1</ref>). The time complexity of counting non-induced cycles and complete graphs is Oðe Á d þ e 2 Þ, whereas counting other subgraphs requires Oðe Á dÞ. Another bound, which is also more suitable for comparison with our method, is Oðe Á d 2 Þ ¼ Oðn Á d 3 Þ. Unlike FANMOD and GraphCrunch, RAGE works only for up to four-node graphlets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>Let x represent a certain node of interest in graph G. Our task is to compute the number of times, o i , that x appears in each orbit O i across all graphlets induced in G. We will present an approach based on a system of linear equations that relate the orbit counts o i. The rank of the system is smaller than the number of orbits by one, so we can compute all values of o i from directly enumerating only a single one. The algorithm allows to compute the orbits for all points x in a graph in time that is smaller than the existing direct enumeration approaches by an order of magnitude. We will first show how to construct a system of equations for fournode graphlets. As for the single orbit that must be enumerated, we chose O 14 , which represents nodes of the complete graph, K 4 (or G 8 ); we show an efficient way to enumerate it. The approach used for four-node graphlets is less suitable for larger graphlets, so we present a different technique for five-node graphlets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Orbits in four-node graphlets</head><p>Right sides of equations we are about to construct contain terms that are computed from the graph G. Let cðu, vÞ ¼ jNðuÞ \ NðvÞj denote the number of common neighbours of nodes u and v. Let pðu, vÞ denote the number of paths on three nodes that start at node u, continue with v and end with some node t, which is not connected to u. We can compute pðu, vÞ as pðu, vÞ ¼ degðvÞ À 1 À cðu, vÞ. If some node x participates in a k-node graphlet G i , it also participates in some ðk À 1Þ-node graphlet G j. This can be seen by removing one of the graphlet's nodes that are the farthest away from x. The subgraph induced by the remaining nodes is connected (any disconnected node would have to be farther from x than the removed node), so it is isomorphic to some ðk À 1Þ-node graphlet G j. We will use this observation in reverse: every four-node graphlet can be constructed by adding a node to some three-node graphlets. To find the relations between counts of orbits in four-node graphlets for a certain node x, we enumerate all three-node graphlets touching the node and count their possible extensions with the fourth node. An example is shown in<ref type="figure" target="#fig_2">Figure 2</ref>. Nodes x, y and z induce graphlet G 1 , a path on three nodes; we will observe its extensions to four-node graphlets with the fourth node, w, connected to y and z (dashed lines). The number of such nodes w is cðy, zÞ. In our example, there are cðy, zÞ ¼ 3 such nodes, which we marked by w 1 , w 2 and w 3 (<ref type="figure" target="#fig_2">Fig. 2a</ref>). The edge ðx, wÞ might exist in the graph G (as in the case of w 3 , the dotted line) or not (as for w 1 and w 2 ). With no edge, nodes x, y, z and w form a paw (G 6 ) with x in orbit O 9 (<ref type="figure" target="#fig_2">Fig. 2b</ref>). With an edge between x and w, they form a diamond (G 7 ) with x in orbit O 12 (<ref type="figure" target="#fig_2">Fig. 2c</ref>). Because all cðy, zÞ nodes in NðyÞ \ NðzÞ must participate either in G 6 or G 7 , which puts x in O 9 or O 12 , this gives o 9 þ o 12 ¼ cðy, zÞ for the particular triplet x, y and z.</p><p>We sum this over all possible three-node paths starting at x. Summation must account for symmetries: each graphlet G 6 appearing in the graph is counted twice with roles of z and w reversed, and G 7 is counted twice with reversed roles of y and w. Accounting for this, we get</p><formula>2o 9 þ 2o 12 ¼ X y, z: x, z2NðyÞ G½fx, y, zgffiG1 cðy, zÞ</formula><p>where ffi denotes graph isomorphism (e.g. G½fx, y, zg, a subgraph on nodes x, y and z is isomorphic to G 1 , a path with three nodes). For a different example, we will relate orbits O 6 and O 9. We will extend a path on nodes x, y and z with another path that starts with nodes x and y; we denoted the number of such paths by pðx, yÞ (<ref type="figure" target="#fig_4">Fig. 3a</ref>). Depending on whether the new node is adjacent to z, the extended graphlet is either a claw (G 4 ,<ref type="figure" target="#fig_4">Fig. 3b</ref>) or a paw (G 6 ,<ref type="figure" target="#fig_4">Fig. 3c</ref>). After accounting for symmetries and subtracting 1, as pðx, yÞ also covers the case when w ¼ z, we get</p><formula>2o 6 þ 2o 9 ¼ X y, z: x, z2NðyÞ G½fx, y, zgffiG1 p x, y ð ÞÀ1 ð Þ</formula><p>There are only two three-node graphlets and relatively few possible extensions. Investigating all possibilities in a similar manner yields 10 linearly independent equations with 11 variables that correspond to counts of 11 orbits in four-node graphlets (see the Supplementary Material). Right sides depend on the graph G and need to be computed for each point x. To accelerate their computation, we precompute values of cðu, vÞ and pðu, vÞ. In all equations, except for the last one, cðu, vÞ is computed on pairs of nodes ðu, vÞ that are connected; in pðu, vÞ, they are connected by the definition of p. Therefore, it suffices to precompute cðu, vÞ and pðu, vÞ only for all pairs of connected nodes u and v, which requires O(e) space. The last equation, in which the new node closes a cycle, is treated separately. Nodes x and z are not adjacent but we can precompute the number of paths of length 2 that start at node x and end at node y. This requires O(n) space for each point; because we compute orbits for one point at a time, this memory can be recycled. Altogether, all lookups in the sums on the right sides can be done in constant time by sacrificing the memory of size Oðe þ nÞ for precomputed values cðx, yÞ and pðx, yÞ. The total time complexity for computing all orbits for all nodes is Oðe Á d þ T 4 Þ, where OðT 4 Þ is the time needed to enumerate complete graphlets on four nodes. Later in the text, we describe an algorithm that does this in Oðn Á d 3 Þ, yet the actual importance of this term depends on the structure and density of the graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Counting complete graphlets</head><p>For every node, we still have to determine the count of one of the 11 orbits. Because graphs are usually sparse, a good candidate is the rare orbit 14, which represents the nodes of the complete graphlet on fourSolid lines are edges in the three-node graphlet being extended. Dashed lines exist by definition: w (or w i ) are the common neighbours of y and z. Dotted lines are optional edges that make the resulting four-node graphlet on x, y, z and w i isomorphic to G 6 or G 7 nodes G 8. Because of few occurrences of this graphlet and its symmetricity, we can efficiently restrict the enumeration. A straightforward way to count the complete graphlets of size four that touch a given node x 1 is to start with that node and in every step add a neighbour x i of the last added node x iÀ1 , while checking that the new node is also connected to all nodes before x i , x j5iÀ1. In this way, when we add x 4 as a neighbour of x 3 we have to check whether it is connected to x 1 and x 2 (dotted lines in<ref type="figure">Fig. 4a</ref>), which is unlikely, especially in sparse graphs. A better strategy is to find the common neighbours of x 1 and x 2 , Nðx 1 Þ \ Nðx 2 Þ, which can be done in O(d). We then choose pairs ðx 3 , x 4 Þ from this set and check whether they are connected (<ref type="figure">Fig. 4b</ref>). Candidates generated in this way have to satisfy only one additional condition, as opposed to two in the straightforward approach. To avoid counting the same graphlet multiple times, we request that x 2 5x 3 5x 4 under some fixed arbitrary ordering of nodes. Although the theoretical time complexity for finding all G 8 that touch x using this algorithm is the same for both approaches, Oðd 3 Þ, the latter is much faster on sparse graphs. This method can be generalized for efficient counting of larger complete graphlets in sparse graphs. In every step, we maintain a list of candidate nodes C i for x i that are adjacent to all previously added nodes. We select one of these candidates and form a new candidate set C iþ1 consisting only of nodes in C i that are adjacent to the selected node,</p><formula>C iþ1 ¼ C i \ Nðx i Þ and C 1 ¼ V.</formula><p>The time complexity of finding all complete k-node graphlets that touch x using this algorithm is Oðd kÀ1 Þ. Later in the text, we use such procedure to enumerate complete subgraphs on five nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Orbits on five-node graphlets</head><p>For counting four-node graphlets, we constructed a list of equations by adding nodes to three-node graphlets and observing the resulting fournode graphlets. Extending the four-node graphlets to five-node graphlets would yield a huge number of equations that are not linearly independent. We will use a different approach: for each orbit, we choose some node y from the corresponding graphlet and observe the graphlets and orbits in which the node of interest, x, appears if we add edges between y and other nodes in the graphlet. Let x be the node of interest, let y be the node whose edges we observe and let x 1 , x 2 and x 3 be the other three nodes in that graphlet.<ref type="figure" target="#fig_5">Figure 5</ref>illustrates counting of appearances of x in O 59 , which belongs to G 24 (<ref type="figure" target="#fig_5">Fig. 5a</ref>). We will focus on the node marked by y, which is connected to the nodes marked by x 1 and x 3. Removing y reduces G 24 into a diamond, G 7 , with x in orbit O 12. Now assume that we are computing orbits for a certain node x and discover some induced subgraph H ffi G 7 with x in O 12. We assign labels x 1 , x 2 and x 3 to the remaining nodes as shown in the figure. Altogether, the graph G contains cðx 1 , x 3 Þ common neighbours of x 1 and x 3 (similar to nodes marked with w in<ref type="figure" target="#fig_4">Fig. 3a</ref>). Although all these nodes are—by definition of cðx 1 , x 3 Þ—connected to x 1 and x 3 , some are also connected to x 2 or x, or both.<ref type="figure" target="#fig_5">Figure 5</ref>shows all four possibilities, which give graphlets G 24 , G 26 , G 27 and G 28 with x in orbits 59, 65, 68 and 70, respectively. Therefore,</p><formula>o 0 59 þ o 0 65 þ o 0 68 þ o 0 70 ¼ cðx 1 , x 3 Þ À 1,</formula><formula>cðx 1 , x 3 Þ þ cðx 2 , x 3 Þ À 2</formula><p>Condition x 1 5x 2 (under some arbitrary ordering of nodes) is needed to consider each graphlet G 7 just once. The other two conditions put x in O 12. The second term in the sum, cðx 2 , x 3 Þ, accounts for the case in which the roles of x 1 and x 2 are exchanged. Using a similar construction for other orbits, except for O 72 , gives 57 linear equations for 58 orbits (see the Supplementary Material). Like for four-node graphlets, we directly enumerate the orbit O 72 , which belongs to the complete graphlet. Equations are linearly independent due to the way in which they were constructed: each equation is set up with one orbit in mind (e.g. O 59 in the aforementioned example), and the other orbits that appear in the equation belong to graphlets with a larger number of edges (the additional edges between y and the other nodes, like the dotted edges in<ref type="figure" target="#fig_5">Fig. 5b</ref>–d). Additional nice consequence besides independence is that the system is easy to solve, as orbit counts can be computed from those belonging to graphlets with more edges towards those with less. When constructing the equations, we choose y that allows for efficient computation of the right sides: we will ensure that the right sides contain only the node degrees and the numbers of common neighbours of pairs and of connected triplets<ref type="bibr">[cðu, vÞ, cðu, v, tÞ]</ref>. This will allow us to precompute and store the values of cðu, vÞ and cðu, v, tÞ for all pairs and connected triplets in G before computing the orbit counts for individual nodes. First, we choose the node y so that the remaining nodes constitute a four-node graphlet, i.e. removing y does not break the graphlet into disconnected components, which would require enumeration of disconnected subgraphs. Second, the node y has to have at most three connections to avoid the need to compute the number of common<ref type="figure">4</ref>. Enumerating G 8 by adding one neighbour at a time or by checking pairs of neighbours. Dashed edges are added by iterating through neighbours, and dotted edges are checked in the last step neighbours of four points, cðu, v, w, tÞ. Besides, when y has three neighbours, they need to be connected. A node y that fulfils these criteria exists for all orbits except O 72. Precomputing the values cðu, v, tÞ for all connected triplets takes Oðe Á d 2 Þ time, and storing them in a hash table takes Oðe Á dÞ space. Computation of the right sides also requires enumerating all the fournodes graphlets, which again has a complexity of Oðe Á d 2 Þ. The total time required to compute all orbit counts for all x 2 V is then Oðe Á d 2 þ T 5 Þ with Oðe Á dÞ space, where OðT 5 Þ is the time required to enumerate all complete five-node graphlets (G 29 ). The algorithm thus has the same upper bound complexity as the existing algorithms, Oðn Á d 4 Þ. However, experiments show that the bound is not tight: the contribution of the OðT 5 Þ is negligible over the range of sensible graph densities, and the actual running times are smaller by an order of magnitude. We could use the same technique to construct systems of equations for larger graphlets. However, we reduced the running times by imposing some conditions to the selection of the node y. We have not researched whether such nodes also exist for larger graphlets; although theoretically interesting, this may be of little practical use in the context of bioinformatics.</p><formula>(a) ( b) ( c)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS AND DISCUSSION</head><p>We compared the speed of Orca with RAGE, GraphCrunch and FANMOD. We ran all experiments on a modest desktop computer (Intel Core 2, 2.67 GHz). We have not experimented with parallel execution; all four algorithms allow for trivial distribution of work on multiple cores, so the benefits of parallelization should be the same for all. We compared the performance of methods on the three largest species-specific PPI networks from the July 2013 update of the Database of Interacting Proteins (<ref type="bibr" target="#b19">Salwinski et al., 2004</ref>) and the human PPI network from the BioGRID (<ref type="bibr" target="#b1">Chatr-Aryamontri et al., 2013</ref>) 3.2.104 release. The sizes of individual datasets are presented in<ref type="figure" target="#tab_1">Table 1</ref>. All algorithms except the significantly slower FANMOD counted orbits for four-node graphlets in the smaller graphs in a few seconds (<ref type="figure" target="#tab_2">Table 2</ref>). Five-node graphlets present a more difficult task: running GraphCrunch on the S.cerevisiae PPI network took 49 min (as compared with 4.4 s for four-node graphlets). FANMOD was almost 10 times slower, whereas Orca finished the same task 80 times faster, in 6.6 s. RAGE is limited to four-node graphlets. We got similar results for the other two networks. In the larger human network, Orca counted the four-node graphlets 100 and 1800 times faster than Rage and GraphCrunch, respectively; we aborted FANMOD after 24 h. Orca was also the only algorithm capable of counting fivenode graphlets in a human PPI network in less than a day. For comparison with RAGE, we included a test network of Internet autonomous systems (http://www.netdimes.org/ PublicData/csv/ASEdges4_2012.csv.gz) that was used as the benchmark for RAGE (<ref type="bibr" target="#b9">Marcus and Shavitt, 2012</ref>). FANMOD required49 h, GraphCrunch finished in 37 min, RAGE in 3 min and Orca in 2.5 s. Orca finished the computation for five-node graphlets in 49 min, whereas the other two algorithms were stopped after 24 h. The time that Orca needs for counting orbits in five-node graphlets is comparable with those that GraphCrunch needs for four-node graphlets. This is consistent with the way the two algorithms are constructed: GraphCrunch enumerates four-node graphlets to count them, whereas Orca enumerates them to count five-node graphlets. As expected, the time needed for enumeration of complete five-node graphlets is negligible at these network densities. For more insight into time complexities of the compared algorithms, we tested them on synthetic data using three different random network models—Erdo 00 s–Re´nyiRe´nyi, geometric and Baraba´siBaraba´si–Albert, random graphs. Erdo 00 s–Re´nyiRe´nyi graphs are constructed by randomly connecting e pairs of nodes. We generated geometric graphs by randomly placing nodes in a 3D unit cube and connecting the e closest pairs; geometric graphs show largest resemblance to protein interaction networks (<ref type="bibr" target="#b17">PrzˇuljPrzˇulj et al., 2004</ref>). Baraba´siBaraba´si–Albert preferential attachment model generates scalefree networks that exhibit hubs and individual highly connected nodes.We explored the performance of GraphCrunch, RAGE and Orca at different network densities. FANMOD was not included as it consistently finished previous tests far behind GraphCrunch. All graphs had 1000 nodes; for each method, we increased the graph density until the method needed more than a minute to complete the test. The corresponding graphs were relatively dense, containing up to 40% of all possible edges for test with four-node graphlets and $10% for five-node graphlets. RAGE counted the four-node graphlets slightly faster than GraphCrunch, but they were both significantly outperformed by Orca (<ref type="figure">Fig. 6</ref>and Supplementary Tables S1–S6). We observed similar results when counting five-node graphlets (<ref type="figure" target="#fig_9">Fig. 7</ref>). Orca achieved the highest gain in comparison with other methods on Baraba´siBaraba´si–Albert models, in which hubs present a large obstacle for GraphCrunch and RAGE. This makes Orca more suitable for real-world networks, which often display the small-world property and contain hubs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONCLUSION</head><p>Graphlet-based network analysis is useful for various tasks in bioinformatics, such as alignment of PPI networks and prediction of protein functions based on topological similarities. Past studies used these approaches to, for instance, identify genes related to cancer (<ref type="bibr">Milenkovicét al., 2010b</ref>) and aging (<ref type="bibr">Milenkovicét al., 2013</ref>). We presented a new algorithm for counting graphlet orbits that is based on derived relations between orbit counts. To count the orbits for k-node graphlets, it enumerates ðk À 1Þnode graphlets and a single k-node graphlet. Empirical results confirm that this decreases the time complexity by an order of magnitude in comparison with other known methods. In practical terms, the algorithm counts orbits in large PPI networks 50–100 times faster than other state-of-the-art algorithms.<ref type="figure">6</ref>. Comparison of times needed for counting orbits in four-node graphlets in random networks. Graphs are cut off at one minute; results of experiments in which the methods were allowed to run for up to 1 h are available in the Supplementary Material</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Graphlets with 2–5 nodes and automorphism orbits. Notation follows (PrzˇuljPrzˇulj, 2007). Colors are chosen arbitrarily; nodes of the same color belong to the same orbit within that graphlet, e.g. both black nodes in G 14 belong to orbit 31</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Relation between orbits O 9 and O 12. Solid lines are edges in the three-node graphlet being extended. Dashed lines exist by definition: w (or w i ) are the common neighbours of y and z. Dotted lines are optional edges that make the resulting four-node graphlet on x, y, z and w i isomorphic to G 6 or G 7</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>where o 0 i denote orbits of x with respect to H. For the relation between o 59 , o 65 , o 68 and o 70 for the entire graph, we sum this over all possible induced G 7 with x in O 12. After considering the symmetries that cause counting the same graphlet multiple times with different assignments of y, x 1 , x 2 and x 3 , we get o 59 þ 4o 65 þ 2o 68 þ 6o 70 ¼ X x1, x2, x3: x15x2^x3= 2NðxÞ, G½fx, x1, x2, x3gffiG7</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.3.</head><figDesc>Fig. 3. Relation between orbits O 6 and O 9. Edges are marked like in Figure 2 (a) ( b) ( c) ( d)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.5.</head><figDesc>Fig. 5. Computing orbit count o 59 ; figures show graphlets for different edges between y and other nodes and the orbits of x</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.</head><figDesc>Fig. 4. Enumerating G 8 by adding one neighbour at a time or by checking pairs of neighbours. Dashed edges are added by iterating through neighbours, and dotted edges are checked in the last step</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>Funding: Slovenian Research Agency (P2-0209, J2-5480). Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.</head><figDesc>Fig. 6. Comparison of times needed for counting orbits in four-node graphlets in random networks. Graphs are cut off at one minute; results of experiments in which the methods were allowed to run for up to 1 h are available in the Supplementary Material</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig.7.</head><figDesc>Fig. 7. Comparison of times needed for counting orbits in five-node graphlets in random networks</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>used graphlet distributions to show that *To whom correspondence should be addressed. ß The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com geometric graphs match the structure of PPI networks better than Erdo 00 s–Re´nyiRe´nyi and scale-free graph models. Using a number of large PPI networks, Hayes et al. (2013) further</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 2. Comparison of algorithms on real-world networks</figDesc><table>Network 
Four-node graphlets 
Five-node graphlets 

FANMOD 
GraphCrunch 
RAGE 
Orca 
FANMOD 
GraphCrunch 
Orca 

S.cerevisiae 
62 s 
4.4 s 
1.7 s 
50.1 s 
87 min 
9.5 min 
6.6 s 
E.coli 
34 s 
1.8 s 
1.0 s 
50.1 s 
38 min 
4.1 min 
4.8 s 
D.melanogaster 
21 s 
3.1 s 
1.6 s 
50.1 s 
18 min 
2.8 min 
2.3 s 
Human 
/ 
183 min 
11.8 min 
6.1 s 
/ 
/ 
269 min 
Internet autonomous systems 
574 min 
37 min 
3.0 min 
2.5 s 
/ 
/ 
49 min 

Note: We aborted the algorithms that took more than a day and marked the corresponding results with /. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 1.</figDesc><table>Statistics of benchmark real-world networks 

Network 
Nodes 
Edges 
Maximum 
degree 

S.cerevisiae 
5097 
22 282 
289 
Escherichia coli 
2984 
11 626 
178 
D.melanogaster 
7618 
22 864 
178 
Human 
18 170 
1 37 775 
9716 
Internet autonomous systems 
25 368 
75 004 
3781 </table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">T.Hoč evar and J.Demš ar at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Graphlet counting at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">A framework for FPGA acceleration of large graph problems: graphlet counting case study</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Betkaoui</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2011 International Conference on FieldProgrammable Technology. IEEE</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">The BioGRID interaction database: 2013 update</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Chatr-Aryamontri</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="816" to="823" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Graphlet-based measures are suitable for biological network comparison</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Hayes</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="483" to="491" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Efficient sampling algorithm for estimating subgraph concentrations and detecting network motifs</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Kashtan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="1746" to="1758" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Finding and counting small induced subgraphs efficiently</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Kloks</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="page" from="115" to="121" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Counting and detecting small subgraphs via equations and matrix multiplication</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Kowaluk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Second Annual ACMSIAM Symposium on Discrete Algorithms</title>
		<meeting>the Twenty-Second Annual ACMSIAM Symposium on Discrete Algorithms</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1468" to="1476" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Integrative network alignment reveals large regions of global network similarity in yeast and human</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Kuchaiev</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Przˇuljprzˇulj</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1390" to="1396" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Topological network alignment uncovers biological function and phylogeny</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Kuchaiev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. R. Soc. Interface</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="1341" to="1354" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">GraphCrunch 2: software tool for network modeling, alignment and clustering</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Kuchaiev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">24</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">RAGE-a rapid graphlet enumerator for large networks</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Marcus</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Shavitt</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Netw</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="page" from="810" to="819" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Uncovering biological network function via graphlet degree signatures</title>
		<author>
			<persName>
				<forename type="first">Milenkovic´</forename>
				<surname>Milenkovic´</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Przˇuljprzˇulj</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cancer Inform</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="257" to="273" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">GraphCrunch: a tool for large network analyses</title>
		<author>
			<persName>
				<forename type="first">Milenkovic´</forename>
				<surname>Milenkovic´</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">70</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Optimal network alignment with graphlet degree vectors</title>
		<author>
			<persName>
				<forename type="first">Milenkovic´</forename>
				<surname>Milenkovic´</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Cancer Inform</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="121" to="137" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Systems-level cancer gene identification from protein interaction network topology applied to melanogenesis-related functional genomics data</title>
		<author>
			<persName>
				<forename type="first">Milenkovic´</forename>
				<surname>Milenkovic´</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. R. Soc</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="423" to="437" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Dominating biological networks</title>
		<author>
			<persName>
				<forename type="first">Milenkovic´</forename>
				<surname>Milenkovic´</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">23016</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Global network alignment in the context of aging</title>
		<author>
			<persName>
				<forename type="first">Milenkovic´</forename>
				<surname>Milenkovic´</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Conference on Bioinformatics, Computational Biology and Biomedical Informatics</title>
		<meeting>the International Conference on Bioinformatics, Computational Biology and Biomedical Informatics</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="23" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Biological network comparison using graphlet degree distribution</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Przˇuljprzˇulj</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="177" to="183" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Modeling interactome: scale-free or geometric?</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Przˇuljprzˇulj</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="3508" to="3515" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Efficient estimation of graphlet frequency distributions in protein-protein interaction networks</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Przˇuljprzˇulj</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="974" to="980" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">The database of interacting proteins: 2004 update</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Salwinski</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="449" to="451" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Graphlet-based edge clustering reveals pathogen-interacting proteins</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">W</forename>
				<surname>Solava</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="480" to="486" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Structure of neighborhoods in a large social network</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Stoica</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Prieur</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2009 International Conference on Computational Science and Engineering. IEEE</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="26" to="33" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Efficient detection of network motifs</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Wernicke</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="347" to="359" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">FANMOD: a tool for fast network motif detection</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Wernicke</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Rasche</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1152" to="1153" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Computing graphlet signatures of network nodes and motifs in Cytoscape with GraphletCounter</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Whelan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>So¨nmezso¨nmez</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="290" to="291" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>