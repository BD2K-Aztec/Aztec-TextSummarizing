
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:34+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">RazerS 3: Faster, fully sensitive read mapping</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">20 2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">David</forename>
								<surname>Weese</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Freie Universitä t Berlin</orgName>
								<address>
									<addrLine>Takustr. 9</addrLine>
									<postCode>14195</postCode>
									<settlement>Berlin</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Manuel</forename>
								<surname>Holtgrewe</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Freie Universitä t Berlin</orgName>
								<address>
									<addrLine>Takustr. 9</addrLine>
									<postCode>14195</postCode>
									<settlement>Berlin</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Knut</forename>
								<surname>Reinert</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Computer Science</orgName>
								<orgName type="institution">Freie Universitä t Berlin</orgName>
								<address>
									<addrLine>Takustr. 9</addrLine>
									<postCode>14195</postCode>
									<settlement>Berlin</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">RazerS 3: Faster, fully sensitive read mapping</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="page" from="2592" to="2599"/>
							<date type="published" when="2012">20 2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts505</idno>
					<note type="submission">Sequence analysis Advance Access publication August 24, 2012 Received on March 3, 2012; revised on August 6, 2012; accepted on August 9, 2012</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Associate Editor: Michael Brudno Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: During the past years, next-generation sequencing has become a key technology for many applications in the biomedical sciences. Throughput continues to increase and new protocols provide longer reads than currently available. In almost all applications, read mapping is a first step. Hence, it is crucial to have algorithms and implementations that perform fast, with high sensitivity, and are able to deal with long reads and a large absolute number of insertions and deletions. Results: RazerS is a read mapping program with adjustable sensitivity based on counting q-grams. In this work, we propose the successor RazerS 3, which now supports shared-memory parallelism, an additional seed-based filter with adjustable sensitivity, a much faster, banded version of the Myers&apos; bit-vector algorithm for verification, memory-saving measures and support for the SAM output format. This leads to a much improved performance for mapping reads, in particular, long reads with many errors. We extensively compare RazerS 3 with other popular read mappers and show that its results are often superior to them in terms of sensitivity while exhibiting practical and often competitive run times. In addition, RazerS 3 works without a pre-computed index. Availability and Implementation: Source code and binaries are freely available for download at http://www.seqan.de/projects/razers. RazerS 3 is implemented in Cþþ and OpenMP under a GPL license using the SeqAn library and supports Linux, Mac OS X and Windows.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Next-generation sequencing allows researches to produce billions of base pairs (bp) within days in the form of reads of length 100 bp and more. It has become an invaluable technology for a multitude of applications, e.g. the detection of single-nucleotide polymorphisms (SNPs) and large structural genome variations, targeted or de novo genome or transcriptome assembly, isoform prediction and quantification, identification of transcription factor binding sites or methylation patterns. In many of these applications, mapping sequenced reads to their potential genomic origin is the first fundamental step for subsequent analyses. A variety of tools have been designed specifically for the purpose of mapping short reads. In a recent publication,<ref type="bibr" target="#b15">Li and Homer (2010)</ref>give a survey and categorize the existing tools into approaches using a q-gram index for a seed-and-extend strategy (e.g.<ref type="bibr" target="#b0">Ahmadi et al., 2011;</ref><ref type="bibr" target="#b1">Alkan et al., 2009;</ref><ref type="bibr" target="#b3">Bauer et al., 2010;</ref><ref type="bibr" target="#b4">David et al., 2011;</ref><ref type="bibr" target="#b21">Weese et al., 2009</ref>) or recursively descending a suffix tree (<ref type="bibr" target="#b8">Hoffmann et al., 2009</ref>) or prefix tree (<ref type="bibr" target="#b13">Langmead et al., 2009;</ref><ref type="bibr" target="#b12">Langmead and Salzberg, 2012;</ref><ref type="bibr" target="#b14">Li et al., 2009;</ref><ref type="bibr" target="#b14">Li and Durbin, 2009</ref>) of the reference genome. Recursive approaches are usually designed for the fast search of one or a few locations where reads map with low error rates. These search algorithms are mostly based on heuristics and optimized for speed instead of enumerating all possible locations. Conversely, approaches based on the seed-and-extend strategy allow such an (often approximate) enumeration. The first class of approaches aims at directly finding the 'best' location for mapping a read (best-mappers), whereas the second class aims at enumerating a comprehensive set of locations (all-mappers). RazerS (<ref type="bibr" target="#b21">Weese et al., 2009</ref>) is an all-mapper that uses q-gram counting for read mapping with controllable sensitivity. This means it can guarantee to find all locations a read maps to in a reference sequence. At the same time, it works with practicable performance. Since the original publication in 2009, sequencing technology has advanced to produce longer reads. The increasing length leads to a larger absolute number of errors to be considered, a problem that is aggravated by new technologies that have a higher error rate (e.g. PacBio). Older read mappers have difficulties mapping long reads with high number of errors with a high sensitivity. In this article, we address this problem and propose a new read mapper RazerS 3, which is able to map reads of arbitrary length with a large number of insertions and deletion (indel) errors. Our novel contributions are as follows: (1) The use of OpenMP to provide a shared-memory parallelization with dynamic load balancing. (2) In addition to the q-gram counting filter used in RazerS, we implemented a pigeonhole-based filter with controllable sensitivity, since it proved to be superior for low error rates. (3) An implementation of a banded version of Myers' bit-vector algorithm, which we use for the verification, similar to Hyyro¨( Hyyro¨(2003), which is up to four times faster than the previous, unbanded version. These algorithmic improvements lead to a running time that is an order of magnitude faster than RazerS while keeping the guarantee for full sensitivity. Various extensive benchmarks show higher sensitivity when compared with other approaches, especially best-mappers. Furthermore, the running time is superior to the considered all-mappers and competitive or superior to best-mappers on medium-sized genomes. On large genomes, the running time is still practical and only about three times slower than that of BWA while being more sensitive. RazerS 3 does not rely on a pre-computed index like the tree-based tools and is in this respect more flexible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>The RazerS algorithm consists of a filtration and a verification part. In the filtration part, the genome is scanned for regions that possibly contain read matches. The results from the filtration are then subjected to a verification algorithm. Formally, we consider the read mapping problem: the input is a reference sequence S, a set of reads R, a distance function and a maximal distance k. The solution of the problem is the set of all locations (matches) in S where the read r is found with distance k under for each read r. Common distance measures are Hamming and edit distance. The Hamming distance counts the minimal number of replacements, whereas the edit distance allows indels. Under edit distance, matches can be ambiguous. The authors explained how to treat such ambiguities and how to derive a gold standard benchmark for read mapping in<ref type="bibr" target="#b10">Holtgrewe et al. (2011)</ref>. This is summarized in Section 2.3. RazerS 3 supports both Hamming and edit distance read mapping.</p><p>Both modes can be run with full or user-definable sensitivity on multiple CPU cores, which allows for time-sensitivity trade-off.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Filtration</head><p>To make RazerS 3 applicable to a broad spectrum of use cases, we implemented two fast filtration algorithms, which differ in filtration specificity and processing speed. In Section 3.1, we analyze which filter performs best under different typical read mapping scenarios. The first filter, based on the SWIFT algorithm, was already used in RazerS and is hence only shortly described here. It is still operational in RazerS 3 since it is superior to the second filter for high error rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">SWIFT</head><p>The first filter is a modified SWIFT algorithm (<ref type="bibr" target="#b19">Rasmussen et al., 2006</ref>), which divides the dot plot between genome and reads into overlapping parallelograms. In a linear scan over the reference sequence, the number of common exact q-grams between read and the reference subsequence is counted for each parallelogram. Parallelograms that contain a sufficient number of common exact qgrams are considered as candidate regions of semi-global alignments between reads and reference sequences with a tolerated number of errors. For more details, we refer the reader to<ref type="bibr" target="#b21">Weese et al. (2009)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Pigeonhole principle</head><p>The second filter is new and is based on the pigeonhole principle which states that if a read is cut into k þ 1 pieces, then in every approximate match of the read with at most k errors occurs at least one piece without error (Baeza<ref type="bibr" target="#b2">Yates and Navarro, 1999</ref>). If all reads have the same length m, they are cut into "m þ 1 b cpieces of length q ¼ Ä m= "m þ 1 b c Å , where " is the tolerated error rate. For reads of arbitrary length, the minimal q is chosen to build a q-gram index over the pieces of the reads. These pieces are then searched in a linear scan of the reference sequence. For every exact match, the dot plot parallelogram, consisting of the diagonals that are at most k diagonals apart of the matching piece, is considered as a candidate region for a match within the tolerated edit distance. In Hamming distance mode, only the diagonals that cover matching pieces are considered as candidate regions. The candidate parallelograms of all matching pieces are recorded and verified in the subsequent verification step. Compared with the SWIFT filter, this filter requires less processing time and, due to non-overlapping seeds, less indexed q-grams at the expense of less filtration specificity and more verifications (more results can be found in Supplementary Table S1).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Lossy filtration and prediction of sensitivity</head><p>Both filters are fully sensitive if parameterized as described above, i.e. every occurrence of a read within the tolerated edit or Hamming distance will be detected as a candidate region and positively verified in the verification step. In our previous work, the use of a lossy filter could improve the overall running time by an order of magnitude while still detecting 99% of all matches (see<ref type="bibr" target="#b21">Weese et al., 2009</ref>). Our approach is based on given positional error probabilities p i , i.e. the probability that in a randomly chosen true match of any read there is an error at position i. As errors we consider base miscalls and mutations, and before mapping compute the error profile p i based on base-call quality values and a user-specific mutation rate. Given the error profile and specific filtration parameters, we propose how to estimate the probability to miss a random match and vice versa how to choose more efficient filtration parameters that guarantee a specific minimal sensitivity. We sketch the procedure shortly for the SWIFT filter and then elaborate the method for the pigeonhole filter.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Predicting SWIFT sensitivity</head><p>The SWIFT filter has two parameters, the q-gram shape Q and the threshold t. The shape is a set of relative positions of the q considered characters. For example, ##-# corresponds to a 3-gram with shape Q ¼ {0, 1, 3} and the two 3-grams with shape Q in the string GTTCA are GTC and TTA. Of all overlapping q-grams with shape Q contained in a read, the threshold t is the minimal number of q-grams occurring without error in the reference a candidate region must have. By increasing q or t, the number of candidate regions and also the overall running time can be reduced at the expense of filtration sensitivity. To decide whether an arbitrary Hamming distance match is detected as a candidate region, it suffices to consider the positions of replacements between read and reference instead of whole sequences and count the number of q-grams without a replacement. Assuming the independence of errors, the occurrence probability of this match can be computed by the given positional error probabilities. In<ref type="bibr" target="#b21">Weese et al. (2009)</ref>, we devised an algorithm to efficiently compute the sensitivity using dynamic programming instead of exhaustive search for both Hamming and edit distance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Predicting pigeonhole sensitivity</head><p>A lossless pigeonhole filter divides a read into at least k þ 1 fragments and uses them as seeds to detect all k-error matches. As fragments we use the first k þ 1 non-overlapping read q-grams where q is chosen as large as possible. In expectation, every read q-gram has n=4 q occurrences in a genome of length n. To reduce the number of random candidates and to reduce the overall running time, we increase q and allow the seeds to overlap. However, with overlapping seeds, some of the mismatch patterns will be missed by the filter, e.g. if every odd seed overlap contains an error. With a ðq, ÁÞ-seed filter, we denote a filter that uses all q-grams starting at multiples of Á in the read as seeds, with q=2 Á q, such that adjacent q-grams overlap by q À Á characters. To compute the sensitivity of such a filter, we consider mismatch patterns between a read of length m and all of its true matches. (A mismatch pattern is a binary string, with 0's at matching and 1's at mismatching positions.) The sensitivity for matches with e ¼ 0, 1,. .. , k errors is the sum of occurrence probabilities of e-error mismatch patterns that are detected by the filter divided by the probability that an e-error mismatch patterns occurs. Instead of enumerating all possible e-error mismatch patterns, we devised a DP (dynamic programming) algorithm that virtually split the mismatch pattern into segments at q-gram boundaries Á, q, 2Á, Á þ q,. .. , ðk þ 1ÞÁ, kÁ þ q and denote the first 2(k þ 1) segments from left to right as x 0 , y 0 , x 1 , y 1. .. , x k , y k (see<ref type="figure">Fig. 1</ref>). Our approach is analogously applicable to edit distance as insertions or deletions behave like mismatches in relation to destroyed seeds.</p><p>The probability PðjjM½i::jÞ jj 1 ¼ eÞ that a random mismatch pattern M contains e errors in a segment from position i to j À 1 can be computed as follows using positional error probabilities p i :</p><p>PðjjM½i::iÞ jj 1 ¼ eÞ ¼ 1, if e ¼ 0 0, else:</p><formula>&amp; PðjjM½i::i þ 1Þ jj 1 ¼ eÞ ¼ 1 À p i , if e ¼ 0 p i , i fe ¼ 1 0, else: 8 &gt; &lt; &gt; :</formula><p>PðjjM½i::jÞ jj 1 ¼ eÞ ¼ ð1 À p jÀ1 Þ Á P jjM½i::j À 1Þjj 1 ¼ e þ p jÀ1 Á P jjM½i::j À 1Þjj 1 ¼ e À 1 :</p><p>We define L(i, e, y) to be the probability of the event that the first i þ 1 seeds contain overall e errors, each at least one error, and y i contains y errors. Let X i and Y i be random variables for the number of errors in the segments x i and y i , then L can recursively be computed as follows:</p><formula>Lð0, e, yÞ ¼ 0, for e ¼ 0 PðX 0 ¼ e À yÞ Á P ðY 0 ¼ yÞ, else: &amp; Lði, e, yÞ ¼ X e s¼1 X sÀy y 0 ¼0 Lði À 1, e À sþ y 0 , y 0 Þ Á P ðX i ¼ s À y À y 0 ÞÁ PðY i ¼ yÞ :</formula><p>The probability that all seeds are destroyed with overall e errors is</p><formula>L all ðeÞ ¼ X e y¼0 X e x¼0</formula><p>Lðk, e À x, yÞ Á PðjjM½kÁ þ q::nÞjj 1 ¼ xÞ, and consequently the sensitivity of the ðq, ÁÞ-seed filter for matches with at most k errors is</p><formula>Sðq, Á, kÞ ¼ 1 À X k e¼0 L all ðeÞ PðjjMjj 1 ¼ eÞ :</formula><p>Before starting the mapping, RazerS 3 estimates the sensitivities of different filter settings and maximizes the seed length q as it has the greatest influence on the overall running time. Beginning with the lossless setting q ¼ Á ¼ m=ðk þ 1Þ Ä Å , it step-wise increases q as long as the estimated sensitivity is higher than required, q does not exceed the maximal seed length of 31 and not more than two seeds overlap (q 2Á). The corresponding step sizes Á ¼ ðm À qÞ=k Ä Å are chosen such that each read contains k þ 1 overlapping seeds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Verification</head><p>The result of the above described filtration part is a set of candidate regions and reads potentially matching there. A candidate region is a parallelogram in the dot plot that might contain the alignment trace of a match and hence has to be verified by the verification part explained in the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Hamming distance verification</head><p>In Hamming mode, a match covers solely one dot plot diagonal. Hence, the candidate parallelogram can be verified by scanning each diagonal while counting the number of mismatches between read and reference sequence. A diagonal can be skipped as soon as the counter exceeds the number of tolerated errors. Otherwise, a match has been found.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Edit distance verification</head><p>For edit distance verification, we implemented a banded version of Myers (1999) bit-vector algorithm as it was proposed in Hyyrö (2003) with small adaptions. The original algorithm by Myers can be used to search a read with at most k edit errors in the reference sequence. The underlying idea is the same as in<ref type="bibr" target="#b18">Needleman and Wunsch (1970)</ref>but the implementation is much more efficient as it encodes a whole DP column in two bit-vectors and computes the adjacent column in a constant number of 12 logical and 3 arithmetical operations. For reads up to length 64 bp, CPU registers can be used directly. For longer reads, bit-vectors and operations must be emulated using multiple words where only words affecting a possible match needs to be updated (<ref type="bibr" target="#b20">Ukkonen, 1985</ref>). However, the additional processing overhead results in a performance drop for reads of length 65 bp and longer. The variant proposed by Hyyro¨computesHyyro¨computes a banded semi-global alignment between read and reference, i.e. it only computes DP cells that are covered by a parallelogram. Hence, only the columns of the parallelogram need to be encoded by bit-vectors which makes it applicable to parallelograms of width up to 63 without the need for bit-vector emulation. However, the banded variant proposed in Hyyro¨(Hyyro¨(2003) requires bitmasks consisting of multiple words for each read as preprocessing information. We implemented a banded variant of Myers' algorithm that requires no preprocessing information at all as we update the five single-word bitmasks (we consider the alphabet AE ¼ {A, C, G, T, N}) during each verification. This strategy is faster than that of Hyyroänd saves memory. Further improvements like the support of clipped parallelograms are explained in Supplementary Section S1. In contrast to Hamming distance verification, where the difference between begin and end position of every match equals the read length, Myers' algorithm outputs only the end of a match. More precisely, it determines the minimal number of errors for a fixed end position and a free begin position. To determine a corresponding begin position, we search the read backwards with a fixed end position. As edit distance scores mismatches and indels equally, there can be multiple best match beginnings. We choose the largest best match to optionally shrink it later using an alignment algorithm for affine gap costs (<ref type="bibr" target="#b7">Gotoh, 1982</ref>) where we penalize gaps slightly more than mismatches and penalize an opened gap more than an extended a gap. More implementation details of our banded variant of Myers' algorithm can be found in Supplementary Section S1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">Island criterion Another improvement in RazerS 3 addresses</head><p>the problem of defining the term match for read mapping. This is discussed in detail by<ref type="bibr" target="#b10">Holtgrewe et al. (2011)</ref>when defining the Rabema benchmark. We will give a summary of this here. Read alignments under edit distance can be ambiguous if more than one error is allowed. Say, for example, a read aligns perfectly except for the first base where we observe a mismatch. Let the beginning of the read be ACT. .. and align with the genome stretch. .. ACCT. .. . Then, there may be two optimal alignments where the read starts with either ACT. .. or A-CT.. .. Such and other ambiguities lead to possibly several local minima (in terms of edit distance) around a match. The model for matches defined in<ref type="bibr" target="#b10">Holtgrewe et al. (2011)</ref>describes a relaxation of the naive requirement to enumerate all edit distance alignments. RazerS 3 uses this model and writes out at least one result record for each Rabema match.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.">Parallelization</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1">Match management</head><p>The overlapping parallelograms of the SWIFT filter or the multiple seeds the pigeonhole filter may find in a<ref type="figure">Fig. 1</ref>. A ðq, ÁÞ-seed filter, with q ¼ 8 and Á ¼ 6, for searching matches with up to k ¼ 3 errors (seed i consists of segments y iÀ1 , x i and y i , except for i ¼ 0) single match result in multiple identical or nearly identical matches found in the verification step. To filter these duplicates, we regularly search for matches of the same read that have an identical begin or end position and keep only those with a minimal number of errors. In addition, we use a heuristic in the pigeonhole filter, that for multiple seeds on the same diagonal only one candidate region is generated. If the user specifies a maximal number M of matches per read, we sort all matches ascendingly by the number of errors and remove all but the first M matches of each read. For a read, the number of errors e in the M-th match is used to dynamically adjust the filter and verifier in order to search only for matches with less than e errors. If e equals 0, the read can be disabled completely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2">Processing in window and batches</head><p>RazerS 3 collects all candidates from windows of a configured size (default: 500 kb). The resulting candidates are split into work packages of a configured size (default: 100) or a larger size if a configured number of packages is exceeded for a window (default: 100 packages). Each package is then verified by a single thread. Thus, the filtration is performed in a window-based fashion and verification is performed in batches. Locks for shared data structures only have to be obtained once for each window or batch. This way, lock contention and overhead are kept small while still allowing for finegranular load balancing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.3">Load balancing scheme We implemented a mixture of static</head><p>and dynamic load balancing: for filtration, reads are statically assigned to threads in subsets of equal size. Each thread has a filter for its owned reads as well as a verifier, shown as large green/blue rectangles in<ref type="figure" target="#fig_1">Figure 2</ref>. Filtration results (green squares) are written to a global work queue. After thread T i completes the filtration in its current window, it takes candidate packages from the global queue until empty and verifies it. Thus, the verification work is distributed over threads and dynamically load balanced. Each thread has a queue for each other thread and itself (labeled with the thread id) acting as a post box. Thread T i then writes the verification results (blue square) to the post box for the owner of its current work package. It then writes the longest consecutive stretch of globally available verification results addressed to itself back into its local result container. (The arrays of matches are subdivided into work packages, of which each has an index. A consecutive sequence of packages is a sequence of packages whose indices are consecutive.) Matches are masked when written back. At the end of the program run, each thread performs a global compaction step on its result. A detailed analysis of influence of the chosen filter on load balancing is given in Supplementary Section S2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.4">Further improvements Another optimization in RazerS 3</head><p>is a reduction of running time of the masking step by conducting local sorting instead of global sorting. As a memory optimization, each filter uses an open addressing q-gram index whose memory footprint is linear in the number of stored q-grams (see Supplementary Sections S3 and S4 for details).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">EXPERIMENTAL RESULTS</head><p>We compared RazerS 3 with the best-mappers Bowtie 2, BWA and Soap 2 as well as the all-mappers Hobbes, mrFAST and SHRiMP 2. For running time comparison, we ran the tools with 12 threads and used local disks for I/O. We used default parameters, except where stated otherwise. Read mappers that accept a maximal number of errors (mrFAST, Hobbes and Soap 2) were configured with the same error rate as RazerS 3. For a fair comparison with best-mappers, we configured RazerS 3 in a second variant to also output one best match per read. The exact parameterization is described in Supplementary Section S6. All read sets are given by their SRA/ENA id. As references we used whole genomes of Escherichia coli (NCBI NC_000913.2), Caenorhabditis elegans (WormBase WS195), Drosophila melanogaster (FlyBase release 5.42) and human (GRCh37.p2). The mapping times were measured on a cluster of nodes with 72 GB RAM and 2 Intel Xeon X5650 processors (each with six cores) per node running Linux 3.2.0.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Comparing the SWIFT and pigeonhole filters</head><p>RazerS 3 provides support for two string metrics (Hamming and edit distance) and two filter variants (SWIFT and pigeonhole filter). To investigate which filter performs best on which kind of input and metric, we conducted an experimental evaluation of the time required to map different real datasets for varying mapping settings. For this reason, we ran RazerS 3 in both filtration modes for reads of lengths 30, 50, 70 and 100 bp for the references of E. coli, C. elegans and chr. 2 of human with error rates of 0–10%.<ref type="figure" target="#fig_0">Figure 3</ref>shows an excerpt of the resulting experimental map for mapping reads to chr. 2 of human using Hamming and edit distance at 100% sensitivity. Supplementary<ref type="figure">Figure S5</ref>shows the full result set and Supplementary<ref type="figure">Table S2</ref>describes the datasets we used.The result shown in<ref type="figure" target="#fig_0">Figure 3</ref>is representative for our overall results and shows the running time ratios between mapping with the pigeonhole and SWIFT filter. We observe that for edit distance, the pigeonhole filter always leads to shorter running times than the SWIFT filter. For Hamming distance, the pigeonhole filter is well suited for low error rates (up to 6%), whereas the SWIFT filter yields better mapping times for higher error rates. Astonishingly, the factors between the two methods range from 1:32 to 32:1. The differences in mapping times can be explained by the different characteristics of both filters. Compared with SWIFT, the simpler but less specific pigeonhole filter requires no counting and hence less processing overhead, which compensates the increased number of verifications for low error rates. With an increase in error rate, the specificity of both filters deteriorates equally for edit distance. For Hamming distance, gapped shapes compensate this degradation and make the SWIFT filter much more specific than the pigeonhole filter, which is based on ungapped q-grams. Supplementary Section S2 gives a detailed comparison of the influence of the filter choice on the running time and load balancing. In the following, we will denote RazerS 3 in edit distance mode using the pigeonhole filter with given sensitivity rate as R3-100 and R3-99. Similarly, we will denote RazerS 3 using SWIFT in edit distance mode with R3-SW-99 and R3-SW-100.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Verification of expected pigeonhole sensitivity</head><p>In this experiment, we examine the accuracy of the sensitivity estimation for our new pigeonhole filter. We used 10 M fly reads of length 75 bp (SRR060093) and 10 M human reads of length 100 bp (ERR012100). For each read set, we computed a reference set consisting of all reads that can be mapped uniquely with up to 5% errors. From the mapping results, we determined positional error probabilities and used them to estimate the fraction of k-error matches lost by a ðq, ÁÞ-seed filter (loss rate) while varying the q-gram length q ¼ 16,. .. , 31 and the q-gram overlap q À Á ¼ 0,. .. , 10. The estimated loss rates were compared with the loss rates observed after mapping the reference read sets with the same filtration settings and are shown on the left-hand side in<ref type="figure">Figure 4</ref>. As a sanity check, we simulated 10 M reads of length 75 and 100 bp from the fly and human genome and implanted errors with the same positional error profile and repeated the whole comparison. The results are shown on the right-hand side in<ref type="figure">Figure 4</ref>. Dots below the diagonal correspond to experiments with an empirical sensitivity higher than estimated and above the diagonal the empirical sensitivity was overestimated. As a measure of accuracy, we use the relative difference between empirical and estimated loss rate. The dashed line shows the mean relative difference of all experiments up to a certain estimated loss rate. We observe a high level of agreement for simulated reads with a mean relative difference 51% for loss rates between 0 and 10%. On real data, the predicted loss rates between 0 and 10% show a mean relative difference of 3% on the fly and 14% on the human read set. We explain this deviation by a correlation of sequencing errors at adjacent positions, whereas our model assumes independence of errors. This error correlation has also been observed in<ref type="bibr" target="#b5">Dohm et al. (2008)</ref>and may be the result of molecules, which are out of phase for multiple cycles in the sequencing process and lead to interferences with signals of adjacent bases. However, this correlation shows no negative influence as in none of our experiments the effective sensitivity was overestimated by our model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Rabema benchmark results</head><p>Next, we used the Rabema benchmark (<ref type="bibr" target="#b10">Holtgrewe et al., 2011</ref>) (v1.1) for a thorough evaluation and comparison of read mapping sensitivity. As datasets, we simulated 100 k reads of length 100 bp from the whole human genome with Mason (<ref type="bibr" target="#b9">Holtgrewe, 2010</ref>) and distributed sequencing errors like in a typical Illumina experiment (see Supplementary Section S9 for more details). The benchmark contains the categories all, all-best, any-best and recall. In the categories all, all-best and any-best, a read mapper has to find all, all of the best or any of the best edit distance matches for each read. The category recall requires a read mapper to find the original location of each read, which is a measure independent of the used scoring model (edit-distance or quality-based). The benchmark was performed for an error rate of 5%. To compare the sensitivity fairly, we configured read mappers as best-mappers and as all-mappers if possible (BWA, Bowtie 2 and RazerS 3). We parametrized the best-mappers for high sensitivity and multiple matches. We do not consider running time here, since best-mappers are not designed for finding all matches and consequently consume more time (up to 3 h in a run compared with several minutes). The aim here was to investigate sensitivity and recall. The results are shown in the left part of<ref type="figure">Table 1</ref>. As expected, the all-mappers generally perform better than the best-mappers.<ref type="figure">4</ref>. Validation of the estimated sensitivity. We compared the estimated with the observed loss rate (1-sensitivity) of unique matches with different numbers of errors for ðq, ÁÞ-seed filters with q ¼ 16,. .. , 31 and overlaps between 0 and 10. We evaluated real (left) and simulated reads (right) using the observed error profile In addition, as expected, mappers lose more of the high-error locations than low-error locations. Surprisingly, Bowtie 2 and BWA are better than the all-mapper Hobbes. Soap 2 is low sensitive to reads with more than two errors as it allows at most two mismatches in total and by chance aligns some of the reads with more errors by replacing all N's in the reads by a G's. R3-100 is the most sensitive method, followed by mrFAST (which is not fully sensitive for higher error rates), SHRiMP 2 and Bowtie 2. Even when configured as a best-mapper (i.e. only reporting one best match), RazerS 3 achieves the best scores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Variant detection</head><p>The next experiment analyzes the applicability of RazerS 3 and other read mappers in sequence variation pipelines. Similarly to the evaluation in<ref type="bibr" target="#b4">David et al. (2011)</ref>, we generated 5 million read pairs of length 2 Â 100 bp with sequencing errors, SNPs and indels from the whole human genome such that each read has an edit distance of at most five to its genomic origin. To distribute sequencing errors according to a typical Illumina run, we used the read simulator Mason with the default profile settings. The reads (pairs) were grouped according to the numbers of contained SNPs and indels, where the group (s and i) consists of reads (pairs) with s SNPs and i indels in total. We mapped the reads both as single and paired-end reads and measured the sensitivities separately for each class and read mapper. A read (pair) was mapped correctly if an alignment (paired alignment) has been found within 10 bp of the genomic origin. It is considered to map uniquely if only one alignment was reported by the mapper. For each class, we define recall to be the fraction of all contained reads (pairs) and precision the fraction of uniquely mapped reads (pairs) that were mapped correctly. The right side of<ref type="figure">Table 1</ref>shows the results for each read mapper and class, where the upper and lower table contain the single-end and paired-end results. An extended version of this table is given in Supplementary Section S11. Comparing the all-mappers results, R3-100 shows the highest recall and precision values on both the single and paired-end datasets. mrFAST is also full sensitive on the single-end dataset but has a low recall value of 8% for pairs with 5-bp indels. SHRiMP 2 shows full precision in all classes and experiments but misses some non-unique alignments. Hobbes seems to have problems with indels and shows the lowest sensitivities in the all-mapper comparison. Surprisingly, R3-100 is the most sensitive best-mapper even in the non-variant class (0,0) where the simulated qualities could possibly give quality-based mappers an advantage. For paired-end reads where matches are also ranked by their deviation from the library size, it is even more sensitive than the all-mappers Hobbes and mrFAST. As observed in<ref type="bibr" target="#b4">David et al. (2011)</ref>, quality-based mappers like Bowtie 2, BWA and Soap 2 are not suited to reliably detect the origin of reads with variants. Their recall values deteriorate with more variants as they prefer alignments where mismatches can be explained by sequencing errors instead of natural sequence variants. The low sensitivity of Soap 2 is again due to its limitation to at most two mismatches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Performance comparison</head><p>In the last experiment, we compare the real-world performance of RazerS 3 with other read mappers. To this end, we mapped four different sets of 10 million Illumina read pairs of length 2 Â 100 bp from E. coli, C. elegans, fly and human, as well as six simulated datasets consisting of 1 million simulated read pairs of length 2 Â 200 bp, 2 Â 400 bp and 2 Â 800 bp from fly and human to their reference genomes. We mapped the reads both as single and paired-end reads with 4% error rate and measured running times, peak memory consumptions, mapped reads (pairs) and reads (pairs) mapped with minimal edit distance. We compared RazerS 3 in default mode with other all-mappers and configured it to output only one best match per read for the best-mapper comparison. Since mrFAST supports no shared-memory parallelization, we split the reads into packages of 500 k reads and mapped them with 12 concurrent processes of mrFAST. Hobbes' large memory consumption also required toRabema scores are given in percent (average fraction of matches found per read. Large numbers are the total scores in each Rabema category and small numbers show the category scores separately for reads with 0 1 2 map the reads package-wise but with a single process and 12 threads. For the evaluation, we use the commonly used measure of percentage of mapped reads (pairs), i.e. the fraction of reads (pairs) that are reported as aligned in the result file of the mapper. However, as some mappers report alignments without constraints on the number of errors, we also determine the fraction of reads (pairs) whose best match has an error rate of at most 0%,. .. , 4% (small numbers in the mapped reads (pairs) column in Tables 2 and 3). We call a read (pair) "-mappable, if it can be aligned with an error rate of " (by any mapper). As a more stringent measure for edit distance mappers, we call an "-mappable read (pair) correctly mapped if at least one (paired) alignment has been found with an error rate of ". For each mapper, we measured the percentage of correctly mapped reads (pairs), i.e. the fraction of "-mappable reads (pairs) for " 2 ½0, 4% that are correctly mapped. For a more detailed analysis, we additionally give the percentages separately for sets of " ¼ 0, " 2 ð0, 1%,. .. , " 2 ð3, 4%. The results for the fly and human Illumina datasets as well as the simulated 800-bp fly dataset are shown in Tables 2 and 3. More detailed tables of all datasets are given in Supplementary Section S12. As can be seen, R3-100 aligns all reads with the minimal number of errors and achieves the best percentage of correctly mapped reads followed by R3-95 in all experiments. A decrease in the specified sensitivity results in a decrease in running time and on the human genome R3-95 is up to twice as fast as R3-100. As in the previous experiments, the actual sensitivity is always higher than specified.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.1">All-mapper comparison</head><p>For the single-end 100-bp datasets, mrFAST is as sensitive but four times slower than R3-100. On paired-end reads, it is less sensitive and apparently has problems to map long reads with an increased number of absolute<ref type="figure">Table 3</ref>. Mapping times and accuracy of paired-end mapping with the same setting as in<ref type="figure">Table 2</ref>As datasets we used 10 M Â 2 Â 100 bp paired-end Illumina reads (left) and 1 M Â 2 Â 800 bp simulated paired-end reads with a stretched Illumina sequencing error profile (right). There were none of the 2 Â 800 bp pairs without error (denoted by a '–' in the 0-error class). errors. In the results of the Illumina paired-end datasets, we found some alignments with actual more errors than asserted by mrFAST and an error rate44%. Thus, the number of totally mapped pairs is slightly higher compared with R3-100 on the Illumina paired-end reads. On single-end reads, Hobbes is about two times slower and only on human paired-end reads faster (up to two times) than R3-100. It maps 5–15% less reads correctly and also the total number of mapped reads is less. Hobbes is not able to map reads longer than 100 bp and some single-end read packages could not be mapped due to repeated crashes (4 of 20 for C. elegans and 1 of 20 for human). As SHRiMP 2 does not use a maximal error rate, it outputs more mapped reads than R3-100 in total. However, the percentages of correctly mapped reads are less in all experiments. This could be due to its different scoring scheme, where two mismatches costs less than opening a gap, but does not explain why it misses reads with 0 errors. SHRiMP 2 is 5–23 times slower than R3-100 on the Illumina datasets and up to 600 times slower on the 800 bp datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.2">Best-mapper comparison</head><p>Compared with other best-mappers, R3-95 is faster or equally fast on all E. coli, C. elegans and fly datasets. For human reads of length 100–200 bp, it is two to three times slower than BWA and equally fast or faster for longer reads. BWA and Bowtie 2 could not be run with a maximal error rate and hence map more reads than R3-100 in total, but less correctly (in terms of edit distance) as they optimize for errors at low-quality bases. With longer reads, BWA becomes less sensitive and BWA-SW might be the better choice. However, we could not compare BWA-SW as it does not align the reads from end to end. As seen before, Soap 2 is low sensitive to reads with more than two errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5.3">Memory requirement</head><p>In all-mode (best-mode), RazerS 3 requires 15 GB (9 GB) for mapping 10 M reads of length 100 bp to hg18. The memory requirement is proportional to the number of reads and matches, about 10 GB are required for each additional 10 M Â 100 bp reads. For the same input set, Bowtie 2 uses 3.3 GB, BWA uses 4.5 GB, Soap 2 uses 5.4 GB and SHRiMP 2 uses 38 GB. Due to the lack of parallelization or a high memory consumption, we ran mrFAST and Hobbes on packages of 500 k reads where they required 11 and 70 GB of memory. Supplementary Section S7 contains a detailed discussion of the memory requirements of RazerS 3 and Supplementary Section S12 contains tables that also show the full memory requirements. A large read set, e.g. an Illumina HiSeq run, can be mapped on clusters or low memory machines by splitting it into blocks of appropriate size and mapping them separately.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>We presented a read mapping program that is faster than (or at least competitive to) existing, popular tools while guaranteeing full sensitivity following a sensible and formal definition for both Hamming and edit distance. Furthermore, it allows the user to lower the sensitivity in a controlled fashion to further lower the running time. Third, RazerS 3 can deal with reads of arbitrary length and large error rates. We showed that RazerS 3 has a superior performance in the presence of sequence variations. Together with some other recent publications, our work shows that the use of the BWT together with more or less exhaustive backtracking strategies has its limitations if the number of absolute indel errors is large. In addition, the above strategies do not need a pre-computed index. The banded edit distance verification algorithm presented here should also be considered as a fast algorithmic ingredient for future read mappers. Finally, our tool is able to fully leverage the in-core parallelism of modern processors. RazerS 3 was implemented using SeqAn (Do¨ring<ref type="bibr" target="#b6">Do¨ring et al., 2008</ref>) and is publicly available at http://www.seqan.de/projects/razers.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.3.</head><figDesc>Fig. 3. Experimental map for human chr. 2 with different read lengths and error rates. Ratios between the mapping times with pigeonhole and SWIFT are color coded in the plots</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. Overview of RazerS 3. Large green/blue rectangles represent the filter/verification states (in the figure with two threads T1 and T2). Small green/blue squares represent filtration/verification work packages. Gray/ green funnels represent the masking/compaction step</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.</head><figDesc>Fig. 4. Validation of the estimated sensitivity. We compared the estimated with the observed loss rate (1-sensitivity) of unique matches with different numbers of errors for ðq, ÁÞ-seed filters with q ¼ 16,. .. , 31 and overlaps between 0 and 10. We evaluated real (left) and simulated reads (right) using the observed error profile</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Table2.</head><figDesc>Mapping times and accuracy of single-end mapping The left side shows the results for the first 10 M Â 100 bp single-end reads of two Illumina datasets. The dataset on the right consists of 1 M Â 800 bp simulated single-end reads with a stretched Illumina sequencing error profile. Hobbes could not be run on reads longer than 100 bp. In large, we show the percentage of totally mapped reads and in small the percentages of reads that are mapped with up to 0 1 % 2% 3% 4% errors. Correctly mapped reads show the fractions of reads that were mapped with the overall minimal number of errors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>Funding: This work was supported by Deutsche Forschungsgemeinschaft [RE-1712/3-1 to MH] and the Federal Ministry of Education and Research [16V0080]. Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Table 1. Rabema benchmark results (left) and variant detection results (right)</figDesc><table></table></figure>

			<note place="foot">ß The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">RazerS 3 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">D.Weese et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> 4 5  errors. Variant detection results are shown for single-end (top right) and paired-end read (bottom right). The percentages of found origins (recall) and fractions of unique reads mapped to their origin (precision) are grouped by reads with s SNPs and i indels (s, i).</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Hobbes: optimized gram-based methods for efficient read alignment</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Ahmadi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page">41</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Personalized copy number and segmental duplication maps using next-generation sequencing</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Alkan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="1061" to="1067" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Faster approximate string matching</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">A</forename>
				<surname>Baeza-Yates</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="127" to="158" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">ELANDv2—fast gapped read mapping for Illumina reads</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Bauer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ISMB. ISCB</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">SHRiMP2: sensitive yet practical short read mapping</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>David</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="1011" to="1012" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Substantial biases in ultra-short read data sets from high-throughput dna sequencing</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Dohm</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page">105</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">SeqAn an efficient, generic Cþþ library for sequence analysis</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Do¨ringdo¨ring</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">11</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">An improved algorithm for matching biological sequences</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Gotoh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">162</biblScope>
			<biblScope unit="page" from="705" to="708" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Fast mapping of short sequences with mismatches, insertions and deletions using index structures</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hoffmann</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">1000502</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<monogr>
		<title level="m" type="main">Mason—a read simulator for second generation sequencing data</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Holtgrewe</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">A novel and well-defined benchmarking method for second generation read mapping</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Holtgrewe</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">210</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">A bit-vector algorithm for computing levenshtein and damerau edit distances</title>
		<author>
			<persName>
				<forename type="first">Hyyro¨</forename>
				<surname>Hyyro¨</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nord. J. Comput</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="29" to="39" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with Bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with burrows-wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">A survey of sequence alignment algorithms for next-generation sequencing</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Homer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="473" to="483" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">SOAP2: an improved ultrafast tool for short read alignment</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1966" to="1967" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">A fast bit-vector algorithm for approximate string matching based on dynamic programming</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="395" to="415" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">A general method applicable to the search for similarities in the amino acid sequence of two proteins</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">B</forename>
				<surname>Needleman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">D</forename>
				<surname>Wunsch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Molecular Biol</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="443" to="453" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Efficient q-gram filters for finding all epsilon-matches over a given length</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">R</forename>
				<surname>Rasmussen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="296" to="308" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Finding approximate patterns in strings</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ukkonen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="132" to="137" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">RazerS–fast read mapping with sensitivity control</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Weese</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1646" to="1654" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>