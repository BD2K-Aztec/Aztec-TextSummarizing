
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:41+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ScaffMatch: scaffolding algorithm based on maximum weight matching</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Igor</forename>
								<surname>Mandric</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Georgia State University</orgName>
								<address>
									<postCode>30303</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alex</forename>
								<surname>Zelikovsky</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Georgia State University</orgName>
								<address>
									<postCode>30303</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">ScaffMatch: scaffolding algorithm based on maximum weight matching</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btv211</idno>
					<note type="submission">Received on November 18, 2014; revised on March 4, 2015; accepted on April 10, 2015</note>
					<note>Sequence analysis *To whom correspondence should be addressed. Associate Editor: John Hancock Contact: mandric@cs.gsu.edu Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Next-generation high-throughput sequencing has become a state-of-the-art technique in genome assembly. Scaffolding is one of the main stages of the assembly pipeline. During this stage, contigs assembled from the paired-end reads are merged into bigger chains called scaffolds. Because of a high level of statistical noise, chimeric reads, and genome repeats the problem of scaffolding is a challenging task. Current scaffolding software packages widely vary in their quality and are highly dependent on the read data quality and genome complexity. There are no clear winners and multiple opportunities for further improvements of the tools still exist. Results: This article presents an efficient scaffolding algorithm ScaffMatch that is able to handle reads with both short (&lt;600 bp) and long (&gt;35 000 bp) insert sizes producing high-quality scaffolds. We evaluate our scaffolding tool with the F score and other metrics (N50, corrected N50) on eight datasets comparing it with the most available packages. Our experiments show that ScaffMatch is the tool of preference for the most datasets. Availability and implementation: The source code is available at http://cran.r-project.org/web/packages/GMD/
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Next-generation sequencing (NGS) is a powerful technology as it can produce millions of short paired-end reads covering whole genome. The cost of producing reads keeps a trend of decreasing making it a very attractive tool for genome sequencing and assembly. Genome assembly from short NGS reads is a challenging problem. Assembled genomes are frequently highly fragmented and consist of contigs of highly variable length. The connectivity information coming from read pairs mapped to contigs can be used to merge them into a scaffold which is a set of chains of oriented ordered contigs with estimated gaps between all pairs of adjacent elements. A recent comprehensive evaluation of available software tools shows that the scaffolding problem still does not have an adequate solution (<ref type="bibr" target="#b6">Hunt et al., 2014</ref>). Because of misassemblies in contigs, repeats and chimeric reads, the information about relative ordering and orientation of two contigs connected with a set of read pairs can be contradictory and not reliable. Thus, choosing a wrong subset of read pairs as an evidence of connection between two contigs can result in inferring a wrong relative ordering and/or orientation as well as the gap estimation between them. Edges that comply with the true orientation of contigs and the distance between them are usually called concordant, otherwise discordant edges. The scaffolding problem is usually formulated as an optimization problem on a graph with the vertices corresponding to the contigs and the edges corresponding to the bunches of read pairs connecting contigs. In contrast, the optimization objectives and the methods to find optimal scaffolding with respect to these objectives significantly vary from one tool to another. For example, OPERA (<ref type="bibr" target="#b4">Gao et al., 2011</ref>) maximizes the number of concordant edges using dynamic programming, SCARPA (<ref type="bibr" target="#b2">Donmez and Brudno, 2013</ref>) minimizes the number of discordant edges using fixed-parameter tractable and bounded algorithm and linear<ref type="bibr" target="#b8">Lindsay et al., 2014</ref>) maximizes number of read pairs agreeing with a chosen contig orientation using nonserial dynamic programming. As all optimization scaffolding formulations are NP-hard (see e.g.<ref type="bibr" target="#b4">Gao et al., 2011</ref>), many state-of-the-art scaffolding tools use heuristic approaches exploiting specific properties of the underlying scaffolding graph. SCARPA and SILP2 solve separately the orientation and the ordering problems, MIP (<ref type="bibr" target="#b13">Salmela et al., 2011</ref>) and SILP2 use decomposition of the scaffolding graph into biconnected components. SSPACE (<ref type="bibr" target="#b0">Boetzer et al., 2011</ref>) uses a simple but powerful greedy heuristic and BESST (<ref type="bibr" target="#b12">Sahlin et al., 2014</ref>) uses read pair statistics to filter out spurious edges created by structural errors and starts scaffolding with larger contigs. In this article, we propose a novel optimization formulation representing scaffolding as a maximum-weight acyclic 2-matching (MWA2M) problem. As the Hamiltonian path problem can be reduced to this problem, this formulation is also NP-complete. The presented algorithm ScaffMatch efficiently finds the maximumweight 2-matching and iteratively destroys all cycles. This approach works very well since, usually, number of cycles is very small. Our experimental study follows the evaluation of state-of-the-art scaffolders in<ref type="bibr" target="#b6">Hunt et al. (2014)</ref>performed on five scaffolding datasets [including four from the GAGE project (<ref type="bibr" target="#b14">Salzberg et al., 2012)]</ref>. We have run the majority of up-to-date versions of stand-alone scaffolders such as OPERA, SOPRA (<ref type="bibr" target="#b1">Dayarian et al., 2010</ref>), SSPACE and MIP as well the recently published ones, SILP2 and BESST. We have also included the results for scaffolding modules of SGA (<ref type="bibr" target="#b15">Simpson and Durbin, 2012</ref>) and SOAPdenovo2 (<ref type="bibr" target="#b9">Luo et al., 2012</ref>) run independently of de novo assembly following (<ref type="bibr" target="#b6">Hunt et al., 2014</ref>). Our matching-based tool ScaffMatch compares favorably with the state-of-the-art tools in terms of widely accepted N50 metric, the metrics introduced in<ref type="bibr" target="#b6">Hunt et al. (2014)</ref>, as well as sensitivity, PPV and F score in predicting contig junctions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head><p>Below we describe the problem formulation and algorithmic details in the following main scaffolding steps: @BULLET Preprocessing of read pairs including read mapping, handling repeats and gap estimation for each read pair. @BULLET Scaffolding graph construction with vertices corresponding to contig strands and edges corresponding to read pairs. @BULLET Matching scaffold finding near-maximum weight paths in the scaffolding graph and the corresponding orientation and ordering contigs. @BULLET Insertion of skipped contigs into the matching scaffold. We conclude with the implementation details of our scaffolding tool.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Read preprocessing</head><p>Each contig has two reverse complement strands, and each read from a pair is mapped to one of the strands. We discard reads aligned to (suspected) repeats. First, we filter out read pairs in which at least one read has multiple alignments. Then for each contig we compute its read coverage and filter out contigs with coverage greater by 2:5r than the average where r is the standard deviation of contig coverage. This empirically chosen threshold allows to remove majority of repeats while keeping almost 99% of correct contigs. Although assemblers may give chimeric contigs or produce two contigs for the same genomic region (representing the two haplotypes), ScaffMatch does not attempt to identify or modify any contigs. Each read is mapped only to one of the two contig strands (palindromes are discarded). For each read pair connecting two distinct contig strands, we estimate the gap according to<ref type="figure">Figure 1</ref>[for an alternative gap estimation model see<ref type="bibr" target="#b11">Sahlin et al. (2012)]</ref>. Among all read pairs connecting the same contig strands, we find a read pair p with the median gap estimation and then bundle p with all read pairs whose gap estimation is at most 3r away from p's estimation. As we want to keep only reads that agree with each other, the reads outside of this bundle are discarded.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Scaffolding graph</head><p>Each vertex of the scaffolding graph G ¼ ðV; EÞ corresponds to one of the contig strands and each inter-contig edge corresponds to a bundle of read pairs connecting two strands of different contigs (<ref type="figure">Fig. 2</ref>). The weight of an inter-contig edge is equal to the size of the corresponding bundle. Also for each contig, we have a dummy edge connecting its two strands.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Matching scaffolding</head><p>Ideally, we expect that the scaffolding graph would consist of a set of paths each corresponding to a different chromosome (<ref type="figure" target="#fig_1">Fig. 3a</ref>). Unfortunately, repeats introduce noisy edges connecting unrelated contigs even from different chromosomes. Additionally, the paths corresponding to chromosomes may skip short contigs (especially contigs which are shorter than the insert length). Therefore, any set of paths passing through all dummy edges in the scaffolding graph G corresponds to a plausible scaffold (<ref type="figure" target="#fig_1">Fig. 3b</ref>). The most likely scaffold would be supported by the largest number of read pairs. Therefore, we can formulate the following</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">The scaffolding problem</head><p>Given a scaffolding graph G, find a set of paths passing through all dummy edges with maximum total weight of all inter-contig edges. By setting the weight of each dummy edge to a large number (e.g. number of all read pairs), we reduce the scaffolding problem to the following.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">MWA2M problem</head><p>Given a weighted graph G ¼ ðV; E; wÞ, find a maximum weight acyclic subset of edges M E, such that each vertex v 2 V is incident to at most two edges in M. The MW2AM of an n-vertex graph G with all edge weights 1 has the weight n – 1 if and only if G has a Hamiltonian path. Therefore, the MWA2M problem is NP-complete since it includes the Hamiltonian path problem. A similar well-known problem, the maximum weight 2-matching (MW2M), allows chosen edges to form cycles. In contrast to the MWA2M problem, the MW2M problem can be efficiently solved (<ref type="bibr" target="#b10">Pulleyblank, 1980</ref>).<ref type="figure">1</ref>. Gap estimation d is calculated in conformity with the formula: d ¼ L f À ðLðAÞ À startðr1ÞÞ À ðLðBÞ À startðr2ÞÞ, where L f is the fragment length, LðAÞ; LðBÞ are lengths of contigs A and B, startðr 1 Þ (respectively, startðr 2 Þ) is the distance from the starting position of r 1 (respectively r 2 ) to the beginning of the strand A (respectively, B 0 ) 2.3.3 Maximum-weight matching heuristic for the MWA2M problem We propose to almost optimally solve the MWA2M problem with the following iterative heuristic based on the well-known blossom algorithm (<ref type="bibr" target="#b3">Edmonds, 1965</ref>) for finding the maximum-weight matching in weighted graphs. It starts with finding the maximum-weight matching M among the inter-contig edges. All the dummy edges also form a matching D. If the union of these two matchings M [ D does not contain cycles, then the heuristic reaches the optimal collection of paths. Otherwise, a negative weight –1 is assigned to the least weight intercontig edge in each cycle. The above steps of finding the intercontig matching M and destroying cycles in M [ D are repeated until the union M [ D becomes a collection of paths. The output of this heuristic will be called the Matching Scaffold. In general, the deletion of least-weight edges may significantly reduce (as much as twice in the worst case) the total weight of the collection of paths. Fortunately, the erroneous heavy inter-contig edges are very rare in real data. Our experiments show that for each scaffolding example, there is no more than a single cycle in the initial union M [ D of the maximum-weight matching M and the dummy edges solution and after the second iteration M [ D does not contain any cycles at all.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.4">Greedy heuristic for the MWA2M problem</head><p>The maximum weight matching can be computed efficiently even for larger genomes. Still the runtime can be dramatically decreased using the Greedy Heuristic repeatedly choosing the heaviest feasible edge, i.e. an edge which does not make a vertex degree higher than 2 and does not form cycles with the previously chosen edges. Note that the Greedy Heuristic picks the globally heaviest edge in contrast to greedy scaffolders (such as SSPACE) greedily extending existing chains. We provide an option that allows ScaffMatch to run with the Greedy Heuristic reducing the runtime complexity from Oðn 3 Þ to Oðn Á log nÞ as we use max heap in our implementation. Our experiments show that the Greedy Matching performs very well in practice but sacrificing not much in quality to the maximum-weight matching heuristic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.5">Contig ordering and orientation</head><p>The Matching Scaffold is represented by a collection of disjoint chains of contig strands. The sequence of edges along each chain alternates: two strands of the same contig are connected with a dummy edge and two strands of different contigs are connected with an inter-contig edge. When traversing the strands along the paths in the matching scaffold, the order of traversing ends of dummy edges gives us the orientation of the corresponding contigs and the order of traversing inter-contig edges gives us the relative order of contigs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Insertion of skipped contigs</head><p>The matching scaffold can skip short contigs whose length is less than the read pair insert size. For example, let the true scaffold contain a triple of consecutive contigs A, B and C such that l A &gt; l ins ; l C &gt; l ins , but l B ( l ins. Then instead of picking both edges AB and BC, the Matching Scaffold may choose one single edge AC since the edge weight between short contigs depends almost linearly on the length of the contigs. Thus, even though the contig B must follow A in the final scaffold, the weight of the edge between A and B is much smaller than the weight of the edge between A and C, which 'jumps' over B. Below we describe the insertion of skipped contigs into the matching scaffold (Algorithm 1). A contig is identified as skipped only if it is isolated or is a part of a 2-chain in the matching scaffold. Scaffolds with more than two contigs are kept intact. For each skipped contig, we identify the most bundle-supported slot in the matching scaffold satisfying the gap estimations and insert it in this slot (<ref type="figure" target="#fig_3">Fig. 4</ref>). If several skipped contigs are assigned to the same slot, their relative order and orientation is decided based on the gap<ref type="figure">Fig. 2</ref>. Contigs A, B and C with connecting bundles of read pairs and the corresponding scaffolding graph. Each contig is split into two nodes connected with a dummy edge. Each bundle of read pairs corresponds to an inter-contig edge connecting respective strands with the weight equal to the size of the bundle. A plausible scaffold corresponds to the path C 0 À C À A 0 À A À B 0 À B supported by two inter-contig edges CA 0 and AB 0XÞ, we estimate the distance to the left contig and orient it according to the adjacent strands. Then we sort all contigs with respect to this distance and insert them according to this order.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Software implementation</head><p>Our algorithm is implemented as a stand-alone software tool called ScaffMatch. We separately provide a UNIX shell script for mapping reads to contigs. As a short read aligner, bowtie2 is used (<ref type="bibr" target="#b7">Langmead and Salzberg, 2012</ref>). The scaffolder takes as input a fasta file containing the contigs and two SAM files produced by mapping the two read files to the contigs. We keep a small set of mandatory parameters: the mean insert size, the standard deviation and the orientation (forward–reverse, reverse–forward or SOLiD-style) of the paired-end reads. The program outputs a fasta file with scaffolds. We use Networkx python library for graph computations (<ref type="bibr" target="#b5">Hagberg et al., 2005</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Datasets</head><p>We validate and compare the scaffolding tools on the collection of scaffolding datasets used in<ref type="bibr" target="#b6">Hunt et al. (2014)</ref>including four datasets from the GAGE project (<ref type="bibr" target="#b14">Salzberg et al., 2012</ref><ref type="bibr" target="#b17">Zerbino and Birney, 2008</ref>). The<ref type="figure" target="#tab_1">Table 1</ref>gives the parameters of all used scaffolding datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Quality metrics</head><p>The main metric that is used for evaluation of scaffolding tools is N50 (<ref type="bibr" target="#b16">Vezzi et al., 2012</ref>). However, this metric may not be representative enough as mentioned in<ref type="bibr" target="#b6">Hunt et al. (2014)</ref>where a comprehensive evaluation of scaffolders was performed. There state-of-the-art tools were compared based on multiple criteria, such as the number of correct junctions between two adjacent contigs, the number of junctions with incorrect relative order, relative orientation, gap estimation and their combinations (e.g. incorrect relative order þ incorrect gap estimation). The scores assigned to the scaffolders, however, can be misleading. For example, MIP on S.aureus (using bowtie2) got a high score despite the fact that it joined no contigs. Thus, we introduce an F-score-based metric to compare the results of our tool ScaffMatch with other de-novo stand-alone scaffolding tools.is obtained with the maximum weight matching; the contig B is connected with edges to all four contigs of the matching, the contig X is connected to A and C; B should be placed between A and C according to the consensus of connecting edges and X should be placed between C and D. (b) Since there is a sufficient distance between contigs A and C, B is placed there, i.e. the edge ðA; C 0 Þ from the matching is replaced with ðA; B 0 Þ and ðB; C 0 Þ [the sum of weights of ðA; B 0 Þ and ðB; C 0 Þ is less than the weight of ðA; C 0 Þ]; since there is no sufficient room for X between contigs C and D, the edges ðA; X 0 Þ and ðX ; E 0 Þ are removed. The resulted scaffold is A À B À C À DScaffMatch: maximum weight matching scaffolding</p><p>Various quality metrics have been proposed up to date. Rather than coming up with our own metrics, we have decided to follow the most recent evaluation paper (<ref type="bibr" target="#b6">Hunt et al., 2014</ref>), which besides N50 and corrected N50 also reports the number of correctly and erroneously predicted joins between contigs in the reference genome. Following<ref type="bibr" target="#b6">Hunt et al. (2014)</ref>, we do not distinguish between links connecting long and short contigs and contigs from different chromosomes. Let P be the number of potential contigs that can be joined in scaffold which is the number of contigs minus the number of chromosomes, let TP be the number of correct contig joins in the output of the scaffolder (true positives) and FP be the number of erroneous joins (false positives). We compute the following quality metrics: TPR ¼ TP P , PPV ¼ TP TPþFP , F score ¼ 2ÁTPRÁPPV TPRþPPV , where TPR is sensitivity and PPV is positive predictive value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Evaluation and comparison</head><p>ScaffMatch is compared with well-established scaffolders SSPACE, OPERA, SOPRA, MIP, SCARPA, two recently published scaffolders SILP2 and BESST (<ref type="bibr" target="#b12">Sahlin et al., 2014</ref>) scaffolding modules of SGA (<ref type="bibr" target="#b15">Simpson and Durbin, 2012</ref>) and SOAPdenovo2 (<ref type="bibr" target="#b9">Luo et al., 2012</ref>).SSPACE, OPERA and SOPRA used bowtie (<ref type="bibr" target="#b7">Langmead and Salzberg, 2012</ref>) mapping, SOAPdenovo2 used its own mapping and all other scaffolders used bowtie2 mapping. All software has been run with the same versions and options as in<ref type="bibr" target="#b6">Hunt et al. (2014)</ref>except SILP2 and BESST for which default parameters were used from the respective websites. Results for SILP2 are not given for the combined insert size datasets as it does not have an option to process datasets with multiple insert size. For computing the number of correct and erroneous links, we used scripts provided in<ref type="bibr" target="#b6">Hunt et al. (2014)</ref>. Note that MIP and SGA did not give meaningful results, respectively, for the S.aureus and H.sapiens (long insert size). We compared three different versions of ScaffMatch: ScaffMatch (maximum weight matching with insertion), ScaffMatch_G (greedy matching with insertion) and ScaffMatch_B (maximum weight matching) in the Supplementary Table S1 (see Supplementary Data). ScaffMatch usually has the best F score among all three versions. ScaffMatch_G also can be very different from ScaffMatch since it may choose to match completely different contigs. ScaffMatch_B has usually the highest PPV and corrected N50 among all three versions implying that insertion of skipped contigs might be erroneous. Unexpectedly, the number of contigs skipped by ScaffMatch_B is not much greater than for ScaffMatch showing that the solution for the scaffolding/MWA2M problem does not skip over many contigs. The results for GAGE scaffolding testcases are in<ref type="figure" target="#tab_2">Table 2</ref>and results for P.falciparum are in<ref type="figure" target="#tab_3">Table 3</ref>. The entries in the bold font are the best among all 10 scaffolders with respect to the corresponding quality metric. ScaffMatch has the top F score for four testcases and the top corrected N50 for two testcases. Additionally, ScaffMatch_B has the top corrected N50 for S.aureus. SOAPdenovo2 has the top F score for two testcases and the top corrected N50 for three testcases. MIP is a top performer once for F score and once for corrected N50. Finally, OPERA is the best in corrected N50 for two testcases (still losing to ScaffMatch_B on S.aureus) and SSPACE has the best F score for one testcase. The runtime of all compared scaffolders are in Supplementary Table S2 in Supplementary Data. The runtime growth rate with respect to the dataset size is similar for all scaffolders. The fastest scaffolder is SSPACE, and the slowest is SOPRA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusions</head><p>In this article, we present a novel stand-alone scaffolding algorithm ScaffMatch, which is based on representation of the scaffolding problem as the maximum weight acyclic 2-matching. Our experiments show that, unexpectedly, the number of skipped contigs is not significant—for many datasets, the results for ScaffMatch_B are only slightly improved by insertion of skipped contigs in ScaffMatch. The ScaffMatch software implementation is shown to be consistently one of the top performers on majority of the scaffolding datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This work is supported in part by the NSF Grant IIS-0916401. Conflict of Interest: none declared.ScaffMatch: maximum weight matching scaffolding</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.</head><figDesc>Fig. 1. Gap estimation d is calculated in conformity with the formula: d ¼ L f À ðLðAÞ À startðr1ÞÞ À ðLðBÞ À startðr2ÞÞ, where L f is the fragment length, LðAÞ; LðBÞ are lengths of contigs A and B, startðr 1 Þ (respectively, startðr 2 Þ) is the distance from the starting position of r 1 (respectively r 2 ) to the beginning of the strand A (respectively, B 0 )</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.3.</head><figDesc>Fig. 3. (a) A scaffold A À B À C À D: the connection of each pair of adjacent contigs is supported by bundles of read pairs. (b) A path A 0 À A À B 0 À B À C 0 ÀC À D 0 À D in the scaffolding graph corresponding to the scaffold A À B À C À D. (c) The matching of the scaffolding graph corresponding to the bunches of read pairs supporting adjacent contigs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>) [Staphylococcus aureus, Rhodobacter sphaeroides and Homo sapiens (chr14)] and one additional dataset Plasmodium falciparum following Hunt et al. (2014). All contigs were assembled by Velvet (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.4.</head><figDesc>Fig. 4. Insertion procedure. (a) The matching scaffold A À C À D À E is obtained with the maximum weight matching; the contig B is connected with edges to all four contigs of the matching, the contig X is connected to A and C; B should be placed between A and C according to the consensus of connecting edges and X should be placed between C and D. (b) Since there is a sufficient distance between contigs A and C, B is placed there, i.e. the edge ðA; C 0 Þ from the matching is replaced with ðA; B 0 Þ and ðB; C 0 Þ [the sum of weights of ðA; B 0 Þ and ðB; C 0 Þ is less than the weight of ðA; C 0 Þ]; since there is no sufficient room for X between contigs C and D, the edges ðA; X 0 Þ and ðX ; E 0 Þ are removed. The resulted scaffold is A À B À C À D</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>V C The Author 2015. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com 2632 Bioinformatics, 31(16), 2015, 2632–2638 doi: 10.1093/bioinformatics/btv211 Advance Access Publication Date: 17 April 2015 Original Paper programming and SILP2 (</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. Scaffolding datasets</figDesc><table>Datasets 
Insert size read. length No. contigs No. reads 

S.aureus 
3600 
37 
170 
3 494 070 
R.sphaeroides 
3700 
101 
577 
2 050 868 
H.sapiens (chr14) 
Short insert size 
2865 
101 
19 936 
22 669 408 
Long insert size 
35 000 
80 
19 936 
2 405 064 
P.falciparum 
Short insert size 
645 
76 
9318 
52 542 302 
Long insert size 
2705 
75 
9318 
12 010 344 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 2. Performance of different algorithms on the scaffolding datasets from GAGE</figDesc><table>Dataset 
Scaffolder 
Correct links 
Error links 
Skipped contigs 
N50 
Corr. N50 
Sensitivity 
PPV 
F score 

S.aureus 
ScaffMatch 
139 
14 
23 
1 476 925 
351 546 
0.832 
0.908 
0.869 
SSPACE 
105 
13 
13 
332 784 
261 710 
0.629 
0.890 
0.737 
OPERA 
112 
11 
22 
1 084 108 
686 577 
0.671 
0.911 
0.845 
SOPRA 
40 
2 
7 
112 278 
112 083 
0.240 
0.952 
0.383 
MIP 
0 
0 
0 
46 221 
46 221 
0 
0 
0 
SCARPA 
77 
16 
10 
112 264 
112 083 
0.461 
0.828 
0.592 
SILP2 
121 
3 
34 
645 780 
284 980 
0.725 
0.976 
0.832 
BESST 
112 
11 
21 
1 716 351 
335 064 
0.671 
0.911 
0.772 
SGA 
83 
1 
10 
309 286 
309 153 
0.497 
0.988 
0.661 
SOAPdenovo2 
131 
12 
13 
643 384 
621 109 
0.784 
0.916 
0.845 

R.sphaeroides 
ScaffMatch 
482 
18 
40 
2 547 706 
2 528 248 
0.845 
0.964 
0.901 
SSPACE 
357 
7 
49 
109 776 
108 410 
0.626 
0.981 
0.764 
OPERA 
316 
1 
23 
108 172 
108 172 
0.554 
0.997 
0.713 
SOPRA 
242 
15 
24 
32 232 
30 492 
0.425 
0.942 
0.585 
MIP 
419 
37 
16 
488 095 
487 941 
0.735 
0.919 
0.817 
SCARPA 
209 
5 
23 
37 667 
37 581 
0.367 
0.977 
0.533 
SILP2 
425 
24 
87 
471 077 
422 445 
0.746 
0.947 
0.834 
BESST 
367 
2 
15 
1 021 151 
1 020 921 
0.644 
0.995 
0.782 
SGA 
232 
1 
26 
42 825 
42 722 
0.407 
0.996 
0.578 
SOAPdenovo2 
468 
8 
26 
2 522 483 
2 522 482 
0.821 
0.983 
0.895 

H.sapiens (chr 14) 
ScaffMatch 
12 411 
252 
3480 
131 135 
80 329 
0.622 
0.980 
0.761 
short insert size 
SSPACE 
9566 
43 
2754 
78 552 
77 361 
0.487 
0.986 
0.652 
OPERA 
12 291 
112 
2991 
214 972 
207 047 
0.616 
0.991 
0.760 
SOPRA 
14 761 
381 
1441 
100 768 
96 436 
0.740 
0.975 
0.841 
MIP 
13 899 
954 
2735 
244 064 
235 731 
0.697 
0.936 
0.799 
SCARPA 
9938 
162 
1829 
58 330 
55 760 
0.498 
0.984 
0.661 
SILP2 
10 548 
124 
4918 
126 689 
77 421 
0.529 
0.988 
0.689 
BESST 
7970 
355 
2165 
146 749 
80 218 
0.400 
0.957 
0.564 
SGA 
9761 
6 
3214 
134 574 
133 192 
0.490 
0.999 
0.657 
SOAPdenovo2 
15 740 
390 
2378 
282 437 
234 561 
0.790 
0.976 
0.873 

H.sapiens (chr 14) 
ScaffMatch 
5938 
443 
5198 
148 412 
42 523 
0.298 
0.933 
0.452 
long insert size 
SSPACE 
2750 
23 
2539 
77 832 
30 449 
0.138 
0.992 
0.242 
OPERA 
3687 
677 
3226 
73 477 
20 677 
0.185 
0.845 
0.303 
SOPRA 
2938 
166 
2622 
79 517 
34 750 
0.147 
0.947 
0.255 
MIP 
5898 
1092 
4861 
272 440 
49 800 
0.296 
0.844 
0.438 
SCARPA 
1603 
31 
1466 
43 969 
17 786 
0.080 
0.981 
0.149 
SILP2 
3899 
65 
3732 
74 094 
38 810 
0.196 
0.984 
0.326 
BESST 
123 
13 
98 
13 815 
8828 
0.006 
0.904 
0.012 
SGA 
0 
0 
0 
12 211 
12 211 
0 
0 
0 
SOAPdenovo2 
4516 
294 
3301 
220 644 
86 679 
0.227 
0.939 
0.365 

H.sapiens (chr 14) 
ScaffMatch 
12 658 
348 
3874 
802 755 
195 239 
0.635 
0.973 
0.769 
combined library 
SSPACE 
9249 
36 
2677 
66 271 
65 222 
0.464 
0.996 
0.633 
short þ long 
OPERA 
12 853 
58 
3409 
1 692 782 
1 062 031 
0.645 
0.996 
0.783 
insert size 
SOPRA 
10 418 
238 
3322 
112 239 
75 046 
0.523 
0.978 
0.681 
MIP 
8534 
696 
3213 
44 372 
31 148 
0.428 
0.925 
0.585 
SCARPA 
10 712 
161 
2376 
134 364 
106 654 
0.537 
0.985 
0.695 
BESST 
8287 
286 
2347 
295 976 
114 434 
0.416 
0.967 
0.581 
SGA 
9764 
3 
3214 
134 574 
133 192 
0.490 
0.999 
0.657 
SOAPdenovo2 
15 748 
382 
2575 
561 198 
447 849 
0.790 
0.976 
0.873 </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><figDesc>Table 3. Performance of different algorithms on the scaffolding datasets for P.falciparum. The best values for each dataset are in bold font.</figDesc><table>Dataset 
Scaffolder 
Correct links 
Error links 
Skipped contigs 
N50 
Corr. N50 
Sensitivity 
PPV 
F score 

P.falciparum 
ScaffMatch 
5648 
287 
37 
8626 
5872 
0.607 
0.952 
0.741 
short insert size 
SSPACE 
5746 
127 
12 
6011 
5845 
0.612 
0.978 
0.757 
OPERA 
3706 
116 
371 
5035 
4824 
0.398 
0.967 
0.565 
SOPRA 
4897 
174 
34 
4954 
4632 
0.526 
0.966 
0.681 
MIP 
5544 
359 
15 
6158 
5485 
0.596 
0.939 
0.730 
SCARPA 
4830 
221 
38 
4912 
4628 
0.519 
0.956 
0.673 
SILP2 
5496 
498 
48 
3109 
2601 
0.591 
0.917 
0.719 
BESST 
2632 
462 
84 
7471 
3931 
0.283 
0.851 
0.425 
SGA 
4940 
46 
100 
5324 
5104 
0.531 
0.991 
0.691 
SOAPdenovo2 
5540 
84 
47 
6234 
5981 
0.596 
0.985 
0.742 

P.falciparum 
ScaffMatch 
6970 
260 
1751 
41 564 
25 380 
0.749 
0.964 
0.843 
long insert size 
SSPACE 
4610 
21 
1235 
17 796 
15 553 
0.496 
0.995 
0.662 
OPERA 
6257 
97 
1339 
44 667 
40 170 
0.673 
0.985 
0.799 
SOPRA 
7247 
181 
656 
49 671 
44 158 
0.779 
0.976 
0.866 
MIP 
7754 
707 
731 
88 297 
78 672 
0.834 
0.916 
0.873 
SCARPA 
4882 
117 
714 
14 037 
9708 
0.525 
0.977 
0.683 
SILP2 
5996 
266 
2839 
45 407 
29 399 
0.645 
0.957 
0.771 
BESST 
1307 
46 
327 
4133 
2813 
0.141 
0.966 
0.245 
SGA 
2902 
2 
652 
4438 
4096 
0.312 
0.999 
0.476 
SOAPdenovo2 
7659 
351 
803 
167 570 
83 851 
0.635 
0.869 
0.734 

P.falciparum 
ScaffMatch 
8223 
425 
654 
78 627 
47 662 
0.884 
0.951 
0.916 
combined library 
SSPACE 
5889 
123 
76 
6383 
5982 
0.633 
0.980 
0.769 
short þ long 
OPERA 
6434 
177 
1171 
42 450 
38 409 
0.692 
0.973 
0.809 
insert size 
SOPRA 
7018 
60 
171 
16 366 
15 511 
0.754 
0.992 
0.857 
MIP 
8082 
513 
75 
56 672 
38 704 
0.869 
0.940 
0.903 
SCARPA 
7336 
370 
251 
36 945 
23 951 
0.789 
0.952 
0.863 
BESST 
3929 
541 
384 
25 300 
7621 
0.422 
0.879 
0.571 
SGA 
4910 
44 
419 
6606 
6134 
0.528 
0.991 
0.689 
SOAPdenovo2 
5977 
228 
254 
12 076 
10 629 
0.643 
0.963 
0.771 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">I.Mandric and A.Zelikovsky at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Scaffolding pre-assembled contigs using sspace</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Boetzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="578" to="579" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Sopra: scaffolding algorithm for paired reads via statistical optimization</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Dayarian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">345</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Scarpa: scaffolding reads with practical algorithms</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Donmez</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Brudno</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="428" to="434" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Paths, trees, and flowers. Can</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Edmonds</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Math</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="449" to="467" />
			<date type="published" when="1965" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Opera: reconstructing optimal genomic scaffolds with high-throughput paired-end sequences</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computational Biology</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1681" to="1691" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title level="m" type="main">Networkx: Python software for the analysis of networks Mathematical Modeling and Analysis. Los Alamos National Laboratory</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Hagberg</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2005-04-15" />
		</imprint>
	</monogr>
	<note>date. last accessed</note>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">A comprehensive evaluation of assembly scaffolding tools</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Hunt</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">42</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with Bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Ilp-based maximum likelihood genome scaffolding</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Lindsay</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">9</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>Suppl. 9</note>
</biblStruct>

<biblStruct   xml:id="b9">
	<monogr>
		<title level="m" type="main">Soapdenovo2: an empirically improved memory-efficient short-read de novo assembler</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Luo</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page">18</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Dual integrity in b-matching problems</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">R</forename>
				<surname>Pulleyblank</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Programming Study</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="176" to="186" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Improved gap size estimation for scaffolding algorithms</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Sahlin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="2215" to="2222" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Besst-efficient scaffolding of large fragmented assemblies</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Sahlin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">281</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast scaffolding with small independent mixed integer programs</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Salmela</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="3259" to="3265" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Gage: a critical evaluation of genome assemblies and assembly algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of large genomes using compressed data structures</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="549" to="556" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Feature-by-feature—evaluating de novo sequence assembly</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Vezzi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">31002</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>