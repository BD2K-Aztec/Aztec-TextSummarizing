
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:48+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Improved gap size estimation for scaffolding algorithms</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Kristoffer</forename>
								<surname>Sahlin</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computational Biology</orgName>
								<orgName type="department" key="dep2">School of Computer Science and Communication</orgName>
								<orgName type="laboratory">Science for Life Laboratory</orgName>
								<orgName type="institution">mKTH Royal Institute of Technology</orgName>
								<address>
									<settlement>Solna</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Nathaniel</forename>
								<surname>Street</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Plant Physiology</orgName>
								<orgName type="institution" key="instit1">Umeå Plant Science Centre</orgName>
								<orgName type="institution" key="instit2">Umeå University</orgName>
								<address>
									<settlement>Umeå, Sweden</settlement>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Joakim</forename>
								<surname>Lundeberg</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">School of Biotechnology</orgName>
								<orgName type="department" key="dep2">Division of Gene Technology</orgName>
								<orgName type="laboratory">Science for Life Laboratory</orgName>
								<orgName type="institution">KTH Royal Institute of Technology</orgName>
								<address>
									<settlement>Solna</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Lars</forename>
								<surname>Arvestad</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computational Biology</orgName>
								<orgName type="department" key="dep2">School of Computer Science and Communication</orgName>
								<orgName type="laboratory">Science for Life Laboratory</orgName>
								<orgName type="institution">mKTH Royal Institute of Technology</orgName>
								<address>
									<settlement>Solna</settlement>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="department">Department of Numerical Analysis and Computer Science</orgName>
								<orgName type="institution" key="instit1">Swedish e-Science Research Centre (SeRC)</orgName>
								<orgName type="institution" key="instit2">Stockholm University</orgName>
								<address>
									<settlement>Stockholm</settlement>
									<country key="SE">Sweden</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alex</forename>
								<surname>Bateman</surname>
							</persName>
						</author>
						<title level="a" type="main">Improved gap size estimation for scaffolding algorithms</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="issue">17</biblScope>
							<biblScope unit="page" from="2215" to="2222"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts441</idno>
					<note type="submission">Received on March 13, 2012; revised on July 5, 2012; accepted on July 9, 2012</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Genome analysis Associate Editor:</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: One of the important steps of genome assembly is scaffolding , in which contigs are linked using information from read-pairs. Scaffolding provides estimates about the order, relative orientation and distance between contigs. We have found that contig distance estimates are generally strongly biased and based on false assumptions. Since erroneous distance estimates can mislead in subsequent analysis, it is important to provide unbiased estimation of contig distance. Results: In this article, we show that state-of-the-art programs for scaffolding are using an incorrect model of gap size estimation. We discuss why current maximum likelihood estimators are biased and describe what different cases of bias we are facing. Furthermore, we provide a model for the distribution of reads that span a gap and derive the maximum likelihood equation for the gap length. We motivate why this estimate is sound and show empirically that it outper-forms gap estimators in popular scaffolding programs. Our results have consequences both for scaffolding software, structural variation detection and for library insert-size estimation as is commonly performed by read aligners. Availability: A reference implementation is provided at https://github. com/SciLifeLab/gapest Supplementary information: Supplementary data are availible at</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The decreasing cost of sequencing has made whole-genome sequencing commonplace (<ref type="bibr" target="#b9">Mardis, 2008</ref>). When sequencing a genome, one obtains a large set of short fragments of DNA (usually referred to as reads). Assembling these reads (and optimally reconstruct the genome or chromosomes that were sequenced into one piece) remains a complex task (<ref type="bibr" target="#b13">Pop and Salzberg, 2008;</ref><ref type="bibr" target="#b14">Pop, 2009</ref>). Due to the presence of repeats, allelic differences and sequencing errors, the result of an assembly is rarely a complete reconstruction of the genome. Instead, the result is often subsets of reads assembled into longer fragments of genomic sequences referred to as contigs. Since the goal is to recreate the genome, ordering and placing these contigs as they appear on the genome (given that the contigs are correctly assembled) is an important assembly step after contig construction in a process called scaffolding (<ref type="bibr" target="#b3">Huson et al., 2002</ref>). In scaffolding, the problem is to link together contigs in their correct order and orientation using paired reads. These paired reads have some known distance (up to a distribution) between them on the genome. If the two separate reads from a pair map to two different contigs, a relation between the two contigs can be inferred. Contigs that can be linked together represent a longer fragment of the genome where sub-parts of the fragment remain unknown (i.e. the gaps between contigs) and such a fragment consisting of more than one contig is called a scaffold. Modern scaffolder programs involve two steps (either separate or intermixed):</p><p>Finding optimal order and orientation of the contigs with respect to some objective function. Checking for paired-read inconsistencies. This involves removing reads that have been mapped with too small/ large an insert size (with respect to some generously set thresholds) and reads that have been mapped in the wrong relative orientation (often removed in the optimization step). After this is done, the distance between contigs is often estimated separately using a maximum likelihood (ML) estimation from the reads that are linking the contigs (<ref type="bibr" target="#b1">Dayarian et al., 2010;</ref><ref type="bibr" target="#b2">Gao et al., 2011;</ref><ref type="bibr" target="#b16">Salmela et al., 2011</ref>). The issue of gap length estimation should not be undervalued: high-quality scaffolding provides an understanding of what is necessary for finishing a genome (<ref type="bibr" target="#b10">Nagarajan et al., 2010</ref>), with the contig distances effectively quantifying the unassembled parts of the genome. Bad estimates of contig distances, in particular under-estimates, can mislead finishing. Bad distance estimates can also interfere in genome annotation, e.g. with an underestimated gap suggesting that there is not room for an expected feature, or e.g., suggesting that a potential intron is too large in the case of over-estimation. Furthermore, with contig distances being an essential indicator in the scaffolding process, a systematic bias can impair correct scaffolding. From currently implemented techniques of gap size estimation, we noticed surprisingly poor estimates even in ideal cases without mapping errors or duplicated reads. Both over-and underestimation of hundreds of base pairs could occur. This prompted our group to model gap size. Our aim is to provide * To whom correspondence should be addressed. an accurate gap size estimation to be applied after ordering and orientation of contigs and filtering of paired-read inconsistencies. It is commonly assumed that the distribution of insert sizes for reads that span over a certain gap (or even over a single position in the genome) is the same as the distribution of the paired end library (often approximated as a normal distribution). This is an erroneous assumption. There is an observation bias from the assumption that reads that span the gap are coming from the whole insert size distribution of the library.<ref type="figure">Fig. 1</ref>gives examples of two types of biases that can occur and which reads would actually be observed in these cases. A 'negative bias' occurs when the gap size is underestimated due to only observing reads from the upper part of the distribution. Similarly, a 'positive bias' occurs when overestimating the gap by only observing reads from the lower parts of the library insert size distribution. Another example of positive bias is when aligning reads to a short contig, a case occurring frequently when working with fragmented assemblies. Then, only pairs with shorter insert size will have both reads mapped. This is highly relevant for read aligners such as Bowtie (<ref type="bibr" target="#b5">Langmead et al., 2009</ref>) and Burrows Wheeler Aligner (BWA) (Li, H. and Durbin) that are routinely estimating the insert sizes for paired-read libraries. Since they are designed mainly for high-quality reference genomes, they are implicitly using an 'infinite contig length' assumption, and hence underestimate the insert size on fragmented assemblies. A heuristic way to deal with this bias is by choosing only large contigs (compared to the insert size of the library) and consider only paired reads that place sufficiently far from contig ends (<ref type="bibr">Phillipphy et al., 2008</ref>). In Sections 2.1–2.3, we explain a model for estimating gap lengths. Section 2.4 derives an estimate from the model in a special case and gives some intuition behind the estimate. In Section 2.5, the model is used to derive a closed form ML expression and we discuss this expression and its practical implications. Section 3 shows results of gap estimations from our formula compared to estimations from popular scaffolding programs. The results are discussed in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">GAP SIZE MODELLING</head><p>Consider two contigs c 1 and c 2. Our objective in this section is to find a model for the distribution of the insert size lengths x of reads spanning a given gap of length d between c 1 and c 2 (see<ref type="figure" target="#fig_2">Fig. 2</ref>). Let X be the stochastic variable denoting the insert size of a read pair and d, |c 1 |, |c 2 | be parameters denoting the gap length and the two contig lengths. As input to a scaffolder, one provides the positions of where reads align to a contig, usually obtained using an external read mapper. For a paired read i, we call these observations o i 1 and o i 2 and let o i 1 þ o i 2 ¼ o i. This gives the equality x i ¼ o i þ d (see<ref type="figure" target="#fig_2">Fig. 2</ref>). This equality is important to keep in mind, since we will alternate between expressing functions in either o þ d or x depending on the context. From this relation, we introduce the stochastic variable O, which is a variable describing the distribution of the observations c i that comes from pairs linking c 1 and c 2. We want to describe the distribution of O given some gap size d and contig lengths |c 1 |, |c 2 |, i.e. O|d, |c 1 |, |c 2 |.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">The model</head><p>We let the probability that a paired-end read of length x i is observed spanning a gap of size d between two contigs c 1 and c 2 be denoted by p(o| |c 1 |,|c 2 |),. Furthermore, let f(x) be the distribution of the insert sizes of the paired-end library. Now, with the library distribution f(o þ d) and the probability of a paired-end read spanning a gap p(o| |c 1 |,|c 2 |), we obtain the distribution of insert sizes from observed reads that span a gap of size d as hðo j d; jc 1 j; jc 2 jÞ ¼ pðo j jc 1 j; jc 2 jÞfðo þ dÞ R 1 À1 pðy j jc 1 j; jc 2 jÞfðy þ dÞdy</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>: ð1Þ</head><p>Here, the denominator is only for normalizing the function to a probability distribution. The probability function h(o| d,|c 1 |,|c 2 |) indicates that the distribution of reads spanning a gap of size d is explained by the probability that a paired read of given insert size will span the gap times the probability that this pair is being generated by the sequencing protocol (with the functions expressed in o instead of x). Now we have seen the general outline for the model, but what assumptions can we make for f and p?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Distribution for f</head><p>The distribution of insert-size lengths of a paired-end library can be very complex. Usually, the insert-size plots from such libraries look like a normal distribution with thicker tails that have been cut. Since different protocols can vary slightly in the distributions<ref type="figure">1</ref>. Illustrating bias in conditioned read-pair insert-length distributions. (a) Example of negative bias. Only the longer reads from the library are observed spanning the gap. Thus, deriving the ML estimate for the gap between the contigs assuming the reads are coming from the whole support of the distribution will lead to underestimation of the gapsize. (b) Positive bias, only the shorter reads from the library are observed. Thus, deriving the ML estimate for the gap assuming the reads are coming from the whole support of the distribution will lead to overestimation of the gap size.they generate, it can be nearly impossible to try to model the exact distribution for each sequencing protocol generated. We will here assume a general 'not too incorrect' consensus model for these libraries and therefore work with the normal distribution, in agreement with other authors (e.g.<ref type="bibr" target="#b2">Gao et al., 2011;</ref><ref type="bibr" target="#b8">Lysholm et al., 2011;</ref><ref type="bibr" target="#b15">Richter et al., 2008</ref>). One motivation for this, that will become clear after the derivation of the ML estimate, is that with thicker tails, the negative bias will be even larger than in the case of a regular normal distribution. Thus, compared to current methods that estimate gap sizes (<ref type="bibr" target="#b0">Boetzer et al., 2010;</ref><ref type="bibr" target="#b1">Dayarian et al., 2010;</ref><ref type="bibr" target="#b2">Gao et al., 2011;</ref><ref type="bibr">Pop et al., 2004;</ref><ref type="bibr" target="#b16">Salmela et al., 2011</ref>), assuming a normal distribution will take us in the right direction of estimating the gap size but we may still leave some of the negative bias due to the assumption of a normal distribution instead of the 'thicker tail' distribution. To summarize, we let the read insert size be modeled by X $ N(, 2 ), thus f will be the normal density function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Deriving p</head><p>What is the probability that a read pair of length x will span a gap of size d located somewhere on a genome of length of size |G| given certain lengths of the contigs c 1 and c 2 ? Under the assumption that the paired reads are generated uniformly throughout the genome (not entirely correct but a reasonable simplification), we can think of this problem as the number of ways that we can cover a segment of d positions with a segment of x positions such that the segment x is within the total length of c 1 | þ d þ |c 2 | (recall notations in from<ref type="figure" target="#fig_2">Fig. 2</ref>). We must, however, take into account that both reads of a pair must map to the contigs. To express the model conveniently, we say that the read lengths of both reads within a paired-end read are equal to r and that the reads must lie completely within a contig in order to span the gap. These restrictions are easy to relax when implementing the model. To be able to untangle the problem of possible placings, we look separately at each of the possible cases that can occur. It can be divided into three different cases (<ref type="figure" target="#fig_4">Fig. 3</ref>illustrates these cases). The first case (<ref type="figure" target="#fig_4">Fig. 3a</ref>) is where the contigs are long enough such that the paired read of length x can 'be placed' around the gap of length d freely. In this case, we can cover the gap in precisely x À d À 2r þ 1 ways.</p><p>In the second case, one of the contigs is so small (say c 1 ) that it limits the number of placements of a read of length x to</p><formula>|c 1 | À r þ 1.</formula><p>The third case is when x is so large compared to the distance |c 1 | þ |c 2 | þ d that the number of placements of x over d is limited to |c 1 | þ |c 2 | þ d À x þ 1. This suggests that p(x À d| |c 1 |, |c 2 |) is a min function consisting of these three functions. So, if c min ¼ minf |c 1 |,|c 2 |}, the probability that a paired-end read of length x will span a gap of size d located somewhere on a genome of length |G| becomes 1 jGj min È maxfx À d À 2r þ 1; 0g; c min À r þ 1; maxfjc 1 j þ jc 2 j þ d À x þ 1; 0g É :</p><p>This function takes the number of possible covering options divided by the number of possible placements of the read to the genome. The max functions within the min function describes that we cannot observe a paired read that is shorter than d þ 2r (it will have at least one read placed within the gap) or longer than c 1 þ c 2 þ d (since they will have at least one read placed outside the two contigs). In practice, reads can be placed partly in contigs if sufficiently many positions overlap, one could then change the integration bounds to the exact ones specified by the read aligners criteria. This will 'however' have a small effect and the general boundaries given here are sufficient to work with. Note that the divisor |G| is not exact since the true expression of 'the number of possible coverings divided by the number of possible placements of the read to the genome' would give a division with |G| À x instead, but |G|/(|G| À x) % 1. The motivation for replacing this probability is that the maximum likelihood formulas with respect to d will become a lot easier to differentiate and analyze (x depends on the observation and d) while the approximation says that the change in results will be marginal, if any at all.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">A special case</head><p>Now we have distributions for f and p and therefore implicitly have the distribution of h. As an example, say that we have two different contigs with lengths larger than the longest insert size of a paired-read library and that they have a gap length of 0 bp between them (they are completely adjacent, i.e. d ¼ 0). What is then E h<ref type="bibr">[O|d]</ref>(the observed mean link length) of the paired-end reads that connect these contigs? With these restrictions, we have pðx À d j jc 1 j; jc 2 jÞ ¼ x À d À 2r þ 1=jGj (contigs are always sufficiently large). Note that this problem is equivalent to theproblem of finding the distribution of insert sizes of paired reads that are spanning over a position. As mentioned above, it is commonly assumed that this expected value is [if X $ N(<ref type="bibr">, 2 )]</ref>. Let us see what we get with our model. For the sake of simplicity, we ignore the read lengths r since they are not important for the example (they only subtract or add 2r bases if they are included respectively not). We then get E h ½O j d ¼ 0; jc 1 j; jc 2 j ¼ ¼ E h ½X À d j d ¼ 0; jc 1 j; jc 2 j ¼ E h ½X j d ¼ 0; jc 1 j; jc 2 j</p><formula>¼ Z 1 À1 x Á hðxjd; c 1 ; c 2 Þdx ¼ ¼ Z 1 À1 y Á ðxþ1Þ jGj fðxÞ R 1 À1 yþ1 jGj fðyÞdy dx ¼ Z 1 À1 ðx 2 þ xÞ Á fðxÞ R 1 À1 ðy þ 1ÞfðyÞdy dx ¼ Z 1 À1 x 2 Á fðxÞ þ 1 dx þ Z 1 À1 x Á fðxÞ þ 1 dx ¼ 1 þ 1 E½X 2  þ þ 1 ¼ 1 þ 1 ðVarðXÞ þ E½X 2 Þ þ þ 1 ¼ 1 þ 1 ð 2 þ 2 Þ þ þ 1 ¼ þ 2 þ 1 : ð2Þ</formula><p>This signifies that the expected insert length of the paired reads that link two contigs of distance 0 is some number that is higher than the mean insert size of the library. Similarly, this in fact shows that the distribution of insert sizes over any position on the genome is not the same as the distribution of the library—the mean is larger. This is intuitive in some sense, since if you would take the 'upper half' of the library and spread across the genome, they would of course cover a larger fraction of the genome than if you take the lower half of the library. Thus, reads from the 'upper half' of the library are much more frequently seen spanning a position than are reads from the 'lower half'. Furthermore, the additional quantity 2 / þ 1 depends on the relation between the variance and the mean of the library. This, as well, is not surprising. If you have a high variance, you will have even larger differences (in size) between many of the largest insert sizes compared to the smallest ones. Basically, the smallest insert-size reads do not span many positions together so they are almost never seen spanning a position, while the contrary holds for large insert-size reads. In addition, the divisor basically says that given any variance, if the mean is large enough, the ratio of a small to large reads given the library distribution will not be too large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Inferring gap size with maximum likelihood estimation</head><p>We will now derive an ML estimator (<ref type="bibr" target="#b6">Le Cam, 1990</ref>) from our model in (1). Let o be a vector of observations. It is then natural to ask: 'What is the most probable value of the gap size provided observations o?'The nature of this function makes it hard to derive its behavior analytically and attempts of proving monotonicity of this function have not succeeded. However, extensive simulation supports the conjecture that this function is monotonically increasing with d for reasonably large contig sizes |c 1 |,|c 2 | ! þ r. This result is important since monotonicity leads us to perform binary search of this function to find the ML estimate of d. In practice, it suffices to perform binary search in the interval ½maxfÀl; À jc 1 j À jc 2 j À m þ 2rg; þ m þ 2r with m % 3 since it is highly unlikely that we can span other ranges with the given library. That is, we cannot expect to span gaps that lie more than around þ 3 bp away. In the same way, we cannot expect to span contig pairs with |c 1 | þ |c 2 |þd5 À3. We have here restricted the lower boundary to Àl, which is the smallest correct gap we can expect to encounter. How to choose l depends on assembly parameters. A frequently occurring case in a de Brujin-based assembly is that the neighboring contigs overlap with one k-mer size (the algorithm splits at a given node in the graph leaving k base pairs commonly shared). However, since binary search in an interval of length n has complexity O(log n), it is not too important to chose a tight l.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head><p>To investigate the bias in gap estimation of current dedicated scaffolders, we simulated a 300 000 bp genome with no biological structure (e.g. free from repeats). This is done to allow us to focus on the concept of pure gap estimation rather than e.g. removal of repeat contigs and mapping errors. Under these simple scaffolding circumstances a reasonable gap estimation model should perform well. Three different libraries were simulated from this genome where paired read positions were uniformly distributed throughout the genome (see<ref type="figure" target="#tab_1">Table 1</ref>). In the evaluation, we tested our gap estimation model, implemented in the program GapEst (code provided at https://github .com/SciLifeLab/gapest), against three state-of-the-art scaffolders: SOPRA (v1.4.6), SSPACE (v2.0) and OPERA (v1.02). GapEst takes a SAM-file as input and infers the gaps between contigs by parsing the positions of the mapped reads in the SAM-file. The gap estimation is based on the formula in Theorem 1. Reads were mapped with BWA (Li, H. and Durbin) using default parameters for all programs except OPERA which is coupled with Bowtie (<ref type="bibr" target="#b5">Langmead et al., 2009</ref>). We chose BWA since it is able to align soft-clipped reads (read aligned partially to contigs) which gives more observations to our tests.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Gap underestimation</head><p>We tested gap estimation where negative bias can occur (see Case a in<ref type="figure">Fig. 1</ref>). For this, we simulated four different sets of contigs from the genome with fixed gap size set to 30, 300, 650 and 950 bp. The contigs were set to a fixed size of 3000 bp. This gives 12 possible combinations of data (three read libraries and four sets of contigs). The results of the mean gap estimates are shown in<ref type="figure">Fig. 4</ref>. We see that SOPRA and OPERA are systematically underestimating gap size in most cases and the underestimation increases as d increases. This is intuitive since as the gap gets larger, more reads from the lower parts of the distribution fail to cover the gap and only the longest are left, as explained (<ref type="figure">Fig. 1</ref>). The bias also increases as the variation of the library increases which was predicted in Section 2. SSPACE does not show the same systematic underestimation bias as OPERA and SOPRA, but the predictions are still far from the true ones. GapEst, in contrast, produces unbiased estimates across all combinations of gap size and standard deviations. There are two estimation points that deviate slightly from the true value, gap size 650 for the SD65 library and gap size 950 for the SD300 library. This can occur since there are actually only between 5 and 10 edges that span these gaps in both of the cases, thus estimations become more uncertain.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Gap overestimation</head><p>We tested gap estimation where positive bias can occur (see Case b) in<ref type="figure">Fig. 1</ref>). For this, we simulated four different sets of contigs from the genome with fixed gap size set to À30, 30, 150 and 300 bp with fixed contig length of 300 bp. The negative gap case frequently occurs since a de Brujin-based assembler splits its contigs at a given node in the de Bruijn graph that leaves an overlap (negative gap) of one k-mer length. With these four sets of contigs, we used the paired-end libraries with 65 and 150 bp standard deviation (we advocate the restriction |c 1 |,|c 2 | ! þr for reasonable precision in GapEst). This gives eight possible combinations of data (two read libraries and four sets of contigs). The results of the mean gap estimates are shown in<ref type="figure" target="#fig_7">Fig. 5.</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">A biological insert size library</head><p>To show that our model is adequate and applicable for real library insert-size distributions, we downloaded the genome and Solexa/Illumina mate-pair reads for Staphylococcus aureus from Genome Assembly Gold-standard Evaluations (GAGE) homepage (<ref type="bibr" target="#b17">Salzberg et al., 2012</ref>). The library had 45Â coverage, mean insert size of 3.6 kbp and a SD of 275 bp. Contigs were obtained by splitting the reference genome into segments of 5 kbp with gaps of fixed size 500, 1500, 2500 and 3500 bp. Reads were mapped with BWA (<ref type="bibr" target="#b7">Li and Durbin, 2009</ref>) using default parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Improved gap size estimation for scaffolding algorithms</head><p>Due to the repeated nature of a real genome, a fraction of the mate-pair reads are likely to be mapped incorrectly, causing spurious links between contigs. Since we are only focusing on gap estimation given that contig links are correct, we removed the gap estimates that gave obvious indicators of alignment errors (about 2% of the estimations), as would be done in a scaffolder. Obvious error estimates were conservatively classified as gap estimations over 1500 bp away from true gap sizes together with a significant deviation in number of spanning links. Inspection indicates that there are still spurious links left in the data and a more strict filtering may reduce the standard deviations. We compared GapEst to SOPRA on this dataset. The results are illustrated in<ref type="figure" target="#tab_2">Table 2</ref>. For GapEst, the average gap estimates are very close to the true ones. The increasing standard deviation in the estimations of GapEst is due to the decreasing number of links that are able to span the gap. Compared to GapEst, SOPRA has a high standard deviation. One possible explanation for this is that SOPRA does not filter out all spurious links. We found that running GapEst without the filtering step gave only minor differences in mean gap length but a significantly higher standard deviation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Gap estimation performance on real assemblies</head><p>GAGE provides (unscaffolded) assemblies from seven different assemblers on S. aureus. We tested how GapEst performed on these assemblies using the same mate-pair reads as in previous section. MUMmer (<ref type="bibr" target="#b4">Kurtz et al., 2004</ref>) was used to align the contigs from an assembly onto the reference genome. For all pairwise combinations of contigs, a gap was estimated if two contigs were on a distance of less than þ 4 and the two contigs had over 90% alignment identity and over 95% aligned length. The gaps calculated by MUMmer in this way are referred to as 'true gaps'. We also ran GapEst and obtained gaps between contigs referred to as 'estimated gaps'. A gap was calculated by GapEst for contig pairs passing the following heuristic filters:</p><p>Links placing at distance ! þ 6 were ignored (presumed false mappings).We plotted the intersection of the gaps inferred by MUMmer and GapEst for the ABySS assembly,<ref type="figure" target="#fig_8">Fig. 6</ref>shows the result. Plots of the six other assemblies of S. aureus. are given in Supplementary material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>The scaffolders we tested perform poorly and suffer from severe bias even in ideal conditions. OPERA and SOPRA show very similar gap estimations. Although OPERA estimates several gap sizes simultaneously, this has no advantage in our tests since paired reads do not span over more than one gap. Under these circumstances, OPERA's gap estimator works with one gap at a time, and effectively becomes the one used by SOPRA. Using simulated datasets, GapEst outperforms the scaffolders tested when estimating gap lengths (Figs 4 and 5). Given the assumptions (in agreement with scaffolding literature) of reads being sequenced uniformly throughout the genome and that the library insert size is somewhat normal, GapEst appears to be unbiased in all cases. GapEst also produces accurate results with the biological data, as shown in Sections 3.3 and 3.4. This type of gap estimation could open up new ways to tackle the scaffolding problem. For example, using the gap information in the ordering step of the scaffolding algorithm could improve relative placings of the contigs. As indicated in Section 1, our model for gap size estimation can be used in more general contexts. For example, read aligners commonly estimate insert size by observing reads pairs that map to the same contig. This is a slightly different problem. On one hand, paired reads with large insert size are more likely to span any position on the genome (as seen in Section 2.4), giving rise to negative bias. On the other hand, one will observe less paired reads with large insert size on a given contig, since long reads are more likely to have one of the reads placed outside the contig. This gives rise to positive bias and the problem is exacerbated if contigs are short relative to insert size distribution. Another problem that requires sensitive estimates of insert-size distributions on a given contig is structural variation detection with paired read information. Here we are facing the sameobservation bias as in the read alignment problem. Our model provides the framework for deriving the exact distribution in each individual case and using this, the sensitivity in detection of structural variants can be improved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>We have, in this article, discussed the mathematical theory behind gap estimation. This theory has resulted in a model that explains the most likely length of the gap between two contigs given the observed read pairs that span the gap. Moreover, we have implemented the formula of the ML equation and compared the estimates to state-of-the-art scaffolding software. Empirical results suggest that our model gives a significant improvement in estimating gap length. We encourage developers of existing scaffolder programs to use this formula for gap size estimation where possible.</p><formula>LðdÞ ¼ Y n i¼1 hðo i j d; jc 1 j; jc 2 jÞ ¼ Y n i¼1 pðo i j jc 1 j; jc 2 jÞ f ðo i þ dÞ R jc1jþjc2jþ1 2rÀ1</formula><p>pðy j jc 1 j; jc 2 jÞ f ðy þ dÞdy ; ð3Þ noting that the integration bounds in the normalizing constant follow from the definition of pðojd; jc 1 j; jc 2 jÞ (it is zero outside this interval). From this, the log likelihood can be written as</p><formula>lðdÞ ¼ X n i¼1 ln pðo i j jc 1 j; jc 2 jÞ þ X n i¼1 ln f ðo i þ dÞ À X n i¼1 ln Z jc1jþjc2jþ1 2rÀ1 pðy j jc 1 j; jc 2 jÞ f ðy þ dÞdy: ð4Þ</formula><p>We want to differentiate this expression with respect to d to obtain the maximum likelihood equation for d. By linearity of the differential operator, differentiation of (4) can be performed separately for each term. The first term is constant in d and cancels out. The second term becomes</p><formula>1 2 X n i¼1 ðo i þ d À Þ:</formula><p>Now, if we let gðdÞ ¼ R jc1jþjc2jþ1 2rÀ1 pðy j jc 1 j; jc 2 jÞfðy þ dÞdy, we can write the third term as</p><formula>X n i¼1 @ @d ðgðdÞÞ gðdÞ ¼ n @ @d ðgðdÞÞ gðdÞ :</formula><p>We therefore have</p><formula>l 0 ðdÞ ¼ 1 2 X n i¼1 ðo i þ d À Þ þ n g 0 ðdÞ gðdÞ :</formula><p>Letting this equation be equal to zero to find the ML estimate, we get (after some algebraic manipulations)</p><formula>þ Z jc1jþjc2jþdþ1 dþ2rÀ1 @ @d pðyjdÞfðyÞdy ¼ 1 jGj Z jc1jþjc2jþdþ1 dþ2rÀ1 IðyÞfðyÞdy: ð5Þ</formula><p>Here, I(y) is the stepwise function obtained from differentiating pðyjdÞ and it is defined bywhere c min ¼ minfjc 1 j; jc 2 jg and c max ¼ maxfjc 1 j; jc 2 jg. Furthermore, evaluating the integral in (5) gives 1 jGj</p><formula>" 1 2 þ 1 2 erf y À ffiffi ffi 2 p # jc1jþjc2jþdþ1 cmaxþdþr À 1 jGj " 1 2 þ 1 2 erf y À ffiffi ffi 2 p # cminþdþr dþ2rÀ1 ¼ 1 2jGj " erf jc 1 j þ jc 2 j þ d þ 1 À ffiffi ffi 2 p þerf d þ 2r À 1 À ffiffi ffi 2 p # À 1 2jGj " erf c max þ d þ r À ffiffi ffi 2 p þ erf c min þ d þ r À ffiffi ffi 2 p # : Evaluating g(</formula><formula># jc1jþjc2jþdþ1 cmaxþdþr À " 1 2 þ ðd þ 2r À 1 À Þ 2jGj erf y À ffiffi ffi 2 p þ ffiffiffiffiffi ffi 2 p e ÀðyÀÞ 2 2 2 # cminþdþr dþ2rÀ1</formula><p>Which can be written asFinally, we note that jGj will cancel when dividing g0ðdÞ with g(d). This is the result we wanted to prove.</p><formula>c min À r þ 1 2jGj " erf c max þ d þ r À ffiffi ffi 2 p À erf c min þ d þ r À ffiffi ffi 2 p # þ jc 1 jþjc 2 jþdþ1À 2jGj " erf jc 1 j þ jc 2 j þ d þ 1 À ffiffi ffi 2 p À erf c max þ d þ r À ffiffi ffi 2 p # þ d þ 2r À 1 À 2jGj " erf d þ 2r À 1 À</formula></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.</head><figDesc>Fig. 1. Illustrating bias in conditioned read-pair insert-length distributions. (a) Example of negative bias. Only the longer reads from the library are observed spanning the gap. Thus, deriving the ML estimate for the gap between the contigs assuming the reads are coming from the whole support of the distribution will lead to underestimation of the gapsize. (b) Positive bias, only the shorter reads from the library are observed. Thus, deriving the ML estimate for the gap assuming the reads are coming from the whole support of the distribution will lead to overestimation of the gap size.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. A paired read with insert size x linking contigs c 1 and c 2. The (unknown) distance between c 1 and c 2 is given by d, which results in the observed distance o i ¼ o i 1 þ o i 2 . Since we have information about the insert size x and x i ¼ o i þ d , this observation carries information about the size of d.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.3.</head><figDesc>Fig. 3. Range of possible 'placings' of a paired read over a gap (shown as dotted lines). The paired reads (arrows facing each other) are positioned furthest to the left. We can 'slide' the paired read across the contigs until we encounter a restriction. This will give us the number of the possible placings for the paired read. (a) Contigs are large compared to x, which makes the restriction of possible placings of a paired read be the insert size of the read (i.e. the number of possible placings is x À d À 2r þ 1). (b) The shortest of the two contigs is so short that it limits the number of possible placements to be the length of the shortest contig minus the read length plus one (i.e. minf|c 1 |,|c 2 |} À r þ 1). (c) x is so long compared to |c 1 | þ |c 2 | þ d that the placement of the read is restricted to |c 1 | þ |c 2 | þ d À x þ 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><figDesc>Contig pair had at least 10 supporting links. Let the mean of the 10 smallest observations and the 10 largest observations over a gap be low obs , high obs , respectively. Then gaps with observations high obs À low obs 46 were ignored (presuming that at least part of the observations are false mappings since the spread of the library is so wide).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.5.</head><figDesc>Fig. 5. Gap size estimates for OPERA, SOPRA, SSPACE and GapEst. The three plots visualize the mean estimates of the gaps of sizes of À30, 30, 150 and 300 bp. Each plot corresponds to one paired-read library where the standard deviations of the libraries are of 65 and 150 bp.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.6.</head><figDesc>Fig. 6. Gap size estimates for GapEst compared to gap sizes inferred from alignment of contigs to reference genome using MUMmer.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. Synthetic paired reads</figDesc><table>Mean 
SD 
No. of reads 
coverage 

lib1 
650 
65 
149 689 
$50Â 
lib2 
650 
150 
149 654 
$50Â 
lib3 
650 
300 
147 463 
$49Â 

Read library statistics from the synthetic dataset. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 2. Estimated mean gap lengths</figDesc><table>Gap 
SOPRA 
GapEst 
No. of gaps 

500 
256 AE 234 
496 AE 72 
465 
1500 
1176 AE 263 
1491 AE 123 
402 
2500 
2119 AE 415 
2500 AE 137 
334 
3500 
2805 AE 535 
3490 AE 156 
283 

Gap length estimations for Staphylococcus aureus dataset. The true gap sizes are 
shown in the first column. Average SOPRA and GapEst estimations together with 
standard deviations are shown in second and third column. Number of gaps are 
listed in column 4. 

</table></figure>

			<note place="foot">ß The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">K.Sahlin et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Improved gap size estimation for scaffolding algorithms at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENT</head><p>The authors thank Mattias Fra˚nbergFra˚nberg for inspiring discussions about the modeling and Francesco Vezzi for advice on data and testing.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Scaffolding pre-assembled contigs using SSPACE</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Boetzer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="578" to="579" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">SOPRA: Scaffolding algorithm for paired reads via statistical optimization</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Dayarian</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">345</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Opera: reconstructing optimal genomic scaffolds with high-throughput paired-end sequences</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1681" to="1691" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">The greedy path-merging algorithm for contig scaffolding</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="603" to="615" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Versatile and open software for comparing large genomes</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Maximum likelihood: an introduction</title>
		<author>
			<persName>
				<forename type="first">Le</forename>
				<surname>Cam</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. Stat. Rev</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="153" to="171" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with Burrows-Wheeler Transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">An efficient simulator of 454 data using configurable statistical models</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Lysholm</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Res. Notes</title>
		<imprint>
			<biblScope unit="page" from="4" to="449" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">The impact of next-generation sequencing technology on genetics</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">R</forename>
				<surname>Mardis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trends Gene</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="133" to="141" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Finishing genomes with limited resources: lessons from an ensemble of microbial genomes</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Nagarajan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genom</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page">242</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Genome assembly forensics: finding the elusive mis-assembly</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">M</forename>
				<surname>Phillippy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">55</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Hierarchical scaffolding with Bambus</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="149" to="159" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Bioinformatics challenges of new sequencing technology</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trends Genet</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="133" to="141" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Genome assembly reborn: recent computational challenges</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="354" to="366" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">MetaSim—A sequencing simulator for genomics and metagenomics</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">C</forename>
				<surname>Richter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">3373</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast scaffolding with small independent mixed integer programs</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Salmela</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="3259" to="3265" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">GAGE: a critical evaluation of genome assemblies and assembly algorithms</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="557" to="567" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">A: PROOF OF THEOREM</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<monogr>
		<title level="m" type="main">Given our function hðo j d; jc 1 j; jc 2 jÞ, we have the likelihood function of d (denoted L(d)) as</title>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>