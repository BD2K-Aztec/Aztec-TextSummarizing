
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:49+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sequence analysis Correction of sequencing errors in a mixed set of reads</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010">2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Leena</forename>
								<surname>Salmela</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<postBox>PO Box 68</postBox>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alex</forename>
								<surname>Bateman</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<address>
									<postBox>PO Box 68</postBox>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sequence analysis Correction of sequencing errors in a mixed set of reads</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">26</biblScope>
							<biblScope unit="issue">10</biblScope>
							<biblScope unit="page" from="1284" to="1290"/>
							<date type="published" when="2010">2010</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq151</idno>
					<note type="submission">Received on March 1, 2010; revised on April 1, 2010; accepted on April 5, 2010</note>
					<note>[19:28 23/4/2010 Bioinformatics-btq151.tex] Page: 1284 1284–1290 BIOINFORMATICS HITSEQ PAPER (Gustaf Hällströmin katu 2b), FI-00014 University of Helsinki, Finland Associate Editor:</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: High-throughput sequencing technologies produce large sets of short reads that may contain errors. These sequencing errors make de novo assembly challenging. Error correction aims to reduce the error rate prior assembly. Many de novo sequencing projects use reads from several sequencing technologies to get the benefits of all used technologies and to alleviate their shortcomings. However, combining such a mixed set of reads is problematic as many tools are specific to one sequencing platform. The SOLiD sequencing platform is especially problematic in this regard because of the two base color coding of the reads. Therefore, new tools for working with mixed read sets are needed. Results: We present an error correction tool for correcting substitutions, insertions and deletions in a mixed set of reads produced by various sequencing platforms. We first develop a method for correcting reads from any sequencing technology producing base space reads such as the SOLEXA/Illumina and Roche/454 Life Sciences sequencing platforms. We then further refine the algorithm to correct the color space reads from the Applied Biosystems SOLiD sequencing platform together with normal base space reads. Our new tool is based on the SHREC program that is aimed at correcting SOLEXA/Illumina reads. Our experiments show that we can detect errors with 99% sensitivity and &gt;98% specificity if the combined sequencing coverage of the sets is at least 12. We also show that the error rate of the reads is greatly reduced. Availability: The JAVA source code is freely available at http://www.protonet.cs.huji.ac.il/neuropid
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The high-throughput sequencing machines such as SOLEXA/Illumina, Applied Biosystems SOLiD and Roche/454 Life Sciences produce millions of short reads in a single run. The reads may contain errors, which continues to present a challenge to de novo assemblers. The error rate of the reads can be reduced with trimming and by correcting the reads. The different sequencing platforms have their own benefits and shortcomings. For example, the distribution of error types varies from one platform to another (<ref type="bibr" target="#b27">Shendure and Ji, 2008</ref>). The dominant error type in SOLEXA/Illumina and SOLiD reads is substitution, reads produced by the 454/Roche platform tend to have many insertions and deletions because of the technology's inability to assess the length of homopolymer runs correctly and the dominant error type in Helicos reads is deletion.</p><formula>(b)</formula><p>Translation from bases to colorsWhile most sequencing platforms produce base space reads, i.e. the reads are sequences of bases A, C, G and T, the SOLiD platform produces reads in color space (<ref type="bibr">Applied Biosystems Incorporated, 2008a</ref>). The SOLiD sequencer interrogates bases in overlapping pairs so that each base is sequenced twice. The pairs are coded with four colors as shown in<ref type="figure" target="#fig_0">Figure 1</ref>. Due to different characteristics of the sequencing platforms, it is an attractive idea to combine reads produced by several platforms. This kind of mixed read sets could improve the results of both error correction and de novo assembly. There are not many tools that can take full benefit from a mixed set of reads especially if part of the reads are SOLiD color space reads. We present this kind of tool for error correction in this article. Many tools for error correction of reads from second generation sequencers use the spectral alignment method first introduced in the EULER-SR assembler (<ref type="bibr" target="#b21">Chaisson et al., 2004;</ref><ref type="bibr" target="#b24">Pevzner et al., 2001</ref>). This method first computes the spectrum of the reads which consists of all l-tuples that are frequent enough in the read set. Then a string r * is computed for each read r such that all l-tuples in r * are in the spectrum and the distance between r and r * is minimized. The distance measure can be, e.g. the Hamming distance allowing only substitutions or edit distance allowing both insertions and deletions. A similar approach is taken in several error correction tools such as SOLiD Accuracy Enhancement Tool (SAET, http://solidsoftwaretools.com/gf/project/saet/) and as preprocessing in many assemblers such as ALLPATHS (<ref type="bibr" target="#b20">Butler et al., 2008</ref>) and SOAPdenovo (<ref type="bibr" target="#b23">Li et al., 2010</ref>). In the alignment approach, multiple alignments are computed for the reads and then errors are detected and corrected based on the columns of these alignments. This approach has been used with reads from the classical Sanger sequencing (<ref type="bibr" target="#b25">Sanger et al., 1977</ref>). Examples of such tools are MisEd (<ref type="bibr" target="#b28">Tammi et al., 2003</ref>) and the preprocessing step in Arachne (<ref type="bibr" target="#b19">Batzoglou et al., 2002</ref>). The problem of this approach is that it is not feasible to compute the multiple alignments for millions of reads produced by the newer sequencing technologies. Recently, the error correction tool SHREC (<ref type="bibr" target="#b26">Schröder et al., 2009</ref>) extended this approach to SOLEXA/Illumina reads by<ref type="bibr">[19:28 23/4/2010 Bioinformatics-btq151.tex]</ref>Page: 1285 1284–1290</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Correction of sequencing errors</head><p>avoiding the computation of the alignments and traversing a spaceefficient suffix trie built of the reads. Most error correction tools are designed for a single sequencing technology although some approaches can handle base space reads from different sequencing platforms. In this article, we present enhancements to the SHREC tool that allow us to utilize both base space and color space reads from any sequencing platforms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>We use the following model of DNA sequencing. We have k reads randomly sampled from a genome of length n. The length of the reads can vary. The reads may have errors with some rather small probability. The errors may be substitutions, insertions or deletions. We further assume that the errors are distributed randomly and that the coverage is sufficient so that each position of the genome is present in several reads. As each position of the genome is sampled several times, it is possible to detect an error in a read by aligning it against other reads. If the errors are distributed randomly, most of the reads that overlap the erroneous read do not have the same error. The alignment is thus very good except for the error position in the erroneous read, and so we can use the alignment to detect and correct the error. We utilize a suffix trie to compute these alignments efficiently. Note that if the reads are from a diploid organism, they may contain single nucleotide polymorphisms (SNPs) in addition to sequencing errors. SNPs look similar to sequencing errors in the multiple alignment as they also create columns where the reads do not agree with each other. However, a sequencing error occurs only in a few reads, while SNPs should be present in several reads. We will extend the SHREC algorithm (<ref type="bibr" target="#b26">Schröder et al., 2009</ref>), and so next we will give an overview of the data structures and methods used by it. For now we will assume that the reads are in base space. Let R be the set of reads and their reverse complements. The generalized suffix trie ST(R) is a tree that contains all the suffixes of the strings in R. We concatenate a unique symbol 1...2k to the end of each string in R so that each suffix is unique. The edges of the tree are labeled with a character from the alphabet {A,C,G,T}. Each node may have only one child labeled with the same character. We call the concatenation of edge labels from the root to a node the path-label of that node. For each suffix of a string in R, there is a leaf such that the path-label of the leaf is the suffix. The weight of a node is the number of leaves in the subtrie rooted at that node. Note that this is exactly the number of suffixes in this subtrie. The level of a node is the length of the path from the root to the node. In the top levels of the trie, almost all nodes have four children as almost all strings of length equal to the level of the children can be found in the genome. Further down in the trie almost all nodes have only one child. This happens at some level r such that 4 r is greater than the length of the genome, i.e. most strings of length r +1 appear at most once in the genome. If a node at this level has more than one child, it is likely that the branching is caused by a sequencing error especially if the weight of one of the children is very small indicating that the subtrie rooted at that child has only a few suffixes in it. Still deeper in the trie the weights of the nodes become too small to distinguish between erroneous and correct children. The SHREC algorithm traverses the generalized suffix trie and identifies the erroneous children at the intermediate levels of the trie. It then attempts to correct the read suffixes that go through the erroneous child by a substitution. Insertions and deletions can be detected in the same way as substitutions and we will explain our algorithm to correct this kind of errors in the next section. The above-mentioned methods can be easily adapted to correct a set of color space reads. The reads are now strings from the alphabet {0,1,2,3} and the reverse complements of these reads can be formed just by reversing the string. The correction algorithm otherwise works exactly in the same way. Correcting a combination of base space and color space reads is more intricate. If we transform a color space read to base space, a single errorInsertion/Deletioncan change all the bases starting from the error, and thus it is not feasible to correct color space reads in base space. However, if we transform a base space read into color space, the errors remain local. As each base is used only in determining two colors in the color space representation of the read, a single error in base space can only affect two colors in color space. Thus, base space and color space reads can be corrected together in color space. If a read was originally a color space read, we will allow substituting, inserting and deleting a color when correcting the read, and if the read was originally a base space read, we will allow such color space transformations that correspond to substituting, inserting or deleting a base in the corresponding base space representation. Note that since SNPs change two colors in a color space read, SNPs are not corrected in color space reads. The SOLiD color code has the following algebraic interpretation (<ref type="bibr">Applied Biosystems Incorporated, 2008b</ref>). A color represents a pair of bases and it can thus be seen as a function that transforms the first base of the pair to the second one. These color functions form an algebraic group where the operator is function composition. An algebraic group is closed so the composition of two colors is also a color.<ref type="figure" target="#fig_2">Figure 2</ref>gives the compositions of all color pairs. If we think of the translation of a base space read to a color space read, then the composite function of two colors corresponds to a function that maps a base in position i to the base in position i+2. The changes reflected in the color space by an error in base space can now be characterized with the composite colors. A substitution causes two colors to change but the composite color remains the same, an insertion changes a color c to two colors c 1 and c 2 such that c is the composite color of c 1 and c 2 , and a deletion changes two colors to their composite color.<ref type="figure" target="#fig_3">Figure 3</ref>shows some examples.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ALGORITHM</head><p>First, we will review the SHREC algorithm (<ref type="bibr" target="#b26">Schröder et al., 2009</ref>) for correcting substitutions in a set of reads of equal length. After that we will introduce our improvements to this algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The SHREC algorithm</head><p>The SHREC algorithm (<ref type="bibr" target="#b26">Schröder et al., 2009</ref>) starts by building a generalized suffix trie of the reads and then it attempts to correct the errors at the intermediate level of the trie.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L.Salmela</head><p>node with low weight node with higher weight A TRecall that the weight of a node in the suffix trie is the number of leaves in the subtrie rooted at that node. It can be shown that if m is sufficiently large so that each substring of length m in the genome is unique, the expected weight of a node at level m of the suffix trie is E(W m ) = ka/n, where k is the number of reads, n is the length of the genome, a = l −m+1 and l is the length of a read. Furthermore, the variance of the weight of a node at level m is</p><formula>σ 2 (W m ) = k(a/n−a 2 /n 2 )</formula><p>. The algorithm then attempts to correct nodes whose weight is below E(W m )−α·σ(W m ), where α is the strictness parameter of the method. Once we have identified a node with a too small weight, we attempt to correct the error as follows. We compare the subtrie S lw rooted at the low weight node to the subtries rooted at the siblings of the node, see<ref type="figure" target="#fig_5">Figure 4</ref>for an example. If we find a sibling subtrie that contains S lw , the error can be corrected by substituting the base of the erroneous node by the base of the sibling node. To transfer this correction to the reads, we find the reads whose suffixes are in the subtrie rooted at the erroneous node and correct the reads. If no such sibling subtrie is found, the reads passing through the erroneous node are marked as erroneous but no correction is made.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Statistical model for reads of varying length</head><p>We will now modify the statistical model of the SHREC algorithm to accommodate for reads of varying length. Let us assume that the read set contains reads of r different lengths and let us denote these lengths by l 1 ,l 2 ,...,l r. Let the number of reads of length l i be k i. Let m be sufficiently large so that each sequence of length m appears only once in the genome. The weight W m of a node at level m in the generalized suffix trie of the reads is the number of suffixes whose path in the trie passes through that node. We will use W m,i to denote the contribution of reads of length l i to the weight of a node at level m. Thus, the weight of a node at level m is</p><formula>W m = r i=1 W m,i. Now if l i &lt; m, W m,i = 0</formula><p>. Otherwise each read is a Bernoulli trial for getting the path-label of the node. There are n substrings of length m in the genome and a read of length l i samples a i = l i −m+1 of them. Thus, the probability of success for the Bernoulli trial is a i /n. The total number of trials is k i and so W m,i is distributed according to the binomial distribution Binand the variance of W m,i is</p><formula>(k i ,a i /n). Thus, the expected value of W m,i is E(W m,i ) = k i a i /n if l i ≥ m, 0</formula><formula>σ 2 (W m,i ) = k i (a i /n−a 2 i /n 2 ) if l i ≥ m, 0 otherwise.</formula><p>By the linearity of expectation we get</p><formula>E(W m ) = E r i=1 W m,i = r i=1 E W m,i .</formula><p>If we assume that W m,i for different i are independent variables then</p><formula>σ 2 (W m ) = σ 2 r i=1 W m,i = r i=1 σ 2 W m,i .</formula><p>The above assumption of the independence of W m,i may be problematic if the length of a read depends on its genomic location. As in the original SHREC algorithm, we try to correct nodes whose weight is below E(W m )−α·σ(W m ), where α is the strictness parameter of the method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Correcting insertions and deletions</head><p>Just like substitutions, insertions and deletions in the reads cause extra branching in the generalized suffix trie of the reads.<ref type="figure" target="#fig_7">Figure 5a</ref>shows how the insertion of a T in a read has created a low weight node in the generalized suffix trie. The insertion can be corrected by deleting the T in which case the subtries rooted at the children of the low weight node and the corresponding siblings of the low weight node will be merged. Therefore, we compare these subtries to figure out if a deletion is a feasible way to correct a low weight node. If we find sibling subtries that contain the subtries rooted at the children of the low weight node, we have confirmed that a deletion can correct the erroneous node. We then find the reads whose suffixes are in the subtrie rooted at the erroneous node and make the deletion. If a read contains an insertion error in a homopolymer run (e.g. one of the A's in the read GAAAATC is an insertion error), the<ref type="bibr">[19:28 23/4/2010 Bioinformatics-btq151.tex]</ref>Page: 1287 1284–1290</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Correction of sequencing errors</head><p>node with low weight node with higher weight</p><formula>3 1 0 2 (a)</formula><p>Substitution. The composition of the colors on the edges is the same , i.e. 30 = 12 = 3. node with low weight node with higher weight 1 0 1</p><formula>(b)</formula><p>Insertion. The color on the correct edge is the composition of the colors on the edges adjacent to the low weight node, i.e. 1 = 01. node with low weight 0 1 1 node with higher weight</p><formula>(c)</formula><p>Deletion. The color on the edge to the low weight node is the composition of the colors on the edges adjacent to its sibling node, i.e. 01=1.error can be corrected by deleting any one of the bases in the run. However, only the last A creates a low weight node in the suffix trie, and thus we correct the error by deleting the last base in the run.<ref type="figure" target="#fig_7">Figure 5b</ref>shows how the deletion of A has created an extra branch in the suffix trie. This deletion can be corrected by inserting an A in the read, and then the subtrie rooted at the low weight node would be merged with the subtrie rooted at the corresponding child of one of its sibling nodes. Therefore, we compare these subtries to determine if an insertion is a feasible way to correct a low weight node. If the subtrie rooted at the low weight node is included in a subtrie rooted at a child node of the sibling nodes, we have identified an insertion that corrects the erroneous node. We then identify the reads whose suffixes are in the subtrie rooted at the erroneous node and insert the appropriate character to these reads. If a read contains a deletion error in a homopolymer run, our algorithm detects a low weight node only after the last base in the run, and thus we correct the error by inserting the missing base to the end of the run.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Correcting indeterminate bases</head><p>It is rather straightforward to adapt the SHREC method to handle indeterminate bases. We now build the generalized suffix trie using the five-letter alphabet {A,C,G,T,N}. When running the correction algorithm over the suffix trie, we always regard a node whose base is N to be erroneous. We then attempt to correct the error by a substitution and a deletion. We do not attempt to correct the node by inserting a character before N as the same could be achieved by correcting the indeterminate base by substitution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Combining base space and color space reads</head><p>The combined correction of base space and color space reads first transforms all the base space reads into color space. Then the generalized suffix trie is built on all the reads and their reverse complements in color space. The algorithm then traverses the trie and identifies low weight nodes at the intermediate level of the trie. Color space reads whose suffixes are found in subtries rooted at low weight nodes can then be corrected exactly as outlined above. Base space reads whose suffixes are found in subtries rooted at low weight nodes are corrected by using color transformations that correspond to substituting, deleting or inserting one base in the base space read. A substitution in base space changes two colors c 1 and c 2 into two colors c 3 and c 4 so that the composite color of c 1 and c 2 is the same as the composite color of c 3 and c 4. Therefore to correct a low weight node, we need to substitute both the color on the edge to the low weight node and the color on the edge between the low weight node and its child. To determine if this kind of substitution is a feasible way to correct a read, we compare the subtrie rooted at the child node with such children of the siblings of the low weight node that the compositions of the colors on the edges are the same. Note that because of the rules of the color space, each sibling can have only one such child. See<ref type="figure" target="#fig_8">Figure 6a</ref>for an example. An insertion in base space replaces a color c in color space with two colors whose composite color is c. Thus, to correct a low weight node, we replace the colors on the edges adjacent to the low weight node by their composite color c. To determine whether a deletion like this is a good way to correct a base space read, we compare the subtrie rooted at the child of the low weight node with the subtrie rooted at such a sibling of the low weight node that the color on the edge to the sibling is c. See<ref type="figure" target="#fig_8">Figure 6b</ref>for an example. A deletion in base space replaces two colors in color space with their composite color. In this case, a low weight node can be corrected by replacing the color c on the edge to the low weight node with two colors whose composite color is c. Now we compare the subtrie rooted at the low weight node with the subtries rooted at such children of the siblings of the low weight node that the composition of the colors on the edges adjacent to the sibling is c.<ref type="figure" target="#fig_8">Figure 6c</ref>shows an example of correcting a deletion. After identifying how to correct a low weight node, we fetch the color space representations of the base space reads whose suffixes are in the subtrie rooted at that node and correct them. If the base space reads contain no indeterminate bases, we can correct them fully in color space and after correction translate them back to base space. Indeterminate bases can be handled by consulting the original base space read to figure out the composite color when we encounter indeterminate colors in the reads translated to color space and by correcting the base space read directly whenever we correct the corresponding color space read.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">IMPLEMENTATION</head><p>We have extended the implementation of SHREC (<ref type="bibr" target="#b26">Schröder et al., 2009)</ref>with the ideas presented in the previous section. We provide two versions of the program. One can correct sets with only base space reads as the transformation to color space is an unnecessary Page: 1288 1284–1290</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L.Salmela</head><p>complication in this case. The other version corrects read sets that may include both color space and base space reads but can naturally be limited to only color space reads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS AND DISCUSSION</head><p>We tested our implementation both on simulated reads and real reads from the Escherichia coli genome. The simulated reads are generated from the K-12 substrain MG1655 (NC_000913). The length of the simulated base space reads varies uniformly at random from 75 to 125 bp and the length of the simulated color space reads varies from 40 to 50 bp. The base space reads were generated with coverages of 6, 12 and 24, and error rates 1.5% and 3.0%. The color space reads were generated with coverages of 15 and 30, and error rates 1.4% and 2.9%. In the base space reads, each type of error is equally probable but in the color space reads only 5% of the errors are insertions or deletions as substitution is the dominant error type in reads produced by the SOLiD sequencing platform. We downloaded real reads from the E.coli strain UTI89 produced by the Roche/454 sequencing platform from NCBI short read archive (accession number SRA000156) and real SOLiD reads from the E.coli strain DH10B from Applied Biosystems (http://solidsoftwaretools.com/gf/project/ecoli2x50/). The SOLiD reads were filtered to exclude low-quality reads. The coverage of these sets is typical for a project involving only one kind of reads. We used a subset of these reads so that the coverage would be closer to a project that uses a hybrid approach to genome assembly. The coverage of our subset of the 454 reads is 6 and the coverage of the subset of SOLiD reads is 30. The length of the 454 reads varies from 42 to 285 and the length of the SOLiD reads varies from 39 to 50. Unfortunately, we could not find base space and color space reads from the same strain of E.coli but nevertheless our experiments on these read sets show that there are benefits to be gained from a mixed set of real reads.<ref type="figure" target="#tab_1">Table 1</ref>shows a summary of the read sets. To test the hybrid correction of base space and color space reads, we used a combination of the base space and color space read sets. All the experiments were run on an Intel Xeon computer with eight cores operating at 3.66 GHz and 32 GB of memory. The algorithms are implemented in Java and compiled and run with JVM 1.6. We tried the algorithm with several values of the strictness parameterα producing different thresholds at the analyzed level of the trie and show the results for the best observed value. For the simulated read sets, the best value was determined by minimizing the number of false positives (FPs) and false negatives (FNs) when detecting erroneous reads, and for the real reads, we chose the value that allowed aligning the corrected reads best to the reference genome.<ref type="figure" target="#tab_2">Table 2</ref>shows the runtime and memory usage of the algorithm, the best strictness value and the corresponding threshold for detecting low weight nodes at the analyzed level of the trie for the various read sets. The memory usage is measured as the peak resident set size of the program. The implementation of the algorithm uses threads. Each thread builds and analyzes a subtrie of the suffix trie where all suffixes start with a prefix specific to that thread. The memory usage of the algorithm can be decreased by reducing the number of threads or increasing the length of the prefix. However, the runtime will then increase. The strictness value must be chosen so that the threshold for detecting low weight nodes at analyzed level is greater than one. The best strictness value varied from 4 to 7 except for the lowest coverage read sets for which we were forced to choose a smaller value to keep the threshold at analyzed level greater than one. To evaluate the performance of the algorithm, we measured its ability to detect erroneous reads and the error rate of the reads before and after correction. The detection of erroneous reads is a binary classification test.<ref type="figure" target="#tab_3">Table 3</ref>shows the definitions for true positive (TP), true negative (TN), false negative (FN) and false positive (FP). The sensitivity is defined as TP/(TP+FN) and specificity<ref type="figure" target="#tab_4">Table 4</ref>shows the results of the classification test for the simulated read sets. For all datasets the sensitivity is &gt;98 % meaning that only a few of the erroneous reads remain undetected. The specificity of the method is also &gt;98 % except for the low-coverage base space read sets B6x1.5 and B6x3.0. To measure the accuracy of correction, we computed the error rate of the read sets before and after correction by comparing them to the original reads before errors were introduced. We compared the accuracy of our correction method with EULER-SR (<ref type="bibr" target="#b21">Chaisson et al., 2004</ref>) in case of base space reads and to SAET by Applied Biosystems in case of color space reads.<ref type="figure" target="#tab_5">Table 5</ref>shows that the error rate is significantly reduced by the correction. Performing hybridcorrection with a mixed set of reads instead of correcting each set separately further increases the correctness of the reads for lowcoverage read sets. Our method reduced the error rate much more than EULER-SR but SAET achieves in most cases better error rates than our method for color space reads. For the real read sets, the accuracy of correction was measured by aligning the reads to the reference genome. We used BLAST (<ref type="bibr" target="#b16">Altschul et al., 1990</ref>) to align the base space reads and SOAP2 (<ref type="bibr" target="#b22">Li et al., 2009</ref>) to align the color space reads.<ref type="figure" target="#fig_10">Figures 7 and 8</ref>show the proportion of reads that can be aligned to the reference genome as a function of allowed error rate. For example, 86% of the original color space reads can be aligned to the reference genome with at most one mismatch, whereas 91% of the corrected color space reads can be aligned with the same mismatch tolerance. Our new method performs better than EULER-SR but SAET achieves slightly better correction in color space than our method. The good performance of SAET might be due to its ability to correct more than one error inan l-tuple, while the bases surrounding an error must align exactly with other reads for our method to correct the error. To demonstrate the impact of error correction on de novo assembly we ran the Velvet (<ref type="bibr" target="#b29">Zerbino and Birney, 2008</ref>) assembler on the real read sets before and after correction.<ref type="figure">Table 6</ref>shows that assembly is greatly improved by the error correction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L.Salmela</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>We have presented a tool for the hybrid correction of a mixed set of reads produced by several sequencing platforms including the SOLiD sequencing technology that produces color space reads. We showed that our method can detect errors with high sensitivity and specificity and also the error rate of the reads is reduced. We also showed that low-coverage read sets clearly benefit from hybrid correction with other read sets.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. SOLiD two base color encoding.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. The composite colors for each color pair.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. The color changes caused by errors in base space. When the nucleotide C is substituted with T, two colors change. In this example, 30 is changed to 12. We note that the composite color remains the same, 3. When the nucleotide C is deleted, the two colors 30 are replaced by their composite color 3. We further note that insertion is the reverse of a deletion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.4.</head><figDesc>Fig. 4. The subtries to compare when correcting a substitution.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.5.</head><figDesc>Fig. 5. The subtries to compare when correcting an insertion or deletion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.6.</head><figDesc>Fig. 6. The subtries to compare when correcting a substitution, insertion or deletion of a base space read in color space.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig.7.</head><figDesc>Fig. 7. The proportion of mapped reads as a function of the maximum allowed error rate when mapping the reads to the reference genome for the real 454 read set RB6x.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig.8.</head><figDesc>Fig. 8. The proportion of mapped reads as a function of the maximum number of mismatches allowed when mapping the reads to the reference genome for the real SOLiD read set RC30x. The coverage of RC30x is so much higher than the coverage of RB6x that the hybrid correction improves the correction result only slightly for RC30x.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. Summary of read sets used in the experiments, last two read sets are real reads and the rest of the sets are simulated</figDesc><table>ID 
Base/ 
Coverage 
Error rate 
Number of 
color space 
(%) 
reads (M) 

B6x1.5 
Base space 
6 
1.5 
0.28 
B6x3.0 
Base space 
6 
3.0 
0.28 
B12x1.5 
Base space 
12 
1.5 
0.56 
B12x3.0 
Base space 
12 
3.0 
0.56 
B24x1.5 
Base space 
24 
1.5 
1.12 
B24x3.0 
Base space 
24 
3.0 
1.12 
C15x1.5 
Color space 
15 
1.4 
1.56 
C15x3.0 
Color space 
15 
2.9 
1.56 
C30x1.5 
Color space 
30 
1.4 
3.13 
C30x3.0 
Color space 
30 
2.9 
3.13 
RB6x 
Base space 
6 
0.12 
RC30x 
Color space 
30 
2.83 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 2. Runtime and memory usage of correction, the best value for the strictness parameter α and the corresponding threshold for detecting low weight nodes at the analyzed level of the trie for the various read sets</figDesc><table>IDs 
Runtime 
Memory 
α 
Threshold at 
(s) 
(MB) 
analyzed level 

B6x1.5 
670 
3087 
2.7 
1.5 
B6x3.0 
708 
3106 
2.7 
1.5 
B12x1.5 
1391 
3160 
4.0 
2.5 
B12x3.0 
1395 
3379 
4.0 
2.5 
B24x1.5 
2765 
3664 
5.5 
5.5 
B24x3.0 
2856 
3905 
5.5 
5.5 
C15x1.5 
1245 
3323 
4.0 
2.5 
C15x3.0 
1268 
3457 
4.0 
2.5 
C30x1.5 
2517 
3937 
5.9 
3.5 
C30x3.0 
2677 
4124 
5.8 
4.5 
B6x1.5 + C15x1.5 
1788 
3677 
5.1 
2.5 
B6x3.0 + C15x3.0 
1955 
3826 
5.1 
2.5 
B12x1.5 + C30x1.5 
4014 
4430 
6.8 
8.5 
B12x3.0 + C30x3.0 
4136 
4740 
7.0 
7.5 
RB6x 
734 
3002 
2.9 
1.5 
RC30x 
2467 
3710 
5.8 
5.5 
RB6x + RC30x 
3296 
3829 
6.7 
5.5 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 3. Classifications of identified and erroneous reads</figDesc><table>Erroneous read 
Error-free read 

Identified as erroneous 
TP 
FP 
Identified as error free 
FN 
TN </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Table 5.</figDesc><table>The error rates (%) of the simulated read sets before and after 
correction 

ID 
Original reads 
Corrected 
EULER-SR 
SAET 

B6x1.5 
1.489 
0.299 
0.595 
– 
B6x3.0 
2.960 
0.882 
1.984 
– 
B12x1.5 
1.491 
0.218 
0.307 
– 
B12x3.0 
2.960 
0.661 
1.094 
– 
B24x1.5 
1.491 
0.215 
0.350 
– 
B24x3.0 
2.960 
0.643 
1.000 
– 
C15x1.5 
1.433 
0.196 
– 
0.220 
C15x3.0 
2.864 
0.707 
– 
0.663 
C30x1.5 
1.435 
0.193 
– 
0.188 
C30x3.0 
2.870 
0.691 
– 
0.527 

B6x1.5 
C15x1.5 

1.489 
0.199 
– 
– 
1.433 
0.193 
– 
– 

B6x3.0 
C15x3.0 

2.960 
0.604 
– 
– 
2.864 
0.695 
– 
– 

B12x1.5 
C30x1.5 

1.491 
0.200 
– 
– 
1.433 
0.195 
– 
– 

B12x3.0 
C30x3.0 

2.960 
0.604 
– 
– 
2.870 
0.697 
– 
– 

as TN/(TN+FP). </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 6. The impact of read correction on de novo assembly</figDesc><table>ID 
Number of 
N50 
Mean contig 
Maximum 
contigs 
length (bp) 
contig 
(≥100 bp) 
length (bp) 

RB6x 
2587 
2933 
1728 
13 555 
RB6x corrected 
1731 
4318 
2568 
18 692 
RC30x 
10 868 
438 
348 
2398 
RC30x corrected 
7027 
590 
455 
3081 

</table></figure>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We wish to thank Andreas Bremges for implementing part of the algorithms and Simon J. Puglisi for helpful comments regarding a draft of this manuscript. We also wish to thank Rainer Lehtonen, Virpi Ahola, Ilkka Hanski, Panu Somervuo, Lars Paulin, Petri Auvinen, Esko Ukkonen, Veli Mäkinen and Niko Välimäki for insightful discussions about error correction.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">194</biblScope>
			<biblScope unit="page" from="28" to="51" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>btq151. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="1289" to="1284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title level="m" type="main">Correction of sequencing errors Table 4. The classification test for simulated read sets ID TP FP FN</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>B6x1</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>B6x3</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>B12x1</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>B12x3</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>B24x1</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>B24x3</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>B6x1</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">C15x1</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>B6x3</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>B12x1</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">C30x1</forename>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">194</biblScope>
			<biblScope unit="page" from="28" to="51" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>btq151. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b15">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="1290" to="1284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Basic alignment search tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="403" to="410" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Principles of di-base sequencing and the advantages of color space analysis in the SOLiD system Available at http://marketing.appliedbiosystems.com/images/Product_Microsites</title>
	</analytic>
	<monogr>
		<title level="j">Applied Biosystems Incorporated</title>
		<imprint>
			<date type="published" when="2008-04-15" />
		</imprint>
	</monogr>
	<note>Solid_. Knowledge_MS/pdf/SOLiD_Dibase_Sequencing_and_Color_Space_Analysis.pdf (last accessed date</note>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">A theoretical understanding of 2 base color codes and its application to annotation, error detection, and error correction Available at http://www3.appliedbiosystems.com/cms/groups</title>
	</analytic>
	<monogr>
		<title level="j">Applied Biosystems Incorporated</title>
		<imprint>
			<date type="published" when="2008-04-15" />
		</imprint>
	</monogr>
	<note>cms_058265. .pdf (last accessed date</note>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">ARACHNE: a whole-genome shotgun assembler</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Batzoglou</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="177" to="189" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">ALLPATHS: de novo assembly of whole-genome shotgun microreads</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Butler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="810" to="820" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Fragment assembly with short reads</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Chaisson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="2067" to="2074" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">SOAP2: an improved ultrafast tool for short read alignment</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1966" to="1967" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">An Eulerian path approach to DNA fragment assembly</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Pevzner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA, 98</title>
		<meeting>. Natl Acad. Sci. USA, 98</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9748" to="9753" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">DNA sequencing with chain-terminating inhibitors</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Sanger</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="1977" />
			<biblScope unit="page" from="5463" to="5467" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">SHREC: a short-read error correction method</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Schröder</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2157" to="2163" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Next-generation DNA sequencing</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Shendure</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Ji</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1135" to="1145" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Correcting errors in shotgun sequences</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">T</forename>
				<surname>Tammi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="4662" to="4672" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>