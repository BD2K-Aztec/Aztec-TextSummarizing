
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:43+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Piecewise linear approximation of protein structures using the principle of minimum message length</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011">2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Arun</forename>
								<forename type="middle">S</forename>
								<surname>Konagurthu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Clayton School of Information Technology</orgName>
								<orgName type="institution">Monash University</orgName>
								<address>
									<postCode>3800</postCode>
									<settlement>Clayton</settlement>
									<region>VIC</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName>
								<forename type="first">Lloyd</forename>
								<surname>Allison</surname>
							</persName>
							<email>lloyd.allison@monesh.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Clayton School of Information Technology</orgName>
								<orgName type="institution">Monash University</orgName>
								<address>
									<postCode>3800</postCode>
									<settlement>Clayton</settlement>
									<region>VIC</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Peter</forename>
								<forename type="middle">J</forename>
								<surname>Stuckey</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science and Software Engineering</orgName>
								<orgName type="institution">The University of Melbourne</orgName>
								<address>
									<postCode>3010</postCode>
									<settlement>Parkville</settlement>
									<region>VIC</region>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Arthur</forename>
								<forename type="middle">M</forename>
								<surname>Lesk</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department" key="dep1">Department of Biochemistry and Molecular Biology</orgName>
								<orgName type="department" key="dep2">Proteomics and Bioinformatics</orgName>
								<orgName type="institution" key="instit1">The Huck Institute for Genomics</orgName>
								<orgName type="institution" key="instit2">The Pennsylvania State University</orgName>
								<address>
									<addrLine>University Park</addrLine>
									<postCode>16802</postCode>
									<region>PA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Piecewise linear approximation of protein structures using the principle of minimum message length</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">27</biblScope>
							<biblScope unit="page" from="43" to="51"/>
							<date type="published" when="2011">2011</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btr240</idno>
					<note>[19:47 6/6/2011 Bioinformatics-btr240.tex] Page: i43 i43–i51 BIOINFORMATICS</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Simple and concise representations of protein-folding patterns provide powerful abstractions for visualizations, comparisons, classifications, searching and aligning structural data. Structures are often abstracted by replacing standard secondary structural features—that is, helices and strands of sheet—by vectors or linear segments. Relying solely on standard secondary structure may result in a significant loss of structural information. Further, traditional methods of simplification crucially depend on the consistency and accuracy of external methods to assign secondary structures to protein coordinate data. Although many methods exist automatically to identify secondary structure, the impreciseness of definitions, along with errors and inconsistencies in experimental structure data, drastically limit their applicability to generate reliable simplified representations, especially for structural comparison. This article introduces a mathematically rigorous algorithm to delineate protein structure using the elegant statistical and inductive inference framework of minimum message length (MML). Our method generates consistent and statistically robust piecewise linear explanations of protein coordinate data, resulting in a powerful and concise representation of the structure. The delineation is completely independent of the approaches of using hydrogen-bonding patterns or inspecting local substructural geometry that the current methods use. Indeed, as is common with applications of the MML criterion, this method is free of parameters and thresholds, in striking contrast to the existing programs which are often beset by them. The analysis of results over a large number of proteins suggests that the method produces consistent delineation of structures that encompasses, among others, the segments corresponding to standard secondary structure.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>With the rapid growth in the corpus of known structures, concise representations are increasingly preferred to inspect and analyze protein folding patterns (<ref type="bibr" target="#b2">Abagyan and Maiorov, 1988;</ref><ref type="bibr" target="#b19">Lesk, 1995;</ref><ref type="bibr" target="#b23">Richardson, 1981;</ref><ref type="bibr" target="#b29">Taylor et al., 1983</ref>). At the core of this simplification is the idea that proteins contain repetitive substructural elements and that the essence of a fold lies in the assembly and * To whom correspondence should be addressed. interaction of these elements (<ref type="bibr" target="#b14">Kamat and Lesk, 2007;</ref><ref type="bibr" target="#b15">Konagurthu and Lesk, 2010;</ref><ref type="bibr" target="#b18">Lesk and Chothia, 1980;</ref><ref type="bibr" target="#b19">Lesk, 1995</ref>). The appearance of some of these elements arises from the periodicity in the patterns of hydrogen bonds between backbone nitrogen and carbonyl groups along the protein polypeptide chain. Among the standard secondary structure definitions are: helix (α-helix, π-helix and 3 10-helix) and strand of sheet (<ref type="bibr" target="#b10">Edsall et al., 1966</ref>). Ideally, the spatial trace of α-Carbon (C α ) atoms of standard secondary structure show a linear trend allowing them to be abstracted using vectors or line segments, without much loss of structural information about the fold. The common practice is to fit an axis to a helix and a least-square line to C α or main chain atoms of strands of sheet (<ref type="bibr" target="#b6">Chothia et al., 1981;</ref><ref type="bibr" target="#b19">Lesk, 1995</ref>). Replacement of secondary structural elements with line segments is therefore one of the common methods to abstract protein structures and construct concise representation of their folding patterns. The number of standard secondary structural elements observed in a protein is typically an order of magnitude smaller than the number of residues in a chain. Therefore methods that utilize concise representations clearly benefit from a massive space and computational saving, especially when comparing and analyzing structures on a large scale (<ref type="bibr" target="#b2">Abagyan and Maiorov, 1988;</ref><ref type="bibr" target="#b16">Konagurthu et al., 2008;</ref><ref type="bibr" target="#b22">Mizuguchi and Go, 1995;</ref><ref type="bibr" target="#b26">Shi et al., 2007</ref>). Methods that abstract protein structure at the level of secondary structure generally rely on external programs that can automatically assign secondary structures to coordinate data. However, accurate identification and assignment of secondary structure is an inexact process (<ref type="bibr" target="#b8">Cuff and Barton, 1999</ref>). Although definitions based on hydrogen bonding provides some rigor in assigning secondary structure, the standard definition of what constitutes a hydrogen bond is based on the notion of bond energy whose measurement can be imprecise and acutely sensitive even to small differences in the position of nitrogen and carbonyl atoms, especially the carbonyl oxygen positions. Two popular programs that use hydrogen bonding as a basis for assignment of secondary structure are DSSP (<ref type="bibr" target="#b13">Kabsch and Sander, 1983</ref>) and STRIDE (<ref type="bibr" target="#b12">Frishman and Argos, 1995</ref>). On the other hand, secondary structure can be defined using geometric features such as distances and dihedral angles of C α atoms along the backbone in addition to other local structural features. In fact, there is a direct correlation between patterns of hydrogen bonding and the geometry that arise out of them. However, secondary structural elements can deviate substantially from ideal geometry, therefore posing severe challenges to detect such elements using geometric features alone. Among the methods that rely primarily on geometry to assign secondary structure are<ref type="bibr">[19:47 6/6/2011 Bioinformatics-btr240.tex]</ref>Page: i44 i43–i51</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.S.Konagurthu et al.</head><p>(<ref type="bibr" target="#b9">Dupuis et al., 2004;</ref><ref type="bibr" target="#b17">Labesse et al., 1997;</ref><ref type="bibr" target="#b20">Levitt and Greer, 1977;</ref><ref type="bibr" target="#b21">Majumdar et al., 2005;</ref><ref type="bibr" target="#b24">Richards and Kundrot, 1988;</ref><ref type="bibr" target="#b27">Sklenar et al., 1989;</ref><ref type="bibr" target="#b28">Srinivasan and Rose, 1999;</ref><ref type="bibr" target="#b30">Taylor, 2001</ref>). (See<ref type="bibr" target="#b21">Majumdar et al. (2005)</ref>for details of popular programs that assign secondary structural elements.) We note that previous comparative studies have highlighted the difficulties of existing programs to assign consistently secondary structure to coordinate data and have proposed using a 'consensus' definition—secondary structure assignment that is at the intersection of all the methods—to arrive at a reliable simplification of protein structures (<ref type="bibr" target="#b7">Colloc'h et al., 1993;</ref><ref type="bibr" target="#b8">Cuff and Barton, 1999</ref>). The main goal for abstracting protein structures must be to achieve maximal economy of description with minimal loss of structural information (<ref type="bibr" target="#b30">Taylor, 2001</ref>). However, simplifying structures at the level of standard secondary structure is lossy because the loop regions are ignored. Therefore, a reliable method that achieves the above goal and that is tolerant to measurement error and noise is preferred. Even better would be a method entirely independent of preconceived notions of what substructures are being sought. Here, we describe a method that generates a principled abstractions of protein structures. Our method uses the rigorous statistical framework of minimum message length (MML). In fact, the realization of the goal to maximize economy and minimize loss of information fits squarely into the MML criterion, making it extremely well-suited for this specific problem. In this work, we treat a protein as an ordered list of C α coordinates. Our method uses an information-theoretic approach to explain as a line segment the points between any pair of residues in the structure. Each such explanation is encoded in a certain number of bits (or code length). Using these code lengths, a globally optimal explanation is computed which minimizes the total encoded (message) length of the given coordinate data. The code lengths contributing to this minimum message length result in the best piecewise linear approximation of the structure. In a stark contrast to the existing methods, our method is completely free of parameters and thresholds. We emphasize that our method is not a method for delineating secondary structures. However, as expected from such a method, our results show that the line segments generated by this method correspond well with standard secondary structures of proteins. We note that this article generalizes to three dimensions the work of<ref type="bibr" target="#b3">Banerjee et al. (1996)</ref>, who described a polygonal approximation method on general two dimensional sequence of points. 1 Indeed, it can be shown that our method described in this paper can be generalized to arbitrary dimensions and other types of structural data (over and beyond proteins). We have attempted to keep the notations in this paper consistent with those described in the work of<ref type="bibr" target="#b3">Banerjee et al. (1996)</ref>for the convenience of the reader. Section 2 briefly summarizes the MML framework, followed by Sections 3–6 which describe the mechanics of our approach. Section 7 presents an analysis of the results of our method over a large number of protein structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">THE MINIMUM MESSAGE LENGTH FRAMEWORK</head><p>Wallace and Boulton (1968) first proposed the theory of MML, where given a set of competing hypotheses (or models) that can explain some observed data, the MML criterion provides a statistically rigorous framework for selecting the best hypothesis to describe the data. In many ways, MML is a formal informationtheoretic realization of the principle of Occam's razor. Assume there are some observed data D and some hypothesis H that explains the data. From Bayes's theorem we get</p><formula>p(H&amp;D) = p(H)×p(D|H) = p(D)×p(H|D)</formula><p>where p(H&amp;D) is the joint probability of data D and the hypothesis H, p(H) is the prior probability of hypothesis H, p(D) is the prior probability of data D, p(H|D) is the posterior probability of H given D, and p(D|H) is the likelihood. MML applies the remarkable result from Shannon's 'Mathematical Theory of Communication' (<ref type="bibr" target="#b25">Shannon, 1948</ref>) that, given an event E with a probability p(E), the message length, l(E) for an optimal code is given by l(E)</p><formula>=−log 2 p(E)</formula><p>bits. Carrying this insight to the Bayes's theorem, we get the following relationship between conditional probabilities in terms of optimal message lengths.</p><formula>l(H&amp;D) = l(H)+l(D|H) = l(D)+l(H|D).</formula><p>The essence of inductive inference is to fit a model to a mass of observed data. For such an approach it is the hypothesis H with the largest posterior probability p(H|D) that is often preferred. Among the terms in the above equation, p(H) (and hence l(H)) can usually be estimated well for some reasonable prior on hypotheses. At the same time, the likelihood p(D|H) can also be estimated. But to estimate the posterior probability distribution p(H|D), the prior of observed data p(D) will be needed. Estimating p(D) can be problematic and even impractical. However, for two competing hypotheses, H and H we have l(H|D)−l(H |D) = l(H)+l(D|H)−l(H )−l(D|H ), thereby eliminating the necessity to estimate p(D) completely when comparing hypotheses. MML is best understood through a communication process where a transmitter and a receiver are connected through one of Shannon's communication channels. The objective is that a transmitter must send some data D to the receiver. The transmitter and receiver must have previously agreed on a set of rules (that is, a code book) of communication using common knowledge and prior expectations. If the transmitter can find a good hypothesis, H * , to fit the data, (s)he will be able to transmit the data economically. In MML, an explanation of the data comes as a two part message:</p><p>(1) transmit the hypothesis H * taking l(H * ) bits, and</p><p>(2) transmit the observed data D given H * taking l(D|H * ) bits. Such a message paradigm ensures complete transparency in communication. That is, any information that is not common knowledge cannot be included except as a part of the message sent by the transmitter. Otherwise, the message sent will be indecipherable</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i44</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Piecewise linear approximation of structures using MML</head><p>by the receiver. There can be no hidden parameters in this framework of communication. In fact, this issue extends to stating and inferring real-valued parameters to an 'appropriate' level of precision, which is pertinent to the current problem on hand. The MML framework additionally offers 'safety' in that if an inefficient code is used to encode a message, it can only make the hypothesis look less attractive than otherwise. Note that MML yields a natural hypothesis test: the null-model corresponds to transmitting the data raw. If a stated hypothesis takes longer than what is required by a null-model, then clearly such an hypothesis is unacceptable. A more complex hypothesis fits the data better than a simpler model, in general. We see that MML encoding gives a trade-off between hypothesis complexity (l(H)), and its goodness of fit to the data (l(D|H)). Therefore, MML criterion formally justifies and realises Occam's razor. An important aspect of MML framework is that it is tolerant to measurement accuracy and noise in the underlying data. For a justification of this and a comprehensive study of the principle of MML, refer (<ref type="bibr" target="#b32">Wallace, 2005</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">FORMULATING THE PROBLEM USING MINIMUM MESSAGE LENGTH</head><p>A protein P ={P 1 ,··· ,P n } is a sequence 2 of n three-dimensional points corresponding to the coordinates (in R 3 ) of C α atoms along the protein backbone, from its N-to C-terminus. 3 Define a piecewise linear approximation of P as a subsequence of k ≤ n points from P of the form</p><formula>Q ={Q 1 ≡ P i 1 ,...,Q k ≡ P i k } such that 1 = i 1 &lt; ··· &lt; i k = n</formula><p>, and the first and last points of Q are the same as the first and last points of P (i.e.</p><formula>Q 1 = P 1 and Q k = P n</formula><p>). Given some subsequence Q of sequence of points P, the protein can be approximated (or simplified) using line segments drawn between every successive pair of points in the subsequence, Q r and Q r +1 , 1≤ r &lt; k. We will use the term delineation to describe this piecewise linear approximation. Further, we will use the term endpoint to describe any point in Q. This is because any pair of consecutive points,</p><formula>Q r ≡ P i r and Q r +1 ≡ P i r</formula><p>+1 , form endpoints for abstracting the points between P i r and P i r +1 (inclusive) in the protein with a line segment. Note that a subsequence Q with k endpoints yields a delineation containing k −1 line segments between successive endpoints. The goal this article is to find the best delineation of a given set of coordinate data, where the objective to select the best comes from defining the problem using the minimum message length criterion. Consistent to the communication process described in Section 2, the transmitter explains the data in P with a hypothesis Q and sends it as a message whose code length is globally minimum over all possible hypotheses. Receiver will then able to infer the entire data P from the received message to a reasonable level of precision using the general rules they have agreed upon as a part of the code book.</p><p>For the problem of delineating a structure from coordinate data, the transmitter will send the following two part message (refer Section 2):</p><p>(1) The first part is the subsequence of points Q which denotes the delineation of P. This is equivalent to transmitting the hypothesis Q in l(Q) bits.</p><p>(2) The second part will contain the remainder of points in P (that is, P −Q) that weren't sent in the first part. In other words, these are the points in P that are between the endpoints stated in Q. The statement of these points will be encoded as spatial deviations with respect to the line segments between endpoints. This is equivalent to transmitting the observed data P given the hypothesis Q over l(P|Q) bits.</p><p>Therefore, as a part of the codebook, the transmitter and receiver must have agreed upon the encoding of the endpoints in Q and the encoding of deviations of points P −Q explained by line segments between successive endpoints in Q. Since the coordinate data of proteins is available at some fixed precision, the transmitter and receiver agree on the specific precision at which the data should be sent. We emphasize that the encoding of the above should allow the receiver to decode the message to the agreed precision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CODE LENGTH TO STATE THE DELINEATION AND DATA UNDER MML CRITERION</head><p>In this section, we will discuss the statement and transmission of the two part message described in Section 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Encoding the first part of the message</head><p>The first part pertains to the transmission of the delineation Q containing k endpoints. The transmitter must therefore state the number of points k. There are several optimal universal prefix codes available to encode integers. Here, we use an asymptotically optimal Elias omega code which encodes the integral value k in log * k bits 4 (<ref type="bibr" target="#b11">Elias, 1975</ref>). Next, the coordinates of all endpoints are to be encoded. Each endpoint is a set of three real numbers of the form x,y,z . Published protein coordinate data contain three putatively significant figures after the decimal point, in Angstrom (Å) units. The transmitter can scale this data to one decimal precision and treat the coordinates as integers. Now, an optimal code to send these coordinates is for the transmitter to first send the coordinates of a bounding rectangular box, x min ,y min ,z min and x max ,y max ,z max over all possible values of x, y and z in the given data. Once this bounding box is specified, any (x,y,z) coordinates within the box can be coded in log(x max −x min )+log(y max −y min )+log(z max −z min ) = log (x max −x min )(y max −y min )(z max −z min ) = logV bits, where V is the volume of the bounding rectangular box. It follows from here that all the k endpoints in Q can be stated in k logV bits. 5 Therefore, the message length to state the first part of the transmission requires log * k +k logV bits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.S.Konagurthu et al.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Encoding the second part of the message</head><p>In the second part, the transmitter has to encode the data, P −Q, between endpoints stated in the first part of the message. For a successive pair of endpoints</p><formula>Q r ≡ P i ,Q r +1 ≡ P j ,1 ≤ i &lt; j ≤ n,1 ≤ r ≤ k</formula><p>in Q, there are j −i−1 intermediate points between P i and P j in P. In this work, these intermediate data points will be treated as noisy samples and will be stated as a set of spatial deviations with respect to the line segment between P i and P j. If such a scheme is used to communicate the second part of the message, for each line segment in Q between successive endpoints, the second part of the message will encode the following information:</p><p>(1) the number of points explained by the line segment.</p><p>(2) three spatial deviations for each intermediate point with respect to the line that will allow the receiver to recover the original location of the intermediate point up to a reasonable approximation.</p><p>(3) the parameters of the probability distribution associated with each of the three sets of spatial deviations, over all intermediate points. To explain the encoding of this part more clearly, consider<ref type="figure" target="#fig_0">Fig. 1</ref>. Let L ij denote the line segment between two successive endpoints in Q, Q r ≡ P i and Q r +1 ≡ P j. This line will be used to explain the intermediate points P i+1 ···P j−1 ∈ P. For any intermediate point P r , i+1 ≤ r ≤ j −1, define three spatial deviations s r ,t r and u r. In the reverse order, u r is the signed distance of P r to the plane defined by vectors P j −P i and z-axis. To define t r , first project P r to the plane defined above. Call this projection point P r. Given this projection, t r is the signed perpendicular distance of P r to the line L ij. Finally, the deviation s r is the (unsigned) lateral distance along the line L ij between points of projection of P r−1 and P r onto the line (<ref type="figure" target="#fig_0">Fig. 1</ref>). (Refer the supplementary note containing a discussion on these deviations under arbitrary rotation of the coordinates.) Note that once the endpoints P i and P j are specified, and given the sets of spatial deviations s r 's, t r 's and u r 's for the intermediate points P r ,∀i &lt; r &lt; j, the receiver can entirely recover the coordinates of all intermediate points. In this work, we assume the three spatial deviations s's, t's and u's of the intermediate points to be independent and normally distributed. Individual variables of each distribution are considered independent and random. (See supplementary note for a discussion on these assumptions.) Given these assumptions we have three distributions of the form:</p><formula>s ∼ N (µ s ,σ 2 s ), t ∼ N (µ t ,σ 2 t ), and u ∼ N (µ u ,σ 2 u )</formula><p>, where µ and σ 2 are the mean and variance of the respective normal distributions. For the structural coordinate data, we assume that the mean of the distributions of t's and u's is zero: t ∼ N (0,σ 2 t ), and u ∼ N (0,σ 2 u ). Therefore, to communicate the three distribution, the transmitter has to state the following four parameters:</p><formula>µ s ,σ 2 s ,σ 2 t ,σ 2 u .</formula><p>Consider the calculations of these parameters. For the line L ij , there are j −i−1 intermediate points. Represent this quantity by the variable m ij. Then</p><formula>µ s = j−1 r=i+1 s r m ij ≈ j r=i+1 s r m ij +1 = D ij m ij +1 ,</formula><p>where D ij is the Euclidean distance between P i and P j. Note that once the endpoints are transmitted (see Section 4.1), the receiver can deduce the value of µ s requiring no explicit statement for this parameter in the message. This reduces the number of parameters to be stated from four to three:</p><formula>σ 2 s ,σ 2 t ,σ 2 u</formula><p>. We will now compute the code lengths to state the variance of three normal distributions. Variance for a Gaussian distribution is simply 'mean squared minus squared mean':</p><formula>σ 2 s = j−1 r=i+1 (s r −µ s ) 2 m ij = j−1 r=i+1 s 2 r m ij −µ s 2 Similarly, we have σ 2 t = j−1 r=i+1 t 2 r m ij and σ 2 u = j−1 r=i+1 u 2 r m ij</formula><p>, since µ t = µ u = 0. We note that the code length for each parameter varies with 1 2 logm ij bits. [See Chapter 5 of (<ref type="bibr" target="#b32">Wallace, 2005)]</ref>. With the parameters of the distributions encoded, we will now compute the code lengths required to state the individual values of s's. Since we have assumed that the distribution is a Gaussian, the probability distribution of a random variable s r with parameters µ s and σ s 2 is given by:</p><formula>s r ∼ N (µ s ,σ s ) = 1 √ 2πσ s e − (sr −µ s ) 2 2σ 2 s</formula><p>Since we assumed that variables are independent, we havePage: i47 i43–i51</p><formula>p s i+1 ,...,,s j−1 |N (µ s ,σ 2 s ) = j−1 r=i+1 1 √ 2πσ s e − (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Piecewise linear approximation of structures using MML</head><p>This implies,</p><formula>p s i+1 ,...,,s j−1 |N (µ s ,σ 2 s ) = 1 √ 2πσ s m ij e −m ij 2 .</formula><p>Therefore, using Shannon's insight, the optimal code length to describe the entire sets of individual deviations of s's for a line L ij will require −log p</p><formula>s i+1 ,...,,s j−1 |N (µ s ,σ 2 s ) =−log 1 √ 2πσ s m ij e −m ij 2 = m ij 2 log 2πeσ 2 s bits.</formula><p>Following a similar expansion, we can show that the code lengths for the deviation t r 's and u r 's are</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Problem statement</head><p>Given a delineation Q (hypothesis) of coordinates P (data), denote the total message length required to explain the data by the hypothesis as H(Q). Combining the code lengths to state the two part message described in Sections 4.1 and 4.2, the total message length is:</p><formula>H(Q) = k−1 r=1 H r ij</formula><p>This allows us to formally define the delineation problem as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The problem:</head><p>Given P containing a sequence of n points, find a subsequence Q ∈ P containing k ≤ n points such that the total message length to explain</p><formula>P with Q, H(Q) = k−1 r=1 H r</formula><p>ij , is globally minimum.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">FINDING THE OPTIMAL DELINEATION</head><p>This section will describe the procedure to compute the optimal delineation Q * for a given coordinate data. Broadly, the search for the optimal delineation has two steps. Potentially every pair of points P i and P j , 1≤ i &lt; j ≤ n can be a part of the delineation in Q * . (We note here that the segments in the delineation must not overlap, except for successive regions, and those only at their endpoints.) Therefore, we will first build a matrix H = (H ij ) 1≤i&lt;j≤n of code lengths for all possible pairs of points in P. Then, the matrix H will be used to find a subsequence of points Q * such that the total code length H(Q * ) of the delineation is minimized, using a one-dimensional dynamic program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Computation of code length over all possible segments</head><p>Equation (2) expresses the message length H ij required to describe any line segment L ij between two points P i and P j. We will examine the complexity of computing each of the components that constitute Equation (2). For the n points in P, there are n</p><formula>C 2 = n×(n−1)</formula><p>2 possible line segments. The logV term in<ref type="bibr">Equation (2)</ref>is constant across all possible segments and is computed once while reading the data points of P. Next, for each line segment, there are three parameters whose code lengths depend on the number of points in between the endpoints. This is trivially computed in constant time as j −i−1. The relatively complex part is to compute the code lengths of the spatial deviations of the line, s's t's and u's. Each of these three deviations have code lengths that depend on their respective variance, σ 2 s ,σ 2 t and σ 2 u. While one can compute the variance of each set of deviations from the coordinate data, such a computation is linear in the number of points that each line segment explains. If this näive approach is followed, the computation of H requires O(n 3 ) operations. We will show in the later Section 6 that this is redundant and that the total time required to compute H can be achieved in O(n 2 ) operations, by computing the variances of all three spatialPage: i48 i43–i51</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.S.Konagurthu et al.</head><p>deviations incrementally from previous computations using a set of sufficient statistics. But before that we will describe the method to compute the optimal delineation given the matrix H.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Optimal delineation as a one-dimensional dynamic program</head><p>Dynamic programming is perfectly suited when dealing with problems that contain sequential constraints, where the solutions to the subproblems have a recursive overlapping substructure (<ref type="bibr" target="#b4">Bellman, 1957</ref>). The problem statement in Section 4.3 is an ideal candidate for the search strategy of dynamic programming. Since a delineation is a subsequence which preserves the linear ordering of its elements, the optimal delineation of the given data can be derived by computing and memoizing (i.e. caching) the optimal delineation of its subproblems. We will use the matrix H of code length between all possible endpoints to find the optimal delineation Q * that minimizes H(Q * ) using a one-dimensional dynamic program. Let C i be an array that stores the optimal code length of</p><formula>delineating points P 1 ,...,P i , ∀1 ≤ i ≤ n.</formula><p>The objective is to find the delineation of the given points where C n is minimum over all possible subsequences of the given points. Therefore, the recurrence relationship of optimal costs using a one-dimensional dynamic program is as follows:</p><formula>C 1 = 0, C j = j−1 min i=1 H 1j ,(C i +H ij ) ,∀1 ≤ j ≤ n</formula><p>In other words, the optimal code length to delineate the points P 1 ,...,P j (1 ≤ j ≤ n) builds on the optimal code length to delineate from P 1 ,...,P i , if and only if the value of C i plus the code length to state a new line segment H ij is minimum, over all 1 ≤ i &lt; j. Using the above relationship, the array C is filled iteratively from 1 to n. Upon completion, the value C n gives the optimal message length corresponding to the best delineation Q * of P, where H(Q * ) ≡ C n is globally minimum. The subsequence of endpoints of this optimal delineation can be computed by storing, for each j, the back pointer i &lt; j of the array from which the optimal value C j was derived. With these back pointers, a simple traceback from C n (until C 1 is reached) gives the set endpoints (in reverse order) that form the best delineation Q * .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">EFFICIENT COMPUTATION OF MATRIX H</head><p>As mentioned in Section 5.1 the matrix of code lengths H can be computed efficiently in O(n 2 ) operations and this section will show how this can be achieved. For the matrix H to be computable in O(n 2 ) operations, each element H ij in the matrix should be computable in constant time.</p><formula>However terms σ r s 2 , σ r t 2 , and σ r u 2 in Equation</formula><p>(2) cannot be computed in constant time. For a line segment L ij , näively, these three variances take time proportional to the number of points explained by the line to compute, leading to a O(n 3 ) algorithm for computing the matrix H. Below we will show that each of σ r</p><formula>s 2 , σ r t 2 , and σ r u 2</formula><p>can indeed be computed incrementally and in constant time from previous computations resulting in a O(n 2 ) algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Constant-time update of σ 2 s 's</head><p>Consider first these notations: for any vector v with direction ratios x,y,z, let ||v|| ≡ x 2 +y 2 +z 2 represents the vector norm of v. Let any point P i ∈ P have the direction ratios of the form x i ,y i ,z i. By the definitions of the spatial deviations in Section 4.2, any</p><formula>s r ,1 ≤ i &lt; r &lt; j ≤ n</formula><p>is the scalar associated with the projection of the vector (P r −P r−1 ) onto the vector L ij ≡ (P j −P i ). (Refer<ref type="figure" target="#fig_0">Fig. 1.</ref>) LetˆL Letˆ</p><formula>LetˆL ij = ˆ L x ij , ˆ L y ij , ˆ L z ij represent the direction cosines of the vector L ij , wherê L x ij = (x j −x i ) ||Lij|| , ˆ L y ij = (y j −y i ) ||Lij|| andˆLandˆ andˆL z ij = (z j −z i ) ||Lij||. Then s r is the dot product of (P r −P r−1 ) andˆLandˆ andˆL ij : s r = (P r −P r−1 )· ˆ L ij .</formula><p>Expanding this we get,</p><formula>s r = (x r −x r−1 ) ˆ L x ij +(y r −y r−1 ) ˆ L y ij +(z r −z r−1 ) ˆ L z ij Denoting S ij = j−1 r=i+1 s 2 r S ij = j−1 r=i+1 (x r −x r−1 ) ˆ L x ij +(y r −y r−1 ) ˆ L y ij +(z r −z r−1 ) ˆ L z ij 2 Expanding S ij , S ij = ˆ L x ij 2 j−1 r=i+1 (x r −x r−1 ) 2 + ˆ L y ij 2 j−1 r=i+1 (y r −y r−1 ) 2 + ˆ L z ij 2 j−1 r=i+1 (z r −z r−1 ) 2 +2ˆL+2ˆ +2ˆL x ijˆL ijˆ ijˆL y ij j−1 r=i+1 (x r −x r−1 )(y r −y r−1 ) +2ˆL+2ˆ +2ˆL y ijˆL ijˆ ijˆL z ij j−1 r=i+1 (y r −y r−1 )(z r −z r−1 ) +2ˆL+2ˆ +2ˆL x ijˆL ijˆ ijˆL z ij j−1 r=i+1 (x r −x r−1 )(z r −z r−1 ) (3) Now, let S xx ij , S yy ij , S zz ij , S xy ij , S yz ij , S xz</formula><p>ij be a set of variables which we will call here sufficient statistics. These variables are of the form:</p><formula>S AB ij = j−1 r=i+1 (A r −A r−1 )(B r −B r−1 )</formula><p>, where A and B take the values {x,y,z}. Expressing Equation (3) in terms of the sufficient statistics, we get</p><formula>S ij = ˆ L x ij 2 S xx ij + ˆ L y ij 2 S yy ij + ˆ L z ij 2 S zz ij +2ˆL+2ˆ +2ˆL x ijˆL ijˆ ijˆL y ij S xy ij +2ˆL+2ˆ +2ˆL y ijˆL ijˆ ijˆL z ij S yz ij +2ˆL+2ˆ +2ˆL x ijˆL ijˆ ijˆL z ij S xz ij (4)</formula><p>From Equation (4) it can be clearly seen that any S ij+1 can be updated from S ij in constant time, using the sufficient statistics. This holds because any S AB</p><formula>ij+1 = S AB ij +(A j −A j−1 )(B j −B j−1 ),</formula><p>where {A,B}∈{x,y,z}. Therefore, using the sufficient statistics the computation of σ s for a line segment can be computed incrementally in constant time. i48<ref type="bibr">[19:47 6/6/2011 Bioinformatics-btr240.tex]</ref>Page: i49 i43–i51</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Piecewise linear approximation of structures using MML</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Constant-time update of σ 2 t 's</head><p>Let n 1 be the normal to a plane defined byˆzbyˆ byˆz × L ij , wherê z is the unit vector along z-axis with the direction cosines 0,0,1. It follows that the direction ratios of</p><formula>n 1 are −(y j −y i ),(x j −x i ),0</formula><p>. Define n 2 as a vector which is normal to the plane L ij ×× n 1. The direction ratios of n 2 will be:</p><formula>−(x j −x i )(z j −z i ),−(y j −y i )(z j −z i ),(x j −x i ) 2 +(y j −y i ) 2 Letˆn Letˆ Letˆn 2 = ˆ n x 2 , ˆ n y 2 , ˆ n z 2</formula><p>represent the direction cosines of n 2 , wherêwherê</p><formula>n x 2 = −(x j −x i )(z j −z i ) || n 2 || , ˆ n y 2 = −(y j −y i )(z j −z i ) || n 2 || andˆnandˆ andˆn z 2 = (x j −x i ) 2 +(y j −y i ) 2 || n 2 || . Then t r = (P r −P i )· ˆ n 2 .</formula><p>(Refer<ref type="figure" target="#fig_0">Fig. 1.</ref>) This implies</p><formula>t r = (x r −x i )ˆ n x 2 +(y r −y i )ˆ n y 2 +(z r −z i )ˆ n z 2 Assume T ij = j−1 r=i+1 t 2 r and</formula><p>expanding along the steps we took in the previous section, we get</p><formula>T ij = ˆ n x 2 2 T xx ij + ˆ n y 2 2 T yy ij + ˆ n z 2 2 T zz ij +2ˆn+2ˆn x 2 ˆ n y 2 T xy ij +2ˆn+2ˆn y 2 ˆ n z 2 T yz ij +2ˆn+2ˆn x 2 ˆ n z 2 T xz ij (5)</formula><p>where computation of any T ij+1 can be updated from T ij in constant time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Constant-time update of σ 2 u 's</head><p>We have seen above that</p><formula>n 1 = −(y j −y i ),(x j −x i ),0 . LetˆnLetˆ Letˆn 1 = ˆ n x 1 , ˆ n y 1 ,0 represent the direction cosines of n 1 , wherê n x 1 = −(y j −y i ) || n 1 || , andˆnandˆ andˆn y 1 = (x j −x i ) || n 1 ||. (Notê n z 1 = 0). Then u r = (P r −P i )· ˆ n 1 .</formula><p>(Refer<ref type="figure" target="#fig_0">Fig 1.</ref>) Expanding as before we get</p><formula>U ij = ˆ n x 1 2 U xx ij + ˆ n y 1 2 U yy ij +2ˆn+2ˆn x 1 ˆ n y 1 U xy ij (6)</formula><p>where again the computation of any U ij+1 can be updated from U ij in constant time, when sufficient statistics are maintained. Therefore, the update rules in Equations (4)–(6) allows an efficient computation of the matrix H of code lengths in O(n 2 ) operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">RESULTS</head><p>In the previous sections, we have demonstrated an efficient and statistically robust algorithm to simplify a protein structure with piecewise linear segments. We implemented the described algorithm (in C++). Our implementation is available from http://www.csse .monash.edu.au/~karun/pmml/. We evaluated our method using a non-redundant dataset containing 15 399 protein structures obtained from the protein data bank (<ref type="bibr" target="#b5">Berman et al., 2002</ref>). (The non-redundancy here implies that no two structures in this dataset share a sequence identity &gt;65%.) This dataset was culled using the program PISCES (<ref type="bibr" target="#b33">Wang and Dunbrack, 2003</ref>). The list of proteins structures in the dataset and the results of their delineation produced by our method can be obtained from the aforementioned link.<ref type="figure">Figure 2</ref>gives the distribution of the measure of simplification of structures over the entire dataset. For a structure, the measure of simplification is the ratio of number of line segments identified by the program over the number of residues in the structure. On an average<ref type="figure" target="#tab_1">Table 1</ref>. Geometric profiles of ideal secondary structures used to classify coarsely the delineation identified by the program. φ and ψ are average backbone dihedral angles. n is the periodicity of the local structure. ρ is the rise. p is the pitchthe respective secondary structure assignments using DSSP and STRIDE. We note that both these programs assign secondary structure definitions at a residue level, while the coarse assignment for our method described above is at a segment level. Therefore, to enable a comparison between the methods we assign all residues within a segment to the segment level secondary structure state.<ref type="figure" target="#tab_2">Table 2</ref>gives the concordance of Helix 6 and Strand assignments between DSSP, STRIDE, and our method, PMML. Although even a coarse segment level assignment by our method produced a satisfactory concordance with DSSP and STRIDE, there is still a disagreement of ∼15% between PMML and the other two methods. Inspecting these differences we note that the majority of them came from the terminal parts of the segments delineated by our program. Therefore, we refine the coarse level assignment produced by PMML using the hydrogen bonding patterns of residues within each segment to reassign the secondary structure state at a residue level. We use a simple proximity (of backbone nitrogen and carbonyl groups) and angle (of N, O, C atoms) based computation of hydrogen bonds. Comparing our refined assignments at a residue level with DSSP and STRIDE we notice a substantial improvement in the concordance of helix and stand assignments with DSSP and STRIDE. (See rows 3 and 4 in<ref type="figure" target="#tab_2">Table 2</ref>.) We emphasize that although PMML can be used to generate protein secondary structure assignments, its real aim is to generate concise representations of structures, irrespective of the nature of the segments of which they are composed. For instance, PMML could be applied to RNA structures without needing any appeal to the types of substructure anticipated. Manually evaluating the delineation of a large number of structures we notice that although PMML's delineation identifies the regions of helix and strand consistently, there remain small discrepancies in assigning precise beginning and end residuesThe SSEs in the rows follow the order of their appearance along the chain of the protein from its N-to C-terminus. The column wwPDB gives the residue ranges of various SSEs as indicated in the wwPDB file 5NLL. The column PMML gives the corresponding residue ranges of the segmentation produced by PMML. of secondary structure elements as ascertained by an expert. To highlight these differences consider the following example of the delineation produced by PMML.<ref type="figure" target="#fig_2">Figure 3</ref>shows the structure of oxidized Clostridium beijerinckii flavodoxin. This protein binds a cofactor, flavin mononucleotide (FMN). Flavodoxin is a small α/β protein, containing a 5-stranded parallel β-sheet (β 1 ,...,β 5 ), with two helices packed against each face of the sheet (α A ,α E and α C ,α D ). There is also a short helix (α B ) located near the N-terminus of the protein. (<ref type="figure" target="#fig_2">Fig. 3.</ref>) Different segments produced by PMML are shown in different colors. The elements of secondary structure shown as thick ribbons are the secondary structure assignments taken from the structure's wwPDB file (5NLL).<ref type="figure" target="#tab_3">Table 3</ref>gives the residue ranges (that is, start and end residues) for each secondary structural element (SSE) of the flavodoxin structure listed in its wwPDB file. The residue ranges of the corresponding segmentation produced by PMML is also presented in the table. Broadly, the program correctly assigns segments to the SSEs. However, minor differences can be i50</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.S.Konagurthu et al.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Piecewise linear approximation of structures using MML</head><p>observed in the locations of their start and end residues. In most cases, we notice an absolute difference of 1 or 2 residues in the N-or C-terminal regions of these SSEs. The segmentation in the regions around the SSEs α E , β 2 and β 5 show some discrepancies. The residue range from wwPDB corresponding to α E was approximated by PMML using 2 segments instead of one. The first segment is composed of roughly one turn of the helix at α E 's N-terminal end. This is understandable as this turn is substantially skewed from the main helical axis and, indeed, there is an interruption in the hydrogen bonding. However, the second segment composed of 11 residues in this region is consistent with the assignment in the wwPDB file. In the case of β 2 , the start location identified by PMML precedes the start location identfied in the wwPDB file by four residues. On inspecting the flavodoxin structure, there appears to be a backbone hydrogen bond between the carbonyl group of residue Asp29 and the nitrogen of Met1 (of strand β 1 ), so the β 2 strand may well start at residue Lys28 or Asp29. Similarly, for β 5 , the start location of the segment from PMML was identified to be three residues before the location identified in the wwPDB file, and inspecting the structure, we note the β−bulge in strand β 5 , and hydrogen bonds between atoms 80O···109N and 82N···109O; assignment of the start of the strand β 5 to residue 109 is not indefensible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We have presented a novel and efficient method to delineate protein structures using the MML framework; MML is tolerant to measurement error and other inaccuracies. The model used in this work is independent of preconceived notions of what substructures are being sought to simplify the observed coordinate data. Our method maximizes the economy of representation while minimizing the loss of information, taking into account even the loop regions of proteins. Analysis of the delineations of a large number of protein structures suggests that the method is consistent in, among others, delineating standard secondary structures. The concise representations produced by this method have a potential use for rapid and accurate structure comparison and lookup. An implementation of our program is available from http://www.csse.monash.edu.au/~karun/pmml/.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Deviations s,t and u of intermediate points P i+1 ···P j−1 to a line segment between two endpoints P i and P j. (Refer main text.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>i47 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from [19:47 6/6/2011 Bioinformatics-btr240.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.3.</head><figDesc>Fig. 3. Wall-eye stereo image of 1.8 Å crystal structure of oxidized Clostridium beijerinckii flavodoxin. Each delineated segment produced by PMML is shown in a different color. The elements of secondary structures, of helices and strands of sheet, were derived from the wwPDB file, 5NLL, and are shown in this figure as thick ribbons. The labels of various secondary structures are also shown. The bound FMN co-factor is shown at the top of the structure as thin lines.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>m ij 2 log 2πeσ 2 t and m ij 2 log 2πeσ 2 u , respectively. So far in this second part, we have computed the code lengths required to state intermediate points explained by the line L ij. Note that a delineation of a structure containing k endpoints defines k −1 such line segments. For convenience in notation, assume the endpoints of each line segment is of the form (P i r ,P j r ),1 ≤ r &lt; k. (In practice, for a delineation, P i r of the r-th line segment is equivalent to P j r−1 of (r −1)th line segment.) Then the total code length of the second part is the sum of the following terms: (1) k−1 r=1 log * m r ij , where m r ij = j r −i r −1, representing the total code length to encode the number of intermediate points described by all line segments in the delineation put together.</figDesc><table>(2) 
k−1 

r=1 

3 

2 logm r 
ij bits to encode the parameters (three per 
line segment) corresponding to the distribution of spatial 
deviations for all lines. 

(3) 
k−1 

r=1 

m r 

ij 

2 log 


2πeσ r 

s 
2 


bits to encode s r 's over all line 
segments 

(4) 
k−1 

r=1 

m r 

ij 

2 log 


2πeσ r 

t 
2 


bits to encode t r 's over all line 
segments 

(5) 
k−1 

r=1 

m r 

ij 

2 log 


2πeσ r 

u 
2 


bits to encode u r 's over all line 
segments 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>H(Q) = log * k +k logV + k−1 r=1 log * m r ij + denotes the component code length to express each line segment L r ij with endpoints P i r and P j r , given a delineation Q. This implies</figDesc><table>k−1 

r=1 

3 
2 
logm r 

ij 

+ 
k−1 

r=1 

m r 

ij 

2 
log 


2πeσ r 

s 
2 


+ 
k−1 

r=1 

m r 

ij 

2 
log 


2πeσ r 

t 
2 

+ 
k−1 

r=1 

m r 

ij 

2 
log 


2πeσ r 

u 
2 


(1) 

Since log  *  k k logV , the transmitter can ignore stating that term in 
the code length. Assume 

H r 
ij = logV +log  *  m r 
ij + 

3 
2 
logm r 
ij + 

m r 

ij 

2 
log 


2πeσ r 

s 
2 

+ 
m r 

ij 

2 
log 


2πeσ r 

t 
2 


+ 
m r 

ij 

2 
log 


2πeσ r 

u 
2 


(2) 

H r 
ij </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Table 2.</figDesc><table>Percentage agreement of Helix and Strand assignments between 
various methods 

Comparison 
Helices (%) 
Strands (%) 

PMML (coarse)_vs_DSSP 
79.0 
83.3 
PMML (coarse)_vs_STRIDE 
79.3 
83.1 
PMML (refine)_vs_DSSP 
92.6 
92.4 
PMML (refine)_vs_STRIDE 
91.3 
92.1 
STRIDE_vs_DSSP 
95.7 
96.9 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>Table 3.</figDesc><table>The residue ranges of secondary structural elements (SSEs) in the 
structure of flavodoxin shown in Fig. 3 

SSE 
wwPDB 
PMML 

β 1 
Lys2-Trp6 
Met1-Tyr5 
α A 
Asn11-Glu25 
Asn11-Glu27 
β 2 
Asn31–Asn34 
Gly27-Ile33 
α B 
Ile40-Asn45 
Asn39-Glu46 
β 3 
Ile48–Cys53 
Asp47-Cys53 
α C 
Phe66-Lys76 
Glu65-Thr75 
β 4 
Lys81–Tyr88 
Gly79-Ser87 
α D 
Lys94-Gly105 
Gly91-Gly107 
β 5 
Leu115–Gln118 
Glu112-Gln118 
α E 
Asp122-Ile136 
Glu120-Gln126,Gln126-Ile136 

</table></figure>

			<note place="foot" n="1"> Banerjee et al. (1996) use a related minimum description length principle for their approach, which is a technique that was introduced a decade after Wallace and Boulton (1968) proposed the MML criterion. The two approaches are significantly different. See Wallace (2005) for a comparison.</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Page: i45 i43–i51</note>

			<note place="foot" n="2"> We use the term sequence in this paper to mean an ordered list. This should not be confused with the primary sequence of amino acids of a protein. 3 Assume that the protein P is oriented such that P 1 is the origin, P 2 lies on the positive x-axis, and P 3 lies on the xy-plane. This is one of the many possible schemes that ensures that our method is invariant to rotation and translation of the frame-of-reference in which the coordinate data is defined. (See supplementary note for a detailed discussion on this issue.)</note>

			<note place="foot" n="4"> log * x = logx +loglogx +··· (over all positive terms) 5 Note that the coordinates of the bounding rectangular box is a constant given the data, so it can be ignored at least for the purposes of comparing two hypotheses. i45 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from [19:47 6/6/2011 Bioinformatics-btr240.tex] Page: i46 i43–i51</note>

			<note place="foot">Fig. 2. Distribution of ratios of number of line segments over number of residues per structure in the dataset. Ratios are expressed in percentages and rounded to the nearest integral value. over the entire dataset the delineation size (that is, the number of line segments in the delineation) constitutes 13.85% of the total size of structure (in residues). In addition, the average segment length over the entire dataset is observed to be 8.11 residues. In general, the number of segments is correlated to total size of the protein structure. It is of considerable interest to evaluate the agreement of standard secondary structural elements—helices and strands of sheets—with the delineation identified by the program. We note that an ideal delineation of a structure must encompass these elements since they are ideal candidates for approximation with lines or vectors given the linear spatial trend in their geometry. In order to evaluate the agreement, we coarsely classify each segment to one of three secondary structure states: &apos;Helix&apos;, &apos;Strand&apos; and &apos;Other&apos;. This threestate classification is based on certain geometric characteristics of the segments in the delineation. Specifically, we compute the following geometric profiles for each segment: &apos;rise&apos;, &apos;pitch&apos; and backbone dihedral angles φ and ψ. The rise (ρ) of the segment with endpoints P i and P j is ρ = D ij /(j −i+1), where D ij is the Euclidean distance between the endpoints. In other words, the rise gives the average translation of points along the line between endpoints. The rise of a standard secondary structure is directly related to the pitch (p) of the segment. For a substructure with a geometry that repeats itself every n residues, the relationship between rise and pitch is given by p = nρ. Table 1 summarizes the geometric profiles of ideal secondary structures (Taylor, 2001). Inspecting these profiles per segment, a coarse characterisation for each segment in the delineation is achieved. Examining the coarse segment level assignment for the structures in the dataset, we note that the average length of segments assigned as &apos;Helix&apos; is 13.01 residues while the same for those assigned as &apos;Strand&apos; is 7.33 residues. To evaluate our coarse assignment, we choose two popular and extensively used secondary structure assignment programs, DSSP (Kabsch and Sander, 1983) and STRIDE (Frishman and Argos, 1995). DSSP and STRIDE assign each residue to one of multiple secondary structural states, including 3 10-, α-, π-helices and β-strands of sheet. For the structures in our dataset, we generate i49 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="6"> We do not distinguish between the three types of helices and treat them as one state.</note>

			<note place="foot">i51 at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank the anonymous referees for comments that improved the manuscript. L.A. and A.S.K. thank Nathan Hurst for useful pointers during the development of this work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">196</biblScope>
			<biblScope unit="page" from="47" to="53" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
	<note>btr240. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="51" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">A simple qualitative representation of polypeptide chain folds: comparison of protein tertiary structures</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">A</forename>
				<surname>Abagyan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<forename type="middle">N</forename>
				<surname>Maiorov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Biomol. Struct. Dyn</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="1267" to="1279" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">A minimum description length polygonal approximation method</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Banerjee</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Tech. Rep., RJ</title>
		<imprint>
			<biblScope unit="volume">10007</biblScope>
			<biblScope unit="page" from="1" to="19" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">Dynamic Programming</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Bellman</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1957" />
			<publisher>Princeton University Press</publisher>
			<pubPlace>Princeton, New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">The protein data bank</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">M</forename>
				<surname>Berman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Crystallogr. D Biol. Crystallogr</title>
		<imprint>
			<biblScope unit="volume">58</biblScope>
			<biblScope unit="page" from="899" to="907" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
	<note>Pt. 6 No 1</note>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Helix to helix packing in proteins</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Chothia</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="1981" />
			<biblScope unit="page" from="4146" to="4150" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Comparison of three algorithms for the assignment of secondary structure in proteins</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Colloc &apos;h</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Protein Eng</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="377" to="382" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Evaluation and improvement of multiple sequence methods for protein secondary structure prediction</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">A</forename>
				<surname>Cuff</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">J</forename>
				<surname>Barton</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="508" to="519" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Protein secondary structure assignment through Voronoi tessellation</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Dupuis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="page" from="519" to="528" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">A proposal of standard conventions and nomenclature for the description of polypeptide conformations</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Edsall</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="399" to="407" />
			<date type="published" when="1966" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Universal codeword sets and representations of the integers</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Elias</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="194" to="203" />
			<date type="published" when="1975" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Knowledge-based protein secondary structure assignment</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Frishman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Argos</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="566" to="579" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and geometrical features</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Kabsch</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Sander</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biopolymers</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="2577" to="2637" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Contact patterns between helices and strands of sheet define protein folding patterns</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">P</forename>
				<surname>Kamat</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">M</forename>
				<surname>Lesk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins: Structure, Function, and Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">66</biblScope>
			<biblScope unit="page" from="869" to="876" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Concise tableau representation of protein folding patterns</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">S</forename>
				<surname>Konagurthu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">M</forename>
				<surname>Lesk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Recogn</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="253" to="257" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Structural search and retreival using tableau representation of protein folding patterns</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">S</forename>
				<surname>Konagurthu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="645" to="651" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">P-SEA: a new efficient assignment of secondary structure from c alpha trace of proteins</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Labesse</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Appl. Bio. Sci</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="291" to="295" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">How different amino acid sequences determine similar protein structures: The structure and evolutionary dynamics of the globins</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">M</forename>
				<surname>Lesk</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Chothia</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">136</biblScope>
			<biblScope unit="page" from="225" to="230" />
			<date type="published" when="1980" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Systematic representation of protein folding patterns</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">M</forename>
				<surname>Lesk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="159" to="164" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Automatic identification of secondary structure in globular proteins</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Levitt</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Greer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">114</biblScope>
			<biblScope unit="page" from="181" to="239" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">PALSSE: A program to delineate linear secondary structural elements from protein structures</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Majumdar</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">202</biblScope>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Comparison of spatial arrangements of secondary structural elements in proteins</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Mizuguchi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Go</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Protein Eng</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="353" to="362" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">The anatomy and taxonomy of protein structure</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">S</forename>
				<surname>Richardson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Adv. Protein Chem</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="167" to="339" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Identification of structural motifs from protein coordinate data: secondary structure and first-level supersecondary structure</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<forename type="middle">M</forename>
				<surname>Richards</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">E</forename>
				<surname>Kundrot</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="71" to="78" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">A mathematical theory of communication</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">E</forename>
				<surname>Shannon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bell Syst. Tech. Jrnl</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="379" to="423" />
			<date type="published" when="1948" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Searching for three-dimensional secondary structural patterns in proteins with ProSMoS</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Shi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="1331" to="1338" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Describing protein structure: a general algorithm yielding complete helicoidal parameters and a unique overall axis</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Sklenar</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="46" to="60" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">A physical basis for protein secondary structure</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Srinivasan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">D</forename>
				<surname>Rose</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="14258" to="14263" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">A elipsoidal approximation of protein shape</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">R</forename>
				<surname>Taylor</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Graphics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="30" to="38" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Defining linear segments in protein structures</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">R</forename>
				<surname>Taylor</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">310</biblScope>
			<biblScope unit="page" from="1135" to="1150" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">An information measure for classification</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">S</forename>
				<surname>Wallace</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">M</forename>
				<surname>Boulton</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comp. J</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="185" to="194" />
			<date type="published" when="1968" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<monogr>
		<title level="m" type="main">Statistical and Inductive Inference using Minimum Message Length. Information Science and Statistics</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">S</forename>
				<surname>Wallace</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">PISCES: a protein sequence culling server</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Wang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">L</forename>
				<surname>Dunbrack</surname>
			</persName>
		</author>
		<author>
			<persName>
				<surname>Jr</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1589" to="1591" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>