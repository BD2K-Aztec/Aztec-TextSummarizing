
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:38+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An efficient parallel algorithm for accelerating computational protein design</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Yichao</forename>
								<surname>Zhou</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Institute for Theoretical Computer Science (ITCS)</orgName>
								<orgName type="department" key="dep2">Institute for Interdisciplinary Information Sciences</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">P. R. China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Wei</forename>
								<surname>Xu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Institute for Theoretical Computer Science (ITCS)</orgName>
								<orgName type="department" key="dep2">Institute for Interdisciplinary Information Sciences</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">P. R. China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Bruce</forename>
								<forename type="middle">R</forename>
								<surname>Donald</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Duke University</orgName>
								<address>
									<postCode>27708</postCode>
									<settlement>Durham</settlement>
									<region>NC</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Biochemistry</orgName>
								<orgName type="institution">Duke University Medical Center</orgName>
								<address>
									<postCode>27708</postCode>
									<settlement>Durham</settlement>
									<region>NC</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Jianyang</forename>
								<surname>Zeng</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Institute for Theoretical Computer Science (ITCS)</orgName>
								<orgName type="department" key="dep2">Institute for Interdisciplinary Information Sciences</orgName>
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<postCode>100084</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">P. R. China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An efficient parallel algorithm for accelerating computational protein design</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="page" from="255" to="263"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu264</idno>
					<note>BIOINFORMATICS Contact: Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Structure-based computational protein design (SCPR) is an important topic in protein engineering. Under the assumption of a rigid backbone and a finite set of discrete conformations of side-chains, various methods have been proposed to address this problem. A popular method is to combine the dead-end elimination (DEE) and A* tree search algorithms, which provably finds the global minimum energy conformation (GMEC) solution. Results: In this article, we improve the efficiency of computing A* heuristic functions for protein design and propose a variant of A* algorithm in which the search process can be performed on a single GPU in a massively parallel fashion. In addition, we make some efforts to address the memory exceeding problem in A* search. As a result, our enhancements can achieve a significant speedup of the A*-based protein design algorithm by four orders of magnitude on large-scale test data through pre-computation and parallelization, while still maintaining an acceptable memory overhead. We also show that our parallel A* search algorithm could be successfully combined with iMinDEE, a state-of-the-art DEE criterion, for rotamer pruning to further improve SCPR with the consideration of continuous side-chain flexibility. Availability: Our software is available and distributed open-source under the GNU Lesser General License Version 2.1 (GNU, February 1999). The source code can be downloaded from</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Structure-based computational protein design (SCPR) provides a promising tool in a wide range of protein engineering applications, such as drug design (<ref type="bibr" target="#b11">Gorczynski et al., 2007</ref>), enzyme synthesis (<ref type="bibr" target="#b2">Chen et al., 2009</ref>), drug resistance prediction (<ref type="bibr" target="#b6">Frey et al., 2010</ref>) and design of protein–protein interactions (<ref type="bibr" target="#b24">Roberts et al., 2012</ref>). The basic idea of SCPR is to find a new amino acid sequence based on a known structure, such that the total energy of the resulting molecular complex is minimized. In general, it is difficult to model an ideal protein design framework with the consideration of full backbone and side-chain flexibility, since there are usually a huge number of conformations that need to be sampled even for a small protein. Therefore, in practice assumptions are often made to reduce the complexity of the protein design problem. In most of protein design models (<ref type="bibr" target="#b24">Roberts et al., 2012</ref>), the backbone structure is assumed as a rigid body, and only side-chains are allowed to rotate among a finite set of discrete conformations, called the rotamer library. Under the rigid backbone assumption, the goal of SCPR is to search over all possible combinations of side-chain rotamer conformations of different allowed amino acids, trying to find the global minimum energy conformation (aka GMEC). Unfortunately, this problem has been proven NP-hard (<ref type="bibr" target="#b1">Chazelle et al., 2004;</ref><ref type="bibr" target="#b22">Pierce and Winfree, 2002</ref>). Thus, a number of heuristic methods, such as Monte Carlo and genetic algorithms, have been proposed to find the approximate solutions to this problem (<ref type="bibr" target="#b15">Kuhlman and Baker, 2000;</ref><ref type="bibr" target="#b19">Marvin and Hellinga, 2001;</ref><ref type="bibr" target="#b29">Shah et al., 2004;</ref><ref type="bibr" target="#b31">Street and Mayo, 1999</ref>). A recent study also suggests that we can split the entire task into small pieces so that a large-scale protein design problem can be solved in parallel (<ref type="bibr" target="#b23">Pitman et al., 2014</ref>). However, these approaches cannot provide any provable guarantee of finding the global optimal solution (i.e., GMEC) as they may get trapped in a local optimum. In contrast, provable algorithms, such as tree decomposition (<ref type="bibr" target="#b32">Xu and Berger, 2006</ref>), integer linear programming with a branch-and-bound technique (<ref type="bibr" target="#b0">Althaus et al., 2002;</ref><ref type="bibr" target="#b13">Kingsford et al., 2005</ref>), dead-end elimination (DEE;<ref type="bibr" target="#b4">Desmet et al., 1992</ref>) and A* search (<ref type="bibr" target="#b5">Donald, 2011;</ref><ref type="bibr" target="#b16">Leach et al., 1998;</ref><ref type="bibr" target="#b18">Lippow and Tidor, 2007</ref>) assure that GMEC will be outputted as a final solution. In particular, the combination of DEE and A* search is popular in computational protein design (<ref type="bibr" target="#b5">Donald, 2011;</ref><ref type="bibr" target="#b18">Lippow and Tidor, 2007</ref>). In this design strategy, DEE is first applied to prune a large number of unfavorable rotamers that are provably not part of the optimal solution. Next, the A* algorithm is used to search over all possible combinations of the remaining rotamers and compute the GMEC solution. A number of DEE criteria have been proposed to improve the rotamer pruning and reduce the complexity of the rotamer conformation search space (<ref type="bibr" target="#b7">Gainza et al., 2012;</ref><ref type="bibr" target="#b10">Georgiev et al., 2008</ref><ref type="bibr" target="#b9">Georgiev et al., , 2006</ref>). Although DEE can prune most rotamer conformations in the problem space, the A* algorithm still runs in exponential time in the worst case. In the DEE and A*-based framework, A* is generally one of the most time-consuming parts, especially for large-scale protein design problems. Thus it is vital to propose a faster algorithm to alleviate this bottleneck and therefore accelerate the protein design process. In this article, we develop an efficient parallel A* tree search algorithm to accelerate computational protein design. By optimizing and parallelizing the computation of heuristic functions and the underlying data structure (i.e., the priority queue) for A* search, our algorithm significantly speeds up the A* search *To whom correspondence should be addressed. ß The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com process. Our approach fully exploits the capacity of parallelism on a Graphics Processing Unit (GPU) to support the A* search for protein design. Tests on a benchmark dataset of 74 proteins show that our new algorithm runs up to 20 000 times faster than the original A*-based protein design algorithm, while still maintaining an acceptable amount of memory overhead. Thus, our parallel A* search algorithm can provide a practically useful tool for computational protein design.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">General-purpose computing on GPUs</head><p>General-purpose computing on graphics processing units (aka GPGPU), is a method to use a GPU together with a CPU to accelerate traditional computation. The main difference between CPU and GPU computational frameworks lies in the mechanisms they use to process calculation tasks. A CPU usually contains several highly optimized cores for sequential instruction execution, while a GPU typically contains thousands of simpler but efficient cores which are able to process different tasks in parallel. As an example, a high-end GPU, AMD Radeon 7970 Tahiti XT, has 2048 processing elements, while a powerful CPU such as Intel Xeon E7-8870 only contains 10 cores. Because of this characteristic, we must modify our algorithms originally designed for a CPU to take advantage of a large amount of parallelism to bring the full power of a GPU into play. A GPU typically has a better performance in floating-point operation than a same-price CPU. For example, an NVIDIA GeForce GTX 580M has 952.3 theoretical GFLOPS (giga floating-point operation per second), while the theoretical GFLOPS of Intel Core i7-3960 is only 158.4, according to the specification released by Intel (<ref type="bibr">Intel Corporation, 2011</ref>) and NVIDIA (NVIDIA Corporation, 2013), respectively. In our protein design problem, the main bottleneck is the floating-point operations for the heuristic function evaluation. Therefore, GPU acceleration is an appropriate tool to address such a problem. A GPU has its own memory system. Thus it can provide a larger memory bandwidth than that of a CPU, which means GPU cores can retrieve and write data from/to the global memory faster than a CPU. This is especially suitable for those algorithms that are limited by the global memory bandwidth. However, before and after the computation, data need to be transferred between the memory of CPU and GPU through a relatively slow PCI-E bus. Thus, in general, we prefer a smaller ratio between the amount of time used to transfer input/output and the amount of time spent on computation. The A* search algorithm is suitable for such a computation framework, as the amount of floating-point computation makes the data transfer overhead negligible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">An A* search algorithm for protein design</head><p>In this section, we will first give some background about using A* algorithm to solve the protein design problem. In Section 2.2.1, we will provide a new approach to improve the computation of heuristic function in A* search. After that, Sections 2.3 and 2.4 will present a two-level parallelized A* algorithm that is suitable for a modern GPU. Finally, Section 2.5 will provide an extended A* algorithm that runs in bounded memory. Under the assumption of a rigid backbone and discrete side-chain rotamers, SCPR can be generally formulated as an optimization problem, in which we aim to find an amino acid or rotamer sequence that minimizes the following objective function using 1-and 2-body energies:</p><formula>E T =E 0 + X ir2A E 1 ði r Þ+ X ir2A X js2A; i5j E 2 ði r ; j s Þ; ð1Þ</formula><p>where A is the set of discrete side-chain rotamer conformations (typically called the rotamer library), E 0 is the backbone or template energy, E 1 (i r ) is the self energy of rotamer r for residue i (including intra-residue and rotamer-to-backbone energies), and E 2 (i r ,j s ) is the pairwise interaction energy between rotamer i r and j s. The global optimal solution, i.e., GMEC, minimizes the above energy function in Equation (1). The combination of DEE and A* search algorithm has been popularly used in computational protein design (<ref type="bibr" target="#b5">Donald, 2011;</ref><ref type="bibr" target="#b8">Gainza et al., 2013;</ref><ref type="bibr" target="#b10">Georgiev et al., 2008;</ref><ref type="bibr" target="#b16">Leach et al., 1998;</ref><ref type="bibr" target="#b17">Lilien et al., 2005;</ref><ref type="bibr" target="#b18">Lippow and Tidor, 2007;</ref>). In this protein design strategy, the DEE algorithm is first applied to prune a number of rotamers that are provably not part of the optimal solution that minimizes the energy function in Equation (1). Next, an A* tree search algorithm is used to search over all possible combinations of the remaining rotamers and find the global optimal solution (i.e., GMEC). Traditional implementations of the A* search algorithm for protein design take a priority queue to decide the order of visiting nodes in the tree search. In this priority queue, elements are sorted by the following heuristic function as the evaluation measure for each expanding rotamer: fðxÞ=gðxÞ+hðxÞ; ð2Þ where g(x) represents the actual cost from the starting node (i.e., the root of the A* search tree) to the current node x, and h(x) represents the estimated cost from the current node x to its destination (i.e., a leaf node in the A* search tree). Each time, we extract a node with the smallest heuristic function value from the priority queue, expand it and then push the new expanded nodes back into the priority queue. We repeat this process until a target node (which is one of the leaf nodes with the minimum heuristic function value in the search tree) is found. Algorithm 1 describes a single-thread version of the traditional A* search procedure.</p><p>Algorithm 1 A single-thread version of the traditional A* search 1: procedure A-STAR(s, T) . s is the starting node and T is 2: Let Q be a priority queue . the set of target nodes 3: Q 1 4: PUSH(Q, s) 5: while Q is not empty do 6: q POP(Q) 7: if q 2 T then 8: return the path found 9: end if 10: Let R be the set of expanded nodes from q 11: Calculate f(x) for all nodes in R 12: Push all the elements from R into Q 13: end while 14: end procedure</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Improved computation of heuristic functions</head><p>In the A* search algorithm for solving the protein design problem, the actual cost from the starting node to current node x in the search tree is defined by</p><formula>gðxÞ=E 0 + X ir2DðxÞ E 1 ði r Þ+ X ir2DðxÞ X js2DðxÞ; i5j E 2 ði r ; j s Þ; ð3Þ</formula><p>where D(x) is the set of residues in which rotamers have been already determined so far, E 0 is the backbone energy, E 1 (i r ) is the self energy of rotamer i r (including both intra-residue and rotamer-to-backbone energies), and E 2 (i r ,j s ) is the pairwise interaction energy between rotamers i r and j s. The estimated cost from current node x to the destination node is defined byA brute-force method of calculating heuristic function f(x) = g(x) + h(x) takes O(n 2 m 2 ) floating-point operations, where n is the length of protein sequence and m is the maximum possible number of rotamers per residue. Thus, it takes O(n 2 m 2 t) floating-point operations to compute heuristic functions for all nodes in the whole A* search tree using this brute-force method, where t is the total number of expanded nodes in the search tree. However, our analysis of Equation (4) reveals that we do not need to spend O(nm) time in repeatedly calculating X k2UðxÞ min u E 2 ði r ; k u Þ each time when we evaluate the heuristic function. Since we search the conformation space residue by residue, there are only n possibilities for U(x). Therefore, we can use a two-dimension table T[U(x),i r ] to pre-compute all these possible values. This pre-computation process takes O(n 2 m) memory and O(n 3 m 2 ) floating-point operations, but reduces time complexity of calculating f(x) down to O(n 2 m) when expanding a new node. Again suppose that the total number of expanded nodes in the final A* search tree is t. Then we bring down the overall time complexity from O(n 2 m 2 t) to O(n 3 m 2 + n 2 mt), which greatly improves the practical efficiency of the algorithm because in general t ) n. We have also applied some technique to improve the computation of the g(x) function, which reduces its computational complexity from O(n 2 ) to O(n). More details of the improved computation of g(x) can be found in Supplementary Material Section S1.</p><formula>hðxÞ= X i2UðxÞ r minðE 1 ði r Þ+ X js2DðxÞ E 2 ði r ; j s Þ+ X k2UðxÞ u minE 2 ði r ; k</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Parallelized computation of heuristic functions</head><p>model well, mainly due to the high overhead of synchronization and branch divergence. To address the aforementioned problems, we propose a new and parallel version of the A* search algorithm to fully exploit the power of parallelism in a GPU for accelerating protein design. This algorithm is mainly based on the observation that we do not need to extract the k lowest-energy conformations with the smallest f(x) values in gap-free sorted order. In fact, we only need to assure that the element with the smallest heuristic function value is extracted, and do not have to restrict others. In our algorithm, we allocate hundreds of priority queues, and then let each thread operate on its own priority queue. Suppose we allocate k priority queues in total. The basic idea of our algorithm includes the following key steps:</p><p>(1) Launch k threads to pop k minimum elements from k priority queues in parallel;</p><p>(2) For each thread, expand new nodes for the extracted element;</p><p>(3) Launch enough threads to perform parallelized computation of heuristic functions, using the procedure described in Section 2.3; and</p><p>(4) Launch k threads to push all expanded nodes back into k priority queues.</p><p>The pseudocode of our algorithm, GA*, can be found in Algorithm 2.</p><p>More details of this parallel algorithm are illustrated in<ref type="figure" target="#fig_1">Figure 1</ref>. The<ref type="figure" target="#fig_1">Fig. 1</ref>. Flow chart of our GA* search algorithm for accelerating protein design. Symbols r i represent all parallel expanded rotamers, and p is the total number of expanded nodes. A shaded and rounded square represents a global state, which can be regarded as a global synchronization point. The directional black edges mean that the procedure needs to be done between two synchronization points. The dashed arrows and the double bold arrows represent the data flow among different states and the priority queues, respectively. A group of similar arrows means that the operations are performed in parallel i257</p><p>A parallel algorithm for accelerating computational protein design parallelism employed in our algorithm can directly address all the previously mentioned computational bottlenecks in A* search and thus greatly speed up the computational protein design process. In addition, our new algorithm introduces small overhead. It only requires a constant number of global synchronization points per round without much communication overhead. Note that this pseudocode is just for computing the GMEC solution. Our algorithm can be easily extended to output all solutions within a specific energetic cutoff from the GMEC solution in gap-free sorted order, using the same strategy as in OSPREY (<ref type="bibr" target="#b2">Chen et al., 2009;</ref><ref type="bibr" target="#b8">Gainza et al., 2013</ref>). Algorithm 2 GA*: a GPU parallel A* algorithm for protein design 1: procedure GA*(k, s, T) . k is the number of allocated 2: for i 1 to k in parallel do . priority queues, s is the 3: Let Q i be a priority queue . starting node, and T is 4: Q i 1 . the set of all target nodes, 5: end for 6: PUSH(Q 1 , s) 7: t nil . t stores the best solution hitherto 8: while 9Q i that is not empty do 9: R 1 10: for i be the index where Q i is not empty in parallel do 11:</p><formula>q i POP(Q i</formula><p>) 12: if q i 2 T then 13: if t=nil or f(p i )5f(t) then 14: t p i 15: end if 16: continue 17: end if 18: Let R 0 be the nodes expanded from q i. 19: R R [ R 0 20: end for 21: if t 6 ¼ nil and fðtÞ=min j fðp j Þ then 22: return t 23: end if 24: Reorder the nodes in R . See Section 2.6 25: Calculate f(x) for all nodes in R in maximum parallel 26: for i 1 to k in parallel do 27: Pick jRj/k nodes from R with different parents 28: Push them into Q i 29: end for 30: end while 31: end procedure</p><p>Note that the nodes to be expanded are not necessarily the most optimal nodes. For example, suppose we have two priority queues, and the 1st, 2nd, 3rd most optimal nodes are in the first priority queue while the 4th one is in the second queue. In this situation, our algorithm will pop out the 1st and 4th most optimal nodes, which is not an ideal situation. This is the price of the parallelism of the priority queue. We try to alleviate this problem by separating the nodes with the same parent nodes, which may have similar heuristic function values, to different queues. Because the parallelism of the priority queue changes the work flow of the overall A* algorithm, it is necessary to provide a proof to show that GA* is able to compute a global optimal solution. Here, our proof is derived mainly for the protein design problem, in which the underlying search graph is a tree.(2) When the algorithm terminates, it returns a solution that is not optimal.</p><p>For (1), it is impossible because the search space is a finite tree and our algorithm will never visit any node twice. For (2), assume that our algorithm returns a node t 1 , while the optimal solution is node t 2. Thus, we have f(t 1 )4f(t 2 ). However, according to Lemma 2.1, we have a node t 0 in the queues {Q i } that satisfies f(t 0 ) f(t 2 )5f(t 1 ), which violates the condition in line 21 of Algorithm 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>«</head><p>Theorem 2.2 states that GA* guarantees to find the global optimal solution. However, GA* does not retain all the properties that the original version of A* search has. The optimality property (<ref type="bibr" target="#b3">Dechter and Pearl, 1985</ref>), which guarantees that A* will expand fewer nodes than any other algorithm using the same heuristic function, is lost in GA*. The reason is that in GA*, it is possible to expand a node whose f(x) value is larger than the best solution due to the parallelism. However, as we will see in the Results section, the fraction of extra expanded nodes compared to the original A* algorithm is within an acceptable range.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Memory-bounded A* search for protein design</head><p>Although our parallel algorithm GA* can speed up the traditional A* algorithm by several orders of magnitude, the scale of the protein design problem that it can solve is still limited. For example, we may support at most 20 mutable residues if all types of amino acids are allowed in each residue. The bottleneck mainly lies in the limited memory available for each machine. In the worst case, A* produces an exponential number of expanded nodes in the search tree. Once the algorithm runs out of memory to store new expanded nodes, it cannot continue. Several efforts have been made to solve this problem. In particular, variants of the A* algorithm such as iterative deepening depth-first search (IDA*) (<ref type="bibr" target="#b14">Korf, 1985</ref>) and simplified memory-bounded A* (SMA*) (<ref type="bibr" target="#b26">Russell, 1992</ref>) have been proposed to address such an issue. IDA* uses a depth-firstsearch strategy to reduce the usage of memory, which is difficult to parallelize on a GPU. On the other hand, we found that SMA* could be well implemented on a GPU. We call this new algorithm GSMA*.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i258</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Y.Zhou et al.</head><p>SMA* is almost identical to a normal A* algorithm, with the only exception that if a new expanded node does not fit in memory, we simply throw away the least promising node in the queue, which has the worst f(x) value. Using this method, SMA* can still assure to generate the optimal solution when the memory is large enough for the original A* algorithm, while it may miss the optimal solution if the size of the priority queue exceeds the memory limit. In this case, although our algorithm cannot guarantee to find the GMEC solution, we can still know whether the solution returned by SMA* is a GMEC solution. This can be done by tracking the lowest f(x) value among all nodes that we have thrown away. If the energy of the returned solution is below this value, we know that SMA* finds the GMEC solution. Otherwise, we can report that the energy of the GMEC solution must lie in the interval between this value and energy of the solution found by SMA*. For GSMA*, when we run out of the memory, we first do a global scan operation (<ref type="bibr" target="#b28">Sengupta et al., 2007</ref>) to pick those nodes which are the leaves of the current searching tree, while freeing the memory occupied by the internal nodes that have already been expanded. Then a global sorting operation is performed over all the remaining nodes according to their f(x) values. Finally, we keep a user-specified percentage of nodes with the lowest f(x) values and then reconstruct the priority queues evenly, in which nodes are stratified by their heuristic function values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Implementation details</head><p>Our new parallel A* search algorithm is implemented based on the current open-source protein design package OSPREY (<ref type="bibr" target="#b2">Chen et al., 2009;</ref><ref type="bibr" target="#b8">Gainza et al., 2013</ref>). The CPU code is written in C and the GPU code is written in CUDA. As the OSPREY library is implemented in Java, we use Java Native Interface (JNI) to communicate with the native C program. At the beginning, our program copies the configuration and necessary information such as energy matrix and the original sequence from CPU memory to the global memory of a GPU. Then it allocates memory space for the nodes generated by GA* and a user-specified number of binary heaps. Each element in a binary heap stores a floating-point value of f(x) and a pointer to its corresponding node x. After initializing the GPU data structure, the GPU circulates among the four states as shown in<ref type="figure">Figure 2</ref>until a valid solution is found. Compared to<ref type="figure" target="#fig_1">Figure 1</ref>, we add a new RADIX-SORTING state. In the EXTRACTION phase, GA* launches a user-specified number of threads, each of which operates on its own priority queue and performs the DELETE-MINIMUM operation to extract the node with the minimum f(x) value. Each priority queue is a vanilla binary heap. In addition, GA* checks whether the extracted node of the current thread is the optimal target node. Also, the expanding operation is done in this phase, which generates the children of the extracted nodes and then puts them into a global buffer.</p><p>The second phase is RADIX-SORTING, which corresponds to line 24 in Algorithm 2. In this phase, the expanded nodes are sorted by their current depth, that is, the number of decided rotamers, before entering the EVALUATION phase. The major motivation for this phase is that the range of the loop during the calculation of f(x) heavily depends on the depth of the corresponding node in the search tree. Thus, after sorting, all the threads in a single SIMD unit of a GPU will tend to have the same length of the loop during the evaluation phase, which thus can reduce the branch divergence overhead and improve the efficiency of the parallelized computation of heuristic functions. There are several efficient sorting algorithms available for GPUs, such as (<ref type="bibr" target="#b26">Satish et al., 2009;</ref><ref type="bibr" target="#b30">Sintorn and Assarsson, 2008</ref>). As the number of elements to be sorted is not that large, we choose a classical and simple method, the GPU radix-sorting (<ref type="bibr" target="#b28">Sengupta et al., 2007</ref>), to perform this task. In the EVALUATION phase, GA* launches the same number of threads as the number of expanded nodes to calculate the heuristic function of each node in order to exploit the full floating-point operation capacity of a GPU. Our tests show that a GPU would spend more than 80% time in this phase. Thus parallelizing the calculation of heuristic functions in this phase can significantly reduce the running time of A* search for protein design. Section 2.3 explains more details about parallelizing computation of heuristic functions in this phase. In the final PUSHING-BACK phase, GA* pushes all the expanded nodes with their heuristic function values back into the priority queues, using the classical INSERT procedure of a binary heap. In addition, GA* pushes the different expanded nodes into priority queues so that the sizes of these queues are balanced and the new expanded nodes with the same parents, which may have similar heuristic function values, are stored in different queues. provably not in the part of the global optimal solution. The iMinDEE algorithm can give a more accurate result on rotamer pruning, but results in a much larger conformation space for the downstream A* algorithm to search over to find the GMEC solution. Strictly speaking, we are not trying to find the GMEC solution in A* when using iMinDEE. We are trying to find the lowest-energy bound conformation for iMinDEE. But from the point view of an A* algorithm, it treats that job as same as finding the GMEC solution. So we will not distinguish these terminologies in the Results section. In this part of the experiment, memory-bounded operations were not performed. Because GA* is a provable algorithm (see Theorem 2.2 in Section 2.4), it can still guarantee to find the optimal solution. For correctness, we also verified that our results are completely identical to those of original OSPREY. The CPU and GPU we used in this benchmark test were an Intel Xeon TM E5-1620 3.6 GHz with 16 GB memory and an NVIDIA Tesla K20c GPU with 4.8 GB global memory and 2496 CUDA cores, respectively. The main point of this test is to measure the speed and the memory consumption of our algorithm, the results of which can be found in Tables 1 and 2, respectively. We ran the full experiment over all 74 protein structures, but we only show the list of the 10 slowest cases here as the others were finished too quickly even for the original A* algorithm implemented in OSPREY after rotamer pruning using iMinDEE. The results of all tests can be found in Tables S1 and S2 in Supplementary Material Section S3. In our GA* algorithm, the number of parallel priority queues, as described in Section 2.4, is a parameter that we can tune for the maximum performance. By increasing the number of priority queues, we can increase the degree of parallelism and further exploit the capability of the GPU hardware. On the other hand, when more parallel priority queues are used, the number of extra expanded nodes in the tree search compared to the original A* algorithm will also increase, which will cause both computation and memory overhead. In our computational experiments, we tested two choices of this parameter. One is 768, designed for the balance between time and space consumption. The other is 4992, targeting at maximizing the protein design speed. From<ref type="figure" target="#tab_1">Table 1</ref>, we found that our parallel A* algorithm GA* can speed up the original A*-based protein design algorithm by several orders of magnitude. For the largest protein design problem related to 2QCP, the original A*-based protein design algorithm took $6 h, while GA*4992 (i.e., GA* algorithm that used 4992 parallel priority queues) was able to finish the search in 1.2 s. Such improvement is striking. In addition, as summarized in<ref type="figure" target="#tab_2">Table 2</ref>, the larger the conformation search space is, the more impact GA* will have. This is because for large problems, GA* is able to better exploit its parallelism, amortizing the overhead to a negligible level. Furthermore, the test results on the memory consumption of GA* (<ref type="figure" target="#tab_2">Table 2</ref>) were also promising. Although for small-scale protein design problems, memory consumption of GA*4992 was several times higher than that of a single-thread version, the discrepancy in memory consumption became more and more negligible when the conformation space scaled up. For the largest design problem related to 2QCP, GA*4992 only generated 1.12 times more nodes than the single-thread algorithm. Therefore, such small growth of memory requirement was acceptable compared to the large improvement on time efficiency achieved by our algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Parallel protein design with bounded memory</head><p>Memory limitation is always a problem when we are conducting large-scale protein design. Although GSMA* can solve this problem, it does not guarantee to generate a GMEC solution anymore. Therefore, it is necessary to evaluate the quality of its solutions when the memory resource is not sufficient. Researches have shown that the sequences of native proteins tend to optimize their core structures for stability (<ref type="bibr" target="#b7">Gainza et al., 2012;</ref><ref type="bibr"></ref>Notes: Time was measured in millisecond. The results were sorted by the running time needed by OSPREY and only the 10 largest cases are listed here. a The second column, labeled with 'Space', reports the size of conformation search space after the rotamer pruning using iMinDEE. b The third column, labeled with 'OSPREY', reports the running time of the original A* algorithm in OSPREY implemented in Java. c The fourth column, labeled with 'A*1', reports the running time of our new implementation of a single-thread A* algorithm written in C programming language running on a CPU, which adopted the improved computation of heuristic functions, as described in Section 2.2.1. d The fifth and sixth columns, labeled with 'GA*768' and 'GA*4992', respectively, report the running time of two fully parallelized A* algorithms running on a GPU, whose numbers of parallel priority queues are 768 and 4992, respectively.Note: Each column has the same meaning as that in<ref type="figure" target="#tab_1">Table 1</ref><ref type="bibr" target="#b15">Kuhlman and Baker, 2000</ref>). Therefore we included the native sequence recovery experiments, in which we removed the types of some amino acids from the core of the wild-type proteins and recorded the percentage of correctly recovered residues by the design algorithm as an indicator of its quality besides other direct critera. We randomly picked six PDBs from the protein sequence recovery dataset provided in (<ref type="bibr" target="#b7">Gainza et al., 2012</ref>) to evaluate performance of our parallel GA* with limited memory (i.e., GSMA*). Unlike Section 3.1 in which we did not change any parameters on the original test dataset, this time we increased the number of mutable residues so that the total number of new nodes expanded by GA* just fitted the physical memory limit of the GPU without throwing any of them away, which had $3 Â 10 7 nodes. We did this because we need to have a set of optimal solutions as a reference for comparison, and we hoped that all the test data had the similar memory consumption so that their performance was comparable. The method for choosing the set of allowed amino acids and the positions of extra mutable residues was as same as that in (<ref type="bibr" target="#b7">Gainza et al., 2012</ref>). The number of parallel priority queues in this experiment was fixed to 768. We ran our experiments four times per test data. Each time we imposed a different restriction on the number of nodes that GSMA* was allowed to expand, which was 3 Â 10 4 , 3 Â 10 5 , 3 Â 10 6 and 3 Â 10 7 , respectively. These restrictions can be approximately considered as using 1000th, 1%, 10% and 100% of memory needed by GA*. Each time the system ran out of memory, 50% of the nodes with larger f(x) values were thrown away. We use four metrics to evaluate the quality of our algorithm. The first one is the availability of the GMEC solution. The second one is whether GSMA* is able to determine that the first solution it found is the GMEC solution. We have described this method in Section 2.5. The other two metrics are based on the first 50 solutions returned by A* rather than the GMEC solution. The third metric, correctness, measures the percentage of the top 50 solutions calculated with memory restriction that were also presented in the top 50 solutions calculated without such restriction. The fourth metric, recovery rate, reports the average percentage of amino acids in the top 50 solutions that are identical to those in the wild-type protein.<ref type="figure">Table 3</ref>shows the results. The numbers reported in the row of GA*768 search space indicate that the numbers of new nodes expanded by parallel A* search did not exceed the memory limit of GPU so that the results computed without memory restriction can be used as references for evaluating their tests with memory restriction. We found that the native sequence recovery ratios of last three structures were a little low, even when no node was thrown away. Apart from that, the results look encouraging. The GMEC solution can be guaranteed by GSMA*768 on all our test data even if we only used $10% of memory required by GA*768. When we restricted the memory to 1%, GSMA*768 can still keep all GMEC solutions, though it cannot theoretically guarantee to find the GMEC solution in some cases.Note: The meaning of each row is explained either in the text or here. a The row labeled with 'GA*768 search space' represents the number of nodes expanded by GA*768 for calculating the best 50 solutions. b The rows labeled with 'Scan Count' represent the number of times that the system ran out of memory, in which a series of operations described in Section 2.5 were executed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i261</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A parallel algorithm for accelerating computational protein design</head><p>In the test with the restriction of 0.1% memory, the algorithm achieved relatively poor performance. In this case, the algorithm was only allow to keep 30 000 nodes in memory, which is unfriendly to parallel A*, as discussed in Section 3.1. When the absolute size of allowed memory is too small, it is more probable for GSMA* to throw away an important node at the beginning of the tree expansion. In practice, we will always use all available memory to perform the protein design task. So this setting was only for the evaluation purpose.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>u ÞÞ; ð4Þ where U(x) represents the set of residues, in which rotamers have not been determined at current node x. i256 Y.Zhou et al.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>LEMMA 2.1.</head><figDesc>Let h r (x) represent the real cost from x to an optimum target node. If the defined heuristic function satisfies h(x) h r (x) for each node x and the search graph is a tree, for any optimal target t 2 T, there exists a node t 0 in the priority queues {Q i } such that f(t 0 ) f(t) in Algorithm 2 before each POP operation is executed. PROOF. Let d(x,y) = g(y)– g(x) denote the real cost from node x to node y, where x must be on the path from the starting node s to y. For all node t 0 that is on the path from s to t, we haveis sufficient to prove that there exists a node t 0 in the priority queues along the path from s to t. At the beginning, the starting node s satisfies such a condition. At any time, if line 11 in Algorithm 2 pops node t 0 , line 18 will generate another node that is also on the path from s to t, which is then pushed back into the queues. Thus, such a node always exists. « THEOREM 2.2. Let h r (x) represent the real cost from x to an optimum target node. If the defined heuristic function satisfies h(x) h r (x) for every node x and the search graph is a tree, the first solution returned by GA* must be the optimal solution. PROOF. We prove this theorem by contradiction. There exists two possible situations that may violate our conclusion: (1) The algorithm never terminates; and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>except that the numbers in last three columns represent the numbers of expanded nodes in different programs. i260 Y.Zhou et al.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. The comparison results about time efficiency of our parallel against original versions of A* search for protein design</figDesc><table>PDB 
Space a 
OSPREY b 
A*1 c 
GA*768 d 
GA*4992 d 

2QCP 
2Á10 17 
21 551 916 
51 091 
3075 
1146 
1XMK 
2Á10 14 
247 585 
2990 
296 
121 
1X6I 
7Á10 13 
96 990 
1406 
138 
73 
1UCS 
6Á10 12 
88 135 
1771 
182 
79 
1CC8 
3Á10 14 
77 614 
1078 
99 
53 
2CS7 
8Á10 12 
64 187 
1154 
149 
57 
2BWF 
9Á10 13 
18 457 
307 
33 
24 
1I27 
7Á10 11 
8151 
88 
18 
16 
1T8K 
2Á10 13 
6806 
89 
18 
15 
1R6J 
2Á10 14 
6018 
107 
18 
21 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 2.</figDesc><table>The comparison results about memory consumption of our par-
allel against original versions of A* search for protein design 

PDB 
Space 
A*1 
GA*768 
GA*4992 

2QCP 
2Á10 17 
31 589 690 
32 825 074 
35 517 854 
1XMK 
2Á10 14 
2 910 324 
3 325 654 
4 419 100 
1X6I 
7Á10 13 
1 919 055 
2 282 986 
3 486 684 
1UCS 
6Á10 12 
1 713 636 
2 196 315 
2 960 752 
1CC8 
3Á10 14 
966 196 
1 255 899 
1 893 701 
2CS7 
8Á10 12 
1 378 633 
1 686 558 
2 354 910 
2BWF 
9Á10 13 
325 634 
529 810 
981 302 
1I27 
7Á10 11 
121 920 
260 825 
737 328 
1T8K 
2Á10 13 
129 767 
211 003 
618 794 
1R6J 
2Á10 14 
117 053 
244 399 
837 359 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 3. Performance of GSMA* with 768 parallel priority queues on 6 test datasets</figDesc><table>PDB 
1OAI 
1U2H 
1ZZK 
2CS7 
2DSX 
3D3B 

No. of mutable residues 
16 
18 
14 
15 
15 
15 
Conformation space 
2Á10 22 
2Á10 20 
2Á10 15 
2Á10 23 
3Á10 20 
6Á18 18 
GA*768 search space a 
4Á10 7 
8Á10 6 
8Á10 6 
4Á10 7 
4Á10 7 
3Á10 7 
3 Â 10 4 nodes limit 
Scan count b 
252 
104 
99 
202 
182 
109 
GMEC gotten 
NO 
YES 
YES 
NO 
YES 
NO 
GMEC assured 
NO 
NO 
NO 
NO 
NO 
NO 
Correctness 
4% 
100% 
20% 
12% 
32% 
6% 
Recovery ratio 
62% 
75% 
85% 
48% 
46% 
48% 

3 Â 10 5 nodes limit 
Scan count b 
139 
43 
36 
103 
97 
55 
GMEC gotten 
YES 
YES 
YES 
YES 
YES 
YES 
GMEC assured 
NO 
YES 
YES 
NO 
NO 
NO 
Correctness 
100% 
100% 
100% 
100% 
100% 
44% 
Recovery ratio 
74% 
75% 
87% 
46% 
48% 
54% 

3 Â 10 6 nodes limit 
Scan count b 
2 2 
3 
3 
2 4 
2 2 
1 8 
GMEC gotten 
YES 
YES 
YES 
YES 
YES 
YES 
GMEC assured 
YES 
YES 
YES 
YES 
YES 
YES 
Correctness 
100% 
100% 
100% 
100% 
100% 
100% 
Recovery ratio 
74% 
75% 
87% 
46% 
48% 
53% 

3 Â 10 7 nodes limit 
Scan count b 
1 
0 
0 
1 
1 
1 
GMEC gotten 
YES 
YES 
YES 
YES 
YES 
YES 
GMEC assured 
YES 
YES 
YES 
YES 
YES 
YES 
Correctness 
100% 
100% 
100% 
100% 
100% 
100% 
Recovery ratio 
74% 
75% 
87% 
46% 
48% 
53% 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">The most time-consuming part of the A* tree search algorithm for protein design lies in the following two aspects: (i) Calculation of heuristic functions; (ii) Priority queue operations for expanding new nodes. To alleviate these two bottlenecks, we propose a new algorithm with two levels of parallelism to accelerate protein design. In this section, we will describe the first level of parallelism, that is, parallelized calculation of heuristic functions in A* search. Although time complexity of calculating a heuristic function has been improved from O(n 2 m 2 t) to O(n 3 m 2 + n 2 mt) in Section 2.2.1, the computation of heuristic functions for new expanded nodes in A* search can be further sped up by exploiting the inherent parallelism capacity of a GPU. This step is quite straightforward, based on the observation that calculation of heuristic function f(x) for each expanded node is simply a series of independent arithmetic operations that can be directly parallelized. The flow chart of the first level parallelism can be found in Figure S1 in Supplementary Material Section S2. 2.4 Parallelized A* search for protein design Although the method described in Section 2.3 can parallelize the A* search algorithm, the scale of the parallelism is still limited. In our protein design problem, the degree of parallelism in the computation of heuristic function is equal to the maximum number of rotamers per residue, which is normally in the order of 10 after pruning unfavorable rotamers using the combinations of different DEE criteria. Although this may be good enough for a single-machine CPU implementation, a GPU implementation definitely needs a larger degree of parallelism as we mentioned in Section 2.1. Another problem is that the priority queue operations, including PUSHBACK and POP, take Oðlog NÞ time, where N stands for the total number of elements in the priority queue and usually is a large number. After computing the heuristic functions of newly expanded nodes, we need to push all of them back into a single priority queue. This part has not been parallelized and thus only exploits a small proportion of the parallel capacity of a GPU. Therefore, further improvement is needed. A na€ ıve idea is to pop a number of minimum elements from a single priority queue and then compute their heuristic function values. However, this method is still unable to parallelize the priority queue operations. Existing parallel priority queues (R€ onngren and Ayani, 1997), such as pipelined binary heap (Moon et al., 2000), do not fit the GPU</note>

			<note place="foot" n="3"> RESULTS 3.1 Parallel protein design In order to evaluate the performance of our new parallel A* algorithm, we performed several protein design experiments. The Results section is divided into two parts. In the first subsection, we will compare the running time and memory usage of our new algorithm GA* against the original A* algorithm for protein design. In the second subsection, we will evaluate the effectiveness of the combination of our parallel design algorithm GA* and the memory-bounded strategy (i.e., SMA*), by testing whether our algorithm is able to get a GMEC solution and calculating the proportion of recovered residues in native sequences recovery. In addition to the original A* search algorithm in OSPREY (Gainza et al., 2013) and our parallel design algorithm GA*, we also implemented a single-thread version of the A* search algorithm on a CPU in C programming language using the new strategy of computing heuristic functions, as we have described in Section 2.2.1. There are two reasons for us to include this program in this benchmark. First, it measures improvement by using this new strategy to compute heuristic functions. Second, it is unfair to perform a direct comparison between algorithms implemented in Java and native machine code on a GPU, because the Java Virtual Machine and the garbage collection system may introduce a considerable amount of overhead. We used 74 protein core redesigns provided by (Gainza et al., 2012) as the test data. We used the same parameters as those in (Gainza et al., 2012), including the set of allowed amino acids and the number of mutable residues. We used iMinDEE (Gainza et al., 2012) as the DEE strategy to prune those rotamers that are Fig. 2. Diagram of the GPU states i259 A parallel algorithm for accelerating computational protein design at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="4"> CONCLUSION AND FUTURE WORK Computational protein design is a challenging problem in the computation biology field. In this article, we have developed an innovative method to improve the A* algorithm for computational protein design, which significantly reduces running time of the original protein design algorithm by up to four orders of magnitude while maintaining low memory overhead. Another advantage of our algorithm is that we do not change the interface of the original protein design framework in OSPREY (Gainza et al., 2013). We have shown that it could be successfully integrated with iMinDEE (Gainza et al., 2012) to further improve SCPR with the consideration of continuous side-chain flexibility. Memory limitation becomes a more important problem in protein design after A* is sped up. Thus, we introduce memory-bounded parallel A*, a variant of A* algorithm that only uses limited memory. In the Results section, we have shown that in practice, the memory-bounded parallel A* algorithm is able to guarantee the GMEC solution with only onetenth of memory consumption that the original algorithm requires. Currently GA* is only implemented on the Tesla GPU card. It would be interesting to know whether it can achieve similar performance on a more affordable GPU card such as NVIDIA GeForce GTX series. In addition, although currently GA* is only runnable on a single GPU platform, it should be easy to port it to other parallel computational platforms due to the parallel characteristic of our algorithm. If we can utilize the existing large clusters of CPUs and GPUs to run GA*, in which more memory and computation resource is available, we will be able to solve a larger protein design problem than ever before.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We thank Mr Kyle Roberts and Mr Pablo Gainza for helping us set up the iMinDEE code and providing us the benchmark dataset and scripts for testing. We thank Mr Kyle Roberts and Mr Mark Hallen for their helpful comments on the draft of this article. We particularly thank Mr Kyle Roberts for his indepth comments on the property of memory-bounded A*. We thank the anonymous reviewers for their helpful comments.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">A combinatorial approach to protein docking with flexible side chains</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Althaus</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="597" to="612" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">A semidefinite programming approach to side chain positioning with new rounding strategies</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Chazelle</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">INFORMS J. Comput</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="380" to="392" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Computational structure-based redesign of enzyme activity</title>
		<author>
			<persName>
				<forename type="first">C.-Y</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci</title>
		<meeting>. Natl Acad. Sci</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="3764" to="3769" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Generalized best-first search strategies and the optimality of A*</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Dechter</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Pearl</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="505" to="536" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">The dead-end elimination theorem and its use in protein sidechain positioning</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Desmet</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">356</biblScope>
			<biblScope unit="page" from="539" to="542" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title level="m" type="main">Algorithms in Structural Molecular Biology</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">R</forename>
				<surname>Donald</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge, MA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Predicting resistance mutations using protein design algorithms</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">M</forename>
				<surname>Frey</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci</title>
		<meeting>. Natl Acad. Sci</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="13707" to="13712" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Protein design using continuous rotamers</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Gainza</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">1002335</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">OSPREY: protein design with ensembles, flexibility, and provable algorithms</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Gainza</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Method. Enzymol</title>
		<imprint>
			<biblScope unit="volume">523</biblScope>
			<biblScope unit="issue">87</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Improved pruning algorithms and divide-and-conquer strategies for dead-end elimination, with application to protein design</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Georgiev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="174" to="183" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">The minimized dead-end elimination criterion and its application to protein redesign in a hybrid scoring and search algorithm for computing partition functions over molecule ensembles</title>
		<author>
			<persName>
				<forename type="first">I</forename>
				<surname>Georgiev</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Chem</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1527" to="1542" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Allosteric inhibition of the protein-protein interaction between the leukemia-associated proteins Runx1 and CBF</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Gorczynski</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Chem. Biol</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1186" to="1197" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Intel Corporation</title>
		<imprint>
			<publisher>Intel Microprocessor Export Compliance Metrics</publisher>
			<date type="published" when="2011" />
			<publisher>Intel Microprocessor Export Compliance Metrics</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Solving and analyzing side-chain positioning problems using linear and integer programming</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">L</forename>
				<surname>Kingsford</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="1028" to="1039" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Depth-first iterative-deepening: an optimal admissible tree search</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">E</forename>
				<surname>Korf</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artif. Int</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="97" to="109" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Native protein sequences are close to optimal for their structures</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Kuhlman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Baker</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci</title>
		<meeting>. Natl Acad. Sci</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="10383" to="10388" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Exploring the conformational space of protein side chains using dead-end elimination and the A* algorithm</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">R</forename>
				<surname>Leach</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins Struct. Funct. Genet</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="227" to="239" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">A novel ensemble-based scoring and search algorithm for protein redesign and its application to modify the substrate specificity of the gramicidin synthetase a phenylalanine adenylation enzyme</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">H</forename>
				<surname>Lilien</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="740" to="761" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Progress in computational protein design</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">M</forename>
				<surname>Lippow</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Tidor</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Curr. Opin. Biotechnol</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="305" to="311" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Conversion of a maltose receptor into a zinc biosensor by computational design</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">S</forename>
				<surname>Marvin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">W</forename>
				<surname>Hellinga</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci</title>
		<meeting>. Natl Acad. Sci</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="4955" to="4960" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Scalable hardware priority queue architectures for highspeed packet switches</title>
		<author>
			<persName>
				<forename type="first">S.-W</forename>
				<surname>Moon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Comput</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="1215" to="1227" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">NVIDIA Tesla Technical Specifications</title>
	</analytic>
	<monogr>
		<title level="j">NVIDIA Corporation</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Protein design is NP-hard</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<forename type="middle">A</forename>
				<surname>Pierce</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Winfree</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Protein Eng</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="779" to="782" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Improving computational efficiency and tractability of protein design using a piecemeal approach. A strategy for parallel and distributed protein design</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Pitman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1138" to="1145" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Computational design of a PDZ domain peptide inhibitor that rescues CFTR activity</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">E</forename>
				<surname>Roberts</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">1002477</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">A comparative study of parallel and sequential priority queue algorithms</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>R€ Onngren</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Ayani</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM T. Model. Comput. S. (TOMACS)</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="157" to="209" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Efficient memory-bounded search methods Designing efficient sorting algorithms for manycore GPUs</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Russell</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Satish</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th European Conference on Artificial intelligence IEEE International Parallel &amp; Distributed Processing Symposium</title>
		<meeting>the 10th European Conference on Artificial intelligence IEEE International Parallel &amp; Distributed Processing Symposium</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="1" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Zhou</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2016-08-30" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Scan primitives for GPU computing</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Sengupta</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGGRAPH/EUROGRAPHICS symposium on Graphics hardware. Eurographics Association</title>
		<editor>Fellner,D. and Spencer,S.</editor>
		<meeting>the 22nd ACM SIGGRAPH/EUROGRAPHICS symposium on Graphics hardware. Eurographics Association<address><addrLine>Aire-la-Ville, Switzerland, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="97" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Preprocessing of rotamers for protein design calculations</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">S</forename>
				<surname>Shah</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Chem</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1797" to="1800" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Fast parallel GPU-sorting using a hybrid algorithm</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Sintorn</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Assarsson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Parallel Distr. Com</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="page" from="1381" to="1388" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">Computational protein design</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">G</forename>
				<surname>Street</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Mayo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Structure</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="105" to="109" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">Fast and accurate algorithms for protein side-chain packing</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Xu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Berger</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM (JACM)</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="533" to="557" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>