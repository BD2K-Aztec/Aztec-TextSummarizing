
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:55+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient privacy-preserving string search and an application in genomics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Kana</forename>
								<surname>Shimizu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Biotechnology Research Institute for Drug Discovery</orgName>
								<orgName type="institution">National Institute of Advanced Industrial Science and Technology</orgName>
								<address>
									<postCode>135-0064</postCode>
									<settlement>Tokyo, Japan</settlement>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Computational Biology</orgName>
								<orgName type="institution">Memorial Sloan Kettering Cancer Center</orgName>
								<address>
									<postCode>1275</postCode>
									<settlement>New York, York</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Koji</forename>
								<surname>Nuida</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Information Technology Research Institute</orgName>
								<orgName type="institution">National Institute of Advanced Industrial Science and Technology</orgName>
								<address>
									<postCode>135-0064</postCode>
									<settlement>Tokyo</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
							<affiliation key="aff3">
								<orgName type="institution">Japan Science and Technology Agency (JST) PRESTO Researcher</orgName>
								<address>
									<settlement>Tokyo</settlement>
									<country key="JP">Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Gunnar</forename>
								<surname>Rä Tsch</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Computational Biology</orgName>
								<orgName type="institution">Memorial Sloan Kettering Cancer Center</orgName>
								<address>
									<postCode>1275</postCode>
									<settlement>New York, York</settlement>
									<region>NY</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient privacy-preserving string search and an application in genomics</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btw050</idno>
					<note type="submission">Received on April 19, 2015; revised on November 27, 2015; accepted on January 19, 2016</note>
					<note>Sequence analysis *To whom correspondence should be addressed. Associate Editor: Janet Kelso Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Personal genomes carry inherent privacy risks and protecting privacy poses major social and technological challenges. We consider the case where a user searches for genetic information (e.g. an allele) on a server that stores a large genomic database and aims to receive allele-associated information. The user would like to keep the query and result private and the server the database. Approach: We propose a novel approach that combines efficient string data structures such as the Burrows–Wheeler transform with cryptographic techniques based on additive homomorphic en-cryption. We assume that the sequence data is searchable in efficient iterative query operations over a large indexed dictionary, for instance, from large genome collections and employing the (positional) Burrows–Wheeler transform. We use a technique called oblivious transfer that is based on additive homomorphic encryption to conceal the sequence query and the genomic region of interest in positional queries. Results: We designed and implemented an efficient algorithm for searching sequences of SNPs in large genome databases. During search, the user can only identify the longest match while the ser-ver does not learn which sequence of SNPs the user queried. In an experiment based on 2184 aligned haploid genomes from the 1000 Genomes Project, our algorithm was able to perform typical queries within % 4.6 s and % 10.8 s for client and server side, respectively, on laptop computers. The presented algorithm is at least one order of magnitude faster than an exhaustive baseline algorithm. Availability and implementation: https://github.com/iskana/PBWT-sec and https://</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>String search is a fundamental task in the field of genome informatics, for which a large variety of techniques have been developed (see, for instance,<ref type="bibr" target="#b0">Altschul et al., 1990;</ref><ref type="bibr" target="#b14">Kent, 2002;</ref><ref type="bibr" target="#b17">Li and Homer, 2010</ref>). Traditionally, those techniques have been optimized for accuracy and computational efficiency, however a recent boom of personal genome sequencing and analyses has spotlighted a new criteria, namely, privacy protection. As reported in many studies, a genome is considered V C The Author 2016. Published by Oxford University Press.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1652</head><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/4.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited. to be one of the most critical pieces of information for an individual's privacy. In fact, it is largely different from any other personal information because it works as an identifier of an individual while it possesses the information that has strong correlation with the phenotype of the individual (<ref type="bibr" target="#b8">Erlich and Narayanan, 2014;</ref><ref type="bibr" target="#b24">Roche and Annas, 2001</ref>). Therefore, in principle, privacy protection is an inevitable problem when handling personal genomes. As a practice, the most popular approach is protecting genomes physically; genomic sequences have been kept at few collaborator sites, and only a limited number of researchers are allowed to access them. This conservative approach severely limits the great potential of existing genomic resources. In order to mitigate the stagnation caused by privacy issues, it appears crucial to develop practical methods that enable searching and mining genomic databases in a privacy-preserving manner. So far, several groups have tackled related problems. Jha et al.</p><p>(2008) developed secure multi-party computation protocols for computing edit distance.<ref type="bibr" target="#b3">Blanton and Aliasgari (2010)</ref>proposed a protocol to search DNA string against a DNA profile represented by finite automata.<ref type="bibr" target="#b4">Bruekers et al. (2008)</ref>proposed a protocol to detect a match between two short DNA sequences for the purpose of genetic test.<ref type="bibr" target="#b2">Baldi et al. (2011)</ref>also aimed for genetic test to develop a method for computing set intersection cardinality.<ref type="bibr" target="#b9">Freedman et al. (2005)</ref>proposed a protocol for searching pre-defined keywords from databases.<ref type="bibr" target="#b21">Naganuma et al. (2012)</ref>proposed a substring search protocol for public databases while keeping user's query private.<ref type="bibr" target="#b1">Ayday et al. (2013)</ref>developed a system by using several cryptographic techniques to find a subset of short reads which includes a fixed-length query string at specific position.<ref type="bibr" target="#b11">He et al. (2014)</ref>proposed an algorithm for finding relatives by secure identity-by-descent matches. We propose a general approach which utilizes an efficient iteratively queriable data structure together with cryptographic techniques. Among many variations of such data structures, the Burrows–Wheeler Transform (BWT<ref type="bibr" target="#b15">Langmead et al., 2009;</ref><ref type="bibr" target="#b16">Li and Durbin, 2009;</ref><ref type="bibr" target="#b16">Li et al., 2009</ref>) and related techniques such as the positional BWT (PBWT;<ref type="bibr" target="#b6">Durbin, 2014</ref>) have dramatically improved the speed of genomic database analyses. Those data structures commonly have an indexed dictionary called a rank dictionary. By referring to the rank dictionary in iterative operations, one can efficiently search the database. For the case of BWT, a match between query and database is reported as a left-open, right-closed interval ðf ; g, and the interval is computed by the look-up of the rank dictionary. In our approach, we access the rank dictionary in privacy-preserving manner by using additive homomorphic encryption and oblivious transfer (OT). Cryptographic approaches often require significant computational resources. The goal of this work is to illustrate that privacypreserving queries are within reach when using current cryptographic techniques and standard computing hardware. We demonstrate that a typical query would only take about 4.6 s on the user side using a single thread and % 10.8 s on the server having four cores, while preserving privacy of the query string and the database. The rest of the paper is organized as follows. In Approach, we describe the main ideas of our approach without going into technical details. In Methods, the detailed algorithm of recursive oblivious transfer is given followed by the description of a practical algorithm, named PBWT-sec, for privacy-preserving search in large-scale genotype databases. We also describe complexity and security properties of the proposed algorithm. We provide the more intricate details of a more efficient version of the algorithm in Supplementary Sections S1–S2. In Experiments, we evaluate the performance of PBWT-sec on datasets created from data of the 1000 Genomes Project (<ref type="bibr">The 1000</ref><ref type="bibr">Genomes Project Consortium, 2012</ref>) and compare it to an alternative method for fixed-length k-mer search. Finally, we conclude our study in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Approach</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Problem setup</head><p>We consider the setting in which a user would like to search a genomic sequence in a database with the aim to either determine whether this sequence exists in the queried database and/or to obtain additional information associated with the genomic sequence. An example is the use in a so-called genomic beacon (for instance, those created within the Beacon Project of the Global Alliance for Genome &amp; Health (GA4GH).) Another application is the search of a specific combination of variants, for instance, in the BRCA1 or BRCA2 genes, with the aim to determine whether that combination of variants is known or predicted to be deleterious (see, for instance, GA4GH's BRCA Challenge). For privacy reasons, the user would like to conceal the queried sequence, which would be particularly relevant for the second example. For both examples it would be important that the server's database is protected.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Information flow of searches on recursive search data structures</head><p>Let us describe the information flow between a user and a server for such problems. In this work, we perform searches on the (positional) Burrows–Wheeler transform of a genomic database of length N. (P)BWT stores string information very efficiently and still allows computations (this is a property of Succinct Data Structures, see<ref type="bibr" target="#b12">Jacobson, 1988</ref>). To search for a query string q over the alphabet R, one iteratively operates on intervals that can later be used to identify the matching genomic regions based on the (P)BWT. A substring match is represented by an interval ðf ; g. The number of matches is given by the length of the interval g–f. It is known that the ðk þ 1Þth interval ðf kþ1 ; g kþ1  corresponding to a ðk þ 1Þ-mer match can be updated from the kth interval ðf k ; g k  and the ðk þ 1Þth letter of the query q. We will provide more details on how to update f and g in Section 3.3. To understand the key ideas, it is sufficient to understand that the updates can be written in the form of</p><formula>f kþ1 ¼ v c ½f k  and g kþ1 ¼ v c ½g k ;</formula><p>where c ¼ q½k þ 1 and v c 2 N N is a large, static lookup table. Hence, the iterative algorithm of updating ðf k ; g k  by using the query q, can be written as a recursive algorithm: f kþ1 ¼ v q½kþ1 ½v q½k ½v q½kÀ1 ½. .. v q½1 ½f 0  .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.. :</head><p>This can be done analogously for g kþ1. In this work we will refer to data structures that can be queried in the recursive way described above as recursive search data structures.<ref type="figure">Figure 1</ref>illustrates the information flow of a search on the recursive search data structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Oblivious transfer for privacy-preserving search</head><p>In a search on the recursive search data structures, the user needs to conceal not only a query string q but also f and g because f i is f iÀ1 th element of v q½i , and q½i is inferred from those two values. Analogously, q½i is also inferred from g i and g iÀ1. The server needs to minimize output because the user reconstructs a part of v from the server's output. In this study, we achieve such security requirements by a cryptographic technique called oblivious transfer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Oblivious transfer</head><p>Oblivious transfer (OT) is a cryptographic technique for two parties: the user and the server, and enables the user to specify 0 t &lt; N and obtain only tth element of the server's vector v without leaking any information about t to the server (<ref type="bibr" target="#b23">Rabin, 1981</ref>).<ref type="figure">Figure 2</ref>illustrates an outline of the oblivious transfer. Among several efficient algorithms (<ref type="bibr" target="#b19">Lipmaa, 2005</ref><ref type="bibr" target="#b20">Lipmaa, , 2008</ref><ref type="bibr" target="#b29">Zhang et al., 2013</ref>), we used those which are based on additive homomorphic encryption. The detailed algorithm will be given in Section 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Concealing the query</head><p>The user's query consists of ðf i ; g i , and q½i þ 1 for ith iteration. A key idea of our approach is to look-up elements of v c by OT and obtain the next interval ðf iþ1 ¼ v c ½f i ; g iþ1 ¼ v c ½g i  without revealing ðf i ; g i  to the server. In our approach, we also use a masking technique such that the user tries v c ½f i  for all c 2 R, and the server only returns v c ½f i  where c ¼ q½i þ 1 without knowing the value of q½i þ 1. Technical details will be given in Section 3.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.3">Concealing the database</head><p>While this approach protects a user's privacy, the server leaks information of v c which may be sufficient to reconstruct parts of the genotypes in the database. In order to rigorously protect the server's privacy, we propose a technique that allows for recursive oblivious transfer where the user does not learn intermediate results but only if a unique match was found. It is based on a bit-rotation technique which enables the server to return ^ f k :¼ Rðf k Þ and ^ g k :¼ R 0 ðg k Þ which are random values to the user. Only the server can recover f k and g k in encrypted form (i.e. the server does not see f k and g k when recovering them), and thus the user can recursively access v c ½f k  and v c ½g k  correctly. The details of this approach are given in Section 3.2. In this work, we designed an algorithm based on these techniques that can be used for privacy-preserving search in large genotype databases. Note that there are still privacy risks for the server, though returning only a unique match minimizes the information leakage from the server. For example, assume there is a database storing a genomic study of drug addicts that implements the PBWT-sec, and a person (Bob) participated in the study. If someone obtains a DNA sample from Bob and queries the databases, he/she will reveal that Bob is a drug addict. As described in the above case, there is always a limitation for protecting the server's privacy as long as the server returns the search results, and there is associated information such as phenotypes (<ref type="bibr" target="#b26">Shringarpure and Bustamante, 2015</ref>). We emphasize that this issue is common for any database search application and is not specific to our proposed method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Additively homomorphic encryption</head><p>Our main cryptographic tool in this paper is an additive-homomorphic public-key encryption scheme ðKeyGen; Enc; DecÞ, which enables us to perform additive operations on encrypted values. Here, the algorithm KeyGen generates a public key pk and a secret key sk; EncðmÞ denotes a ciphertext obtained by encrypting message m under the given pk; and DecðcÞ denotes the decryption result of ciphertext c under the given sk. The scheme also has the following additive-homomorphic properties:This scheme should have semantic security; that is, a cipher text leaks no information about the original message (<ref type="bibr" target="#b10">Goldwasser and Micali, 1984</ref>). For example, we can use either the Paillier cryptosystem (<ref type="bibr" target="#b22">Paillier, 1999</ref>) or the 'lifted' version of the ElGamal cryptosystem (<ref type="bibr" target="#b7">ElGamal, 1985</ref>); now the second operation can be realized by repeating the first operation È.<ref type="figure" target="#fig_3">Figure 3</ref>illustrates an outline of performing an additive operation on a user's value m 1 and a server's value m 2 by the additively homomorphic encryption. In the first step, the user generates two keys: a secret key and a public key, and the user sends the public key to the server. In the second step, the user encrypts m 1 by the public key and sends a ciphertext Encðm 1 Þ to the server. In the third step, the server<ref type="figure">Fig. 1</ref>. Information flow of a search on a recursive search data structure such as (P)BWT. For ith iteration, the user sends q½i; f iÀ1 , and g iÀ1 , the server returns v q½i ½f iÀ1  and v q½i ½g iÀ1 , and the user updates f i ¼ v q½i ½f iÀ1  and g i ¼ v q½i ½g iÀ1 <ref type="figure">Fig. 2</ref>. Outline of Oblivious Transfer (OT). The user (laptop computer) obtains tth element of the server's vector v without leaking t to the server, and none of the other elements of the vector v encrypts m 2 by the public key and computes c ¼ Encðm 1 þ m 2 Þ. The server sends a ciphertext c to the user. In the fourth step, the user obtains m 1 þ m 2 by decrypting c. It goes beyond the scope of this paper to review the details of these cryptographic techniques and the reader is referred to a book (<ref type="bibr" target="#b28">Yi et al., 2014</ref>) on homomorphic encryption. A typical addition operation in the ElGamal cryptosystem takes about 2 Â 10 À7 s on a single CPU based on AIST's ElGamal encryption library (https://github. com/aistcrypt/Lifted-ElGamal).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Recursive oblivious transfer by random rotations</head><p>To protect the privacy of the database, we propose a technique for recursively querying a data structure without obtaining information about intermediate results. Let us define the recursive oblivious transfer problem as follows:</p><p>MODEL 1. A user has a private value 0 x 1 &lt; N and a server has a private vector v of length N. Let us denote x kþ1 ¼ v½x k  and the user is allowed to access the server ' À 1 times. After the calculation, the user learns only x ' and the server learns nothing about x 1 ;. .. ; x '. Here we explain our idea by extending a simple linear communication size OT where the user aims to know the tth element of the server's vector v.<ref type="figure" target="#fig_2">Figure 4</ref>illustrates the oblivious transfer algorithm based on additive homomorphic encryption. In the initialization step, the user generates a public key and a secret key and sends the public key to the server. The user creates a bit vector: q ¼ ðq 0 ¼ 0;. .. ; q t ¼ 1;. .. ; q NÀ1 ¼ 0Þ ; and sends the following encrypted vector to the server. ~ EncðqÞ ¼ ðEncðq 0 Þ .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.. ; Encðq NÀ1 ÞÞ</head><p>The server computes</p><formula>c ¼ È NÀ1 i¼0 ðv½i Encðq i ÞÞ;</formula><p>and sends c to the user. The user computes DecðcÞ and obtains v½t by using the secret key because i ¼ t ) v½t Encðq t Þ ¼ Encðv½iÞ and i 6 ¼ t ) v½t Encðq t Þ ¼ Encð0Þ. Now we consider the case that the server does not leak v½t, but allows the user to access v½v½t. Our idea is that the server generates a random value r 2 f0; 1;. .. ; N À 1g and returns the cipher textwhere ða þ bÞ mod N denotes addition in a number field modulo N. The user decrypts ^ c to know a randomized result ðv½t þ rÞ mod N , and performs the next query: ^ q ¼ ð^ q 0 ¼ 0;. .. ; ^ q ððv½tþrÞ mod N Þ ¼ 1;. .. ; ^ q NÀ1 ¼ 0Þ:</p><p>Note that ^ q is the r-rotated permutation of the 'true' query:</p><formula>q 0 ¼ ðq 0 0 ¼ 0;. .. ; q 0 v½t ¼ 1;. .. ; q 0 NÀ1 ¼ 0Þ:</formula><p>Therefore, denote Permðq; rÞ as the permutation of a vector q such that ith element moves to ðði À rÞ modN ÞÞth position, the server<ref type="figure">Fig. 5</ref>. Outline of the search strategy with PBWT. A set of genotype sequences X ¼ fx1;. .. ; x5g illustrated in (a) is sorted by the algorithm described in Durbin (2014) to obtain the positional prefix arrays A illustrated in (b). Each element P i;j of PBWT matrix illustrated in (c) is ðj þ 1Þth letter of sequence A i;j. By computing rank operations with regard to kth query letter on P Á;kÀ1 , one can update an interval corresponding to k-mer match between the query and X. In this figure, the search starts from fourth allele. The first interval ðf 1 ; g 1  is initialized by rank operations on P Á;3 with regard to first query letter '1'. The second interval ðf 2 ; g 2  is obtained by rank operations on PÁ;4 with regard to the second query letter '0' and ðf1; g1. Similarly, the third interval ðf3; g3 is obtained by rank operations on PÁ;5 with regard to the third query letter '0' and ðf2; g2. See Sections 2.2 and 3.3 for more details can correctly recover 'true' query q 0 in its encrypted form by the following permutation: ~ Encðq 0 Þ ¼ Permð ~ Encð^ qÞ; rÞ. In this way, the server correctly computes an encrypted v½tth element by Encðv½v½tÞ ¼ È NÀ1 i¼0 ðv½i Encðq 0 i ÞÞ; without learning any information about the user's query. By recursively applying these calculations, the user can obtain x kþ1 according to Model 1. The complete algorithm implementing this idea is given in Algorithm 1. It uses a function ROT for rotating the server's results to conceal intermediate query results in order to protect the database.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">PBWT-sec: Privacy-preserving search on genotype databases</head><p>In this section, we introduce a practical genotype database search based on recursive oblivious transfer and PBWT. We only introduce the algorithm to search for the longest match starting from tth column, however, variations are possible and would allow for a variety of different search types (see also<ref type="bibr" target="#b6">Durbin, 2014</ref>). To formulate the problem, let us consider a set X of M haplotype sequences x i , i ¼ 1;. .. ; M over N genomic positions indexed by k ¼ 1;. .. ; N, and a query q which is a user's haplotype sequence over the same N genomic positions. We denote kth allele of a sequence x i by x i ½k. Given two indices k 1 and k 2 , we say that there is a match between q and x i from k 1 to k 2 , if q½k 1 . .. q½k 2 À 1 ¼ x i ½k 1 . .. x i ½k 2 À 1. We say that the match is set-longest at k 1 if there is no match between q and any sequence x j (possibly with j ¼ i) from k 1 to k 2 þ 1. The goal is to find a set-longest match at a given position t between q and X in a privacy-preserving manner. Here, we consider the case that the user's private information is the query string and the position t is not the user's private information. We later introduce the case that the both the query string and t are user's private information. The formal description of the model is described as follows: MODEL 2. The user is a private haplotype sequence holder, and the server is a holder of a set of private haplotype sequences. The user learns nothing but a set-longest match at a given position t between the query and the database while the server learns nothing about the user's query. t is not a user's private information and the server knows it. Let us remember how to search the set-longest match in nonprivacy-preserving manner. PBWT involves a matrix P 2 N MÂN that stores well-compressible information in an efficiently searchable form. It is created from the genotype matrix X by algorithms described in Durbin (2014) such that ith column is ði þ 1Þth letters of sequences sorted by i reverse prefix (i.e. sorted from ith letter to first letter). In order to compute the match starting from the first allele, P has 0th column P Á;0 ¼ ðx 1 ½1;. .. ; x M ½1Þ T. By using rank dictionary operations on P (see below), one can search a match between a query and X. When operating on P one computes updates of intervals using the following two quantities (see Durbin, 2014 for more details): (i) The rank dictionary for sequence S for letter c 2 R at position t:</p><p>Rank c ðS; tÞ ¼ jf j j S½j ¼ c ; 1 j t gj ;</p><p>where R is the alphabet of S. (ii) The table CF counting occurrences of letters that are lexicographically smaller than c in S by</p><formula>CF c ðSÞ ¼ X r&lt;c Rank r ðS; NÞ :</formula><p>Based on these two quantities, we can compute the updates ðf kþ1 ; g kþ1  using two simple operations</p><formula>f kþ1 ¼ CF c ðP Á;k Þ þ Rank c ðP Á;k ; f k Þ ; g kþ1 ¼ CF c ðP Á;k Þ þ Rank c ðP Á;k ; g k Þ ;</formula><p>where we denoted the kth column vector by P Á;k. Let us define a look-up vector v c for the column k where</p><formula>v c ½i ¼ CF c ðP Á;k Þ ð i ¼ 0Þ CF c ðP Á;k Þ þ Rank c ðP Á;k ; iÞ ð1 i MÞ ( (1)</formula><p>for c 2 R. Then, updating an interval is equivalent to two look-ups in the vector v c :</p><formula>f kþ1 ¼ v c ½f k  and g kþ1 ¼ v c ½g k :</formula><formula>(2)</formula><p>Given a position t and a PBWT P of the database sequences, the first match is obtained as an interval ðf 1 ¼ v c ½0; g 1 ¼ v c ½M where c ¼ q½1 and v c is a look-up vector for ðt À 1Þth column of P (see the definition of v c in<ref type="bibr">Equation (1)</ref>). The match is extended by one letter by an update of the interval. The update from the kth interval to ðk þ 1Þth interval is conducted by specifying c ¼ q½k þ 1, re-computing v c for ðk þ 1Þth column of P and referring v c ½f k  and v c ½g k  as f kþ1 and g kþ1 (see<ref type="bibr">Equation (2)</ref>). The set-longest-match is found</p><formula>v, r, r 0 , N) 8: ~ Encðq 0 Þ ¼ Permð ~ Encð^ qÞ; r 0 Þ 9: ^ c ¼ È NÀ1</formula><p>i¼0 ðððv½i þ rÞ modN Encðq 0 i ÞÞ 10: return ^ c 11: end function 12: 13: v is a server's private vector of length N. 14: x 1 is a user's private value. 15: x ' is the value of user's interest. 16: ' is known to both user and server. 17: User's initialization: t x 1 18: Server's initialization: r 0 0 19: Common initialization: i 1 20: while i &lt; ' do 21: The user computes: ~ EncðqÞ PrepQueryðt; NÞ 22: if i ¼¼ ð' À 1Þ then 23: Server sets: r ¼ 0 24: else 25: Server generates random value r 26: end if 27: Server computes: ^ c ROT( ~ EncðqÞ; v, r, r 0 , N) 28: Server sets: r 0 r 29: Server sends ^ c to user 30: User computes: t Decð^ cÞ 31: end while 32: User obtains x ' ¼ t. when f ¼ g. An outline of the search using PBWT is illustrated in<ref type="figure">Figure 5</ref>. In order to achieve the security described in the model 2, for each update, the user has to specify c without leaking c to the server, and obtain only v c ½f  and v c ½g without leaking f and g. To satisfy the second requirement, the user accesses the server's v c through the function ROT, which allows the user to obtain a specific element in the specified vector. To achieve the first requirement, the server computes all possible intervals (i.e. computing (f<ref type="bibr">, g]</ref>for the all case of c ¼ 0;. .. ; jRj À 1). This allows the user to obtain the correct interval, however, the sever leaks extra information (i.e. intervals for c 6 ¼ q½k). To avoid this, the user sends Encðq½kÞ, and the server adds a conditional randomization factor r Â ðq½k À cÞ to f and g with different random value r for all c 2 R. Note that this factor becomes equivalent to 0 iff. q½k ¼ c, and user only obtains the interval for c ¼ q½k. In order to identify the set-longest match, the user has to know if f ¼ g. The user cannot compute the identity of f and g directly from the server's return, because ROT returns a value which is a random value to the user (but the 'true' value is recovered in encrypted form only at the server side). Therefore, the server also sends an encrypted flag d which shows whether or not f ¼ g. Since f and g are represented as indices of q 0 f ¼ Permðq f ; r 0ðf Þ Þ and q 0 g ¼ Permðq g ; r 0ðgÞ Þ (see the functions PrepQuery and ROT), the server computes d by following: d ¼ È M i¼0 Encðr i Â ðq 0 f ½i À q 0 g ½iÞÞ where r i is a random value. DecðdÞ is equal to 0 iff. q f ¼ q g. See Supplementary Algorithm S5 which defines a function isLongest. In addition to finding a set-longest match at t, it is convenient to find a longest substring which matches to at least e sequences. This operation enables to avoid detecting unique haplotype and provides eanonymity result and is implemented by replacing the function: isLongest by another function: isLongestGT e which computes flags each of which shows if the interval matches to 0;. .. ; e À 1 respectively and returns shuffled flags, and the user knows the result by checking if there is a flag which is equal to zero. See Supplementary Algorithm S5 for more details. The detailed algorithm of PBWT-sec is shown in Algorithm 2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Concealing the search position</head><p>By the algorithm introduced above, the match position t needs to be provided to the server. Let us consider the case that t needs to be concealed (e.g. the used would not like to reveal which gene is analyzed). In practical genotype database search, it is often sufficient for the user to hide t in a set of multiple columns. Therefore, here we assume the following security model. MODEL 3. The user is a private haplotype sequence holder, and the server is a holder of a set of private haplotype sequences. The user has a vector of D positions T ¼ ðt 1 ;. .. ; t D Þ. The user learns nothing but a set-longest match at a given position t 2 ft 1 ;. .. ; t D g between the query and the database while the server learns nothing about the user's query string. The server knows T but cannot identify which element the user queries. Conceptually, the user could query multiple positions at the same time to conceal the search position. In the extreme case the user would query all search positions to avoid leaking any information about t. However, every answered query would leak more information from the database and querying would become computationally prohibitive. We therefore propose joint processing using OT that simultaneously uses multiple search positions. Let us define V c as another look-up vector for a letter c as follows:where o j ¼ ðj À 1ÞðM þ 1Þ is an offset and k is an index which is initialized by –1 and incremented by 1 in each iteration of the recursive</p><p>Algorithm 2. The detailed description of PBWT-sec finding a set-longest match at position t.</p><p>Public input: Problem size M &amp; N; alphabet R ¼ f0; 1; ::; jRj À 1g, start position t 2 f1;. .. ; Ng Private input of user: A query sequence S of length ' Private input of server: PBWT matrix P 2 N MÂN 0. (Key setup of cryptosystem) User generates key pair ðpk; skÞ by key generation algorithm KeyGen for additive-homomorphic cryptosystem and sends public key pk to server. 1. (User initialization) Set initial interval ðf ¼ 0; g ¼ M. 2. (Recursive search) Initializes query and position index: i 1; k t À 1 while (i ') do a. (Query entry) The user performs the following steps: Prepares next query:</p><formula>~ Encðq f Þ PrepQueryðf ; M þ 1Þ ~ Encðq g Þ PrepQueryðg; M þ 1Þ Sends EncðS½iÞ; ~ Encðq f Þ; ~ Encðq g Þ</formula><p>to the server. b. (Search) The server performs the following steps: Compute look-up tables for all c 2 R:</p><formula>v c ½j ¼ CF c ðP Á;k Þ ð j ¼ 0Þ CF c ðP Á</formula><formula>0 , r 1 e ðf Þ c / e ðf Þ c È Encðr 0 Â ðS½i À cÞÞ e ðgÞ c / e ðgÞ c È Encðr 1 Â ðS½i À cÞÞ</formula><p>Compute an encrypted flag showing if match is longest</p><formula>d isLongest ð ~ Encðq f Þ, ~ Encðq g Þ, r 0ðf Þ , r 0ðgÞ Þ Store random values r 0ðf Þ r ðf Þ , r 0ðgÞ r ðgÞ Send d, e ðf Þ ; e ðgÞ</formula><p>to the user c. (Decryption of encrypted flag and randomized interval)</p><p>The user performs the following steps: if (DecðdÞ ¼¼ 0) Sends decoy queries to server until i ¼¼ ' Reports result S½1;. .. ; i À 2 else</p><formula>Computes f Decðe ðf Þ S½i Þ, g Decðe ðgÞ S½i Þ, end if i i þ 1, k k þ 1 end while</formula><p>Efficient privacy-preserving string searchsearch. Note that (V c ½o j ;. .. ; V c ½o j þ M) corresponds to v c for t j th column. The algorithm for the Model 3 is designed by replacing the lookup tables v c by V c (see Step 2a, item 1 in Algorithm 2) and initializing f and g by o x and o x þ M, respectively, where t ¼ t x (see Step 1 in Algorithm 2). As a result the tables get D times larger which has an impact on computing requirements and data transfer size (see Section 3.7). We therefore suggest using this algorithm for small D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Reducing communication size</head><p>As we will describe in the Complexity analysis in the following section, the PBWT-sec algorithm using standard OT requires OðMjRjÞ in communication size per iteration in the best case, which makes the core algorithm less practical. We propose to use an algorithm for sublinear-communication OT (SC-OT) proposed in<ref type="bibr" target="#b29">Zhang et al. (2013)</ref>. Using this approach we can reduce the communication size of PBWTsec to Oð ffiffiffiffiffiffiffiffiffiffi ffi MjRj p Þ (best case). Here, we only outline the key ideas of SC-OT and its adaptation of PBWT-sec. In the SC-OT, the one encodes the position t by a two dimensional representation:</p><formula>t 0 ¼ t= ffiffiffiffi ffi N p AE Ç ; t 1 ¼ ðtÞ mod ffiffiffi N p</formula><p>d e , where Á d e denotes the ceil of the argument. The user sends Encðt 0 Þ and ~ EncðqÞ to the server, where</p><formula>~ EncðqÞ ¼ ðEncðq 0 ¼ 0Þ. .. ; Encðq t1 ¼ 1Þ;. .. ; Encðq ffiffiffi N p d eÀ1 ¼ 0ÞÞ:</formula><p>The server obtains random valuesr k ; k ¼ 0;. .. ;</p><formula>ffiffiffiffi ffi N p AE Ç À 1, and computes c k ¼ È ffiffiffi N p d eÀ1 i¼0 ðv½k Â ffiffiffiffi ffi N p l m þ i Encðq i ÞÞÈðr k Encðt 0 À kÞÞ;</formula><p>and sends c ¼ ðc 0 ; .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.. ; c ffiffiffi</head><p>N p d eÀ1 Þ to the user. The user knows the result by the decryption: Decðc t0 Þ. Note that Encðt 0 À kÞ ¼ Encð0Þ iff. t 0 ¼ k, therefore the decryption of c i becomes a random value when i 6 ¼ t 0. In order to apply bit-rotation technique naturally to SC-OT, the server needs to return v½t in the same two dimensional representation. The key idea here is that the server creates v 0 and v 1 where</p><formula>v 0 ½i ¼ v½i= ffiffiffiffi ffi N p AE Ç and v 1 ½i ¼ ðv½iÞ mod ffiffiffi N p d e ; i ¼ 0;. .. ; N À 1</formula><p>, and searches on both v 0 and v 1. Similar to the linear communication size function ROT, the removable random factors are added to server's returns. More details on SC-OT is given in Section S1. The complete algorithm for privacy-preserving search based on SC-OT is given in Supplementary and Algorithm S2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">An exhaustive baseline algorithm</head><p>There are a few related works in regard to finding a DNA substring match (<ref type="bibr" target="#b2">Baldi et al., 2011;</ref><ref type="bibr" target="#b5">Cristofaro et al., 2013</ref>), however, the goal of PBWT-sec is to find the set-longest prefix match from a set of aligned sequences while those works aim to find a fixed-length approximate substring match between two sequences. Therefore, we will compare our algorithm with a baseline algorithm which can find the set-longest prefix match on the basis of exhaustive enumeration of k-mers. This baseline algorithm serves as a proxy for the other conceptually similar algorithms. In order to identify the match, the user queries the server about the presence of a k-mer. Here, the server stores all k-mers, there are OðjRj k Þ of them, and we use SC-OT. Such a strategy is efficient for short queries as jRj k is not too large. However, the resource requirements will be dominated by queries for large k and the algorithm quickly gets intractable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.7">Complexity</head><p>Most of the computing and transfer on server and user side is related to the encryption/decryption and the computational cost of the search is negligible. While PBWT requires essentially Oð1Þ to update the intervals per iteration, PBWT-sec needs to conceal the query and requires MjRj operations on the server, where M is the number of sequences in the database and jRj is the size of the alphabet. When multiple queries are performed at the same time, i.e. D &gt; 1, the effort increases linearly in D, i.e. the server sides compute effort is Oð MDjRjÞ per iteration. When using SC-OT, the communication size and effort for the user is Oð ffiffiffiffiffiffiffiffiffiffiffiffiffiffi ffi MDjRj p Þ (see Section 3.5 and Supplementary Section S1 for details).<ref type="figure" target="#tab_1">Table 1</ref>summarizes the time, data transfer overhead and space complexities of the PBWT-sec, when the server's PBWT is M Â N matrix consisting of a set of alphabet letters R and the user's query length is ' and the number of queries positions is D (including D – 1 decoy positions; see Section 3.4 for details). For the purpose of comparison, we consider the method outlined in Section 3.6 that achieves the same security and utility as PBWT-sec. Since the complexity of the exhaustive approach is exponential to the query length, its performance deteriorates quickly for long matches. On the other hand, the time and data transfer overhead complexity of the PBWT-sec are linear and sub-linear to the query length, which enables the user to find a long match efficiently.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.8">Security notion</head><p>In this paper, we assume the security model called Semi-honest model where both parties follow the protocol, but an adversarial one attempts to infer additional information about the other party's secret input from the legally obtained information. The semantic security of the encryption scheme used in the protocol (see Section 3.1) implies immediately that the server cannot infer any information about the user's query q during the protocol. Also, the user cannot infer any information about server's return except for the result. Another security model is called Malicious model where an adversarial party cheats even in the protocol (e.g. by inputting maliciously chosen invalid values) in order to illegally obtain additional information about the secret. Here we briefly describe one example of an illegal access based on the Malicious model. In our protocol, the user needs to create a bit vector q of N that includes a bit that is 1 and the rest of the N – 1 bits are 0. If the malicious user creates a non-bit vector:</p><formula>q k ¼ 1 ðk ¼ iÞ x ðk ¼ jÞ 0 ðk 6 ¼ i ^ k 6 ¼ jÞ 8 &gt; &gt; &lt; &gt; &gt; :</formula><p>where x is a large integer, the server returns c ¼ Encðv½i þ x Á v½jÞ. When x is larger than any element of v, the user can infer v½i by<ref type="figure" target="#tab_1">Table 1</ref>. The summary of the time, communication and space complexities of PBWT-sec (CP) and an exhaustive method (EX)is the length of query and is the alphabet size</p><formula>' q Þ Oð ffiffiffiffiffiffiffiffiffiffiffiffi DjRj ' q Þ Oð ffiffiffiffiffiffiffiffiffiffiffiffi DjRj ' q Þ EX (server) OðDjRj ' Þ Oð ffiffiffiffiffiffiffiffiffiffiffiffi DjRj ' q Þ OðDjRj ' Þ</formula><p>Both algorithms use SC-OT. M is the number of haplotype sequences (server side), D is the number of queried positions (including D – 1 decoy position to conceal the query position), ' is the length of query and jRj is the alphabet size. ðDecðcÞÞ mod x and v½j by DecðcÞ=x. (For example, if x ¼ 100 and DecðcÞ ¼ 821, the user can detect v½i ¼ 21 and v½j ¼ 8.) Thus the server leaks two elements of v by a single query. In this study, we do not discuss such cases in detail; however, we would like to mention that it is possible to design an algorithm for the Malicious model with a small modification. In order to avoid such attacks, the server needs to verify if the user sends a bit vector which includes only one bit that is 1 and rest of the bits are 0. To achieve this, we suggest using a cryptographic technique called NonInteractive Zero Knowledge Proofs which enables the user to convince a server that each ciphertext EncðmÞ corresponds to a value m 2 f0; 1g, but does not leak any information about which of 0 and 1 is m. Among several algorithms, Sakai's algorithm (<ref type="bibr" target="#b25">Sakai et al., 2013</ref>) has such a property. By using the algorithm, the server knows whether or not q½i 2 f0; 1g. To return a correct result only if q includes only a single 1, it is sufficient for the server to add w ¼ r ð Encðq 0 ÞÈ. .. ÈEncðq NÀ1 ÞÈEncðÀ1ÞÞ to the original result, where r is a random value. Note that w ¼ Encð0Þ iff. q i ¼ 1 and q j ¼ 0 for 0 j &lt; N and i 6 ¼ j.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>In this section, we evaluate the performance of the proposed method on the datasets created from the chromosome 1 data from the 1000 Genomes Project phase 1 data release which consists of 2184 haploid genomes (<ref type="bibr">The 1000</ref><ref type="bibr">Genomes Project Consortium, 2012</ref>). In our experiments and as in Durbin (2014), we used alleles having SNPs, but we did consider indel variants. We used all 2184 genomes of original data for all the experiments. We implemented the proposed algorithm in C þþ based on an open source C þþ library of elliptic curve ElGamal encryption provided by AIST. Our implementation supports communication over the network. We used the standard parameters called secp192k1 (SECG curve over a 192-bit prime field), according to the recommendation by The Standards for Efficient Cryptography Group. For comparison, we also implemented an exhaustive baseline method (see Section 3.6) that achieves the same security and utility as PBWT-sec. In order to perform a fair comparison, both PBWT-sec and the exhaustive method used the same SC-OT module where computation of c k (see Algorithm 1) is simply parallelized by OpenMP. In the first experiment, the user selected a true start position together with 49 decoys (see Section 3.4 for details), and both PBWTsec and the exhaustive method were run with the same computational setting: the user used a single thread of a laptop computer equipped with an Intel Core(TM) i7 3.00 GHz CPU and 16 GB memory, and the server used more than eight threads of another laptop equipped with an Intel Core(TM) i7 2.60 GHz CPU (four cores with hyper-threading) and 8 GB memory. Those two computers communicated over the network. Figures 6 and 7 show run time and data transfer overhead of PBWT-sec and of the exhaustive method. The observed run time and data transfer size of PBWT-sec is linear in the query length, while that of the exhaustive approach is exponential. For query lengths larger than 30 bit, the computation of the exhaustive method did not finish within 24 h. These results fit the theoretical complexity described in Section 3.7. We also evaluated performance of the runtime of PBWT-sec when the user selected 0, 4, 9, 14, and 49 additional decoy positions. The search with a typical query of length 25 SNP positions and no decoy required no more than 15.5 s including communication overhead (<ref type="figure" target="#tab_2">Table 2</ref>). The user's run time of PBWT-sec is relatively small, making it suitable for a practical case where computation power in a server side is generally stronger than that of user side. Since the memory usage of PBWT-sec does not depend on query length, it uses lessPBWT-sec (user to server) PBWT-sec (server to user) Exhaustive (user to server) Exhaustive (server to user)Query length (bit) PBWT-eps (user) PBWT-eps (server) Crypto PBWT (all) Exhaustive (user) Exhaustive (server) Exhaustive (all)<ref type="figure">Fig. 6</ref>. Run time of PBWT-sec and the exhaustive method on 2184 aligned haploid genomes on laptop computers equipped with four cores. The user selected 49 decoy positions for concealing the true query position. The server used all of the four cores with hyper-threading while the user used a single thread. 'PBWT-sec (all)' and 'Exhaustive (all)' include communication overheadThe server used all the four cores with hyper-threading while the user used a single thread. All included communication overhead. D is the number of positions queried simultaneously to conceal the query position (if required). than 60 MB while that of the exhaustive method exponentially increases according to the query length and required 6 GB when the query length is 25 bit. Although the exhaustive method is efficient for short queries, we consider that PBWT-sec is more practical when taking into account that the bit length of a unique substring for a human genome is greater than 31 bits. Moreover, since there are large linkage blocks, even queries with more than 100 bits would not always lead to unique matches in the 1000 genomes data. Hence, the exhaustive search strategy would either not always be able to return a unique match or would be very inefficient. The proposed iterative privacypreserving technique is efficient also for long queries. In the second experiment, we evaluated the performance of the run time of PBWT-sec on a compute node equipped with four CPU sockets (Intel Xeon 2.40 GHz CPU; total of 32 cores with hyperthreading). In this experiment, the user also selected 0, 4, 9, 14 and 49 additional decoy positions. For environmental reasons, we did not perform communication over the network and the data was transferred by file I/O which is also included in run time. Although the current implementation is a prototype and there is room for improvement in terms of parallelization, the server's run time was at an acceptable level in practical configurations (<ref type="figure">Table 3</ref>). We note, that with improvements in parallelization, the server run time may be reduced to 3–4 s.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>In this paper, we have proposed a novel approach for searching genomic sequences in a privacy-preserving manner. Our approach combines an efficient data structure that can be used for recursive search and a novel approach for recursive oblivious transfer. It achieves high utility and has strong security features and requires acceptable compute and communication resources. The developed novel algorithm can find the longest match between a query and a large set of aligned genomic sequences indexed by PBWT. We implemented our algorithm and tested on the dataset created from the 1000 Genomes Project data (The 1000<ref type="bibr">Genomes Project Consortium, 2012</ref>). Compared to an exhaustive baseline approach, our algorithm, named PBWT-sec, was orders of magnitude more efficient both in run time and data transfer overhead for practical query sizes. When the prototype program was run on laptop machines, the total run time including communication time over the network was 15.5 s for searching on 2184 genomes without concealing the query position. Searches with a concealed query position using a compute node took between 18.6 and 133 s depending on the level of privacy.</p><p>As the original data structure supports many useful search options such as wild card search and set maximal search, PBWT-sec could also support those options by using the same techniques used in the original structures in combination with cryptographic techniques, including OT. Moreover, the approach could be easily applied for BWT and has a potential to be applied for other recursively searchable data structures. To the best of our knowledge, the proposed algorithm is the first that allows set-maximal search of genomic sequences in a privacypreserving manner for user and database. We note that the implementation can still be improved and the overall run time can likely be reduced to not more than a few seconds per query. This would make it practical to use our approach in a genomic Beacon (see GA4GH's Beacon Project) that would allow the privacy-preserving search for combinations of variants. It also appears practical to use our approach to enable search by a user that has access to his/her genomic sequence and would like to query the database, for instance, for information related to disease risk without sharing this information with anybody. Finally, the algorithm can also be used to facilitate sharing of genetic information across institutions and countries in order to identify large enough cohorts with a similar genetic backgrounds. This is in spirit of the mission of the Global Alliance for Genome and Health.Wall time includes server (% 90%) and user time (% 10%). D is the number of positions queried simultaneously to conceal the query position (if required).</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>@BULLET</head><figDesc>Given two ciphertexts Encðm 1 Þ and Encðm 2 Þ of integer messages m 1 and m 2 , Encðm 1 þ m 2 Þ can be computed without knowing m 1 , m 2 and the secret key (denoted by Encðm 1 ÞÈEncðm 2 Þ). @BULLET Given a ciphertext EncðmÞ of a message m and an integer e, Encð e Á mÞ can be computed without knowing m and the secret key (denoted by e EncðmÞ). In particular, EncðÀmÞ can be computed in this manner.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.4.</head><figDesc>Fig. 4. Outline of Oblivious Transfer (OT) based on additive homomorphic encryption. See Sections 2.3 and 3.2 for more details</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. Computation of m1 þ m2 on the server in encrypted form by additively homomorphic encryption</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><figDesc>; r ðgÞ ; r 0ðgÞ ; MÞ Randomize return values except for user's target interval by computing the following for all c 2 R Generate temporary random values r</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>20 25 30 35 40 45 50 Data transfer overhead (K byte) Query length (bit)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.7.</head><figDesc>Fig. 7. Data transfer overhead of PBWT-sec and the exhaustive method on 2184 aligned haploid genomes on laptop computers. The user selected 49 decoy positions for concealing the true query position</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 2.</figDesc><table>The run time of a typical query of length 25 SNP positions 
with PBWT-sec on M ¼ 2184 aligned haploid genomes on laptop 
computers equipped with four cores 

User 
Server 
All 

Run time (sec) with D ¼ 1 
4.55 
10.8 
15.5 
Run time (sec) with D ¼ 5 
8.77 
34.0 
43.0 
Run time (sec) with D ¼ 10 
12.5 
65.3 
78.0 
Run time (sec) with D ¼ 20 
17.3 
124 
142 
Run time (sec) with D ¼ 50 
27.5 
311 
339 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 3. The run time of a typical query with PBWT-sec on M ¼ 2184 aligned haploid genomes on a compute node with up to 16 cores with hyper-threading and a query length of 25 SNP positions</figDesc><table>Parallel Compute Cores 
4 
8 
16 

Run time (sec) with D ¼ 1 
22.6 
15.5 
7.9 
Run time (sec) with D ¼ 5 
47.3 
40.0 
18.4 
Run time (sec) with D ¼ 10 
84.5 
68.4 
31.6 
Run time (sec) with D ¼ 20 
154 
114 
56.5 
Run time (sec) with D ¼ 50 
386 
260 
132.6 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">K.Shimizu et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We are thankful to Stephanie L. Hyland for proof-reading the manuscript. We would also like to acknowledge an encouraging discussion with Richard Durbin. We are grateful to the reviewers for their detailed comments that significantly improved the manuscript.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>We gratefully acknowledge funding from AIST (to K.S.), Memorial Sloan Kettering Cancer Center (to G.R.) and NIH (grant 1R01CA176785-01A1). This study was also supported by the Japan-Finland Cooperative Scientific Research Program of Japan Science and Technology Agency (JST; to K.S.). Conflict of Interest: none declared.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Basic local alignment search tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="403" to="410" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Privacy-preserving processing of raw genomic data In: Data Privacy Management and Autonomous Spontaneous Security – 8th International Workshop</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ayday</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">DPM 2013, and 6th International Workshop, SETOP 2013</title>
		<meeting><address><addrLine>Egham, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-09-12" />
			<biblScope unit="page" from="133" to="147" />
		</imprint>
	</monogr>
	<note>Revised. Selected Papers</note>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Countering GATTACA: efficient and secure testing of fully-sequenced human genomes</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Baldi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th ACM Conference on Computer and Communications Security, CCS 2011</title>
		<meeting>the 18th ACM Conference on Computer and Communications Security, CCS 2011<address><addrLine>Chicago, Illinois, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011-10-17" />
			<biblScope unit="page" from="691" to="702" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Secure outsourcing of DNA searching via finite automata</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Blanton</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Aliasgari</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data and Applications Security and Privacy XXIV, 24th Annual IFIP WG 11.3 Working Conference Proceedings</title>
		<meeting><address><addrLine>Rome, Italy</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010-06-21" />
			<biblScope unit="page" from="49" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Privacy-preserving matching of DNA profiles</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Bruekers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IACR Cryptol. ePrint Arch</title>
		<imprint>
			<biblScope unit="page">203</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Secure genomic testing with size-and positionhiding private substring matching</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">D</forename>
				<surname>Cristofaro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th annual ACM Workshop on Privacy in the Electronic Society</title>
		<meeting>the 12th annual ACM Workshop on Privacy in the Electronic Society<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-11-04" />
			<biblScope unit="page" from="107" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Efficient haplotype matching and storage using the positional Burrows–Wheeler transform (PBWT)</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1266" to="1272" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">A public key cryptosystem and a signature scheme based on discrete logarithms</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Elgamal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inf. Theory</title>
		<imprint>
			<biblScope unit="page" from="31" to="469" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Routes for breaching and protecting genetic privacy</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Erlich</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Narayanan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="409" to="421" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Keyword search and oblivious pseudorandom functions</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Freedman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Theory of Cryptography, Second Theory of Cryptography Conference, TCC 2005 Proceedings</title>
		<meeting><address><addrLine>Cambridge, MA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-02-10" />
			<biblScope unit="page" from="303" to="324" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Probabilistic encryption</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Goldwasser</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Micali</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="270" to="299" />
			<date type="published" when="1984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Identifying genetic relatives without compromising privacy</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>He</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="664" to="672" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title level="m" type="main">Succinct static data structures</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">J</forename>
				<surname>Jacobson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>ACM Order number AAI8918056</publisher>
			<pubPlace>PA, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Towards practical privacy for genomic computation</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Jha</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Security and Privacy</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="216" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">BLAT – the BLAST-Like Alignment Tool</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">J</forename>
				<surname>Kent</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="656" to="664" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with Burrows–Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">A survey of sequence alignment algorithms for next-generation sequencing</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Homer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Briefings Bioinf</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="473" to="483" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Soap2: an improved ultrafast tool for short read alignment</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1966" to="1967" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">An oblivious transfer protocol with log-squared communication</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Lipmaa</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Security, 8th International Conference, ISC 2005 Proceedings</title>
		<meeting><address><addrLine>Singapore</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005-09-20" />
			<biblScope unit="page" from="314" to="328" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">New communication-efficient oblivious transfer protocols based on pairings</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Lipmaa</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Information Security, 11th International Conference. Proceedings</title>
		<meeting><address><addrLine>Taipei, Taiwan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008-09-15" />
			<biblScope unit="page" from="441" to="454" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Private string search using the blocksorting algorithm</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Naganuma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Proceedings of SCIS 2012</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>In. Japanese</note>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Public-key cryptosystems based on composite degree residuosity classes</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Paillier</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 17th international conference on Theory and application of cryptographic techniques, EUROCRYPT&apos;99</title>
		<meeting>the 17th international conference on Theory and application of cryptographic techniques, EUROCRYPT&apos;99</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<monogr>
		<title level="m" type="main">How to exchange secrets with oblivious transfer</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">O</forename>
				<surname>Rabin</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Protecting genetic privacy</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">A</forename>
				<surname>Roche</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">J</forename>
				<surname>Annas</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="392" to="396" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Methods for restricting message space in public-key encryption</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Sakai</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Trans</title>
		<imprint>
			<biblScope unit="page" from="96" to="1156" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Privacy risks from genomic data-sharing beacons</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">S</forename>
				<surname>Shringarpure</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">D</forename>
				<surname>Bustamante</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">97</biblScope>
			<biblScope unit="page" from="631" to="646" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">An integrated map of genetic variation from 1,092 human genomes</title>
	</analytic>
	<monogr>
		<title level="m">The 1000 Genomes Project Consortium</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="56" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<monogr>
		<title level="m" type="main">Homomorphic Encryption and Applications. Springer Briefs in Computer Science</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Yi</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Practical fully simulatable oblivious transfer with sublinear communication</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Financial Cryptography and Data Security – 17th International Conference, FC 2013</title>
		<meeting><address><addrLine>Okinawa, Japan</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013-04-01" />
			<biblScope unit="page" from="78" to="95" />
		</imprint>
	</monogr>
	<note>Revised. Selected Papers</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>