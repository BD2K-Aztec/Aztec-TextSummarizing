
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:54+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sprites: detection of deletions from sequencing data by re-aligning split reads</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Zhen</forename>
								<surname>Zhang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>Changsha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">College of Information and Communication Engineering</orgName>
								<orgName type="institution">Hunan Institute of Science and Technology</orgName>
								<address>
									<postCode>414006</postCode>
									<settlement>Yueyang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName>
								<forename type="first">Jianxin</forename>
								<surname>Wang</surname>
							</persName>
							<email>jxwang@mail.csu.edu.cn</email>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>Changsha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Junwei</forename>
								<surname>Luo</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>Changsha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Xiaojun</forename>
								<surname>Ding</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>Changsha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Jiancheng</forename>
								<surname>Zhong</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>Changsha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Jun</forename>
								<surname>Wang</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Department of Molecular Physiology &amp; Biophysics</orgName>
								<orgName type="institution">Baylor College of Medicine</orgName>
								<address>
									<postCode>77030</postCode>
									<settlement>Houston</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<surname>Wu</surname>
								<roleName>Fang-Xiang</roleName>
							</persName>
							<affiliation key="aff3">
								<orgName type="department" key="dep1">Department of Mechanical Engineering</orgName>
								<orgName type="department" key="dep2">Division of Biomedical Engineering</orgName>
								<orgName type="institution">University of Saskatchewan</orgName>
								<address>
									<postCode>S7N 5A9</postCode>
									<settlement>Saskatoon</settlement>
									<region>SK</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yi</forename>
								<surname>Pan</surname>
							</persName>
							<affiliation key="aff4">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Georgia State University</orgName>
								<address>
									<postCode>30302-4110</postCode>
									<settlement>Atlanta</settlement>
									<region>GA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sprites: detection of deletions from sequencing data by re-aligning split reads</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btw053</idno>
					<note type="submission">Received on September 5, 2015; revised on January 25, 2016; accepted on January 25, 2016</note>
					<note>Sequence analysis *To whom correspondence should be addressed. Associate Editor: Inanc Birol Supplementary data: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Advances of next generation sequencing technologies and availability of short read data enable the detection of structural variations (SVs). Deletions, an important type of SVs, have been suggested in association with genetic diseases. There are three types of deletions: blunt deletions , deletions with microhomologies and deletions with microsinsertions. The last two types are very common in the human genome, but they pose difficulty for the detection. Furthermore, finding deletions from sequencing data remains challenging. It is highly appealing to develop sensitive and accurate methods to detect deletions from sequencing data, especially deletions with microho-mology and deletions with microinsertion. Results: We present a novel method called Sprites (SPlit Read realIgnment To dEtect Structural variants) which finds deletions from sequencing data. It aligns a whole soft-clipping read rather than its clipped part to the target sequence, a segment of the reference which is determined by spanning reads, in order to find the longest prefix or suffix of the read that has a match in the target sequence. This alignment aims to solve the problem of deletions with microhomologies and deletions with microinsertions. Using both simulated and real data we show that Sprites performs better on detecting deletions compared with other current methods in terms of F-score. Availability and implementation: Sprites is open source software and freely available at https:// github.com/zhangzhen/sprites. Contact:</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Structural variation (SV) was originally defined as insertions, deletions and inversions larger than 1k bp in size (<ref type="bibr" target="#b10">Feuk et al., 2006</ref>), and now has been extended to include much smaller variants (e.g. those &gt;50 bp in length) (<ref type="bibr" target="#b3">Alkan et al., 2011</ref>) and more types of variants, such as translocation and tandem duplication. These variants are prevalent in human populations and are associated with human diseases, complex traits and evolution (<ref type="bibr" target="#b4">Baker, 2012</ref>). Thus, finding SVs is an important task. Recent advances in high throughput sequencing make it possible to reveal more variants than ever before. Many efforts have been made to detect variants from high throughput sequencing data. For example, the 1000 Genomes Project V C The Author 2016. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com</p><p>Consortium has released SV data of 1092 individuals from 14 populations (<ref type="bibr" target="#b8">Consortium et al., 2012</ref>). Some methods are specially designed for detecting a specific type of SVs: SVSeq (<ref type="bibr" target="#b38">Zhang and Wu, 2011</ref>) for deletion and MindTheGap (<ref type="bibr" target="#b24">Rizk et al., 2014</ref>) for insertion. A deletion indicates a DNA segment missing in an individual genome, also known as a donor/sample genome, compared with the reference genome. Eighty percent of genetic disorders in the disease database, Database Chromosomal Imbalance and Phenotype in Humans using Ensembl Resources (DECIPHER), are caused by deletions (<ref type="bibr" target="#b34">Weischenfeldt et al., 2013</ref>). Deletions are such an important type of SVs that almost every SV discovery tool has developed a module to find deletions. We focus on the discovery of deletions in this article. Read pairs are the most common form of current sequencing data. DNA libraries are generally constructed by shearing a genome into fragments, cloning and size-selecting the fragments. A library is a collection of fragments with a roughly equal size. The length of a fragment excluding adapters at two ends is commonly referred to as the insert size. The insert size varies from fragment-to-fragment. The exact value of insert size for each fragment cannot be determined but its approximate value can be estimated by sampling. The normal range of insert sizes is specified through the library mean and standard deviation (<ref type="bibr">Luo et al., 2015a, b</ref>). Two reads of a read pair are generated by sequencing two ends of a fragment. Before calling variants are performed, these read pairs need to be mapped to a reference genome using read mappers such as BWA (<ref type="bibr" target="#b17">Li and Durbin, 2009</ref>) and Bowtie2 (<ref type="bibr" target="#b15">Langmead and Salzberg, 2012</ref>). If two reads of a read pair are successfully mapped, its insert size is then given as the distance between two corresponding locations on the reference genome. An anomalous insert size indicates a value beyond the normal range. The corresponding read pairs are called discordant read pairs. Analyzing discordant read pairs to reveal variants, such as read pair method, is one of the most common approaches. Many tools adopt such approach, such as BreakDancer (<ref type="bibr" target="#b5">Chen et al., 2009</ref>), PEMer (<ref type="bibr" target="#b14">Korbel et al., 2009</ref>), VariationHunter (<ref type="bibr" target="#b11">Hormozdiari et al., 2009</ref><ref type="bibr" target="#b12">Hormozdiari et al., , 2010</ref>), and GASV (<ref type="bibr" target="#b26">Sindi et al., 2009</ref>). Although read pair methods can improve the resolution of calling with high-coverage data, they uncover variants by giving only inexact positions of breakpoints. The read depth method is another approach that gives approximate breakpoints. Read depth refers to the number of reads mapped to a particular part of the genome and can indicate how many copies of a region are present, but it cannot indicate where the copies occur (<ref type="bibr" target="#b4">Baker, 2012</ref>). SegSeq (<ref type="bibr" target="#b6">Chiang et al., 2009</ref>), EWT (<ref type="bibr" target="#b36">Yoon et al., 2009</ref>) and CNVnator (<ref type="bibr" target="#b0">Abyzov et al., 2011</ref>) are some examples of algorithms that apply this approach. Assembly and split read methods are two types of approaches that are able to detect variants with base-pair breakpoint resolution. Assembly methods exploit aberrations from the reference genome to identify locations where variants might be, and then assemble reads just for that area (<ref type="bibr" target="#b4">Baker, 2012</ref>). Comparing the assembled contigs to the area on the reference genome can detect variants with exact breakpoints. However, assembly methods have limitations. Although only local assembly is performed, all reads of the library are processed in order to construct the k-mer spectrum that is required for assembly. The step requires a large amount of time and memory to run. It also tends not to deal well with heterozygous variants, which occur on only one of a pair of homologous chromosomes (<ref type="bibr" target="#b4">Baker, 2012</ref>). Split reads refer to those that cover breakpoints of variants whether they are single-end or paired-end. Split read methods, as their name implies, derive variants from these split reads. Read aligners can help identify split reads. Given a pair of reads ðr i ; r 0 i Þ, if r i is mapped and r 0 i is either unmapped or soft-clipped at the 5 0-or 3 0-end, r 0 i may be a split read. In some cases it may not be a split read due to either sequencing error or mapping error. There are two ways to use split reads to detect variants: via split read mapping and via soft-clipped mapping. Split read mapping focuses on unmapped reads. An unmapped read was first broken up into two parts. Then, these two parts are respectively mapped to the reference sequence, which results in the breakpoint of the corresponding variant being pinpointed. Examples of split read mapping-based methods include Pindel (<ref type="bibr" target="#b35">Ye et al., 2009</ref>), AGE (<ref type="bibr" target="#b0">Abyzov and Gerstein, 2011</ref>), SVSeq (<ref type="bibr" target="#b38">Zhang and Wu, 2011</ref>), PRISM (<ref type="bibr" target="#b13">Jiang et al., 2012</ref>) and DELLY (<ref type="bibr" target="#b23">Rausch et al., 2012</ref>). Soft-clipped mapping focuses on reads with the 5 0-or 3 0-end soft-clipped. These reads are also called soft-clipping reads. One breakpoint of the variant is specified by the mapping location where soft-clipping occurs. The other breakpoint is determined by aligning the soft-clipped segment of the read to the reference sequence. ClipCrop (<ref type="bibr">Suzuki et al., 2011</ref>), CREST (<ref type="bibr" target="#b33">Wang et al., 2011</ref>), SVSeq2 (<ref type="bibr" target="#b37">Zhang et al., 2012</ref>) and Socrates (<ref type="bibr" target="#b25">Schrö der et al., 2014</ref>) are representatives of soft-clipped mapped-based methods. Split read methods have a few disadvantages, such as time and memory inefficiency, and both high false positive and false negative rates. Some of them do not perform well on low-coverage data. Three deletion types are observed in the human genome: (1) blunt deletions: nothing special happened at the breakpoints, (2) deletions with microhomologies: two small identical sequences at deletion breakpoints, and (3) deletions with microinsertions: deletion breakpoints having a small untemplated sequence inserted.<ref type="bibr" target="#b7">Conrad et al. (2010)</ref>studied the breakpoints of 315 deletions and found that 70% of breakpoints have 1–30 bp of microhomology, 33% of breakpoints contain 1–369 bp of inserted sequence, and 10% of breakpoints have both simultaneously. Only a few breakpoints ($7%) have blunt ends. The presence of microhomology and microinsertion creates problems for re-aligning the clipped part. Microhomology in a soft-clipping read causes the clipped part to be too short for the alignment. The alignment algorithm returns multiple hits for the clipped part. Finding the correct one among these hits is challenging. Microinsertion in the clipped part causes the alignment to fail because inserted sequence cannot match the reference. However, split read mapping can deal with microhomology and microinsertion. Pindel uses the pattern growth approach to report deletions with microinsertions. AGE aligns the 5 0 and 3 0 ends of two given sequences simultaneously and creates a jumping gap to address their presence. Delly follows the AGE approach and makes changes to AGE. Despite the availability of these tools, methods with high accuracy are required for the detection of deletions with microhomologies and microinsertions. In this article, we present a new method called Sprites (SPlit Read re-alIgnment To dEtect Structural variants) for detecting deletions from sequencing data. Sprites can solve the problem that microhomologies and microinsertions cause. It re-aligns the whole read rather than the clipped part to the target sequence, a segment of the reference, in order to find the longest prefix or suffix of the read that has a match in the target sequence. In the case of microhomology, the length of the sequence to be matched is extended to the length of clipped part plus the length of microhomology. The longest mapped prefix or suffix of the read can usually cover microhomology. Thus, the deletion call is easy to determine. In the case of microinsertion, the longest matched prefix or suffix of the read can avoid the impact of microinsertion on the detection. The comparison of the re-alignments of the soft-clipped segment and the whole read is illustrated in<ref type="figure" target="#fig_0">Figure 1</ref>. Sprites uses alignments produced by BWA, while it can also use alignments produced by other read aligners that support 5 0-or 3 0-end soft-clipping, like Bowtie2 (<ref type="bibr" target="#b15">Langmead and Salzberg, 2012</ref>). Re-alignment is one of most time-consuming tasks in the detection. A target sequence is a segment of the reference. For a soft-clipping read, Sprites relies on its spanning read pairs to determine the size and location of target sequences. Given that most of these target sequences have a length of only hundreds of base pairs, re-aligning soft-clipping reads to them saves a large amount of time. The input file has the size on the order of Gigabytes. Sprites transverses it from start to end only once and only stores information about soft-clipping reads that are useful for deletion detection, which reduces Sprites' memory footprint. Besides its great performance on lowcoverage data, Sprites can also be used for the analysis of highcoverage data. We tested it extensively on the simulated data and real sequencing data and compared it with four other detection tools including SVSeq2, LUMPY, Delly and Pindel. The results show that among these tools Sprites is highly sensitive at the relatively low false discovery rates and thus has the greatest F-scores in many cases. The major contributions of this article include: (1) our method can find the longest prefix or suffix of a soft-clipping read that has a match in the target sequence by performing the re-alignment; (2) our method solves the problem of deletions with microhomology and deletions with microinsertion, which are very challenging to be found from the sequencing data; (3) our method limits the alignment length so that time and memory usage are dramatically reduced; (4) a piece of open source software is implemented based on our method and can be freely available.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head><p>Sprites takes as input a BAM file that stores paired-end reads along with alignment information. The BAM file needs to be generated by any read aligner that is able to perform soft-clipping alignment such as BWA, Bowtie2. We mainly focused on soft-clipping reads, at the 5 0-end of which more than a specified number of base pairs are softclipped. These soft-clipping reads then go through the following processing steps. Eventually deletions that these soft-clipping reads indicate will be discovered.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preprocessing</head><p>Preprocessing as the first step of our method is aimed at retrieving some reads from the alignment file. Most of these reads correspond to deletions in the input human genome sample. These reads follow the same pattern: they have soft-clipping signature at either end. Information about all these reads including location, soft-clipping and their mate is stored into a read set when the preprocessing is done. To define the 5 0-end soft-clipping read, we first list two cases for a read pair Pðr i ; r i Þ: Case 1: The first k ri base pairs of the read r i is forwardly mapped, the mate r i is reversely mapped and the read r i appears upstream of the mate r i on the reference. Case 2: The last k ri base pairs of the read r i is reversely mapped, the mate r i is forwardly mapped and the read r i appears downstream of the mate r i on the reference. Read r i in read pair Pðr i ; r i Þ is called 5 0-end soft-clipping if Case 1 or Case 2 is satisfied and the distance from the read r i to the mate r i on the reference is in the range of the mean size within four standard deviations (<ref type="bibr" target="#b17">Li, 2013</ref>), which is called as the normal range in this article. Note that the distance includes the length of two reads in this article. A soft-clipping read r i is represented by a 4-tuple ðseq ri ; k ri ; loc ri ; case ri Þ, where seq ri denotes the sequence of the read, k ri is the length of mapped prefix or suffix and loc ri is the location of soft-clipping. If the read is satisfied with Case 1, case ri is assigned to 1, otherwise to 2. Assume that the insert size of read pairs follows a normal distribution with the mean equal to the library average l and the standard deviation equal to the library standard deviation r. l and r can be estimated by the sample average X and the sample standard deviation s X , respectively. If the insert size and its standard deviation are not given at the beginning, we can use a sampling method presented in<ref type="bibr" target="#b37">Zhang et al. (2012)</ref>to estimate them. In the preprocessing, we will not use the reads for the deletion detection if they have ambiguous alignment. Reads that are from repetitive regions usually have multiple hits, so they are not used for the detection. Soft-clipping reads are selected from the input BAM file and added to a read set R based on the FLAG field and the CIGAR string of each read. Not only does the FLAG field show the mapping orientations of both the read and the mate, but it also indicates whether the distance between them is in the normal range. From the CIGAR string, we can determine the presence of soft-clipping and the value of k i. Suppose that a read r i has a CIGAR string '50S51M', where 'S' represents soft-clipping, 'M' represents matching and the number before them indicates how many base pairs are involved (<ref type="bibr" target="#b17">Li and Durbin, 2009</ref>). We know that the first 50 base pairs are soft-clipped and the remaining 51 base pairs are mapped, i.e. k ri ¼51. One thing to note is that only reads with the length of the soft-clipped segment l ri À k ri larger than or equal to M sc should be kept, where l ri denotes the read length and M sc denotes the minimum alignment length (12 by default). To improve the efficiency of running time, we try to reduce the number of reads in the set R. If multiple reads in R with the same Case are soft-clipped at the same location, i.e. the values of loc and case in their 4-tuples are the same, they will be grouped together. Reads in a group are sorted in ascending order of the length of softA Bclipped prefix or suffix. Then only the middle read in the group is kept and other reads in the group are removed from R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Determining the target sequences</head><p>In this step, we use a reversely mapped read r i with the soft-clipping location loc ri in R, i.e. r i is satisfied with Case 2, to illustrate the process of determining the target sequences. The process is illustrated in<ref type="figure" target="#fig_2">Figure 2</ref>. This lemma ensures that the target sequence Sprites obtains is long enough to completely cover the softclipped segment of r i in almost every case. For each spanning pair of the set SP ri , a set S ri including a target sequence s k ri along with its ending location endðs k ri Þ was created. All sequences in the set of target sequences S ri were then sorted by their ending location. If two adjacent sequences overlap, they will be merged. The larger one of the two ending locations acts as the ending location of the merged sequence. Merging continues until there is nothing left to merge. Actually, a soft-clipping read often corresponds to more than one target sequences. Eventually, Sprites obtained a set of target sequences for each reversely mapped read in the read set R. The set of target sequences S ri will be used to call a deletion for the read r i. The procedure in determining target sequences for a forwardly mapped read is the same except for the following subtleties. In choosing spanning pairs, the range used for selecting r k is from loc ri to loc ri þ l þ 3r À l r k , and r k must be on the left of loc ri. In extracting a target sequence, Sprites takes the fragment of length l þ 3r starting at l oc r k on the reference. When adding a target sequence to S ri , its starting location startðs k ri Þ is added along with it. The smaller one of the two starting locations acts as the starting location of the merged sequence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Finding deletion calls</head><p>The aim of calling deletion is, given a soft-clipping read r i and the set of target sequences S ri , to pinpoint the left breakpoint interval I l ri and the right breakpoint interval I r ri of the deletion that corresponds to r i , respectively. The result obtained at the end of this step is a set of breakpoint interval pairs, which will be merged at the next step. Like the previous step, we used a reversely mapped read to illustrate the process of calling deletions. Target sequences in S ri were arranged in right-to-left order according to their ending location. As a result, the rightmost target sequence was in first place and the leftmost target sequence was in last place. r i was then re-aligned to each target sequence in S ri one by one until Sprites found an alignment between a suffix of r i and a substring of a target sequence of this read, which is satisfied with the following conditions: (1) its length should not be less than M sc ; (2) its percentage identity should not be less than M pi which denotes the minimum percentage identity (96% by default); (3) it is the longest one among all alignments satisfied with the conditions (1) and (2). Both mismatches and indels were taken into account in the alignment. Suppose that when aligning r i to the target sequences in S ri , an alignment a i between the suffix of r i and a substring of the target sequence s k ri was found. The initial location of the right breakpoint was computed using endðs k ri Þ À l ai , where l ai denotes the length of a i. If l ai is larger than the length of soft-clipped segment l ri À k ri , the deletion is mediated by microhomology with high probability, especially when neither sequencing error nor mapping error happens. So an interval with a length of jl ai À l ri þ k ri j starting at the location en dðs k ri Þ À l ai can be used to represent the right breakpoint. loc ri denotes the initial location of the left breakpoint. Similarly, an interval with a length of jl ai À l ri þ k ri j ending at loc ri is used to represent the left breakpoint. The two intervals of left and right breakpoints which represent a deletion call of r i are added to a call set D. If l ai is less than l ri À k ri , a small non-template insertion may occur with high probability, especially when neither sequencing error nor mapping error happens. In this case, an interval with a length of jl ai À l ri þk ri j ending at the location endðs k ri Þ À l ai is used to represent the right breakpoint. The left breakpoint is represented by another interval starting at loc ri with the same length. Similarly, the two intervals of left and right breakpoints are added to the call set D. Each deletion call was represented by a pair of intervals which represent the left breakpoint and the right breakpoint, respectively, i.e. the left interval and the right interval. It is clear that each read in R has one deletion call at most. The length of the deletion call was determined by subtracting the starting location of the left interval from the starting location of the right interval. When dealing with a forwardly mapped read with soft-clipping, there were small differences in calling deletions. Target sequences of S ri were arranged in left-to-right order instead. Sprites searched for an alignment between the longest prefix of r i and a substring of a target sequence. The initial location of the left breakpoint was computed using startðs k ri Þ þ l ai. The initial location of the right breakpoint was denoted by loc ri. When l ai &gt; l ri À k ri , the interval with a length of jl ai À l ri þ k ri j ending at startðs k ri Þ þ l ai was used to represent the left breakpoint, and the interval with the same length starting at loc ri was used to represent the right breakpoint. When l ai &lt; l ri À k ri , the interval with a length of jl ai À l ri þ k ri j starting at s tartðs k ri Þ þ l ai was used to represent the left breakpoint, and the interval with the same length ending at loc ri was used to represent the right breakpoint. A deletion call is represented by a pair of intervals ðI l i ; I r i Þ, where I l i and I r i denote the left interval and the right interval, respectively. Two calls are said to overlap if their left intervals overlap and their right intervals overlap at the same time. These calls were lexically sorted by the ordered vector consisting of the start of I l i , the end ofThe segment A and C are adjacent in the donor, but they are not adjacent in the reference. The segment B of the reference refers to a deletion that occurs on the donor sequence. The arrow r i is a 5 0-end soft-clipping read. The solid part represents the mapped part of the read, while the hollow part represents the soft-clipped part of the read. The arrow pair ðr k ; r k Þ is a spanning pair for r i SpritesI l i , the start of I r i and the end of I r i. The first call is kept in D. If any subsequent calls overlap it, they are removed from D. The second call in D is dealt with in the same way. This process continues until the last call is done. The resulting call set D is output to a file in the BEDPE format, which is used to specify genomic regions, at the end.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head><p>We compared Sprites with the four most commonly used SV detection tools, i.e. Pindel, SVSeq2, Delly and LUMPY (<ref type="bibr" target="#b16">Layer et al., 2014</ref>). Pindel is the first tool that relies on the concept of splitting reads to detect variants. Besides deletions, it is able to call other types of variants, such as insertions and inversions. SVSeq2 is a tool that specializes in finding deletion calls. Deletions are called by realigning the soft-clipped sequence of reads, which is similar to our tool. It focuses on analyzing low-coverage data. The latest version of SVSeq2 can only process one chromosome at a time. When working on whole genome data, we first ran SVSeq2 for each chromosome (or contig) of the human reference genome and then concatenated the results of individual chromosomes to obtain the final results. LUMPY is a probabilistic-based approach for SV discovery, which integrates multiple SV detection signals, such as read pairs, split reads, thereby achieving a substantial improvement in detection as compared with other popular SV tools such as BreakDancer, GASVPro (<ref type="bibr" target="#b27">Sindi et al., 2012</ref>). Homozygous variants are commonly used for the detection evaluation. However, heterozygous variants are prevalent variants which are often less deleterious but more frequent among genetic disorders compared with homozygous variants. Moreover, the detection of heterozygous variants plays a substantial role in the tumor study because that real samples tend to be a mixture of abnormal and normal genomes and tumor samples usually to have more heterogeneous variants than homozygous ones (<ref type="bibr" target="#b34">Weischenfeldt et al., 2013</ref>). However, detecting heterozygous variants is problematic. So we use heterozygous variants for the evaluation besides homozygous variants. Ryan Layer, the author of Lumpy, provided us with two artificial genomes: one genome with 2500 randomly generated deletions of size 100 bp to 10 kbp, the other genome with 5516 non-randomly generated deletions. The 5516 deletions were publicly released by the 1000 Genomes Project. SVSim (https://github.com/ GregoryFaust/SVsim), an SV simulator, was used to generate these genomes by introducing these deletions into the b37 version of human reference, also known as GRCh37 version. The FASTA file of the b37 version can be found at ftp://ftp.1000genomes.ebi.ac.uk/ vol1/ftp/technical/reference/. The location of these simulated deletions in these genomes was recorded in two BEDPE files. We used the first genome for homozygous deletion detection and the second genome for heterozygous deletion detection. The first genome was intended for homozygous deletion detection. We used wgsim (https://github.com/lh3/wgsim), a read simulator, to sequence this genome with 2Â, 5Â, 10Â, 20Â and 50Â haploid coverage, respectively, to generate paired-end reads of length 150 bp. The insert size of paired-end reads was centered at 500 bp with the standard deviation equal to 50 bp. Generated reads contained sequencing errors (the overall error rate of 0.5%). The second genome was intended for heterozygous deletion detection. In order to generate heterozygous deletions, a normal genome and an abnormal genome were required. We used the b37 version of the human reference genome as the normal genome and the genome with 5516 deletions as the abnormal genome. Pairedend reads were generated by using wgsim to sequence the two genomes with 0.05, 0.1, 0.2 and 0.5 SV allele frequencies at 10Â, 20Â and 40Â, respectively. For example, we generated reads with 0.05 SV allele frequency at 10Â coverage like this: we used wgsim to sequence the normal genome at 9.5Â haploid coverage and sequence the abnormal genome at 0.5Â haploid coverage, then the two sets of reads were combined to form pair-end reads with 0.05 SV allele frequency at 10Â coverage. Reads for heterozygous deletions have the same properties with reads for homozygous deletions. Whether reads are for homozygous deletions or for heterozygous deletions, they need to be mapped to the reference for use with detection tools. BWA ALN was used to map reads. Then, alignment files were sorted and indexed by SAMtools (<ref type="bibr" target="#b17">Li et al., 2009</ref>). LUMPY required as input two BAM files: a file that was the original BAM file and a file that represented split read alignment. The split read alignment file was generated as follows: split reads were first extracted from the original BAM file using a custom script provided along with the Lumpy program; these split reads were then realigned by YAHA (<ref type="bibr" target="#b9">Faust and Hall, 2012</ref>). Furthermore, we used the data of the NA12878 individual released by the Illumina Platinum Genomes project and the data of the five other individuals (NA19311, NA19312, NA19313, NA19316 and NA19317) provided by the 1000 genomes project, as the real data for the evaluation. Sprites uses two micro-intervals to represent the two breakpoints of a deletion. Micro-intervals reflect the fact that microhomologies and microinsertions occur at deletion breakpoints. LUMPY also uses two intervals to represent breakpoints. However, for each deletion SVseq2 and Pindel predicted, two breakpoints were converted to two breakpoint intervals with a length 100 bp. For each known deletion, the same conversion was performed. Since Delly provides the confidence interval of deletion breakpoints, we used them as breakpoint intervals and no conversion was performed. A deletion call is represented by two breakpoint intervals A and B. A known deletion is represented by two breakpoint intervals A 0 and B 0. The deletion calls overlaps the known deletion if and only if A overlaps A 0 and B overlaps B 0. BEDTools (<ref type="bibr" target="#b22">Quinlan and Hall, 2010</ref>) was used for checking such overlaps. A call is a true positive (TP) if the call overlaps a known deletion, otherwise it is a false positive (FP). False negatives (FN) refer to the known deletions that SV detection tools failed to report. A comprehensive measure, called F-score, is mainly used to evaluate the methods. The F-score is defined as the harmonic mean of the sensitivity and the precision (1 À FDR). The sensitivity is defined as TP TPþFN while the false discovery rate (FDR) is defined as FP TPþFP .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Evaluation on the strategy of re-aligning the whole read</head><p>We designed a dedicated experiment to show Sprites's improvement in the detection of deletions with microhomology and microinsertion. One hundred thirty-two validated deletions, which consists of 10 blunt deletions (7.6%), 96 deletions with microhomology (72.7%) and 26 deletions with microinsertion (19.7%), were introduced to the chromosome 15 of the Hg18 reference. These 132 deletions reported by<ref type="bibr" target="#b21">Mills et al. (2011)</ref>are from 45 individuals of the CEU population on the chromosome 15, and the frequencies of lengths of these deletions share the same trend with the frequencies of lengths of deletions found by the 1000 Genomes Project. Furthermore, the frequencies of three deletion types roughly match the frequencies of three deletion types (<ref type="bibr" target="#b7">Conrad et al., 2010</ref>) found. Simulated paired-end reads (101 Â 2 bp) were then generated by wgsim at the error rate 0.005 and at the coverage of 5. The mean and the standard deviation of insert size are 500 and 50, respectively. The results in<ref type="figure" target="#tab_1">Table 1</ref>show that Sprites achieves the highest detection accuracy and is the most sensitive in finding deletions with microhomology and microinsertion. SVseq2 that re-aligns the clipped part is much less sensitive in finding deletions with microinsertion. Delly that uses split read mapping and Pindel that applies the pattern growth approach are less sensitive than Sprites that realigns the whole read.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Results on simulated homozygous deletions</head><p>Sensitivity and FDR of homozygous deletion detection on five tools are shown in Supplementary Table S1. Sprites consistently achieves higher sensitivity than other tools across almost all coverage levels. Pindel is negligibly more sensitive than Sprites at 20Â and 50Â coverage (99.4 versus 98.5% and 99.5 versus 98.5%), but has much higher FDR than Sprites (4.2 versus 0.4% and 18.8 versus 0.9%) at the same coverages. In terms of sensitivity, Sprites performs extraordinarily well at the low coverage (2Â and 5Â). It is more sensitive than the second best (SVseq2 and LUMPY) at 2Â and 5Â coverage (59.3 versus 44.8% and 92.1 versus 86.2%). The FDR of Sprites rises as the coverage increased from 2Â to 50Â, but the maximal FDR that appeared at 50Â coverage is very small, just 0.9%. Although SVSeq2 has the lowest FDR over all coverage levels, it is not so sensitive compared to others in general. To comprehensively compare all five methods,<ref type="figure" target="#fig_3">Figure 3</ref>shows that F-score of homozygous deletion detection on five tools. Sprites gets the best F-score in all cases. In terms of F-score, Sprites performs even better in low-coverage data than other tools. The results show the evidence that our method is effective in solving the problems caused by deletions with microhomologies and microinsertions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Results on simulated heterozygous deletions</head><p>Supplementary Tables S2 and S3 show the sensitivity and FDR of heterozygous deletion detection on five tools, respectively. Sprites is more sensitive than others where either SV allele frequency or the coverage or both are low, i.e. the abnormal genome is sequenced at lower coverages. As a major competitor to Sprites for SV detection from low-coverage data, SVSeq2 performs well compared with LUMPY and Pindel, but is less sensitive than Sprites. For example, Sprites and SVSeq2 correctly detect 50.9 and 39.2% of deletions, respectively, in the case of 0.1 SV allele frequency and 10Â coverage. As seen from Supplementary<ref type="figure">Table S3</ref>, SVSeq2 achieves the lowest FDR in nearly all cases. The FDRs of Sprites and SVSeq2 are generally very close. The highest difference (0.6%) between the FDRs of Sprites and SVSeq2 appears in the case of 0.5 SV allele frequency and 40Â coverage. Sprites achieves a lower FDR than SVSeq2 in the case of 0.05 SV allele frequency and 50x coverage.<ref type="figure" target="#fig_4">Figure 4</ref>shows that F-score of heterozygous deletion detection on five tools. At 10Â and 20Â coverage, the F-score of Sprites is the best with 0.05, 0.1 and 0.2 SV allele frequencies. With 0.5 SV allele frequency, the F-score Sprites is not the best. At 40Â coverage, the F-score of Sprites is the best only with 0.05 and 0.1 SV allele frequencies while it is not better in other cases compared with Lumpy and Pindel. The reason may be that both Lumpy and Pindel directly use paired-end information while Sprites does not use this information directly. Actually high-coverage data contain much more paired-end information which can help improve the detection if directly used.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Results on the subsample of NA12878</head><p>Calls made from the real data are difficult to evaluate in terms of sensitivity and FDR because there are still variants that remain unknown for each individual. The number of known variants varies from individual to individual. However, performance comparison based on the real data is indispensable because not all sequencing artifacts can be simulated by any read simulator. Besides, only if an SV detection tool performs well and precisely on the real data, can biologists actually benefit from this. Sequencing data of NA12878 is most commonly used in the evaluation of SV tools. The golden standard SV list we used is recently released in (<ref type="bibr" target="#b2">Abyzov et al., 2015</ref>). This list contains 8943 deletions. Two FASTQ files storing paired-end reads of the NA12878 sample were downloaded under the run accession ERR194147 from the European Nucleotide Archive (http://www.ebi.ac.uk/ena). We subsampled 10% paired-end reads from these files by setting each paired-end read to have a probability of 0.1 to be selected. Since the original files have approximately 50Â coverage, so the resulting subsampling files had roughly 5Â coverage. They were then mapped with BWA ALN and sorted with SAMtools. We can see from<ref type="figure" target="#tab_2">Table 2</ref>that in terms of sensitivity, Sprites obtained the best value (14.12%); in terms of FDR, although Sprites got the second better value (42.7%), the difference between the value and the best one that SVSeq2 got (38.03%), is not that large. Sprites performs the best among all five methods in terms of the comprehensive F-score.Sprites</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Results on the illumina data of five individuals</head><p>We used five real datasets from the 1000 Genomes Project to compare Sprites with SVSeq2, LUMPY, Pindel and Delly. Alignment files for chromosome 20 of five individuals that were also used for the evaluation in the SVSeq2 paper (NA19311, NA19312, NA19313, NA19316 and NA19317), were able to be downloaded from ftp://ftp. ncbi.nlm.nih.gov/1000genomes/ftp/phase1/data/. These files have been generated by mapping paired-end reads with BWA ALN. Each file involves only one fragment library and the insert size of each library is specified in the header section of each BAM file. Since the standard deviation of reads is not given, it is computed by detection tools themselves. Reads of NA19311, NA19312 and NA19313 have the insert size of 400, and reads of the other two individuals have that of 213. The coverages of these five samples NA19311, NA19312, NA19313, NA19316 and NA19317 are 4.6, 5.4, 5.5, 6.2 and 6.2, respectively. Lumpy, Pindel SVseq2 and Delly are run with default parameters. For Sprites, we set the mismatching rate and the minimum overlap length to 0.1 and 15, respectively; the same mean and the same standard deviation of the insert size are used as SVSeq2.<ref type="figure">Table 3</ref>shows the sensitivity, FDR and F-score of each tool for each individual. The F-scores of Sprites and SVseq2 are very close and better than others for NA19311 and NA19312. For NA19313, Sprites gets the highest F-score. For NA19316, the F-score of Sprites is slightly lower than Pindel and higher than others. For NA19317, the F-score of Sprites is ranked third.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.6">Speed and memory usage</head><p>The dataset for the chromosome 20 of NA19312 at the coverage of about 5.4 to benchmark the speed and memory usage of these five tools. The chromosome has 63, 025, 520 bp. All tools were run as a single thread with default arguments on a 2-GHz 12-core Intel Xeon server with 512-Gb RAM. The time of extracting splitters and discordants for Lumpy is not included in the comparison. From<ref type="figure">Table 4</ref>, it can be clearly seen that Sprites runs much faster than the other tools with the least memory footprint. Sprites deals with only soft-clipping reads one by one without saving them in memory. The alignment is one of performance bottlenecks in the detection. Sprites uses Lemmas in the SVseq2 paper to determine target sequences. These sequences have the length of hundreds of base pairs on average. This keeps the alignment from requiring much time and memory to run.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discussion</head><p>Sprites is a new deletion detection method based upon re-aligning soft-clipping reads. Results of tests on both simulated and real data show that Sprites is more sensitive in low-coverage data. The false discovery rate of Sprites is also low. As a result, Sprites performs the best overall in terms of the F-score in low-coverage data. Furthermore, there is also evidence that realigning soft-clipping reads is more effective than realigning their soft-clipped segments. Tests on simulated data show that Sprites is able to detect deletions with microhomologies and microinsertions at breakpoints in addition to blunt deletions. We have only used reads with soft-clipping at the 5 0-end because 5 0-end has generally higher quality than 3 0end. The reason why Sprites does not work well in high-coverage data may be that Sprites does not directly use paired-end information for the detection. Since there is plenty of paired-end information in high-coverage data, such information could play a more important role in the detection in high-coverage data than in low-coverage data. Utilizing paired-end information in order to improve its performance in high-coverage data is one of directions of our future work. The development of next generation sequencing technologies has increased read length from 36 to 100–200 bp. As a result, SV detection methods have shifted from pure PE methods to SR and to hybrid methods such PE þ SR methods. As the trend continues, we believe that re-aligning split reads-based methodology will play an important role in SV detection in population-scale and cancergenome studies, because such methods are applicable to these types of data.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Comparison between the re-alignments of the soft-clipped segment and the whole read in the detection of deletions with microhomology and microinsertion. The read r consists of three segments: r 1 , r 2 and r 3. The realignment of the soft-clipped segment is shown above the reference. The realignment of the whole read is shown below the reference. The segments A and C are common in both the reference and the donor. The segment B represents the deletion in the donor. (A) Microhomology at the breakpoints. The two Ds refer to microhomologies. They are two identical sequences of small size. The read includes one D, expressed as r 2. r 3 represents the soft-clipped segment. (B) Microinsertion at the breakpoints. D is a microinsertion. r 2 refers to the microinsertion</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>. A read pair Pðr k ; r k Þ with r k forwardly mapped and r k reversely mapped is called a spanning pair SP ri ðr k ; r k Þ on the read r i when r k occurs in the range from loc ri À l À 3r þ l r k to loc ri and r k must be on the right of loc ri. This range was derived according to Lemma 1 in Zhang et al. (2012), which guarantees that almost all read pairs from this range really span the soft-clipping location loc ri , i.e. one breakpoint of r i. All possible spanning pairs on the read r i were selected and added to a set SP ri. Given a spanning pair SP ri ðr k ; r k Þ, a fragment of length l þ 3r ending at the location loc r k þ l r k , which we call a target sequence s k ri of the read r i , was extracted from the reference according to Lemma 2 in Zhang et al. (2012)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. Identification of spanning pairs and re-alignment of 5 0-end soft-clipping reads in Case 2. The segment A and C are adjacent in the donor, but they are not adjacent in the reference. The segment B of the reference refers to a deletion that occurs on the donor sequence. The arrow r i is a 5 0-end soft-clipping read. The solid part represents the mapped part of the read, while the hollow part represents the soft-clipped part of the read. The arrow pair ðr k ; r k Þ is a spanning pair for r i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. Performance comparison of homozygous deletions. Two thousand five hundred deletions are randomly generated in the simulation (Color version of this figure is available at Bioinformatics online.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.4.</head><figDesc>Fig. 4. Performance comparison of deletion detection in the heterozygous simulation. This simulation introduced 5516 non-overlapping deletions identified by the 1000 Genomes Project (Color version of this figure is available at Bioinformatics online.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Table 1.</figDesc><table>The comparison of the detection of deletions with micro-
homology and microinsertion 

Tool 
Total FDR Sensitivity 
of blunt 
deletions 

Sensitivity of 
deletions with 
microhomology 

Sensitivity of 
deletions with 
microinsertion 

Sprites 
0 
60 
76 
76.9 
SVseq2 
0 
20 
22.9 
15.4 
Lumpy 
4.6 
60 
62.5 
65.4 
Pindel 
2.5 
60 
59.4 
53.8 
Delly 
9.4 
60 
65.6 
69.2 

FDR, false discovery rate. Sensitivity and FDR are expressed as 
percentages. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 2. Performance comparison of deletion detection in a 5Â subsample of Illumina sequencing data of NA12878</figDesc><table>Tool 
Sensitivity 
FDR 
F-score 

Sprites 
14.1 
42.7 
0.227 
SVseq2 
4.7 
38 
0.088 
Lumpy 
9.1 
77.7 
0.129 
Pindel 
8 
61.7 
0.132 
Delly 
13.8 
87.7 
0.13 

FDR is short for false discovery rate. Sensitivity and FDR are expressed as 
percentages. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 3. Comparison of results on five individuals</figDesc><table>Q1 
NA19311 
NA19312 
NA19313 
NA19316 
NA19317 

S 
FDR 
F-score 
S 
FDR 
F-score 
S 
FDR 
F-score 
S 
FDR 
F-score 
S 
FDR 
F-score </table></figure>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Z.Zhang et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Suzuki,S. et al. (2011) Clipcrop: a tool for detecting structural variations with single-base resolution using soft-clipping information. BMC Bioinformatics, 12(Suppl 14), S7.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We are grateful to Ryan Layer for his generously providing simulated data and giving advice. We would also like to thank Jeffrey Duerr for taking the time and effort to help us revise the paper.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This work was supported by the National Natural Science Foundation of China under Grant Nos. 61232001, 61379108 and 61370172. Conflict of Interest: none declared.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Age: defining breakpoints of genomic structural variants at single-nucleotide resolution, through optimal alignments with gap excision</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Abyzov</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Gerstein</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="595" to="603" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Cnvnator: an approach to discover, genotype, and characterize typical and atypical cnvs from family and population genome sequencing</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Abyzov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="974" to="984" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Analysis of deletion breakpoints from 1,092 humans reveals details of mutation mechanisms</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Abyzov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Commun</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page">7256</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Genome structural variation discovery and genotyping</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Alkan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="363" to="376" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Structural variation: the genome&apos;s hidden architecture</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Baker</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="133" to="137" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Breakdancer: an algorithm for high-resolution mapping of genomic structural variation</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Chen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="677" to="681" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">High-resolution mapping of copy-number alterations with massively parallel sequencing</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">Y</forename>
				<surname>Chiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="99" to="103" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Mutation spectrum revealed by breakpoint sequencing of human germline cnvs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">F</forename>
				<surname>Conrad</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="385" to="391" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">An integrated map of genetic variation from 1,092 human genomes</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">P</forename>
				<surname>Consortium</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">491</biblScope>
			<biblScope unit="page" from="56" to="65" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Yaha: fast and flexible long-read alignment with optimal breakpoint detection</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">G</forename>
				<surname>Faust</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<forename type="middle">M</forename>
				<surname>Hall</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="2417" to="2424" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Structural variation in the human genome</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Feuk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="85" to="97" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Combinatorial algorithms for structural variation detection in high-throughput sequenced genomes</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Hormozdiari</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1270" to="1278" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Next-generation variationhunter: combinatorial algorithms for transposon insertion discovery</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Hormozdiari</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="350" to="357" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Prism: pair-read informed split-read mapping for basepair level detection of insertion, deletion and structural variants</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="2576" to="2583" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Pemer: a computational framework with simulationbased error models for inferring genomic structural variants from massive paired-end sequencing data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">O</forename>
				<surname>Korbel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">23</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Lumpy: a probabilistic framework for structural variant discovery</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">M</forename>
				<surname>Layer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">84</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Aligning sequence reads, clone sequences and assembly contigs with Fast and accurate short read alignment with burrows-wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<surname>Bwa-Mem</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Arxiv E-Prints Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">The sequence alignment/map format and samtools</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2078" to="2079" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Epga: de novo assembly using the distributions of reads and insert size</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Luo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="31" to="825" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Epga2: memory-efficient de novo assembler</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Luo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="3988" to="3990" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Mapping copy number variation by population-scale genome sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">E</forename>
				<surname>Mills</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">470</biblScope>
			<biblScope unit="page" from="59" to="65" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Bedtools: a flexible suite of utilities for comparing genomic features</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">R</forename>
				<surname>Quinlan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<forename type="middle">M</forename>
				<surname>Hall</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="841" to="842" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Delly: structural variant discovery by integrated paired-end and split-read analysis</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Rausch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="333" to="339" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Mindthegap: integrated detection and assembly of short and long insertions</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Rizk</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="3451" to="3457" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Socrates: identification of genomic rearrangements in tumour genomes by re-aligning soft clipped reads</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Schrö Der</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="1064" to="1072" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">A geometric approach for classification and comparison of structural variants</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Sindi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="222" to="230" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">An integrative probabilistic model for identification of structural variation in sequencing data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">S</forename>
				<surname>Sindi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol. R22. Sprites</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">19</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<monogr>
		<title level="m" type="main">S is sensitivity and FDR is false discovery rate. We estimated that the coverages of NA19311</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="m">5Â, 6.2Â and 6.2Â, respectively</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<monogr>
		<title level="m" type="main">Table 4 Comparison of five tools on the speed and memory usage Tool Run time Peak memory usage (kb) Sprites 45</title>
		<imprint>
			<date type="published" when="23552" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<monogr>
		<title level="m" type="main">Lumpy 1 min 8 s 290800</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<monogr>
		<title level="m" type="main">Pindel 38 min 18 s 15188048</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">Crest maps somatic structural variation in cancer genomes with base-pair resolution</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="652" to="654" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">Phenotypic impact of genomic structural variation: insights from and for human disease</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Weischenfeldt</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="125" to="138" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">Pindel: a pattern growth approach to detect break points of large deletions and medium sized insertions from paired-end short reads</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Ye</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2865" to="2871" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b36">
	<analytic>
		<title level="a" type="main">Sensitive and accurate detection of copy number variants using read depth of coverage</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Yoon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1586" to="1592" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b37">
	<analytic>
		<title level="a" type="main">An improved approach for accurate and efficient calling of structural variations with low-coverage sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page">6</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>Suppl. 6</note>
</biblStruct>

<biblStruct   xml:id="b38">
	<analytic>
		<title level="a" type="main">Svseq: an approach for detecting exact breakpoints of deletions with low-coverage sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Wu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="3228" to="3234" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>