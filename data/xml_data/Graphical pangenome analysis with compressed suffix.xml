
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:54+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Graphical pan-genome analysis with compressed suffix trees and the Burrows–Wheeler transform</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Uwe</forename>
								<surname>Baier</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Theoretical Computer Science</orgName>
								<orgName type="institution">Ulm University</orgName>
								<address>
									<postCode>89069</postCode>
									<settlement>Ulm</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Timo</forename>
								<surname>Beller</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Theoretical Computer Science</orgName>
								<orgName type="institution">Ulm University</orgName>
								<address>
									<postCode>89069</postCode>
									<settlement>Ulm</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Enno</forename>
								<surname>Ohlebusch</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Theoretical Computer Science</orgName>
								<orgName type="institution">Ulm University</orgName>
								<address>
									<postCode>89069</postCode>
									<settlement>Ulm</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Graphical pan-genome analysis with compressed suffix trees and the Burrows–Wheeler transform</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btv603</idno>
					<note type="submission">Received on July 30, 2015; revised on September 17, 2015; accepted on October 13, 2015</note>
					<note>Genome analysis *To whom correspondence should be addressed. Associate Editor: John Hancock Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Low-cost genome sequencing gives unprecedented complete information about the genetic structure of populations, and a population graph captures the variations between many individuals of a population. Recently, Marcus et al. proposed to use a compressed de Bruijn graph for representing an entire population of genomes. They devised an Oðn log gÞ time algorithm called splitMEM that constructs this graph directly (i.e. without using the uncompressed de Bruijn graph) based on a suffix tree, where n is the total length of the genomes and g is the length of the longest genome. Since the applicability of their algorithm is limited to rather small datasets, there is a strong need for space-efficient construction algorithms. Results: We present two algorithms that outperform splitMEM in theory and in practice. The first implements a novel linear-time suffix tree algorithm by means of a compressed suffix tree. The second algorithm uses the Burrows–Wheeler transform to build the compressed de Bruijn graph in Oðn log rÞ time, where r is the size of the alphabet. To demonstrate the scalability of the algorithms , we applied it to seven human genomes. Availability and implementation:</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Background</head><p>Second-and third-generation sequencers produce vast amounts of DNA sequence information, and it is often the case that multiple genomes of the same or closely related species are available. An example is the 1000 Genomes Project, which started in 2008. Its goal was to sequence the genomes of at least 1000 humans from all over the world and to produce a catalog of all variations (SNPs, indels, etc.) in the human population. In this article, the term 'pan-genome' of the population refers to the genomic sequences together with this catalog.<ref type="bibr" target="#b18">Tettelin et al. (2005)</ref>coined the term pan-genome a decade ago; they evaluated the composition of six strains of Streptococcus agalactiae. The pan-genome analysis of other bacteria followed: e.g. the pan-genome structure of Escherichia coli was studied by<ref type="bibr" target="#b14">Rasko et al. (2008)</ref>. In a broader sense, the pan-genome defines the entire genomic repertoire of a given phylogenetic clade (which may range from species to phylum and beyond). One distinguishes between the core genome that contains genes shared by all strains within the clade (housekeeping genes, etc.), the dispensable genome (made of genes shared by only a subset of the strains) and strain-specific genes. Since the de novo assembly of, e.g. mammalian genomes, is still a serious problem (both from a technological and a budgetary point of view), the reference-based approach dominates in genomics. Small wonder that most methods to represent a pan-genome by a graph are reference based. Here, we briefly discuss a few of them:<ref type="bibr" target="#b16">Schneeberger et al. (2009)</ref>were the first to explicitly model variation in a population DAG of a few Arabidopsis thaliana genomes.<ref type="bibr" target="#b13">Rahn et al. (2014)</ref>used a data structure called 'Journaled String Tree' to consistently represent both SNPs and indels as edits to a reference genome, and<ref type="bibr" target="#b4">Dilthey et al. (2015)</ref>use a population reference graph for genome inference. In contrast to these works, which are all alignment-based,<ref type="bibr" target="#b12">Paten et al. (2014)</ref>came up with a different solution: they proposed context mapping to relate genomes.<ref type="bibr" target="#b9">Marcus et al. (2014)</ref>proposed a reference-and alignment-free approach for pan-genome analyses. Ideally, it takes multiple assembled genomes as input, but it can also work with contigs. For some species, especially medically important bacteria, multiple complete genomes are available. For example, in 2015, NCBI GenBank contained 72 strains of Chlamydia trachomatis (a sexually transmitted human pathogen) and 62 strains of the prokaryotic model organism E.coli.<ref type="bibr" target="#b9">Marcus et al. (2014)</ref>proposed a compressed de Bruijn graph as a graphical representation of the relationship between genomes. Basically, it is a compressed version of the colored de Bruijn graph introduced by<ref type="bibr" target="#b8">Iqbal et al. (2012</ref><ref type="bibr" target="#b9">). Marcus et al. (2014</ref>describe an Oðn log gÞ time algorithm that directly computes the compressed de Bruijn graph based on a suffix tree (ST), where n is the total length of the genomes and g is the length of the longest genome. They write about their software splitMEM: 'Future work remains to improve splitMEM and further unify the family of sequence indices. Although. .. , most desired are techniques to reduce the space consumption. .. ' In this article, we present two different techniques that achieve this goal. The first implements a novel linear-time suffix tree algorithm by means of a compressed ST (CST). The second algorithm uses the Burrows–Wheeler transform to build the compressed de Bruijn graph in Oðn log rÞ time, where r is the size of the alphabet R. Preliminary ideas for the second algorithm were presented by<ref type="bibr" target="#b0">Beller and Ohlebusch (2015)</ref>. In contrast to splitMEM, both of our algorithms use only O(n) space. The contracted de Bruijn graph introduced by Cazaux et al.</p><p>(2014) is not identical with the compressed de Bruijn graph. A node in the contracted de Bruijn graph is not necessarily a substring of one of the genomic sequences [see the remark following Definition 3 in the article by<ref type="bibr" target="#b3">Cazaux et al. (2014)]</ref>. Thus the contracted de Bruijn graph, which can be constructed in linear time from the ST, is not useful for our purposes. Very recently, other alignment-free and reference-free approaches were described by Solomon and Kingsford (2015) and<ref type="bibr" target="#b7">Holley et al. (2015)</ref>. Both are k-mer approaches that use Bloom filters. We will discuss their relationship to the splitMEM approach in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Problem definition</head><p>Given a string S of length n and a natural number k, the de Bruijn graph representation of S contains a node for each distinct length k substring of S, called a k-mer. Two nodes u and v are connected by a directed edge u ! v if u and v occur consecutively in S, i.e. u ¼ S½i::i þ k À 1 and v ¼ S½i þ 1::i þ k, where S½i::j denotes the substring of S starting with the character at position i and ending with the character at position j.<ref type="figure" target="#fig_0">Figure 1</ref>shows an example. Clearly, the graph contains at most n nodes and n edges. By construction, adjacent nodes will overlap by k – 1 characters, and the graph can include multiple edges connecting the same pair of nodes or self-loops representing overlapping repeats. For every node, except for the start node (containing the first k characters of S) and the stop node (containing the last k characters of S), the in-degree coincides with the out-degree. A de Bruijn graph can be 'compressed' by merging non-branching chains of nodes into a single node with a longer string. More precisely, if node u is the only predecessor of node v and v is the only successor of u (but there may be multiple edges u ! v), then u and v can be merged into a single node that has the predecessors of u and the successors of v. After maximally compressing the graph, every node (apart from possibly the start node) has at least two different predecessors or its single predecessor has at least two different successors and every node (apart from the stop node) has at least two different successors or its single successor has at least two different predecessors;<ref type="figure" target="#fig_0">Figure 1</ref>. Of course, the compressed de Bruijn graph can be built from its uncompressed counterpart (a much larger graph), but this is disadvantageous because of the huge space consumption. That is why we will build it directly.<ref type="figure">Figure 2</ref>shows how splitMEM represents the compressed de Bruijn graph G for k ¼ 3 and the string S ¼ACTACGTACGTACG$. Each node corresponds to a substring x of S and consists of the four components ðid; len; posList; adjListÞ, where id is a natural number that uniquely identifies the node, len is the length jxj of x, posList is the list of positions at which x occurs in S (sorted in ascending order) and adjList is the list of the successors of the node (sorted in such a way that the walk through G that gives S is induced by the adjacency lists: if node G½id is visited for the ith time, then its successor is the node that can be found at position i in the adjacency list of G½id). In pan-genome analysis, S is the concatenation of multiple genomic sequences, where the different sequences are separated by special symbols (in practice, we use one separator symbol and treat the different occurrences of it as if they were different characters). The nodes in the compressed de Bruijn graph of a pan-genome can be categorized as follows: @BULLET A uniqueNode represents a unique substring in the pan-genome and has a single start position (i.e. posList contains just one element). @BULLET A repeatNode represents a substring that occurs at least twice in the pan-genome, either as a repeat in a single genome or as a segment shared by multiple genomes. According to<ref type="bibr" target="#b9">Marcus et al. (2014)</ref>, the compressed de Bruijn graph is most suitable for pan-genome analysis: 'This way the complete pan-genome will be represented in a compact graphical representation such that the shared/strain-specific status of any substring is immediately identifiable, along with the context of the flanking sequences. This strategy also enables powerful topological analysis of the pan-genome not possible from a linear representation'.<ref type="figure" target="#fig_1">Figure 3</ref>illustrates this point of view.and the string ACTACGTACGTACG$ is shown on the left, while its compressed counterpart is shown on the right<ref type="figure">Fig. 2</ref>. Representation of the compressed de Bruijn graph from<ref type="figure" target="#fig_0">Fig. 1</ref>1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Suffix trees and other index data structures</head><p>In this section, we briefly introduce the data structures on which our new algorithms are based. For details, we refer to the textbooks of Gusfield (1997) and Ohlebusch (2013), and the references therein. An ST for a string S of length n is a compact trie storing all the suffixes of S, i.e. the concatenation of the edge labels on the path from the root to leaf i exactly spells out the ith suffix S i ¼ S½i::n of S (S is terminated with the special character $ to guarantee that each suffix ends at a leaf of the tree). An ST can be built in linear time. For each node v in ST, strðvÞ denotes the string obtained by concatenating the labels on the edges on the root-to-v path. In this article, we need the following operations on STs (u and v are nodes): sDepthðvÞ gives v's string-depth jstrðvÞj; parentðvÞ=fChildðvÞ=nSiblingðvÞ yields the parent/first child/next sibling of v (if existent); if strðvÞ ¼ aa for some character a, then the suffix link sLinkðvÞ gives the unique node u with strðuÞ ¼ a; LCAðu; vÞ yields the lowest common ancestor of u and v; HAQðv; kÞ returns the highest ancestor u of v so that jstrðuÞj ! k. Below we will show that HAQðv; kÞ can be supported in constant time; it is wellknown that the same is true for the other operations. The suffix array SA of the string S is an array of integers in the range 1 to n specifying the lexicographic ordering of the n suffixes of S, i.e. it satisfies S SA½1 &lt; S SA½2 &lt; Á Á Á &lt; S SA½n ;<ref type="figure" target="#fig_2">Figure 4</ref>. A suffix array can be constructed in linear time. For every substring x of S, the x-interval is the suffix array interval ½i::j so that x is a prefix of S SA½k if and only if i k j. For a node v in ST, the strðvÞ-interval in the suffix array, denoted by ½lbðvÞ::rbðvÞ, contains all the suffixes of the subtree of ST rooted at v. To support the operation HAQðv; kÞ on the ST in constant time, initialize a bit vector B of size n with zeros and proceed as follows. For each internal node u in ST with sDepthðuÞ ! k and sDepthðparentðuÞÞ &lt; k set B½lbðuÞ ¼ 1 and B½rbðuÞ ¼ 1, where ½lbðuÞ::rbðuÞ is the strðuÞ-interval. Now preprocess B in linear time so that a rank 1 ðB; iÞ query (returns the number of ones in B up to and including position i) and a select 1 ðB; iÞ query (returns the position of the ith one in B) can be answered in constant time. The resulting data structure requires only n þ oðnÞ bits: n bits for B and oðnÞ bits to support the queries in constant time. The node u ¼ HAQðv; kÞ can then be found in constant time as follows: select 1 ðrank 1 ðB; lbðvÞÞÞ returns the position i of the first 1 in B that is left to lbðvÞ and select 1 ðrank 1 ðB; lbðvÞÞ þ 1Þ returns the position j of the first 1 in B that is right to rbðvÞ (note that i ¼ lbðvÞ and j ¼ rbðvÞ is possible). It can be shown that leaf i is the leftmost and leaf j is the rightmost leaf of the subtree rooted at u. Hence LCAði; jÞ yields the node u (note that u ¼ v is possible). The Burrows–Wheeler transform converts the string S into the string BWT½1::n defined by BWT½i ¼ S½SA½i À 1 for all i with SA½i 6 ¼ 1 and BWT½i ¼ $ otherwise;<ref type="figure" target="#fig_2">Figure 4</ref>. The BWT can be built in linear time via the suffix array, but there are also algorithms that construct the BWT directly (i.e. without constructing the suffix array). The LF mapping (last-to-first-mapping) is defined as follows: If</p><p>SA½i ¼ q, then LFðiÞ is the index j so that SA½j ¼ q À 1 (if SA½i ¼ 1, then LFðiÞ ¼ 1). In other words, if the ith entry in the suffix array is the suffix S q , then LFðiÞ 'points' to the entry at which the suffix S qÀ1 can be found;<ref type="figure" target="#fig_2">Figure 4</ref>. In data compression, the LF-mapping is used to reconstruct the original string S from the BWT (given the BWT, the LF-mapping can easily be computed in linear time). The LCP-array stores the lengths of the longest common prefixes of lexicographically adjacent suffixes: for 2 i n; LCP½i ¼ max fp ! 0jS SA½i and S SA½iÀ1 share a prefix of length pg and LCP½1 ¼ À1 ¼ LCP½n þ 1; see<ref type="figure" target="#fig_2">Figure 4</ref>for an example. The LCParray can be computed in linear time from the suffix array and its inverse, but it is also possible to construct it directly from the BWT in Oðn log rÞ time. A CST with full functionality supports the same operations as an ST. It consists of three components: a compressed suffix array, a compressed LCP-array and a succinct representation of the ST topology. A CST requires much less space than an ST, but it cannot support all operations in constant time. A substring x of S is a repeat if it occurs at least twice in S. Let x be a repeat of length ' and let ½i::j be the x-interval. The repeat x is left-maximal if jfBWT½qji q jgj ! 2, i.e. the set fS½SA½q À 1ji q jg of all characters that precede at least one ofGraphical pan-genome analysisthe suffixes S SA½i ;. .. ; S SA½j is not singleton (where S½0 :¼ $). Analogously, the repeat x is right-maximal if jfS½SA½q þ 'ji q jgj ! 2. A left-and right-maximal repeat is called maximal repeat.<ref type="bibr">[</ref><ref type="bibr">.]</ref>An internal node v in the ST is called left-maximal if strðvÞ is a left-maximal repeat. Note that every internal node v of the ST is right-maximal in the sense that strðvÞ is a right-maximal repeat.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head><p>Our algorithms are based on the following simple lemma: Let v be a node in the compressed de Bruijn graph and let x be the string corresponding to v. If v is not the start node, then it has at least two different predecessors if and only if the length k prefix of x is a left-maximal repeat. It has at least two different successors if and only if the length k suffix of x is a rightmaximal repeat.</p><p>The lemma provides a tool to decide at which positions a split occurs. Both of our methods make extensive use of it.They introduce so-called 'suffix skips' to compute repeatNodes in Oðn log gÞ time. Our new linear-time Algorithm 1 computes repeatNodes without them. The idea behind Algorithm 1 is as follows: Start the computation only with left-maximal internal nodes that have no internal node as child and use suffix links to detect their repeat-structure (i.e. where splits are necessary). Stop the computation if a left-maximal internal node x is encountered. This is because either x has no internal node as child, so it will be considered later, or x has an internal node y as child, so its repeat-structure will be found when y is processed. In Algorithm 1, cur is a pointer to a repeat that must or must not be split later, and ' is the number of characters that must be skipped before the split occurs (note that if a split occurs, then the left and right part overlap by k À 1 characters). A split occurs if the k-length prefix of strðvÞ is left-or right-maximal, where v is the current internal node. Let u ¼ HAQðv; kÞ and consider the situation of<ref type="figure" target="#fig_6">Figure 5</ref>. In that situation, Algorithm 1 uses the following case analysis:7: else if d &gt; k then 8: cur v 9: ' / 0 10: repeat 11: u HAQðv; kÞ " u ¼ v is possible 12: if u is left-maximal then 13: if ' &gt; 0 then "1 If strðuÞ is a left-maximal repeat, then the length k prefix of strðuÞ is left-maximal. This implies that the length k prefix of strðvÞ is leftmaximal. If in this case ' &gt; 0, then x must be split at the beginning of strðuÞ; so the length ' þ k À 1 prefix of x is a repeatNode. 1a If strðuÞ is a right-maximal k-mer (because sDepthðuÞ ¼ k), then x must also be split at the end of strðuÞ because strðuÞ is also a repeatNode. The algorithm continues with x½' þ 2::jxj and ' ¼ 0. 1b If strðuÞ is not a right-maximal k-mer, then the algorithm continues with the string strðvÞ ¼ x½' þ 1::jxj and ' ¼ 1. 2a If strðuÞ is not a left-maximal repeat but a right-maximal k-mer, then x must be split at the end of strðuÞ; so the length ' þ k prefix of x is a repeatNode. The algorithm continues with x½' þ 2::jxj and ' ¼ 0. 2b If strðuÞ is neither a left-maximal repeat nor a right-maximal kmer, then the algorithm continues with the string x and ' þ 1. The procedure CREATE-REP-NODE in Algorithm 1 creates a new repeatNode if this node does not exist yet.is the shortest prefix of str(v) of length ! k that is right-maximal because u ¼ HAQðv ; kÞ We will next show that Algorithm 1 runs in OðnÞ time. Since all operations in the algorithm take constant time, the run-time is proportional to the overall number of suffix links that are followed. The ST of a string S of length n has n leaves. Since every internal node is branching, ST has at most n À 1 internal nodes. It follows that there are at most n À 1 suffix links because every internal node has exactly one suffix link. We claim that every suffix link is used at most once in Algorithm 1. Suppose to the contrary that a suffix link from node v to node w is used more than once. This is only possible if node v has at least two incoming suffix links, say from nodes u and u 0. If strðvÞ ¼ a, then we must have strðuÞ ¼ aa and strðu 0 Þ ¼ a 0 a for two distinct characters a and a 0. However, this implies that v is left-maximal and Algorithm 1 stops whenever a left-maximal node is reached. This contradiction proves our claim and shows that Algorithm 1 runs in linear time. Once Algorithm 1 has computed the repeatNodes, we proceed as in the second phase of splitMEM: the set of genomic starting positions that occur in each repeatNode is sorted, so that uniqueNodes that bridge any gaps between adjacent repeatNodes as well as the edges in the compressed de Bruijn graph can be computed in a single pass over the sorted list. However, there is one difference to<ref type="bibr" target="#b9">Marcus et al. (2014)</ref>: to achieve linear run-time, we use a non-comparison-based sorting algorithm for this task; details can be found in the Supplementary Material.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Using a (compressed) suffix tree</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Using the BWT</head><p>Our second algorithm uses the BWT and the LF-mapping to compute the complete compressed de Bruijn graph G (uniqueNodes, repeatNodes and the edges between them) in a single backward pass over the whole pan-genome S. To be more precise, Algorithm 2 starts with the suffix S n ¼ $ at index j ¼ 1 in the suffix array and successively computes the indices of S nÀ1 ;. .. ; S 1 with the help of the LF mapping (i.e. S nÀ1 can be found at index i ¼ LF½j; S nÀ2 can be found at index LF½i, etc.). In Algorithm 2, the current string x is a prefix of suffix S p , which occurs at index j in the suffix array. The next string that must be considered in the algorithm is cx, where c ¼ S½p À 1. Note that cx is a prefix of suffix S pÀ1 , which occurs at index i ¼ LFðjÞ in the suffix array. The string x must be split if (i) the length k prefix of cx is a right-maximal repeat or (ii) the length k prefix of x is a left-maximal repeat; see<ref type="figure">Figure 6</ref>Here, we only briefly explain this procedure; it is described in detail in the Supplementary Material, where it is also shown that its run-time is Oðn log rÞ. All three bit vectors are initialized with zeros. The procedure obtains the bit vector B 1 by computing the suffix array interval ½lb::rb of each right-maximal k-mer and setting B 1 ½lb ¼ B 1 ½rb ¼ 1; see<ref type="figure" target="#fig_2">Figure 4</ref>for an example. Moreover, B 1 is preprocessed, so that rank-queries can be answered in constant time. By means of B 1 , it is then possible to perform test (i) in constant time: if cx is prefix of the suffix at index i in SA, then it has a right-maximal k-mer as prefix if and only if B 1 ½i ¼ 1 or rank 1 ðB 1 ; iÞ is odd. If this is the case, a split occurs and Algorithm 2 must continue with the k-mer prefix of cx as next node. The number bðrank 1 ðB 1 ; iÞ þ 1Þ=2c will serve as a unique identifier of this next node. In the following, rightMax ¼ rank 1 ðB 1 ; nÞ=2 is the number of right-maximal k-mer intervals. Procedure CREATE-BIT-VECTORS also computes the bit vectors B 2 and B 3 as follows: If the suffix array interval ½lb::rb of a left-maximal repeat of length ! k is detected (hence the corresponding k-mer prefix is left-maximal), then B 2 ½q is set to 1 for all q in ½lb::rb. Moreover, for each c in BWT½lb::rb, the procedure sets B 3 ½ LF½q to 1, where q is the index of the last occurrence of c in BWT½lb::rb. Finally, the procedure resets each one bit in B 3 that marks a right-maximal k-mer to zero (the reason for this will become clear in a moment); in the example of<ref type="figure" target="#fig_2">Figure 4</ref>, no bit of B 3 had to be reset. By means of B 2 , it is then possible to perform test (ii) in constant time: if x is prefix of the suffix at index j in SA, then it has a left-maximal k-mer as prefix if and only if B 2 ½j ¼ 1. If this is the case, a split occurs and Algorithm 2 must continue with the k-mer prefix x of cx, which is a prefix of the suffix at index i ¼ LF½j, as next node. If B 1 ½i ¼ 1 or rank 1 ðB 1 ; iÞ is odd, then bðrank 1 ðB 1 ; iÞ þ 1Þ=2c is the identifier of this next node. If not, then we use the bit vector B 3 to assign the unique identifier rightMaxþ rank 1 ðB 3 ; i À 1Þ þ 1 to the next node, which corresponds to (or ends with) x. This is because rightMax is the number of all rightmaximal k-mers and rank 1 ðB 3 ; i À 1Þ ¼ rank 1 ðB 3 ; lb 0 À 1Þ, where ½lb 0 ::rb 0  is the x-interval. It can be shown that B 3 ½lb 0 ::rb 0 À 1 solely contains zeros and B 3 ½rb 0  ¼ 1; consequently rank 1 ðB 3 ; i À 1Þ þ 1 ¼ rank 1 ðB 3 ; rb 0 Þ. To sum up, after the preprocessing phase it is known that the compressed de Bruijn graph G has rightMaxþleftMax þ 1 many nodes: there are rightMax ¼ rank 1 ðB 1 ; nÞ=2 many nodes that end with a right-maximal k-mer, leftMax ¼ rank 1 ðB 3 ; nÞ many nodes that end with a non-right-maximal k-mer and the stop node that ends with the special symbol $. Consequently, Algorithm 2 initializes an array G of that size, in which a node is represented by the triple ðlen; posList; adjListÞ, where posList is the sorted list of positions at which the corresponding string x occurs in S; len is the length of x and adjList is the corresponding adjacency list. The for-loop of Algorithm 2 implements the single backward pass over S as described above. A split occurs whenever number 6 ¼ ?. In this case, the position p is added to the front of the posList of the current node cur and cur is added to the front of the adjList of the next node number. If number ¼ ?, then the length of the string corresponding to node cur is incremented by one.<ref type="figure">6</ref>. The string x is prefix of the suffix S p of S and cx is prefix of SpÀ1. x must be split if (i) the length k prefix of cx is a right-maximal repeat or (ii) the length k prefix of x is a left-maximal repeatAs explained in the Supplementary Material, the computation of the bit vectors B 1 ; B 2 and B 3 requires Oðn log rÞ time. Apart from the LF-mapping, all operations in Algorithm 2 take only constant time. In our implementation, the LF-mapping is implemented by a wavelet tree of the BWT, so it takes Oðlog rÞ time to compute a value LFðjÞ. Consequently, the overall run-time of Algorithm 2 is Oðn log rÞ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Graphical pan-genome analysis</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The size of the compressed de Bruijn graph</head><p>It follows from the preceding section that the size of the compressed de Bruijn graph can be characterized in terms of left-and rightmaximal k-mer repeats. The number of nodes equals jV 1 j þ jV 2 j þ 1, where V 1 ¼ fxjx is a right-maximal k-mer repeat in Sg and V 2 ¼ fxj9i 2 f1;. .. ; n À kg : x ¼ S½i::i þ k À 1 6 2 V 1 and S½i þ 1::i þ k is a left-maximal k-mer repeat in Sg; the stop node is taken into account by adding 1. The number of edges is jfij1 i n À k and S½i::i þ k À 1 2 V 1 [ V 2 gj.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head><p>We implemented our new algorithms in Cþþ, using the library sdsl of<ref type="bibr" target="#b5">Gog et al. (2014)</ref>. Software and test data are available at http:// www.uni-ulm.de/in/theo/research/seqana.html. Both algorithms use a variant of the semi-external algorithm described in<ref type="bibr" target="#b2">Beller et al. (2013b)</ref>to construct the CST and the BWT, respectively. The experiments were conducted on a 64 bit Ubuntu 14.04.1 LTS (Kernel 3.13) system equipped with two ten-core Intel Xeon processors E52680v2 with 2.8 GHz and 128 GB of RAM (but no parallelism was used). All programs were compiled with gþþ (version 4.8.2) using the provided makefile. With the CST-based and the BWT-based algorithm, respectively, we built compressed de Bruijn graphs for the 62 E.coli genomes (containing 310 million base pairs) listed in the Supplementary Material of<ref type="bibr" target="#b9">Marcus et al. (2014)</ref>, using the k-mer lengths 50, 100 and 1000.<ref type="figure" target="#tab_1">Table 1</ref>lists the results of our experiments. The run-times include the construction of the index, but similar to splitMEM it is unnecessary to rebuild the index for a fixed dataset and varying values of k. The peak memory usage reported in<ref type="figure" target="#tab_1">Table 1</ref>includes the size of the index and the size of the compressed de Bruijn graph. Because of its large memory requirements, splitMEM was not able to build a compressed de Bruijn graph for all 62 strains of E.coli on our machine equipped with 128 GB of RAM. That is why we included a comparison based on the first 40 E.coli genomes (containing 199 million base pairs) of the dataset. The experimental results show that both of our algorithms use significantly less space (two orders of magnitude) than splitMEM. The CST-based algorithm is five times faster than splitMEM, while the BWT-based algorithm is more than an order of magnitude faster. It is worth mentioning that our two algorithms compute isomorphic—but not necessarily identical—compressed de Bruijn graphs because the node identifiers may differ. To show the scalability of our new algorithms, we applied them to five different assemblies of the human reference genome (UCSC Genome Browser assembly IDs: hg16, hg17, hg18, hg19 and hg38) as well as the maternal and paternal haplotype of individual NA12878 (Utah female) of the 1000 Genomes Project; see<ref type="bibr" target="#b15">Rozowsky et al. (2011)</ref>. The compressed de Bruijn graphs of their first chromosomes (7xChr1, containing 1736 million base pairs) and the complete seven genomes (7xHG, containing 21 201 million base pairs) were built for the k-mer lengths 50, 100 and 1000. The experimental results in<ref type="figure" target="#tab_1">Table 1</ref>show that the BWT-based algorithm clearly outperforms the CST-based algorithm. It took slightly over 6 h (22 000 s) to construct the index of the seven human genomes and less than 2 h (6000–7000 s) to build the graph with the Our CST-based algorithm mimics splitMEM in this respect, whereas the BWT-based algorithm treats the different occurrences of # as if they were different characters. Assuming that # is the second smallest character, this can be achieved as follows. As explained in the Supplementary Material, all right-maximal k-mers can be determined without the entire LCP-array if the algorithm in<ref type="bibr" target="#b1">Beller et al. (2013a)</ref>is used. If there are m – 1 occurrences of # in total and this algorithm starts with m – 1 singleton intervals ½i::i; 2 i m, instead of the #-interval ½2::m, then the different occurrences of # are treated as if they were different characters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discussion</head><p>We have presented two space-efficient methods to build the compressed de Bruijn graph from scratch. An experimental comparison with splitMEM showed that our algorithms are more than an order of magnitude faster than splitMEM while using significantly less space (two orders of magnitude). To demonstrate their scalability, we successfully applied them to seven complete human genomes. Consequently, it is now possible to use the compressed de Bruijn graph for much larger pan-genomes than before (consisting, e.g. of hundreds or even thousands of different strains of bacteria). Although the BWT-based algorithm is the clear winner of the comparison, CSTbased algorithms are still important. This is because STs play a central role in sequence analysis and most bioinformatics curricula comprise courses that cover this important data structure. It is therefore conceivable that a bioinformatician might be able to come up with a suffix tree algorithm that solves his/her problem at hand, but not with an algorithm that is based on the BWT and/or related data structures. If the space requirement of the ST is the bottleneck in the application, one can use a CST instead. CSTs with full functionality are, e.g. implemented in the succinct data structure library (sdsl) of<ref type="bibr" target="#b5">Gog et al. (2014)</ref>. On the downside, extra features such as suffix skips are not implemented in those libraries so that a direct implementation of a suffix tree algorithm by means of a CST might not be possible. Future work includes parallel implementations of the algorithms. Moreover, it should be worthwhile to investigate the time-space tradeoff if one uses data structures that are optimized for highly repetitive texts, see Navarro and Ordó n ˜ ez (2014) and the references therein. Most important, however, is to address the problem of compressing the 'compressed de Bruijn graph' itself. (Our experiments show that for smaller k, the size of the graph can be larger than the size of the index, e.g. the graph for the seven human genomes and k ¼ 50 takes 1.65 bytes per base pair, whereas the BWT-index requires only 1.13 bytes per base pair.) Very recently, two Bloom filter methods were presented that can be used for this purpose. Solomon and Kingsford (2015) introduced the Sequence Bloom Tree to support sequence-based querying of large-scale collections of thousands of short-read sequencing experiments and applied it to the problem of finding conditions under which query transcripts are expressed. The second approach by<ref type="bibr" target="#b7">Holley et al. (2015)</ref>is closer to the splitMEM approach. Their data structure—the Bloom Filter Trie (BFT)—allows to efficiently store and traverse the uncompressed de Bruijn graph. In the Section Conclusion of their article,<ref type="bibr" target="#b7">Holley et al. (2015)</ref>write 'Future work concerns the possibility to compress non-branching paths. .. ' This is exactly what splitMEM and our new algorithms do, so maybe the combination of both approaches will yield the ideal pan-genome representation.The first row in a block specifies the experiment. The second row shows the graph size in bytes per base pair. Rows 3–6 contain the numbers of edges, nodes, uniqueNodes and repeatNodes, respectively. Rows 7–10 show the average out-degree of the nodes as well as the average string length of the nodes, uniqueNodes and repeatNodes. The remaining rows (if applicable) contain the percentage of the nodes that are shared by x sequences.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This work was supported by the Deutsche Forschungsgemeinschaft (DFG grant no. OH 53/6-2). Conflict of Interest: none declared.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. The de Bruijn graph for k ¼ 3 and the string ACTACGTACGTACG$ is shown on the left, while its compressed counterpart is shown on the right Fig. 2. Representation of the compressed de Bruijn graph from Fig. 1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.3.</head><figDesc>Fig. 3. Cartoon representation of a pan-genome consisting of the four genomes A–D. The genomic sequences are decomposed into strain-specific segments and segments that are shared by a subset of the strains. The edges maintain the adjacencies of the segments</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.4.</head><figDesc>Fig. 4. The suffix array SA of the string ACTACGTACGTACG$ and related notions are defined in Section 1.3. The bit vectors B 1 , B 2 and B 3 are explained in Section 2.2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>Note that Marcus et al. (2014) use the term 'maximal exact match' instead of the more common term 'maximal repeat'. We will not use the term 'maximal exact match' here</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>Marcus et al. (2014) describe an algorithm that computes the compressed de Bruijn graph directly (i.e. without using the uncompressed de Bruijn graph) based on an ST of the pan-genome. Their algorithm consists of two phases: 1. Compute the set of repeatNodes of the compressed de Bruijn graph. 2. Compute the uniqueNodes as well as edges between nodes in the compressed de Bruijn graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Algorithm1.</head><figDesc>Computation of the repeatNodes in the compressed de Bruijn graph based on an ST</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.5.</head><figDesc>Fig. 5. Suppose that the first ' characters of the repeat x ¼ strðcurÞ have already been considered in the repeat-loop of Algorithm 1. Then str(v ) ¼ x[' þ 1::jxj] and str(u) is the shortest prefix of str(v) of length ! k that is right-maximal because u ¼ HAQðv ; kÞ</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>for an illustration. Algorithm 2 uses three bit vectors B 1 , B 2 and B 3 , which are constructed in a preprocessing phase by the procedure CREATE-BIT-VECTORS.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.</head><figDesc>Fig. 6. The string x is prefix of the suffix S p of S and cx is prefix of SpÀ1. x must be split if (i) the length k prefix of cx is a right-maximal repeat or (ii) the length k prefix of x is a left-maximal repeat</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Algorithm 2. Construction of a compressed de Bruijn graph without the suffix array.</figDesc><table>1: function CREATE-COMPRESSED-GRAPH(k; BWT; LF) 
2: 
ðB 1 ; B 2 ; B 3 Þ / CREATE-BIT-VECTORS (k; BWT) 
3: 
rightMax 
rank 1 ðB 1 ; nÞ=2 
4: 
leftMax 
rank 1 ðB 3 ; nÞ 
5: 
create an array G of size rightMax þ leftMax þ 1 
6: 
j 
1 
" suffix $ occurs at index 1 
7: 
cur / rightMax þ leftMax þ 1 " id of the stop node 
8: 
G½cur:len 
1 
" length of the suffix $ 
9: 
for p 
n down to 2 do 
10: 
i 
LFðjÞ 
" LF is the last-to-first mapping 
11: 
ones 
rank 1 ðB 1 ; iÞ 
12: 
number 
? 
13: 
if ones is odd or B 1 ½i ¼ 1 then 
14: 
number 
bðones þ 1Þ=2c 
15: 
else if B 2 ½j ¼ 1 then 
16: 
number 
rightMax þ rank 1 ðB 3 ; i À 1Þ þ 1 
17: 
if number 6 ¼ ? then 
18: 
add p to the front of G½cur:posList 
19: 
add cur to the front of G½number:adjList 
20: 
G½number:len 
k 
21: 
cur 
number 
22: 
else 
23: 
increment G½cur:len by one 
24: 
j 
i 
25: add 1 to the front of G½cur:posList 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 2. Statistics about the compressed de Bruijn graphs</figDesc><table>k ¼ 50 
k ¼ 100 
k ¼ 1000 

40 E.coli 
graph size 
1.07 
0.65 
0.06 
edges 
9 205 701 
5 157 748 
301 191 
nodes 
767 391 
552 240 
79 252 
uniqueNodes 
129 901 
104 951 
26 322 
repeatNodes 
637 490 
447 289 
52 930 
avg. out-degree 
12.00 
9.34 
3.80 
avg. node length 
89.67 
175.42 
2232.84 
avg. uNode length 
146.87 
276.05 
3299.91 
avg. rNode length 
78.018 
151.81 
1702.19 
62 E.coli 
graph size 
1.12 
0.68 
0.06 
edges 
16 304 084 
9 219 061 
555 810 
nodes 
1 007 765 
738 980 
117 021 
uniqueNodes 
174 717 
141 167 
34 463 
repeatNodes 
833 048 
597 813 
82 558 
avg. out-degree 
16.18 
12.48 
4.75 
avg. node length 
86.70 
170.15 
2105.87 
avg. uNode length 
132.23 
257.81 
3242.76 
avg. rNode length 
77.15 
149.45 
1631.28 
7xChr1 
graph size 
1.87 
1.59 
1.50 
edges 
193 620 506 
167 393 470 
160 874 818 
nodes 
1 718 646 
939 054 
310 841 
uniqueNodes 
215 190 
195 241 
91 221 
repeatNodes 
1 503 456 
743 813 
219 620 
avg. out-degree 
112.66 
178.26 
517.55 
avg. node length 
186.16 
371.53 
2310.18 
avg. uNode length 
104.25 
212.23 
2500.46 
avg. rNode length 
197.88 
413.35 
2231.14 
nodes shared by 1 
14.76% 
24.15% 
29.44% 
nodes shared by 2 
6.89% 
11.03% 
12.51% 
nodes shared by 3 
0.18% 
0.28% 
0.40% 
nodes shared by 4 
0.49% 
0.64% 
0.88% 
nodes shared by 5 
7.86% 
12.39% 
17.00% 
nodes shared by 6 
11.23% 
17.54% 
20.37% 
nodes shared by 7 
58.60% 
33.96% 
19.39% 
7xHG 
graph size 
1.65 
1.16 
1.00 
edges 
2 056 675 301 1 475 958 859 1 319 219 774 
nodes 
25 367 105 
12 030 826 
3 851 688 
uniqueNodes 
2 614 834 
2 316 797 
1 143 848 
repeatNodes 
22 752 271 
9 714 029 
2 707 840 
avg. out-degree 
81.08 
122.68 
342.50 
avg. node length 
163.48 
364.16 
2326.95 
avg. uNode length 
99.44 
208.65 
2505.46 
avg. rNode length 
170.84 
401.24 
2251.54 
nodes shared by 1 
11.36% 
21.23% 
30.01% 
nodes shared by 2 
5.93% 
10.74% 
12.17% 
nodes shared by 3 
0.19% 
0.31% 
0.43% 
nodes shared by 4 
0.31% 
0.47% 
0.66% 
nodes shared by 5 
6.20% 
11.60% 
16.63% 
nodes shared by 6 
9.74% 
17.46% 
20.64% 
nodes shared by 7 
66.28% 
38.19% 
19.46% 

</table></figure>

			<note place="foot">U.Baier et al. at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">The columns show the run-times in seconds and, in parentheses, the maximum main memory usage in bytes per base pair. A minus indicates that the algorithm was not able to solve its task on our machine equipped with 128 GB of RAM.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank the anonymous reviewers for their helpful comments. Special thanks go to Gonzalo Navarro, who initiated this work.</p></div>
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Efficient construction of a compressed de Bruijn graph for pan-genome analysis</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Beller</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ohlebusch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 26th Annual Symposium on Combinatorial Pattern Matching</title>
		<editor>Cicalese,F. et al.</editor>
		<meeting>the 26th Annual Symposium on Combinatorial Pattern Matching<address><addrLine>Cham, Heidelberg, New York ; Dordrecht London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="40" to="51" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Computing the longest common prefix array based on the Burrows-Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Beller</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="22" to="31" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Space-efficient construction of the Burrows-Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Beller</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th International Symposium on String Processing and Information Retrieval</title>
		<editor>Kurland,O. et al.</editor>
		<meeting>the 20th International Symposium on String Processing and Information Retrieval<address><addrLine>Cham, Heidelberg, New York ; Dordrecht London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="5" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">From indexing data structures to de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Cazaux</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 25th Annual Symposium on Combinatorial Pattern Matching</title>
		<editor>Kulikov,A.S. et al.</editor>
		<meeting>the 25th Annual Symposium on Combinatorial Pattern Matching<address><addrLine>Cham, Heidelberg, New York, Dordrecht, London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="89" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Improved genome inference in the MHC using a population reference graph</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Dilthey</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="682" to="688" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">From theory to practice: plug and play with succinct data structures</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gog</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Symposium on Experimental Algorithms</title>
		<editor>Gudmundsson,J. et al.</editor>
		<meeting>the 13th International Symposium on Experimental Algorithms<address><addrLine>Cham, Heidelberg, New York, Dordrecht, London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="326" to="337" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<monogr>
		<title level="m" type="main">Algorithms on Strings, Trees, and Sequences</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Cambridge University Press Cambridge University Press</publisher>
			<pubPlace>New York, NY, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Bloom filter trie—a data structure for pan-genome storage</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Holley</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th International Workshop on Algorithms in Bioinformatics</title>
		<editor>Pop,M. and Touzet,H.</editor>
		<meeting>the 15th International Workshop on Algorithms in Bioinformatics<address><addrLine>Heidelberg, New York, Dordrecht, London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2015" />
			<biblScope unit="page" from="217" to="230" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">De novo assembly and genotyping of variants using colored de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Iqbal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">44</biblScope>
			<biblScope unit="page" from="226" to="232" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">SplitMEM: a graphical algorithm for pan-genome analysis with suffix skips</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Marcus</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="3476" to="3483" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Faster compressed suffix trees for repetitive text collections</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Ordó N ˜ Ez</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 13th International Symposium on Experimental Algorithms</title>
		<editor>Gudmundsson,J. and Katajainen,J.</editor>
		<meeting>the 13th International Symposium on Experimental Algorithms<address><addrLine>Cham, Heidelberg, New York, Dordrecht, London</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="424" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<monogr>
		<title level="m" type="main">Bioinformatics Algorithms: Sequence Analysis, Genome Rearrangements, and Phylogenetic Reconstruction</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ohlebusch</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>Oldenbusch Verlag</publisher>
			<pubPlace>Bremen, Germany</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title level="m" type="main">Mapping to a reference genome structure</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Paten</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Journaled string tree—a scalable data structure for analyzing thousands of similar genomes on your laptop</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Rahn</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="3499" to="3505" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">The pangenome structure of Escherichia coli: comparative genomic analysis of E. coli commensal and pathogenic isolates</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">A</forename>
				<surname>Rasko</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Bacteriol</title>
		<imprint>
			<biblScope unit="volume">190</biblScope>
			<biblScope unit="page" from="6881" to="6893" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">AlleleSeq: analysis of allele-specific expression and binding in a network framework</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Rozowsky</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page">522</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Simultaneous alignment of short reads against multiple genomes</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Schneeberger</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">98</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<monogr>
		<title level="m" type="main">Large-scale search of transcriptomic read sets with sequence Bloom trees. bioRxiv, 017087</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Solomon</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Kingsford</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Genome analysis of multiple pathogenic isolates of Streptococcus agalactiae: implications for the microbial &quot; pan-genome</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Tettelin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="13950" to="13955" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>