
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:49+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">TEAM: efficient two-locus epistasis tests in human genome-wide association study</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010">2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Xiang</forename>
								<surname>Zhang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Shunping</forename>
								<surname>Huang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Fei</forename>
								<surname>Zou</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Department of Biostatistics</orgName>
								<orgName type="institution">University of North Carolina at Chapel Hill</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Wei</forename>
								<surname>Wang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">TEAM: efficient two-locus epistasis tests in human genome-wide association study</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">26</biblScope>
							<biblScope unit="page" from="217" to="227"/>
							<date type="published" when="2010">2010</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq186</idno>
					<note>[11:33 12/5/2010 Bioinformatics-btq186.tex] Page: i217 i217–i227 BIOINFORMATICS</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>As a promising tool for identifying genetic markers underlying phenotypic differences, genome-wide association study (GWAS) has been extensively investigated in recent years. In GWAS, detecting epistasis (or gene–gene interaction) is preferable over single locus study since many diseases are known to be complex traits. A brute force search is infeasible for epistasis detection in the genome-wide scale because of the intensive computational burden. Existing epistasis detection algorithms are designed for dataset consisting of homozygous markers and small sample size. In human study, however, the genotype may be heterozygous, and number of individuals can be up to thousands. Thus, existing methods are not readily applicable to human datasets. In this article, we propose an efficient algorithm, TEAM, which significantly speeds up epistasis detection for human GWAS. Our algorithm is exhaustive, i.e. it does not ignore any epistatic interaction. Utilizing the minimum spanning tree structure, the algorithm incrementally updates the contingency tables for epistatic tests without scanning all individuals. Our algorithm has broader applicability and is more efficient than existing methods for large sample study. It supports any statistical test that is based on contingency tables, and enables both family-wise error rate and false discovery rate controlling. Extensive experiments show that our algorithm only needs to examine a small portion of the individuals to update the contingency tables, and it achieves at least an order of magnitude speed up over the brute force approach.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Genetic association analysis examines the statistical correlation between an organism's genotype with its phenotype. With the development of high-throughput genotyping technologies, genetic variation of human and other model organisms has been measured at genome-wide scale. As the most abundant source of genetic variation, the number of single nucleotide polymorphism (SNPs) in public databases (dbGaP, JAX) is up to millions. Genome-wide association study (GWAS) has been shown to be a promising tool to locate the genetic factors that cause phenotypic differences (<ref type="bibr" target="#b17">Saxena et al., 2007;</ref><ref type="bibr" target="#b18">Scuteri et al., 2007;</ref><ref type="bibr">WTCCC, 2007;</ref><ref type="bibr" target="#b21">Weedon et al., 2007</ref>). Epistasis, or gene–gene interaction detection, has received increasing attention in complex trait analysis. Different from singlelocus approach, the goal of two-locus epistasis detection is to identify interacting SNP pairs that have strong association with the phenotype. Please refer to<ref type="bibr" target="#b0">Balding (2006)</ref>, Hirschhorn and, Hoh and Ott (2003) and<ref type="bibr" target="#b13">Musani et al. (2007)</ref>for reviews of current progress and challenges in epistasis detection in GWAS. * To whom correspondence should be addressed.</p><p>There are two grand challenges in epistasis detection. The first is to develop statistical tests that can effectively capture the interaction between SNPs. Various tests have been proposed for two-locus association study, such as the chi-square test, likelihood ratio test and entropy-based test (<ref type="bibr" target="#b0">Balding, 2006</ref>). Another crucial challenge in two-locus association study is the intensive computational burden imposed by the enormous search space. Suppose that there are N SNPs for M individuals. The overall search space of pairwise interactions is MN(N −1)/2. The large number of tests also causes the multiple testing problem (<ref type="bibr" target="#b12">Miller, 1981</ref>). Controlling the familywise error rate (FWER) and false discovery rate (FDR) are standard ways to control the error rate (<ref type="bibr" target="#b4">Dudoit and Laan, 2008;</ref><ref type="bibr" target="#b22">Westfall and Young, 1993</ref>). In the FWER and FDR controlling, permutation test is preferred over simple Bonferroni correction since many SNPs are correlated (<ref type="bibr" target="#b2">Churchill and Doerge, 1994</ref>). The correlation structure among genotype profiles is preserved across permutations and is incorporated into permutation P-value estimation. The idea of permutation test is to randomly shuffle the phenotype values among the individuals and recalculate the test statistics. The distribution of these test values are used to estimate the null distribution. Permutation test dramatically increases the search space. With K permutations, the entire search space of two-locus association mapping is KMN(N −1)/2. Consider a moderate GWAS setting, in which M = 1000, N = 100 000 and K = 1000. The size of the search space is about 5×10 15. Apparently, a brute force enumeration of the search space is infeasible and thus efficient algorithms are in demand. Although the computational challenge of epistasis detection has been well recognized, the algorithmic development is still very limited. For a small number of SNPs, e.g. from tens to a few hundreds, exhaustive algorithms that explicitly enumerate all possible SNP combinations have been developed (<ref type="bibr" target="#b14">Nelson et al., 2001;</ref><ref type="bibr" target="#b15">Ritchie et al., 2001</ref>). These methods are not scalable for genome-wide computing. Genetic algorithm (<ref type="bibr" target="#b1">Carlborg et al., 2000</ref>) has been proposed. This approach is heuristic, which does not guarantee to find the optimal solution. To avoid explicitly exploring the entire search space, a common heuristic used in epistasis detection is a two-step approach (<ref type="bibr" target="#b6">Evans et al., 2006;</ref><ref type="bibr" target="#b10">Hoh et al., 2000;</ref><ref type="bibr" target="#b24">Yang et al., 2009</ref>). First, a subset of SNPs are selected according to certain criteria. Then the selected SNPs are used for subsequent epistatic analysis. However, the SNP screening process suffers from the same problem as the single-locus approach. SNPs with strong epistasis but low marginal effects are likely to be filtered out (<ref type="bibr" target="#b26">Zhang et al., 2009a</ref>). Recently, the approach based on search space pruning has been shown to be able to dramatically speed up the process of epistasis detection without compromising the optimality of the results. FastANOVA (<ref type="bibr" target="#b25">Zhang et al., 2008</ref>) and FastChi (<ref type="bibr" target="#b27">Zhang et al., 2009b</ref>) are specifically designed for ANOVA test and chi-square test,</p><formula>Y 1 0 1 0 0 1 1 1 0 0 0 1 1 1 1 1 0 1 0 0 1 0 1 0 0 Y 2 0 0 1 0 1 1 1 1 1 1 0 0 1 0 0 1 1 1 0 0 0 1 0 0 Y 3 1 0 1 1 1 1 0 1 1 1 0 0 0 1 0 1 0 0 1 0 0 0 1 0 Y 4 0 1 1 1 1 1 0 0 0 1 0 0 1 0 1 0 0 0 1 1 0 1 1 0 Y 5 1 0 1 1 0 0 0 0 0 1 1 1 1 0 1 1 0 0 0 0 0 1 1 1</formula><p>respectively. The COE algorithm (<ref type="bibr" target="#b26">Zhang et al., 2009a</ref>) is a more general approach that is applicable to all convex tests. Utilizing an upper bound derived for the test being used, these algorithms only need to examine a small number of promising SNP pairs and prune the SNP pairs that are proven to have no strong association with the phenotype. Unlike heuristic approaches, these algorithms are guaranteed to find the optimal solution. Although these methods provide promising alternatives for GWAS, there are two major drawbacks that limit their applicability. First, they are designed for relatively small sample size and only consider homozygous markers (i.e. each SNP can be represented as a {0,1} binary variable). In human study, however, the sample size is usually large and most SNPs contain heterozygous genotypes and are coded using {0,1,2}. These make existing methods intractable. Second, although the FWER and the FDR are both widely used for error controlling, existing methods are designed only to control the FWER. From a computational point of view, the difference in the FWER and the FDR controlling is that, to estimate FWER, for each permutation, only the maximum two-locus test value is needed. To estimate the FDR, on the other hand, for each permutation, all two-locus test values must be computed. Further details of the FWER and the FDR controlling are described in Section 2. In this article, we propose an exhaustive algorithm, TEAM (Tree-based Epistasis Association Mapping), for efficient epistasis detection in human GWAS. TEAM has several advantages over previous methods. @BULLET It supports to both homozygous and heterozygous data.</p><p>@BULLET By exhaustively computing all two-locus test values in permutation test, it enables both FWER and FDR controlling.</p><p>@BULLET It is applicable to all statistics based on the contingency table. Previous methods are either designed for specific tests or require the test statistics to satisfy certain property. @BULLET Experimental results demonstrate that TEAM is more efficient than existing methods for large sample study. TEAM incorporates permutation test for proper error controlling. The key idea is to incrementally update the contingency tables of two-locus tests. We show that only four of the 18 observed frequencies in the contingency table need to be updated to compute the test value. In the algorithm, we build a minimum spanning tree (<ref type="bibr" target="#b3">Cormen et al., 2001</ref>) on the SNPs. The nodes of the tree are SNPs. Each edge represents the genotype difference between the two connected SNPs. This tree structure can be utilized to speed up updating process for the contingency tables. A majority of the individuals are pruned and only a small portion are scanned to update the contingency tables. This is advantageous in human study, which usually involves thousands of individuals. Extensive experimental results demonstrate the efficiency of the TEAM algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">THE PROBLEM OF TWO-LOCUS EPISTASIS DETECTION IN HUMAN GWAS</head><p>Suppose that the genotype dataset consists of N SNPs {X 1 ,...,X N } for M individuals {S 1 ,...,S M }. We adopt the convention of using 0 and 2 to represent the homozygous majority and homozygous minority genotypes, respectively, and 1 to represent the heterozygous case. Let Y 0 ∈{0,1} be the phenotype of interest (0 for controls and 1 for cases). Let Y ={Y 1 ,...,Y K } be the set of K permutations of Y 0. In each permutation Y k , the phenotype labels are randomly reassigned to individuals with no replacement.<ref type="figure" target="#tab_1">Table 1</ref>shows an example dataset of SNPs and phenotype permutations. The genotype dataset consists of six SNPs {X 1 ,...,X 6 } for 24 individuals {S 1 ,...,S 24 }. Individuals {S 1 ,...,S 12 } are cases and {S 13 ,...,S 24 } are controls. The phenotype is permuted five times, i.e. Y ={Y 1 ,...,Y 5 }. Let T denote the statistical test to be used. Specifically, we represent the test value of SNP X i and phenotype Y k (0 ≤ k ≤ K) as T (X i ,Y k ), and represent the test value of SNP pair (X i X j ) and Y k as T (X i X j ,Y k ). A contingency table that records the observed values of certain events, is the basis of many statistical tests. Tables 2–4 show contingency tables for the single-locus tests T (X i ,Y k ) and T (X j ,Y k ), genotype relationship between SNPs X i and X j and two-locus test T (X i X j ,Y k ), respectively. Due to the large number of hypotheses being tested, multiple testing problem has received considerable attention in GWAS. Controlling the FWER and FDR are two widely used approaches to control the error rate. The FWER is the probability of having i218Page: i219 i217–i227 TEAMat least one false positive. The FDR is the expected proportion of false positives among rejected hypotheses. Permutation test is the standard way to estimate the null distribution in both approaches. Next, we briefly describe the typical procedures of the FWER and FDR control. For statistical background of these approaches, refer to<ref type="bibr">Dudoit</ref></p><formula>X i = 0 X i = 1 X i = 2 Total X j = 0 X j = 1 X j = 2 Total Y k = 0 Event A Event B Event E Y k = 0 Event G Event H Event I Y k = 1 Event C Event D Event F Y k = 1 Event J Event L Event O Total M Total M</formula><formula>X i = 0 X i = 1 X i = 2 Total X j = 0 Event S Event T Event R X j = 1 Event P Event Q Event U X j = 2 Event V Event W Event Z Total M</formula><formula>X i = 0 X i = 1 X i = 2 Total X j = 0 X j = 1 X j = 2 X j = 0 X j = 1 X j = 2 X j = 0 X j = 1 X j = 2 Y k = 0</formula><formula>i.e. T Y k = max{T (X i X j ,Y k )|1 ≤ i &lt; j ≤ N}. The distribution of {T Y k |Y k ∈ Y }</formula><p>is used as the null distribution. Given an error rate threshold α, the critical value T α is the αK-th largest value in</p><formula>{T Y k |Y k ∈ Y }. A SNP pair (X i X j )</formula><p>is considered significant if its test value with the original phenotype Y 0 exceeds the critical value, i.e.</p><formula>T ( X i X j ,Y 0 ) ≥ T α .</formula><p>The FDR controlling procedure: let PV represent the set of the pooled test values of all permutation tests,</p><formula>i.e. PV ={T (X i X j ,Y k )|1 ≤ i &lt; j ≤ N,1 ≤ k ≤ K}. The P-value of test T (X i X j ,Y 0 ) can be calculated as p(T (X i X j ,Y 0 )) =|{t ≥ T (X i X j ,Y 0 )</formula><p>|t ∈ PV }|/|PV |, i.e. the proportion of the values in PV that are no less than</p><formula>T (X i X j ,Y 0 ). Let p (1) ≤ p (2) ... ≤ p (</formula><formula>set {p (1) ,p (2) ,...,p (v) }.</formula><p>In the FWER controlling, we only need the maximum test value of each permutation. To control the FDR, all test values need to be computed to estimate the P-value of the original tests. The existing algorithms, such as FastChi (<ref type="bibr" target="#b27">Zhang et al., 2009b</ref>) and COE (<ref type="bibr" target="#b26">Zhang et al., 2009a</ref>), prune the SNP pairs having weak associations. Thus they cannot be used to control the FDR. Our algorithm, TEAM, exhaustively computes the test values of all SNP pairs for every permutation. It can be used for both the FWER and FDR controlling. In this article, we mainly focus on the problem of permutation test, since it is the most computationally intensive procedure. Testing SNP pairs using original phenotype can be treated as a special case of permutation test.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X.Zhang et al.</head><p>contingency tables. For any test T based on the contingency table, to calculate the two-locus test value T (X i X j ,Y k ), one needs all 18 observed frequencies for the events in the two-locus contingency table shown in<ref type="figure" target="#tab_4">Table 4</ref>. The following theorem shows that we only need four of the 18 values to calculate the two-locus test value given the three contingency tables in Tables 2 and 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3.1. For SNPs X i , X j and permutation Y k , given the observed frequencies in Tables 2 and 3, specifically, the values of</head><formula>{O D ,O F ,O J ,O L ,O O ,O S ,O P ,O V ,O T ,O Q ,O W ,O R , O U ,O Z }</formula><p>, all of the observed frequencies in<ref type="figure" target="#tab_4">Table 4</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>can be determined if the values of</head><formula>{O d 2 ,O d 3 ,O f 2 ,O f 3 } are known.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. See Appendix.</head><p>Suppose that we have all the single-locus contingency tables, i.e.<ref type="figure" target="#tab_2">Table 2</ref>. Given a SNP pair (X i ,X j ),<ref type="figure" target="#tab_3">Table 3</ref></p><formula>d 2 ,O d 3 ,O f 2 ,O f 3 }, T (X i X j ,Y k )</formula><p>can be calculated accordingly. In the following, we show that these values can be computed incrementally utilizing a minimum spanning tree built on SNPs. We focus on the incremental process for</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">BUILDING THE MINIMUM SPANNING TREE ON THE SNPS</head><p>To build a minimum spanning tree (<ref type="bibr" target="#b3">Cormen et al., 2001</ref>) on the SNPs, let the SNPs {X 1 ,X 2 ,...,X N } be the nodes and SNP pairs (X i X j ) (i = j) be the (undirected) edges. For each edge (X i X j ), we denote its weight (the number of individuals having different genotypes in the two SNPs) as w(X i X j ). A spanning tree T is a tree that spans (connects) all SNPs. Let V (T ) be its node set and E(T ) be its edge set. A minimum spanning tree is a spanning tree whose weight</p><formula>W T = w(X i X j ), where (X i X j ) ∈ E(T )</formula><p>, is no greater thanany other spanning tree.<ref type="figure" target="#fig_2">Figure 1</ref>shows the minimum spanning tree built using the example dataset in<ref type="figure" target="#tab_1">Table 1</ref>. The number on each edge represents its weight. For example, in X 3 and X 2 , there are six individuals, {S 2 ,S 8 ,S 10 ,S 12 ,S 15 ,S 20 }, having different genotypes. For any individual, the genotype difference from X i to X j can be any one of the six combinations, i.e. 0 → 1 (indicating that the genotype in X i is 0, and the genotype in X j is 1), 1 → 0, 0 → 2, 2 → 0, 1 → 2 and 2 → 1. Using the example dataset in<ref type="figure" target="#tab_1">Table 1</ref>,<ref type="figure" target="#tab_5">Table 5</ref>shows the genotype differences between the connected two SNPs in the minimum spanning tree in<ref type="figure" target="#fig_2">Figure 1</ref>. We use (X i X j ) {u→v} (u,v ∈{0,1,2}) to represent the set of individuals whose genotype in X i is u and genotype in X j is v. For example,</p><formula>(X 3 X 2 ) {1→2} ={S 8 ,S 10 } and (X 3 X 2 ) {1→2}∪{0→2} ={S 2 ,S 8 ,S 10 }.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">INCREMENTALLY UPDATING OBSERVED FREQUENCY O d 2</head><p>In this section, we discuss how to update O d 2 by utilizing the minimum spanning tree. For clarity, from now on, we use</p><formula>d 2 (X i X j ,Y k )</formula><formula>= 1∧Y k = 1), and O D (X i ,Y k ) = |D(X i ,Y k )|.</formula><p>Next, we show that for any SNP pair (X i X j ) and an edge</p><formula>(X j X j ) ∈ E(T ), given O d 2 (X i X j ,Y k )</formula><p>, how to update the value for</p><formula>O d 2 (X i X j ,Y k</formula><p>). From the contingency tables in<ref type="figure" target="#tab_2">Table 2</ref>–4, it is easy to see that</p><formula>O d 2 (X i X j ,Y k ) =|D(X i ,Y k )∩Q(X i ,X j )|, and O d 2 (X i X j ,Y k ) =|D(X i ,Y k )∩Q(X i ,X j )|.</formula><p>The following theorem shows that, given</p><formula>O d 2 (X i X j ,Y k ) and D(X i ,Y k )</formula><p>, using the genotype difference associated with edge (X j X j ), we can get the value of</p><formula>O d 2 (X i X j ,Y k ).</formula><p>Theorem 5.1. For any SNP pair</p><formula>(X i X j ) and an edge (X j X j ) ∈ E(T ), we have O d 2 (X i X j ,Y k ) = O d 2 (X i X j ,Y k )+|D(X i ,Y k )∩ (X j X j ) {0→1}∪{2→1} |− |D(X i ,Y k )∩(X j X j ) {1→0}∪{1→2} |.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. See Appendix.</head><p>Example 5.2. Using the example dataset in<ref type="figure" target="#tab_1">Table 1</ref>, let i = 3, j = 2, j = 5, and k = 4, i.e. we consider SNP pair (X 3 X 2 ),<ref type="figure" target="#tab_5">Table 5</ref>. Genotype difference between the connected SNPs in the minimum spanning tree shown in<ref type="figure" target="#fig_2">Figure 1</ref>0Page: i221 i217–i227 TEAM</p><formula>→ 1 1 → 0 0 → 2 2 → 0 1 → 2 2 → 1</formula><formula>(X 3 X 2 ) ∅ ∅ { S 2 } { S 12 ,S 15 ,S 20 } { S 8 ,S 10 } ∅ (X 2 X 5 ) {S 7 } { S 13 } { S 3 } { S 1 ,S 4 ,S 6 ,S 16 ,S 23 } ∅ { S 8 ,S 10 } (X 5 X 6 ) ∅ ∅ { S 16 } { S 9 ,S 24 } { S 7 } ∅ (X 6 X 1 ) {S 4 } { S 8 ,S 10 } { S 5 ,S 9 ,S 12 ,S 23 } { S 2 ,S 3 ,S 11 ,S 21 } ∅ ∅ (X 6 X 4 ) ∅ ∅ ∅ { S 16 ,S 18 } { S 10 } { S 21 } i220</formula><formula>S 8 {Y 2 ,Y 3 } S 10 {Y 2 ,Y 3 ,Y 4 ,Y 5 } S 13 {Y 1 ,Y 2 ,Y 4 ,Y 5 } S 19 {Y 3 ,Y 4 }</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>permutation Y 4 and the edge (X</head><formula>d 2 (X 3 X 5 ,Y 4 ) from O d 2 (X 3 X 2 ,Y 4 )without scanning all individuals.</formula><p>So far, we have discussed the procedure to update the value</p><formula>of O d 2 (X i X j ,Y k ) from O d 2 (X i X j ,Y k )</formula><p>for a specific phenotype permutation Y k. This procedure can be easily extended to handle all the permutations. From Theorem 5.1, for any permutation Y k , to update the value of</p><formula>O d 2 (X i X j ,Y k ) from O d 2 (X i X j ,Y k )</formula><p>, we need the value of D(X i ,Y k ) and the genotype difference associated with edge (X j X j ). Note that the genotype difference is fixed once the minimum spanning tree is built. Next, we discuss how to compute</p><formula>D(X i ,Y k ) for all permutations {Y 1 ,Y 2 ,...,Y K }</formula><p>in a batch mode in detail. Let D K (X i ) be a list of M entries, with each entry corresponding to an individual. For each individual S m , we record in D K (X i )<ref type="bibr">[m]</ref>the set of phenotypes satisfying (X i = 1∧Y k = 1). For example, consider the dataset in<ref type="figure" target="#tab_1">Table 1</ref>, we have that D K (X 3 )<ref type="bibr">[8]</ref>={Y 2 ,Y 3 }.<ref type="figure" target="#tab_4">Table 4</ref>shows the entries of D K (X 3 ). Only non-empty entries, i.e.<ref type="bibr">[m]</ref>=∅, are shown in the table. It is easy to see that, for any X i and Y k , we can get</p><formula>D K (X i )</formula><formula>D(X i ,Y k ) from D K (X i ) as follows: D(X i ,Y k )</formula><p>is the set of individuals whose corresponding entries in D K (X i ) contain Y k as an element, i.e.</p><formula>D(X i ,Y k ) ={S m |Y k ∈ D K (X i )[m]}. (1)</formula><p>For example, using the example dataset in<ref type="figure" target="#tab_1">Table 1</ref>, from<ref type="figure" target="#tab_6">Table 6</ref>, we know that D(</p><formula>X 3 ,Y 4 ) ={S 10 ,S 13 ,S 19 }. For SNP pair (X i X j ), let O d 2 (X i X j ) =[O d 2 (X i X j ,Y 1 ), O d 2 (X i X j ,Y 2 ),...,O d 2 (X i X j ,Y K )]. From Theorem 5.1 and Equation (1), for any SNP pair (X i X j ) and an edge (X j X j ) ∈ E(T ), we can get O d 2 (X i X j ) from O d 2 (X i X j ) using D K (X i</formula><p>) and the genotype difference information associated with edge (X j X j ). First,), which can be defined in a similar way to that of D K (X i ): for each individual S m , we record in F K (X i )<ref type="bibr">[m]</ref>the set of phenotypes satisfying (X i = 2∧Y k = 1).</p><formula>initialize O d 2 (X i X j ) = O d 2 (X i X j ). Next, for every m (1 ≤ m ≤ M), if Y k ∈ D K (X i )[m], we update O d 2 (X i X j ) as follows: increase O d 2 (X j X j ,Y k ) if S m ∈ (X j X j ) {0→1}∪{2→1} ; decrease O d 2 (X j X j ,Y k ) if S m ∈ (X j X j ) {1→0}∪{1→2} .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">THE TEAM ALGORITHM</head><p>TEAM examines SNP pairs through a double loop, where the outer loop visits a leaf node at a time, and the inner loop traverse the rest of the tree, starting from the parent node of the leaf. Let</p><formula>O d 2 d 3 f 2 f 3 (X i X j ) =[O d 2 (X i X j ),O d 3 (X i X j ),O f 2 (X i X j ), O f 3 (X i X j )]</formula><p>. Let L(T ) ∈ V (T ) be the set of leaf nodes of the minimum spanning tree T. For any leaf node X i ∈ L(T ), let AP(The overall algorithm is summarized in Algorithm 1. Given the SNPs</p><formula>X i ) ={(X i X j )|i = j,X j ∈ V (T )}</formula><formula>) ={(X 3 X 2 ),(X 3 X 5 ), (X 3 X 6 ),(X 3 X 1 ),(X 3 X 4 )}.</formula><formula>X ={X 1 ,X 2 ,...,X N }, phenotype permutations Y ={Y 1 ,Y 2 ,...,Y K }</formula><p>, we first enumerate and store all single-locus contingency tables. We then build the minimum spanning tree T , with genotype difference associated with each edge. For leaf node X i , we compute), we delete X i from T and repeat the procedure for the remaining leaf nodes. Time complexity: the time complexity on generating all singlelocus contingency tables and building the minimum spanning tree is O(MNK) and O(MN 2 ), respectively. The time complexity to</p><formula>D K (X i ), F K (</formula><formula>compute D K (X i ) and F K (X i ) for all SNPs is O(MNK). The total updating cost for all AP(X i ) is O(W T NK).</formula><p>Thus, the overall time complexity of TEAM is O(MNK +MN 2 +W T NK). Note that the complexity of the brute force approach is O(MN 2 K). The number of SNPs N is the dominant factor. Space complexity: the dataset size is O(M(N +K)). The space needed to store all single-locus contingency tables is O(NK). The size of tree T is O(W T ). The size of</p><formula>D K (X i ) and F K (X i ) is O(MK).</formula><p>Thus, the total space complexity of TEAM is O(M(N +K)+ K(N +M)+W T ). Note that we can do incremental computation using any exploration order. TEAM utilizes minimum spanning tree to update the contingency tables. The reason is that the cost of such update depends on the difference between the SNPs. The more similar they are, the lower the cost. Since minimum spanning tree has the minimum weight W T over all spanning trees, using it to guide the computation leads to optimal efficiency. It is not absolutely necessary to use a minimum spanning tree. As long as the tree is close to a minimum spanning tree, we should expect good performance. An implementation issue in building the minimum spanning tree is that we need O(N 2 ) space to store all pairwise differences between the SNPs. In practise, we divide the SNPs into sub groups of equal size. A minimum spanning tree is built for each group. Then the sub trees are merged to a larger tree by randomly connecting leave nodes. The tree built in this way is an approximate minimum spanning tree. Our focus in this article is not to build an optimal minimum spanning tree, but to use the tree structure for efficient updating. Refer to Eisner (1997) and Graham and Hell (1985) for surveys on minimum spanning tree construction. In the experiments, we show the performance evaluation using different spanning trees.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EXPERIMENTAL RESULTS</head><p>In this section, we present extensive experimental results on the performance of the TEAM algorithm. TEAM is implemented in C++. We first evaluate the efficiency of TEAM. Then, we present the findings of epistasis detection in simulated human genome-wide study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Efficiency evaluation</head><p>We use both simulated human and real mouse for the efficiency evaluation experiments. The experiments are performed on a 2.6 GHz PC with 8G memory running Linux system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Human data</head><p>The human datasets are generated by the simulator Hapsample (<ref type="bibr" target="#b23">Wright et al., 2007</ref>), which is publicly accessible from the web site http://www.hapsample.org. We evaluate the performance of TEAM by comparing it with the brute force approach since there is no previous algorithm readily applicable to human datasets. Note that the brute force approach is very time consuming, we use a moderate number of SNPs and permutations in the experiments so that the brute force approach can finish in a reasonable amount of time. Unless otherwise specified, the default experimental setting is the following: #individuals = 400, #SNPs = 10 000, #permutations = 100, and the case/control ratio is 1. These experimental settings are chosen to demonstrate the efficiency gain offered by TEAM over the brute force implementation. TEAM can handle much larger datasets. The performance of TEAM is expected to follow the same trends presented in this section. TEAM contains three major components: building the minimum spanning tree, updating the contingency tables, and calculating the actual test values. Note that TEAM can be applied to any statistics defined on the contingency table. With different statistics, the only difference in runtime would be caused by the last component calculating the statistics. In the experiments, we choose chi-square test as our statistic.<ref type="figure" target="#fig_4">Figure 2</ref>shows the running time comparison of TEAM and the brute force approach using different experimental settings. The y-axis is in logarithm scale. In these figures, we also show the detailed runtime of these three components.<ref type="figure" target="#tab_8">Table 8</ref>shows the percentage of individuals pruned by TEAM under different experimental settings. Since in theory we can update the contingency tables in any exploration order, in the table, we also show the pruning effect of using a random spanning tree and a linear spanning tree to guide the updating process. The random spanning tree is generated by starting from a randomly picked SNP and growing edges that connect the remaining SNPs in a random order. The linear tree is a single path connecting all SNPs sequentially. From the table, we can see that TEAM prunes more effectively than the other two updating methods. In the table, we also show the ratio of the tree weights and the size of the SNP dataset, i.e. W T /(M ×N), which is a determining factor of the pruning ratio. Note that varying i222<ref type="figure" target="#fig_4">Figures 2a</ref>depicts the runtime comparison when varying the number of SNPs. TEAM is more than an order of magnitude faster than the brute force approach. Among the three components of TEAM, the procedures on building the minimum spanning tree and calculating test values only take a small portion of the total runtime of TEAM. The runtime of TEAM is dominated by the cost of updating the contingency tables. As will be shown later, TEAM prunes most of the individuals when updating the contingency tables. In<ref type="figure" target="#fig_4">Figures 2b</ref>–d, we can also observe a similar one to two orders of magnitude speed up of TEAM over the brute force approach when varying the number of individuals, the number of permutations and the case/control ratio.</p><formula>(d) (c)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.2">Mouse data</head><p>The mouse datasets is extracted from a set of combined SNPs from the 10 K GNF (http://www.gnf.org/) mouse dataset and the 140 K Broad/MIT mouse dataset (<ref type="bibr" target="#b20">Wade and Daly, 2005</ref>). This merged dataset has 1 56 525 SNPs for 71 mouse strains. The missing values in the dataset are imputedPage: i224 i217–i227using NPUTE (<ref type="bibr" target="#b16">Roberts et al., 2007</ref>). We compare TEAM and the recently proposed COE algorithm (<ref type="bibr" target="#b26">Zhang et al., 2009a</ref>), which is specifically designed for association study in mouse datasets. The default experimental setting is as follows: #individuals = 70, #SNPs = 10 000, #permutations = 100, and the case/control ratio is 1.<ref type="figure" target="#fig_6">Figure 3</ref>shows the comparison results. In the figure, we also plot the runtime of the brute force approach.<ref type="figure" target="#fig_6">Figure 3a</ref>shows the runtime of the three approaches when varying the number of SNPs. It is clear that both TEAM and COE are orders of magnitude faster than the brute force approach. TEAM is about twice faster than COE.<ref type="figure" target="#fig_6">Figure 3b</ref>shows the runtime comparison when varying the number of individuals. From the figure, COE is more suitable for datasets having small number of individual. As the number of individuals increases, the TEAM algorithm becomes more efficient than COE. Note that in human study, the number of individuals usually ranges up to thousands, much larger than that in typical mouse datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X.Zhang et al.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>100</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Epistasis detection in simulated human GWAS</head><p>In this section, we report the results of epistasis detection using simulated human GWAS data generated by Hapsample. In total, we generate four datasets, each of which has 112 036 SNPs for 250 cases and 250 controls. In each dataset, a disease causal interacting SNP pair is embedded. The embedded SNP pairs are: (rs768529, rs3804940) in dataset 1, (rs10495728, rs521882) in dataset 2, (rs1016836, rs2783130) in dataset 3 and (rs648519, rs1012273) in dataset 4. We use standard chi-square test with 500 permutations. Similar results can be found by using likelihood ratio test.</p><p>With an overall FDR threshold of 0.005,<ref type="figure" target="#tab_9">Table 9</ref>shows the identified significant SNP pairs using TEAM. TEAM successfully identified the embedded SNP pairs in all simulated datasets. The embedded SNP pairs are labelled with stars '*'. The table shows the SNP loci on the genome. For example, in dataset 1, we embed SNP pair rs768529 and rs3804940, which are located on chromosome 1 at position 51 946 762 bp and chromosome 3 at 7 520 545 bp, respectively. The FWER for each reported SNP pair is also shown. Note that, for a SNP pair, an FDR (or FWER) value of 0 indicates that permutation tests do not generate any test value larger than value of the reported SNP pair. In dataset 1, except for the embedded SNP pair (rs768529, rs3804940), five other SNP pairs are also reported. One of the embedded SNP, rs768529, is involved in all the five pairs. A closer look at the other SNPs in the reported SNP pairs shows that they are all adjacent to the embedded SNP rs3804940. The normalized linkage disequilibrium (<ref type="bibr" target="#b11">Lewontin and Kojima, 1960</ref>) between rs3804940 and the other five SNPs are D (rs3804940, rs756084)= 1, D (rs3804940, rs779742)= 0.477, D (rs3804940, rs1872393)= 0.442, D (rs3804940, rs779744)= 0.442 and D (rs3804940, rs6764561)= 0.454, indicating there is strong linkage disequilibrium between them.Page: i225 i217–i227</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION AND FUTURE WORK</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>TEAM</head><p>makes the problem computationally even more intensive. In this article, we propose an efficient algorithm, TEAM, for epistasis detection human GWAS. TEAM has the same strength as the recently developed epistasis detection methods, i.e. it guarantees to find the optimal solution. Compared with existing methods, TEAM is more efficient in large sample study, and offers broader applicability. Existing methods designed for homozygous SNPs cannot be used for human data where most SNPs are heterozygous. TEAM, on the other hand, can handle both homozygous and heterozygous SNPs. Since it exhaustively enumerate all SNP pairs, TEAM can be used to control the FWER and FDR, both of which are widely used in controlling error in GWAS; while previous methods only control the FWER. Existing methods need to exam the formulation of the statistic. TEAM is focused on efficiently updating contingency tables rather than any specific statistic. It can, therefore, be used for any statistical test based on contingency table regardless of its formulation. In this artcile, we focus on the disease phenotypes that can be represented as binary variables. Many association studies involve phenotypes measured as continuous variables. We will investigate how to apply the idea of the current algorithm to quantitative phenotypes in the future study. Funding: National Science Foundation (awards IIS0448392, IIS0812464, partially).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict</head><p>of Interest: none declared.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>X.Zhang et al.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>APPENDIX</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 3.1</head><p>Proof. From the four contingency tables shown in Tables 2–4, it is easy to get the following linear equation system:</p><formula>⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝</formula><p>1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0<ref type="figure" target="#fig_2">0 0 0 0 0 1 1 1  1</ref>0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1</p><formula>⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ O a 1 O a 2 O a 3 O b 1 O b 2 O b 3 O c 1 O c 2 O c 3 O d 1 O d 2 O d 3 O e 1 O e 2 O e 3 O f 1 O f 2 O f 3 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ = ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ O A O B O C O D O E O F O G O H O I O J O L O O O S O P O V O T O Q O W O R O U O Z ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠</formula><p>The rank of the above linear system is 14. We thus take 14 rows {4,6,10,11,12,13,14,15,16,17,18,19,20,21}, which form a full rank matrix. The row reduced echelon form of this non-redundant linear system is ⎛</p><formula>⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝</formula><p>1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 O S −O W +O D +O F 0 1 0 0 0 0 0 0 0 0 −1 0 0 0 0 0 −1 0 O P −O V 0 0 1 0 0 0 0 0 0 0 0 −1 0 0 0 0 0 −1 O G −O U 0 0 0 1 0 0 0 0 0 0 −1 −1 0 0 0 0 0 0 O T −O D 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 O Q 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 O H 0 0 0 0 0 0 1 0 0 0 −1 −1 0 0 0 0 −1 −1 O W −O D −O F 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 0 O V 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 1 O U 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 O D 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 −1 −1 O R −O F 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 O O 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 O L 0 0 0 0 0 0 0 0 0 0 0</p><formula>0 0 0 0 1 1 1 O F ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠</formula><p>Thus, we have the following solution:</p><formula>⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ O a 1 O a 2 O a 3 O b 1 O b 2 O b 3 O c 1 O c 2 O c 3 O d 1 O e 1 O e 2 O e 3 O f 1 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ = ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ O S −O W +O D +O F O P −O V O G −O U O T −O D O Q O H O W −O D −O F O V O U O D O R −O F O O O L O F ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ − ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ 1 −1 0 −1 1 0 −1 1 0 1 0 0 0 0 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ O d 2 − ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ 1 0 −1 −1 0 1 −1 0 1 1 0 0 0 0 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ O d 3 − ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ 1 −1 0 0 0 0 −1 1 0 0 −1 1 0 1 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ O f 2 − ⎛ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎜ ⎝ 1 0 −1 0 0 0 −1 0 1 0 −1 0 1 1 ⎞ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎟ ⎠ O f</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof of Theorem 5.1</head><p>Proof. It suffices to show that</p><formula>D(X i ,Y k )∩Q(X i ,X j ) =[D(X i ,Y k )∩Q(X i ,X j )]∪[D(X i ,Y k )∩((X j X j ) {0→1}∪{2→1} )]−[D(X i ,Y k )∩((X j X j ) {1→0}{1→2} )].</formula><p>This is the same as to show that</p><formula>Q(X i ,X j ) = Q(X i ,X j )∪((X j X j ) {0→1}∪{2→1} )−((X j X j ) {1→0}{1→2} ).</formula><p>This is clearly true, hence completes the proof.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i227</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>[11:33 12/5/2010 Bioinformatics-btq186.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>N(N−1)/2) be the ordered P-values of the original tests. Let v = max{u : p (u) ≤ uα N(N−1)/2 }. The classic Benjamini–Hochberg method rejects all hypotheses for which the corresponding P-values are in the</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.1.</head><figDesc>Fig. 1. The minimum spanning tree built on the SNPs in the example dataset shown in Table 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.2.</head><figDesc>Fig. 2. Comparison between TEAM and the brute force approach on human datasets under various experimental settings: varying the number of SNPs (a), individuals (b), permutations (c) and varying the case/control ratio (d).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>i223 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from [11:33 12/5/2010 Bioinformatics-btq186.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.3.</head><figDesc>Fig. 3. Comparison between TEAM, COE and the brute force approach on mouse datasets under various experimental settings: (a) varying the number of SNPs and (b) varying the number of individuals.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>The large number of SNPs genotyped in the genome-wide scale poses great computational challenges in two-locus epistasis detection. The permutation test used for proper error rate controlling i224 [11:33 12/5/2010 Bioinformatics-btq186.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. An example dataset consisting of six SNPs {X 1 ,...,X 6 }, the original phenotype Y 0 and five phenotype permutations {Y 1 ,...,Y 5 } for 24 individuals {S 1 ,...,S 24 } S 1 S 2 S 3 S 4 S 5 S 6 S 7 S 8 S 9 S 10 S 11 S 12 S 13 S 14 S 15 S 16 S 17 S 18 S 19 S 20 S 21 S 22 S 23 S 24</figDesc><table>X 1 0 
0 
0 
1 
2 
0 
2 
0 
2 
0 
0 
2 
0 
0 
0 
2 
0 
2 
1 
0 
0 
2 
2 
0 
X 2 2 
2 
0 
2 
0 
2 
0 
2 
2 
2 
2 
0 
1 
0 
0 
2 
0 
2 
1 
0 
2 
2 
2 
2 
X 3 2 
0 
0 
2 
0 
2 
0 
1 
2 
1 
2 
2 
1 
0 
2 
2 
0 
2 
1 
2 
2 
2 
2 
2 
X 4 0 
2 
2 
0 
0 
0 
2 
1 
0 
2 
2 
0 
0 
0 
0 
0 
0 
0 
1 
0 
1 
2 
0 
0 
X 5 0 
2 
2 
0 
0 
0 
1 
1 
2 
1 
2 
0 
0 
0 
0 
0 
0 
2 
1 
0 
2 
2 
0 
2 
X 6 0 
2 
2 
0 
0 
0 
2 
1 
0 
1 
2 
0 
0 
0 
0 
2 
0 
2 
1 
0 
2 
2 
0 
0 

Y 0 1 
1 
1 
1 
1 
1 
1 
1 
1 
1 
1 
1 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 2. Contingency tables for single-locus tests T (X i ,Y k ) and T (X j ,Y k ) Contingency table for T (X i ,Y k ) Contingency table for T (X j ,Y k )</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 3. Contingency table for genotype relation between two SNPs X i and X j</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 4. Contingency table for two-locus test T (X i X j ,Y k )</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Event a 1 Event a 2 Event a 3 Event b 1 Event b 2 Event b 3 Event e 1 Event e 2 Event e 3 Y k = 1 Event c 1 Event c 2 Event c 3 Event d 1 Event d 2 Event d 3 Event f 1 Event f 2 Event f 3</figDesc><table>Total 
M 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>and Laan (2008) and Westfall and Young (1993) for details. The FWER controlling procedure: for each permutation Y k ∈ Y , let T Y k represent the maximum test value among all SNP pairs,</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>is fixed. Thus, from Theorem 3.1, for permutation Y k , once we have the values of {O</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><figDesc>O d 2. The same process can be applied to update O d 3 , O f 2 and O f 3. We first discuss how to update O d 2 for a specific permutation. Then we show that the procedure can also handle all the permutations in a batch mode.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><figDesc>to denote the specific event d 2 for the SNP pair (X i X j ) and permutation Y k , i.e. the subsets of individuals satisfying (X i = 1∧X j = 1∧Y k = 1). We use O d 2 (X i X j ,Y k ) to represent its observed frequency, i.e. O d 2 (X i X j ,Y k ) =|d 2 (X i X j ,Y k )|.</figDesc><table>This notation also applies to other events in the contingency 
tables shown in Tables 2–4. For example, D(X i ,Y k ) represents the 
subset of individuals satisfying (X i </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="false"><figDesc>Table 6. Entries of D K (X 3 ) with empty entries omitted for all permutations in a batch mode</figDesc><table>Individual id. 
Phenotype permutations 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><figDesc>2 X 5 ) in Figure 1. Suppose that we already know that O d 2 (X 3 X 2 ,Y 4 ) = 2, and event D(X 3 ,Y 4 ) = {S 10 ,S 13 ,S 19 }. From Table 5, we have (X 2 X 5 ) {0→1}∪{2→1} = {S 7 ,S 8 ,S 10 }, and (X 2 X 5 ) {1→0}∪{1→2} ={S 13 }. Thus according to Theorem 5.1, we have O d 2 (X 3 X 5 ,Y 4 ) = O d 2 (X 3 X 2 ,Y 4 )+|{S</figDesc><table>10 }|− 
|{S 13 }| = 2. Note that by this way, we get the value of O </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="false"><figDesc>(X 3 X 2 ) and (X 3 X 5 ), with (X 2 X 5 (X 2 X 5 ) is (X 2 X 5 ) {0→1}∪{2→1} ={S 7 ,S 8 ,S 10 }, and (X 2 X 5 ) {1→0}∪{1→2} ={S 13 }. For individual S m ∈{S 7 ,S 8 ,S 10 } (S m ∈{S 13 }), we need to increase (decrease) the corresponding</figDesc><table>Example 5.3. Following Example 5.2, we consider the two 
SNP pairs ) being an edge of 
the tree in Figure 1. Assume that D K (X 3 ) is as shown in 
Table 6, and O d 2 (X 3 X 2 ) =[1,1,1,2,1]. From Table 5, the genotype 
difference on edge </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_13" validated="false"><figDesc>Table 7. Updating O d 2 (X 3 X 5 ) from O d 2 (X 3 X 2 ) for all permutations in a batch mode Y 1 Y 2 Y 3 Y 4 Y 5 O d 2 (X 3 X 5 2 (X 3 X 5 ) after updating for S 7 2 (X 3 X 5 ) after updating for S 8 2 (X 3 X 5 ) after updating for S 10 2 (X 3 X 5 ) after updating for S 13 0 2 3 2 1 values in O d 2 (X 3 X 2 ) according to D K (X 3 ). Table 7 shows the updating process for O d 2 (X 3 X 5 ). Initially, O d 2 (X 3 X 5 ) = O d 2 (X 3 X 2 ). For individual S 7 , since its corresponding entry in D K (X3), D K (X3)[7]=∅, O d 2 (X 3 X 5 ) remains unchanged. For individual S 8 , D K (X3)[8]={Y 2 ,Y 3 }, we increase the values of O d 2 (X 3 X 5 ,Y 2 ) and O d 2 (X 3 X 5 ,Y 3 ) by 1. Similarly, we increase and decrease the values in O d 2 (X 3 X 5 ) according to D K (X3) for S 10 and S 13. For individual S 19 , we do not have any update because S 19 / ∈{S 7 ,S 8 ,S 10 } and S 19 / ∈{S 13 }. The final result is O d 2 (X 3 X 5 ) =[0,2,3,2,1]. Note that to get the value of O d 2 (X i X j ), using a brute force approach, we need to scan a (2+K)×M matrix consisting of the genotype of (X i X j ) and permutations {Y 1 ,Y 2 ,...,Y K } for the M individuals. In the previous example, to compute the value of O d 2 (X 3 X 5 ), the cost of the brute force approach is (3+5)×24 = 192. Using our approach, the total number of updates is |D K (X3)[8]|+ |D K (X3)[10]|+|D K (X3)[13]| = 10, which is significantly less than the cost of the brute force approach. More formally, given D K (X i ), the time complexity of updating O d 2 (X i X j ) from O d 2 (X i X j ) is O(w(X j X j )K). The procedure of updating O d 2 (X i X j ) from O d 2 (X i X j ) can also be applied to update the remaining free variables O d 3 (X i X j ), O f 2 (X i X j ) and O f 3 (X i X j ). Note that, to update O f 2 (X i X j ), O f 3 (X i X j ), we will need F K (X i</figDesc><table>) after initializing 
1 
1 
1 
2 
1 
O d 1 
1 
1 
2 
1 
O d 1 
2 
2 
2 
1 
O d 1 
3 
3 
3 
2 
O d </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_14" validated="false"><figDesc>. Let X a be the parent node of X i. Since all SNPs are connected in T , once we have O d 2 d 3 f 2 f 3 (X i X a ), we can update all O d 2 (X i X j ) ∈ AP(X i ) by enumerating the edges in E(T ) in a breath-first traversal starting from X a. Example 6.1. Consider the tree in Figure 1. Let X i = X 3 and X a = X 2. We have AP(X 3</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_15" validated="false"><figDesc>Starting from X 3 , a breadth-first search will enumerate edges {(X 2 X 5 ),(X 5 X 6 ), (X 6 X 1 ),(X 6 X 4 )}, which can be utilized to update O d 2 d 3 f 2 f 3 (X i X j ) for the SNP pairs in AP(X 3 ). Once the SNP pairs in AP(X i ) have been processed, we delete X i from L(T ), and repeat the same process for another leaf node. i221 X.Zhang et al. Algorithm 1 The TEAM Algorithm Input: SNPs X ={X 1 ,X 2 ,...,X N }, phenotype permutations Y ={Y 1 ,Y 2 ,...,Y K } Output: T (X i X j ,Y k ) for all possible two-locus tests compute and store all single-locus contingency tables; build minimum spanning tree T ; for every X i ∈ L(T ), do compute D K (X i ) and F K (X i ); compute O d 2 d 3 f 2 f 3 (X i X a ); compute T (X i X a ,Y k ) (1≤ k ≤ K) and output; EnumStack.push(O d 2 d 3 f 2 f 3 (X i X a )); while EnumStack =∅ do O d 2 d 3 f 2 f 3 (X i X j ) = EnumStack.pop(); for every X j = adj(X j ) do update O d 2 d 3 f 2 f 3 (X i X j ) from O d 2 d 3 f 2 f 3 (X i X j ); compute T (X i X j ,Y k ) (1≤ k ≤ K) and output; EnumStack.push(O d 2 d 3 f 2 f 3 (X i X j )); end end delete X i from T ; end</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_16" validated="false"><figDesc>X i ) and O d 2 d 3 f 2 f 3 (X i X a ). This information is then used to incrementally update O d 2 d 3 f 2 f 3 (X i X j ) for all SNP pairs in AP(X i ). After processing AP(X i</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_18" validated="true"><figDesc>Table 8. The tree weight and the proportion of the individuals pruned by TEAM on the human datasets</figDesc><table>Settings 
TEAM 
Updating by Random Tree 
Updating by Linear Tree 

Tree weight (%) 
Pruning ratio (%) 
Tree weight (%) 
Pruning ratio (%) 
Tree weight (%) 
Pruning ratio (%) 

No. of SNPs 
10 K 
17.721 
94.104 
53.326 
88.722 
53.158 
89.210 
20 K 
18.692 
93.981 
52.881 
88.895 
52.851 
89.390 
30 K 
19.314 
93.802 
53.011 
88.823 
52.946 
89.380 

No. of Individuals 
200 
16.641 
94.376 
53.358 
88.749 
53.179 
89.205 
300 
17.342 
94.209 
53.343 
88.730 
53.142 
89.213 
400 
17.721 
94.104 
53.326 
88.722 
53.158 
89.210 

No. of Permutations 
100 
17.721 
94.104 
53.326 
88.722 
53.158 
89.210 
300 
17.721 
94.105 
53.326 
88.724 
53.158 
89.212 
500 
17.721 
94.104 
53.326 
88.724 
53.158 
89.212 

Case/control ratio 
100/300 
17.721 
97.049 
53.326 
94.355 
53.158 
94.599 
200/200 
17.721 
94.104 
53.326 
88.722 
53.158 
89.210 
300/100 
17.721 
97.049 
53.326 
94.355 
53.158 
94.599 

the number of permutations and the case/control ratio does not effect 
the tree being built. 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_20" validated="true"><figDesc>Table 9. Identified significant SNP pairs in the simulated human GWAS datasets</figDesc><table>Dataset 
Significant SNP-pair 
Chromosome and location 
FDR 
FWER 

1 
(rs768529, rs3804940)  *  
(chr1: 51946762, chr3: 7520545) 
0.00067 
0 
(rs768529, rs756084) 
(chr1: 51946762, chr3: 7536149) 
0.00067 
0 
(rs768529, rs779742) 
(chr1: 51946762, chr3: 7558058) 
0.00067 
0 
(rs768529, rs1872393) 
(chr1: 51946762, chr3: 7546236) 
0.00067 
0.004 
(rs768529, rs779744) 
(chr1: 51946762, chr3: 7555121) 
0.00067 
0.004 
(rs768529, rs6764561) 
(chr1: 51946762, chr3: 7514592) 
0.00067 
0.004 

2 
(rs10495728, rs521882)  *  
(chr2: 22811773, chr8: 16688797) 
0.004 
0.004 

3 
(rs1016836, rs2783130)  *  
(chr10: 31935845, chr13: 79068161) 
0 
0 

4 
(rs648519, rs1012273)  *  
(chr11: 98972936, chr16: 58525067) 
0.002 
0.002 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_21" validated="false"><figDesc>TEAM Clearly, only four variables {O d 2 ,O d 3 ,O f 2 ,O f 3 } are free.</figDesc><table>3 

i226 

at :: on August 31, 2016 

http://bioinformatics.oxfordjournals.org/ 

Downloaded from 

[11:33 12/5/2010 Bioinformatics-btq186.tex] 

Page: i227 i217–i227 

Once the values of these free variables are known, the observed frequencies of 
remaining events in the two-locus contingency table are also known. 

</table></figure>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> FREE VARIABLES IN THE CONTINGENCY TABLE OF TWO-LOCUS TEST Let E event and O event denote the expected frequency and observed frequency of an event in Tables 2–4. Note that each event represents a subset of individuals. For example, event D is a subset of individuals satisfying (X i = 1∧Y k = 1), and O D represents its observed frequency, i.e. O D =|D|. Using the dataset in Table 1, consider X 3 and Y 4 (i.e. i = 3 and k = 4), we have D ={S 10 ,S 13 ,S 19 }, and O D = 3. Many statistics, such as chi-square test and likelihood ratio test are defined as functions of the observed frequencies in i219 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">i225 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">A tutorial on statistical methods for population association studies</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Balding</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="781" to="791" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">The use of a genetic algorithm for simultaneous mapping of multiple interacting quantitative trait loci</title>
		<author>
			<persName>
				<forename type="first">O</forename>
				<surname>Carlborg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Empirical threshold values for quantitative trait mapping</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">A</forename>
				<surname>Churchill</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">W</forename>
				<surname>Doerge</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genetics</title>
		<imprint>
			<biblScope unit="volume">138</biblScope>
			<biblScope unit="page" from="963" to="971" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title level="m" type="main">Introduction to Algorithms</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">H</forename>
				<surname>Cormen</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>MIT Press and McGraw-Hill</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">Multiple Testing Procedures with Applications to Genomics</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Dudoit</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Laan</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2008" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title level="m" type="main">State-of-the-art algorithms for minimum spanning trees: a tutorial discussion</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Eisner</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Two-stage two-locus models in genome-wide association</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">M</forename>
				<surname>Evans</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page">157</biblScope>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">On the history of the minimum spanning tree problem</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">L</forename>
				<surname>Graham</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Hell</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. History Comput</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="43" to="57" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Genome-wide association studies for common diseases and complex traits</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">N</forename>
				<surname>Hirschhorn</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Daly</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="95" to="108" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Mathematical multi-locus approaches to localizing complex human trait genes</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Hoh</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Ott</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="701" to="709" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Selecting snps in two-stage analysis of disease association data: a model-free approach</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Hoh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Ann. Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">64</biblScope>
			<biblScope unit="page" from="413" to="417" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">The evolutionary dynamics of complex polymorphisms</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">C</forename>
				<surname>Lewontin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Kojima</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evolution</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="458" to="472" />
			<date type="published" when="1960" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title level="m" type="main">Simultaneous Statistical Inference</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">G</forename>
				<surname>Miller</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1981" />
			<publisher>Springer</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Detection of gene x gene interactions in genome-wide association studies of human population data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">K</forename>
				<surname>Musani</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Hum. Hered</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="67" to="84" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">A combinatorial partitioning method to identify multilocus genotypic partitions that predict quantitative trait variation</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">R</forename>
				<surname>Nelson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="458" to="470" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Multifactor-dimensionality reduction reveals high-order interactions among estrogen-metabolism genes in sporadic breast cancer</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">D</forename>
				<surname>Ritchie</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am. J. Hum. Genet</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="page" from="138" to="147" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Inferring missing genotypes in large snp panels using fast nearest-neighbor searches over sliding windows</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Roberts</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of ISMB</title>
		<meeting>eeding of ISMB</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Genome-wide association analysis identifies loci for type 2 diabetes and triglyceride levels</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Saxena</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">316</biblScope>
			<biblScope unit="page" from="1331" to="1336" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Genome-wide association scan shows genetic variants in the fto gene are associated with obesity-related traits</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Scuteri</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Genet</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="1200" to="1210" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">The Wellcome Trust Case Control Consortium Genome-wide association study of 14,000 cases of seven common diseases and 3,000 shared controls</title>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">447</biblScope>
			<biblScope unit="page" from="661" to="678" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Genetic variation in laboratory mice</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">M</forename>
				<surname>Wade</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Daly</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="1175" to="1180" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">A common variant of hmga2 is associated with adult and childhood height in the general population</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Weedon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Genet</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="1245" to="1250" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<monogr>
		<title level="m" type="main">Resampling-based Multiple Testing</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">H</forename>
				<surname>Westfall</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">S</forename>
				<surname>Young</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>Wiley</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">Simulating association studies: a data-based resampling method for candidate regions or whole genome scans</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<forename type="middle">A</forename>
				<surname>Wright</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="2581" to="2588" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">SNPHarvester: a filtering-based approach for detecting epistatic interactions in genomewide association studies</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Yang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="504" to="511" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">FastANOVA: an efficient algorithm for genome-wide association study</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of KDD</title>
		<meeting>eeding of KDD</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">COE: a general approach for efficient genome-wide two-locus epistatic test in disease association study</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of RECOMB</title>
		<meeting>eeding of RECOMB</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">FastChi: an efficient algorithm for analyzing gene-gene interactions</title>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceeding of PSB</title>
		<meeting>eeding of PSB</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">115</biblScope>
			<biblScope unit="page" from="33" to="45" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>btq186. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b29">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="226" to="217" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>