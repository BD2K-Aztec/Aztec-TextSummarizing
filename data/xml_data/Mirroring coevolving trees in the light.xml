
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:52+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Phylogenetics Mirroring co-evolving trees in the light of their topologies</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2012">2012</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Iman</forename>
								<surname>Hajirasouliha</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computing Science</orgName>
								<orgName type="institution">Simon Fraser University</orgName>
								<address>
									<postCode>V5A 1S6</postCode>
									<settlement>Burnaby</settlement>
									<region>BC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alexander</forename>
								<surname>Schönhuth</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Centrum Wiskunde &amp; Informatica (CWI)</orgName>
								<address>
									<addrLine>Science Park 123</addrLine>
									<postCode>1098 XG</postCode>
									<settlement>Amsterdam</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">David</forename>
								<surname>De Juan</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="laboratory">Structural Biology and Biocomputing Programme</orgName>
								<orgName type="institution">CNIO) Spanish National Cancer Research Centre</orgName>
								<address>
									<postCode>28029</postCode>
									<settlement>Madrid</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alfonso</forename>
								<surname>Valencia</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="laboratory">Structural Biology and Biocomputing Programme</orgName>
								<orgName type="institution">CNIO) Spanish National Cancer Research Centre</orgName>
								<address>
									<postCode>28029</postCode>
									<settlement>Madrid</settlement>
									<country key="ES">Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">S</forename>
								<forename type="middle">Cenk</forename>
								<surname>Sahinalp</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">School of Computing Science</orgName>
								<orgName type="institution">Simon Fraser University</orgName>
								<address>
									<postCode>V5A 1S6</postCode>
									<settlement>Burnaby</settlement>
									<region>BC</region>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Phylogenetics Mirroring co-evolving trees in the light of their topologies</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">28</biblScope>
							<biblScope unit="issue">9</biblScope>
							<biblScope unit="page" from="1202" to="1208"/>
							<date type="published" when="2012">2012</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/bts109</idno>
					<note type="submission">Received on October 18, 2011; revised on February 23, 2012; accepted on February 24, 2012</note>
					<note>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [12:42 9/4/2012 Bioinformatics-bts109.tex] Page: 1202 1202–1208 Advance Access publication March 6, 2012 Associate Editor: David Posada Availability: A C implementation of the method demonstrated in this article is available at</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Determining the interaction partners among protein/domain families poses hard computational problems, in particular in the presence of paralogous proteins. Available approaches aim to identify interaction partners among protein/domain families through maximizing the similarity between trimmed versions of their phylogenetic trees. Since maximization of any natural similarity score is computationally difficult, many approaches employ heuristics to evaluate the distance matrices corresponding to the tree topologies in question. In this article, we devise an efficient deterministic algorithm which directly maximizes the similarity between two leaf labeled trees with edge lengths, obtaining a score-optimal alignment of the two trees in question. Results: Our algorithm is significantly faster than those methods based on distance matrix comparison: 1 min on a single processor versus 730 h on a supercomputer. Furthermore, we outperform the current state-of-the-art exhaustive search approach in terms of precision, while incurring acceptable losses in recall.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The vast majority of cellular functions are exerted by combinations of interacting gene products. As a result, 'preservation of functionality' among proteins and other gene products typically implies 'preservation of interactions' across species. It is well established that protein–protein interactions (both physical interactions as well as co-occurence of domains) are preserved through speciation events [see Lovell and Robertson (2010);<ref type="bibr" target="#b7">Pazos and Valencia (2008)</ref>and the references therein]. A major implication of this is that the evolutionary trees behind two interacting protein families can look near-identical. As interacting proteins have a tendency to co-evolve, it may be possible to assess the potential of two or more proteins (or other gene products) being interaction partners by measuring how similarly they evolve across related species. For this purpose, a number of computational strategies have been developed. Such strategies aim to compare the phylogenetic trees of two (or more) protein or protein-domain families, where paralogs and orthologs are represented with leaves with appropriate labels and internal vertices can be interpreted as either speciation or duplication events. Among these strategies we will focus on mirrortree approaches, which explicitly or implicitly map leaves of a pair of trees (belonging to two distinct proteins or gene products) onto one another such that the leaves that are mapped to each other would be identified as potential interaction partners. Mirrortree approaches aim at an overall quantification of 'family similarity' via a measure of tree similarity. Typically, these approaches do not aim to modify the specific topology of the underlying phylogenetic trees and thus are different from tree reconciliation approaches (<ref type="bibr" target="#b5">Page, 1994;</ref><ref type="bibr" target="#b16">Vyugin et al., 2002</ref>). They are also distinct from phylogenetic profiling methods (<ref type="bibr" target="#b8">Pellegrini et al., 1999</ref>), which aim to measure the phylogenetic profiles of proteins or domains to check for potential interaction partners. The first mirrortree approach was proposed to discover protein– protein (rather than domain–domain) interactions and was based on comparing the distance matrices 1 resulting from the multiple alignment members of each protein family (<ref type="bibr" target="#b6">Pazos and Valencia, 2001</ref>). Note that one can interpret this as mapping leaves onto one another, as will be explained below. Since this study, a number of mirrortree approaches have been developed; almost all of these approaches are again based on comparing distance matrices rather than the trees directly (see the introductory paper by<ref type="bibr" target="#b6">Pazos and Valencia (2001)</ref>and Pazos and Valencia (2008) for more references). In fact, direct comparison of gene trees has been considered as '... a problem yet to be fully resolved.' (<ref type="bibr">Izarzugaza et al., 2008, p. 2)</ref>. In this article, we consider a fresh approach to the problem of predicting protein or other gene product interactions by comparing gene trees directly, without the aid of a distance matrix. Note that such a distance matrix is a byproduct of the underlying phylogenetic tree: popular multiple sequence alignment methods typically align sequences in the order imposed by their phylogenetic tree and the 'distances' in the matrix correspond to the distances in the phylogenetic tree. As a result our method should be considered as a more direct approach to mirroring trees. In the case where there are no paralogs of any gene, assessing tree similarity is both computationally straightforward and reliable (<ref type="bibr" target="#b7">Pazos and Valencia, 2008</ref>). More specifically, if there is at most one family member per species, the mapping problem reduces to</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Aligning phylogenetic trees</head><p>the problem of finding out species where the interaction is lost; after removal of such species, the topologies of the two trees will be identical, i.e. the leaf representing a particular species in one tree will correspond to the leaf representing the same species in the other tree. In the presence of paralogous genes (and thus proteins or gene products), however, the mapping problem becomes much more complex. For example, if we have n paralogs per tree for one of the species, we may need to evaluate more than n! many potential mappings (n! is the number of mappings where each paralog from one tree pairs with a paralog from the other tree. In addition, there are mappings where one has to remove non-interacting paralogs. As was pointed out in<ref type="bibr" target="#b15">Tillier et al. (2006)</ref>, protein interaction can be preserved during duplication, while interaction can be lost during speciation.). Thus, the number of potential mappings is superexponential in the number of paralogs per species, implying a significant computational challenge. There are a number of mirrortree approaches which address the presence of paralogs and aim directly at inferring the correct mapping of leaves; these approaches typically aim to 'align' the distance matrices by shuffling and eliminating the rows (and corresponding columns) so as to maximize the similarity between the matrices. The similarity between two aligned matrices is defined in the form of root mean square difference (<ref type="bibr" target="#b10">Ramani and Marcotte, 2003</ref>), correlation coefficient (<ref type="bibr" target="#b1">Gertz et al., 2003</ref>), informationtheoretic 'total interdependency' of multiple alignments (<ref type="bibr" target="#b15">Tillier et al., 2006</ref>), Student's t (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>) or the size of the largest common submatrix (<ref type="bibr" target="#b14">Tillier and Charlebois, 2009</ref>). Because an exact solution to the matrix alignment problem, where the goal is to maximize any of these notions of similarity (by determining the right mapping of rows and columns), is hard to compute, many available approaches employ heuristics based on swapping pairs of rows/columns in a greedy fashion. These methods also commonly perform column/row elimination from the 'larger' matrix only, and not the other (<ref type="bibr" target="#b1">Gertz et al., 2003;</ref><ref type="bibr" target="#b2">Izarzugaza et al., 2008;</ref><ref type="bibr" target="#b3">Jothi et al., 2005;</ref><ref type="bibr" target="#b10">Ramani and Marcotte, 2003;</ref><ref type="bibr" target="#b15">Tillier et al., 2006</ref>). We are aware of one exception by (<ref type="bibr" target="#b14">Tillier and Charlebois, 2009</ref>), which aims to determine the largest common (i.e. within a threshold) submatrix and removes the remainder of the columns and rows from both matrices. Similarly the only approach which directly compares the tree topologies themselves is by<ref type="bibr" target="#b3">Jothi et al. (2005)</ref>, which uses a Metropolis algorithm to heuristically travel 'tree automorphism' space. However, this approach cannot handle trees of different sizes. See Lovell and Robertson (2010);<ref type="bibr" target="#b7">Pazos and Valencia (2008)</ref>; and<ref type="bibr" target="#b14">Tillier and Charlebois (2009)</ref>for references on mirrortree approaches which do not necessarily relate to the mapping problem in the presence of paralogs. In this article, we present polynomial-time algorithms that determine mappings of leaves which respect the topologies of the two trees compared. As input, we are given two 'gene trees' T and T of two protein/domain families known to interact with one another. T and T have labeled leaves where labels reflect species such that the presence of the same label at two different leaves reflects the presence of paralogs. We introduce and formally define the gene tree alignment problem, which aims to delete both leaves and inner vertices from both trees until the remaining trees are isomorphic, that is, one can map the vertices of the two remaining trees in a one-to-one fashion onto another such that ancestor relationships are preserved. This in particular implies a one-to-one mapping of the remaining leaves, which we present as output. Clearly, there are many different possible choices of such one-to-one mappings of leaves—our algorithms determine the score-optimal such alignment where different deletion operations are penalized in different ways, depending on how they transform the topologies of the trees. Note that our algorithm depends on some (user-defined) cost parameters, that can be used to impose constraints on the alignment. We describe the nature of our scoring scheme in detail in the following; please see Section 3 for full details and precise notations. Note that the algorithm only outputs one uniquely determined, score-optimal alignment of subsets of leaves of T ,T. Note further that we do not perform an exhaustive search since we never consider mappings of leaves which imply mappings of internal vertices that do not preserve ancestor relationships of the gene trees T ,T and thereby contradicts their topologies. Our method can be viewed as an extension of tree-edit distance approaches. Alternative constraints leading to polynomial time solvable variants on the tree edit distance is surveyed in Zhang (1996). For further, more recent work see also<ref type="bibr" target="#b9">Pinter et al. (2008)</ref>that address the subtree homeomorphism problem, which, given a 'text' tree T and a 'pattern tree' P as the input, asks to find a subtree t in T such that P is homeomorphic to t. Now, two trees T 1 ,T 2 are said to be homemorphic if one can remove degree 2 vertices from T 1 ,T 2 such that T 1 and T 2 are isomorphic. Another recent work (<ref type="bibr" target="#b11">Raynal et al., 2010</ref>) considers homeomorphic alignment of 'weighted' but unlabeled trees. Here the goal is to obtain a homeomorphic mapping between vertices of two trees such that the differences between the weights of 'aligned' edges is minimized. While being related to our approach, the method described in<ref type="bibr" target="#b11">Raynal et al. (2010)</ref>is not applicable to our problem as the trees they consider are not leaf labeled. We refer the reader to<ref type="bibr" target="#b0">Bille (2003)</ref>for a general and gentle overview of further related work on tree edit distance, tree alignment and tree inclusion. The main technical contribution of this article is a novel deterministic mirrortree algorithm that directly compares tree topologies. The algorithm is optimal within the constraints we impose and is provably efficient. We compare our algorithm with the most recent, state-of-the-art heuristic search approach (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>) that aims to maximize the similarity between distance matrices, where distances reflect lengths of shortest paths in neighbor-joining trees. In our comparisons, we use precisely the same trees to be able to juxtapose a distance matrix-based heuristic search method to our topology-based, deterministic method without introducing further biases.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES AND NOTATIONS</head><p>Let T = (V ,E,w) be a tree with weighted edges as given by a nonnegative weight function w : E → R +. We denote the leaves of T by L ={ 1 ,..., n }, the internal nodes of T (excluding the root) by U ={u 1 ,...,u m } and the root of T by r. In particular, let n be the number of leaves and m be the number of internal vertices without the root. Note that a tree T is binary and rooted if and only if deg(r) = 2 and deg(u) = 3 for all internal vertices u ∈ U; this will imply that m = n−2 and |E|=2n−2. In our setting, edge weights w(v i ,v j ) reflect the evolutionary distance between adjacent vertices v i ,v j. Note that leaves refer to gene products whereas internal vertices can be interpreted as speciation and/or duplication events. For a given vertex v ∈ V , we define θ(v) as the evolutionary distance</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I.Hajirasouliha et al.</head><p>between the root and v. In other words, θ(v) is the sum of the edge weights in the unique path from the root to v. In rooted trees, there is a natural partial order v i ≤ v j ⇔ v i is an ancestor of v j</p><formula>(1)</formula><p>on the vertices of T. Hence, the edges have a natural orientation and each vertex v i induces a unique subtree T (v i ). This partial order is crucial for our algorithm—which cannot be applied to unrooted trees in a straightforward manner. For processing unrooted (e.g. neighborjoining) trees, consider the pair of proteins/domains (one from each tree) which are known to interact. We root the two trees at these vertices in order to apply our algorithm. Provided such a pair exists (which is typically the case), our algorithm optimally aligns the trees as it does not assume any order among the many sibling vertices. In a tree T which is rooted at r, we call vertex u the parent of a vertex v if u and v are connected by an edge and u is closer to r than v. The height of a rooted tree is defined as max{d(r,, i ) | i = 1,...,n} where d(v 1 ,v 2 ) is the length of the shortest path between vertices v 1 and v 2 without considering edge weights, that is the maximum (unweighted) distance of the root to a leaf. We denote a bijection (i.e. a one-to-one and onto alignment) of subsets of vertices of T ,T by M<ref type="bibr">[T ,T ]</ref>and write</p><formula>M := {(v,w) ∈ T ×T | M(v) = w} (2)</formula><p>for the pairs of mapped vertices. Note that in such a bijection, not all vertices of T are necessarily mapped to a vertex in T and vice versa. We refer to vertices which are not mapped as deleted by M<ref type="bibr">[T ,T ]</ref>. We only consider alignments which satisfy the following: (i) the alignment preserves the ancestor relationship of T and T ; (ii) only leaves with identical labels are mapped onto one another; and (iii) upon deletion of vertices, where deletion of an internal vertex v leads to new edges joining the parent of v with the children of v, the two tree topologies are isomorphic. Among the alignments satisfying the above conditions, we compute the alignment that has maximum score. For a formal definition of our scoring scheme, consider the internal vertices of T and T that are deleted. Among them, we distinguish between vertices v that have descendants x which are not deleted. We write N I for such vertices. We write N T for the remaining deleted vertices. Note that each vertex v ∈ N T makes part of a subtree of T which has been deleted as a whole. The score of the alignment is then defined as</p><formula>S(M[T ,T ]) = (v,v )∈M S M (v,v )+ v∈N I S N I (v)+ v∈N T S N T (v). (3)</formula><p>The individual score functions S M ,S N I and S N T will be formally defined in Section 3. As noted above, our algorithm, which maximizes the overall score of the alignment, can be viewed as an extension of the standard tree edit distance algorithm for unweighted trees (<ref type="bibr" target="#b12">Tai, 1979</ref>), to those with edge weights. Determining the tree edit distance is NP-complete (<ref type="bibr" target="#b19">Zhang et al., 1992</ref>) [in fact MAXSNP-hard (<ref type="bibr" target="#b18">Zhang and Jiang, 1994)]</ref>. Since the instances treated here are too large (trees have up to &gt;200 leaves) we have to impose reasonable constraints when aiming at fast, polynomial-runtime solutions. Motivated by test runs (see numbers referring to C 1,2 in Sections 4 and 5), we chose to impose the additional constraint</p><formula>),(a 2 ,b 4 ),(a 3 ,b 2 )</formula><p>and (a 4 ,b 1 ). that a vertex u and its parent v cannot be deleted at the same time without deleting the entire subtree rooted at v. That is we disallow to have both a parent v and a child u in N I. Note, however, that deletion of two internal siblings is permissible—we found that such deletions can lead to favorable alignments. As the operation of deleting entire subtrees does not lead to runtime issues, does not perturb the topology of the remaining trees and also reflects the biologically reasonable assumption that interaction can be lost for entire subtrees, we allow it without additional restrictions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">METHODS</head><p>Given two rooted weighted-edge trees T and T , our algorithm aligns the trees by mapping a subset of leaves of T to a subset of leaves of T. In order to obtain this mapping, a series of (i) individual vertex deletions or (ii) subtree deletions (with specific penalties) are performed on each tree with the goal of obtaining two isomorphic trees<ref type="figure" target="#fig_1">Figure 1</ref>shows two such rooted trees that are isomorphic; it also shows a mapping between the leaves. The specifics of vertex and subtree deletions on a tree T = (V ,E,w) are as follows.</p><formula>T 1 = (V 1 ,E 1 ,w 1 ) (from T ) and T 1 = (V 1 ,E 1 ,w 1 ) (from T 1 );</formula><p>(1) Deleting an internal vertex v also deletes the edge (u,v), where u is the parent of v. Furthermore, it connects each child x of v to u by deleting the edge (v,x) and creating a new edge (u,x). The weight of this new edge, w(u,x) is set to w(u,v)+w(v,x). As mentioned earlier, it is not possible to delete both a node v and its parent u from T .</p><p>(2) Deleting an entire subtree rooted at an internal vertex v deletes all descendants of v and their associated edges.</p><p>In the remainder of this section, we will discuss the costs of the above deletion operations and the scores of the mapped vertices. As mentioned earlier, the overall score of the mapping will be the sum of the scores of the mapped vertices and the scores (negative costs) of the the deletion operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Scoring scheme</head><p>Let T 1 and T 1 be the isomorphic trees which result from performing a series of deletion operations on T and T. The isomorphism : T 1 → T 1 implies an alignment M<ref type="bibr">[T ,T ]</ref>between the original trees T ,T. Let L 1 ,L 1 denote the sets of leaves that are mapped in T and T , respectively; because the mapping is a bijection, we must have |L 1 |=|L 1 |. We write SP :<ref type="bibr">,T ]</ref>for the set of mapped pairs (we require that mapped leaves have identical labels hence the naming SP for 'species'). Recall that a mapping of two trees may involve deleting internal vertices or entire subtrees. We now distinguish between two types of internal vertex deletions.</p><formula>= {(l,l ) | l ∈ L,l ∈ L ,(l,l ) ∈ M}⊂M[T</formula><p>(1)<ref type="bibr">[Isolated Deletion:]</ref>deletion of only one child v of a vertex u. Let further x 1 ,x 2 be the two children of v. Isolated deletion of v also</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Aligning phylogenetic trees</head><p>implies to also delete edges (u,v),(v,x 1 ),(v,x 2 ) and create new edges (u,x 1 ),(u,x 2 ). Note that after deletion v has three children.</p><p>(2)<ref type="bibr">[Parallel Deletion:]</ref>deletion of both children (say x and y) of a vertex v. This implies deletion and creation of edges in a fashion analogous to that for isolated deletion. Note that after deletion v has four children. Accordingly, we further distinguish between isolated deleted vertices N I,iso and vertices which became deleted in parallel N I,par such that N I = N I,iso ˙ ∪ N I,par. The idea behind distinguishing between isolated and parallel deletion is that parallel deletion reflects greater perturbation of tree topology at the same evolutionary point in time, and is less likely to occur. For a given</p><formula>mapping M[T ,T ] let E S (M) := {(u,v) | v ∈ N I</formula><p>,iso } be the set of edges which join isolated deleted vertices with their parents. Analogously, E P (M) is the set of edges that join deleted siblings with their parent. See<ref type="figure">Figure 2</ref>for examples of isolated and parallel deletions. Given a pair of mapped leaves˜1leaves˜ leaves˜1 , ˜ 2 ∈ SP their alignment score,</p><formula>κ( ˜ 1 , ˜ 2 ) is defined as κ( ˜ 1 , ˜ 2 ) = C −|θ( ˜ 1 )−θ( ˜ 2 )|</formula><p>where C is a positive constant, providing a positive contribution to the overall score because of the mapping of two leaves with the same label while we subtract the difference between the distances of˜1of˜ of˜1 and˜2and˜ and˜2 from the root for penalizing the mapping between two leaves which have topologic differences. The total score S of an alignment M<ref type="bibr">[T ,T ]</ref>as per the above definition is fully specified by</p><formula>S(M[T ,T ]) = (˜ 1 ,˜ 2 )∈SP κ( ˜ 1 , ˜ 2 ) − es∈E iso (M) E ·w(e s )− ep∈Epar (M) F ·w(e p )</formula><formula>(4)</formula><p>where, with respect to the formulation in (3), the term in the first row is for v,v ∈M S M (v,v ), the second row is for</p><formula>v∈N I S N I (v) and</formula><p>v∈N T S N T (v) is zero. E and F are user-defined constants that, respectively, penalize isolated deletion and parallel deletion of edges. Note that this penalty is proportional to the length of the edges joining the deleted vertices with their parents— deletion of longer edges leads to a more severe perturbation of topology hence is more severely penalized. We set the cost of deleting a subtree (i.e. S N T ) to 0. Note, however, deleting subtrees is implicitly penalized by disregarding any potential good mappings of leaves in them. Given the above score function, the gene tree alignment problem can be formally stated as follows.</p><p>Gene tree alignment problem. Given two rooted weighted-edge trees T ,T , determine subsets of leaves L 1 ⊂ L,L 1 ⊂ L of equal size such that the corresponding subtrees can be transformed by isolated and parallel deletion and subtree removal operations into trees T 1 ,T 1 , for which there is an isomorphism : T 1 → T 1 that maximizes S(M<ref type="bibr">[T ,T ]</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">A dynamic programming solution</head><p>The gene tree alignment problem can be efficiently solved by a dynamic programming algorithm. Our algorithm runs in O(|V |·|V |) time for two binary, rooted trees T ,T with vertex sets V ,V. In general, our strategy can be applied to arbitrary rooted trees with bounded maximum degree, max. Note that by allowing to delete internal vertices (i.e. contract the edges), the number of children of an internal vertex will be still bounded by a constant (≤4).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Initialization.</head><p>As a first step, we remove all leaves that refer to species that are unique to each tree. Let n =|V | and n =|V |. For every pair of vertices v i ∈ V and v j ∈ V (i.e. for every i = 1,...,n and j = 1,...,n ), we compute the maximum alignment score for the subtrees rooted at v i from T [i.e. T (v i )]</p><p>(a)</p><formula>(c)</formula><p>(b)<ref type="figure">Fig. 2</ref>. A gene tree (a), with an isolated node deletion, A 5 (b) and a parallel deletion of the nodes, A 5 and A 6 (c). and v j from T [i.e. T (v j )]. We denote the maximum alignment score for T (v i ) and T (v j ) by S ij. Note that the computation of the maximum alignment score between rooted subtrees induce a mapping between their leaves. In our dynamic programming algorithm, we handle the 'base' cases, where one (or both) of T (v i ) or T (v j ) have three or fewer leaves, as follows. @BULLET If both v i ∈ V and v j ∈ V are leaves, then by definition, S ij = κ(v i ,v j ). @BULLET Without loss of generality, if v i is a leaf and v j is an internal vertex, S ij = max(S ij 1 ,S ij 2 ), where j 1 and j 2 correspond to the children of v j. @BULLET The remainder of the base cases have both v i and v j as internal vertices and are solved through exhaustive evaluation of all possible alignments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Recursion. Internal vertices</head><p>, each with at least four descendants, S ij will be computed through recurrence equations. These equations are based on the alignment scores between subtrees rooted at the children (or grandchildren) of v i and v j. Let i 1 (j 1 ) and i 2 (j 2 ) be the children of the vertex v i (v j ). Also, let i 11 , i 12 be the children of i 1 , and i 21 , i 22 be the children of i 2. Similarly, let j 11 , j 12 be the children of j 1 , and j 21 , j 22 be the children of j 2. We first give a high-level description of the recurrence equation. Suppose that the maximum alignment score between any subtree in T (v i ) and any subtree in T (v j ) has already been computed. In order to compute the alignment score S ij , we consider several cases: we can either delete one or both subtrees rooted at the children of v i and v j (deleting an entire subtree) or align the subtrees rooted at the children of v i and v j to each other. We can also delete one of the children of v i (either i 1 or i 2 ) together with one of the children of v j (either j 1 or j 2 ) and align the three resulting subtrees in T (v i ) to a permutation 2 of the ones in T (v j ). Finally, we have to consider the case where both children of the root [i.e.</p><formula>i 1 and i 2 in T (v i ), and j 1 and j 2 in T (v j )]</formula><p>are deleted. In this case, we align four subtrees in T (v i ) (rooted at i 11 ,i 12 ,i 21 , i 22 ) to a permutation of the four resulting subtrees in T (v j ). The optimal alignment score of S ij will thus be the maximum alignment score provided by all of the cases above. Let e(v) denote the penalty for isolated deletion of an internal vertex v, which is the product of the constant E and the weight of the edge between v and its parent (see Section 3.1). Also, let f (v) denote the penalty for parallel deletion of both children of an internal vertex v. f (v) was defined as a constant</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I.Hajirasouliha et al.</head><p>F times the total weight of the edges that connect v to its children. The recurrence equation for S ij thus becomes the following</p><formula>S ij = max ⎧ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎪ ⎩</formula><p>0 (deleting both subtrees from each tree)</p><formula>S i 1 j 1 +S i 2 j 2 S i 1 j 2 +S i 2 j 1 regular cases ⎧ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎩ S ij 1 S ij 2 S i 1 j S i 2 j ⎫ ⎪ ⎪ ⎪ ⎪ ⎬ ⎪ ⎪ ⎪ ⎪ ⎭ deleting one subtree from each tree max ⎧ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎩ S i 11 j 2 +S i 12 j 11 +S i 2 j 12 S i 11 j 2 +S i 12 j 12 +S i 2 j 11 S i 12 j 2 +S i 11 j 11 +S i 2 j 12 S i 12 j 2 +S i 11 j 12 +S i 2 j 11 ⎫ ⎪ ⎪ ⎪ ⎪ ⎬ ⎪ ⎪ ⎪ ⎪ ⎭ −e(i 1 )−e(j 1 ) max ⎧ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎩ S i 21 j 2 +S i 22 j 11 +S i 1 j 12 S i 21 j 2 +S i 22 j 12 +S i 1 j 11 Si 22 j 2 +S i 21 j 11 +S i 1 j 12 S i 22 j 2 +S i 21 j 12 +S i 1 j 11 ⎫ ⎪ ⎪ ⎪ ⎪ ⎬ ⎪ ⎪ ⎪ ⎪ ⎭ −e(i 2 )−e(j 1 ) max ⎧ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎩ S i 21 j 1 +S i 22 j 21 +S i 1 j 22 S i 21 j 1 +S i 22 j 22 +S i 1 j 21 S i 22 j 1 +S i 21 j 21 +S i 1 j 22 S i 22 j 1 +S i 21 j 22 +S i 1 j 21 ⎫ ⎪ ⎪ ⎪ ⎪ ⎬ ⎪ ⎪ ⎪ ⎪ ⎭ −e(i 2 )−e(j 2 ) max ⎧ ⎪ ⎪ ⎪ ⎪ ⎨ ⎪ ⎪ ⎪ ⎪ ⎩ S i 11 j 1 +S i 12 j 21 +S i 2 j 22 S i 11 j 1 +S i 12 j 22 +S i 2 j 21 S i 12 j 1 +S i 11 j 21 +S i 2 j 22 S i 12 j 1 +S i 11 j 22 +S i 2 j 21 ⎫ ⎪ ⎪ ⎪ ⎪ ⎬ ⎪ ⎪ ⎪ ⎪ ⎭ −e(i 1 )−e(j 2 ) S i 11 π 1 +S i 12 π 2 +S i 21 π 3 +S i 22 π 4 −f (v i )−f (v j )</formula><formula>(5)</formula><p>where the permutation π = π 1 π 2 π 3 π 4 ranges over all permutations of {j 11 ,j 12 ,j 21 ,j 22 }. Note that some cases are redundant but are still represented here for the sake of clarity. In case that several options yield the same, optimal score, the algorithm picks the first observed one. Now, given r and r , the roots of T and T , respectively, the alignment score S r 1 r 2 (i.e. the maximum alignment score of the rooted trees) can be computed using the above recurrence equation, providing a solution to the gene tree alignment problem. It is quite straightforward to prove that our algorithm correctly computes the maximum alignment score through a (strong) induction on the sum of the heights of the rooted trees. Note that the scores of internal vertex alignments can be computed through the scores of the alignments between their (grand)children and the recurrence precisely serves to satisfy the constraints. The base of the induction is trivial. If the minimum height of the trees is zero (i.e. one of the trees is just a single leaf), the optimal value of the alignment can be found using the definitions and simple case analysis. Given the subtrees T (v i ) and T (v j ), with heights h and h , respectively, we assume the induction hypothesis, that for all pairs of subtrees T (v p ) and T (v q ) with heights h p and h q such that h p +h q &lt; h+h. It is easy to verify by case analysis that all cases in the recurrence equation will be reduced to a case in which the sum of the heights of the aligned (grand) children will be less.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Evaluation criteria. We</head><p>determine the maximum number of members of the two protein domain families under consideration that can be paired by following (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>): for each species we determine the paralogous members of the domain in the two trees that can be paired with one another (that is both members reside in the same protein) and determine the maximum number of pairs that can result from the respective potential pairings. Summing up these numbers yields the maximal size of a correct mapping. By the usual conventions, we denote this value as P. In other words, P is the size of the correct pairing. Among the P many potential correct pairs, we determine the ones which were inferred by the algorithm in use and refer to them as 'true positives', TP. Similarly, the number of<ref type="bibr">[MatrixHeuristic, (Izarzugaza et al., 2008)]</ref>and the deterministic, treetopology-based approach (TreeTopology = C opt ). Baseline is determined as randomly pairing as many protein domain family members as possible. Runtimes for MatrixHeuristic and TreeTopology are 730 h and 1 min, respectively.domain pairs computed, where the respective members are not from the same protein, is referred to as 'false positives', FP. Recall (Sensitivity) is defined as Rec=TP/P and Precision (positive prediction rate) is defined as Prec=TP/(TP+FP). Note that Recall is referred to as accuracy in (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>). We determine Precision and Recall for each pair of trees individually. Values displayed in<ref type="figure" target="#fig_3">Figure 3</ref>,<ref type="figure" target="#tab_1">Table 1</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data source and alternative methods.</head><p>We benchmarked our algorithm against the most recent heuristic search method (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>) for determining a mapping in the presence of paralogs on the large-scale data corpus described in the same study. This data set contains multiple alignments for 604 yeast protein domains among which 488 domain pairs are known to co-occur in the same protein. Those 488 domain family pairs are considered to be a particularly tough test (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>) due to the presence of ∼6 paralogs per species on average. For all interacting domain family pairs, neighbor-joining trees were computed, using ClustalW (<ref type="bibr" target="#b13">Thompson et al., 1994</ref>) and the trees were rooted at the domains which are known to interact. Tree constraints. In order to appropriately assess the contribution of the different tree constraints as outlined in Section 3, we evaluated our algorithm by not allowing to delete internal nodes (C 0 ), allowing isolated node deletion (C 1 ) as well as further allowing parallel deletion of two sibling nodes (C 1,2 ), see<ref type="figure">Figure 2c</ref>allow deletion of subtrees as a whole without penalty. The specific scores for these cases are as follows:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Aligning phylogenetic trees</head><formula>C 0 : C = 1,E =∞,F =∞, C 1 : C = 1,E = 0,F =∞ and C 1,2 : C = 1,E = F = 0.</formula><p>Among the cases above C 1,2 gives the best results (see<ref type="figure" target="#tab_1">Table  1</ref>and further comments below), implying that parallel deletions are beneficial. We experimented with several values of E and F, and noticed that it may be beneficial to impose a large penalty for parallel deletions in contrast to a relatively small penalty for isolated deletions. We concluded that an optimal choice of parameters would be E = 2,F = 50 (referred to as C Opt ), when C = 1. Note that the exact value of C is the function of neighbor-joining trees resulting from ClustalW multiple alignments alone—for different settings absolute values need to be put into perspective with orders of magnitude of edge weights of the trees under consideration. As outlined in Section 3, inducing tree constraints considerably reduces the search space, thereby allowing for an efficient and deterministic method. Given a pair of trees, let CP (constraint positives) denote the maximum number of correctly paired domains over all possible alignments of the trees. Note that one can compute, CP for any given pair of trees, by running our algorithm with a scoring scheme which assigns 1 to correctly paired domains and not penalizing any operation which the constraints allow us to do. 3 We compute RP = CP/P (relative positives) as the fraction of pairings that can still be inferred, and which measures the reduction of search space size due to imposing constraints. We further compute RelRec = TP/CP (Relative Recall) as a recall value which reflects how many of the correct pairings possible were inferred by the algorithm in question. The good RelRec values the tree topology approach achieves (0.59 versus 0.55 for the matrix-based approach, note that for the matrix-based approach this coincides with Recall since it does not impose any constraints), indicate that losses in Recall are due to imposing constraints, but not necessarily due to the scoring scheme.<ref type="figure" target="#fig_3">Figure 3</ref>presents numbers of all 488 tree pairs for a canonical baseline procedure, which randomly pairs as many domain family members per species as possible, the heuristic matrix-based approach (MatrixHeuristic) and the deterministic tree-topologybased approach (TreeTopology = C opt ).<ref type="figure" target="#tab_1">Table 1</ref>furthermore presents numbers resulting from usage of different tree constraints. Following (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>), we also separate tree pairs according to the numbers of leaves of the larger tree and the product of the numbers of leaves of the two paired trees which, according to (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>), quantifies search space size. See<ref type="figure" target="#fig_5">Figure  4</ref>for the respective results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>Runtime. The possibly most striking advantage of our topologybased approach is the drastic reduction of runtime—we can compute mappings for the 488 interacting domain families in roughly 1 min on a single CPU—in comparison to 730 h on MareNostrum 4 needed for the Metropolis search performed by (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>). Note that there are rapidly growing large-scale phylogenetic databases such as ENSEMBL (http:// ensembl.org) or PhylomeDB (http://phylomedb.org), whose growth is further accelerated by next-generation sequencing projects (as of 12th August, 2011, PhylomeDB contains 482274 phylogenetic trees). The reduction in runtime delivered by our approach certainly overcomes a major obstacle—we render largescale mapping and, as a consequence, comparison of paralog-rich gene trees feasible. Note that this reduction has become possible by imposing both computationally and biologically reasonable constraints on the search space while at the same time allowing for an efficient scheme to find the global optimum within these constraints. Search space size/recall. Comparing C Opt with the method of (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>) (heuristic) overall, clearly,<ref type="bibr" target="#b2">Izarzugaza et al. (2008)</ref>achieve best recall. As pointed out above, this comes as no surprise since we cannot explore pairings that contradict the topologies of the paired trees. Quite surprisingly though, although usage of tree topology and neighbor-joining trees in particular have been discussed rather controversially (<ref type="bibr" target="#b17">Waddell et al., 2007</ref>), we find that still the majority of pairings (54.6% with the strictest constraints and 61.2% for allowing isolated and parallel deletion) can be determined by a topology-based approach. These numbers may put usage of neighbor-joining tree topology in mirrortree approaches into a general perspective. Moreover, note that the fraction of correct domain pairs computed by our method over that of the heuristic search method is ∼0.7 (= TP(C opt )/TP(heuristic) = Recall(C opt )/Recall(heuristic) =</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I.Hajirasouliha et al.</head><p>of Precision than (<ref type="bibr" target="#b2">Izarzugaza et al., 2008</ref>), see Precision in<ref type="figure" target="#fig_3">Figure 3</ref>. See also<ref type="figure" target="#fig_5">Figure 4</ref>for a comparison with respect to search space sizerelated differences. While<ref type="bibr" target="#b2">Izarzugaza et al. (2008)</ref>achieve excellent values on pairs of smaller trees, we outperform their approach on larger trees, with the most obvious differences on pairs of trees where the product of the numbers of leaves is large.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conclusion.</head><p>In summary, we have, for the first time, devised a deterministic and efficient, polynomial-runtime mirrortree approach which directly compares the gene trees, and not the distance matrices behind or giving rise to them. We have juxtaposed our approach with the most recent, state-of-the-art matrix-based heuristic search procedure without introducing further experimental biases. Most importantly, our tree topology-based algorithm lists efficiency as its decisive benefit. While recall is better for the heuristic search obviously due to that it does not impose any constraints on the search space, we only incur relatively mild losses. We achieve better results in precision, in particular when both of the mirrored trees are large. This leads us to the overall conclusion that the heuristic method remains the better choice for smaller trees and when runtime is not an issue. In case of larger trees and in particular for large-scale studies, our approach has considerable benefits. Note finally that we have been comparing neighbor-joining trees which have been repeatedly exposed as suboptimal choices of phylogenetic trees. We believe that our approach can gain from improvements in tree quality significantly more than the matrix-based approaches. Note finally that mapping domains can lead to ambiguous results due to that several homologous copies can co-occur in one protein. To resolve such issues is interesting future work.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [12:42 9/4/2012 Bioinformatics-bts109.tex] Page: 1204 1202–1208</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.1.</head><figDesc>Fig. 1. Two isomorphic trees are shown as an example in this figure. The leaves of the left tree are labeled with a 1 ,a 2 ,a 3 and a 4 whereas the leaves of the tree on the right are labeled with b 1 ,b 2 ,b 3 and b 4. A possible mapping between the leaves that respect the tree topology is (a 1 ,b 3 ),(a 2 ,b 4 ),(a 3 ,b 2 ) and (a 4 ,b 1 ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [12:42 9/4/2012 Bioinformatics-bts109.tex] Page: 1206 1202–1208</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. Recall and Precision for the heuristic matrix-based approach [MatrixHeuristic, (Izarzugaza et al., 2008)] and the deterministic, treetopology-based approach (TreeTopology = C opt ). Baseline is determined as randomly pairing as many protein domain family members as possible. Runtimes for MatrixHeuristic and TreeTopology are 730 h and 1 min, respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>and Figure 4 (see Section 4) are average values for all 488 co-evolving tree pairs respectively for all tree pairs satisfying the respective criteria.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.4.</head><figDesc>Fig. 4. The comparison of our method with the heuristic search method reveals favorable results for large trees (bottom row), x-axis indicates the size (number of leaves) of the larger tree of the two trees paired and in particular for large search spaces, that is for Space ≥11 680 where Space is the product of the number of leaves of the two trees paired.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><figDesc>) which is more than what was to be expected by reduction of the search space (CP(C opt )/CP(heuristic) = CP(C opt )/P(heuristic) = RP(C opt ) = 0.61) which points out that we compensate search space reduction by a more effective search strategy. This becomes reflected by the better RelRec values of C opt. Precision. Precision favors the topology-based approach, at least on larger (combinations of) trees (see figure 4 and table 1). Better precision reflects a larger fraction of the correct domain pairs among the pairs inferred overall. We achieve slightly better values in terms Copyedited by: TRJ MANUSCRIPT CATEGORY: ORIGINAL PAPER [12:42 9/4/2012 Bioinformatics-bts109.tex] Page: 1208 1202–1208</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><figDesc>Funding: I.H. was supported by an Natural Sciences and Engineering Research Council of Canada (NSERC) Alexander Graham Bell Canada Graduate Scholarships. A.S. was supported by a postdoctoral fellowship of the Pacific Institute of Mathematical Sciences. S.C.S. receives funds from the NSERC and Bioinformatics for Combating Infectious Diseases. Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 1. Evaluation of different schoring schemes. C Opt is 'TreeTopology' in the other figures.</figDesc><table>Method 
RP 
Recall 
RelRec 
Precis 

C 0 
0.546 
0.330 
0.557 
0.447 
C 1 
0.610 
0.378 
0.586 
0.475 
C {1,2} 
0.612 
0.377 
0.581 
0.471 
C ser 
0.638 
0.373 
0.556 
0.444 
C Opt 
0.612 
0.380 
0.588 
0.479 

</table></figure>

			<note place="foot" n="1"> The distance matrix of a gene tree is comprised of entries (i,j) which represent the distance between leaves i and j.</note>

			<note place="foot">© The Author 2012. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="2"> We have to consider all the permutations because the trees are unordered (i.e. the order of siblings of an internal vertex is unimportant).</note>

			<note place="foot" n="3"> This scoring scheme assumes knowledge we are not allowed to use in the algorithm; we use this knowledge for the purpose of evaluation here.</note>

			<note place="foot" n="4"> MareNostrum is a supercomputer of the Barcelona Supercomputing Center, one of the largest machines in the world dedicated to science (Izarzugaza et al., 2008, p. 10).</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<monogr>
		<title level="m" type="main">Tree edit distance, alignment and inclusion</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Bille</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Inferring protein interactions from phylogenetic distance matrices</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Gertz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="2039" to="2045" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Enhancing the prediction of protein pairings between interacting families using orthology information</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Izarzugaza</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">35</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Predicting protein-protein interaction by searching evolutionary tree automorphism space</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Jothi</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="241" to="250" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Suppl. . 1</note>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">An integrated view of molecular co-evolution in protein-protein interactions</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Lovell</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Robertson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2567" to="2575" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Maps between trees and cladistic analysis of historical associations among genes, organisms, and areas</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Page</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Syst. Biol</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="58" to="77" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Similarity of phylogenetic trees as indicator of proteinprotein interaction</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Pazos</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Valencia</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Protein Eng</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="609" to="614" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Protein co-evolution, co-adaptation and interactions</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Pazos</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Valencia</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">EMBO J</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2648" to="2655" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Assigning protein functions by comparative genome analysis: protein phylogenetic profiles</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pellegrini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="1999" />
			<biblScope unit="page" from="4285" to="4288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Approximate labelled subtree homeomorphism</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Pinter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discr. Algor</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="480" to="496" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Exploiting the co-evolution of interacting proteins to discover interaction specificity</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Ramani</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Marcotte</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">327</biblScope>
			<biblScope unit="page" from="273" to="284" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Homeomorphic alignment of weighted trees</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Raynal</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Pattern Recogn</title>
		<imprint>
			<biblScope unit="volume">43</biblScope>
			<biblScope unit="page" from="2937" to="2949" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">The tree-to-tree correction problem</title>
		<author>
			<persName>
				<forename type="first">K.-C</forename>
				<surname>Tai</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="422" to="433" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Clustal w: improving the sensitivity of progressive multiple sequence alignments through sequence weighting, position specific gap penalties and weight matrix choice</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Thompson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="4673" to="4680" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">The human protein coevolution network</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Tillier</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Charlebois</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1861" to="1871" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Codep: maximizing co-evolutionary interdependencies to discover interacting proteins</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Tillier</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Prot. Struc. Func. Bioinform</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="822" to="831" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Tree conciliation: reconstruction of species phylogeny by phylogenetic gene trees</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Vyugin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="650" to="658" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Phylogenetic methodology for detecting protein interactions</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Waddell</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mol. Biol. Evol</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="650" to="659" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Some MAX-SNP-hard results concerning unordered labeled trees</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="page" from="249" to="254" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">On the editing distance between unordered labeled trees</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="133" to="139" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">A constrained edit distance between unordered labeled trees</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="205" to="222" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>