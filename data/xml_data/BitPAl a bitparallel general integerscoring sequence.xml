
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:52+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sequence analysis BitPAl: a bit-parallel, general integer-scoring sequence alignment algorithm</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">. 22 2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Joshua</forename>
								<surname>Loving</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratory for Biocomputing and Informatics</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Graduate Program in Bioinformatics</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yozen</forename>
								<surname>Hernandez</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratory for Biocomputing and Informatics</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Graduate Program in Bioinformatics</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Gary</forename>
								<surname>Benson</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Laboratory for Biocomputing and Informatics</orgName>
							</affiliation>
							<affiliation key="aff1">
								<orgName type="department">Graduate Program in Bioinformatics</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Boston University</orgName>
								<address>
									<postCode>02215</postCode>
									<settlement>Boston</settlement>
									<region>MA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">John</forename>
								<surname>Hancock</surname>
							</persName>
						</author>
						<title level="a" type="main">Sequence analysis BitPAl: a bit-parallel, general integer-scoring sequence alignment algorithm</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="page" from="3166" to="3173"/>
							<date type="published" when="2014">. 22 2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu507</idno>
					<note type="submission">Received on February 27, 2014; revised on July 18, 2014; accepted on July 21, 2014</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Associate Editor: Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Mapping of high-throughput sequencing data and other bulk sequence comparison applications have motivated a search for high-efficiency sequence alignment algorithms. The bit-parallel approach represents individual cells in an alignment scoring matrix as bits in computer words and emulates the calculation of scores by a series of logic operations composed of AND, OR, XOR, complement, shift and addition. Bit-parallelism has been successfully applied to the longest common subsequence (LCS) and edit-distance problems, producing fast algorithms in practice. Results: We have developed BitPAl, a bit-parallel algorithm for general , integer-scoring global alignment. Integer-scoring schemes assign integer weights for match, mismatch and insertion/deletion. The BitPAl method uses structural properties in the relationship between adjacent scores in the scoring matrix to construct classes of efficient algorithms , each designed for a particular set of weights. In timed tests, we show that BitPAl runs 7–25 times faster than a standard iterative algorithm. Availability and implementation: Source code is freely available for download at http://lobstah.bu.edu/BitPAl/BitPAl.html. BitPAl is implemented in C and runs on all major operating systems.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Sequence alignment algorithms are critical tools in the analysis of biological sequence data including DNA, RNA and protein sequences. The demands placed on computational resources by high-throughput experiments require new, more efficient methodologies. While the standard algorithms of Smith and<ref type="bibr" target="#b14">Waterman (1981)</ref>and Needleman and<ref type="bibr" target="#b13">Wunch (1970)</ref>calculate the score in each cell of the alignment scoring matrix sequentially, a newer technique called bit-parallelism partially overcomes score dependencies so that scores can be calculated in parallel to achieve much higher efficiencies. Bit-parallel algorithms have been developed for exact and approximate string matching problems. Early examples include the algorithms of Baeza-Yates and<ref type="bibr" target="#b1">Gonnet (1992)</ref>, which finds exact matches to a simple string pattern, and<ref type="bibr" target="#b15">Wu and Manber (1992)</ref>, which finds approximate matches to a string pattern or a regular expression, where the number of differences between the pattern and the text is at most k (counting single character substitutions and single character insertions and deletions or indels). The latter is implemented as the Unix command agrep. Additional k-differences examples include (<ref type="bibr" target="#b16">Wu et al., 1996</ref>), which finds matches to 'limited expressions', i.e. regular expressions without Kleene closure, (<ref type="bibr" target="#b11">Myers, 1999</ref>), which finds matches to simple string patterns and emulates the dynamic programming solution used in alignment, and (<ref type="bibr" target="#b12">Navarro, 2004</ref>), which allows arbitrary integer weights for substitution of each pair of characters, insertion of each character and deletion of each character, and finds occurrences of regular expressions where the sum of the edit weights is at most k. In most k-differences algorithms, the complexity (and computing time) increases with increasing k. Bit-parallel methods have been successfully applied to the longest common subsequence (LCS) problem (<ref type="bibr" target="#b0">Allison and Dix, 1986;</ref><ref type="bibr" target="#b4">Crochemore et al., 2001;</ref><ref type="bibr" target="#b6">Hyyr€ o, 2004</ref>), and to unit-cost edit-distance (Hyyr€ o and<ref type="bibr" target="#b7">Navarro, 2005;</ref><ref type="bibr" target="#b7">Hyyr € o et al., 2005</ref>) by modifications of Myers's method (1999). These algorithms compute the alignment score, de-linking that computation from the traceback, which produces the final alignment. In the LCS scoring matrix, scores are monotonically non-decreasing in the rows and columns, and bit-parallel implementations use bits to represent the cells where an increase occurs. In edit-distance scoring, adjacent scores can differ by at most one, and the binary representation stores the locations of (two of the three) possible differences, +1, –1 and zero. These algorithms are ad hoc in their approach, relying on specific properties of the underlying problems, making it difficult to directly adapt them to other alignment scoring schemes. Below, we present a bit-parallel method for similarity and distance based global alignment using general integer-scoring (<ref type="bibr" target="#b2">Benson et al., 2013</ref>), allowing arbitrary integer weights for match, mismatch and indel. Other approaches have been suggested by<ref type="bibr" target="#b15">Wu and Manber (1992)</ref>and Bergeron and Hamel (2002). The method of<ref type="bibr" target="#b12">Navarro (2004)</ref>is more flexible in scoring and applies to both simple patterns and regular expressions, but is much slower than our method in practice. Our contribution is based on an observation of the regularity in the relationship between adjacent scores in the scoring matrix (Section 2.1) and the design of an efficient series of bit operations to exploit that regularity (Section 3). Because every distinct choice of weights requires a different program, we show how to construct a class of efficient algorithms, each designed for a particular set of weights, and provide an online C code generator for users. *To whom correspondence should be addressed. ß The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/4.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited.</p><p>The complexity of our algorithms depends on the weights, not the ultimate score of the alignment. Our method works for general alphabets, but our interest derives from frequent use of DNA alignment when analyzing high-throughput sequencing data to detect genetic variation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head><p>The problem to be solved is stated in terms of similarity scoring, but the technique applies to distance scoring as well.</p><p>PROBLEM. Given two sequences X and Y, of length n and m respectively, and a similarity scoring function S defined by three integer weights M (match), I (mismatch) and G (indel or gap), calculate the global alignment similarity score for X and Y using logic and addition operations on computer words of length w.</p><p>We are interested in two measures of efficiency for the algorithms. The first is standard time complexity and the second is a ratio of the word size, w, and the count, p, of logic and addition operations required to process w consecutive cells in the alignment scoring matrix. The efficiency, e=w=p, is the average number of cells computed per operation. For example, when using 64 bit words, LCS has e=64=4=16<ref type="bibr">[</ref>. As P is independent of w, if the word size doubles, e doubles too. Note that we are counting only logic and addition operations, not storage of values in program variables. Adding store operations would be more accurate but the number of these operations is compiler and optimization level specific. We require that the alignment method be global or semi-global. That is, we do not restrict the initializations in the first row or column of the alignment scoring matrix or where in the last row or column the alignment score is obtained. Typical initializations require (i) a gap weight to be added successively to every cell (global alignment from the beginning of a sequence), and (ii) a zero in every cell (semi-global alignment where an initial gap has no penalty). We assume that match scores are positive or zero, M ! 0, mismatch and gap scores are negative, I; G50 and that the use of mismatch is possible, meaning that its penalty is no worse than the penalty for two adjacent gaps, one in each sequence, I ! 2G. While other weightings are possible, they either reduce to simpler problems from a bit-parallel perspective (e.g. LCS has G=0; I= À 1; M=1) or require more complicated structures than detailed here (e.g. protein alignment using PAM or BLOSUM style amino acid substitution tables).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Function tables</head><p>Let S be a recursively-defined, global similarity scoring function for two sequences X and Y computed in an alignment scoring matrix:Instead of actual values of S, we store only the differences, "V, between a cell and the cell above, and "H, between a cell and the cell to its left:</p><p>"V½i; j=S½i; j À S½i À 1; j "H½i; j=S½i; j À S½i; j À 1:</p><p>It is an easy exercise to prove that the minimum and maximum values for "V and "H are G and M – G, respectively. Lemma 2.1 gives the recursive definitions for "V and "H in terms of M, I and G. LEMMA 2.1. The values for "V are as shown below and the values for "H are computed similarly. That is, "H½i; j in matrix S is equal to V½j; i in the transpose of matrix S.The recursion for "V is summarized in the Function Table in<ref type="figure" target="#fig_6">Figure 1</ref>. Note the value I – G, which frequently occurs in the recursion, and the relation "H="V. They set the boundaries for the marked zones in the table. These zones comprise ("V; "H) pairs, which determine how the best score of a cell in S is obtained in the absence of a match, either as an indel from the left (Zones A and B), a mismatch (Zone C) or an indel from above (Zone D). Borders between zones, indicated by dotted lines, yield ties for the best score.<ref type="figure">Figure 2</ref>shows how the relative size of the Zones changes with changes in I and G.For the illustrations in this article, we use the scoring weights:The "V Function Table for these weights is shown in<ref type="figure" target="#fig_8">Figure 3</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ALGORITHM</head><p>The algorithm proceeds row-by-row through the alignment matrix. For each row, the input is: the "H values from the preceding row, the leftmost "V value in the current row and the match positions in the current row.</p><p>The computation first determines all the remaining "V values for the current row and then, using those, determines the "H values for the current row. A central concept is a run of "H min. This is a set of consecutive positions in the preceding row for which the values of "H all equal min (in<ref type="figure" target="#fig_7">Fig. 4</ref>, positions for which "H= À 5). The algorithm has the following steps (see<ref type="figure" target="#fig_7">Fig. 4</ref>), which follow from Lemma 2.1. 1. Find the locations where "V=max (highest value in Zone A):</p><p>Step 1A: because of a match between the characters in Sequence X and Sequence Y. These occur at match locations where "H=min:</p><p>Step 1B: in any run of "H min to the right of a match location in the run. 2. Find the locations where "V=i,fori 2 fmid+1;. .. ; max À1g (the remaining values in Zone A). These are computed in decreasing order of i. For each i, there are two categories, those locations:</p><p>Step 2A: because of a match or a larger preceding "V value. These also depend on the "H value.Step 3A: a match or the preceding "V value and the "H value (Zone B).Step 4: all the remaining locations with undetermined "V values. 5. Find the current row locations where the new "H=i for: Step 5A: i4min.</p><p>Step 5B: i=min. We describe the simplest case where the length of the first sequence is less than the computer word size w. Longer sequences can be handled in 'chunks', where each chunk has size w. Match<ref type="figure">Fig. 2</ref>. Relative size of Zones as I (mismatch penalty) decreases from 2G (twice gap penalty) where there is no preference for mismatches, to zero, where mismatches are free and gaps are introduced only to obtain matchespositions for every row are computed before the calculation of the row values as is also done for the LCS and edit-distance problems. Details are given at the end. We present two algorithms, BitPAl and BitPAl Packed. They differ in the data structures used to hold and process the "H and "V values and their computation of Steps 3, 4 and 5. Correctness theorems for the various steps are presented in Supplementary Information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">BitPAl</head><p>Data Structure for BitPAl One computer word (sometimes called a vector) represents each possible value of "H and "V. Bit i in a word refers to column i in the alignment scoring matrix. With the weights used for illustration, there are 13 values fG;. .. ; M À Gg=fÀ5; À4;. .. ; 6; 7g, and therefore 13 words each, for "H and "V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Computing the " values</head><p>To compute its output values, each cell needs to know its "H and "V input values. As in standard left to right processing, the output "V value from one cell becomes the input value for the cell to its right. All the input "H values are in the preceding row. Zone A Inspection of the Function Table (<ref type="figure" target="#fig_8">Fig. 3</ref>) reveals that the output values in Zone A are interdependent and require computing in order from high to low. For example, output "V=5 can be obtained in two ways from higher "V input values, ð"V=7; "H= À 3Þ and ð"V=6; "H= À 4Þ. "V= 5 cannot be obtained from lower "V input values. The leftmost column in the table, "H min (–5 in the example), is an identity column. This means that for runs of "H min , an input "V value yields the identical "V ouput for every location in the run to the right of the input. For example, if the input "V=5 for the leftmost position in a run, then the output "V for every position in the run is also 5 (see<ref type="figure" target="#fig_7">Fig. 4</ref>steps 1B, 2B for 4). Carrying an input value through a run of "H min can be accomplished with an addition (+) as seen below. Addition is similarly used to solve left-to-right dependency problems in LCS and editdistance bit-parallel algorithms. Note in the bottom row of the Function Table that a match acts as an input "V max (7 in the example), so we will treat the match positions as having input "V max. Steps 1A and 1B: The locations where "V=max, stored in the "V max vector, are calculated with four operations (<ref type="figure">Fig. 5</ref>). The locations are shifted one position to the right for input to subsequent calculations. The operations are—(i) an AND to find max because of matches; (ii) an ADDITION (+) to carry max through runs of "H min and into the position following a run (because the result will be shifted). This causes erroneous internal bit flips if there are multiple matches in the same run; (iii) an XOR with "H min to complement the bits within the "H min runs and (iv) an XOR with the initial "V max to correct any erroneous bits and finish the shift by removing the locations set with matches.<ref type="figure" target="#fig_8">Figure 3</ref>. The input is the "H prev value in the same column and the "V curr value in the column to the left, except, when there is a match, the value in the column to the left is treated as a max and, starting with Step 3, if the value in the column to the left is not assigned, it is treated as mid. "H prev y is a modification of "H prev in which all Match positions have been changed to max and all values less than mid have been changed to mid. The "H curr value for a particular column is found using the transpose of the table in<ref type="figure" target="#fig_8">Figure 3</ref>. The input is the "H prev y in the same column and the "V curr value in the column to the leftSteps 2A and 2B: Remaining "V high vectors are calculated, in descending order from "V=max À 1 to "V=mid+1 because of the dependencies as discussed above. The operations are: (i) finding the locations because of a preceding higher "V value using AND of appropriate ð"V; "HÞ pairs (which intersect along a common diagonal in the Function<ref type="figure">Table)</ref>and collecting them together with ORs; (ii) shifting the initial vectors right one position for subsequent calculations; (iii) carrying through runs of "H min computed in two operations, an ADDITION (+) as before and an XOR with "H min to complement the bits within the "H min runs (<ref type="figure" target="#fig_9">Fig. 6</ref>). Before the addition, those "H min positions that have already output a "V max value must be removed. Steps 3A and 3B. (<ref type="figure" target="#fig_12">Fig. 7</ref>). At this point, all the "V high input values for Zone B have been computed (they are the outputs from Zone A), remaining output values are all "V low. The operations are: (i) the AND of appropriate ð"V; "HÞ pairs, which intersect along a common diagonal (Zone B); (ii) the AND of the appropriate "H vector and all positions without a "V high output (Zone C); (iii) an OR combination of the preceding two results and (iv) a shift of the locations one position to the right for subsequent calculations. Step 4: Zone D has only one output value, "V min. It is assigned to all remaining locations as well as the zero location if gap penalty in the first column is being used. Step 5: After the "V values are computed, all inputs are available and the new "H vectors for the current row can be computed immediately. The Function Table for the new "H is the transpose of the table for "V, i.e. the input labels are swapped. Each new "H vector is obtained by the AND of appropriate ð"V; "HÞ input pairs, which intersect along a common diagonal, collected together with ORs. Before this can proceed, though, the Match positions must be added to the previous row's "H max vector (with OR) and removed from all other previous row "H vectors. Also, all previous row "H low locations must be converted to "H mid .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">BitPAl Packed</head><p>Data structure for BitPAl packed The number of logic operations in BitPAl scales linearly with the size of the function table. Many of these are the AND and OR operations to compute identical values along Zone B diagonals. These calculations can be performed more efficiently with a new representation. The idea is to store the input "H and "V values in such a way that they can all be added simultaneously to give the appropriate output values. Rather than using bit-vectors to represent single "H or "V values, we use them to represent binary digits (<ref type="figure" target="#fig_11">Fig. 8</ref>). We map the "V values fmin;. .. ; maxg one-to-one onto the positive values f0;. .. ; max À ming and store them in the vectors "V p0 ; "V p1 ; "V p2 ; etc. where p i is the place holder for the ith power of 2. The mapping for "H is onto negative numbers, i.e. fmin;. .. ; maxg are mapped to f0;. .. ; Àðmax À minÞg and stored in vectors "H p0 ; "H p1 ; "H p2 ; etc. After addition, the sums will fall in fÀðmax À minÞ;. .. ; max À ming, so we use dlog 2 ð2ðmax À minÞ+1Þe bit-vectors for "H and "V. For our example, the "V values are mapped to f0;. .. ; 12g, the "H values are mapped to f0;. .. ; À12g and the sums fall within fÀ12;. .. ; 12g, so we use five vectors each for "H and "V. BitPAl Packed does not change the computation of the "V values in Zone A. The "H values are always maintained in the packed representation, but some are unpacked into the original representation for the Zone A computations. Once Steps 1 and 2 are completed, all locations without a "V value are set to mid, all match locations are set to max, and the "V values are converted into the packed representation. Steps 3 and 4 are computed by 'adding' together the two sets of packed vectors using a series of AND, OR and XOR operations (<ref type="figure" target="#fig_11">Fig. 8</ref>) to produce the final encoded values for "V. Any negative values (sign bit set) are converted to min (Zone D). For Step 5, the new "H values are determined with a second addition. Because all input "H in the range ½min; mid give the same result, we first re-encode that range to mid. Packing and unpacking Packing "V vectors involves identifying the locations where the binary representation of the encoded<ref type="figure">Fig. 5</ref>. Finding "V max. Each line represents a computer word with low order bit, corresponding to the first position in a sequence, on the left. 1s are shown explicitly, 0s are shown only to fill runs of "H min and the first position to the right of each run. Symbol 44 indicates that the final "V max values are shifted to the right one position. Bits erroneously set by the ADDITION (+) are shown in bold. Sample code is from the complete listing in Supplementary Informationvalues all have a specific bit set. For example, the binary representations for 1, 3, 5, 7, 9 and 11 all have the bit representing 2 0 set, and the binary representations for 2, 3, 6, 7, 10 and 11 all have the bit representing 2 1 set. Effectively then,</p><formula>"V p0 ="V 1 OR "V 3 OR "V 5 OR "V 7 OR "V 9 OR "V 11 "V p1 ="V 2 OR "V 3 OR "V 6 OR "V 7 OR "V 10 OR "V 11 etc:</formula><p>where "V i is the vector of locations with encoded value i. However, as can be seen for these two examples, there are common terms ("V 3 ; "V 7 ; "V 11 ), so combining the terms as above leads to inefficiencies. Unpacking the "H vectors involves identifying locations of specific encoded values from the binary representation vectors. For example, the "H À1 locations are those (using two's complement, –1 = 11 111) that have all bits set and "H À2 locations are those (using two's complement, –2 = 11 110) that have all but the lowest bit set. Again, effectively</p><formula>"H À1 ="H p0 &amp; "H p1 &amp; "H p2 &amp; "H p3 &amp; "H p4 "H À2 = $"H p0 &amp; "H p1 &amp; "H p2 &amp; "H p3 &amp; "H p4 etc:</formula><p>Again, there are common terms that can be combined to avoid inefficiencies. For both packing and unpacking, we use a binary tree structure in the code generator to guide creation of temporary intermediate vectors so that operations are not duplicated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Other tasks</head><p>Determining matches As a preprocessing step, the position of the matches are determined for each character in the sequence alphabet. A bit vector Match records those positions in sequence X where occurs. Filling all the Match simultaneously can be accomplished efficiently in a single pass through X. Decoding the alignment score The score in the last column of the last row of the alignment scoring matrix can be obtained by calculating the score in the zero column (=m Ã G) and then adding the number of 1 bits in each of the "H vectors multiplied by the value of the vector. Using the method described in (<ref type="bibr" target="#b10">Kernighan and Ritchie, 1988</ref>), this takes Oðn+M À 2GÞ operations with a small constant:</p><formula>S½m; n=m Ã G+ X MÀG i=G bits i Ã i</formula><p>where bits i is the number of 1 bits set in "H i .For BitPAl Packed, the alignment score can similarly be computed in Oðn Á kÞ operations</p><formula>S½m; n=m Ã G+ X kÀ1 i=0 pbits i Ã 2 i :</formula><p>where pbits i is the number of 1 bits set in "H pi , and k is the number of bit vectors in the packed representation. Several straightforward methods can be used to efficiently find all scores in the last row or last column.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Complexity and number of operations</head><p>The time complexity of our algorithms is Oðznm=wÞ where z depends on the version. For BitPAl standard, z represents the combined size of Zones A, B and C (the latter reduced to a single row as in<ref type="figure" target="#fig_8">Fig. 3</ref>) in the Function<ref type="figure">Table.</ref>This in turn depends on the alignment weights M, I and G:</p><formula>z= ðM À 2G+1Þ 2 À ðI À 2GÞ 2 2</formula><p>and the constant hidden in the big O notation is $4 (dominated by two operations per cell of Zones A, B and C for "V and separately for "H). For the example weights used in this article, the number of logic and addition operations, p, per word is 265, yielding an efficiency of 64=265 % 0:24 cells per operation with 64 bit words. For the packed version, z represents the size of Zone A, the number of distinct "H and "V values for the packing and unpacking steps, and the binary log of the number of distinct values for the addition steps:</p><formula>z=ðM À IÞ 2 +ðM À 2G+1Þ+log 2 ðM À 2G+1Þ:</formula><p>Unlike the standard version, the term constants are not uniform ($2, 2 and 12, respectively). For the example weights used in this article, the number of logic and addition operations, p, per word is 166, yielding an efficiency of 64=166 % 0:38 cells per operation for 64 bit words. See<ref type="figure" target="#fig_10">Figure 9</ref>for a comparison of the number of operations required by the two algorithms for different alignment weights.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Implementation</head><p>Each unique set of weights M, I and G requires a uniquely tailored program. To simplify usage, we have constructed a Web site http://lobstah.bu.edu/BitPAl/BitPAl.html that generates C source code for download. The Web site takes as input the user's alignment weights, the algorithm version (standard or packed), whether it will be used for short sequences (single word) or long sequences (multiple word) and where the final score should be found.<ref type="bibr" target="#b15">Wu and Manber, 1992</ref>) approximate pattern matching algorithm and (vii) N—the (<ref type="bibr" target="#b12">Navarro, 2004</ref>) general integer scoring, approximate regular expression matching algorithm. We implemented BitPAl, BitPAl Packed, NW, LCS, ED and WM. N was graciously provided by Gonzalo Navarro. For all experiments, we used human DNA and ran 100 pattern sequences against 250 000 text sequences for a total of 25 million alignments. (Pattern and text distinctions are irrelevant for BitPAl, BitPAl Packed, NW, LCS and ED.) All sequenceswere 63 characters long. For WM, we varied k, the maximum number of allowed errors, from 1 to 15. For N, we varied k from 1 to 12. All programs were compiled with GCC using optimization level O3 and were run on an<ref type="bibr">Intel</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENTAL RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DISCUSSION</head><p>The BitPAl and BitPAl packed algorithms outlined above can be extended in several ways. Computers now in common usage have special 128 bit SIMD registers (Single Instruction, Multiple Data). Using these, with the addition of several bookkeeping operations, would essentially double the efficiency and the speed of computation. Another extension derives from the unexploited parallelism of the operations. There are no dependencies on prior computations after the "V vectors in Zone A are computed. This means that all the computations in Zones B, C and D for "V and all the subsequent computations for "H can be done simultaneously, an ideal situation for the use of general purpose graphical processing units (GPGPU). Another possible extension expands the types of scoring schemes allowed. BLOSUM type scoring, which is useful for protein alignments, eliminates match and mismatch scoring and instead assigns different substitution weights to each pair of characters. Affine-gap scoring replaces single character indel scoring with gap initiation and gap extension weights. Extension to local alignment is also possible. This is a different class of problem in that the best final alignment score can occur in any cell of the alignment matrix. If all the cells have to be examined, then the time complexity shifts back to O(nm). Hyyr € o and Navarro (2006) had some success with this problem using unit cost weights and identifying columns in which the score of at least one cell exceeds a predefined threshold k. The BitPAl methods have already been used to accelerate software for detecting tandem repeat variants in high-throughput sequencing data (<ref type="bibr" target="#b5">Gelfand et al., 2014</ref>) and are well-suited to other DNA sequence comparison tasks that involve computing many alignments. Funding: This work was supported by the National Science Foundation (IIS-1017621 to G.B., DGE-0654108 to J.L. and Y.H.).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict</head><p>of interest: none declared.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>P = 4 operations per word (Hyyr€ o, 2004)], and edit distance has e=64=15 % 4:2 [an improvement from 64/16 in the method of Hyyr € o et al. (2005) and Myers (1999); see Supplementary Information for details]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>By substitution in the recursive formula for S. w</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>DEFINITIONS. min=G; max=M À G; mid=I À G, low 2 fmin; ... ; midg and high 2 fmid+1;. .. ; maxg.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>Step 2B: because of the value i being carried through a run of "H min: 3. Find the locations where "V=i, for i 2 fmin+1;. .. ; midg (the values in Zones B and C). These are computed separately for each value i and depend on:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><figDesc>Step 3B: the "H value alone (Zone C). 4. Find the locations where "V=min (the values in Zone D). These are:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.1.</head><figDesc>Fig. 1. Zones in the Function Table for "V. Zone A: all values are in V high 2 fI À G+1;. .. ; M À Gg; Zone B: all values are in V low 2 fG;. .. ; I À Gg; Zone C: all values are in V low and values depend only on "H; Zone D: all values are G; Last row: values also apply when there is a match;. First column: identity column for values in V high</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.4.</head><figDesc>Fig. 4. An example of the calculation of "V curr and "H curr values. "H prev values come from the previous row. The match locations and the leftmost "V curr value are known. The "V curr value for a particular column is found using the table in Figure 3. The input is the "H prev value in the same column and the "V curr value in the column to the left, except, when there is a match, the value in the column to the left is treated as a max and, starting with Step 3, if the value in the column to the left is not assigned, it is treated as mid. "H prev</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.3.</head><figDesc>Fig. 3. The "V Function Table for the weights M=2; I= À 3; G= À 5: Note that "V high ; "H high 2 3; 7 ½ ; "V low ; "H low 2 À5; 2 ½ ; "V min ="H min = À 5; "V max ="H max =7. The "H Function Table is the transpose of this table, i.e. the labels "H and "V are swapped</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig.6.</head><figDesc>Fig. 6. Carry through runs of "H min for remaining values in "V high : Symbol X marks a single position between runs which cannot be 1 in the initial shifted values</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig.9.</head><figDesc>Fig. 9. Comparison of the number of operations for BitPAl and BitPAl packed for different alignment weights (M, I, G)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig.8.</head><figDesc>Fig. 8. Top: The BitPAl Packed mapping of "H and "V values for the parameter set M=2; I= À 3; G= À 5. Middle: conversion from the 13 "V i vectors at left to the five 'packed' vectors at right. Bottom: example code for adding the packed representation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig.7.</head><figDesc>Fig. 7. Code for Zones B, C and D</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><figDesc>We compared running times for several bit-parallel algorithms using different alignment weights: (i) BitPal, (ii) BitPAl Packed, (iii) NW—the classical Needleman and Wunch (1970) dynamic programming alignment algorithm, (iv) LCS—the bit-parallel LCS algorithm of Hyyr€ o (2004), (v) ED—our improved bit-parallel, unit-cost edit-distance algorithm from the method of Hyyr € o et al. (2005) and Myers (1999), (vi) WM—the unit-cost (</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig.10.</head><figDesc>Fig. 10. Running times. Each experiment involved 25 million alignments. For BitPAl and BitPAl Packed, alignment weights (M, I, G) are shown in parenthesis. All times are averages of three runs. Left: unit-cost BitPAl, unit-cost WM, LCS and ED. k is the maximum number of errors allowed for WM. k is not a parameter for the other algorithms and their times are shown as horizontal lines. LCS uses 4 bit operations per w cells, ED uses 15 bit operations, BitPAl (0, –1, –1) uses 23 bit operations. For k = 7, the times for BitPal and WM are nearly the same. By k = 15, BitPAl runs approximately twice as fast. Results for N are not shown on the graph. It was 118–304 times slower than BitPAl (0, –1, –1) even when optimal parameters were chosen. Right: variants of BitPAl and NW (shown as a horizontal line). For BitPAl, time is approximately linearly proportional to one dimension of the function table. For BitPAl packed, time is approximately linearly proportional to the area of the function tables. BitPAl packed (2, –3, –5) is $7.1 times faster than NW and BitPAl (0, –1, –1) is $24.9 times faster</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><figDesc>Core 2 Duo E8400 3.0 GHz CPU running Ubuntu Linux 12.10. Results are shown in Figure 10 and Table 1.</figDesc></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Bit-parallel, general integer-scoring alignment at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3169"> Bit-parallel, general integer-scoring alignment at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">J.Loving et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">A bit-string longest-common-subsequence algorithm</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Allison</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">I</forename>
				<surname>Dix</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="305" to="310" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">A new approach to text searching</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Baeza-Yates</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">H</forename>
				<surname>Gonnet</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="74" to="82" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">A bit-parallel, general integer-scoring sequence alignment algorithm</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Benson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorial Pattern Matching</title>
		<editor>Fischer,J. and Sanders,P.</editor>
		<meeting><address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2013" />
			<biblScope unit="page" from="50" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Vector algorithms for approximate string matching</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Bergeron</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Hamel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Found. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="53" to="65" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">A fast and practical bit-vector algorithm for the longest common subsequence problem</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Crochemore</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inform. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">80</biblScope>
			<biblScope unit="page" from="279" to="285" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">VNTRseek-a computational tool to detect tandem repeat variants in high-throughput sequencing data</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Gelfand</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Bit-parallel LCS-length computation revisited</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hyyr € O</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 15th Australasian Workshop on Combinatorial Algorithms</title>
		<meeting>the 15th Australasian Workshop on Combinatorial Algorithms<address><addrLine>Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Bit-parallel witnesses and their applications to approximate string matching</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hyyr € O</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="203" to="231" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Bit-parallel computation of local similarity score matrices with unitary weights</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hyyr € O</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Int. J. Found. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="1325" to="1344" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Increased bit-parallelism for approximate and multiple string matching</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Hyyr € O</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Exp. Algorithmics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="2" to="6" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<monogr>
		<title level="m" type="main">The C Programming Language</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Kernighan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Ritchie</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>Prentice Hall</publisher>
			<pubPlace>Upper Saddle River, NJ, USA</pubPlace>
		</imprint>
	</monogr>
	<note>2nd. edn</note>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">A fast bit-vector algorithm for approximate string matching based on dynamic programming</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="395" to="415" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Approximate regular expression searching with arbitrary integer weights</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nordic J. Comput</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="356" to="373" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">A general method applicable to the search for similarities in the amino acid sequence of two proteins</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Needleman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Wunch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="443" to="453" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Identification of common molecular subsequences</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Smith</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Waterman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">147</biblScope>
			<biblScope unit="page" from="195" to="197" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast text searching: allowing errors</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Wu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Manber</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="83" to="91" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">A subquadratic algorithm for approximate limited expression matching</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Wu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="50" to="67" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<monogr>
		<title level="m" type="main">Table 1. Table of run times in minutes Algorithm Parameters (M, I, G)</title>
		<imprint>
			<biblScope unit="page" from="0" to="1" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<monogr>
		<title level="m" type="main">Shown are averages over three trials for 25 million alignments. Needleman– Wunsch has the same runtime for all parameters</title>
		<author>
			<persName>
				<surname>Note</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
	<note>056056. min</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>