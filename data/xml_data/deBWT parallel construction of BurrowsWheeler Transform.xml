
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:38+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">deBWT: parallel construction of Burrows–Wheeler Transform for large collection of genomes with de Bruijn-branch encoding</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Bo</forename>
								<surname>Liu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Bioinformatics</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Dixian</forename>
								<surname>Zhu</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Bioinformatics</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Yadong</forename>
								<surname>Wang</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Center for Bioinformatics</orgName>
								<orgName type="institution">Harbin Institute of Technology</orgName>
								<address>
									<postCode>150001</postCode>
									<settlement>Harbin, Heilongjiang</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">deBWT: parallel construction of Burrows–Wheeler Transform for large collection of genomes with de Bruijn-branch encoding</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btw266</idno>
					<note>*To whom correspondence should be addressed. † The authors wish it to be known that, in their opinion, the first two authors should be regarded as joint First Authors. Contact: ydwang@hit.edu.cn Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: With the development of high-throughput sequencing, the number of assembled gen-omes continues to rise. It is critical to well organize and index many assembled genomes to promote future genomics studies. Burrows–Wheeler Transform (BWT) is an important data structure of genome indexing, which has many fundamental applications; however, it is still non-trivial to construct BWT for large collection of genomes, especially for highly similar or repetitive genomes. Moreover, the state-of-the-art approaches cannot well support scalable parallel computing owing to their incremental nature, which is a bottleneck to use modern computers to accelerate BWT construction. Results: We propose de Bruijn branch-based BWT constructor (deBWT), a novel parallel BWT construction approach. DeBWT innovatively represents and organizes the suffixes of input sequence with a novel data structure, de Bruijn branch encoding. This data structure takes the advantage of de Bruijn graph to facilitate the comparison between the suffixes with long common prefix, which breaks the bottleneck of the BWT construction of repetitive genomic sequences. Meanwhile, deBWT also uses the structure of de Bruijn graph for reducing unnecessary comparisons between suffixes. The benchmarking suggests that, deBWT is efficient and scalable to construct BWT for large dataset by parallel computing. It is well-suited to index many genomes, such as a collection of individual human genomes, with multiple-core servers or clusters. Availability and implementation: deBWT is implemented in C language, the source code is available at https://sites.googIe.com/site/jianfang86/JSCCA.
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>With the rapid development and ubiquitous application of highthroughput sequencing, many genomes have been sequenced in cutting-edge genomics studies. For example, 1000 Genomes (<ref type="bibr">The 1000</ref><ref type="bibr">Genomes Project Consortium, 2015</ref>) and UK10K (<ref type="bibr" target="#b30">The UK10K Consortium, 2015</ref>) projects have sequenced many thousands of individual human genomes. Moreover, as the cost of sequencing continuously decreases, e.g. the cost of sequencing a human sample has already been lower than 1000 dollars (<ref type="bibr" target="#b33">Watson, 2014</ref>), the number of genomes may explosively increase in the future. Under this circumstance, it is fundamental to well organize and index the large amount of genomes to facilitate future genomics studies. Burrows–Wheeler Transform (BWT;<ref type="bibr">Burrows and Wheeler, 1994;</ref><ref type="bibr" target="#b7">Ferragina and Manzini, 2000</ref>) is a self-indexing data structure having many fundamental applications, such as genome indexing (<ref type="bibr" target="#b11">Hon et al., 2004;</ref><ref type="bibr" target="#b13">Karkkainen, 2007</ref>), sequence alignment (<ref type="bibr" target="#b14">Lam et al., 2008;</ref><ref type="bibr" target="#b16">Li and Durbin, 2009a;</ref><ref type="bibr" target="#b15">Langmead and Salzberg, 2012</ref>), genome compression (<ref type="bibr" target="#b22">Makinen et al., 2010;</ref><ref type="bibr" target="#b4">Cox et al., 2012</ref>), genome assembly (<ref type="bibr" target="#b27">Simpson and Durbin, 2012;</ref><ref type="bibr" target="#b18">Li, 2012</ref>) and sequencing error correction (<ref type="bibr" target="#b3">Cox et al., 2011</ref>). However, the BWT construction of genomic sequence(s) is a non-trivial task. Mainly, the core of BWT construction is to determine the lexicographical order of all the suffixes of the input sequence(s). Because there could be many repetitive sequences within a genome (<ref type="bibr" target="#b32">Treangen and Salzberg, 2012</ref>), the cost would be prohibitively high to straightforwardly compare all the suffixes to determine their lexicographical orders. The problem is even more serious for constructing the BWT of many highly similar genomes, such as a large collection of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i174</head><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/by-nc/4.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals.permissions@oup.com<ref type="bibr">Bioinformatics, 32, 2016</ref>, i174–i182 doi: 10.1093/bioinformatics/btw266 ISMB 2016 individual human genomes, as there would be many common sequences to make the whole input even more repetitive. Efforts have been made to BWT construction. As the BWT of input sequence(s) can be directly derived from the corresponding suffix array (SA), many extant SA construction methods (<ref type="bibr" target="#b28">Smyth and Turpin, 2007</ref>) are applicable to this task. However, the memory footprint may be not practical for large genomic sequences, e.g. sequence over tens of Giga basepairs (Gbp), as proposed SA construction methods usually need to store the entire SA in memory. Although there are also proposed SA construction methods having smaller memory footprints (<ref type="bibr" target="#b5">Crauser and Ferragina, 2008;</ref><ref type="bibr" target="#b25">Nong et al., 2014</ref>), however, they are at the expense of speed, as they need to use external memory. Most of the state-of-the-art BWT construction methods take the advantage of the incremental construction approach, which is on the basis of the property that the relative lexicographical order of a set of sorted suffixes will not be changed by adding new suffixes. (<ref type="bibr" target="#b12">Hon et al., 2007</ref>) proposed the first compressed suffix array (CSA) construction method using this property. Mainly, it logarithmically partitions the input sequence into blocks, and incrementally builds the CSA from shortest to longest suffixes in three steps: (i) construct the SA for a new block of suffixes; (ii) sequentially insert each of the suffixes within the new block into the CSA of the old blocks, based on the property that the relative order of the suffixes within the old blocks do not change, and the CSA values monotonically increase for the suffixes having the same initial character; (iii) merge the new and old blocks to update the CSA. There are other proposed BWT construction methods in this incremental blockwise approach, which have various implementations. (<ref type="bibr" target="#b9">Ferragina et al., 2012</ref>) proposed a BWT construction method, bwt-disk, similar to (<ref type="bibr" target="#b12">Hon et al., 2007</ref>), which also logarithmically partitions the input sequence. But it sorts each new block with a modified DC3 algorithm, and takes advantage of the last-first mapping (LF-mapping) property of BWT (<ref type="bibr" target="#b8">Ferragina and Manzini, 2005</ref>) to merge new and old blocks. (<ref type="bibr" target="#b21">Liu et al., 2014b</ref>) also proposed a BWT construction method, ParaBWT, in a similar manner. It uses a longest common prefix table to facilitate the sorting of newly added suffixes, but also merges the new and old blocks based on LF-mapping. The main contribution of this method is that it implements parallelization for the sorting of newly added blocks, which is beneficial for processing large input sequences. Other than constructing BWT for one or more large sequences, this approach is also used for indexing large collections of sequencing reads.<ref type="bibr" target="#b0">Bauer et al. (2013)</ref>proposed BCR, an algorithm for constructing the BWT of a large set of reads. It uses a specific partition of SA, i.e. partitioning all the suffixes into blocks by their positions on the corresponding sequencing reads. With this partition, the markers (denoted as specific characters) of the reads can be fully used for improving the efficiency of the sorting and merging of blocks. (<ref type="bibr" target="#b19">Li, 2014</ref>) also proposed a similar method, RopeBWT2, with improved ability of handling the sequences in various lengths. Besides the blockwise incremental approach, there are also other approaches proposed. (<ref type="bibr" target="#b13">Karkkainen, 2007</ref>) proposed a method that constructs BWT in a different blockwise manner. It samples a set of suffixes as splitters to bin all the suffixes into various blocks, and for each of the blocks, the proposed method addresses all the suffixes with difference cover sample (DCS). (<ref type="bibr" target="#b20">Liu et al., 2014a</ref>) proposed a graphics processing unit (GPU-based) BWT construction method, CX1, for indexing a large set of short reads. The main idea of the method is to bin all the suffixes by their initial k-mers, and address all the bins with GPU-based radix sort. This method is mainly designed for reads with limited length, as the radix sort relies on the auxiliary characters attached to the reads. The major advantage of the incremental blockwise approach is that, based on the LF-mapping property, it provides an effective way to compare suffixes with long common prefix, which is critical to the BWT construction of large repetitive genomes. However, owing to the incremental nature, this approach is not suitable for parallel computing. Considering the rapid increase of assembled genomes, the input sequence will be much larger than before. In this situation, processing the large sequence with parallel computing is favorable, especially that modern servers and clusters have much more CPU cores and RAM than before. Recent studies have made the efforts to BWT construction with parallel computing. ParaBWT implemented the parallel BWT construction for large sequence; however, the results demonstrated that it is not scalable, i.e. the speedup will saturate when a couple of threads (e.g. eight threads) are used. This is mainly owing to the bottleneck of the incremental blockwise approach. As a non-incremental approach, CX1 is scalable; however, it has limitation on the length of input sequences. Herein, we propose de Bruijn branch-based BWT constructor (deBWT), a novel scalable parallel BWT construction method, which draws support from de Bruijn graph (dBG). The relationship between dBG and suffix trie was explored in previous studies (<ref type="bibr" target="#b24">Marcus et al., 2014</ref>); however, it has still not been fully used in BWT construction. The main contribution of deBWT is to represent and organize the suffixes of input sequence with the property of dBG that all the copies of the same k-mer within the input sequence(s) collapse to the same vertex of the dBG of the sequence(s). The critical point of deBWT is to represent the suffixes with a novel data structure, de Bruijn branch encoding, which is derived from the unipaths of the dBG of the input sequence. This data structure facilitates the comparison between the suffixes with long common prefix. Moreover, deBWT partitions the whole BWT into blocks by their initial k-mers, and uses the property of dBG to avoid unnecessary sorting for some of the blocks, i.e. the BWT characters of some blocks can be derived in constant time based on the topology of the graph. We benchmarked deBWT with various datasets, and the result suggests that it has fast speed and good scalability to multiple threads. Especially, deBWT is well-suited to the BWT construction of a collection of highly similar genomic sequences, such as multiple human genomes, which may have wide application in the future genomics studies.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preliminary</head><p>Let a DNA sequence, G, be a sequence over the alphabet R ¼ A; C; G; T f ghaving G j j characters. Further, we assume the sequence to be indexed is S ¼ G$, where $ is an auxiliary character, and the lexicographical order of the alphabet of S is A &lt; C &lt; G &lt; T &lt; $. Moreover, S i ½ ; i ¼ 0;. .. ; G j j denotes the i-th character of S, and S½i; j denotes the substring of S starting at S i ½  and ending at S j ½ . A suffix of S is a substring S½i; G j j, i ¼ 0;. .. ; G j j, and the SA of S is a function that SA i ½  ¼ j, i ¼ 0;. .. ; G j j, where j is the starting position of the i-th lexicographically smallest suffix of S. The BWT of S, B S , is the permutation of the characters of S that, B S i ½  ¼ S½SA i ½  À 1, if SA i ½  6 ¼ 0, and B S i ½  ¼ $, otherwise. The dBG of G, D G , is a directed graph, where the vertices consist of all the k-mers of G. Each of the vertices is denoted as KM i , deBWT i175 i ¼ 1;. .. ; D G , where D G is the total number of distinct k-mers. For any pair of vertices of D G , KM i ; KM j À Á , there is a directed edge KM i ! KM j , only if KM i and KM j have a k-1 overlapping, i.e. KM i 1; k À 1 ½ ¼KM j ½0; k À 2. With this definition, a set of maximal non-branched paths can be derived from D G. Here, a maximal non-branch path indicates a path that meets the following conditions: (i) for the first vertex, the in-degree is 0 or &gt;1, and the out-degree is 1; (ii) for the last vertex, the out-degree is 0 or &gt;1, and the in-degree 1; (iii) for all the other internal vertices, the in-and out-degrees are exactly 1 (<ref type="bibr" target="#b31">Tomescu and Medvedev, 2016</ref>). Such paths are usually termed as 'unipaths' or 'unitigs', which are commonly used in the de novo assembly of genome (<ref type="bibr" target="#b10">Gnerre et al., 2011;</ref><ref type="bibr" target="#b34">Zimin et al., 2013;</ref><ref type="bibr" target="#b31">Tomescu and Medvedev, 2016</ref>). We used the term 'unipath' in the following sections. For the convenience of discussion, we assign each of the unipaths of D G an identity, U j ; j ¼ 1;. .. ; U G , where U G is the total number of the unipaths.</p><p>In the following subsections, we present the unipath-based BWT construction approach at first (Section 2.2), then the overview of deBWT (Section 2.3) and more detailed information about the implementation of the various steps of the method (Section 2.4-2.7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Unipath-based BWT construction</head><p>2.2.1 The unipath representation of suffix The DNA sequence G can be represented by a specific walk on the dBG D G , i.e. it equals to the sequence of collapsing a specific ordered list of the vertices of D G , KM G 0 ; KM G 1 ;. .. ; KM G G j jÀk , where each KM G i ; i ¼ 0;. .. ; G j j À k is the corresponding k-mer starting at position i of G, and each of the two neighboring vertices within the list is a specific edge of D G. With this observation, we have the following lemma.This lemma is easy to justify by collapsing all such edges,where KM G i and KM G iþ1 are respectively single-out and single-in vertices. Thus, the ordered list can be re-written as</p><formula>U G 1 ; U G 2 ;. .. ; U G</formula><p>UG j j , where U G j j is the total number of the unipaths representing G, each U G i ; i ¼ 1;. .. ; U G j j represents a unipath. It is also worth noting that, some of the identities within the list may be same to each other, as a unipath could have multiple copies. For each U G i , we further define its starting position on G as a Unipath Change Point (UCP), UCP G i. An illustration is in Supplementary<ref type="figure" target="#fig_2">Figure 1</ref>. Furthermore, we have the following corollary.Each of the suffixes, S½i; G j j, can be directly represented by the ordered list KM G i ; KM G iþ1 ; .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.. ; KM G</head><p>G j jÀk , where KM G i is the corresponding k-mer at position i. If position i is a UCP, the ordered list of k-mers can be re-written as the ordered list of unipaths, U G j ; U G jþ1 ;. .. ; U G UG j j ; otherwise, it can be re-written as</p><formula>S i; UCP G jþ1 À 1 h i ; U G jþ1 ;. .. ; U G</formula><p>UG j j , where U G jþ1 is the UCP closest to position i downstream, and S i; UCP G jþ1 À 1 h i is the substring of the unipath that KM G i is within (Supplementary<ref type="figure" target="#fig_2">Fig. 1</ref>). We term this list as the unipath representation of the suffix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">The unipath-based comparison between two suffixes</head><p>Given two suffixes of S, Suf S i ¼ S½i; G j j and Suf S j ¼ S½j; G j j, where i 6 ¼ j, i &lt; G j j À k and j &lt; G j j À k, the comparison between the two suffixes can be deduced as the following two situations. First, considering the two ordered lists of k-mers,KM G i 6 ¼ KM G j , the lexicographical order of the two suffixes can be easily determined by their initial k-mers. Secondly, if KM G i ¼ KM G j , the comparison is more complicated. In this situation, the two suffixes are two walks on D G starting at the same vertex, as all the copies of the same k-mers collapse to the same vertex of the dBG. Thus, S i; UCP G iþ1 À 1 Â Ã ¼ S j; UCP G jþ1 À 1 h i , as the two strings are the same substring of the corresponding unipath. An illustration is in<ref type="figure" target="#fig_2">Figure 1a</ref>. Then it becomes an iterative comparison between the aligned unipaths, i.e. if the two unipaths, U G iþ1 and U G jþ1 , are different, the lexicographical order can be determined, otherwise we need to compare the following unipaths until we meet two different unipaths (<ref type="figure" target="#fig_2">Fig. 1b</ref>). Considering the property of dBG, if the two unipaths, U G iþl and U G jþl , are identical to each other, the starting vertices of U G iþlþ1 and U G jþlþ1 must be two vertices with the same precursor; thus, the first k-1 characters of the two vertices must be same, i.e. the comparison can be done by only checking the k-th characters of the two unipaths, i.e. G UCP G iþlþ1 þ k À 1 h i and G UCP G jþlþ1 þ k À 1 h i (<ref type="figure" target="#fig_2">Fig. 1c</ref>).</p><p>Moreover, if the last vertex of U G iþl (U G jþl ) is a single-out vertex, the comparison can be also omitted because the next unipaths must be the same. With these observations, we designed a novel data structure named as de Bruijn branch encoding (<ref type="figure" target="#fig_2">Fig. 1d</ref>). The de Bruijn branch encoding of G, dE G , is defined as the concatenation of all such characters G i þ k ½ ; i ¼ 0;. .. ; G j j À k À 1 meeting the condition that KM G i corresponds to a multiple-out vertex. Each of the characters of dE G is also called a branching character. Then, for each of the Suf T j , j &lt; G j j À k, we define its projection suffix on dE G as</p><formula>dE G / j ð Þ; dE G À 1 Â Ã</formula><p>, where / j ð Þ is the dE G coordinate of the first branching character after the position j in S, and dE G is the length of dE G. Lemma 2: For two suffixes at least k bp long, their lexicographical order can be determined by comparing their projection suffixes defined by the de Bruijn branch encoding of the DNA sequence, if the initial k-mers of the two suffixes are identical. This lemma is easy to justify with the observations mentioned above, and it provides a cost-effective solution of the comparison between two suffixes with long common prefix. corresponding parts by their initial k-mers. After the two steps, the BWT construction becomes D G sub-problems, i.e. separately determining the lexicographical order of the suffixes within each of the D G , as the lexicographical order of the suffixes with different k-mers have been implicitly determined during the construction of the k-mer partition. Thus, for each of the D G parts corresponding to various initial k-mers, the task is the comparison of a series of suffixes with the same initial k-mer, which can be implemented with the help of the de Bruijn branch encoding dE G. Moreover, the problem can be further reduced with the following lemma. Lemma 3: If a vertex KM i of D G (i ¼ 1; .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.. ; D G</head><p>) is single-in, the corresponding BWT part consists of KM i j j same characters, where KM i j jis the number of the copies of KM i in G, only except if the part involves the first suffix. This lemma is obtained with the observation that if a vertex of the dBG is single-in, all the suffixes with this k-mer must have the same previous character, i.e. the BWT of this part is purely KM i j j copies of the first character of the precursor of KM i. This is except for the parts involving the first suffix, as the BWT character of the first suffix is $. With this lemma, only the parts labeled by multiplein vertices need to be sorted. Thus, there are at most U G subproblems, as such vertices must be the initial k-mers of the unipaths.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Overview of the deBWT method</head><p>As in many cases, the input is not only one, but a set of DNA sequences, such as a set of genomes, chromosomes or assembled contigs, we re-define the sequence to be indexed as S ¼ G 1 G 2. .. G ND $, where N D is the number of input DNA sequences, and each of G i ; i ¼ 1;. .. ; N D is a specific sequence. is another auxiliary character, and the alphabet becomes A &lt; C &lt; G &lt; T &lt; &lt;$. DeBWT constructs the BWT of S in the following three major phases. i. dBG building and analysis: deBWT builds a dBG of all the involved sequences G 1 ; G 2 ;. .. ; G ND f g with a user-defined parameter k, sort the k-mers to build the k-mer partition of the BWT, recognize all the unipaths as well as the multiple-out and multiple-in vertices and solves all the parts corresponding to single-in vertices. ii. de Bruijn branch encoding generation: deBWT computes the de Bruijn branch encoding of S (dE S ), bins all the suffixes of S corresponding to the unsolved parts of BWT and computes their projection suffixes. iii. BWT construction with projection suffixes: for each of the unsolved BWT parts, deBWT builds the SA of the involved projection suffixes to determine the BWT characters of the part. A schematic illustration of the method is in<ref type="figure" target="#fig_3">Figure 2</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">dBG building and analysis</head><p>It needs all the k-mers as well as the numbers of their copies in G 1 ; G 2 ;. .. ; G ND f g to build the k-mer partition and solve the single-in parts, i.e. a k-mer counting task. In the current version of deBWT, Jellyfish (<ref type="bibr" target="#b23">Marc¸ais and Kingsford, 2011</ref>) is used. As both of the multiplein and multiple-out vertices are needed in later steps, deBWT counts the edges of the dBG, i.e. the (k þ 1)-mers, instead of the k-mers. To build the k-mer partition of the BWT, deBWT sorts all the (k þ 1)-mers by their lexicographic order, and respectively merges all the (k þ 1)-mers with identical first k bp prefixes into k-mers to build the partition. For each of the k-mers, its number of copies is calculated by directly summing up the corresponding (k þ 1)-mers.of the dBG, two suffixes, Suf G i and Suf G j with the same initial k-mer must link to the same offset of the same unipath (the copies of the unipaths on the DNA sequence are marked by segments with various colors). Thus, the lexicographical order of the two suffixes cannot be determined until the comparison reaches the end of the unipath, as all the corresponding characters of the two suffixes are same to each other. (b) When the comparison goes to new unipaths from the finished (same) unipath, the lexicographical order can be determined only if the two suffixes have two different unipaths on the corresponding positions of their unipath representation, otherwise, more unipaths are needed. In this case, both of the two suffixes have the same unipath (the red unipath) successive to the first unipath (the blue unipath), so that the comparison continues to the third unipaths. For the third unipath, the lexicographical order can be determined as the two suffixes goes to two difference branches (green and purple, respectively) at the end of the second unipath. (c) Owing to the property of dBG, two different unipaths must be different to each other at their first k-mers. Furthermore, if two different k-mers have the same precursor, their first (k-1) characters must be same to the last (k-1) characters of their precursor (the gray segments in the figure), i.e. the two branching k-mers are only different at their k-th character (the blocks marked as green and purple in the<ref type="figure">figure)</ref>. In this situation, it only needs to compare the k-th characters of two unipaths to determine if they are the same unipath. (d) With this property, the de Bruijn encoding, dE G , is defined as a string concatenating all such characters, G x þ k ½  ; x ¼ 0;. .. ; G j jÀ k À 1, along the DNA sequence, G, where the k-mer, KM G x , at the position x of G is a copy of a multiple-out vertex. Each of the G x þ k ½  s is also termed as a branching character (marked as colored blocks in the figure). And for a position j of G, / j ð Þ is defined as the position of Br j ð Þ on dE G , where Br j ð Þ is the branching character downstream and closest to the position j in S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>deBWT i177</head><p>Meanwhile, the multiple-out vertices can also be recognized during the merging, and deBWT records all the multiple-out vertices for building the de Bruijn branch encoding in the later step. The multiple-in vertices is then recognized based on the sorted (k þ 1)-mer list. That is, deBWT partitions the sorted (k þ 1)-mer list into four ordered lists, each corresponding to a specific initial character, A, C, G or T. Then deBWT recognizes all the multiple-in vertices by a four-way merging on the lists. During the merging, two tasks are done simultaneously, i.e. if a vertex is recognized as singlein, deBWT assigns it the first character of the corresponding (k þ 1)mer and the number of copies to solve the BWT part; otherwise, deBWT records the k-mer in another data structure to generate the / Á ð Þ function in the later step. It is worth noting that, owing to the existence of the auxiliary character #, deBWT recognizes all the k-mers that have at least one copy previous to and next to # as multiple-out and multiple-in k-mers, respectively. The parallelization of this step is straightforward. The k-mer counting can be directly parallelized (<ref type="bibr" target="#b23">Marc¸ais and Kingsford, 2011</ref>). There are many feasible parallel integer sorting approaches for sorting the (k þ 1)-mers and we used a simple approach, i.e. a radix sort is implemented to partition all the (k þ 1)-mers into blocks, and each of the blocks is further processed in parallel by integer quick sort. The merging of the k-mer lists is not executed in parallel; however, the cost is linear to the number of (k þ 1)-mers and not expensive.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">The generation of de Bruijn branch encoding and projection suffixes</head><p>DeBWT builds a hash table-based data structure, de Bruijn branch index, to index all multiple-in and multiple-out k-mers (Supplementary<ref type="figure" target="#fig_3">Fig. 2</ref>). With this index, the de Bruijn branch encoding and the / Á ð Þ function are simultaneously generated by scanning S one time. DeBWT initially allocates an empty string as dE S , a counter CdE S recording the length of dE S and a linear table, PdE S , which records the positions and the / Á ð Þ values for all the copies of the multiple-in k-mers (Supplementary<ref type="figure" target="#fig_3">Fig. 2</ref>). Each of the multiple-in k-mers occupies a series of cells of PdE S as a sub-table for their own copies. Each of the sub-table can be accessed with a specific pointer. DeBWT then scans S from upstream to downstream to check each of the k-mers. For a position i of S, if the corresponding k-mer, KM S i , is a multiple-in k-mer, deBWT records the character S i À 1 ½  and the value CdE S þ 1 À Á into the corresponding sub-table of PdE S ; if KM S i is a multiple-out k-mer, deBWT appends the branching character S i þ k ½  to dE S and updates CdE S. Here, S i À 1 ½  is the BWT character of KM S i , and CdE S þ 1 À Á is the / i ð Þ value, as the next branching character must be the first character of the projection suffix of KM S i , and CdE S þ 1 À Á is its position on dE S. The parallelization of this step is implemented as follows. DeBWT divides S into P segments, and assigns each of the segments to a specific thread to generate local dE S and / Á ð Þ values. The value P is equal to the number of threads. It is worth noting that all the threads share the same hash table and PdE S data structures with read-write locks, but have their own CdE S and dE S. When all the threads accomplish their own tasks, deBWT appends all the local dE S s and updates the local / Á ð Þ values generated by thread p 2 1; 2;. .. ; P f gby the following operation: assume the length of the dE S of the j-th segments is l dE j ; j 2 1; 2;. .. ; P f g , for each of multiple-in k-mers, KM S i , within the p-th segments (p &gt; 0), the corresponding / Á ð Þ value, / i ð Þ, is updated as / i ð Þ þ P pÀ1 j¼0 l dE j .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">BWT construction with projection suffixes</head><p>For each of the BWT parts corresponding to the multiple-in k-mers, deBWT constructs the SA of the projection suffixes with the dE S and the / Á ð Þ function. The SA is built by straightforwardly quick-sorting the involved projection suffixes. As all the unsolved parts are independent, it is also easy to accomplish the tasks in parallel. We did a modification on the recursive process of the original quick-sort method to improve the efficiency. That is, for a specific sub-array of suffixes transferred into the recursive function, deBWT checks whether all the suffixes have the same BWT characters at first. If this is the case, deBWT marks the sub-array as sorted, as the precise lexicographical order of these suffixes is not necessary for the BWT construction; otherwise, deBWT calls the original recursive function to further sort the sub-array. This modification can also be seen as an extension of Lemma 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Additional processing</head><p>After all the operations mentioned above, there are still N D Â k unsolved BWT characters, each corresponding to one of the suffixes, which start less than k positions before # or $. These suffixes are initially set aside, and deBWT builds the SA of such suffixes standalone to fill the BWT string. As there are only few such suffixes, this sorting is implemented by directly comparing the original sequences of the suffixes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head><p>We benchmarked deBWT with three datasets mimicking various real application scenarios. (i) A dataset consists of 10 in silico human genomes (totally 30.9 Gbp). Each of the genomes is generated by integrating the variants of a specific sample from 1000 Genomes (The 1000 Genomes Project<ref type="bibr" target="#b30">Consortium, 2015</ref>) into the human reference genome GRCh37/Hg19. This dataset mimics the indexing of multiple individual human genomes, which has many applications in genomic studies. (ii) A dataset consists of a set of simulated contigs. As long read sequencing technologies, such as Single Molecular Real-Time sequencing, have improved the contig N50 of human genome assembly to &gt;10 million bp (http://www. pacb.com/blog/toward-platinum-genomes-pacbio-releases-a-newhigher-quality-chm1-assembly-to-ncbi/), we randomly extracted 3000 sequences (each is about 10M bp long, totally 30.2 Gbp) from the 10 in silico human genomes with an in-house script, which is revised from Wgsim simulator (<ref type="bibr" target="#b17">Li et al., 2009b</ref>; https://github.com/ lh3/wgsim). (iii) A dataset consists of eight primate genomes including gibbon, gorilla, orangutan, rhesus, baboon, chimp, bonobo and human (downloaded from: http://hgdownload.soe.ucsc.edu/down loads.html). This dataset assessed the ability of deBWT to index more diverse genomes. The benchmark was implemented on a server with four Intel Xeon E4820 CPUs (32 cores in total) at 2.00 GHz and 1 Terabytes RAM, running Linux Ubuntu 14.04. DeBWT uses Jellyfish (version 2.1.4;<ref type="bibr" target="#b23">Marc¸ais and Kingsford, 2011</ref>) for implementing the k-mer counting of the input sequences (the parameter k is configured as 31). Two recently published methods, RopeBWT2 (<ref type="bibr" target="#b19">Li, 2014</ref>) and ParaBWT (version 1.0.8-binary-x86_64) (<ref type="bibr" target="#b21">Liu et al., 2014b</ref>), were also performed on the same datasets for comparison. At first, we tested the performance of deBWT with 32 threads, i.e. running with all the 32 CPU cores of the server. ParaBWT was also run with 32 threads, but RopeBWT2 was run with its default setting, as it does not support parallel computing. The elapsed time (<ref type="figure" target="#tab_1">Table 1</ref>) indicates that deBWT and ParaBWT have comparable speed, while RopeBWT2 is slower, likely owing to the fact that it does not support parallel computing and the algorithm could not be suited to long sequences. We further investigate the processing of deBWT, and found that the speed of deBWT was largely slowed down by Jellyfish owing to the format of its output file. The default output of Jellyfish is a binary file in an unpublished format. As the details about the format is unknown for us, we used the 'dump' command of Jellyfish to convert the output file into text file, and then converted the text file into binary file in our own format as the input of further steps. This file conversion costs a couple of hours for all the three datasets, i.e. about 60–70% of the total running time. The time cost would be much reduced if the output format of jellyfish was available, or if other k-mer counting tools with similar performance and readable output format were used. Deducting the time of file conversion, deBWT is much faster than the other two methods. We investigated the time cost of the various steps of deBWT (<ref type="figure" target="#tab_2">Table 2</ref>). Mainly, two issues are observed. First, most of the core steps of deBWT, i.e. k-mer counting, kmer sorting, de Bruijn branch encoding and / Á ð Þ values generation and projection suffixes sorting, are efficient. This is because of a couple of reasons. (i) The de Bruijn branch code greatly reduces the cost of sorting suffixes with long common prefixes. We investigated the lengths of the generated de Bruijn branch code, and found that, for both of the genomes and the contigs datasets, their lengths are respectively one order shorter than those of the original input sequences. Under this circumstance, the comparison between projection suffixes is much less expensive than that of the original suffixes. Furthermore, the k-mer partition of BWT also helps to reduce many unnecessary comparison operations. (ii) The designs of these steps are suitable for parallel computing, which can fully use the multiple CPU cores. It is worth noting that, besides the parallel implementation of the core steps of deBWT, the state-of-the-art k-mer counting tool also has good parallelization. As k-mer counting is still an open problem with wide application, there are a few choices for this step. We also tried a newer published tool, KMC2 (<ref type="bibr" target="#b6">Deorowicz et al., 2015</ref>), and obtained even faster speed (<ref type="figure" target="#tab_2">Table 2</ref>). However, KMC2 also outputs a binary file, which is hard to directly interpret. It would be beneficial if the state-of-the-art k-mer counting tools have an easy-to-interpret output file. (iii) Besides the parallelism, multiple steps, i.e. k-mer counting, the radix sort of k-mers, de Bruijn branch encoding and / Á ð Þ values generation, have quasi linear time complexity. Second, the I/O operation is the main issue slowing down the method. Other than the file conversion step mentioned above, there are also many I/O operations in the 'de Bruijn graph analysis' and the 'additional processing' steps. That is, in the dBG analysis step, deBWT needs to merge the files recording the four ordered lists of k-mers to recognize the multiple-in k-mers; and in the additional processing step, deBWT needs to convert the large sequences to be indexed from text (fasta format) into binary format and merge various BWT parts. Although these operations theoretically have low time complexity, they also depend on the performance of the file system of the computer as well as the implementation of the program.It is also an important future work for us to further optimize these operations. Other than the two issues mentioned above, the time cost of the projection suffixes sorting step is especially critical, as it is the core step to handle the long repetitions within the input sequence(s). The total time cost of this step is</p><formula>P U G j j j¼1 t U G j , where t U G j</formula><p>is the time for solving the j-th unsolved part of the BWT. As each of the unsolved parts are handled by quicksort, the time cost can be represented as follows (<ref type="bibr" target="#b1">Bentley and Sedgewick, 1997;</ref><ref type="bibr" target="#b13">Karkkainen, 2007</ref>):</p><formula>t U G j ¼ O N j logN j þ P Nj i¼1 DP PS i ð Þ !</formula><p>, where N j is the number of the projection suffixes involved in the unsolved part j, and DP PS i ð Þ is the length of the distinguishing prefix of the i-th projection suffix (denoted as PS i ) of the part. Here, the distinguishing prefix of PS i is the shortest prefix of PS i , which is necessary to determine the BWT characters of the corresponding part. For the highly similar input sequences, G 1 , G 2 ,. . ., G ND , the upper bound of DP PS i ð Þ is O dE GM À Á in theory, owing to the existence of long repetitions, where G M is the input sequence having the longest de Bruijn branch encoding, and dE GM is the length of the corresponding de Bruijn branch encoding. For example, two sequences G i and G j could be almost the same; thus, the length of distinguishing prefix could be close to the length of the de Bruijn branch encoding of the sequences. As the total number of the branching characters of G M , the value dE GM does not only depend on how many unipaths G M has, but also how many copies of the unipaths there are. Although the theoretical upper bound is large, however, DP PS i ð Þ also greatly depends on the distributions of genomic variations as well as the repetitiveness of the input sequences, which could make it lower in practice. To more precisely investigate the time cost, we assessed the DP j values and the DP M j values of the most repetitive dataset in the benchmark (i.e. the 10 human genomes dataset), where DP j and DP M j are respectively the mean and maximal length of the distinguishing prefix of the projection suffixes within the j-th unsolved part. A series of quantiles of DP j and DP M j values of the 10 human genomes dataset are shown in<ref type="figure" target="#tab_3">Table 3</ref>. These quantiles indicate that, for most of the blocks, the distinguishing prefixes are short, e.g. the 0.90 quantile of DP M j is 11 872, indicating that for 90% of the unsolved BWT parts, the max length of the distinguishing prefixes is shorter than 11 872 characters. This is not expensive to determine their lexicographical orders by a straightforward comparison. Thus, the overall cost of this step is not high, although there is still a small proportion (&lt;0.1%) of BWT parts having long distinguishing prefixes (average value is &gt; 298k). We also run deBWT with 8, 16, 24 threads to investigate its scalability. The results (<ref type="figure" target="#tab_4">Table 4</ref>) suggest that deBWT can gradually speedup with the increase of threads, i.e. it has good scalability. However, the speed of ParaBWT is nearly the same with the various settings on threads. This is likely owing to the incremental nature of the ParaBWT method, which may limit its performance on modern servers and clusters. The time of the various steps of deBWT with various numbers of threads is in<ref type="figure">Figure 3</ref>. It indicates that the two core steps, de Bruijn branch encoding and / Á ð Þ values generation and projection suffixes sorting (steps 4 and 5 in the figure), are most scalable steps, i.e. they speedup with the increasing number of threads. This property is beneficial for implementing the method with more computational resources. We further run deBWT on the in silico human genome dataset with various configurations on the k parameter to investigate its effect<ref type="figure" target="#tab_5">Table 5</ref>. It can be observed from the result that, on a large range of k parameters, i.e. k ¼ 23–31, the total running time is close, but for smaller k parameter, the time consumption is higher. This is likely owing to the fact that the moderate long k-mers (such as 23to 31-mers) may have similar ability to span short repeats. In this situation, the structure of the dBG does not change much with these k configurations, i.e. there are similar numbers of unipaths as well as their copies in the graph. However, when k is smaller, the unipaths will be shorter and have more copies, which would make the de Bruijn branch encoding longer and more projection suffixes need to be sorted. k &gt; 32 could have better ability to span repeats, which may improve the overall performance; however, it requires much more RAM space, as a k-mer cannot be stored by one 64-bits cell. The memory footprint of deBWT (<ref type="figure" target="#tab_6">Table 6</ref>) depends on both of the method itself and the used k-mer counting tool. The memory usage of Jellyfish and KMC2 is highly configurable, and we set them to use relatively large memory to accomplish the k-mer counting step as fast as possible. The major RAM costs of the three phases of deBWT are different. In the first phase, the major cost originates from the data structure of k-mer sorting. Briefly, deBWT uses a linear table like PdE S to bin all the k-mers; however, each cell of the table costs 16 bytes to record the string of the k-mer as well as its number of copies. The cost of the second phase is more complicated. It needs to simultaneously keep the input sequences, the de Bruijn branch index and the generated de Bruijn branch encoding in memory. Thus, the memory usage mainly depends on several issues, i.e. the size of the input sequence(s), the numbers of multiple-out and-in k-mers and the numbers of the copies of the multiple-out and-in kmers. The last two items respectively determine the length of de Bruijn branch encoding and the number of unsolved suffixes, which need to record in memory. The numbers of the multiple-out and-in k-mers and their copies highly relate to the repetitiveness of the input genomes. We did statistics on the two human datasets (as they are more repetitive), and observed two issues (<ref type="figure" target="#tab_7">Table 7</ref>).First, for both the datasets, the numbers of multiple-out and-in k-mers are much less than S j j, i.e. the number of characters of the input sequences. Thus, the cost of the hash table is not expensive comparing with the entire input sequences. Moreover, it is also worth noting that for highly similar genomes, the increment of the numbers of multiple-out and-in k-mers would be much smaller comparing with the increment of involved genomes, as there are many common sequences and they would not introduce new branches into the dBG. Second, the numbers of the copies of multiple-out and-in k-mers are also an order lower than S j j, although human genomes are repetitive. In this situation, the de Bruijn branch encoding can be seen as a DNA sequence an order shorter than S, so that the space cost is not large. The major cost originates from the copies of multiple-in k-mers, as it needs to record the / Á ð Þ value and the BWT character with a few bytes for each copy. The RAM cost of the third step is also similar to that of the second phase. To sort the projection suffixes, it needs to keep the de Bruijn branch encoding and the / Á ð Þ values and the BWT characters of the copies of the multiple-in k-mers in RAM.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discussion</head><p>The well organization and indexing of many genomes will be on wide demand in future genomics studies, with the rapid increase of assembled genomes. As an important genome indexing data structure, BWT may have many applications; however, the construction of BWT for a large collection of genomes, especially highly similar re-sequenced genomes (e.g. many human individual genomes), is still a non-trivial task. Moreover, owing to the incremental nature of the state-of-the-art methods, it is hard to construct BWT with scalable parallel computing. This is a bottleneck to fully use the computational resources of modern servers or clusters to handle large amount of data. We propose deBWT, a novel parallel BWT construction approach, to break the bottleneck. The main contribution of deBWT is its dBG-based representation and organization of suffixes, which facilitates the comparison of suffixes with long common prefixes and avoid unnecessary comparisons. Moreover, owing to its nonincremental design, deBWT has good scalability to various computational resources. These properties make deBWT well-suited to construct BWT for large collections of highly similar or repetitive genomes with modern servers or clusters. In the experiments, deBWT achieves a substantial improvement on the speed of indexing multiple individual human genomes and contigs. For more diverse genomes, e.g. multiple primate genomes, deBWT also shows faster speed and better parallelization; however, the improvement is smaller, likely owing to that the density of the dBG is lower. That is, there are more k-mers and unipaths to handle, but the overall repetitiveness of the input is lower than highly similar genomes. Comparing with state-of-the-art approaches, deBWT has obviously larger memory footprint. There are potential solutions to reduce the memory footprints of the various phases of deBWT. For phase 1, it is feasible to bin the k-mers into several subsets and separately sort each of the subsets with limited memory. The<ref type="figure">Fig. 3</ref>. Time consumption of the various steps of deBWT. The bars respectively indicate the elapsed time (in minutes) of the various steps of deBWT for the 10 human genomes dataset (a), the human genome contig dataset (b) and the 8 primate genomes dataset (c). Bars in the same color correspond to a specific number of threads, i.e. blue, red, green and purple bars are respectively for 8, 16, 24 and 32 threads'DeBWT' indicates the elapsed time of deBWT, and 'deBWT (no conversion)' deducts the time of the format conversion of Jellyfish output file.For the 'x/y/z' of deBWT in the memory columns, the x, y and z values respectively indicate the memory footprints of Jellyfish, phase1 of deBWT, and phases2 and phases3 of deBWT. results of the multiple subsets can be straightforwardly merged into the ordered list of all the k-mers with small memory space. For phase 2, it is also possible to reduce the memory footprint by keeping only a proportion of / Á ð Þ values and BWT characters, which can be implemented with the following strategy. Because all the multiple-in k-mers and their numbers of copies are known before the second phase, it can partition the whole set of multiple-in k-mers into several subsets. Each of the subsets has a limited number of k-mer copies. Thus, the second phase can be done with multiple times of scanning on the input sequences, instead of one time. In each time of scanning, only the copies of the multiple-in k-mers within the corresponding subset are recognized, recorded and output to a specific file with limited RAM space. As all the subsets are independent to each other for the third phase, the files of the subsets can be separately processed to generate various parts of BWT. Further, the BWT parts can be directly merged to accomplish the construction. This strategy is feasible to limited workspace, but at the expense of time owing to the fact that it needs multiple executions of phase 2. For phase 3, it can also keep only a proportion of unsolved of BWT partitions in memory as all such partitions are independent. There are two possible improvements on deBWT, which are important future works for us. First, deBWT straightforwardly sorts the projection suffixes by quick-sort. Because the de Bruijn branch encoding can be also seen as a special DNA sequence, it is also possible to use other approaches to further accelerate the projection suffix sorting step. For example, the method proposed by Karkkainen (2007) uses DCS to accelerate the sorting of the binned suffixes of the original input sequence. This method could be also used for sorting the binned projection suffixes without loss of the ability of parallel computing, as it is non-incremental. Second, for the current version of deBWT, the I/O-intensive steps are still not optimized, which slowed down the speed. We plan to further optimize the I/O-intensive steps to improve the efficiency of deBWT. Meanwhile, as k-mer counting is still an open problem, and advanced k-mer counting tools are developing (<ref type="bibr" target="#b26">Perez et al., 2016</ref>), we also plan to replace Jellyfish by other more advanced k-mer counting tools, or remove the file conversion step by directly accessing the default Jellyfish output file, to break the practical bottleneck of the method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>sequence can be represented by an ordered list of the unipaths of the dBG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>Corollary 1: Each of the suffixes can be represented as an ordered list of unipaths, or a substring of a specific unipath appending an ordered list of unipaths.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.1.</head><figDesc>Fig. 1. The unipath-based comparison between two suffixes with the same initial k-mer. (a) Because all the copies of the same k-mers collapse to the same vertex of the dBG, two suffixes, Suf G i and Suf G j with the same initial k-mer must link to the same offset of the same unipath (the copies of the unipaths on the DNA sequence are marked by segments with various colors). Thus, the lexicographical order of the two suffixes cannot be determined until the comparison reaches the end of the unipath, as all the corresponding characters of the two suffixes are same to each other. (b) When the comparison goes to new unipaths from the finished (same) unipath, the lexicographical order can be determined only if the two suffixes have two different unipaths on the corresponding positions of their unipath representation, otherwise, more unipaths are needed. In this case, both of the two suffixes have the same unipath (the red unipath) successive to the first unipath (the blue unipath), so that the comparison continues to the third unipaths. For the third unipath, the lexicographical order can be determined as the two suffixes goes to two difference branches (green and purple, respectively) at the end of the second unipath. (c) Owing to the property of dBG, two different unipaths must be different to each other at their first k-mers. Furthermore, if two different k-mers have the same precursor, their first (k-1) characters must be same to the last (k-1) characters of their precursor (the gray segments in the figure), i.e. the two branching k-mers are only different at their k-th character (the blocks marked as green and purple in the figure). In this situation, it only needs to compare the k-th characters of two unipaths to determine if they are the same unipath. (d) With this property, the de Bruijn encoding, dE G , is defined as a string concatenating all such characters, G x þ k ½  ; x ¼ 0;. .. ; G j jÀ k À 1, along the DNA sequence, G, where the k-mer, KM G x , at the position x of G is a copy of a multiple-out vertex. Each of the G x þ k ½  s is also termed as a branching character (marked as colored blocks in the figure). And for a position j of G, / j ð Þ is defined as the position of Br j ð Þ on dE G , where Br j ð Þ is the branching character downstream and closest to the position j in S.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.2.</head><figDesc>Fig. 2. A schematic illustration of the deBWT method. (a) DeBWT initially builds a dBG of the input sequence(s) with a user-defined parameter, k, which determines the size of the vertices. The dBG is then analyzed to build the k-mer partition of the BWT and recognize all the unipaths (the colored bars in the figure indicate the copies of various unipaths of the input sequence). With the unipaths, all the multiple-in and multiple-out vertices are indexed by a hash table-based data structure, de Bruijn branch index. Moreover, all the multiple-in vertices are marked. In this case, the red block indicates the first k-mer of the 'red' unipath of the dBG which is a multiple-in vertex, and the grey and the white blocks respectively indicate other multiple-in and-out k-mers. (b) DeBWT scans the input sequence(s) to recognize the branching characters with de Bruijn branch index (marked as colored reverse rectangles above the input sequence) and generate the de Bruijn branch encoding. Meanwhile, the suffixes with initial k-mers corresponding to multiple-in vertices, i.e. the suffixes belonging to the unsolved parts of the BWT, are also recognized with the index (marked as colored rectangles below the input sequence). Furthermore, for each of the suffixes within the unsolved parts, deBWT calculates its / Á ð Þ value to determine the corresponding projection suffix and also recorded it into the de Bruijn branch index. (c) With de Bruijn branch index, deBWT addresses all the unsolved BWT parts by sorting the projection suffixes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><figDesc>work has been partially supported by the National Nature Science Foundation of China (Nos: 61301204 and 31301089), the National HighTech Research and Development Program (863) of China (Nos: 2015AA020101, 2015AA020108 and 2014AA021505) and the National Science and Technology Major Project (No: 2013ZX03005012). Conflict of Interest: none declared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>V C The Author 2016. Published by Oxford University Press.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><figDesc>Table 1. Running Time with 32 CPU cores (in minutes)</figDesc><table>Methods 
Human 
genomes 

Human 
contigs 

Primate 
genomes 

deBWT 
134 
129 
330 
deBWT (no conversion) 
48 
56 
100 
ParaBWT 
241 
262 
180 
RopeBWT2 
1694 
2247 
1546 

'DeBWT' indicates the elapsed time of deBWT, and 'deBWT (no conver-
sion)' deducts the time of the format conversion of Jellyfish output. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 2. The time of the various steps of deBWT (in minutes)</figDesc><table>Steps 
Human 
genomes 

Human 
contigs 

Primate 
genomes 

Phase1: dBG building and analysis 
k-mer counting 
16 
16 
26 
File conversion 
87 
74 
229 
k-mer sorting 
3 
3 
8 
dBG analysis 
8 
7 
19 
Phase2: The generation of 
de Bruijn branch encoding 
and projection suffixes 
de Bruijn branch encoding and 
/ Á 
ð Þ values generation 

9 
1 2 
1 6 

Phase3: BWT construction with 
projection suffixes 
Projection suffixes sorting 
4 
12 
10 
Additional processing 
Additional processing 
7 
6 
22 
Supplement 
k-mer counting with KMC2 
7 
9 
12 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>Table 3. Quantiles of DP j and DP M</figDesc><table>j 

values of the 10 human gen-
omes dataset 

Quantiles 0.50 0.90 
0.95 
0.99 
0.999 
0.9999 

DP j 
107 
588 
2382 
95 019 
298 598 
515 006 
DP M 

j 

1760 11 872 238 368 1 925 600 3 232 832 3 387 040 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Table 4.</figDesc><table>Running time with various numbers of threads (in 
minutes) 

Methods 
8 threads 16 threads 24 threads 32 threads 

Human genomes 
deBWT 
194 
153 
142 
134 
deBWT (no conversion) 
109 
68 
56 
48 
ParaBWT 
265 
240 
240 
241 
Human contigs 

deBWT 
183 
154 
123 
129 
vdeBWT (no conversion) 
116 
86 
56 
56 
ParaBWT 
294 
277 
276 
262 
Primate genomes 
deBWT 
423 
355 
332 
330 
deBWT (no conversion) 
193 
125 
105 
100 
ParaBWT 
196 
182 
181 
180 </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><figDesc>Table 5. Running time of the in silico human genome dataset with various configurations on the k parameter (in minutes)</figDesc><table>Methods 
k ¼ 19 
k ¼ 23 
k ¼ 27 
k ¼ 31 

deBWT 
142 
124 
131 
134 
deBWT (no conversion) 
75 
51 
47 
48 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="true"><figDesc>Table 6. Memory footprints with 32 CPU cores (in Gigabytes)</figDesc><table>Methods 
Human genomes 
Human contigs 
Primate genomes 

deBWT 
120/78/38 
120/63/34 
235/203/58 
ParaBWT 
30 
30 
29 
RopeBWT2 
30 
24 
40 
Supplement 
KMC2 
119 
119 
119 

</table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="2">.2.3 The k-mer partition of BWT According to the definition of SA, the suffixes starting with identical k-mers (suppose it as KM i ) constitute a continuous block in SA, as a suffix with a different initial k-mer (e.g. KM j ) must be larger or smaller than all the suffixes starting with KM i. Thus, given D G , the BWT of S can be partitioned into D G  þ k parts. D G  of them correspond to the D G  k-mers of D G , i.e. each of the D G  parts involves all the suffixes with a specific k-mers of D G ; and each of the remaining k parts corresponds to a specific suffix whose starting position is less than k bp previous to the end of S. This partition (called k-mer partition of BWT) can be constructed in two steps: (i) sort all the k-mers of D G and the last k suffixes of S by their lexicographical order; (ii) bin all the &gt; k bp long suffixes of S into the i176 B.Liu et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">&apos;DeBWT&apos; indicates the elapsed time of deBWT, and &apos;deBWT (no conversion)&apos; deducts the time of the format conversion of Jellyfish output file. i180 B.Liu et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Lightweight algorithms for constructing and inverting the bwt of string collections</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">J</forename>
				<surname>Bauer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">483</biblScope>
			<biblScope unit="page" from="134" to="148" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Fast algorithms for sorting and searching strings</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">L</forename>
				<surname>Bentley</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Sedgewick</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th Annual Symposium on Discrete Algorithms ACM</title>
		<meeting>the 8th Annual Symposium on Discrete Algorithms ACM<address><addrLine>San Francisco, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title level="m" type="main">A block-sorting lossless data compression algorithm</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Burrow</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Wheeler</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<pubPlace>Digital Equipment Corporation, California</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Poster abstract: hypothesis-free detection of splice junctions in RNA-Seq data</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">J</forename>
				<surname>Cox</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of CSHL conference on Genome Informatics. Spring Harbor</title>
		<meeting>CSHL conference on Genome Informatics. Spring Harbor<address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Large-scale compression of genomic sequence databases with the Burrows-Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">J</forename>
				<surname>Cox</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1415" to="1419" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">A theoretical and experimental study on the construction of suffix arrays in external memory</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Crauser</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="1" to="35" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">KMC 2: fast and resource-frugal k-mer counting</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Deorowicz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="31" to="1569" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Opportunistic data structures with applications</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 41st Annual Symposium on Foundations of Computer Science (FOCS). Redondo Beach, California</title>
		<meeting>41st Annual Symposium on Foundations of Computer Science (FOCS). Redondo Beach, California</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="390" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Indexing compressed text</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="552" to="581" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Lightweight data indexing and compression in external memory</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">63</biblScope>
			<biblScope unit="page" from="707" to="730" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">High-quality draft assemblies of mammalian genomes from massively parallel sequence data</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Gnerre</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl. Acad. Sci. USA</title>
		<meeting>. Natl. Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1513" to="1518" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Practical aspects of compressed suffix arrays and FMIndex in searching DNA sequences</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">K</forename>
				<surname>Hon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Sixth Workshop on Algorithm Engineering and Experiments and the First Workshop on Analytic Algorithmics and Combinatorics</title>
		<meeting>the Sixth Workshop on Algorithm Engineering and Experiments and the First Workshop on Analytic Algorithmics and Combinatorics<address><addrLine>New Orleans, LA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="31" to="38" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Constructing compressed suffix arrays with large alphabets</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">K</forename>
				<surname>Hon</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">48</biblScope>
			<biblScope unit="page" from="23" to="36" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Fast BWT in small space by blockwise suffix sorting</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Karkkainen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">387</biblScope>
			<biblScope unit="page" from="249" to="257" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Compressed indexing and local alignment of DNA</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">W</forename>
				<surname>Lam</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="791" to="797" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with Bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with Burrows-Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">The sequence alignment/map format and SAMtools</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2078" to="2079" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Exploring single-sample snp and indel calling with wholegenome de novo assembly</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1838" to="1844" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Fast construction of FM-index for long sequence reads</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="3274" to="3275" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<monogr>
		<title level="m" type="main">GPU-accelerated BWT construction for large collection of short reads</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Liu</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Parallel and space-efficient construction of BurrowsWheeler transform and suffix array for big genome data</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Liu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
	<note>in. press</note>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Storage and retrieval of highly repetitive sequence collections</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Makinen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comp. Biol</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="281" to="308" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Marc¸ais</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Kingsford</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="764" to="770" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">SplitMEM: a graphical algorithm for pan-genome analysis with suffix skips</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Marcus</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="3476" to="3483" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Suffix array construction in external memory using d-critical substrings</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Nong</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Inform. Syst</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Computational performance assessment of k-mer counting algorithms</title>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Perez</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comp. Biol</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="248" to="255" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of large genomes using compressed data structures</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="549" to="556" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">A taxonomy of suffix array construction algorithms</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">F</forename>
				<surname>Smyth</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">H</forename>
				<surname>Turpin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">The 1000 Genomes Project Consortium (2015) A global reference for human genetic variation</title>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">526</biblScope>
			<biblScope unit="page" from="68" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">The UK10K project identifies rare variants in health and disease</title>
		<author>
			<persName>
				<forename type="first">Uk10k</forename>
				<surname>The</surname>
			</persName>
		</author>
		<author>
			<persName>
				<surname>Consortium</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">526</biblScope>
			<biblScope unit="page" from="82" to="90" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<monogr>
		<title level="m" type="main">Safe and complete contig assembly via omnitigs</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">I</forename>
				<surname>Tomescu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Medvedev</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2016" />
			<publisher>LNBI</publisher>
			<biblScope unit="page" from="152" to="163" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">Repetitive DNA and next-generation sequencing: computational challenges and solutions</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">J</forename>
				<surname>Treangen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Rev. Genet</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="36" to="46" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">Illuminating the future of DNA sequencing</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Watson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page">108</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">The MaSuRCA genome assembler</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">V</forename>
				<surname>Zimin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="2669" to="2677" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Liu</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>