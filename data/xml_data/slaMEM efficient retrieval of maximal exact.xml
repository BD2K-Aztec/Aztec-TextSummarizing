
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:56+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Sequence analysis slaMEM: efficient retrieval of maximal exact matches using a sampled LCP array</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Francisco</forename>
								<surname>Fernandes</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Instituto de Engenharia de Sistemas e Computadores Investigaç a</orgName>
								<orgName type="laboratory">Knowledge Discovery and Bioinformatics Group (KDBIO)</orgName>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Ana</forename>
								<forename type="middle">T</forename>
								<surname>Freitas</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Instituto de Engenharia de Sistemas e Computadores Investigaç a</orgName>
								<orgName type="laboratory">Knowledge Discovery and Bioinformatics Group (KDBIO)</orgName>
							</affiliation>
							<affiliation key="aff2">
								<orgName type="department">Department of Computer Science and Engineering</orgName>
								<orgName type="institution" key="instit1">Instituto Superior Té cnico (IST) – Universidade de Lisboa</orgName>
								<orgName type="institution" key="instit2">Avenida Rovisco Pais</orgName>
								<address>
									<postCode>1049-001</postCode>
									<settlement>Lisbon</settlement>
									<country key="PT">Portugal</country>
								</address>
							</affiliation>
						</author>
						<author>
							<affiliation key="aff1">
								<orgName type="department">Desenvolvimento (INESC-ID)</orgName>
								<orgName type="institution">Rua Alves Redol</orgName>
								<address>
									<postCode>1000-029</postCode>
									<settlement>Lisbon</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Sequence analysis slaMEM: efficient retrieval of maximal exact matches using a sampled LCP array</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="issue">4</biblScope>
							<biblScope unit="page" from="464" to="471"/>
							<date type="published" when="2014">2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btt706</idno>
					<note type="submission">Received on August 11, 2013; revised on November 20, 2013; accepted on November 28, 2013</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Associate Editor: Martin Bishop Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Maximal exact matches, or just MEMs, are a powerful tool in the context of multiple sequence alignment and approximate string matching. The most efficient algorithms to collect them are based on compressed indexes that rely on longest common prefix array-centered data structures. However, their space-efficient representations make use of encoding techniques that are expensive from a computational point of view. With the deluge of data generated by high-throughput sequencing, new approaches need to be developed to deal with larger genomic sequences. Results: In this work, we have developed a new longest common prefix array-sampled representation, optimized to work with the backward search method inherently used by the FM-Index. Unlike previous implementations that sacrifice running time to have smaller space, ours lead to both a fast and a space-efficient approach. This implementation was used by the new software slaMEM, developed to efficiently retrieve MEMs. The results show that the new algorithm is competitive against existing state-of-the-art approaches. Availability and implementation: The software is implemented in C and is operating system independent. The source code is freely available for download at http://sydney.edu.au/science/biology/meep/softwarel.
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>With the new high-throughput sequencing technologies becoming faster, cheaper and more accurate, the number of available genomes is growing fast. Metagenomics is also pushing forward the need to align new sequences to those already known to compare different strains or assemblies, build phylogenetic trees, identify new genes, identify mutations or polymorphisms, observe structural variations and perform other relevant operations. It is well known that dynamic programming approaches are prohibitive, both in terms of required memory and processing time, when aligning large genomes or a number of different genomes. To approach these problems, strategies using seeded alignments with shared segments, which are identical among the sequences and act as anchor points for the alignment, have been developed. These anchors can be fixed-length exact matches, or k-mers, as those used in the BLAST (<ref type="bibr" target="#b2">Altschul et al., 1990</ref>) tool. However, this type of match is inefficient because it can lead to an oversized number of hits, and these still have to be extended in both directions using pairwise comparisons, implying a significant processing time. Much more efficient is the identification of maximal unique matches (MUMs) that have been introduced first by<ref type="bibr">MUMmer (Delcher et al., 1999</ref>). MUMs are identical substrings that occur exactly once in each sequence and whose occurrences cannot be extended to either side without producing a mismatch. The second version of MUMmer (<ref type="bibr" target="#b7">Delcher et al., 2002</ref>) introduced a new more compact suffix tree (ST) representation, and the third and last one (<ref type="bibr" target="#b22">Kurtz et al., 2004</ref>) added the ability to output maximal exact matches (MEMs). These are similar to MUMs but can occur any number of times, which is useful when the number of MUMs is insufficient to produce enough anchors for a solid alignment, e.g. when many repeated regions exist. Also, using MEMs instead of MUMs multiplies the regions covered by anchors, reducing considerably the areas requiring further processing. However, the bottleneck of MUMmer is the memory requirements of its ST index structure, which can become problematic when it does not fit into the main memory. Other closedsource tools based on enhanced suffix arrays (ESAs) such as Vmatch (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref>) and CoCoNUT (<ref type="bibr" target="#b1">Abouelhoda et al., 2008</ref>) have also been released, but they share the same problem. For this reason, and to deal with larger sequences, other approaches to find MEMs have been developed. The sparseMEM approach (<ref type="bibr" target="#b17">Khan et al., 2009</ref>) makes use of a sparse SA as an index, which trades memory space for extra computational time. Later, backwardMEM (<ref type="bibr" target="#b27">Ohlebusch et al., 2010</ref>) used a backward search method over a compressed ESA. More recently, essaMEM (<ref type="bibr" target="#b33">Vyverman et al., 2013</ref>) improved sparseMEM by enhancing it with a sparse child array that reduces computational time maintaining the same memory footprint. This method currently shows the best tradeoff between time and memory consumption for MEM identification. In this work, we propose another approach as an alternative to these previous tools. We have developed a new sampled representation of the longest common prefix (LCP) array, optimized to work with the backward search method inherent from the *To whom correspondence should be addressed. FM-Index. Results show the effectiveness of the new method for a number of different genomes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Basic notions</head><p>STs (<ref type="bibr" target="#b35">Weiner, 1973</ref>) are fundamental data structures in the field of string processing. However, despite being linear (<ref type="bibr" target="#b31">Ukkonen, 1995</ref>), their space requirements are large. Consequently, they have been progressively replaced by SAs (<ref type="bibr" target="#b24">Manber and Myers, 1993</ref>) and more recently by more space-efficient Burrows– Wheeler Transform (BWT) (<ref type="bibr" target="#b3">Burrows and Wheeler, 1994</ref>)-based indexes, namely, the FM-Index (<ref type="bibr" target="#b8">Ferragina and Manzini, 2000</ref>). Although these more advanced indexes work just fine for standard pattern matching, they lack certain functionalities originally present in STs, including the possibility to follow suffix links. To overcome these limitations, other data structures have been proposed, like the ESA (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref>), which extends the original SA with additional information to simulate the behavior of STs. Other alternatives are reviewed in (Navarro and Ma¨kinenMa¨kinen, 2007) and (<ref type="bibr" target="#b32">Vyverman et al., 2012</ref>). Let AE ¼ { 1 ,. .. , jAEj } be a finite ordered alphabet, and AE* be the set of all strings over AE, including the empty string ". Let T be a string or text over AE*, which is always terminated by a special character $, which is lexicographically smaller than any character in AE and does not occur anywhere else in T. Let T<ref type="bibr">[i]</ref>denote the character at position i in T, for 0 i5n, where n ¼ jTj. This way, we define T[i. .. j] as the substring of length (j À i þ 1) starting at the ith position and ending at the jth position of T, where 0 i j5n. We call T i the ith suffix of T, i.e. the substring T[i. .. (n À 1)], with 0 i5n. In the same way, the substring T[0. .. i], 0 i5n corresponds to a prefix of T.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">STs and SAs</head><p>The ST of T is a rooted tree that represents all the non-empty suffixes of T in the following compact way. Each node has a label corresponding to a substring that occurs in T. The special top node is called the root and corresponds to the empty string. Each internal node has at least two children, and no two children branching from the same node can have labels starting with the same character. Each node can also be identified by its path label, i.e. the string obtained by concatenating all the node labels on the path from the root down to that node. The tree has exactly n leaves, corresponding to the n suffixes of T, where the path label of the ith leaf spells the ith suffix. A suffix link is a pointer that connects a node to its subsequent suffix node, i.e. it associates each node with path label !, such that 2AE and !2AE*, to the node whose path label is !. The SA of T is an array of size n of numbers corresponding to the lexicographical ordering of the n suffixes of T, i.e. a permutation of the integers {0,. .. ,(n À 1)} such that T SA<ref type="bibr">[0]</ref>5 T SA<ref type="bibr">[1]</ref>5.. .5T SA<ref type="bibr">[nÀ1]</ref>. The SA takes O[n*log(n)] bits of space and can be built using linear time and space (Ka¨rkkaïnen<ref type="bibr" target="#b15">Ka¨rkkaïnen and Sanders, 2003;</ref><ref type="bibr" target="#b18">Kim et al., 2003;</ref><ref type="bibr" target="#b19">Ko and Aluru, 2003;</ref><ref type="bibr" target="#b26">Nong et al., 2009</ref>). Taking advantage of the SA as an index structure, a pattern P can be matched in O[m*log(n)] time using binary search. The term !-interval (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref>) is often used to denote the interval in the index obtained from matching the string !.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">BWT and FM-Index</head><p>The BWT of T is a permutation of the characters of T such that BWT<ref type="bibr">[i]</ref>corresponds to the character preceding the ith lexicographically ordered rotation of T, i.e. BWT<ref type="bibr">[i]</ref>¼ T[SA<ref type="bibr">[i]</ref>À1] if SA<ref type="bibr">[i]</ref>6 ¼ 0 and BWT<ref type="bibr">[i]</ref>¼ $ otherwise. If we consider the conceptual matrix M consisting of all the sorted rotations of T, the BWT array corresponds to the last column of M. In the example of<ref type="figure">Figure 2</ref>, the BWT of the previously illustrated string (<ref type="figure" target="#fig_0">Fig. 1</ref>) is 'TCACCG$GAATAGC'. The BWT array takes O[n*log(jAEj)] space and can be constructed in linear time and space, e.g. using the induced sorting approach from Okanohara and Sadakane (2009), among others. Using the BWT together with some extra information, we can build another index structure called the FM-Index (<ref type="bibr" target="#b8">Ferragina and Manzini, 2000</ref>). One of its key concepts is the Last-to-First column mapping (LF-mapping), which finds, for each position i, the position j such that SA[j] ¼ (SA<ref type="bibr">[i]</ref>À 1) (mod n). Like the name suggests, it simply maps the kth occurrence of each symbol in the last column L to the kth occurrence of the same symbol in the first column F. In other words, and noting that the BWT is in fact the last column L, if L<ref type="bibr">[i]</ref>¼ BWT<ref type="bibr">[i]</ref>¼ T[(SA<ref type="bibr">[i]</ref>À 1)(mod n)] ¼ c is the kth occurrence of the character c in the last column L, then we will have LF<ref type="bibr">[i]</ref>¼ j where F<ref type="bibr">[j]</ref>¼ T[SA<ref type="bibr">[j]</ref>] ¼ c is the kth occurrence of the same character in the first column F. For the example in<ref type="figure">Figure 2</ref>, LF<ref type="bibr">[0]</ref>¼ 12 for character 'T' and LF<ref type="bibr">[1]</ref>¼ 5 for character 'C'. The LF-mapping can be efficiently computed by setting: LF<ref type="bibr">[i]</ref>¼ C<ref type="bibr">[c]</ref>þ occ(c,i) À 1, where: c ¼ BWT<ref type="bibr">[i]</ref>C<ref type="bibr">[c]</ref>is the total number of occurrences in T of all the characters strictly smaller than c occ(c,i) is the number of occurrences of c in BWT[0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.. i]</head><p>Pattern matching on a pattern P of size m is done in O(m) time according to the BackwardSearch procedure (<ref type="bibr" target="#b9">Ferragina and Manzini, 2005</ref>) detailed in the Supplementary Material. The search is performed backward by iteratively applying the LF-mapping rule to obtain the P[i. . .Because the BWT stores characters and not numbers, the FMIndex space requirements of O(n*log(jAEj)) are much lower than those of ST and SA, O(n*log(n)). More specifically, these values are typically $10*n–20*n bytes for ST and 5*n bytes for SA, assuming 32-bit integers (Kurtz, 1999).</p><formula>(m À 1)]-interval from the P[(i þ 1). .. (m À 1)]-interval, for 0 i5(m À 1).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.4">LCP array and lcp-intervals</head><p>The ESA can simulate all the functionality of the original ST while improving the SA's pattern matching time to O(m), and consists of the basic SA augmented with two additional structures, the LCP array and the lcp interval tree represented by a child table. The LCP of T is an array of numbers with size n that stores the length of the lcp between each suffix and the previous one, i.e. LCP<ref type="bibr">[i]</ref>¼ j lcp(T SA<ref type="bibr">[iÀ1]</ref>, T SA<ref type="bibr">[i]</ref>) j for 05i n LCP<ref type="bibr">[0]</ref>¼ (À1)</p><p>It can be built in both linear time and space using the SA (<ref type="bibr" target="#b16">Kasai et al., 2001</ref>). An lcp-interval with lcp-value l is named an l-interval and is denoted by l À<ref type="bibr">[i,j]</ref>, where 0 i5j (nÀ1) and the following properties hold: LCP<ref type="bibr">[i]</ref>5 l LCP<ref type="bibr">[k]</ref>! l for all k with (i þ 1) k j LCP<ref type="bibr">[k]</ref>¼ l for at least one k with (i þ 1) k j LCP<ref type="bibr">[jþ1]</ref>5 l if j 6 ¼ (nÀ1)</p><p>Consequently, if we have an lcp-interval l À<ref type="bibr">[i,j]</ref>, this means that the substring T[(SA<ref type="bibr">[i]</ref>). .. (SA<ref type="bibr">[i]</ref>þ l À 1)] of size l is the longest common prefix between all the (j À i þ 1) suffixes T SA<ref type="bibr">[i]</ref>.. . T SA<ref type="bibr">[j]</ref>of that SA interval. Note that because the lcp is calculated between the current SA position and its predecessor, the first position i of an lcp-interval l À<ref type="bibr">[i,j]</ref>always has an lcp-value lower than l. In this way, it is sometimes useful to refer to the depth of an interval or a single position, which for an lcp-interval l À<ref type="bibr">[i,j]</ref>is always l, but for a general !-interval given by<ref type="bibr">[i,j]</ref>, it can be obtained from the LCP as:</p><p>Depth(<ref type="bibr">[i, j]</ref>) ¼ max{LCP<ref type="bibr">[i]</ref>, LCP</p><formula>[i þ 1]}, if i ¼ j min{LCP[i þ 1], LCP[j]}, if i 6 ¼ j</formula><p>The parent interval of an lcp-interval l À [i,j] is an lcp-interval q À<ref type="bibr">[r,s]</ref>such that q5l, r i and s ! j, and there is no other lcpinterval of lcp-value t enclosing l À [i,j] such that q5t5l. Therefore, it corresponds to the first larger lcp-interval that encloses l À<ref type="bibr">[</ref>PSV<ref type="bibr">[i]</ref>¼ max{k:(0 k 5 i and LCP<ref type="bibr">[k]</ref>5 LCP<ref type="bibr">[i]</ref>) or k ¼ 0} NSV<ref type="bibr">[i]</ref>¼ min{k:(i5 k n and LCP<ref type="bibr">[k]</ref>5 LCP<ref type="bibr">[i]</ref>) or k ¼ n} As their names suggest, the PSV/NSV arrays contain the first position above/below in the LCP array that has an lcp-value lower than the current one, respectively. Because in an lcp-interval l À<ref type="bibr">[i,j]</ref>the nearest lcp-values lower than l are located at LCP<ref type="bibr">[i]</ref>and LCP<ref type="bibr">[j þ 1]</ref>, its first enclosing interval will have an lcp-value equal to the higher of these two values. Therefore, the resulting parent interval is defined by:</p><p>Parent(l À<ref type="bibr">[i,j]</ref>) ¼ (LCP<ref type="bibr">[k]</ref>) À [PSV<ref type="bibr">[k]</ref></p><formula>, (NSV[k] À 1)], with k ¼ i, if LCP[i] ! LCP[j þ 1] k ¼ j þ 1, if LCP[j þ 1] 4 LCP[i]</formula><p>Some illustrative lcp-intervals in<ref type="figure" target="#fig_2">Figure 3</ref>make this more clear, e.g. the parent of the 3À<ref type="bibr">[6,</ref><ref type="bibr">7]</ref>interval, corresponding to the 'CAG'-interval, is the 2À<ref type="bibr">[5,</ref><ref type="bibr">7]</ref>interval corresponding to the 'CA'-interval, and lcp-interval 3À<ref type="bibr">[9,</ref><ref type="bibr">10]</ref>has 1À<ref type="bibr">[9,</ref><ref type="bibr">11]</ref>as parent, coinciding with the 'GCA' and 'G' intervals, respectively. From the parent/child relations of the lcp-intervals, an lcpinterval tree can also be built to simulate the topography of the ST. Instead of pre-computing and storing the PSV/NSV arrays explicitly, they can also be calculated on the fly using Range Minimum Queries (RMQ) (<ref type="bibr" target="#b11">Fischer and Heun, 2007</ref>) that rely on other auxiliary data structures. Although many applications exist that use these last two methods, they have not been applied in this work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.5">LCP array representations</head><p>Some direct representations of the LCP include storing each value using only 1 byte with the larger values going in a separate array (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref>), or encoding it with a wavelet<ref type="figure">Fig. 2</ref>. Matrix of all the rotations of the string CAGCAACTGCAGT$ evidencing its BWT, the first and last columns F and L and the counts of each alphabet character c along the BWT in occ(c,i). The last characters of the rotations are grayed out to show the difference from each corresponding suffix<ref type="bibr">[j]</ref>¼ i gives the position i in the SA where the text position j is stored, i.e. SA<ref type="bibr">[i]</ref>¼ j. This means that if we rearrange the LCP entries in text order rather than lexicographic order, the values decrease by at most 1. From this observation, a new array of size n defined by Hgt<ref type="bibr">[j]</ref>¼ (j þ LCP[SA À1<ref type="bibr">[j]]</ref>) and composed entirely of nondecreasing integers can be constructed and stored using only 2n þ O(n) bits, with a special data structure used to encode sorted numbers. Given SA<ref type="bibr">[i]</ref>¼ j, LCP<ref type="bibr">[i]</ref>can then be derived from Hgt<ref type="bibr">[j]</ref>. This method of storing the LCP in text order and not in SA order originated the concept of the permuted longestcommon-prefix array (Ka¨rkkaïnen<ref type="bibr" target="#b14">Ka¨rkkaïnen et al., 2009</ref>) defined by PLCP<ref type="bibr">[j]</ref>¼ LCP[SA À1<ref type="bibr">[j]</ref>]. The major drawback of this approach is that it is dependent on the time needed to retrieve SA[i] ¼ j, which can be expensive when SA is not available explicitly. Another representation of the LCP array is the sampled LCP (SLCP) described in Sire´nSire´n (2010). It introduces the notions of maximal or irreducible values, which satisfy PLCP<ref type="bibr">[j]</ref></p><formula>6 ¼ (PLCP[j À 1] À 1)</formula><p>, and minimal values, if either j ¼ (n À 1) or PLCP[j þ 1] is maximal, i.e. if it is the last value of the array or the last one of a run of decreasing values flanked by a larger value on the right. The LCP is then sampled at these minimal PLCP values, which are as many as the number of equal letter runs in the BWT, and stored in SA order using a bit vector to mark their positions. To retrieve the value of LCP<ref type="bibr">[i]</ref>, the É(i) function is iterated k times until we fall over a sample, and finally it outputs LCP<ref type="bibr">[i]</ref>¼ (LCP[É k (i)] þ k). The É(i) function is defined as É(i) ¼ SA À1 [SA<ref type="bibr">[i]</ref>þ 1], meaning that it is the converse of the LF(i) function but returning the position in the SA of the suffix one text position to the right instead of to the left.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">SLCP array</head><p>The main motivation for our sampled version of the LCP is the observation that when performing the backward search over the BWT, if we want to retrieve the parent interval of the current BWT interval through the LCP, PSV and NSV arrays, we only need the values located at the two positions corresponding to both ends of the interval (more accurately, we need the top end and the position next to the bottom end) and not on any of the values in between. Therefore, it suffices to store the data only for positions that correspond to edges of non-singular BWT search intervals instead of storing it for all the positions of the BWT. This can be seen in<ref type="figure">Figure 4</ref>, where, for example, at the 'AG'-interval, given by 2À<ref type="bibr">[7,</ref><ref type="bibr">11]</ref>, we only need the values of the mentioned arrays at positions 7 and 12 ¼ 11 þ 1. As mentioned before, to be able to retrieve LCP<ref type="bibr">[i]</ref>, previous LCP representations need to first perform a series of É steps to compute the value of SA<ref type="bibr">[i]</ref>, and in virtually all implementations of compact indexes, the SA array is already stored in some sampled form. Unlike them, our approach does not require this time penalty cost for any supplemental computation of SA or LF values. Because we need to access the LCP array quite often for the purpose of resolving parent intervals, the retrieval of the lcp values should be as fast as possible. Therefore, the efforts in this work have been made in the direction of reducing the LCP space requirements with this SLCP approach, but without making use of any other space-oriented representations that would sacrifice speed, such as representing it with a wavelet tree (<ref type="bibr" target="#b20">Kulekci et al., 2012</ref>). Unlike the sampled version from Sire´nSire´n (2010), our SLCP method takes the positions in the LCP that correspond to the boundaries of the search intervals in the BWT. More precisely, these positions of interest are the ones delimiting BWT ranges with the same depth, i.e. the positions whose lcp value differs from the next one: SLCP ¼ {LCP<ref type="bibr">[i]</ref>:i ¼ (n À 1) or LCP<ref type="bibr">[i]</ref>6 ¼ LCP[i þ 1]}. This is the same as discarding the positions with consecutive equal lcp values, similar to what is done in run length encoding, but without the need to store the length of each run. The rest of the positions, if needed, can be deduced from the sampled ones. We use the terms top corner and bottom corner to refer to the lower value/topmost position and to the higher value/bottommost position of the BWT search interval, respectively. Attending to this, every sampled position is either a top corner or a bottom corner. Formally, the sets of both types of corners are defined by:</p><p>TopCorners ¼ {i:(i þ 1) 6 ¼ n and LCP<ref type="bibr">[i]</ref>5 LCP[i þ 1]} BottomCorners ¼ {i:(i þ 1) ¼ n or LCP<ref type="bibr">[i]</ref>4 LCP[i þ 1]}</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Sampled smaller values</head><p>While calculating parent intervals when executing a BWT search, we only need to perform PSV requests on the higher edge of each interval, i.e. on top corners, and NSV requests on the lower edge, i.e. on bottom corners. Therefore, it is sufficient to keep one single sampled smaller value (SSV) array instead of both PSV and NSV arrays. SSV<ref type="bibr">[i]</ref>will automatically return the value of PSV<ref type="bibr">[i]</ref>or NSV<ref type="bibr">[i]</ref>if position i corresponds to a top corner or to a bottom corner, respectively. More correctly, SSV<ref type="bibr">[i]</ref>Where i 0 is the number of sampled positions in the interval [0,(i À 1)] because SSV does not have the same size as PSV/NSV, as it only stores the sampled positions. Algorithm 1 associates each SLCP position with its corresponding PSV or NSV positions depending on whether it is a top or bottom corner, and stores it in the unified SSV array. It shares some resemblances with the procedure from (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref>) to calculate the lcp-interval<ref type="figure">Fig. 4</ref>. Example of a hypothetical section of an index structure showing arrays LCP, PSV and NSV. The sampled values of these three arrays are emphasized in gray. Only top and bottom corner positions are sampled for the LCP. The PSV is only sampled at top corners and the NSV only at bottom corners tree, as the PSV/NSV queries are the basis for the parent/child relationships in the tree's hierarchy. For simplicity, it uses the full LCP and SSV arrays with size n, but it is easy to adapt it to use the sampled versions instead.</p><p>Algorithm 1 maintains two stacks, one for top corners (line 1) and another for bottom corners (line 2). Each stack stores pairs of values containing the position of the corner in the BWT and an lcp-value. This lcp-value is LCP<ref type="bibr">[i]</ref>for top corners and LCP<ref type="bibr">[i þ 1]</ref>for bottom corners, as we are interested in how low the lcp-value was before and how low will it decrease next, respectively. This means the top corners stack stores {i,LCP<ref type="bibr">[i]</ref>} and the bottom corners stack stores {i,LCP[i þ 1]}. At every moment, the set of pairs stored in both stacks is always ordered by increasing positions and non-decreasing lcp-values. To fill the SSV array, the LCP is scanned from top to bottom. When a top corner is found (line 5), it is linked to the previous found top corner (line 6) and added to the stack (line 7) to be later linked to by another top corner. When a bottom corner is found (line 8), all the active previous bottom corners with an lcp-value higher than the current one (line 9) are linked to it and removed from the stack (line 10), as they were already used. This new bottom corner is saved (line 12) to be later linked to the next lower such corner. All the top corners with lcp-value higher or equal than the current bottom corner are also removed from its stack (lines 13 and 14), as these will not have a chance of being linked to anymore. Algorithm 2 allows us to obtain the parent interval of a given interval by relying solely on the sampled arrays, SLCP and SSV. For clarity reasons, the check to ensure that (j 0 þ 1) does not go beyond the size of the SLCP was omitted from the pseudo-code above to facilitate its reading. First, the edge positions of our initial interval in the full arrays, i and j, are translated into positions in the sampled arrays, i 0 and j 0 (lines 1 and 2). At this point, we cannot simply set each corner to its SSV position because we also have to take into consideration the depth of the parent interval. Similarly to the Parent operation on lcp-intervals, we need to check which side of the interval will lead to a higher lcp-value (lines 3 and 7), because the lcp-value of the parent is always max{LCP<ref type="bibr">[i 0 ]</ref>,LCP[j 0 þ 1]}. The corner displaying this property is expanded and replaced by the corner at its SSV position and the other corner remains unchanged. If both corners share the same value (line 11), they are both updated. Finally, it outputs the parent interval in the BWT along with its destination depth (line 15). In<ref type="figure" target="#fig_4">Figure 5</ref>, the illustrated arrows are connecting the top/bottom corners of the child intervals with the top/bottom corners of their parent intervals at their corresponding depths. Note that because intervals with different depths can share one of their borders, these arrows do not necessarily correspond to the destination SSV positions. For example, in the succession of parent intervals 3À<ref type="bibr">[3,</ref><ref type="bibr">5]</ref>, 2À<ref type="bibr">[1,</ref><ref type="bibr">5]</ref>and 1À<ref type="bibr">[1,</ref><ref type="bibr">12]</ref>, the first two share the same bottom corner at position 5, so SSV<ref type="bibr">[5]</ref>points directly to position 12, the bottom corner of the last one. When we have an interval composed of a single position, we find its parent interval by doing a simple scan in the SLCP for the closest top and bottom corners around that position. Because we use the SLCP instead of the LCP, the search is faster. The boundaries of our target interval are promptly determined by starting at those initial corners and iteratively following the SSV values until the required destination depth is reached. Because in the current context only parent-interval queries are required and we have no need for child-interval queries, this new SSV array replaces the lcp-interval tree and it also eliminates the need for other representations of the ST topology such as balanced parenthesis (<ref type="bibr" target="#b12">Geary et al., 2006</ref>) or RMQs (<ref type="bibr" target="#b11">Fischer and Heun, 2007</ref>). We give the term Sampled Search Intervals from Longest Common Prefixes (SSILCP) to the structure combining the described SLCP and SV arrays. Each interval with no children intervals is of size no larger than jAEj, as there are only jAEj distinct characters (including the terminator character '$') that can be used to extend the common prefix in each suffix, otherwise if at least one of the characters was repeated, it would create a child interval. This means that in each childless interval, we will have at most (jAEjÀ2) un-sampled positions, because we always need one sample for each edge. Therefore, theoretically, the maximum number of positions saved by using the SLCP instead of the full LCP will be of 3*(n/5) for DNA alphabet, which means, at most, a 60% size reduction, although in practice that value will be lower.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Finding MEMs</head><p>The MEM searching algorithm is based on the one proposed in Section 4 of (<ref type="bibr" target="#b27">Ohlebusch et al., 2010</ref>) and used in backwardMEM, as theBasically, Algorithm 3 processes the query sequence backward (line 2), and for each interval<ref type="bibr">[i,j]</ref>found (line 3), it keeps following parent intervals</p><formula>[i 0 ,j 0 ]</formula><p>(line 20) until the length l 0 of the current match is lower than a given threshold minLength (line 11). Because the right-maximality is already assured (lines 4–7), we check for left-maximality by verifying that each position inside [i 0 ,j 0 ] can no longer be further extended to the left, i.e. if the character to the left in the text, given in the BWT array, is not the same as the character to the left in the pattern (lines 13 and 17). Because each new parent interval [i 0 ,j 0 ] encloses the previous one<ref type="bibr">[previ',prevj']</ref>, only the newly found positions above (lines 12–15) and below (lines 16–19) are checked. This algorithm runs in O(m þ R L þ M L *t SA ) time, where m is length of the query sequence, R L and M L are the number of right maximal matches and MEMs, respectively, of size at least L ¼ minLength and t SA is the time needed to obtain a value from the SA, which is constant in our case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Implementation</head><p>The SSILCP is built from the full LCP, presenting a variable sampling rate of $1.2 based on the test results of<ref type="figure" target="#tab_1">Table 1</ref>, and is used as a replacement for both the LCP and the PSV/NSV arrays. Following the same idea as in (<ref type="bibr" target="#b0">Abouelhoda et al., 2004</ref>), based on the observation that the vast majority of the values in the LCP array are small, the lcp values 5255 are stored using 8 bits per number, while the remaining values go into a complementary table containing only larger numbers. We also use an additional space-saving trick based on the fact that most of the PSV<ref type="bibr">[i]</ref>and NSV<ref type="bibr">[i]</ref>values do not jump too far away from its position i. Therefore, the SSV array can also take advantage of a similar approach as the LCP array by storing the differential values between the source and destination positions, with negative values representing PSV jumps and positive values NSV jumps. Now the values represented using only 8 bits are within the range from À127 to þ127. To comply with the most commonly used computer memory architectures, the SA array coupled to the FM-Index uses a fixed sampling rate of 32. Further details about the index and SSILCP implementations are available in the Supplementary Material. All algorithms and data structures have been developed from scratch without relying on any other existing code base.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Datasets</head><p>As test suites, we have chosen two real-life scenarios that feature significantly sized genomes. The first dataset is constituted by two species of the fruit fly, Drosophila melanogaster and Drosophila yakuba, with 162 and 163 Mbp, respectively, as this setting was also featured in the publications of every other tested tool. The second dataset includes the complete genomes of Homo sapiens, build 19 (HG19) (<ref type="bibr" target="#b5">Church et al., 2011</ref>), and Mus musculus, build 10 (MM10) (<ref type="bibr" target="#b34">Waterston et al., 2002</ref>), with 3.1 and 2.7 Gbp, respectively. The chosen references for each dataset were D. melanogaster and HG19. Specific LCP-related characteristics for each one are depicted in<ref type="figure" target="#tab_1">Table 1</ref>. Using this new SSILCP data structure, we get O(1) time for LCP and parent operations. It also scales linearly with the size of the reference genome. The space requirements are typically around 2.2*n bytes for practical applications on DNA according to the tests presented in the second last row of<ref type="figure" target="#tab_1">Table 1</ref>, consuming $19% of the space we would have used by storing the full LCP, PSV and NSV arrays in the naı¨venaı¨ve way.Note: The reference genome size considers {A,C,G,T} chars only. Samples with an lcp value 4254 and SV samples with an absolute value 4127 are considered oversized. The maximum lcp value indicates the length of the largest repeat present in the genome. The full SSILCP size accounts for the SLCP and SSV arrays and all the supporting data structures, excluding the FM-Index. MB, Megabyte; Mbp, Mega base pair. reducing the time complexity by removing the log(n) term while maintaining a similar memory usage of (9/K þ 1)*n bytes. backwardMEM uses an enhanced compressed SA supported by a BWT encoded as a wavelet-tree and adapted existing MEM locating algorithms to work with backward search. It features a balanced parentheses representation of the lcp-interval tree capable of constant time parent interval queries. Its memory requirements are $(4/k þ 2)*n bytes in practice. When available, the tools were given different SA sampling values of powers of 2 ranging from 1 to 32, using the run-time parameter '-k' in sparseMEM and essaMEM and the compiletime flag 'BWTK' in backwardMEM. All tools were run with the same parameters '-maxmatch-n-l L' to report all MEMs, with minimum length L ¼ 50 for the Drosophila dataset and L ¼ 100 for the human/mouse dataset. The source code of each tool was edited to launch a process in the background that starts collecting the time and memory values right after the data structures were built and just before the actual MEM finding algorithms take place. Because each tool uses different index structures and different construction algorithms that would be difficult to compare as a whole, this allows the benchmarks to reflect the MEM retrieving efficiency only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Tested programs</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Benchmarks</head><p>Time corresponds to the elapsed real time and memory to the maximum physically resident memory, fields 'etime' and 'rss', respectively, in the Unix system command 'ps', and measured using the 'memusgpid' script included in the source package. All tests were run on a Linux server machine featuring an Intel Xeon CPU clocked at 2.13 GHz with 256 GB of RAM and 64 cores, but none of the tools was run with multi-threading options. The results are presented in<ref type="figure">Table 2</ref>and Figures 6 and 7 and detailed in the Supplementary Material. Because all the tools only index the reference genome, the used memory is determined by the reference size, with the addition of the currently loaded query. As the results show, slaMEM's approach consumes $3.3*n bytes in practice. In the Drosophila dataset, it uses approximately the same memory as backwardMEM and sparseMEM, both with a sampling value of 32, while being almost 7 times faster than backwardMEM and 25 times faster than sparseMEM. Therefore, between the two backward searching-based methods, slaMEM achieves the best performance. It is only outperformed in terms of memory by essaMEM with K ¼ 16 and K ¼ 32, while still running slightly faster. Compared with the un-sampled approach used in MUMmer, slaMEM runs in half the time and uses almost four times less space. In the human/mouse dataset, MUMmer, backwardMEM and essaMEM with K ¼ 1 all failed or crashed possibly due to the use of signed integer variable types, which do not support arrays with sizes larger than 2 billion positions. Theoretically, for a comparable memory usage, slaMEM is equivalent to a sampling rate of K ¼ 6 in the sparse methods and still almost 8 times faster than the closest test results (K ¼ 4 and K¼ 8). The best time/memory ratio belongs to essaMEM. Nevertheless, slaMEM achieves the fastest running times among all the tested tools and sampling values in both datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">CONCLUSIONS</head><p>An algorithmic improvement that can be further explored is based on the observation that on applications that involve pursuing parent intervals only when a mismatch occurs, e.g. matching statistics (<ref type="bibr" target="#b4">Chang and Lawler, 1994</ref>) or super-maximal matches (<ref type="bibr" target="#b13">Gusfield, 1997</ref>), we only need to retrieve parent intervals when the current BWT search interval does not include at least one of the letters of the alphabet, which might be the one we were interested in following backward. This way, the SSILCP memory requirements can be lowered even further by ignoringNote: Only MEMs with size at least 50 and 100, respectively, have been considered.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. SA and ST for the string CAGCAACTGCAGT$. Each leaf node in the ST corresponds to an SA entry and vice versa, while internal nodes correspond to shared prefixes among consecutive ordered suffixes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>i,j]. To calculate a parent interval, we can use the next smaller value (NSV) and the previous smaller value (PSV) arrays introduced in Fischer et al. (2009) and defined as:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.3.</head><figDesc>Fig. 3. LCP, PSV and NSV arrays for the string CAGCAACTGCAGT$. The shaded characters represent the shared prefixes between adjacent suffixes</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><figDesc>of bottom corners stores (NSV[i þ 1] À 1), as NSVs are always one position ahead of bottom corners. Hence, PSV and NSV values for sampled positions can be recovered from the SSV array using the relation: SSV[i 0 ] ¼ PSV[i], if SSV[i 0 ] 5 i SSV[i 0 ] ¼ NSV[i þ 1] À 1, if SSV[i 0 ] 4 i</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.5.</head><figDesc>Fig. 5. Parent interval relations in a section of a hypothetical index. The arrows connect the top/bottom corners of each interval to their respective parent interval's top/bottom corners at the appropriate destination depth. In the SLCP and SSV sampled arrays, dashes represent un-sampled positions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.6.</head><figDesc>Fig. 6. Plot comparing the time and memory used by the different MEM locating tools in the Drosophila dataset. Multiple points for the same tool represent distinct values of K, if available</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.7.</head><figDesc>Fig. 7. Plot displaying the results of all the tested tools over the human dataset</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="true"><figDesc>Table 1. LCP statistics for the used datasets</figDesc><table>Dataset 
Drosophila 
Human versus 
mouse 

Genome reference size 
162 Mbp 
2897 Mbp 
Sampled positions 
88.3% 
86.9% 
Oversized LCP samples 
8.2% 
1.6% 
Oversized SV samples 
2.6% 
2.8% 
Average lcp value 
100 
1059 
Maximum lcp value 
48 382 
2 339 520 
SSILCP structure size 
416 MB 
6680 MB 
Index size 
182 MB 
3259 MB 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 2. MEM statistics for the used datasets showing the number of found MEMs and their average size in each dataset</figDesc><table>Dataset 
Drosophila 
Human versus 
mouse 

Number of MEMs 
1 461 805 
537 438 
Average MEM size 
82 
114 

</table></figure>

			<note place="foot">ß The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">slaMEM at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">F.Fernandes and A.T.Freitas at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">MUMmer builds an ST for the reference using the compact representation from (Kurtz, 1999) that requires $15.4 bytes per input character and streams the query sequences against it. sparseMEM indexes the reference with a sparse SA and uses the LCP and SA À1 arrays to simulate suffix links, which are essential to accelerate the computation of MEMs in that data structure. Its time complexity is O(m*log(n) þ q) for a reference of size n, query of size m and q dependent on the sparseness factor and minimum matches length. A sampled SA approach keeps all the suffixes of the text but only stores each kth entry of the SA array, whereas the sparse SA approach only maintains each Kth suffix of the text and their corresponding SA entry. essaMEM works over an enhanced sparse SA that replaces the SA À1 array of sparseMEM with a sparse child array, greatly</note>

			<note place="foot">F.Fernandes and A.T.Freitas at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from the samples for LCP intervals that contain all the DNA letters. slaMEM could also take advantage of multi-threading to speed up computation by processing many queries or parts of the same query in parallel. Furthermore, by extending the current implementation to support some missing ST operations, the combination of the FM-Index with the SSILCP could be used as a full compressed ST representation. We observed that because the boundaries of non-unitary BWT search intervals can only fall in certain positions, it is enough to sample the LCP, PSV and NSV arrays at those specific positions. Therefore, we engineered the SSILCP specifically to closely wrap around the string matching mechanism that characterizes the FM-Index. This added ability to the index enables faster parent interval queries, which makes it especially useful for calculating matching statistics and maximal exact matches, where its absence would otherwise render the MEM retrieval algorithm impractically slow. Unlike other representations of the LCP, ours does not depend on the calculation of any previous SA or LF values, resulting in a strategy with a good space/time tradeoff to replace both the LCP array and the lcp-interval tree. Results on real data show that, for this application, our new combined SLCP and PSV/NSV representation proves to be a competitive approach against other equivalent structures such as the lcpinterval tree, thus making slaMEM a useful backbone for any project in the field of comparative genomics that relies on MEMs.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>The authors thank Arlindo Oliveira for proofreading and providing valuable suggestions for this document and Michaeï Vyverman for his help on tracking down a bug in our sequence parsing code.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Replacing suffix trees with enhanced suffix arrays</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">I</forename>
				<surname>Abouelhoda</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Discrete Algorithms</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="53" to="86" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">CoCoNUT: an efficient system for the comparison and analysis of genomes</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">I</forename>
				<surname>Abouelhoda</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">476</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Basic local alignment search tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="403" to="410" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">A Block-Sorting Lossless Data Compression Algorithm</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Burrows</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Wheeler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital Systems Research Center</title>
		<meeting><address><addrLine>Palo Alto, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Sublinear approximate string matching and biological applications</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">I</forename>
				<surname>Chang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">L</forename>
				<surname>Lawler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="327" to="344" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Modernizing reference genome assemblies</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">M</forename>
				<surname>Church</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Biol</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">1001091</biblScope>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Alignment of whole genomes</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">L</forename>
				<surname>Delcher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2369" to="2376" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Fast algorithms for large-scale genome alignment and comparison</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">L</forename>
				<surname>Delcher</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<biblScope unit="page" from="2478" to="2483" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Opportunistic data structures with applications</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Annual Symposium on Foundations of Computer Science</title>
		<meeting>the 41st Annual Symposium on Foundations of Computer Science</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="390" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Indexing compressed text</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">52</biblScope>
			<biblScope unit="page" from="552" to="581" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Faster entropy-bounded compressed suffix trees</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Fischer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">410</biblScope>
			<biblScope unit="page" from="5354" to="5364" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">A new succinct representation of RMQ-information and improvements in the enhanced suffix array</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Fischer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Heun</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorics, Algorithms, Probabilistic and Experimental Methodologies</title>
		<editor>Chen,B. et al.</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="459" to="470" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">A simple optimal representation for balanced parentheses</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">F</forename>
				<surname>Geary</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">368</biblScope>
			<biblScope unit="page" from="231" to="246" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<monogr>
		<title level="m" type="main">Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<monogr>
		<title level="m" type="main">Permuted longest-common-prefix array</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Ka¨rkkaïnenka¨rkkaïnen</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<publisher>Combinatorial Pattern Matching. Springer</publisher>
			<biblScope unit="page" from="181" to="192" />
			<pubPlace>Berlin</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Simple linear work suffix array construction</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Ka¨rkkaïnenka¨rkkaïnen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Sanders</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automata, Languages and Programming</title>
		<editor>Baeten,J. et al.</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="943" to="955" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Linear-time longest-common-prefix computation in suffix arrays and its applications</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Kasai</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Annual Symposium on Combinatorial Pattern Matching</title>
		<meeting>the 12th Annual Symposium on Combinatorial Pattern Matching</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="181" to="192" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">A practical algorithm for finding maximal exact matches in large sequence datasets using sparse suffix arrays</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Khan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1609" to="1616" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Linear-time construction of suffix arrays</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">K</forename>
				<surname>Kim</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorial Pattern Matching</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="186" to="199" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Space efficient linear time construction of suffix arrays</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ko</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Aluru</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorial Pattern Matching</title>
		<editor>Baeza-Yates,R. et al.</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="200" to="210" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Efficient maximal repeat finding using the BurrowsWheeler transform and wavelet tree</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">O</forename>
				<surname>Kulekci</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="421" to="429" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Reducing the space requirement of suffix trees</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Softw. Pract. Exp</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="1149" to="1171" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<monogr>
		<title level="m" type="main">Versatile and open software for comparing large genomes</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Suffix arrays: a new method for on-line string searches</title>
		<author>
			<persName>
				<forename type="first">U</forename>
				<surname>Manber</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="935" to="948" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Compressed full-text indexes</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Navarro</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Ma¨kinenma¨kinen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Comput. Surv</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">Linear suffix array construction by almost pure inducedsorting</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Nong</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Compression Conference DCC&apos;09</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="193" to="202" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Computing matching statistics and maximal exact matches on compressed full-text indexes</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ohlebusch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">String Processing and Information Retrieval</title>
		<editor>Chavez,E. and Lonardi,S.</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="347" to="358" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">A linear-time burrows-wheeler transform using induced sorting</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Okanohara</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Sadakane</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">String Processing and Information Retrieval</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="90" to="101" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Compressed suffix trees with full functionality</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Sadakane</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theory Comput. Syst</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="page" from="589" to="607" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">Sampled longest common prefix array</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Sire´nsire´n</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorial Pattern Matching</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="227" to="237" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">On-line construction of suffix trees</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Ukkonen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="249" to="260" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">Prospects and limitations of full-text index structures in genome analysis</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Vyverman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="6993" to="7015" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">essaMEM: finding Maximal Exact Matches using enhanced sparse suffix arrays</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Vyverman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="page" from="802" to="804" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b34">
	<analytic>
		<title level="a" type="main">Initial sequencing and comparative analysis of the mouse genome</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">H</forename>
				<surname>Waterston</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="volume">420</biblScope>
			<biblScope unit="page" from="520" to="562" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b35">
	<analytic>
		<title level="a" type="main">Linear pattern matching algorithms</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Weiner</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Conference Record of 14th Annual Symposium on Switching and Automata Theory, 1973. SWAT&apos;08</title>
		<imprint>
			<date type="published" when="1973" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>