
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:46+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Genome analysis Omega: an Overlap-graph de novo Assembler for Metagenomics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2014">19 2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Bahlul</forename>
								<surname>Haider</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Mathematics Division</orgName>
								<orgName type="institution">Oak Ridge National Laboratory</orgName>
								<address>
									<postCode>37831</postCode>
									<settlement>Oak Ridge</settlement>
									<region>TN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Tae-Hyuk</forename>
								<surname>Ahn</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Mathematics Division</orgName>
								<orgName type="institution">Oak Ridge National Laboratory</orgName>
								<address>
									<postCode>37831</postCode>
									<settlement>Oak Ridge</settlement>
									<region>TN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Brian</forename>
								<surname>Bushnell</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Mathematics Division</orgName>
								<orgName type="institution">Oak Ridge National Laboratory</orgName>
								<address>
									<postCode>37831</postCode>
									<settlement>Oak Ridge</settlement>
									<region>TN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Juanjuan</forename>
								<surname>Chai</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Mathematics Division</orgName>
								<orgName type="institution">Oak Ridge National Laboratory</orgName>
								<address>
									<postCode>37831</postCode>
									<settlement>Oak Ridge</settlement>
									<region>TN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Alex</forename>
								<surname>Copeland</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Mathematics Division</orgName>
								<orgName type="institution">Oak Ridge National Laboratory</orgName>
								<address>
									<postCode>37831</postCode>
									<settlement>Oak Ridge</settlement>
									<region>TN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Chongle</forename>
								<surname>Pan</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Mathematics Division</orgName>
								<orgName type="institution">Oak Ridge National Laboratory</orgName>
								<address>
									<postCode>37831</postCode>
									<settlement>Oak Ridge</settlement>
									<region>TN</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">John</forename>
								<surname>Hancock</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="institution" key="instit1">U.S. Department of Energy</orgName>
								<orgName type="institution" key="instit2">Joint Genome Institute</orgName>
								<address>
									<postCode>94598</postCode>
									<settlement>Walnut Creek</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Genome analysis Omega: an Overlap-graph de novo Assembler for Metagenomics</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">30</biblScope>
							<biblScope unit="page" from="2717" to="2722"/>
							<date type="published" when="2014">19 2014</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btu395</idno>
					<note type="submission">Received on January 26, 2014; revised on June 12, 2014; accepted on June 13, 2014</note>
					<note>BIOINFORMATICS ORIGINAL PAPER Contact: panc@ornl.gov Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Metagenomic sequencing allows reconstruction of microbial genomes directly from environmental samples. Omega (overlap-graph metagenome assembler) was developed for assembling and scaffolding Illumina sequencing data of microbial communities. Results: Omega found overlaps between reads using a prefix/suffix hash table. The overlap graph of reads was simplified by removing transitive edges and trimming short branches. Unitigs were generated based on minimum cost flow analysis of the overlap graph and then merged to contigs and scaffolds using mate-pair information. In comparison with three de Bruijn graph assemblers (SOAPdenovo, IDBA-UD and MetaVelvet), Omega provided comparable overall performance on a HiSeq 100-bp dataset and superior performance on a MiSeq 300-bp dataset. In comparison with Celera on the MiSeq data-set, Omega provided more continuous assemblies overall using a fraction of the computing time of existing overlap-layout-consensus assemblers. This indicates Omega can more efficiently assemble longer Illumina reads, and at deeper coverage, for metagenomic datasets. Availability and implementation: Implemented in C++ with source code and binaries freely available at http://omega.omicsbio.org.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Metagenome assemblers attempt to reconstruct genomes of microorganisms in a community from its metagenomic sequencing data. In recent years, many isolate genome assemblers have been developed for Illumina sequencing data using de Bruijn graphs [e.g. ABySS (<ref type="bibr" target="#b16">Simpson et al., 2009</ref>), IDBA (<ref type="bibr" target="#b10">Peng et al., 2010</ref>), ALLPATH (<ref type="bibr" target="#b0">Butler et al., 2008</ref>), Velvet (<ref type="bibr" target="#b19">Zerbino and Birney, 2008</ref>) and SOAPdenovo (<ref type="bibr" target="#b5">Li et al., 2010)]</ref>and overlap graphs [e.g. SGA (<ref type="bibr" target="#b15">Simpson and Durbin, 2012</ref>) and PEGASUS (<ref type="bibr" target="#b2">Haider, 2012)]</ref>. However, they cannot be directly applied to metagenome assembly for the following reasons. First, isolate genome assemblers typically assume a uniform coverage depth across a genome. This assumption is used for identifying repeat regions in a genome and estimating the size of a genome. In metagenome assembly, however, genomes may have vastly different coverage depths depending on their relative abundances in a community. Second, isolate genome assembly only needs to resolve repeat regions within a single genome, while metagenome assembly also has to handle repeat regions between multiple genomes. Third, sequencing errors significantly convolute the assembly by introducing false overlaps between reads and disrupting true overlaps. Error correction can be performed for isolate genome assembly using consensus sequences. However, it is difficult to separate sequencing errors from single nucleotide polymorphisms (SNPs) in metagenome assembly. To address these challenges, some of the de Bruijn graph assemblers have been upgraded for Illumina metagenomic sequencing data, including MetaVelvet (<ref type="bibr" target="#b9">Namiki et al., 2012</ref>) and IDBA-UD (<ref type="bibr" target="#b11">Peng et al., 2012</ref>). In this study, the Omega (overlap-graph metagenome assembler) algorithm was developed specifically for metagenome assembly. Omega followed the general overlap graph (string graph) approach described in BOA (<ref type="bibr" target="#b8">Myers, 2005</ref>) and PEGASUS (<ref type="bibr" target="#b2">Haider, 2012</ref>). Here, the overlap graph approach was adapted to metagenome assembly by addressing its differences from isolate genome assembly described above. The assembly performance of Omega was compared with SOAPdenovo, IDBA-UD and MetaVelvet on Illumina HiSeq 100-bp data and MiSeq 300-bp data. SOAPdenovo was selected because it was used for metagenome assembly in the human microbiome project (<ref type="bibr" target="#b12">Pop, 2011</ref>) and many Joint Genome Institute studies. IDBA-UD and MetaVelvet were designed specifically for metagenome assembly. A widely used overlap-layout-consensus assembler, Celera (<ref type="bibr" target="#b7">Myers et al., 2000</ref>), was also compared using the MiSeq 300-bp data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">SYSTEM AND METHODS</head><p>The performance of assemblers on Illumina HiSeq 100-bp data was benchmarked using a real-world sequencing dataset of genomic DNA mixture of 64 diverse bacterial and archaeal microorganisms (<ref type="bibr" target="#b14">Shakya et al., 2013</ref>). The dataset is available at National Center for Biotechnology Information (NCBI) Sequence Read Archive (SRA) (accession number: SRX200676). The 64 microorganisms are listed in Supplementary Table S1. Fastq sequences were extracted from the SRA format raw dataset using NCBI SRA Toolkit (version *To whom correspondence should be addressed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.3.4</head><p>). This dataset contains 108.7 million paired-end and 0.4 million single-end 100-bp reads. Sickle (https://github.com/ najoshi/sickle) was used to trim reads using a 20-Phred quality threshold, to filter out reads shorter than 60 bp and to discard reads containing many Ns. BBNorm (https://sourceforge.net/ projects/bbmap/) was then used for error correction with default settings. The HiSeq 100-bp dataset was assembled using SOAPdenovo, IDBA-UD, MetaVelvet and Omega. The k-mer length or minimum overlap length was optimized for each assembler based on the N50 size: SOAPdenovo (best k-mer length = 51 of 31, 41, 51 and 61), IDBA-UD (k-mer length range = 30–60 with a step size of 10), MetaVelvet (best k-mer length = 51 of 31, 41, 51 and 61) and Omega (best minimum overlap length = 50 of 30, 40, 50, 60 and 70). SOAPdenovo was run in a metagenome configuration as described (<ref type="bibr" target="#b12">Pop, 2011</ref>). IDBA-UD, MetaVelvet and Omega were run with default parameters. The performance of assemblers on Illumina MiSeq 300-bp data was tested using a simulated dataset of a nine-genome synthetic community. Ten million paired-end 300-bp reads with an average insert size of 900 bp were simulated based on an empirical error model using MetaSim (<ref type="bibr" target="#b13">Richter et al., 2008</ref>). Supplementary<ref type="figure" target="#tab_2">Table S2</ref>lists the nine genomes and their relative abundances ranging from 3 to 20%. The simulated reads were preprocessed using Sickle and error-corrected using BBNorm as described above. The maximum k-mer length of MetaVelvet was increased to 171 by changing a constant parameter in its source code. We were unable to increase the maximum k-mer lengths of SOAPdenovo and IDBA-UD, which were hard-coded at 127 and 124, respectively. The k-mer length or minimum overlap length was optimized for each assembler: SOAPdenovo (best k-mer length = 121 of 41, 61, 81, 101, 121 and 127), IDBAUD (k-mer length range = 40–120 with a step size of 20), MetaVelvet (best k-mer length = 151 of 121, 131, 141, 151 and 161) and Omega (best minimum overlap length = 150 of 120, 130, 140, 150 and 160). The assemblers were run as described above. Celera was also tested for the MiSeq 300-bp dataset using a default setting and a metagenomics setting (http://sourceforge. net/apps/mediawiki/wgs-assembler/index.php?title=RunCA_ Examples_-_454_%2B_Sanger_Metagenomic). The Celera assembly using the default setting was substantially better than that using the metagenomics setting and, therefore, was used for performance comparison. To measure assembly accuracy, contigs and scaffolds 4200 bp produced by each assembler were aligned with reference genomes using Burrow–Wheeler Aligner (BWA) (<ref type="bibr" target="#b5">Li and Durbin, 2010</ref>). The alignments were used to generate a list of correct contigs containing 55% of substitutions and indels. The scaffolding of two adjacent contigs was considered to be correct if their alignments to the same reference genome were in correct orientation and separated apart by less than the mean plus one standard deviation (SD) of the mate inner distances of the paired-end sequencing data. The performance of assemblers was compared by N80, N50, N20, largest contig length and genome sequence coverage for each reference genome. N80, N50 and N20 are the minimum size thresholds for length-sorted contigs that covers 80, 50 and 20% of the total length of all contigs, respectively. Genome sequence coverage is the percentage of a reference genome sequence covered by the assembled contigs. N80, N50, N20 and largest contig length measure the contiguity of the correct contigs at different levels. Genome sequence coverage measures the completeness of the correct contigs. Different types of assembly errors were identified based on the BWA alignment between the contigs and the reference genomes, including the number of base pairs of insertion, deletion and substitution and the number of chimeric contigs. Chimeric contigs were identified by their fragmented alignments to multiple non-contiguous regions of a reference genome or multiple reference genomes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ALGORITHM</head><p>Omega was developed in C+ + using object-oriented programming. Omega can accept multiple input datasets with different insert sizes and variable read lengths in fasta or fastq format. The assembly and scaffolding were performed in eight steps (<ref type="figure" target="#fig_0">Fig. 1</ref>):</p><p>(1) Hash table construction. All unique reads are loaded to the memory and indexed in a hash table. Let K be the userdefined minimum overlap length. The keys of the hash table are DNA sequence substrings of length K – 1. Each read is inserted to the hash table with four keys: prefix and suffix of length K – 1 of both forward sequence and reverse complement sequence of the read. A value in the hash table is an array of pointers to the reads associated with the corresponding key. The hash table is initialized to be eight times of the total read number. Hash collision is resolved using linear probing. The hash table allows a nearly constant time search of all reads by their prefixes or suffixes. A read that is a substring of another read is called a contained read. To identify all contained reads of read r, every proper substring s of length K in read r is searched in the hash table. This produces a short list of reads that contains s as a prefix or suffix, which is then compared with read r to identify the contained reads of(2) Overlap graph construction. Each read is represented by a vertex in a bi-directed overlap graph. An edge is inserted between two vertices if the two corresponding reads have an exact-match overlap of at least K bp. The bi-directed edges represent the four different orientations in which two reads can overlap: suffix with prefix (!––!), suffix of the reverse complement with prefix ( ––!), suffix with prefix of the reverse complement (!–– ) and suffix of the reverse complement with prefix of the reverse complement ( –– ). To efficiently find all reads overlapping with a read r, every proper substring s of length K – 1 in read r is searched in the hash table, and all retrieved reads are compared with the read r. If a read has the exact match with read r for their remaining overlap, an edge is inserted between the two reads' corresponding vertices. After inserting all edges of read r, all transitive edges incident on read r are removed using a linear algorithm as described (<ref type="bibr" target="#b2">Haider, 2012;</ref><ref type="bibr" target="#b8">Myers, 2005</ref>). Briefly, suppose that r is connected with two other reads, a and b. If there is also an edge between a and b to form a triangle with r and the sequence represented by the edge (r, b) is the same as the sequence represented by the path through (r, a) and (a, b), then (r, b) is identified as a transitive edge and is deleted. Removing all transitive edges significantly simplifies the overlap graph without losing any information.</p><p>(3) Composite edge contraction. While the bi-directed edges can be traversed in both directions, the vertices can be traversed only by entering a vertex in an in-arrow and exiting in an out-arrow (–!!–) or by entering a vertex in an out-arrow and exiting in an in-arrow (– –). A valid path in the overlap graph represents an assembled DNA sequence containing proper overlapping reads with appropriate orientation and sufficient overlap length. After removing transitive edges, simple vertices have exactly one in-arrow and one out-arrow, representing only one possible way to traverse such simple vertices. A read in a simple vertex uniquely overlaps with one other read in either direction. To simplify the overlap graph, a simple vertex, r, along with its in-arrow edge (u, r) and out-arrow edge (r, w), are replaced by a composite edge (u, w) in the overlap graph. The composite edge (u, w) contains the read r and all ordered reads in edge (u, r) and (r, w). The edge (u, w) has the same arrow types to u and w as the original edges, (u, r) and (r, w), respectively. Simple vertices are merged into composite edges iteratively, until there is no simple vertex remaining in the overlap graph.</p><p>(4) Sequence variation removal. Sequence variations originate from uncorrected sequencing errors and natural sequence polymorphisms in microbial communities. Many reads with sequence variations do not overlap with any other reads and are represented as isolated vertices in the overlap graph. Reads with the same sequence variation may overlap with one another, which creates small branches and bubbles in the overlap graph. Small branches are short dead-end paths that contain 510 reads. Bubbles are two edges that connect the same two vertices with the same arrow types. The overlap graph is systematically traversed to trim off small branches and remove the edges containing less reads in bubbles. This may create new simple vertices that are then removed by repeating the composite edge contraction.</p><p>(5) Minimum cost flow analysis. Each edge in the overlap graph is associated with a string copy number, representing how many times the edge's sequence is present in the metagenome. String copy numbers of edges are estimated based on the topology of the overlap graph using minimum cost flow analysis as described (<ref type="bibr" target="#b2">Haider, 2012;</ref><ref type="bibr" target="#b8">Myers, 2005</ref>). Composite edges with sequences 41000 bp are set to have a minimum flow of 1, requiring such edges' sequences to be present in the metagenome at least once. The minimum flow for short edges (51000 bp) is set to 0. The CS2 algorithm (<ref type="bibr" target="#b1">Goldberg, 1997</ref>) is used to optimize the amount of flow passing through every edge such that the total cost of the flow network in the overlap graph is minimized. Edges with more than one unit of flow correspond to repeat regions shared among multiple genomes or multiple places in a single genome. Edges with zero flow represent short sequences that are not needed to connect long sequences together and are ignored. Tree structures in the overlap graph are simplified using the flows. A tree comprises two edges, (p, t) and (q, t), merging to a third edge (t, r), and the flow on (t, r) is equal to the total flow on (p, t) and (q, t). Such a tree is reduced to two new edges (p, r) and (q, r) that both contain the reads in vertex t and edge (t, r).</p><p>(6) Merging of adjacent edges with mate-pair support. The insert size of each paired-end dataset is estimated separately to accommodate a mixture of datasets with different insert sizes. The overlap graph at this stage has long composite edges that contain both reads of many matepairs. The insert sizes of such pairs are determined from their relative locations on the long edges and are pooled to estimate the mean and SD of all mate-pairs' insert sizes in each dataset. Mate-pairs that span multiple edges are used to merge adjacent edges in the overlap graph. For each of such mate-pairs, all possible paths of length within range ( – 3, + 3) are enumerated. If all paths of a mate-pair travel through two adjacent edges, (m, r) and (r, n), the connection between these two edges is considered to be supported by this mate-pair. After processing all mate-pairs, if the connection between (m, r) and (r, n) is supported by more than three mate-pairs, these two edges are merged to one edge (m, n) containing a duplicated r.</p><p>(7) Scaffolding of long edges with mate-pair support. Scaffolding uses mate-pairs that have no valid path between their paired reads in the overlap graph because of a gap in genome coverage. Scaffolding is attempted for every pair of non-adjacent edges 41000 bp. A mate-pair is considered to support the scaffolding of two edges if its two reads are uniquely mapped to the two edges at an appropriate distance apart. After processing all matepairs, the scaffolds of long edges with support of more than three mate-pairs are accepted.</p><p>(8) Resolving ambiguity by coverage depth. Many unresolved vertices in the overlap graph have two incoming edges and two outgoing edges, which often originate from a short repeat region between two different genomes. The two genomes may have different coverage depths to separate their edges. The coverage depth is calculated for every position along an edge to estimate the mean and SD of coverage depth along the edge. Only unique reads in an edge are considered for coverage depth calculation. A pair of adjacent edges on an unresolved vertex are merged if</p><formula>j 1 – 2 j5 1 + 2 .</formula><p>Finally, Omega reports contigs and scaffolds based on the edges of the overlap graph.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS AND DISCUSSION</head><p>After trimming and filtering, the HiSeq 100-bp dataset contained 101 million paired-end reads. To find the error rate, reads were aligned to the concatenated 64 reference genomes using Bowtie2 (<ref type="bibr" target="#b4">Langmead and Salzberg, 2012</ref>) allowing up to three mismatches per read. We defined sequencing errors as mismatches supported by less than three reads to exclude consistent substitutions attributable to SNPs. Before error correction, 93.8 million reads were aligned to at least one reference genome, and an average of 0.12 sequencing error per read was found. After error correction with BBNorm, 97.5 million reads were aligned with 0.02 sequencing error per read. The error-corrected HiSeq 100-bp dataset was assembled using SOAPdenovo, IDBA-UD, MetaVelvet and Omega. The CPU usage and peak memory usage were, respectively, 13 h and 29 GB for SOAPdenovo, 49 h and 112 GB for IDBA-UD, 8 h and 21 GB for MetaVelvet and 15 h and 105 GB for Omega.SOAPdenovo, MetaVelvet and Omega were efficient in CPU usage, but SOAPdenovo and MetaVelvet used much less memory. Omega spent 1.5 h building the hash table from reads, 2.7 h identifying contained reads, 7.1 h constructing the overlap graph and 3.5 h simplifying the overlap graph. The peak memory usage of Omega was at the end of overlap graph construction when Omega stored all reads (50 GB), the hash table (5 GB) and the completed overlap graph (50 GB) in memory. The assembly results were verified by aligning contigs and scaffolds with the reference genomes. The four assemblers all produced some misassembled contigs. The common causes for misassemblies included homologous repeat regions among the 64 genomes, undersampled regions of the genomes and remaining sequencing errors. For each reference genome, we generated standard assembly statistics of correct scaffolds, including N80, N50, N20, largest contig length and genome sequence coverage (<ref type="figure" target="#fig_1">Fig. 2</ref>and Supplementary<ref type="figure" target="#tab_1">Table S1</ref>). On average across all genomes, more contiguous assemblies were provided by IDBA_UD, Omega, MetaVelvet and SOAPdenovo in this order (<ref type="figure" target="#tab_1">Table 1</ref>). However, the four assemblers performed similarly for many genomes, and IDBA-UD and Omega provided clearly improved assembly results for different subsets of genomes (<ref type="figure" target="#fig_1">Fig. 2</ref>). The assembly of Fusobacterium nucleatum (genome 22 in<ref type="figure" target="#fig_1">Fig. 2</ref>) was poor because of its low abundance in the mock community. The four assemblers, as well as Celera, were then compared using a simulated MiSeq 300-bp dataset. The aggregate raw and verified assembly statistics of contigs and scaffolds are shown in<ref type="figure" target="#tab_2">Table 2</ref>. The assembly results for individual genomes are listed in Supplementary Table S2. Celera used much more CPU hours than the other four assemblers (420 times more than Omega;<ref type="figure">Table 3</ref>). The assembly from Omega was more contiguous than the assemblies from the three de Bruijn graph assemblers and Celera. The assemblers had different error profiles (<ref type="figure">Table 3</ref>). For example, Omega generated more chimeric contigs and substitution errors than Celera, but less insertion and deletion errors. MetaVelvet had less insertion, deletion and substitution errors than Omega and Celera, but more chimeric contigs. Generally, it was difficult to generate more contiguous assembly while minimizing all types of errors. Here, the performance of assemblers was benchmarked using a real-world HiSeq 100-bp dataset and a simulated MiSeq 300-bp dataset, both of which had reference genomes for result verification. However, computationally simulated sequencing data cannot reproduce many complications of Illumina sequencing. Even real-world sequencing data of artificially mixed genomic DNAs cannot replicate the true complexity of natural microbialcommunities with high strain-level variations and large abundance differences. As there was no complex natural community composed of microorganisms with known genome sequences, it was still a challenge to accurately benchmark the real-world performance of metagenome assemblers. The overall performance of Omega was comparable with SOAPdenovo, IDBA_UD and MetaVelvet on the HiSeq 100bp dataset and superior on the 300-bp MiSeq dataset, although each assembler provided the best assembly for some individual genomes in the two synthetic communities. Our benchmarking indicated the unique advantages of the five assemblers: Omega was generally more suitable for datasets with longer reads and higher coverage depth using larger overlaps; SOAPdenovo and MetaVelvet were efficient in memory and CPU usage, which is critical for large datasets; IDBA-UD automatically iterated through a k-mer range and provided better assembly for more genomes in the HiSeq 100-bp dataset; and Celera performed well for long reads but was computationally very expensive for Illumina datasets. It is important for users to select an assembler based on test assembly results from their actual metagenome datasets. It may also be advantageous to use a dedicated metagenome scaffolding algorithm, such as Bambus 2 (<ref type="bibr" target="#b3">Koren et al., 2011</ref>), or to combine multiple assembly tools using the metAMOS pipeline (<ref type="bibr" target="#b18">Treangen et al., 2013</ref>). In conclusion, our results indicated the effectiveness of the overlap graph approach for metagenome assembly. We believe the overlap graph approach will become more useful for future Illumina technologies with longer reads and higher throughput.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Overview of Omega. The prefix and suffix (red sections) of every read are indexed in a hash table. As reads are aligned using the hash table, transitive edges (green arrows) are removed. In the unitig graph, edges (blue arrows) represent unambiguous series of overlapping reads, vertices (red dots) represent branching points and flows (green numbers) estimate the copy numbers of strings in the edges. The mate-pair linkages (orange dotted lines) are used to build contigs and then scaffolds containing gaps (blue dotted arrows). The repeat region between two different genomes (the edge with 2 units of flow) may be resolved using mate-pair supports (as shown here) or coverage depth information</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. Scaffold assembly statistics for individual genomes from the HiSeq 100-bp dataset. The x-axis lists the 64 genomes in alphabetic order, and the indices and organism names of the genomes are shown in the legend. The assemblies were provided by SOAPdenovo (blue squares), IDBA-UD (green triangles), MetaVelvet (black diamonds) and Omega (solid red circles). Outliers below the minimum threshold of a performance statistics are not shown</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Table 2. Comparison of overall assembly statistics on the MiSeq 300-bp dataset*</figDesc><table>Assembly 
Statistics 
Assembler 
Total 
contigs 

N50 
contigs 

N80 
(10 3 bp) 

N50 
(10 3 bp) 

N20 
(10 3 bp) 

Largest 
contig (10 3 bp) 

Sum 
(10 6 bp) </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Table 1.</figDesc><table>Average genome assembly statistics across all genomes in the 
HiSeq 100-bp dataset 

Assembler 
N80 
(10 3 bp) 

N50 
(10 3 bp) 

N20 
(10 3 bp) 

Largest 
Contig 
(10 3 bp) 

Coverage 
(%) 

SOAPdenovo 
11 
33 
73 
144 
92.81 
MetaVelvet 
17 
46 
92 
147 
82.10 
Omega 
25 
61 
111 
174 
94.50 
IDBA_UD 
35 
70 
136 
203 
95.65 </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="true"><figDesc>Table 3. Comparison of error profiles and computational costs of the MiSeq 300-bp dataset assembly</figDesc><table>Assembler 
Verified N50 
(10 3 bp) 

Verified N50 
/ Raw N50 

Small 
Insertion 
5 5bp (bp) 

Large 
Insertion 
5bp (bp) 

Small 
Deletion 
5 5bp (bp) 

Large 
Deletion 
5bp (bp) 

Substitution 
(bp) 

Chimeric 
Contigs 

CPU 
(hours) 

Memory 
(GB) 

SOAPdenovo 
20 
100% 
0 
0 
0 
0 
2485 
2 
3 
19 
IDBA_UD 
95 
93.1% 
9 
502 
35 
1443 
732 
101 
8 
24 
MetaVelvet 
135 
99.3% 
10 
0 
2 
0 
298 
65 
1 
8 
Celera 
151 
100% 
11 
220 
5 
122 
1384 
19 
67 
19 
Omega 
158 
99.4% 
13 
35 
23 
28 
1958 
43 
3 
22 </table></figure>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">B.Haider et al. at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">Omega at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="annex">
			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">ALLPATHS: de novo assembly of whole-genome shotgun microreads</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Butler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="810" to="820" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">An efficient implementation of a scaling minimum-cost flow algorithm</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">V</forename>
				<surname>Goldberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="1" to="29" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title level="m" type="main">A New Algorithm for De Novo Genome Assembly</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Haider</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Bambus 2: scaffolding metagenomes</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Koren</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="2964" to="2971" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Fast gapped-read alignment with Bowtie 2</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">L</forename>
				<surname>Salzberg</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat. Methods</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="357" to="359" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Fast and accurate long-read alignment with BurrowsWheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="589" to="595" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">De novo assembly of human genomes with massively parallel short read sequencing</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="265" to="272" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">A whole-genome assembly of Drosophila</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">287</biblScope>
			<biblScope unit="page" from="2196" to="2204" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">The fragment assembly string graph</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<forename type="middle">W</forename>
				<surname>Myers</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="79" to="85" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
	<note>Suppl. . 2</note>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">MetaVelvet: an extension of Velvet assembler to de novo metagenome assembly from short sequence reads</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Namiki</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page">155</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">IDBA—A Practical Iterative de Bruijn Graph De Novo Assembler</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research in Computational Molecular Biology</title>
		<editor>Berger,B.</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="426" to="440" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">IDBA-UD: a de novo assembler for single-cell and metagenomic sequencing data with highly uneven depth</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Peng</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="1420" to="1428" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pop</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">MetaSim: a sequencing simulator for genomics and metagenomics</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">C</forename>
				<surname>Richter</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PloS One</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page">3373</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Comparative metagenomic and rRNA microbial diversity characterization using archaeal and bacterial synthetic communities</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Shakya</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Environ. Microbiol</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="1882" to="1899" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Efficient de novo assembly of large genomes using compressed data structures</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="549" to="556" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<monogr>
		<title level="m" type="main">ABySS: a parallel assembler for short read sequence data</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">T</forename>
				<surname>Simpson</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1117" to="1123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">MetAMOS: a modular and open source metagenomic assembly and analysis pipeline</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">J</forename>
				<surname>Treangen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page">2</biblScope>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Velvet: algorithms for de novo short read assembly using de Bruijn graphs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">R</forename>
				<surname>Zerbino</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Birney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="821" to="829" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>