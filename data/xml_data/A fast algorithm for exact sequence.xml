
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:44+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A fast algorithm for exact sequence search in biological sequences using polyphase decomposition</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010">2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Abhilash</forename>
								<surname>Srikantha</surname>
							</persName>
							<email>.abhilash@samsung.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Samsung Advanced Institute of Technology India Lab</orgName>
								<address>
									<settlement>Bangalore</settlement>
									<region>Karnataka</region>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Ajit</forename>
								<forename type="middle">S</forename>
								<surname>Bopardikar</surname>
							</persName>
							<email>ajit.b@samsung.com</email>
							<affiliation key="aff0">
								<orgName type="institution">Samsung Advanced Institute of Technology India Lab</orgName>
								<address>
									<settlement>Bangalore</settlement>
									<region>Karnataka</region>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Kalyan</forename>
								<surname>Kumar Kaipa</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">Samsung Advanced Institute of Technology India Lab</orgName>
								<address>
									<settlement>Bangalore</settlement>
									<region>Karnataka</region>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Parthasarathy</forename>
								<surname>Venkataraman</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">Samsung Advanced Institute of Technology India Lab</orgName>
								<address>
									<settlement>Bangalore</settlement>
									<region>Karnataka</region>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Kyusang</forename>
								<surname>Lee</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Emerging Center</orgName>
								<orgName type="laboratory">Genetic Analysis Group</orgName>
								<orgName type="institution">Samsung Advanced Institute of Technology</orgName>
								<address>
									<settlement>Suwon</settlement>
									<country key="KR">South Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Taejin</forename>
								<surname>Ahn</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Emerging Center</orgName>
								<orgName type="laboratory">Genetic Analysis Group</orgName>
								<orgName type="institution">Samsung Advanced Institute of Technology</orgName>
								<address>
									<settlement>Suwon</settlement>
									<country key="KR">South Korea</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Rangavittal</forename>
								<surname>Narayanan</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution">Samsung Advanced Institute of Technology India Lab</orgName>
								<address>
									<settlement>Bangalore</settlement>
									<region>Karnataka</region>
									<country key="IN">India</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A fast algorithm for exact sequence search in biological sequences using polyphase decomposition</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">26</biblScope>
							<biblScope unit="page" from="414" to="419"/>
							<date type="published" when="2010">2010</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq364</idno>
					<note>[10:28 28/8/2010 Bioinformatics-btq364.tex] Page: i414 i414–i419 BIOINFORMATICS</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<textClass>
				<keywords>Contact: s</keywords>
			</textClass>
			<abstract>
				<p>Motivation: Exact sequence search allows a user to search for a specific DNA subsequence in a larger DNA sequence or database. It serves as a vital block in many areas such as Pharmacogenetics, Phylogenetics and Personal Genomics. As sequencing of genomic data becomes increasingly affordable, the amount of sequence data that must be processed will also increase exponentially. In this context, fast sequence search algorithms will play an important role in exploiting the information contained in the newly sequenced data. Many existing algorithms do not scale up well for large sequences or databases because of their high-computational costs. This article describes an efficient algorithm for performing fast searches on large DNA sequences. It makes use of hash tables of Q-grams that are constructed after downsampling the database, to enable efficient search and memory use. Time complexity for pattern search is reduced using beam pruning techniques. Theoretical complexity calculations and performance figures are presented to indicate the potential of the proposed algorithm.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Decreasing costs of sequencing personal genome have opened up many avenues of research. Several efforts related to Personal Healthcare and Pharmacogenetics are attempting to use the information in an individual's genomic data towards personalization of healthcare. An important component of these solutions is the search for specific subsequences in a given genome. For example, Cetuximab (<ref type="bibr" target="#b6">Eric et al., 2009</ref>)—an Epidermal Growth Factor Receptor (EFGR) inhibitor used to treat various types of cancer is ineffective if certain mutations in the KRAS gene (which lies in Exon 2 of Chromosome 12) exist. Thus, a search for appropriate mutations conducted on genetic data would be vital in prescribing the most effective treatment. Exact sequence search also finds application in fields such as Evolutionary Biology and Phylogenetics where certain subsequences of DNA are mined from genomic data of various species of organisms to understand their origin, relatedness and descent. In the above context, the challenge is to be able to perform fast pattern searches in whole genomes (a complete human genome contains 3 billion base pairs) and databases spanning Giga to Tera Bytes or more. Prevalent search methods (<ref type="bibr" target="#b2">Altschul et al., 1990;</ref><ref type="bibr" target="#b4">Charras and Lecroq, 2004;</ref><ref type="bibr" target="#b8">Gusfield 1997;</ref><ref type="bibr" target="#b10">Kurtz et al., 2004;</ref><ref type="bibr" target="#b12">Li and Durbin, 2010;</ref><ref type="bibr" target="#b13">Lipman and Pearson, 1985;</ref><ref type="bibr" target="#b14">Ma et al., 2002;</ref><ref type="bibr" target="#b16">Ning et al., 2001</ref>) use techniques that have proven to be efficient for * To whom correspondence should be addressed. existing genomic sequences and databases, but do not scale up well for large datasets such as those of whole human genomes. Fast and efficient search methods that scale up well for large databases are therefore of great value. In this article, we address the problem of searching for all occurrences of pattern P in a text T, where T is the reference sequence whose length can vary from several million (in case of individual chromosomes) to several billion (in case of complete genomes) bases. P is the pattern which is a few tens to a few hundred bases in length.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Many methods have been developed for the task of pattern search. These include FASTA (<ref type="bibr" target="#b13">Lipman and Pearson, 1985;</ref><ref type="bibr" target="#b17">Pearson and Lipman, 1988</ref>), BLAST (<ref type="bibr" target="#b2">Altschul et al., 1990</ref>), PatternHunter (<ref type="bibr" target="#b14">Ma et al., 2002</ref>), MUMMER (<ref type="bibr" target="#b10">Kurtz et al., 2004</ref>), SSAHA (Sequence Search and Alignment using Hashing Algorithm) (<ref type="bibr" target="#b16">Ning et al., 2001</ref>), Fast String Matching Algorithms (<ref type="bibr" target="#b11">Lecroq, 2007</ref>) and BWA-SW (Burrows Wheeler Alignment—Smith Waterman) (<ref type="bibr" target="#b12">Li and Durbin, 2010</ref>). Though Smith Waterman-based methods such as FASTA mines approximate matches by employing dynamic programming techniques, they are computationally very intensive. BLAST and its variants are an improvement over FASTA in that they use certain seeds for basic anchoring, which are then extended to exact or approximate matches. However, apart from being probabilistic in nature, BLAST type algorithms require large amounts of memory and computing time for pattern search in large sequences such as whole genomes. PatternHunter (<ref type="bibr" target="#b14">Ma et al., 2002</ref>) is a similar seedbased technique but is still inefficient for applications that involve whole genomes or large databases. Recent suffix tree-based methods (<ref type="bibr" target="#b8">Gusfield, 1997</ref>) such as Mummer (<ref type="bibr" target="#b10">Kurtz et al., 2004</ref>) that yield exact matches have a very low-search time complexity. They represent all suffixes of the text as a plurality of inter-mingled linked lists. At times when the knowledge about genomes gets updated frequently, updating the suffix tree in place becomes tedious as the inter-mingling of linked lists is very sensitive to changes in the text data. Also, as every node in the tree is required to hold tree-related information such as pointers to their parents and children apart from text-based information, even the best implementation of suffix trees require ∼15.4 bytes per base (<ref type="bibr" target="#b10">Kurtz et al., 2004</ref>), which scales up to 46 GB of memory to store the preprocessed Human Genome. Deterministic Finite Automaton (DFA)-based methods (<ref type="bibr" target="#b4">Charras and Lecroq, 2004;</ref><ref type="bibr" target="#b8">Gusfield 1997</ref>) such as BWA-SW (<ref type="bibr" target="#b12">Li and Durbin, 2010</ref>) combine DFA and dynamic-programming-basedPage: i415 i414–i419</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A fast algorithm for exact sequence search in biological sequences using polyphase decomposition</head><p>alignment methods. As this method involves Finite Automaton, the method does not scale well for large sequences, even for the best case of exact matches. Also, because they use dynamic programming, the memory requirements of the method are huge. Hashing-based methods such as SSAHA (<ref type="bibr" target="#b16">Ning et al., 2001</ref>) and those proposed by Lecroq (2007) propose substring matching and Q-gram hashing method to greatly improve the time complexity. To summarize, efficient biological pattern-search algorithms must mitigate two problems. First, that of random access into text, without which the time complexity of the algorithm shoots up to an unacceptable O(L T ) (<ref type="bibr" target="#b4">Charras and Lecroq, 2004;</ref><ref type="bibr" target="#b9">Knuth et al., 1977;</ref><ref type="bibr" target="#b15">Melichar, 1995</ref>), where T is of the order of several billion bases. This can be mitigated by employing mechanisms such as suffix trees and hash tables. Hashing methods are considered because changing data locally is an easy task when information in the corresponding sequence gets updated. The second problem is that of memory constraints. Random access algorithms (<ref type="bibr" target="#b10">Kurtz et al., 2004;</ref><ref type="bibr" target="#b11">Lecroq, 2007;</ref><ref type="bibr" target="#b16">Ning et al., 2001</ref>) come with an undesirable space complexity of O(L T ), where L T is the length of the text T is of the order of several billion bases. In our work, we propose an efficient methodology that employs down-sampled version of T and polyphase decomposition of P to determine potential areas of exact match. These, in conjunction with hash tables and the use of Q grams to successively refine potentialsearch regions results in superior space and time complexity. Note that the present method differs from the existing methods (<ref type="bibr" target="#b11">Lecroq, 2007;</ref><ref type="bibr" target="#b16">Ning et al., 2001</ref>) in that, firstly, we consider down-sampled substrings of both text and the pattern that result in large memory savings. Secondly, the Q-grams have traditionally been used only for the purposes of string matching, but in the proposed method, their locations have been used to progressively localize the potential locations of exact match. We now describe the proposed algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">PROPOSED METHOD</head><p>We first explain various terminologies we use in the exposition that follows. For this purpose, we use an example sequence, given by:</p><formula>S = 'actgcttctact'.</formula><formula>(1)</formula><p>Let the length of the sequence S be denoted by L S. Also, S<ref type="bibr">[n]</ref>is used to represent the n-th base of the sequence S. For example, S<ref type="bibr">[0]</ref>= 'a' and S<ref type="bibr">[1]</ref>= 'c'. Downsampling (<ref type="bibr" target="#b18">Vaidyanathan, 1993</ref>) a sequence by a factor of M means that we pick every M-th base from sequence S to form a new sequence SM given by:</p><formula>SM[n]=S[Mn],0 ≤ n ≤ L S M (2)</formula><p>where, indicates the largest integer less than the argument. For example, for the sequence S and M = 3, S3 = 'agta' M-channel polyphase decomposition (<ref type="bibr" target="#b18">Vaidyanathan, 1993</ref>) gives M possible down-sampled sequences for different integer-phase shifts. The generalized form of polyphase decomposition is given by:</p><p>SMi<ref type="bibr">[n]</ref>=S<ref type="bibr">[Mn+i]</ref>,</p><formula>0 ≤ n ≤ L S M ,0 ≤ i ≤ M −1.</formula><formula>(3)</formula><p>Note that SM = SM0. The polyphase decomposition of the sequence S in Equation (1) for M = 3 yields: S30 = 'agta', S31 = 'cccc' and S32 = 'tttt'</p><p>A Q-gram of a sequence S is denoted by QS(n) and is made up of Q consecutive bases starting from position n. Thus for sequence S as in Equation</p><p>(1) example Q-grams are:</p><p>QS(0) = 'actg' QS(1) = 'ctgc'</p><p>QS(2) = 'tgct' QS(8) = 'tact'</p><p>Contiguous Q-grams of a sequence S is the set:</p><formula>CQS = QS 0 QS 1 ···QS L S −Q (4)</formula><p>where the cardinality of the set CQS is |CQS|=L S −Q+1. Note that there are Q – 1 common bases between any two consecutive Q-grams in CQS. For example, given S as in Equation</p><p>(1) and Q = 4,</p><formula>CQS = {'actg', 'ctgc', 'tgct', 'gctt', 'cttc', 'ttct', 'tcta', 'ctac', 'tact'}.</formula><p>NQS is the set of non-overlapping Q-grams of sequence S given by:</p><formula>NQS = QS 0 QS Q ...QS L S Q .</formula><formula>(5)</formula><p>Note that:</p><formula>∀ QS i and QS j ∈ NQS, QS i ∩QS j = φ if i = j</formula><p>where φ denotes the null set. That is the Q-grams in NQS are pairwise and non-overlapping. For S as in Equation (1) and Q = 4, NQS = {'actg', 'cttc', 'tact'}. We now describe the proposed method which is composed of two stages, namely:</p><p>(1) Preprocessing stage.</p><p>(2) Pattern-search stage.</p><p>The detailed description of each stage is presented in the following subsections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Preprocessing stage</head><p>A block diagram for the preprocessing stage is shown in<ref type="figure" target="#fig_1">Figure 1</ref>. In this step, text T is downsampled and processed into a hash table to support random access into the text. A hash table is a data structure that efficiently links keys to corresponding values called buckets (<ref type="bibr" target="#b5">Cormen et al., 1990</ref>). In our case, the key refers to each distinct Q-gram while bucket refers to the list of locations of that Q-gram in the text. Here, T is first downsampled by a factor of M to give TM and a hash table H TMQ is then constructed using contiguous Q-grams of TM. The bucket of a given Q-gram q is denoted by H TMQ<ref type="bibr">[q]</ref>. The details of the preprocessing algorithm are given below. This is followed by an example on sample text.</p><formula>Algorithm–A</formula><p>(1) Downsampled the text T by a factor of M to yield TM.</p><p>(2) Generate the set of contiguous Q-grams for TM, namely, CQTM.</p><p>(3) For each Q-Gram in CQTM, consult the key field of the hash(4) If the Q-Gram exists in the key field, append the new position in the bucket H TMQ<ref type="bibr">[Q-gram]</ref>.</p><p>(5) Else, add a new Q-gram key and its position in the corresponding bucket in H TMQ .</p><p>Example: Consider the sequence T = 'acc gat tag aag ggt tta aga gtc tca acc aga cta agc'. For M = 3 and Q = 3, the result of the algorithm is given below.</p><p>(1) T3 = agtagtagtaaca.</p><p>(2) CQT3:{agt(0), gta(1), tag(2), agt(3), gta(4), tag(5), agt(6), gta(7), taa(8), aac(9), aca(10)}. Note that we have also mentioned the indices for each Q-gram in CQT3 in parentheses.</p><p>(3) Finally the H TMQ is as given in<ref type="figure" target="#tab_1">Table 1</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Pattern-search stage</head><p>The idea behind the pattern-search algorithm is that given T and P, if P occurs in T at unknown locations, it is necessary that at least one downsampled polyphase PMi of P occurs in TM. Note that the reverse need not be true, that is, a certain PMi occurring in TM does not guarantee that P occurs in T. Therefore, we first mine for all occurrences of PMi in TM and search around the resulting indices for an exact match in T.<ref type="figure" target="#fig_3">Figure 2</ref>presents the block diagram of the procedure.</p><p>The definitions of crucial variables are given below:</p><p>(1) PPAll: this is the array that holds the locations of exact matches for all polyphases of P. The elements of PPAll denoted by PPAll(n).</p><p>(2) PP: this is the array that holds the locations of exact matches of a particular polyphase of P. The elements of PP are denoted by PP(n).</p><p>The algorithm breaks each polyphase into non-overlapping Q-grams and bases its search on a successive refinement principle by employing beam pruning technique. That is, matches to the first non-overlapping Q-gram are first found. If these matches extend to the next Q-gram, then these locations are retained. This process is carried out for all the Q-grams in the given polyphase. At the end of this process, those locations where all the Q-grams match represent the locations where the polyphase PMi matches TM. These locations are then mapped to the original text T where the final search takes place. In this manner, the algorithm successively refines the search regions and thus speeds the search process. The algorithm is presented below followed by an example on a sample pattern. Algorithm—B</p><p>(1) Generate PMi 0 ≤ i ≤ M −1 from P using Polyphase Decomposition.</p><p>(2) Initialize PPAll = {φ} (an empty array).</p><p>(3) For each polyphase PMi, do (4) and (8).</p><p>(4) Generate NQPMi (set of non-overlapping Q-grams of polyphase PMi).</p><p>(5) PP = H TMQ [<ref type="bibr">NQPMi(0)]</ref>(this represents all positions in TM where an exact match is found for the first non overlapping Q-gram of PMi).</p><p>(6) For all NQPMi(j) ∈NQPMi, j &gt; 0 (the rest of the entries in NQPMi) do (7).</p><p>(7) Delete from PP, PP(k) such that PP(k) + jQ / ∈ H TMQ [NQPMi(j)] NQPMi(j) should have occurred at location PP(k) + jQ if there was an exact match. But, if that is not the case, there is no chance of an exact match of polyphase PMi in TM at location PP(k). Hence, it must be pruned from the array PP.</p><p>(8) Append all PP (k) ∈ PP into PPAll. That is, make note of all locations of exact match of PMi in TM in the array PPAll that holds the locations of exact match for all PMis in TM.</p><p>(9) Translate PPAll(n) to corresponding location in original text T and verify exact match of P in T in that location.Page: i417 i414–i419(1) PM0 = 'agtagt' PM1 = 'agtgtc' PM2 = 'gtaaca'.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A fast algorithm for exact sequence search in biological sequences using polyphase decomposition</head><p>(2) PPAll = {φ} (an empty array) (3) Iterating for PM0 for Steps (4) and (8).</p><p>(4) NQPM0 = {agt(0), agt(1)} (note that we have mentioned the indices of the Q-gram in NQPM0 in parenthesis).</p><formula>(5) PP = H TNQ [NQPM0(0)] = [0,3,6].</formula><p>(6) Iterating over {agt(1)} for Step (7).</p><p>(7) Prune only PP(2).</p><formula>Because PP(2)+1×Q = 6+3 = 9 / ∈ H TNQ [NQPM0(1)].</formula><formula>(8) PPAll = {0,3},</formula><p>(a) result of PM1: PP = {φ};</p><p>(b) result of PM2: PP = {7}. Therefore, PPAll = {0,3,7}.</p><p>(9) Translating the locations of PPAll to those in T gives {0,9,19}. Note that we have considered the actual polyphase the exact match has come from. For example, as PPAll<ref type="bibr">[2]</ref>= 7 come from the second polyphase, the mapping of this location to a location in T would be PPAll<ref type="bibr">[2]</ref>×M −2 = 19. Exact matches are now verified starting from these locations in T. In this example, the exact match occurs at index 9 in T.</p><p>Note that if the length of PMi is not an integral multiple of Q, then certain trailing nucleotides will be missed by the NQPMi. One of the solutions in order to avoid this loss is to verify exact match of PMi in TM for all PP(n) just before Step (8).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ALGORITHM ANALYSIS</head><p>We now present the space and time complexity analysis of the proposed method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Space complexity of hash table</head><p>From Algorithm A, because every overlapping Q-gram in TM contributes to an entry in the hash table, the algorithm's space complexity is O(L TM ) where the length of TM, L TM = L T /M due to downsampling. Also, because constructing the hash table is a sequential process, its time complexity is O(L TM ). Note that there are two types of memory in a computer—main memory, which is fast, costly and scarce and the secondary memory, which is slow, cheap and abundant. An efficient design of an algorithm is an optimal balance between its speed and its main memory requirements. In our design, we have retained a smaller, down-sampled version of the text T in the main memory, which we consider for space complexity calculations. For the purposes of exact match verification in Step (9) of Algorithm B, the original text T can reside in the cheaper secondary memory, and relevant sections (with length &lt;&lt; L T ) can be paged into the main memory when required. Also note that if we set M = 1, the H TMQ reduces to its naïve version and its main memory requirements are then O(L T ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Time complexity of pattern search</head><p>We will now discuss the time complexity for pattern search (Algorithm B). In our analysis, we model the base distribution as an iid process and following uniform distribution. This is reasonable over large databases because it has been shown that DNA sequences at best have weak long-range correlations (<ref type="bibr" target="#b3">Bernaola et al., 2002</ref>). The complexity of processing a particular polyphase as described in Steps (4) and</p><p>(8) is as given below. Step 4 is the generation of the NQPMi list. This step which generates non overlapping Q-grams is computationally simple and its effect on the search complexity can be neglected. Step 5 is a look up from the hash table. Because this step is only a main memory lookup (<ref type="bibr" target="#b5">Cormen et al., 1990</ref>), it contributes O(1) to the search complexity. Also, It follows from our assumption that the distribution of bases is uniform and iid, the probability of the existence of any given Q-gram = 1/4 Q. Thus, the expected number of any Q-grams in TM = L TM ×(1/4 Q ). That is, the expected number of matches for the first Q-gram in any given polyphase is L TM /4 Q. Step 7 is the beam pruning procedure, where entries from the array PP are removed based on the entries in the bucket H TMQ [<ref type="bibr">NQPMi(j)]</ref>. This translates to traversal of both arrays, namely, PP and H TMQ [<ref type="bibr">NQPMi(j)]</ref>. The complexity of this step then depends on the lengths of each array. @BULLET The bucket: following the above explanation, the bucket has an average of</p><formula>L TM /4 Q entries.</formula><p>@BULLET The PP Array: note that for any j, the PP Array holds the locations of a string of length j ×Q. Therefore, the expected length of the PP Array for any j is</p><formula>L TM /4 jQ .</formula><p>As a result, employing binary search, the complexity of the beam pruning procedure for a single polyphase is</p><formula>O((L TM /4 Q )log(L TM /4 Q )). Also, note that Steps (1), (2)</formula><p>and</p><p>(8) are computationally simple and their contribution to the search complexity can be neglected. Now, the complexity of the algorithm until Step (9) is the complexity of beam pruning procedure for all M polyp</p><formula>hases = O(M(L TM /4 Q )log(L TM /4 Q ))) = O((L T /4 Q )log(L TM /4 Q )).</formula><p>The complexity of Step (9) is negligible as its of order</p><formula>O(L P ), L P &lt;&lt; L T .</formula><p>Thus the overall time complexity for the search procedure:</p><formula>O((L T /4 Q )log(L T /M4 Q )).</formula><p>A comparison of complexities of various search algorithms are given in<ref type="figure" target="#tab_2">Table 2</ref>. As can be seen from the table, the proposed method has superior complexity as compared to most existing methods. Also, while i417</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.Srikantha et al.</head><formula>BLAST a O(L P L T ) b O(L P L T ) FASTA a O(L P L T ) O(L P L T ) Finite automaton O(L P ) O(L T ) Knuth Morris Pratt O(L P ) O(L T ) Suffix tree based O(L T ) O(L P ) BWA-SW O(L P ) O(L 0.628 P L T ) SSAHA O(L T ) O((L T /4 Q )log(L T /4 Q )) Proposed O(L T /M) O((L T /4 Q )log(L T /M4 Q )) a Methods also yield approximate matches. b L P &lt;&lt; L T &lt;&lt; L T .</formula><p>The bold line corresponds to the complexity of the proposed algorithm.the suffix-tree approach would possibly have the advantage of a slightly better time complexity when compared to the proposed method, this advantage could be offset by its huge memory requirements. The space savings would be particularly useful in processing huge sequences such as whole genomes. Also, note that because the algorithm works on polyphase decomposition with little inter-dependency between each polyphase, it lends itself to easy parallelization thereby speeding up its operation.</p><formula>Q = 8 Q = 9 Q = 10 Q = 11 M = 7</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Experimental analysis</head><p>The algorithm was implemented using Python. The text T considered is the Human Chromosome 1 (L T = 250 M bases) (Genome Reference Consortium, UCSC) the pattern P is randomly chosen segment of 300 bases (L P = 300) from T. All experiments were conducted on a PC with a 2 GB RAM and Intel 2.4 GHz Quad core processor. The variation of the size of the hash table with varying M and Q is presented in<ref type="figure" target="#tab_3">Table 3</ref>. It can be seen that the size of the hash table decreases with increasing M as expected. Also, it can be seen that the size of the hash table increases slightly with increasing Q. The variations in time taken to process the pattern and generate a list of locations for post processing are presented in<ref type="figure" target="#tab_4">Table 4</ref>. Note that the combination of parameters M and Q must satisfy the condition MQ &lt; L P. Otherwise, at least one of the polyphases will contain &lt; Q bases, and thus cannot be looked up through the hash table. The blocks whose M −Q combination is infeasible for L P = 300 are marked with '–'. It can be seen that as M and Q increases, the search time decreases as expected. Also, as M increases, the number of potential exact matches that must be post-processed also increases.<ref type="figure" target="#tab_5">Table 5</ref>provides this data.Thus, it can be seen from the data presented that a large M results in a smaller hash table, but also generates larger number of potential matches that must be post processed. Also, a larger Q speeds up the polyphase search, but demands larger hash table size. Therefore, values M and Q must be carefully chosen. For example, for setting parameters M and Q for a pattern of length ∼300,<ref type="figure" target="#tab_3">Table 3</ref>inspires us to use a highest value of M = 39 (because this gives the smallest hash table). However, the numbers in table<ref type="figure" target="#tab_4">Table 4</ref>suggest that it would be reasonable to select the higher values of Q and set M ∼ 23 (because higher M −Q combinations are either slow or infeasible) and further consultation with<ref type="figure" target="#tab_5">Table 5</ref>indicates that a combination of M = 23 and Q = 11 is practical (because the number of matches that must be post processed are near minimal). Thus an optimal choice of parameters would be M = 23 and Q = 11, which requires 45.3 MB for the hash table (Text size = 250 M bases). Also, with respect to the pattern (Pattern size = 300 bases) related searching time, 0.5 ms are required to generate the list of exact matches of polyphases in the downsampled text. Another 1 ms is required to verify if the exact polyphase match translates to exact match in text. Thus a total of 1.5 ms were required for mining exact matches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">CONCLUSION</head><p>In this article, we presented a method for fast exact sequence search that relies on downsampling and polyphase representations to expedite the search process. We also computed the complexity of the algorithm and showed it to be better than existing methods. Because the proposed method uses polyphase representations, and because searching for exact matches in multiple polyphases does not have any data or functional inter-dependency, the algorithm can be parallelized. This would further reduce time complexity. Implementation of a parallel version of the algorithm will be a topic of further work. The proposed algorithm addresses the problem of finding exact matches to a substring. Our future research will extend the utility of this algorithm to finding approximate matches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Conflict of Interest: none declared.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i418</head></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>[10:28 28/8/2010 Bioinformatics-btq364.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.1.</head><figDesc>Fig. 1. Block diagram of the preprocessing stage.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>Note that Steps (4) and (8) deal with extracting exact locations of PMi in TM. Step (7) is a beam-pruning method to prune out non-exact-match locations of PMi from the PP. Example: Consider P = 'aag ggt tta aga gtc tca'. Also M, Q and T as are the same as those used in the previous illustration. We show the steps of the algorithm for one of the polyphases: PM0. The results of the other two polyphases are presented in Step (8). i416 [10:28 28/8/2010 Bioinformatics-btq364.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.2.</head><figDesc>Fig. 2. Block diagram of the pattern-search stage.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>table H TMQ .</figDesc><table>i415 A.Srikantha et al. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><figDesc>Table 1. A sample Q-gram hash table</figDesc><table>Key: Q(=3) gram 
Bucket: Locations' list 

agt 
0, 3, 6 
gta 
1, 4, 7 
tag 
2, 5 
taa 
8 
aac 
9 
aca 
10 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 2. Comparison of theoretical complexities of various pattern/homology search algorithms Search algorithm Space complexity Time complexity</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>Table 3. Hash table size for M −Q combinations (MB)</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="true"><figDesc>Table 4. Search times for various M −Q combinations (in micro seconds) Q = 8 Q = 9 Q = 10 Q = 11</figDesc><table>M = 7 
1830 
277 
27 
30 
M = 15 
288 
33 
7 
3 
M = 23 
105 
9 
1.4 
0.5 
M = 31 
108 
8 
– 
– 
M = 3 9 
– 
– 
– 
– 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Table 5. Number of matches to be post processed versus M M = 7 M = 15 M = 23 M = 31</figDesc><table>Number of matches 
1 
1 
2 
330 

</table></figure>

			<note place="foot">© The Author(s) 2010. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/2.5), which permits unrestricted non-commercial use, distribution, and reproduction in any medium, provided the original work is properly cited. at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from [10:28 28/8/2010 Bioinformatics-btq364.tex] Page: i416 i414–i419</note>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">i419 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">108</biblScope>
			<biblScope unit="page" from="28" to="28" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>btq364. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title level="m" type="main">Page: i419 i414–i419 A fast algorithm for exact sequence search in biological sequences using polyphase decomposition REFERENCES</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">Basic local alignment search tool</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Mol. Biol</title>
		<imprint>
			<biblScope unit="volume">215</biblScope>
			<biblScope unit="page" from="403" to="410" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Study of statistical correlations in DNA Sequences</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Bernaola-Galvan</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Gene</title>
		<imprint>
			<biblScope unit="volume">300</biblScope>
			<biblScope unit="page" from="105" to="115" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">Handbook of Exact String Matching Algorithms</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Charras</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Lecroq</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2004" />
			<publisher>Kings College, London Publications</publisher>
			<pubPlace>London</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title level="m" type="main">Hash tables In Introduction to Algorithms</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Cormen</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>McGraw Hill MIT Press</publisher>
			<biblScope unit="page" from="221" to="245" />
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
	<note>2nd. edn</note>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">Cetuximab and chemotherapy as initial treatment for metastatic colorectal cancer</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<forename type="middle">C</forename>
				<surname>Eric</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">N. Engl. J. Med</title>
		<imprint>
			<biblScope unit="volume">360</biblScope>
			<biblScope unit="page" from="567" to="578" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Ucsc</forename>
				<surname>Genome Reference Consortium</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<monogr>
		<title level="m" type="main">Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1997" />
			<publisher>Cambridge University Press</publisher>
			<pubPlace>Cambridge, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast pattern matching in strings</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Knuth</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="323" to="350" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Versatile and open software for comparing large genomes</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kurtz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">12</biblScope>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Fast exact string matching algorithms</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Lecroq</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inf. Process. Lett</title>
		<imprint>
			<biblScope unit="volume">102</biblScope>
			<biblScope unit="page" from="229" to="235" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Fast and accurate long-read alignment with Burrows– Wheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="589" to="595" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Rapid and sensitive protein similarity searches</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Lipman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">R</forename>
				<surname>Pearson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">227</biblScope>
			<biblScope unit="page" from="1435" to="1441" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">PatternHunter: faster and more sensitive homology search</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="440" to="445" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Approximate string matching by finite automata</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Melichar</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer analysis of images and patterns</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="342" to="349" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">SSAHA: a fast search method for large DNA databases</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Ning</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1725" to="1729" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Improved tools for biological sequence comparison</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">R</forename>
				<surname>Pearson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Lipman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. Natl Acad. Sci</title>
		<imprint>
			<biblScope unit="volume">85</biblScope>
			<biblScope unit="page" from="2444" to="2448" />
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<monogr>
		<title level="m" type="main">Multirate Systems and Filter Banks</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">P</forename>
				<surname>Vaidyanathan</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>Prentice-Hall</publisher>
			<pubPlace>Englewood Cliffs, NJ</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>