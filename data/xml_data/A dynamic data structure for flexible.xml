
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-11T00:00+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A dynamic data structure for flexible molecular maintenance and informatics</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2011">2011</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Chandrajit</forename>
								<surname>Bajaj</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<settlement>Austin</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Rezaul</forename>
								<forename type="middle">Alam</forename>
								<surname>Chowdhury</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<settlement>Austin</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Muhibur</forename>
								<surname>Rasheed</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Texas at Austin</orgName>
								<address>
									<settlement>Austin</settlement>
									<region>TX</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A dynamic data structure for flexible molecular maintenance and informatics</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">27</biblScope>
							<biblScope unit="issue">1</biblScope>
							<biblScope unit="page" from="55" to="62"/>
							<date type="published" when="2011">2011</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq627</idno>
					<note type="submission">Structural bioinformatics Advance Access publication November 25, 2010 Received on August 2, 2010; revised on October 15, 2010; accepted on October 30, 2010</note>
					<note>[11:31 2/12/2010 Bioinformatics-btq627.tex] Page: 55 55–62 Associate Editor: Anna Tramontano Contact: bajaj@cs.utexas.edu Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: We present the &apos;Dynamic Packing Grid&apos; (DPG), a neighborhood data structure for maintaining and manipulating flexible molecules and assemblies, for efficient computation of binding affinities in drug design or in molecular dynamics calculations. Results: DPG can efficiently maintain the molecular surface using only linear space and supports quasi-constant time insertion, deletion and movement (i.e. updates) of atoms or groups of atoms. DPG also supports constant time neighborhood queries from arbitrary points. Our results for maintenance of molecular surface and polarization energy computations using DPG exhibit marked improvement in time and space requirements.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Many human functional processes are mediated through the interactions among proteins, a major molecular constituent of our anatomical makeup. A computational understanding of these interactions provides important clues for developing therapeutic interventions related to diseases such as cancer and metabolic disorders. Computational methods such as automated docking through shape and energetic complementarity scoring aim to gain insight and predict such molecular interactions. Docking (<ref type="bibr" target="#b10">Bajaj et al., 2009b;</ref><ref type="bibr" target="#b21">Gilson and Zhou, 2007</ref>) involves induced complementary fit between flexible protein interfaces. The flexible docking solution space consisting of all relative positions, orientations and conformations of the proteins is searched, and each putative docking is evaluated using combinations of interface complementarity scoring and atomic pairwise charged Coulombic interactions. Also, since proteins function in predominantly watery (solvent) environment, the protein solvation energy also plays an important role in determining intermolecular binding affinities 'in vivo' for drug screening, as well as in molecular dynamics simulations and in the study of hydrophobicity and protein folding. When computing the solvation energy for molecules, it is crucial to correctly model and sample the molecular surface. The most common model for molecules is a collection of atoms represented by spherical balls, with radii equal to their van der * To whom correspondence should be addressed.</p><p>Waals radii (<ref type="bibr" target="#b16">Duncan and Olson, 1993;</ref><ref type="bibr" target="#b23">Mezey, 1993</ref>). The surface of the union of these spheres is known as the van der Waals surface. Accessibility to the solvent, namely the solvent accessible surface (SAS), can be defined as the locus of the center of a 'probe' sphere as it contacts the molecular surface. Usually, the 'probe' is a water molecule modeled as a sphere with radius 1.4 Å. Another definition for molecular surface is as a set of contact and reentrant patches (<ref type="bibr" target="#b28">Richards, 1977</ref>), commonly known as the solvent contact surface (SCS), or solvent excluded surface (SES) or simply the molecular surface. While a number of techniques have been devised for the static construction of molecular surfaces (see e.g.<ref type="bibr" target="#b11">Bajaj et al., 2009c</ref>for a brief review), not much work has been done on neighborhood data structures for the dynamic maintenance of molecular surfaces under conformational changes and domain movements.<ref type="bibr">Bajaj et al.</ref>considered limited dynamic maintenance of molecular surfaces based on Non Uniform Rational BSplines (NURBS) descriptions for the patches (<ref type="bibr" target="#b8">Bajaj et al., 2003</ref>). Eyal and Halperin presented an algorithm based on dynamic graph connectivity that updates the union of balls molecular surface after a conformational change in O (log 2 n ) amortized time per affected (by this change) atom (<ref type="bibr" target="#b18">Eyal and Halperin, 2005a</ref>, b). In this article, we present the Dynamic Packing Grid (DPG), a space and time efficient neighborhood data structure that maintains a collection of balls (atoms) in 3-space, allowing a range of spherical range queries and updates for rapid scoring of flexible protein–protein interactions (<ref type="bibr" target="#b9">Bajaj et al., 2009a</ref><ref type="bibr" target="#b12">Bajaj et al., , 2010</ref>). The efficiency of the data structure results from the assumption that the centers of two different balls in the collection cannot come arbitrarily close to each other, which is a natural property of molecules. A consequence of this assumption is that any ball in the collection can intersect at most a constant number of other balls. On a RAM with w-bit words, our DPG data structure can report all balls intersecting a given ball or within O (r max ) distance from a given point in O (loglogw ) time with high probability (w.h.p.), where r max is the radius of the largest ball in the collection. It can also answer whether a given ball is exposed (i.e. lies on the union boundary) or buried within the same time bound. At any time, the entire union boundary can be extracted from the data structure in O (m ) time in the worst case, where m is the number of atoms on the boundary. There are existing techniques like<ref type="bibr" target="#b32">Weiser et al. (1998</ref><ref type="bibr" target="#b33">Weiser et al. ( , 1999</ref>), which can compute/approximate the exposed atoms and the surface area in the same time bound, but do not allow dynamic updates. On the other hand, DPG supports updates (i.e. insertion/deletion/movement of a ball) in O (logw ) time w.h.p. 1 The data structure uses linear space.</p><p>As we show here, DPGs can be used to maintain both the van der Waals surface and the SCS of a molecule within the performance bounds mentioned above. DPGs can also be used to enable fast energetics calculation by rapidly locating the atoms close to each sampled integration point of the SCS. Besides protein docking and molecular dynamics, the neighborhood query and surface maintenance of DPG also has potential applications in interactive computer-aided design (CAD) tools developed for de novo drug design, protein folding, n-body simulations, etc. All these applications often need to handle extremely large number of atoms or points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">THE DYNAMIC PACKING GRID DATA STRUCTURE</head><p>Let M = {B 1 ,...,B n } be a collection of n balls in 3-space with c i and r i being the center and radius, respectively, of</p><formula>B i , i ∈[1,n]. Let r max = max i {r i } and let d min = min i,j d(c i ,c j ) , where d(c i ,c j )</formula><p>is the Euclidean distance between c i and c j. We describe the packing grid data structure for maintaining M efficiently under the following set of queries and updates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Queries</head><p>(1) Intersect(c,r): Returns all balls intersecting B = (c,r).</p><p>(2) Range(p,δ): Returns all balls with centers within distance δ of point p. We assume that δ = O(r max ).</p><p>(3) Exposed(c,r): Returns true if the ball B = (c,r) ∈ M contributes to the boundary of the union of the balls in M.</p><p>(4) Surface( ): Returns the outer boundary of the union of the balls in M. If there are multiple disjoint outer boundaries defined by M, the routine returns one of them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Updates</head><p>(1) Add( c, r ): Adds a new ball B = (c,r) to the set M.</p><p>(2) Remove( c, r ): Removes the ball B = (c,r) from M.</p><formula>(3) Move( c 1 , c 2 , r ):</formula><p>Moves the ball with center c 1 and radius r to a new center c 2 .</p><p>We assume that the following holds at all times.In general, a ball in a collection of n balls in 3-space can intersect (n ) other balls in the worst case, and it has been shown by<ref type="bibr" target="#b15">Clarkson et al. (1990)</ref>that the boundary defined by the union of these balls has a worst case combinatorial complexity of (n 2 ). However, if M is a 'union of balls' representation of the atoms in a molecule, then assumption 2.1 holds naturally (<ref type="bibr" target="#b22">Halperin and Overmars, 1994;</ref><ref type="bibr" target="#b31">Varshney et al., 1994</ref>), and as proved by<ref type="bibr" target="#b22">Halperin and Overmars (1994)</ref>, both complexities improve by a factor of n. The following theorem (see<ref type="bibr" target="#b12">Bajaj et al., 2010</ref>for a proof) states the consequences of the assumption.</p><formula>q = O (loglogw ) t q = O (loglogn ) t u = O (logw ) t u = O ( logn loglogn )</formula><p>Range, Intersect,</p><formula>O (loglogw ) O (loglogn )</formula><p>Exposed Add, Remove, Move O (logw )</p><formula>) = O (n ).</formula><p>Therefore, as Theorem 2.1 suggests, one should be able to handle M more efficiently if assumption 2.1 holds. The efficiency of our data structure, listed in<ref type="figure" target="#tab_1">Table 1</ref>, also depends partly on this assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Preliminaries</head><p>Before we describe our data structure, we present some definitions in order to simplify the exposition.is referred to as the (a,b,c,r)-cell or simply as the (a,b,c)-cell when r is clear from the context. The (b,c,r)-line (where b,c ∈ Z) in an r-grid consists of all (x,y,z,r)-cells with y and z fixed to b and c, respectively. The (c,r)-plane (where c ∈ Z) in an r-grid consists of all (x,y,z,r)-cells with z fixed to c.</p><p>The proof of the following lemma is straightforward.At the heart of our data structure is a fully dynamic one dimensional integer range reporting data structure for word RAM described by<ref type="bibr" target="#b25">Mortensen et al. (2005)</ref>. Their data structure maintains a set S of integers under updates (i.e. insertions and deletions), and answers queries of the form Query(l,h), which reports any or all points in S in the interval<ref type="bibr">[l,h]</ref>. The following theorem (proved in<ref type="bibr" target="#b25">Mortensen et al., 2005</ref>) summarizes the performance bounds of the data structure which are of interest to us.(i) t u = O (logw ) and t q = O (loglogw ) using the data structure in<ref type="bibr" target="#b25">Mortensen et al. (2005)</ref>;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Page: 57 55–62</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic packing grid data structure</head><p>and</p><p>(ii) t u = O (logn/loglogn ) and t q = O (loglogn ) using the data structure in (<ref type="bibr" target="#b25">Mortensen et al., 2005</ref>) for small w and a fusion tree (<ref type="bibr" target="#b20">Fredman and Willard, 1993</ref>) for large w.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Description (layout) of the packing grid data Structure</head><p>We are now in a position to present the DPG data structure. DPG represents the entire 3-space as a 2r max-grid, and maintains the non-empty grid-planes, grid-lines and grid-cells. Note that a grid component (i.e. cell, line or plane) is non-empty if it contains the center of at least one ball in M. The data structure can be described as a tree with five levels: 4 internal levels (levels 3, 2, 1 and 0) and an external level of leaves (see<ref type="figure" target="#fig_0">Fig. 1</ref>). The description of each level follows (further details are available in<ref type="bibr" target="#b12">Bajaj et al., 2010</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">The leaf level 'Ball' data structure (DPG −1 )</head><p>The data structure stores the center c = (c x ,c y ,c z ) and the radius r of the given ball B. It also includes a Boolean flag exposed which is set to true if B contributes to the outer boundary of the union of the balls in M, and false otherwise. The 3D arrangement of the spheres B∪N (B), where N (B) is the set of balls intersecting B, divides the boundary of B into spherical patches, some of which are exposed, that is they contribute to the union boundary. We store all exposed patches (if any) of A in a set F of size O (1 ), and with each patch f ∈ F we store pointers to the data structures of O (1 ) other balls that share edges with f and also the identifier of the corresponding patch on each ball.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">The level 0 'Grid-Cell' data structure (DPG 0 )</head><p>The 'gridcell' data structure stores the root (see Definition 2.1) (a,b,c) of the grid-cell it corresponds to. A grid-cell maintains a list of pointers to data structures of the O (1 ) balls whose centers lie inside the cell. Since we create 'grid-cell' data structures only for non-empty grid-cells, there will be at most n (and possibly n) such data structures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">The level 1 'Grid-Line' data structure (DPG 1</head><p>) We create a 'grid-line' data structure for a (b,c)-line provided it contains at least one non-empty grid-cell. Each (a,b,c)-cell lying on this line is identified with the unique integer a, and the identifier of each such non-empty grid-cell is stored in an integer range search data structure RR as described in Section 2.1 (see Theorem 2.2). We augment RR to store the pointer to the corresponding 'grid-cell' data structure with each identifier it stores.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4">The level 2 'Grid-Plane' data structure (DPG 2 )</head><p>A 'gridplane' data structure is created for a c-plane provided it contains at least one non-empty grid-line. Similar to the 'grid-line' data structure, it identifies each non-empty (b,c)-line lying on the c-plane with the unique integer b, and stores the identifiers in a range reporting data structure RR.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.5">The level 3 'Grid' data structure (DPG 3 )</head><p>This data structure maintains the non-empty grid-planes in an integer range reporting data structure RR in a similar way where each c-plane is identified by the unique integer c. The 'grid' data structure also stores a surface-root pointer which points to the 'ball' data structure of an arbitrary exposed ball in M. We have the following lemma (proved in<ref type="bibr" target="#b12">Bajaj et al., 2010</ref>) on the space usage of the data structure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2.2. Let Assumption 2.1 hold. Then the packing grid data structure storing M uses O</head><p>(n ) space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Queries and updates</head><p>The queries and updates supported by the data structure are implemented as follows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.1">Queries</head><formula>(1) Range( p, δ ): Let p = (p x ,p y ,p z )</formula><p>. First we invoke the function Query(l,h) of the range reporting data structure RR under the level 3 grid data structure with l = (p z −δ)/(2r max ) and h = (p z +δ)/(2r max ). This query returns a set S 2 of nonempty c-planes represented as pointers to level 2 grid-plane data structures. Then, for each c-plane, we perform similar queries under the corresponding level 2 data structure to obtain the set S 1 of nonempty grid-lines. Again, querying under each grid-line data structure produces the set S 0 containing non-empty grid-cells. Finally, for each cell in S 0 , we collect and return each ball whose center lies within distance δ from p. The correctness of the function follows trivially since it queries a region in 3-space, which includes the region covered by a ball of radius δ centered at p. Also, assuming</p><formula>r max = O (d min ) (i.e. Assumption 2.1) and δ = O (r max )</formula><p>, the complexity reduces to O (t q ). Details can be found in (<ref type="bibr" target="#b12">Bajaj et al., 2010</ref>).</p><p>(2) Intersect( c, r ): Let B = (c,r) be the given ball. First, we call Range( c, r +r max ) and collect the output in set S. From S we remove the data structure of each ball that does not intersect B, and return the resulting (possibly reduced) set. The correctness follows from basic geometry and the correctness of Range. Under Assumption 2.1, this function runs in O (t q ) time.</p><p>(3) Exposed( c, r ): Let B = (c,r) be the given ball. We locate B's data structure by calling Range(c,0), and return the value stored in its exposed field. Clearly, the function takes O (t q + r max /d min 3 ) time (w.h.p.), which reduces to O (t q ) under Assumption 2.1.Page: 58 55–62</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>C.Bajaj et al.</head><p>(4) Surface( ): The surface-root pointer under the level 3 'grid' data structure points to the 'ball' data structure of a ball B on the union boundary of M. We scan the set F of exposed faces of B, and using the pointers to other exposed balls stored in F we perform a depth-first traversal of all exposed balls in M and return the exposed faces on each such ball. Let m be the number of balls contributing to the union boundary of M. Then according to Theorem 2.1, the depth-first search takes O ( r max /d min 3 ·m ) time in the worst case, which reduces to O (m ) under Assumption 2.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3.2">Updates</head><formula>(1) Add( c, r ): Let c = (c x ,c y ,c z ) and let c u = c u 2r max , where u ∈</formula><p>{x,y,z}. Let G be the grid data structure. If G does not exist, then create and initialize G. Then, first we create and initialize a data structure B and add to M. Then, we query the range reporting data structure G.RR to locate the data structure P for the c z-plane. If P does not exist, create and initialize P, and insert c z along with a pointer to P into G.RR. Similar steps are taken for the grid-line and then the grid-cell data structures to identify the</p><formula>(c x ,c y ,c z )-cell C</formula><p>and add B to C. We then use the Intersect query to identify N (B), the set of balls intersecting B. Finally we update the arrangement of each ball in B∪N (B), list exposed faces on each ball and update the surface-root pointer if necessary. Observe that the introduction of a new ball may affect the surface exposure of only the balls it intersects (by burying some/all of them partly or completely), and no other balls. Hence, updating the arrangements of the balls in B∪N (B) (in addition to those in earlier steps) are sufficient to maintain the correctness of the entire data structure. The Add function terminates in O (t u ) assuming r max = O (d min ). Detailed analysis is in (<ref type="bibr" target="#b12">Bajaj et al., 2010</ref>).</p><p>(2) Remove( c, r ): This function is symmetric to the Add function, and has exactly the same asymptotic time complexity. Hence, we do not describe it here.</p><formula>(3) Move( c 1 , c 2 , r ):</formula><p>This function is implemented in the obvious way by calling Remove( c 1 , r ) followed by Add( c 2 , r ). It has the same asymptotic complexity as the two functions above. Therefore, we have the following theorem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Molecular surface maintenance using DPG</head><p>In this section, we briefly describe applications of the packing grid data structure for efficient maintenance of molecular surfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.1">Maintaining van der Waals surface of molecules</head><p>Each atom is simply treated as a ball with a radius equal to the van der Waals radius of the atom see (<ref type="bibr" target="#b13">Batsanov, 2001</ref>) for a list of van der Waals radius of different atoms).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4.2">Maintaining Lee-Richards (SCS/SES) surface</head><p>For the efficient maintenance of the Lee-Richards surface of a molecule within the performance bounds given in<ref type="figure" target="#tab_1">Table 1</ref>, we maintain two packing grid data structures: DPG and DPG. The DPG data structure keeps track of the patches on the Lee-Richards surface, and DPG is used for detecting intersections among concave patches. Before adding an atom to DPG, we increase its radius by r s , where r s is the radius of the rolling solvent atom. The DPG data structure keeps track of all solvent exposed atoms, i.e. all atoms that contribute to the outer boundary of the union of these enlarged atoms. Theorem 2.1 implies that each atom in DPG contributes O (1 ) patches to the Lee-Richards surface, and the insertion/deletion/movement of an atom results in local changes of only O (1 ) patches. We can modify DPG to always keep track of where two or three of the solvent exposed atoms intersect, and once we know the atoms contributing to a patch we can easily compute the patch in O (1 ) time (<ref type="bibr" target="#b8">Bajaj et al., 2003</ref>). The Lee-Richards surface can self-intersect in two ways: (i) a toroidal patch can intersect itself and (ii) two different concave patches may intersect (<ref type="bibr" target="#b8">Bajaj et al., 2003</ref>). The self-intersections of toroidal patches can be easily detected from DPG. In order to detect the intersections among concave patches, we maintain the centers of all current concave patches in DPG , and use the Intersect query to find the concave patch (if any) that intersects a given concave patch.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Energetics computation using DPG</head><p>Generally, the solvation energy G sol of a molecule is decomposed into three components, namely, G cav (the energy to form cavity in the solvent), G vdw (the solute-solvent van der Waals interaction energy), and G pol (the polarization energy or the electrostatic potential energy change due to the solvation). The first two terms G cav and G vdw are linearly related to the solvent accessible surface area SAS. The last term, G pol , can be approximated using the Generalized Born (GB) theory as introduced by<ref type="bibr" target="#b29">Still et al. (1990)</ref>.</p><formula>G pol =− τ 2 i,j q i q j r 2 ij +R i R j e −r 2 ij /4R i R j ,</formula><formula>(2.1)</formula><p>where τ = 1− 1 , and R i is the effective Born radius of atom i (see<ref type="figure" target="#fig_2">Fig. 2a</ref>). Either of Equations 2.2 or 2.3 can be used as discrete approximation of R −1 i (<ref type="bibr" target="#b7">Bajaj and Zhao, 2010</ref>).</p><formula>R −1 i = 1 4π N k=1 w k (r k −x i )·n(r k ) |r k −x i | 4 ,</formula><formula>(2.2) R −3 i = 1 4π N k=1 w k (r k −x i )·n(r k ) |r k −x i | 6 ,</formula><formula>(2.3)</formula><p>where the r k 's are N carefully chosen integration points on the boundary of the molecule, and w k is a weight assigned to r k to ensure higher order of accuracy for small N (see<ref type="figure" target="#fig_2">Fig. 2b</ref>). Other methods have used volume integrals (<ref type="bibr" target="#b30">Tjong and Zhou, 2007</ref>) or</p><p>Page: 59 55–62integrals over bonded and non-bonded atom pairs (<ref type="bibr" target="#b26">Qiu et al., 1997</ref>) to approximate Born Radii. The non-polar terms G cav and G vdw can be computed directly from the SAS area SAS of the molecule. The SAS of the molecule can be extracted in O ( mlogw ) time and O ( m ) space using a DPG data structure, where m is the number of atoms in the molecule. The DPG data structure outputs the SAS as a set of spherical and toroidal patches, and we add up the area of each patch in order to calculate SAS .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic packing grid data structure</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5.1">Discrete approximation of Born Radii</head><p>In order to approximate the polar term G pol , first we need to approximate the Born radius R i of each atom i. We compute the SES as Aspline patches, produce a quality improved meshing of the surface and sample integration points and their weights following (<ref type="bibr" target="#b7">Bajaj and Zhao, 2010</ref>) (see<ref type="figure" target="#fig_3">Figure 3</ref>) and then use Equation (2.2) to approximate R i. But observe that the direct computation of R i requires O(n 2 ) time, where n is the number of atoms and assuming that the number of sampled integration points is also O(n). However, since the terms in the summation diminish very fast with the increase of distance, distance cutoffs can be used to approximate it. Given the set of atoms A, the set of integration points Q sampled on the surface, and two user-defined parameters α,δ &gt; 0, for every integration point q ∈ Q, we place each atom a ∈ A in one of the following three categories based on the distance d between q and the center of a:<ref type="figure" target="#fig_4">Figure 4</ref>shows an example in 2D. For the near categories, the computation is performed exactly. For the midway category, clusters of atoms and integration points are viewed as pseudo-atoms and pseudo-integration points, and hence a coarse computation is performed. For the far category, a single average distance and a single average weighted normal is used for all pairs of clusters. Separate DPG data structures are used to store the atoms, integration points, pseudo-atoms and pseudo-integration points. DPG is used both for identifying the near, midway and faratoms/pseudoatoms as well as for clustering (see<ref type="bibr" target="#b12">Bajaj et al., 2010</ref>for details). Assuming that m δ is an upper bound on the number of atoms within distance δ from any given point in space, the time spent for computing all R i 's is O (N loglogw+N m δ ), which reduces to O (N loglogw ) since m δ is a constant (though could be quite large) for constant δ. Once all R i 's are computed, G pol can be computed using Equation (2.1) in O ( m 2 ) time in the worst case. The space usage is O ( m+N m δ ) which is O ( m+N ) for constant δ.</p><formula>(i) near (d ≤ δ), (ii) mid-way (δ&lt;d ≤ αδ) and (iii) far (αδ &lt; d).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Maintenance of flexible molecules</head><p>Suppose we are given a flexible molecule decomposed into several (mostly) rigid domains which interact either through connected chain segments or large interfaces. We refer to these chain segments and interfaces as connectors. Domains may move with respect to each other through motions applied to the connectors. Two domains connected by at least one connector may undergo bending motion applied to some hinge point around some hinge axis. If they are connected by only one connector, a twisting motion can also be applied to the connector by updating torsion angles along its backbone. If two domains share a large interface area, they may undergo a shearing motion with respect to each other. However, though domains are mostly rigid they may have flexible loops and side chains on their surfaces. We maintain a separate packing grid data structure P i for each domain D i. If two domains D i and D j are connected and i &lt; j, the set S ij of all connectors between these two domains are included in P i , and a transformation matrix M ij is kept with P i that describes the exact location and orientation of the grid structure of P j with respect to that of P i. Whenever some motion is applied to the connectors in S ij , we update P i in order to reflect the changes in the locations of the atoms in these connectors, and also update M ij in order to reflect the new relative position and orientation of P j with respect to P i. The complexities of these operations are presented in the following lemma proved in (<ref type="bibr" target="#b12">Bajaj et al., 2010</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS AND DISCUSSIONS</head><p>The performance of the basic functions of DPG are reported in Section 3.2. Sections 3.3 and 3.4, respectively, analyzes performance of DPG in molecular surface maintenance and energetics calculation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Implementation details</head><p>In our current implementation, instead of the 1D integer rangereporting data structure presented in (<ref type="bibr" target="#b25">Mortensen et al., 2005</ref>), we have implemented a much simpler data structure that supports both updates and distance queries in expected O (logw ) time and uses linear space. Since w is usually not more than 64, for most practical purposes a O (logw ) query time should be almost as good as O (loglogw ) time. This data structure builds on binary search trees, dynamic perfect hashing and y-fast trees. However, instead of dynamic perfect hashing we used 'cuckoo hashing' (<ref type="bibr" target="#b27">Rasmus and Flemming, 2004</ref>) since it is much simpler, and still supports lookups in O (1 ) worst case time, and updates in expected O (1 ) time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Performance analysis of updates and queries</head><p>To measures the performance of the update and query functions of DPG, we use more than 180k quadrature points, generated for energetics computations by sampling uniformly at random on the surface of PSTI (a variant of human pancreatic trypsin inhibitor: 1HPT.pdb) after protonation using PDB2PQR (<ref type="bibr" target="#b17">Dolinsky et al., 2004</ref>). Experiments are performed on a 3 GHz 2× dual core (only one core was used) AMD Opteron 2222 processor with 4 GB RAM. Please refer to (<ref type="bibr" target="#b12">Bajaj et al., 2010</ref>) for details of the experiment.<ref type="figure" target="#tab_2">Table 2</ref>shows the results of this experiment. The time required is O (logw+K ) where K is the size of the output or in this case, the number of points returned. The last column of the table shows that as the point set becomes denser, the efficiency of the data structure remains almost the same.<ref type="figure" target="#tab_3">Table 3</ref>reports the performance of update functions of DPG's range reporting data structure. Four different macromolecules were used, and for each of them all atoms were first randomly insertedinto the data structure followed by the random deletion of all atoms. The reported insertion and deletion times are averages of four such independent runs. The average time for a single insertion/deletion was never more than 5 µs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Performance of molecular surface maintenance</head><p>We compared the performance of DPG with the 3D hashing used by (<ref type="bibr" target="#b18">Eyal and Halperin, 2005a</ref>, b) in producing and maintaining molecular surfaces. We used the same implementation of 3D arrangement and surface generation (<ref type="bibr" target="#b19">Eyal and Halperin, 2005b</ref>), but switched between the two different range query data structures. We measured the space and time requirements for generating the surface of various macromolecules. To verify scalability, multiple chains of the same protein were inserted. For virus capsids, as multiple chains are inserted, not only the number of atoms increases but also the overall structure becomes sparser. The results of this experiment are reported in<ref type="figure" target="#tab_4">Table 4</ref>. It is clear that the space requirement of the DPG is linear in the number of atoms. The difference in space requirement becomes more pronounced for larger and sparser structures. Also, its running times are comparable with that of 3D hash. Though 3D hash performs insertions and queries in optimal constant time, using too much memory can adversely affect its running time. For example, in the case of RDV P3 with four chains, 3D hash operations run slower than DPG range reporting operations. We believe that this slowdown is due to page faults caused by excessive space requirement of 3D hash.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Performance of Born Radii and polarization energy calculation</head><p>A parallel implementation of the approximation scheme described in Section 2.5.1 was applied to compute the Born Radii, which were used to compute the polarization energy G Pol. The experiments were performed on the RANGER cluster, on a single node with 16 cores. First, three different approximations were performed by varying the δ parameter for the molecules in ZDock Benchmark 2.0 (<ref type="bibr" target="#b24">Mintseris et al., 2005</ref>). We shall refer to these as DPG_GB_g_x, where δ = xD,x ∈ 0.5,0.75,1.0 and D is the dimension of a cell in DPG, and it means that a g×g×g grid was used to generate the surface and integration points on the surface. Both D and α are automatically selected based on the size of the molecules. For each atom i of a molecule, the approximation error is defined as</p><formula>ε i = |(R exact i −R dpg i )| * 100 R exact i , where R dpg i and R exact i</formula><p>are the Born Radii of atom i approximated using DPG-based scheme and by exact (full pairwise) evaluation of Equation (2.2), respectively. The approximation errorfor a molecule is the average of the ε i 's.<ref type="figure" target="#fig_5">Figure 5a</ref>reports the approximation errors for each molecule. It is clear that a larger 'near' band results in lower error. On the other hand,<ref type="figure" target="#fig_5">Figure 5b</ref>shows the speedup for each approximation, where speedup is defined as (time taken by exact computation)/(time taken by DPG-based computation). Though there is a clear speed/accuracy trade-off, it only underscores the efficacy and flexibility of the scheme. For example, DPG_GB_128_1.0 is almost 50 times faster than the naive pairwise computation with only 2.41% error. In<ref type="figure" target="#fig_6">Figure 6</ref>, we report the error of G pol computation where, for each molecule, the error is defined as |(G exact −G dpg )| * 100</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>G exact</head><p>, where G exact and G dpg are, respectively, the G pol computed using R exact i</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and R dpg i</head><p>for each atom i of the molecule. G pol errors are much lower than the Born Radii errors because the integral of the G pol formulation also falls off with distance and hence accuracy of G pol is more dependent on the accuracy of the Born radii of atoms near the surface. In<ref type="figure" target="#tab_5">Table 5</ref>, the Born Radii of all atoms of all molecules are grouped into five bins based on R exact i</p><p>. It is easy to verify that Born Radii computation errors for the atoms near the surface (having lower values of Born Radii) are indeed much lower. Another notable aspect from the results in<ref type="figure" target="#fig_6">Figure 6</ref>is that some of the molecules, specially 1PPE_l_b, the G pol error is considerably higher. We found that this tend to happen for molecules which are very small (for example, 1PPE_l_b has only 436 atoms) or very flat, in other words does not have much in the 'far' band. Our scheme for computing partial sums for 'far' bands seem to overestimate in such cases. We also computed the Born Radii and G pol for the same set of molecules using Amber (<ref type="bibr" target="#b14">Case et al., 2005</ref>) and GBr 6 (<ref type="bibr" target="#b30">Tjong and Zhou, 2007</ref>) on the same computing cluster using the same number of nodes and cores. The results in<ref type="figure">Figure 7a</ref>show that DPG-based implementations, are much faster than GBr 6 and are comparable to Amber. In<ref type="figure">Figure 7b</ref>, we report the ratio of the Born Radiicomputation time of DPG and Amber, sorted in increasing size of molecules. It is clear that DPG gets better as the size increases and outperforms Amber in a few cases. So, we experimented with Amber, GBr 6 and DPG for a very large molecule, the Cucumber Mosaic Virus (CMV) capsid, consisting 509K atoms. DPG completed in only 22 s, while Amber needed 172 s and GBr 6 needed about 3.6 h. As G pol obtained using different formulations often vary a lot, we decided to compare the consistency instead of the exact values.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.1.</head><figDesc>Fig. 1. Hierarchical structure of DPG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>[11:</head><figDesc>31 2/12/2010 Bioinformatics-btq627.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.2.</head><figDesc>Fig. 2. (a) G pol is computed based on Born Radii and charges of each atom pair, (b) Born Radii of an atom can be approximated based on integration points, shown as red dots, sampled on the surface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.3.</head><figDesc>Fig. 3. Gaussian integration points (c) on the surface of nuclear transport factor 2 (1A2K) computed after generating a smooth surface (b) from the collection of balls model (a).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig.4.</head><figDesc>Fig. 4. (a) A simple 2D example depicting definition of near, medium and far atoms (centers shown as green dots) from a particular integration point x i. In the example, two atoms are near, seven are medium and three are far. (b) After clustering using hierarchical DPG, each cell contains a pseudoatom (centers shown as blue circles). Now two atoms are near, three clusters are medium and two clusters are far.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.5.</head><figDesc>Fig. 5. (a) Comparison of the approximation errors for Born Radii computation at various levels of approximation. Average percentage error across all molecules for the schemes are 11.42,4.44,2.16,4.84 and 4.41 (in the order shown in legend). (b) Comparison of the speedup (with respect to the exact implementation) for Born Radii computation at various levels of approximation. Average speedup across all molecules for the schemes are 47.96,37.71,30.63,59.97 and 47.51 (in the order shown in legend). Figures appear in color in the online version of the paper.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.6.</head><figDesc>Fig. 6. Approximation errors for G pol computation. The average G pol error across all molecules are 0.09 and 0.1, respectively for DPG_GB_256_1.0 and DPG_GB_128_1.0. Note that G pol errors are much lower than Born Radii errors.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>Assumption 2.1. If d min is the minimum Euclidean distance between the centers of any two balls in M, then r max = O (d min ).</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>Theorem 2.1 [Theorem 2.1 in (Halperin and Overmars, 1994), slightly modified]. Each ball in M intersects at most 216· r max /d min 3 = O (1 ) other balls in M and the combinatorial</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Table 1.</figDesc><table>Time complexities of the operations supported by the packing grid 
data structure 

Operations 
Time Complexity (w.h.p.) 

Assuming 
Assuming 
t </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>O ( logn loglogn ) Surface O (#balls on surface ) (worst case) Assumptions: (i) RAM with w-bit Words, (ii) Collection of n balls, (iii) δ = O (r max ) and, (iv) r max = O (minimum distance between two balls ) complexity of the boundary of the union of the balls is O ( r max /d min 3 ·n</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Definition 2.1 [r-grid, grid-cell, grid-line and grid-plane]. An rgrid is an axis-parallel infinite grid structure in 3-space consisting of cells of size r ×r ×r (r ∈ R) with the root (i.e. the corner with the smallest x, y, z coordinates) of one of the cells coinciding with the origin of the Cartesian coordinate axes. The grid cell that has its root at Cartesian coordinates (ar,br,cr) (where a,b,c ∈ Z)</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>Lemma 2.1. If M is stored in the 2r max-grid G and if Assumption 2.1 holds, then (i) Each grid-cell in G contains the centers of at most O (1 ) balls. (ii) Each ball in M intersects at most eight grid-cells in G. (iii) For a given ball B ∈</figDesc><table>M with center in grid-cell C, the center 
of each ball intersecting B lies either in C or in one of the 26 
grid-cells adjacent to C. 
(iv) The number of non-empty grid-cells in G is at most n, and the 
same bound holds for grid-lines and grid-planes. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>(t u ) and O (t q +k</figDesc><table>Theorem 2.2. On a RAM with w-bit words, the fully dynamic one 
dimensional integer range reporting problem can be solved in linear 
space, and w.h.p. bounds of O ) on update time 
and query time, respectively, where k is the number of items reported, 
and 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><figDesc>(i) uses O (n ) space; (ii) supports updates (i.e. insertion/deletion/movement of a ball) in O (t u ) time w.h.p.; (iii) reports all balls intersecting a given ball or within O (r max ) distance from a given point in O (t q )</figDesc><table>Theorem 2.3. Let M be a collection of n balls in 3-space as defined 
in Theorem 2.1, and let Assumption 2.1 hold. Let t q and t u be as 
defined in Theorem 2.2. Then the packing grid data structure storing 
M on a word RAM: 

time w.h.p., where r max 
is the radius of the largest ball in M; and 
(iv) reports whether a given ball is exposed or buried in O (t q ) 
time w.h.p., and returns the entire outer union boundary of M 
in O (m ) worst-case time, where m is the number of balls on 
the boundary. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9" validated="true"><figDesc>Table 2. Performance of the Query function of packing grid</figDesc><table>Quadr. 
Query 
Average Time 
Average number of 
Points 
Distance (Å) 
(ms)/Query 
Points Returned (k/ms) 

45654 
2 | 4 | 8 
0 .31 | 0.57 | 1.42 
0.38 | 1.37 | 3.14 
91309 
2 | 4 | 8 
0 .59 | 1.14 | 2.80 
0.38 | 1.43 | 3.31 
136963 
2 | 4 | 8 
0 .97 | 1.85 | 4.44 
0.34 | 1.32 | 3.27 
182618 
2 | 4 | 8 
1 .30 | 3,22 | 5.86 
0.38 | 1.31 | 3.30 

We randomly assign each of the 182 618 points to one of four groups and thus obtain 
four approximately equal-sized groups. We then run queries from the atom centers (100 
queries per atom) on group 1, merge groups 1 and 2 and run queries on this merged 
group, and so on. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="true"><figDesc>Table 3. Insertion and deletion times of our current packing grid implementation</figDesc><table>Molecule 
Number 
Average Insert 
Average Delete 
(PDB File) 
of Atoms 
Time (µs) 
Time (µs) 

GroEL (1GRL) 
29 274 
3.3 
4.0 
RDV P8 (1UF2: P) 
193 620 
3.9 
4.4 
RDV P3 (1UF2: A) 
459 180 
3.9 
4.6 
Dengue (1K4R) 
545 040 
4.0 
4.5 

The results are averages of four runs. In each run, all atom centers are randomly inserted 
into the data structure followed by random deletion of all atom centers. </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_11" validated="false"><figDesc>Table 4.</figDesc><table>Comparison of the performance of the 3D range reporting data 
structure used by DPG and the 3D hash table used in (Eyal and Halperin, 
2005b). 

Molecule (PDB 
File) 

Number of 
Chains 

Number of 
Atoms 

Number of Cells (k)Time (s) 

DPG 3D hash 
DPG 
3D hash 

1I3Q 
1 
11 114 
4.68 
45.18 
17.36 
16.23 

2GLS 
1 
3636 
1.44 
9.18 
5.43 
5.06 
5 
18 180 
7.28 
41.40 
37.10 
34.80 

2BG9 
1 
2991 
1.20 
10.75 
4.44 
4.29 
5 
14 955 
6.03 
31.20 
24.31 
22.95 

1UF2: 
Chain P 
(RDV P8) 

1 
3227 
1.35 
9.26 
4.47 
4.23 
2 
6454 
2.74 1124.04 
9.23 
8.56 
4 
12 908 
5.47 4426.11 
19.36 
18.14 
8 
25 816 
10.98 6332.16 
45.22 
44.44 

1UF2: 
Chain A 
(RDV P3) 

1 
7653 
3.23 
38.76 
10.99 
10.23 
2 
15 306 
6.46 
927.44 
22.73 
21.44 
3 
22 959 
9.74 1992.75 
40.48 
39.62 
4 
30 612 
12.99 2591.70 
119.28 128.37 

1K4R: 
Chains A and B 

2 
6056 
2.62 
20.70 
8.46 
7.71 
4 
12 112 
5.24 
138.60 
17.56 
16.52 
6 
18 168 
7.85 
333.06 
33.73 
32.62 

</table></figure>

			<note place="foot" n="1"> For an input of size n, an event E occurs w.h.p. (with high probability) if, for any α ≥ 1 and c independent of n, Pr(E) ≤ 1− c n α. © The Author 2010. Published by Oxford University Press. All rights reserved. For Permissions, please email: journals.permissions@oup.com</note>

			<note place="foot">at :: on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">1112</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>btq627. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName>
				<surname>Page</surname>
			</persName>
		</author>
		<imprint>
			<biblScope unit="page" from="55" to="62" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Bajaj</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<monogr>
		<title level="m" type="main">Table 5. Distribution of errors for different ranges of Born Radii. Clearly, error is lower for atoms near the surface (smaller Born Radii)</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">Range of Number of atoms Average % error Born Radii in range [0, 2] 17 580 0</title>
		<imprint>
			<biblScope unit="page" from="765" to="775" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<monogr>
		<title level="m" type="main">Comparison of Born Radii computation speeds of Amber, GBr 6 and DPG. DPG is almost as fast as Amber, which is the fastest. And GBr 6 is the slowest (some higher values are cropped) (b) Ratio of Born radii computation times of DPG and Amber, sorted by increasing size of molecules. DPG_GB_128_0.75 is the fastest, and DPG_GB_256_1.0 is the slowest as expected. But the ratio of all five schemes improve as the size of the molecules increase</title>
		<author>
			<persName>
				<surname>Fig</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
	<note>c. ) Scatter plot correlating the polarization energies computed using DPG and GBr6 with Amber</note>
</biblStruct>

<biblStruct   xml:id="b6">
	<monogr>
		<title level="m" type="main">Figure 7c displays that DPG consistently produces G pol values similar to Amber&apos;s. In fact, the average deviation of G pol computed by DPG-based scheme from Amber&apos;s is less than 5%</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">in part); a grant from the UT-Portugal CoLab project. Conflict of Interest: none declared Fast molecular solvation energetics and force computation</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Bajaj</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Zhao</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">REFERENCES SIAM J. Sci. Comput</title>
		<editor>NIH contracts (R01-EB00487, R01-GM074258, R01GM073087</editor>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="4524" to="4552" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Dynamic maintenance and visualization of molecular surfaces</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Bajaj</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dis. Appl. Math</title>
		<imprint>
			<biblScope unit="volume">127</biblScope>
			<biblScope unit="page" from="23" to="51" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">A dynamic data structure for flexible molecular maintenance and informatics</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Bajaj</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SPM &apos;09: 2009 SIAM/ACM Joint Conference on Geometric and Physical Modeling</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="259" to="270" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">F2Dock: fast fourier protein-protein docking</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Bajaj</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Transactions on Computational Biology and Bioinformatics [Epub ahead of print</title>
		<imprint>
			<biblScope unit="volume">57</biblScope>
			<biblScope unit="page" from="10" to="1109" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">A fast variational method for the construction of resolution adaptive c 2smooth molecular surfaces</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Bajaj</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Methods Appl. Mech. Eng</title>
		<imprint>
			<biblScope unit="volume">198</biblScope>
			<biblScope unit="page" from="1684" to="1690" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<monogr>
		<title level="m" type="main">A dynamic data structure for flexible molecular maintenance and informatics</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Bajaj</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<pubPlace>Austin, TX, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Van der Waals radii of elements</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">S</forename>
				<surname>Batsanov</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Inorg. Mater</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="871" to="885" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">The Amber biomolecular simulation programs</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">A</forename>
				<surname>Case</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Chem</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="1668" to="1688" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Combinatorial complexity bounds for arrangements of curves and spheres</title>
		<author>
			<persName>
				<forename type="first">K</forename>
				<forename type="middle">L</forename>
				<surname>Clarkson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Dis. Comput. Geom</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="99" to="160" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Approximation and characterization of molecular surfaces</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Duncan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Olson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Biopolymers</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="219" to="229" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">Pdb2pqr: an automated pipeline for the setup, execution, and analysis of poisson-boltzmann electrostatics calculations</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">J</forename>
				<surname>Dolinsky</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="665" to="667" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Dynamic maintenance of molecular surfaces under conformational changes</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Eyal</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Halperin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCG &apos;05: Proceedings of the 21st Annual Symposium on Computational Geometry</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="45" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Improved maintenance of molecular surfaces using dynamic graph connectivity</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Eyal</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Halperin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="401" to="413" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Surpassing the information theoretic bound with fusion trees</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">L</forename>
				<surname>Fredman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">E</forename>
				<surname>Willard</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Syst. Sci</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="page" from="424" to="436" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Calculation of protein-ligand binding affinities</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">K</forename>
				<surname>Gilson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">X</forename>
				<surname>Zhou</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Biophys. Biomol. Struct</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="21" to="42" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Spheres, molecules, and hidden surface removal</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Halperin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">H</forename>
				<surname>Overmars</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SCG &apos;94: Proceedings of the 10th Annual Symposium on Computational Geometry</title>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="113" to="122" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<monogr>
		<title level="m" type="main">Shape in Chemistry; An Introduction to Molecular Shape and Topology</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">G</forename>
				<surname>Mezey</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>VCH Publishers</publisher>
			<pubPlace>New York, USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">Protein-protein docking benchmark 2.0: an update</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Mintseris</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proteins</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="214" to="216" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">On dynamic range reporting in one dimension</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">W</forename>
				<surname>Mortensen</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">STOC &apos;05: Proceedings of the 37th Annual ACM Symposium on Theory of Computing</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="104" to="111" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">The GB/SA continuum model for solvation. a fast analytical method for the calculation of approximate Born radii</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Qiu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Phys. Chem. A</title>
		<imprint>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="page" from="3005" to="3014" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Cuckoo hashing</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Rasmus</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Flemming</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Algorithms</title>
		<imprint>
			<biblScope unit="volume">51</biblScope>
			<biblScope unit="page" from="122" to="144" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">Areas, volumes, packing, and protein structure</title>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Richards</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Biophys. Bioeng</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="151" to="176" />
			<date type="published" when="1977" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Semianalytical treatment of solvation for molecular mechanics and dynamics</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Still</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Am. Chem. Soc</title>
		<imprint>
			<biblScope unit="volume">112</biblScope>
			<biblScope unit="page" from="6127" to="6129" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">GBr6: a parameterization-free, accurate, analytical generalized born method</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Tjong</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">X</forename>
				<surname>Zhou</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Phys. Chem. B</title>
		<imprint>
			<biblScope unit="volume">111</biblScope>
			<biblScope unit="page" from="3055" to="3061" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">Computing smooth molecular surfaces</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Varshney</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Comput. Graph. Appl</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="19" to="25" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b32">
	<analytic>
		<title level="a" type="main">Neighbor-list reduction: optimization for computation of molecular van der Waals and solvent-accessible surface areas</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Weiser</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Chem</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="797" to="808" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b33">
	<analytic>
		<title level="a" type="main">Fast, approximate algorithm for detection of solvent-inaccessible atoms</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Weiser</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Chem</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="588" to="596" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>