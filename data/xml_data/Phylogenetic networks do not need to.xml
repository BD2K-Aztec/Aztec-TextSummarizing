
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:58+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Phylogenetic networks do not need to be complex: using fewer reticulations to represent conflicting clusters</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010">2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Leo</forename>
								<surname>Van Iersel</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Mathematics and Statistics</orgName>
								<orgName type="institution">University of Canterbury</orgName>
								<address>
									<addrLine>Private Bag 4800</addrLine>
									<settlement>Christchurch</settlement>
									<region>New Zealand</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Steven</forename>
								<surname>Kelk</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Centrum voor Wiskunde en Informatica (CWI)</orgName>
								<address>
									<addrLine>Life Sciences</addrLine>
									<postBox>P.O. Box 94079</postBox>
									<postCode>1090 GB</postCode>
									<settlement>Amsterdam</settlement>
									<country key="NL">The Netherlands</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Regula</forename>
								<surname>Rupp</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Center for Bioinformatics ZBIT</orgName>
								<orgName type="institution">Tübingen University</orgName>
								<address>
									<addrLine>Sand 14</addrLine>
									<postCode>72076</postCode>
									<settlement>Tübingen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Daniel</forename>
								<surname>Huson</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">Center for Bioinformatics ZBIT</orgName>
								<orgName type="institution">Tübingen University</orgName>
								<address>
									<addrLine>Sand 14</addrLine>
									<postCode>72076</postCode>
									<settlement>Tübingen</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Phylogenetic networks do not need to be complex: using fewer reticulations to represent conflicting clusters</title>
					</analytic>
					<monogr>
						<imprint>
							<biblScope unit="volume">26</biblScope>
							<biblScope unit="page" from="124" to="131"/>
							<date type="published" when="2010">2010</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btq202</idno>
					<note>[09:34 17/5/2010 Bioinformatics-btq202.tex] Page: i124 i124–i131 BIOINFORMATICS Contact: Supplementary information: Supplementary data are available at Bioinformatics online.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Phylogenetic trees are widely used to display estimates of how groups of species are evolved. Each phylogenetic tree can be seen as a collection of clusters, subgroups of the species that evolved from a common ancestor. When phylogenetic trees are obtained for several datasets (e.g. for different genes), then their clusters are often contradicting. Consequently, the set of all clusters of such a dataset cannot be combined into a single phylogenetic tree. Phylogenetic networks are a generalization of phylogenetic trees that can be used to display more complex evolutionary histories, including reticulate events, such as hybridizations, recombinations and horizontal gene transfers. Here, we present the new CASS algorithm that can combine any set of clusters into a phylogenetic network. We show that the networks constructed by CASS are usually simpler than networks constructed by other available methods. Moreover, we show that CASS is guaranteed to produce a network with at most two reticulations per biconnected component, whenever such a network exists. We have implemented CASS and integrated it into the freely available Dendroscope software.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Phylogenetics studies the reconstruction of evolutionary histories from genetic data of currently living organisms. A (rooted) phylogenetic tree is a representation of such an evolutionary history in which species evolve by mutation and speciation. The leaves of the tree represent the species under consideration and the root of the tree represents their most recent common ancestor. Each internal node represents a speciation: 1 species splits into several new species. Thus, mathematically speaking, such a node has indegree 1 and outdegree at least 2. In recent years, a lot of work has been done on developing methods for computing (rooted) phylogenetic networks (<ref type="bibr" target="#b4">Gambette, 2009;</ref><ref type="bibr" target="#b7">Gusfield et al., 2007b</ref>; D.H.<ref type="bibr">Huson et al., submitted for publication;</ref><ref type="bibr" target="#b16">Nakleh, 2009;</ref><ref type="bibr" target="#b18">Semple, 2007</ref>), which form a generalization of phylogenetic trees. Next to nodes representing speciation, rooted phylogenetic networks can also contain reticulations: nodes with indegree at least 2. Such nodes can be used to represent the recombinations, hybridizations or horizontal gene transfers, depending on the biological context. In addition, phylogenetic networks can also be interpreted in a more abstract sense, as a visualization of contradictory phylogenetic information in a single diagram. * To whom correspondence should be addressed. Suppose we wish to investigate the evolution of a set X of taxa (e.g. species or strains). Each edge of a rooted phylogenetic tree represents a cluster: a proper subset of the taxon set X. In more detail, an edge (u,v) represents the cluster containing those taxa that are descendants of v. Each phylogenetic tree T is uniquely defined by the set of clusters represented by T. Phylogenetic networks also represent clusters. Each of their edges represents one 'hardwired' and at least one 'softwired' cluster. An edge (u,v) of a phylogenetic network represents a cluster C ⊂ X in the hardwired sense if C equals the set of taxa that are descendants of v. Furthermore, (u,v) represents C in the softwired sense if C equals the set of all taxa that can be reached from v when, for each reticulation r, exactly one incoming edge of r is 'switched on' and the other incoming edges of r are 'switched off'. An equivalent definition states that a phylogenetic network N represents a cluster C in the softwired sense if there exists a tree T that is displayed by N (formally defined below) and represents C. In this article, we will always use 'represent' in the softwired sense. It is usually the clusters in a tree that are of more interest, and less the actual trees themselves, as clusters represent putative monophyletic groups of related species. For a complete introduction to clusters see D.H.<ref type="bibr">Huson et al. (</ref>submitted for publication). In phylogenetic analysis, it is common to compute phylogenetic trees for more than one dataset. For example, a phylogenetic tree can be constructed for each gene separately, or several phylogenetic trees can be constructed using different methods. To accurately reconstruct the evolutionary history of all considered taxa, one would preferably like to use the set C of all clusters represented by at least one of the constructed phylogenetic trees. In general, however, some of the clusters of the different trees will be incompatible, which means that there will be no single phylogenetic tree representing C. Therefore, several recent publications have studied the construction of a phylogenetic network representing C.<ref type="bibr" target="#b9">Huson and Rupp (2008)</ref>describe how a phylogenetic network can be constructed that represents C in the hardwired sense (a cluster network). A network is a galled network if it contains no path between two reticulations that is contained in a single biconnected component (a maximal subgraph that cannot be disconnected by removing a single node, see<ref type="figure">Fig. 1</ref>). Huson and Klöpper (2007) and<ref type="bibr" target="#b11">Huson et al. (2009)</ref>describe an algorithm for constructing a galled network representing C in the softwired sense. Related literature describes the construction of phylogenetic networks from phylogenetic trees or triplets (phylogenetic trees on three taxa). A tree or triplet T is displayed by a network N if there is a subgraph T of N that is a subdivision of T (i.e. T can be obtained from T by replacing edges by directed paths). Computing the minimum number of reticulation required in ashowed that it is fixed parameter tractable (FPT), if parameterized by the minimum number of reticulations. The downside of these algorithms is that they are very rigid in the sense that one generally needs very complex networks in order to display the given trees. The level of a binary network is the maximum number of reticulations in a biconnected component, 1 and thus provides a measure of network complexity. Given an arbitrary number of trees on the same set of taxa,<ref type="bibr" target="#b12">Huynh et al. (2005)</ref>describe a polynomialtime algorithm that constructs a level-1 phylogenetic network that displays all trees and has a minimum number of reticulations, if such a network exists (which is unlikely in practice). Given a triplet for each combination of three taxa, Jansson and coworkers (<ref type="bibr" target="#b13">Jansson and Sung, 2006;</ref><ref type="bibr" target="#b13">Jansson et al., 2006</ref>) and give a polynomial-time algorithm that constructs a level-1 network displaying all triplets, if such a network exists. The algorithm by van Iersel and Kelk (2009) can be used to find such a network that also minimizes the number of reticulations. These results have later been extended to level-2 (van<ref type="bibr" target="#b20">Iersel and Kelk, 2009;</ref><ref type="bibr" target="#b21">van Iersel et al., 2009a</ref>) and more recently to level-k, for all k ∈ N (<ref type="bibr" target="#b19">To and Habib, 2009</ref>). Although this work on triplets is theoretically interesting, it has the practical drawback that biologists do not work with triplets (but rather with trees or clusters) and that it is rather difficult to intuitively convey what it means for a triplet to be 'in' a network. An additional drawback is that these triplet algorithms need at least one triplet in the input for each combination of three taxa, while some triplets might be difficult to derive correctly. If, for example, one induces triplets from a set of trees, then this is likely not to give you a triplet for each combination of three taxa, if one or more input trees are not fully resolved or if some input trees do not have exactly the same set of taxa. In this article, we present the algorithm Cass, 2 which takes any set C of clusters as input and constructs a phylogenetic network that represents C (in the softwired sense). Furthermore, the algorithm aims at minimizing the level of the constructed network and in this sense Cass is the first algorithm to combine the flexibility of clusters with the power of level minimization. Cass constructs a phylogenetic tree representing C whenever such a tree exists. 1 In Section 2, we generalize the notion of level to non-binary networks. 2 Named after the Cass Field Station in New Zealand.<ref type="bibr" target="#b11">Huson et al., 2009</ref>) for C ={{a,b,f ,g,i}, {a,b,c,f ,g,i}, {a,b,f ,i}, {b,c,f ,i}, {c,d,e,h}, {d,e,h}, {b,c,f ,h,i}, {b,c,d,f ,h,i}, {b,c,i}, {a,g}, {b,i}, {c,i}, {d,h}} and (b) the network constructed by Cass for the same input. Moreover, we prove that Cass constructs a level-1 or level-2 network representing C whenever there exists a level-1 or level-2 network representing C, respectively. Experimental results show that also when no level-2 network representing C exists, Cass usually constructs a network with a significantly lower level and lower number of reticulations compared with other algorithms. In fact, we conjecture that similar arguments as in our proof for level-2 can be used to show that Cass always constructs a level-k network with minimum k. We prove a decomposition theorem for level-k networks that supports this conjecture. Finally, we prove that Cass runs in polynomial time if the level of the output network is bounded by a constant. We have implemented Cass and added it to our popular treedrawing program Dendroscope (<ref type="bibr" target="#b8">Huson et al., 2007</ref>), where it can be used as an alternative for the cluster network (<ref type="bibr" target="#b9">Huson and Rupp, 2008</ref>) and galled network (<ref type="bibr" target="#b11">Huson et al., 2009</ref>) algorithms. Experiments show that, although Cass needs more time than these other algorithms, it constructs a simpler network representing the same set of clusters. For example,<ref type="figure" target="#fig_1">Figure 2a</ref>shows a set of clusters and the galled network with four reticulations constructed by the algorithm in<ref type="bibr">Huson et al. (2009). However, for</ref>this dataset also a level-2 network with two reticulations exists, and Cass can be used to find this network, see<ref type="figure" target="#fig_1">Figure 2b</ref>. Dendroscope now combines the powers of Cass and the two previously existing algorithms for constructing galled-and cluster networks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">LEVEL-K NETWORKS AND CLUSTERS</head><p>Consider a set X of taxa. A rooted (phylogenetic) network (on X ) is a directed acyclic graph with a single root and leaves bijectively labeled by X. The indegree of a node v is denoted δ − (v) and v is called a reticulation if δ − (v) ≥ 2. An edge (u,v) is called a reticulation edge if its head v is a reticulation and is called a tree edge otherwise. We assume without loss of generality that each reticulation has outdegree at least 1. Consequently, each leaf has indegree 1. When counting reticulations in a phylogenetic network, we count reticulations with more than two incoming edges more than once because, biologically, these reticulations represent several reticulate evolutionary events. Therefore, we formally define the reticulation number of a phylogenetic network N = (V ,E) as</p><formula>v∈V :δ − (v)&gt;0 (δ − (v)−1) =|E|−|V |+1.</formula><p>A directed acyclic graph is connected (also called 'weakly connected') if there is an undirected path (ignoring edge i125</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>L.van Iersel et al.</head><p>orientations) between each pair of nodes. A node (edge) of a directed graph is called a cut-node (cut-edge) if its removal disconnects the graph. A directed graph is biconnected if it contains no cut-nodes. A biconnected subgraph B of a directed graph G is said to be a biconnected component if there is no biconnected subgraph B = B of G that contains B. A phylogenetic network is said to be a level-k network if each biconnected component has reticulation number at most k. 3 A phylogenetic network is called binary if each node has either indegree at most 1 and outdegree at most 2 or indegree at most 2 and outdegree at most 1. Note that the above definition of level generalizes the original definition (<ref type="bibr" target="#b3">Choy et al., 2005</ref></p><formula>1 ∩ C 2 =∅ or C 1 ⊂ C 2 or C 2 ⊂ C 1 .</formula><p>Consider a set of clusters C. We say that a set of taxa X ⊆ X is separated (by C) if there exists a cluster C ∈ C that is incompatible with X. The incompatibility graph IG(C) of C is the undirected graph (V ,E) that has node set V = C and edge set</p><formula>E ={{C 1 ,C 2 } | C</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">DECOMPOSING LEVEL-K NETWORKS</head><p>In this section, we describe the general outline of our algorithm Cass. We show how the problem of determining a level-k network can be decomposed into a set of smaller problems by examining the incompatibility graph. Our algorithm will first construct a simple level-≤ k network for each connected component of the incompatibility graph and subsequently merge these simple level≤ k networks into a single level-k network on all taxa. We first give a formal description of the algorithm, which is illustrated by an example in<ref type="figure" target="#fig_5">Figure 3</ref>. After that we will explain why we can use this approach. Consider a set of taxa X and a set C of input clusters. We assume that all singletons (sets {x} with x ∈ X ) are clusters in C. Our algorithm proceeds as follows.</p><p>Step 1. Find the non-trivial connected components C 1 ,...,C p of the incompatibility graph IG(C). For each i ∈{1,...,p}, let C i be the result of collapsing unseparated sets of taxa as follows. Let</p><formula>X i = C∈C i C.</formula><p>For each maximal subset X ⊂ X i that is not separated by C i , replace, in each cluster in C i , the elements of X by a single new taxon X, e.g. if X ={b,c} then a cluster {a,b,c,d} is modified to {a,{b,c},d}.Proof. Let C be a set of input clusters and N a level-k network representing C. Let C 1 ,...,C p be the non-trivial connected components of the incompatibility graph IG(C). For each i ∈ {1,...,p}, we construct a simple level-≤ k network N i as follows. Let X i = C∈C i C as before. For each maximal subset X ⊂ X i (with |X| &gt; 1) that is not separated by C i , replace in N an arbitrary leaf labeled by an element of X by a leaf labeled X and remove all other leaves labeled by elements of X. In addition, remove all leaves with labels that are not in X i. We tidy up the resulting graph by repeatedly applying the following five steps until none is applicable: (i) delete unlabeled nodes with outdegree 0; (ii) suppress nodes with indegree and outdegree 1 (i.e. contract one edge incident to the node); (iii) replace multiple edges by single edges, (iv) remove the root if it has outdegree 1 and (v) contract biconnected components that have only one outgoing edge. This leads to a level-k network N i. Let C i be defined as in Step 1 of the algorithm. By its construction, N i represents C i . Furthermore, N i is a simple level-≤ k network, because if it would contain a cutedge e whose head is not a leaf, then the set of taxa labeling leaves reachable from e would not be separated by C i and would hence have been collapsed. Finally, the networks N 1 ,.N/A (only one cluster) N/A (only one cluster)) constructs a level-2 network from the clusters {a,b}, {b,c}, {d,e}, {d,f }, {e,f }, {a,b,c,d,e,f ,g}, {g,h,i,j}, {i,j}, {h,i,j}. Section 4 describes how the simple networks in Step 2 are created. biconnected components correspond to the connected components of the incompatibility graph. Since N has level k, each biconnected component has level at most k. Hence, we can construct a simple level-≤ k network for each connected component of the incompatibility graph. Subsequently, we can merge these simple level-≤ k networks into a level-k network representing C. This is precisely what the set-up described above does. Note finally that the statement obtained by replacing 'level-k network' by 'network with k reticulations' in Theorem 1 does not hold, as shown in<ref type="bibr" target="#b11">Huson et al. (2009)</ref>, based on Gusfield et al.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>..,N</head><formula>(2007a).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">SIMPLE LEVEL-K NETWORKS</head><p>This section describes how one can construct a simple levelk network representing a given set of clusters. We say that a phylogenetic tree T is a strict subtree of a network N if T is a subgraph of N and for each node v of T , except its root, it holds that the in-and outdegree of v in T are equal to the in-and (respectively) outdegree of v in N. Informally, our method for constructing simple level-k networks operates as follows. See<ref type="figure" target="#fig_8">Figure 4</ref>Observe that any simple level-k network N (k ≥ 1) contains a leaf whose parent is a reticulation (since we assume that each reticulation has outdegree at least 1). If we remove this leaf and reticulation from N, the resulting network might contain one or more strict subtrees. To reconstruct the network, we need to identify these strict subtrees from the set of clusters. We will see below that each strict subtree corresponds to an ST-set. Moreover, for the case k ≤ 2, we prove that (without loss of generality) each maximal strict subtree corresponds to a maximal ST-set. Cass collapses the maximal ST-sets because it assumes that these correspond to the strict subtrees. Now observe that collapsing each maximal strict subtree of the network leads to a (not necessarily simple) level-(k −1) network, which again contains a leaf whose parent is a reticulation. It follows that it is indeed possible to repeat the described steps k times. Finally, Cass checks if all clusters are represented and only outputs networks for which this is the case. Let us now formalize this algorithm. Given a set S ⊆ X of taxa, we use C \S to denote the result of removing all elements of S from each cluster in C and we use C|S to denote C \(X \S) (the restriction of C to S). We say that a set S = X is an ST-set (strict tree set) w.r.t. C, if S is not separated by C and any two clusters C 1 ,C 2 ∈ C|S are compatible. An ST-set S is maximal if there is no ST-set T with S T. Informally, the maximal ST-sets are the result of repeatedly collapsing pairs of unseparated taxa for as long as possible.We use Collapse(C) to denote the result of collapsing each maximal ST-set S into a single taxon S. More precisely, for each cluster C ∈ C and maximal ST-set S of C, we replace C by C \S ∪{{S}}. For example (omitting singleton clusters), if C ={ {1,2}, {2,3,4}, {3,4} }, then {3,4} is the only non-singleton maximal ST-set andProof. The general idea of the proof is as follows. Details have been omitted due to space constraints. Assume k ≤ 2. It is clear that any (simple) level-k network N contains a reticulation r with a leaf, say labeled x, as child. Let N \{x} denote the network obtained by removing the reticulation r and the leaf labeled x from N. This network might contain one or more strict subtrees. By the definition of ST-set, the set of leaf labels of each maximal strict subtree corresponds to an ST-set w.r.t. C \{x}. However, in general not each such set needs to be a maximal ST-set. This is critical, because the total number of ST-sets can be exponentially large. Therefore, the main ingredient of our proof is the following. We show that whenever there exists a simple level-k network representing C, there exists a simple level-k network N representing C such that the sets of leaf-labels of the maximal strict subtrees of N \{x} are the maximal ST-sets w.r.t. C \{x}, with x the label of some leaf whose parent is areturn N reticulation in N. This is clearly true for k = 1. For k = 2, we sketch our proof below. Let us first mention that the actual algorithm is slightly more complicated than the pseudocode in Algorithm 1. First, when Cass(k) constructs a tree, it adds a new 'dummy' root to this tree and creates an edge from this dummy root to the old root. Such a dummy root is removed before outputting a network. Second, whenever the algorithm removes a dummy taxon δ (which we use to model the situation when the previous leaf removal caused more than one reticulation to disappear), it makes sure that it does not collapse in the previous step. Suppose there exists some level-2 network representing C. It can be shown that any such network is simple and that there exists at least one binary such network, say N. Since N is a binary simple level-2 network, there are only four possibilities for the structure of N (after removing leaves), see van<ref type="bibr" target="#b21">Iersel et al. (2009a)</ref>. These structures are called generators. In each case, N \{x} contains at most two maximal strict subtrees that have more than one leaf. Furthermore, N \{x} contains exactly one reticulation r , below which hangs a strict subtree T r with set of leaf labels X r (possibly, |X r |=1 or |X r |=0). First, we assume that X r is not a maximal ST-set w.r.t. C \{x}. In that case it follows that there is some maximal ST-set X that contains X r and also contains at least one taxon labeling a leaf that is not reachable by a directed path from the reticulation of N \{x}. We can replace by a strict subtree on X that represents C|X. Such</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i127</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>i128</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Simpler phylogenetic networks from clusters</head><p>a tree exists because X is an ST-set. We remove all leaves that label elements of X and are not in this strict subtree. Since there are now no leaves left below the reticulation, we can remove this reticulation as well. It is easy to see that the resulting network is a tree representing C \{x}. Moreover, we show that in each case a leaf labeled x can be added below a new reticulation (possibly with indegree 3) in order to obtain a network N that represents C. Since N contains just one reticulation, it is clear that the maximal strict subtrees of N \{x} are the maximal ST-sets w.r.t. C \{x}. Cass(2) reconstructs such a network with an indegree-3 reticulation by removing x, removing a dummy taxon δ, constructing a tree, adding a leaf labeled δ below a reticulation, adding a leaf labeled x below a reticulation, removing the leaf labeled δ and contracting the (now redundant) edges between the two reticulations. Note that this works because Cass(2) does not collapse in this case. It remains to consider the possibility that X r is a maximal ST-set w.r.t. C \{x}. In this case, we modify network N to N in such a way that also the other maximal ST-sets w.r.t. C \{x} appear as the leaf-sets of strict subtrees in N \{x}. We again use a case analysis to show that this is always possible in such a way that the resulting network N represents C.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Lemma 2. Cass runs in time O(|X | 3k+2 ·|C|), if k is fixed.</head><p>Proof. Omitted due to space constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 2. Given a set of clusters C, Cass constructs in polynomial time a level-2 network representing C, if such a network exists.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proof. Follows from Lemmas 1 and 2 and Theorem 1.</head><p>We conclude this section by showing that for each r ≥ 2, there exists a set of clusters C r such that any galled network representing C r needs at least r reticulations, while Cass constructs a network with just two reticulations, which also represents C r. This follows from the following lemma.Proof. Omitted due to space constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PRACTICE</head><p>Our implementation of the Cass algorithm is available as part of the Dendroscope program (<ref type="bibr" target="#b8">Huson et al., 2007</ref>). To use Cass, first load a set of trees into Dendroscope. Subsequently, run the algorithm by choosing 'options' and 'network consensus'. The program gives you the option of entering a threshold percentage t. Only clusters that appear in more than t percent of the input trees will be used as input for Cass. Choose 'minimal network' to run the Cass algorithm to construct a phylogenetic network representing all clusters that appear in more than t percent of the input trees. Cass computes a solution for each biconnected component separately. If the computations for a certain biconnected component take too long, you can choose to 'skip' the component, in which case the program will quickly compute the cluster network (<ref type="bibr" target="#b9">Huson and Rupp, 2008</ref>) for this biconnected component, instead. Alternatively, you can choose to construct a galled network, or to increase the threshold percentage t. See van<ref type="bibr" target="#b22">Iersel et al. (2009b)</ref>for a user guidecontain 47, 65, 40, 37, 34 and 19 taxa, respectively. We have compared the results of Cass not only with the galled network and the cluster network algorithms, but also with the very recently developed algorithms HybridInterleave (J.<ref type="bibr">Collins et al.,</ref>submitted for publication) and PIRN (Y.Wu, submitted for publication). HybridInterleave computes the minimum number of reticulations required to combine two binary phylogenetic trees (on the same set of taxa) into a phylogenetic network that displays both trees. PIRN has the same objective as HybridInterleave but has the advantage that it can accept more than two trees as input (which are still required to be binary). On the other hand, HybridInterleave has the advantage that it is guaranteed to find an optimal solution. For this experiment, we compiled PIRN with the ILP (Integer Linear Programming) solver CPLEX 10.2. We considered all possible subsets of at least two of the six gene trees; 57 in total. For each subset, we first restricted the trees to the taxa present in all trees in the subset to make the input data compatible with HybridInterleave and PIRN. Then, we executed each program for a maximum of 5 min on a 2.83 GHz quad-core PC with 8 GB RAM and recorded the best solution it could find in that time frame. The full results are available in<ref type="figure" target="#tab_2">Table 2</ref>in the Supplementary Material. Results for HybridInterleave (which could only be applied to pairs of trees) differ from the results reported in (J.<ref type="bibr">Collins et al.,</ref>submitted for publication) because there trees with a different rooting were used. Our results show that Cass always found a solution (within 5 min) when the minimum level was at most 4, and sometimes when the minimum level was 5 or 6. We also see that, in all these cases, no program found a solution using fewer reticulations than Cass. To obtain each of the graphs in<ref type="figure" target="#fig_12">Figure 5</ref>, we averaged over those subsets where all the programs had terminated within 5 min (which was the majority). Several conclusions can be drawn from these graphs. The main conclusion is that Cass on average required fewer reticulations than each of the other programs. That Cass uses fewer reticulations than PIRN can be explained by the fact that PIRN (as well as HybridInterleave) requires the output network to display all input trees. The networks constructed by Cass do not necessarily display the input trees, but still represent all clusters from the trees, and in general use fewer reticulations to do so.<ref type="figure" target="#fig_12">Figure 5a</ref>is noteworthy in this regard. It turns out that, when restricted to subsets of exactly two trees, Cass, PIRN and HybridInterleave always achieved the same optimum. This turns out not to be coincidence, but a mathematical consequence of extracting clusters from exactly two binary trees on the same taxa set (L.J.J.van Iersel and S.M.Kelk, in preparation). The advantages of Cass clearly become most visible when larger subsets of trees are used. In terms of running time, PIRN and HybridInterleave are in general faster than Cass, but Cass has the significant flexibility that it is not restricted to binary (i.e. fully resolved) input trees and is not restricted to trees on the same taxa set. Compared with HybridInterleave, Cass also has the advantage that it is not restricted to two input trees and that it constructs an actual network rather than to only report the number of reticulations. Finally, because Cass is not restricted to binary trees, the user is free to choose only well-supported clusters from the input trees.<ref type="figure" target="#fig_14">Figure 6</ref>is a nice example of this: this is the output of Cass when given all clusters that were in at least three of the six gene trees (i.e. t = 34%), without having to first restrict to those taxa common to all six trees (in this case, only four taxa were common to all six input trees). This example also illustrates that, when there exists a solution with a low level, Cass can handle large numbers of taxa and reticulations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">DISCUSSION</head><p>We have introduced the Cass algorithm, which can be used to combine any set of clusters into a phylogenetic network representing those clusters. We have shown that the algorithm performs well on practical data. It provides a useful addition to existing software, because it usually constructs a simpler network representing the same set of input clusters. Furthermore, we have shown that Cass provides a polynomial-time algorithm for deciding whether a level2 phylogenetic network exists that represents a given set of clusters. This algorithm is more useful in practice than algorithms for similar problems that take triplets as input (<ref type="bibr" target="#b13">Jansson and Sung, 2006;</ref><ref type="bibr" target="#b13">Jansson et al., 2006;</ref><ref type="bibr" target="#b19">To and Habib, 2009;</ref><ref type="bibr" target="#b20">van Iersel and Kelk, 2009;</ref><ref type="bibr" target="#b21">van Iersel et al., 2009a</ref>), because clusters are more biologically relevant than triplets and because the latter algorithms need at least one triplet for each combination of three taxa as input, while Cass can be used for any set of input clusters. Furthermore, Cass is also not restricted to two input trees, as the algorithms in<ref type="bibr" target="#b2">Bordewich et al. (2007)</ref>the six gene trees of the Poaceae grass dataset, within 5 s. Clusters were used that were present in at least three of the six gene trees. For the same input GalledNetwork produced a level-5 network with 17 reticulations, and the cluster network algorithm produced a level-11 network with 32 reticulations. all clusters in the multi-labeled tree(s) and subsequently uses Cass to find a phylogenetic network representing these clusters. Several theoretical problems remain open. First of all, does Cass always construct a minimum-level network, even if this minimum is three or more? Second, what is the complexity of constructing a minimum level network, if the minimum level k is not fixed but part of the input? Is this problem FPT when parameterized by k? Finally, it would be interesting to design an algorithm that finds a network representing a set of input clusters that has a minimum reticulation number. So far, not even a non-trivial exponential-time algorithm is known for this problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig.2.</head><figDesc>Fig. 2. (a) The output of the galled network algorithm (Huson et al., 2009) for C ={{a,b,f ,g,i}, {a,b,c,f ,g,i}, {a,b,f ,i}, {b,c,f ,i}, {c,d,e,h}, {d,e,h}, {b,c,f ,h,i}, {b,c,d,f ,h,i}, {b,c,i}, {a,g}, {b,i}, {c,i}, {d,h}} and (b) the</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><figDesc>) for binary networks. A level-k network is called a simple level-≤ k network if the head of each cut-edge is a leaf. A simple level-≤ k network is called a simple level-k network if its reticulation number is precisely k. For example, Figure 2a is a simple level-4 network and Figure 2b is a simple level-2 network. A phylogenetic tree (on X ) is a phylogenetic network (on X ) without reticulations, i.e. a level-0 network. Consider a set of taxa X. Proper subsets of X are called clusters. We say that two clusters C 1 ,C 2 ⊂ X are compatible if either C</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Step2.</head><figDesc>For each i ∈{1,...,p}, construct a simple level-≤ k network N i representing C i .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.3.</head><figDesc>Fig. 3. How the four-step decomposition algorithm of Cass (Section 3) constructs a level-2 network from the clusters {a,b}, {b,c}, {d,e}, {d,f }, {e,f }, {a,b,c,d,e,f ,g}, {g,h,i,j}, {i,j}, {h,i,j}. Section 4 describes how the simple networks in Step 2 are created.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><figDesc>for an example. Cass loops over all taxa x. For each choice of x, Cass removes it from each cluster and subsequently collapses all maximal 'ST-sets' ('strict tree sets', defined below) of the resulting cluster set. The algorithm repeats this step k times, after which all leaves will be collapsed into just two taxa and the second phase of the algorithm starts. Cass creates a network consisting of a root with two children, labeled by the only two taxa. Then the algorithm 'decollapses', i.e. it replaces each leaf labeled by an ST-set by a strict subtree. Subsequently, Cass adds a new leaf below a new reticulation and labels it by the latest removed taxon. Since it does not know where to create the new reticulation, Cass tries adding the reticulation below each pair of edges. The algorithm continues with a new decollapse step followed by hanging the next leaf below a reticulation. These steps are also repeated k times. For each constructed simple level-k network, Cass checks whether it represents all input clusters. If it does, the algorithm outputs the resulting network, after contracting any edges that connect two reticulations. The idea behind this strategy is as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.4.</head><figDesc>Fig. 4. Construction of a simple level-2 network by the Cass algorithm. The edges e 1 ,e 2 that will be subdivided are colored red. Singleton clusters have been omitted, as well as the last collapse step, for simplicity.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><figDesc>Collapse(C) ={ {1,2}, {2,{3,4}} }. The set of taxa of a (collapsed) cluster set C is denoted X (C). Thus, for the above example, X (Collapse(C)) ={1,2,{3,4}}. We are now ready to give the pseudocode of Cass(k) in Algorithm 1. The actual implementation is slightly more complex and much more space efficient. Figure 4 shows how the Cass(2) algorithm, for example, constructs a simple level-2 network. We will now show that Cass(1) and Cass(2) will indeed construct a simple level-1, respectively, level-2 network whenever this is possible.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>return</head><figDesc>any simple level-k network in N , after removing each leaf labeled δ and contracting each edge connecting two reticulations 22: else 23:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Fig.5.</head><figDesc>Fig. 5. (a) The average number of reticulations used by the compared programs, ranging over all combinations of two gene trees from the six trees in the Poaceae grass dataset, and restricted to those combinations for which all programs terminated within 5 min. (b) As in (a), but ranging over combinations containing three or more gene trees. (c) As in (a), but ranging over all combinations of two or more trees.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><figDesc>; J.Collins et al., (submitted for publication); Linz and Semple (2009) and not to fully resolved trees on identical taxa sets, as the algorithms in Bordewich et al. (2007), J.Collins et al. (submitted for publication), Y.Wu et al. (submitted for publication). Finally, we remark that Cass can also be used when one or more multi-labeled trees are given as input. In this case, Dendroscope first computes i130 Simpler phylogenetic networks from clusters</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig.6.</head><figDesc>Fig. 6. Level-4 network with 66 taxa and 15 reticulations constructed by Cass for the six gene trees of the Poaceae grass dataset, within 5 s. Clusters were used that were present in at least three of the six gene trees. For the same input GalledNetwork produced a level-5 network with 17 reticulations, and the cluster network algorithm produced a level-11 network with 32 reticulations.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>1 and C 2 are incompatible clusters in C}.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Step 3. Let C * be the result of applying the following modifications to C, for each i ∈{1,...,p}: remove all clusters that are in C i , add a cluster X i and add each maximal subset X ⊂ X i that is not separated by C i. Construct the unique phylogenetic tree T on X representing</figDesc><table>Theorem 1. Let C be a set of clusters. If there exists a level-k network 
representing C, then there also exists such a network satisfying the 
decomposition property w.r.t. C. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><figDesc>p can be merged into a level-k network representing C and satisfying the decomposition property by executing Steps 3 and 4 of the algorithm. Intuitively, Theorem 1 tells us that whenever there exists a level-k network N representing C, there also exists such a network N whose i126 Simpler phylogenetic networks from clusters</figDesc><table>{a,b} 

{b,c} 

a 

{d,f} {d,e} 

{e,f} 

{a,b,c,d,e,f,g} 

{g,h,i,j} 

{i,j} 
{h,i,j} 

X1 = {a,b,c} 
X2 = {d,e,f} 
X3 = {a,b,c,d,e,f,g,h,i,j} 
X4 = {i,j} 
X5 = {h,i,j} 

No unseparated 
maximal subsets 

No unseparated 
maximal subsets 

Unseparated maximal subsets 
are {a,b,c,d,e,f} and {h,i,j} 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>Lemma 1. Given a set of clusters C, such that IG(C) is connected and any X X is separated, Cass(1) and Cass</figDesc><table>(2) construct a simple 
level-1, respectively, a simple level-2 network representing C, if such 
a network exists. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="true"><figDesc>Table 1. Results of Cass compared with GalledNetwork for several example cluster sets with |C| clusters and |X | taxa</figDesc><table>Data 
GalledNetwork 
Cass 

|C| 
| X | 
t 
k 
r 
t 
k 
r 

3 0 
5 
0s 
6 
6 
1s 
4 
4 
6 2 
6 
0s 
8 
8 
7s 
5 
5 
1 2 6 
7 
0s 
1 0 
1 0 
2 8s 
6 
6 
2 5 4 
8 
6s 
1 2 
1 2 
4m3s 
7 
7 
42 
10 
0 s 
4 
4 
6 s 
4 
4 
38 
11 
0 s 
7 
7 
14 s 
5 
5 
61 
11 
0 s 
6 
6 
47 s 
5 
5 
77 
22 
0 s 
9 
9 
36 s 
3 
3 
75 
30 
0 s 
11 
11 
5 s 
2 
2 
89 
31 
0 s 
16 
16 
27 m 32 s 
4 
4 
180 
51 
0 s 
11 
11 
30 s 
2 
2 
193 
57 
0 s 
1 
4 
1 s 
1 
4 
270 
76 
0 s 
16 
16 
4 m 52 s 
2 
2 
404 
122 
1 s 
2 
2 
21 m 10 s 
2 
2 

135.8 31.9 
1s 
8.5 
8.7 
4 m 19 s 
3.7 
3.9 </table></figure>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="3"> Note that to determine the reticulation number of a biconnected component one only counts edges inside this biconnected component. precisely those clusters in C * . (Notice that each trivial connected component of the incompatibility graph is also a cluster in C * .) Step 4. For each i ∈{1,...,p}, replace in T the lowest common ancestor v i of X i by the simple level-≤ k network N i as follows. Delete all edges leaving v i and merge T with N i by identifying the root of N i with v i and identifying each leaf of N i labeled X by the lowest common ancestor of the leaves labeled X in T. Output the resulting network. Notice that Steps 1, 3 and 4 are similar to the corresponding steps in algorithms for constructing galled trees (i.e. level-1 networks) and galled networks (Huson and Klöpper, 2007; Huson et al., 2009; D.H.Huson et al., submitted for publication). The reason why we use the same set-up in our algorithm, is outlined by Theorem 1. It shows that, when constructing a level-k network displaying a set of clusters, we can restrict our attention to level-k networks that satisfy the decomposition property (D.H.Huson et al., submitted for publication), which intuitively says that the biconnected components of the network correspond to the connected components of the incompatibility graph. We now repeat the formal definition. Since a cluster C ∈ C can be represented by more than one edge in a network N, an edge assignment is defined as a mapping that chooses for each cluster C ∈ C a single tree edge (C) of N that represents C. A network N representing C is said to satisfy the decomposition property w.r.t. C if there exists an edge assignment such that: • for any two clusters C 1 ,C 2 ∈ C, the edges (C 1 ) and (C 2 ) are contained in the same biconnected component of N if and only if C 1 and C 2 lie in the same connected component of the incompatibility graph IG(C).</note>

			<note place="foot">For each algorithm, the level k and reticulation number r of the output network are given as well as the running time t in minutes (m) and seconds (s) on a 1.67 GHz 2 GB laptop. The last row gives the average values. for Cass and all datasets used for this article. See Huson et al. (2007) for more information on using Dendroscope. We have tested Cass on both practical and artificial data and compared Cass with other programs. The results (using t = 0) are summarized in Table 1 and Figure 5. For Table 1, several example datasets have been used, which have been selected in such a way as to obtain a good variation in number of taxa, number of clusters and network complexity. The first four datasets are the sets containing all possible clusters on 5, 6, 7 and 8 taxa, respectively. The other datasets have been constructed by taking the set of clusters in (arbitrary) networks of increasing size and complexity. Mostly networks with just one biconnected component have been used because, for networks with more biconnected components, both algorithms use the same method to decompose into biconnected components and then both find a solution for each biconnected component separately. For each dataset, we have constructed one network using Cass, which we call the Cass network, and one galled network using the algorithm in Huson et al. (2009). Two conclusions can be drawn from the results. First, Cass uses more time than the galled network algorithm. Nevertheless, the time needed by Cass can still be considered acceptable for phylogenetic analysis. Second, Cass constructs a much simpler network in almost all cases. For three datasets, the Cass network and the galled network have the same reticulation number and the same level. For all other datasets, the Cass network has a significantly smaller reticulation number, and also a lower level, than the galled network. Figure 5 summarizes the results of an application of Cass to practical data. This dataset consists of six phylogenetic trees of grasses of the Poaceae family, originally published by the Grass Phylogeny Working Group (2001) and reanalyzed in Schmidt (2003). The phylogenetic trees are based on sequences from six different gene loci, ITS, ndhF, phyB, rbcL, rpoC and waxy, and i129 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">i131 at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">09</title>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page" from="34" to="51" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
	<note>btq202. .tex]</note>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Computing the minimum number of hybridization events for a consistent evolutionary history</title>
		<author>
			<persName>
				<forename type="first">Page</forename>
				<surname>Bordewich</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Semple</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Appl. Math</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="page" from="131" to="124" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">A reduction algorithm for computing the hybridization number of two trees</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Bordewich</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Evol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="86" to="98" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Computing the maximum agreement of phylogenetic networks</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Choy</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">335</biblScope>
			<biblScope unit="page" from="93" to="107" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<monogr>
		<title level="m" type="main">Who&apos;s who in phylogenetic networks Available at http:// www.lirmm.fr/∼gambette/PhylogeneticNetworks</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Gambette</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009-04-24" />
		</imprint>
	</monogr>
	<note>last. accessed date</note>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Phylogeny and subfamilial classification of the grasses (Poaceae)</title>
	</analytic>
	<monogr>
		<title level="j">Grass Phylogeny Working Group Ann. Mo. Bot. Gard</title>
		<imprint>
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="page" from="373" to="457" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">A decomposition theory for phylogenetic networks and incompatible characters</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="1247" to="1272" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">An efficiently computed lower bound on the number of recombinations in phylogenetic networks: theory and empirical study</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Gusfield</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Appl. Math</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="page" from="806" to="830" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Beyond galled trees-decomposition and computation of galled networks</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">H</forename>
				<surname>Klöpper</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Research in Computational Molecular Biology (RECOMB)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="221" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Summarizing multiple gene trees using cluster networks</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Rupp</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Algorithms in Bioinformatics (WABI)</title>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="page" from="296" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Dendroscope: an interactive viewer for large phylogenetic trees</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page">460</biblScope>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">Computing galled networks from real data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">H</forename>
				<surname>Huson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="85" to="93" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Constructing a smallest refining galled phylogenetic network</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Huynh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Research in Computational Molecular Biology (RECOMB) Lecture Notes in Bioinformatics</title>
		<imprint>
			<publisher>Springer</publisher>
			<biblScope unit="volume">3500</biblScope>
			<biblScope unit="page" from="265" to="280" />
			<date type="published" when="2005" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Inferring a level-1 phylogenetic network from a dense set of rooted triplets</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Jansson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W.-K</forename>
				<surname>Sung</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comp. Sci</title>
		<imprint>
			<biblScope unit="volume">363</biblScope>
			<biblScope unit="page" from="60" to="68" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">Algorithms for combining rooted triplets into a galled phylogenetic network</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Jansson</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="page" from="1098" to="1121" />
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Hybridisation in nonbinary trees</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Linz</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Semple</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="30" to="45" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Evolutionary phylogenetic networks: models and issues</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Nakleh</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Problem Solving Handbook for Computational Biology and Bionformatics</title>
		<editor>Heath,L. and Ramakrishnan,N.</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<monogr>
		<title level="m" type="main">Phylogenetic trees from large datasets</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<forename type="middle">A</forename>
				<surname>Schmidt</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<pubPlace>Düsseldorf</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Hybridization networks</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Semple</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reconstructing Evolution-New Mathematical and Computational Advances</title>
		<editor>Gascuel,O. and Steel,M.</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="277" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">Level-k phylogenetic networks are constructable from a dense triplet set in polynomial time</title>
		<author>
			<persName>
				<forename type="first">T.-H</forename>
				<surname>To</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Habib</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Combinatorial Pattern Matching (CPM)</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="275" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<monogr>
		<title level="m" type="main">Constructing the simplest possible phylogenetic network from triplets. Algorithmica [Epub ahead of print</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">J J</forename>
				<surname>Van Iersel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">M</forename>
				<surname>Kelk</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009-07-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Constructing level-2 phylogenetic networks from triplets</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">J J</forename>
				<surname>Van Iersel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans. Comput. Biol. Bioinform</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="667" to="681" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<monogr>
		<title level="m" type="main">Cass: Combining phylogenetic trees into a phylogenetic network</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">J J</forename>
				<surname>Van Iersel</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2009-04-24" />
		</imprint>
	</monogr>
	<note>last. accessed date</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>