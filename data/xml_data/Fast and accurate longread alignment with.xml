
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:49+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast and accurate long-read alignment with Burrows–Wheeler transform</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date type="published" when="2010">2010</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName>
								<forename type="first">Heng</forename>
								<surname>Li</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Wellcome Trust Sanger Institute</orgName>
								<orgName type="institution" key="instit2">Wellcome Genome Campus</orgName>
								<address>
									<postCode>CB10 1SA</postCode>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Richard</forename>
								<surname>Durbin</surname>
							</persName>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">Wellcome Trust Sanger Institute</orgName>
								<orgName type="institution" key="instit2">Wellcome Genome Campus</orgName>
								<address>
									<postCode>CB10 1SA</postCode>
									<settlement>Cambridge</settlement>
									<country key="GB">UK</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fast and accurate long-read alignment with Burrows–Wheeler transform</title>
					</analytic>
					<monogr>
						<title level="j" type="main">BIOINFORMATICS ORIGINAL PAPER</title>
						<imprint>
							<biblScope unit="volume">26</biblScope>
							<biblScope unit="issue">5</biblScope>
							<biblScope unit="page" from="589" to="595"/>
							<date type="published" when="2010">2010</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.1093/bioinformatics/btp698</idno>
					<note type="submission">Sequence analysis Advance Access publication January 15, 2010 Received on September 19, 2009; revised on November 24, 2009; accepted on December 16, 2009</note>
					<note>[16:59 8/2/2010 Bioinformatics-btp698.tex] Page: 589 589–595 Associate Editor: Dmitrij Frishman</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Many programs for aligning short sequencing reads to a reference genome have been developed in the last 2 years. Most of them are very efficient for short reads but inefficient or not applicable for reads &gt;200 bp because the algorithms are heavily and specifically tuned for short queries with low sequencing error rate. However, some sequencing platforms already produce longer reads and others are expected to become available soon. For longer reads, hashing-based software such as BLAT and SSAHA2 remain the only choices. Nonetheless, these methods are substantially slower than short-read aligners in terms of aligned bases per unit time. Results: We designed and implemented a new algorithm, Burrows-Wheeler Aligner&apos;s Smith-Waterman Alignment (BWA-SW), to align long sequences up to 1 Mb against a large sequence database (e.g. the human genome) with a few gigabytes of memory. The algorithm is as accurate as SSAHA2, more accurate than BLAT, and is several to tens of times faster than both. Availability: http://bio</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Following the development of sensitive local alignment software, such as FASTA (<ref type="bibr" target="#b18">Pearson and Lipman, 1988</ref>) and BLAST (<ref type="bibr" target="#b0">Altschul et al., 1997</ref>) around 1990, a new generation of faster methods to find DNA sequence matches was developed since 2000, including MegaBLAST (<ref type="bibr" target="#b16">Morgulis et al., 2008;</ref><ref type="bibr" target="#b24">Zhang et al., 2000</ref>), SSAHA2 (<ref type="bibr" target="#b17">Ning et al., 2001</ref>), BLAT (<ref type="bibr" target="#b6">Kent, 2002</ref>) and PatternHunter (<ref type="bibr" target="#b14">Ma et al., 2002</ref>), greatly speeding up matching capillary sequencing reads against a large reference genome. When new sequencing technologies arrived that generated millions of short (&lt;100 bp) reads, a variety of new algorithms were developed which were 10–1000 times faster, including SOAP (<ref type="bibr" target="#b12">Li,R. et al., 2008</ref>), MAQ (<ref type="bibr" target="#b10">Li,H. et al., 2008</ref>), Bowtie (<ref type="bibr" target="#b8">Langmead et al., 2009</ref>) and BWA (<ref type="bibr" target="#b9">Li and Durbin, 2009</ref>). However, Roche/454 sequencing technology has already produced reads &gt;400 bp in production, Illumina gradually increases read length &gt;100 bp, and Pacific Bioscience generates 1000 bp reads in early testing (<ref type="bibr" target="#b3">Eid et al., 2009</ref>). Reads coming from the new sequencing technologies are not short any more, which effectively rules out many of the new aligners exclusively designed for reads * To whom correspondence should be addressed. no longer than 100 bp. Efficiently aligning long reads against a long reference sequence like the human genome poses a new challenge to the development of alignment tools. Long-read alignment has different objectives from short-read alignment. First, in short-read alignment, we would usually like to align the full-length read to reduce the reference bias caused by the mismatches toward the ends of the read. Given this requirement, we can design spaced seed templates (<ref type="bibr" target="#b14">Ma et al., 2002</ref>) spanning the entire read (<ref type="bibr" target="#b5">Jiang and Wong, 2008;</ref><ref type="bibr" target="#b13">Lin et al., 2008;</ref><ref type="bibr" target="#b22">Smith et al., 2008</ref>), or quickly filter out poor matches, for example, by applying q-gram filtration (<ref type="bibr" target="#b21">Rumble et al., 2009;</ref><ref type="bibr" target="#b23">Weese et al., 2009</ref>) or by bounding the search process (<ref type="bibr" target="#b9">Li and Durbin, 2009</ref>), and thus accelerate the alignment. In long-read alignment, however, we would prefer to find local matches because a long read is more fragile to structural variations and misassemblies in the reference but is less affected by the mismatches close to the ends of a read. Secondly, many short-read aligners are only efficient when doing ungapped alignment or allowing limited gaps, e.g. a maximum of one gap. They cannot find more gaps or the performance quickly degrades when they are tuned for this task. Long-read aligners, however, must be permissive about alignment gaps because indels occur more frequently in long reads and may be the dominant source of sequencing errors for some technologies such as 454 and Pacific Bioscience. When considering algorithms to speed-up long-read alignment, hash table indexing as is used in most current software is not the only choice.<ref type="bibr" target="#b15">Meek et al. (2003)</ref>found a Smith–Waterman-like dynamic programming that can be applied between a query sequence and the suffix tree of the reference, effectively aligning the query against each subsequence sampled from the suffix tree via a top-down traversal. As on a suffix tree identical sequences are collapsed on a single path, time is saved by avoiding repeated alignment of identical subsequences.<ref type="bibr" target="#b7">Lam et al. (2008)</ref>furthered this idea by implicitly representing the suffix tree with an FM-index (<ref type="bibr" target="#b4">Ferragina and Manzini, 2000</ref>), which is based on the Burrows–Wheeler Transform (BWT;<ref type="bibr" target="#b2">Burrows and Wheeler, 1994</ref>), to achieve a small memory footprint. Their new algorithm, BWT-SW, is able to deliver identical results to the standard Smith–Waterman alignment, but thousands of times faster when aligning against the human genome sequence. While BWT-SW is still slower than BLAST on long query sequences, it finds all matches without heuristics. One can imagine that introducing heuristics would further accelerate BWT-SW. Our BWA-SW algorithm follows this route. To some extent, BWA-SW, as well as BWT-SW, also follows the seed-and-extend paradigm. But different from BLAT and SSAHA2,Page: 590 589–595</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H.Li and R.Durbin</head><p>BWA-SW finds seeds by dynamic programming between two FMindices and allows mismatches and gaps in the seeds. It extends a seed when the seed has few occurrences in the reference sequence. Speed is gained by reducing unnecessary extension for highly repetitive sequences. In this article, we will describe this new alignment algorithm, BWA-SW, for long-read alignments and evaluate its practical performance along with BLAT and SSAHA2 on both simulated and real data. We will also give a brief introduction to suffix array and FM-index, but readers are referred to Li and Durbin (2009) for more details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">METHODS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Overview of the BWA-SW algorithm</head><p>BWA-SW builds FM-indices for both the reference and query sequence. It implicitly represents the reference sequence in a prefix trie and represents the query sequence in a prefix directed acyclic word graph (prefix DAWG;<ref type="bibr" target="#b1">Blumer et al., 1985</ref>), which is transformed from the prefix trie of the query sequence (Section 2.3). A dynamic programming can be applied between the trie and the DAWG, by traversing the reference prefix trie and the query DAWG, respectively. This dynamic programming would find all local matches if no heuristics were applied, but would be no faster than BWTSW. In BWA-SW, we apply two heuristic rules to greatly accelerate this process. First, traversal on the query DAWG is carried in the outer loop, and therefore without finishing the dynamic programming, we know all the nodes in the reference prefix trie that match the query node with a positive score. Based on the observation that the true alignment tends to have a high alignment score, we can prune low-scoring matches at each node to restrict the dynamic programming around good matches only. The scale of dynamic programming can thus be dramatically reduced. It is possible for the true alignment to be pruned in this process, but in practice, this can be controlled by the use of heuristics and happens rarely, given long or highquality query sequences. Secondly, BWA-SW only reports alignments largely non-overlapping on the query sequence instead of giving all the significant local alignments. It heuristically identifies and discards seeds contained in a longer alignment and thus saves computing time on unsuccessful seed extensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Notations and definitions</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.1">Suffix array and BWT</head><p>Let ={A,C,G,T } be the alphabet of nucleotides and $ be a symbol that is lexicographically smaller than all the symbols in. Given a nucleotide sequence X = a 1 ...a n−1 with a n−1 = $, let X<ref type="bibr">[i]</ref>=a i be the i-th symbol, X<ref type="bibr">[i, j]</ref>=a i ... a j a subsequence of X and X i = X<ref type="bibr">[i, n−1]</ref>a suffix of X. The suffix array S of X is a permutation of integers 0,...,n−1 such that S(i) = j if and only if X j is the i-th lexicographically smallest suffix. The BWT of X is a permutation of X, where B<ref type="bibr">[i]</ref>=$ if S(i) = 0 and B<ref type="bibr">[i]</ref>=X[S(i)−1] otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.2">Suffix array interval</head><p>Given a sequence W , the suffix array interval or SA interval [R(W ),R(W )] of W is defined as R(W ) = min{k: W is the prefix of X S(k) } R(W ) = max{k: W is the prefix of X S(k) } In particular, if W is an empty string, R(W ) = 1 and R(W ) = n−1. The set of the positions of all the occurrences of W is {S(k) : R(W ) ≤ k ≤ R(W )}. Let C(a) = #{0 ≤ j ≤ n−2 : X<ref type="bibr">[j]</ref>&lt; a} and O(a,i) = #{0 ≤ j ≤ i : B<ref type="bibr">[j]</ref>and that R(aW ) ≤ R(aW ) if and only if aW is a substring of X.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.3">FM-index</head><p>The suffix array S, array C and O suffice for the exact search of a pattern in X. FM-index (<ref type="bibr" target="#b4">Ferragina and Manzini, 2000</ref>) is a compressed representation of the three arrays, consisting of the compressed BWT string B, auxiliary arrays for calculating O, and part of the suffix array S. BWA-SW, however, uses a simplified FM-index where we do not compress B and store part of the occurrence array O without auxiliary data structures. The simplified version is more efficient for DNA sequences with a very small alphabet. Details on the construction are presented in our previous paper (<ref type="bibr" target="#b9">Li and Durbin, 2009</ref>).. Similarly, we can define the 'contained' relationship between alignments (a stronger condition) and between an alignment and a match.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2.4">Alignment</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Prefix trie and prefix DAWG</head><p>The prefix trie of string X is a tree with each edge labeled with a symbol such that the concatenation of symbols on the path from a leaf to the root gives a unique prefix of X. The concatenation of edge symbols from a node to the root is always a substring of X, called the string represented by the node. The SA interval of a node is defined as the SA interval of the string represented by the node. Different nodes may have an identical interval, but recalling the definition of SA interval, we know that the strings represented by these nodes must be the prefixes of the same string and have different lengths. The prefix DAWG, of X is transformed from the prefix trie by collapsing nodes having an identical interval. Thus in the prefix DAWG, nodes and SA intervals have an one-to-one relationship, and a node may represent multiple substrings of X, falling in a sequence where each is a prefix of the next as is discussed in the previous paragraph.<ref type="figure">Figure 1</ref>gives an example.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Aligning prefix trie against prefix DAWG</head><p>We construct a prefix DAWG G(W ) for the query sequence W and a prefix trie T (X) for the reference X. The dynamic programming for calculating the best score between W and X is as follows. Let G uv = I uv = D uv = 0 when u is the root of G(W ) and v the root of T (X). At a node u in G(W ), for each of its parent node u , calculate</p><formula>I uv|u = max{I u v ,G u v −q}−r D uv|u = max{D uv ,G uv −q}−r G uv|u = max{G u v +S(u ,u;v ,v),I u v ,D u v ,0}</formula><p>where v is the parent of v in T (X), function S(u ,u;v ,v) gives the score between the symbol on the edge (u ,u) and the one on (v ,v), and q and r are gap open and gap extension penalties, respectively. G uv , I uv and D uv are calculated with:where pre(u) is the set of parent nodes of u. G uv equals the best score between the (possibly multiple) substrings represented by u and the (one) substring represented by v. We say a node v matches u if G uv &gt; 0. The dynamic programming is performed by traversing both G(W ) and T (X) in the reverse post-order (i.e. all parent nodes are visited before children) in a nested way. Noting that once u does not match v, u does not match any nodes descending from v, we only need to visit the nodes close to the root of T (X) without traversing the entire trie, which greatly reduces the number of iterations in comparison to the standard Smith–Waterman algorithm that always goes through the entire reference sequence.</p><formula>u * = argmax u ∈pre(u) G uv|u (G uv ,I uv ,D uv ) = (G uv|u * ,I uv|u * ,D uv|u * ) G uv|u * &gt; 0</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Acceleration by the standard Smith–Waterman</head><p>In comparison to the standard Smith–Waterman alignment whose time complexity is O(|X|·|W |), BWA-SW has better time complexity since it is no slower than BWT-SW whose time complexity O(|X| 0.628 |W |) (<ref type="bibr" target="#b7">Lam et al., 2008</ref>). This conclusion comes because for short sub-alignments we are considering multiple possible matches with a single uv comparison. However, the constant associated with each iteration is much larger due to the complex steps related to the traversal of prefix trie and prefix DAWG, which makes BWA-SW inefficient when we use BWA-SW to extend a unique alignment. A more efficient strategy would be to use BWA-SW to find partial matches and apply the Smith–Waterman algorithm to extend. In dynamic programming, we know the number of partial matches being considered at any pair because this can be calculated from the size of the SA interval. When G uv is good enough and the SA interval size of v is below a certain threshold (3 by default), we save the (u,v) pair, called a seed interval pair, and do not go deeper from the v node in T (X). By looking up the suffix array of X and W , we can derive seed matches, or simply seeds, from seed interval pairs. These seeds are then extended by the Smith–Waterman algorithm later. If the entire query is a highly repetitive sequence, it will be aligned purely with the algorithm described in the last section without the Smith–Waterman extension. Because we are stopping the dynamic programming early to generate seeds, the global best alignment may contain multiple seeds and in practice this will tend to be the case for long alignments. Typically for 1 kb alignments there will be 10–20 seeds. Below we will take advantage of this observation to heuristically speed up the search. BWT-SW deploys a similar strategy in performing the dynamic programming between a sequence and a prefix trie to find seed matches followed by Smith–Waterman extension. The main difference from our algorithm is that BWT-SW initiates the Smith–Waterman alignment once the score is high enough, regardless of the SA interval size. Sometimes a repetitive sequence may match to thousands of places in the human genome and extending partial matches each time may be slow.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6">Heuristic accelerations</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6.1">Z-best strategy</head><p>The algorithm described so far is exact in that it is able to deliver the same results as the Smith–Waterman algorithm. Although it is much faster than the standard algorithm given a long reference sequence, it is not fast enough for aligning large-scale sequencing data. Closer investigation reveals that even for a unique 500 bp query sequence, a few million nodes in T (X) may match the query with a positive alignment score. The majority of these nodes are random matches or matches in short low-complexity regions. Visiting all of them is wasteful. To accelerate alignment, we traverse G(W ) in the outer loop and T (X) in the inner loop, and at each node u in G(W ) we only keep the top Z best scoring nodes in T (X) that match u, rather than keep all the matching nodes. This heuristic strategy is called Z-best. Of course, when we apply the Z-best strategy, we could miss a seed contained in the true alignment when a false match has a higher score. But if the query is nearly identical to the reference, this happens less often. In addition, if the true alignment is long and contains many seeds, the chance of all seeds being false is very small. On both simulated and real data (Section 3), we find even Z = 1 works well with high-quality 200 bp reads (&lt;5% sequencing error rate). Increasing Z to 10 or higher marginally improves the accuracy but greatly reduces the alignment speed. To reduce alignment errors, we also align the reverse query sequence to the reverse reference sequence, namely reverse–reverse alignment, in addition to the forward–forward alignment. Ideally, the forward–forward and the reverse–reverse alignments should yield identical outcomes, but if a seed in the true alignment has a low-scoring suffix (or prefix), the forward–forward (or reverse–reverse) alignment is likely to miss it, while combining the two rounds of alignment reduces the chance. Moreover, if the best alignment from the forward–forward alignment contains many seed matches, the chance of it being false is also small. In implementation, we do not apply the reverse–reverse alignment if the best alignment contains, by default, 5 or more seeds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.6.2">Filtering seeds before the Smith–Waterman extension</head><p>Like BLAST, both BLAT and SSAHA2 report all significant alignments or typically tens of top-scoring alignments, but this is not the most desired output in read mapping. We are typically more interested in the best alignment or best few alignments, covering each region of the query sequence. For example, suppose a 1000 bp query sequence consists of a 900 bp segment from one chromosome and a 100 bp segment from another chromosome; 400 bp out of the 900 bp segment is a highly repetitive sequence. For BLAST, to know this is a chimeric read we would need to ask it to report all the alignments of the 400 bp repeat, which is costly and wasteful because in general we are not interested in alignments of short repetitive sequences contained in a longer unique sequence. On this example, a useful output would be to report one alignment each for the 900 bp and the 100 bp segment, and to indicate if the two segments have good suboptimal alignments that may render the best alignment unreliable. Such output simplifies downstream analyses and saves time on reconstructing the detailed alignments of the repetitive sequence. In BWA-SW, we say two alignments are distinct if the length of the overlapping region on the query is less than half of the length of the shorter query segment. We aim to find a set of distinct alignments which maximizes the sum of scores of each alignment in the set. This problem can be solved by dynamic programming, but as in our case a read is usually aligned entirely, a greedy approximation would work well. In the practical implementation, we sort the local alignments based on their alignment scores, scan the sorted Page: 592 589–595</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H.Li and R.Durbin</head><p>list from the best one and keep an alignment if it is distinct from all the kept alignments with larger scores; if alignment a 2 is rejected because it is not distinctive from a 1 , we regard a 2 to be a suboptimal alignment to a 1 and use this information to approximate the mapping quality (Section 2.7). Because we only retain alignments largely non-overlapping on the query sequence, we might as well discard seeds that do not contribute to the final alignments. Detecting such seeds can be done with another heuristic before the Smith–Waterman extension and time spent on unnecessary extension can thus be saved. To identify these seeds, we chain seeds that are contained in a band (default band width 50 bp). If on the query sequence a short chain is fully contained in a long chain and the number of seeds in the short chain is below one-tenth of the number of seeds in the long chain, we discard all the seeds in the short chain, based on the observation that the short chain can rarely lead to a better alignment than the long chain in this case. Unlike the Z-best strategy, this heuristic does not have a noticeable effect on alignment accuracy. On 1000 10 kb simulated data, it halves the running time with no reduction in accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.7">Approximating mapping quality</head><p>Li,<ref type="bibr">H. et al. (2008)</ref>introduced the concept of mapping quality to estimate the probability of a query sequence being placed at a wrong position. If an alignment algorithm guarantees to find all local alignments, mapping quality is determined by these local alignments only. However, as BWASW deploys heuristic rules, the chance of producing a wrong alignment is also related to the heuristics. To estimate the mapping quality of a BWA-SW alignment, we fit an empirical formula:</p><formula>250·c 1 ·c 2 ·(S 1 −S 2 )/S 1 ,</formula><p>where S 1 is the score of the best alignment, S 2 the score of the second best alignment, c 1 equals 1 if the alignment covers more than four seeds or 0.5 otherwise, and c 2 equals to 1 if the best alignment is found by both forward–forward and reverse–reverse alignments or 0.2 otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RESULTS</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Implementation</head><p>The BWA-SW algorithm is implemented as a component of the BWA program (<ref type="bibr" target="#b9">Li and Durbin, 2009</ref>), which is distributed under the GNU general public license (GPL). The implementation takes a BWA index and a query FASTA or FASTQ file as input and outputs the alignment in the SAM format (<ref type="bibr" target="#b9">Li et al., 2009</ref>). The query file typically contain many sequences (reads). We process each query sequence in turn, using multiple threads if applicable. Memory usage is dominated by the FM-index, about 3.7 GB for the human genome. Memory required for each query is roughly proportional to the sequence length. On typical sequencing reads, the total memory is &lt;4 GB; on one query sequence with 1 million base pairs (Mbp), the peak memory is 6.4 GB in total. In the implementation, we try to automatically adjust parameters based on the read lengths and sequencing error rates to make the default settings work well for inputs of different characteristics. This behavior is convenient to users who are not familiar with the algorithm and helps performance given the reads of mixed lengths and error rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Evaluation on simulated data</head><p>On simulated data, we know the correct chromosomal coordinates from the alignment and the evaluation is straightforward.<ref type="figure" target="#tab_1">Table 1</ref>shows the CPU time, fraction of confidently aligned reads and alignment error rates for BLAT (v34), BWA-SW (version 0.5.3) and SSAHA2 (version 2.4) given different read lengths and error rates. Unless necessary, we tried to use the default command-line options of each aligner. Fine tuning the options based on the characteristics of the input data may yield better performance. From Table 1, we can see that BWA-SW is clearly the fastest, several times faster than BLAT and SSAHA2 on all inputs, and its speed is not sensitive to the read length or error rates. The accuracy of BWA-SW is comparable with SSAHA2 when the query is long or has low error rate. Given short and error-prone reads, SSAHA2 is more accurate, although it has to spend more time on aligning such reads. SSAHA2 is not tested on the 10 kb reads because it is not designed for this task initially and thus does not perform well. BLAT with the-fastMap option is faster than SSAHA2, but less accurate. Under the default option, BLAT is several to tens of times slower than SSAHA2. The accuracy is higher in comparison toApproximately 10 000 000 bp data of different read lengths and error rates are simulated from the human genome. Twenty percent of errors are indel errors with the indel length drawn from a geometric distribution (density: 0.7·0.3 l−1 ). These simulated reads are aligned back to the human genome with BLAT (option-fastMap), BWA-SW and SSAHA2 (option −454 for 100 and 200 bp reads), respectively. The aligned coordinates are then compared with the simulated coordinates to find alignment errors. In each cell in this table, the three numbers are the CPU seconds on a single-core of an Intel E5420 2.5 GHz CPU, percent alignments with mapping quality greater than or equal to 20 (Q20), and percent wrong alignments out of Q20 alignments. SSAHA2 and BWA-SW report mapping quality; BLAT mapping quality is estimated as 250 times the difference of the best and second best alignment scores divided by the best alignment score (essentially the same calculation as the one for BWA-SW).A total of 137 670 454 reads uniformly selected from SRR003161 were mapped against the human genome with BWA-SW and SSAHA2, respectively. A read is said to be aligned inconsistently if the leftmost coordinates of the BWA-SW and SSAHA2 alignment differs by over 355 bp, the average read length. A score, which equals to the number of matches minus three multiplied by the number of differences (mismatches and gaps) in the aligned region, is calculated for each alignment. A BWA-SW alignment is said to be plausible if the score derived from the BWA-SW alignment minus the one derived from the SSAHA2 alignment of the same read is greater than or equal to 20 (i.e. the BWA-SW alignment is sufficiently better); otherwise the BWA-SW alignment is said to be questionable. Plausible and questionable SSAHA2 alignments are defined in a similar manner. In thethe-fastMap mode, but still lower than that of BWA-SW in general (data not shown). On memory, both BWA-SW and BLAT uses ∼4 GB memory. SSAHA2 uses 2.4 GB for ≥500 bp reads with the default option, and 5.3 GB for shorter reads with the −454 option which increases the number of seed sequences stored in the hash table and increases the memory as a result. In addition, BWA-SW supports multi-threading and thus may take less memory per CPU core if it is run on a multicore computer. SSAHA2 and BLAT do not support multi-threading at present.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Overall performance</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Page: 593 589–595</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Alignment with BWA-SW</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Chimera detection</head><p>We first study the behavior of each aligner given a chimeric read. To do so, we fabricated two chimeric reads with both consisting of one 1000 bp piece from one chromosomal position and one 300 bp piece from another position. The main difference between the two reads is that the 1000 bp piece in the second read has a ∼750 bp repetitive sequence, while the first read is highly unique. When we align the two chimeric reads to the human genome, BWA-SW reports four alignments, one for each piece, as is desired. The latest SSAHA2 fails to find the alignment of the 300 bp pieces in both reads, although it is able to find the alignments if we align the 300 bp piece as an individual read. An older version (1.0.9) is able to align the 300 bp piece in the first read by default, but for the second read, we need to switch to a more thorough but much slower configuration that reports all the hits to the 750 bp repeat. BLAT with-fastMap does not find the alignment of the 300 bp piece for the second read. On the two examples, only BWA-SW has sufficient power to detect chimera. Furthermore, BWA-SW rarely produces high-quality false chimeric alignments. For example, given the 10 000 1 kb reads with 10% errors but without chimera in simulation, BWA-SW predicts 18 chimeric reads. The mapping quality of the wrongly aligned pieces on these reads is only 2.4 (maximum 11), implying that BWA-SW is aware that these chimera are unreliable. As is expected, BWA-SW produces fewer false chimeric reads given lower base errors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Evaluation on real data</head><p>Evaluation on real data is complicated by the lack of a ground truth. However, it is still possible to evaluate the relative accuracy by comparing the results from two aligners using the principle that the true alignment tends to have a considerably higher alignment score, because most errors arise from failing to find a seed. Suppose we align a read using two aligners A and B and get different results. If both A and B give low mapping qualities, the alignment is ambiguous and it does not matter if either alignment is wrong. If A gives high mapping quality and the A alignment score is worse than B, A alignment is probably wrong; even if A alignment score is just a little better than B, A alignment is not reliable and the high mapping quality given by A is still questionable. In practice, defining 'a little better' alignment score requires to set a arbitrary threshold on the score difference and therefore this evaluation method is approximate.<ref type="figure" target="#tab_2">Table 2</ref>gives a summary of 454 reads which are mapped by only one aligner or mapped to different places, and are assigned a mapping quality greater or equal to 20 by either BWA-SW or SSAHA2. We can see that BWA-SW tends to miss short alignments with high error rates (946 of them), which agrees with the evaluation on simulated data. SSAHA2 misses alignments for a different reason. On 1188 reads, SSAHA2 produces obviously wrong alignments. It is aware that these alignments are wrong by assigning low mapping quality, but the true alignments are missed anyway. For both aligners, most wrong alignments are caused by overlooking alignments with a similar score to the best reported alignment. For example, SSAHA2 aligns read SRR003161.1261578 to X chromosome with mapping quality 244 and BWA-SW aligns it to chromosome 2 with identical alignment length and edit distance. The existence of two best scoring alignments means the read cannot be uniquely placed and a mapping quality as high as 244 is inaccurate. SSAHA2 gives this high mapping quality probably because it overlooks the match on chromosome 2. And in this specific example, BWA-SW properly gives a mapping quality zero, although it may overlook alternative matches in other examples. On simulated 100 and 200 bp reads, SSAHA2 with the −454 option delivers better alignments than BWA-SW. On this real dataset, BWA-SW is more accurate possibly because the average read length is relatively long (355 bp).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>To confirm this</head><p>Page: 594 589–595</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>H.Li and R.Durbin</head><p>speculation, we compared the two aligners on 99 958 reads from run SRR002644 with average read length 206 bp. This time BWA-SW misses 1092 SSAHA2 Q20 alignments and produces 39 questionable alignments; SSAHA2 misses 325 and produces 10 questionable ones. SSAHA2 is more accurate on this shorter dataset, although it is nine times slower than BWA-SW and uses 40% more memory.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><figDesc>[16:59 8/2/2010 Bioinformatics-btp698.tex]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><figDesc>&lt; a}, where #{·} calculates the cardinality (or size) of a set. Ferragina and Manzini (2000) proved that R(aW ) = C(a)+O(a,R(W )−1)+1 R(aW ) = C(a)+O(a,R(W ))</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><figDesc>An alignment is a tuple (W 1 ,W 2 ,A) where W 1 and W 2 are two strings and A is a series of copying, substitution, insertion and deletion operations which transform W 2 into W 1. Insertions and deletions are gaps. Gaps and substitutions are differences. The edit distance of the alignment equals the total number of differences in A. A score can be calculated for an alignment given a scoring system. We say W 1 matches W 2 if W 1 and W 2 can be aligned with a positive score, and in this case, we also say (W 1 ,W 2 ) is a match. A match (W 1 ,W 2 ) is said to be contained in (W 1 ,W 2 ) on the first sequence if W 1 is a substring of W 1</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><figDesc>Table 1. Evaluation on simulated data</figDesc><table>Program 
Metrics 
100 bp 
200 bp 
500 bp 
1000 bp 
10 000 bp 

2% 
5% 
10% 
2% 
5% 
10% 
2% 
5% 
10% 
2% 
5% 
10% 
2% 
5% 
10% 

BLAT 
CPU sec 
685 
577 
559 
819 
538 
486 
1078 
699 
512 
1315 
862 
599 
2628 
1742 
710 
Q20% 
68.7 
25.5 
3.0 
92.0 
52.9 
7.8 
97.1 
86.3 
21.4 
97.7 
96.4 
39.0 
98.4 
99.0 
94.0 
errAln% 
0.99 
2.48 
5.47 
0.55 
1.72 
4.55 
0.17 
1.12 
4.41 
0.01 
0.52 
3.98 
0.00 
0.00 
1.28 

BWA-SW 
CPU sec 
165 
125 
84 
222 
168 
118 
249 
172 
152 
234 
168 
150 
158 
134 
120 
Q20% 
85.1 
62.2 
19.8 
93.8 
88.7 
49.7 
96.1 
95.5 
85.1 
96.9 
96.5 
95.0 
98.4 
98.5 
98.1 
errAln% 
0.01 
0.05 
0.17 
0.00 
0.02 
0.13 
0.00 
0.00 
0.04 
0.00 
0.00 
0.00 
0.00 
0.00 
0.00 

SSAHA2 
CPU sec 
4872 
7962 
9345 
1932 
2236 
5252 
3311 
8213 
6863 
1554 
1583 
3113 
– 
– 
– 
Q20% 
85.5 
83.8 
78.2 
93.4 
93.1 
91.9 
96.6 
96.5 
96.1 
97.7 
97.6 
97.4 
– 
– 
– 
errAln% 
0.00 
0.01 
0.19 
0.01 
0.00 
0.01 
0.00 
0.01 
0.04 
0.00 
0.00 
0.00 
– 
– 
– 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><figDesc>Table 2.</figDesc><table>Summary of alignments inconsistent between the BWA-SW and SSAHA2 on real data 

Condition 
Count 
BWA-SW 
SSAHA2 

avgLen 
avgDiff 
avgMapQ 
avgLen 
avgDiff 
avgMapQ 

BWA-SW≥ 20; SSAHA2 unmapped 
0 
– 
– 
– 
– 
– 
– 
BWA-SW≥ 20 plausible; SSAHA2&lt; 20 
1188 
398.2 
1.3% 
178.4 
198.3 
13.1% 
3.9 
BWA-SW≥ 20 questionable 
40 
183.0 
7.8% 
41.2 
280.3 
9.4% 
2.4 

SSAHA2≥ 20; BWA-SW unmapped 
946 
– 
– 
– 
75.4 
6.3% 
51.2 
SSAHA2≥ 20 plausible; BWA-SW&lt; 20 
47 
129.0 
9.3% 
2.5 
200.5 
8.8% 
34.4 
SSAHA2≥ 20 questionable 
185 
400.2 
1.7% 
13.4 
399.2 
2.9% 
216.4 

</table></figure>

			<note place="foot">at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="591"> at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot">and more convenient output. For BWT-SW, end users usually need to post-process the results to filter out many alignments of little interest to them. In all, BWA-SW is tuned toward practical usefulness given large-scale real data. The high speed of BWA-SW largely comes from two strategies: the use of FM-indices and the suppression of short repetitive matches contained in a better match. While the first strategy is not applicable to hash table-based algorithms such as SSAHA2 and BLAT, the second strategy could be implemented in such programs and may substantially accelerate them by saving much time on the construction of repetitive alignments. And although the use of BWT reduces unnecessary alignments in repeats, each BWT operation comes with a large constant in comparison with a hash table look up. It is still possible that hash table-based algorithms could be faster than BWA-SW if they incorporated some of these features.</note>

			<note place="foot" n="595"> at :: on August 31, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGEMENTS</head><p>We are grateful to Zemin Ning for his helpful comments on the SSAHA2 algorithm, and to Kimmo Palin for providing the literature on DAWG.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">DISCUSSION</head><p>BWA-SW is an efficient algorithm for aligning a query sequence of a few hundred base pairs or more against a long reference genome. Its sensitivity and specificity tend to be higher given a long query or a query with low error rate, and on such query sequences, the accuracy of BWA-SW is comparable with the most accurate aligner so far. Furthermore, BWA-SW is able to detect chimera, potentially caused by structural variations or reference misassemblies, which may pose a challenge to BLAT and SSAHA2. BWA-SW, BLAT and SSAHA2 all follow the seed-and-extend paradigm. The major difference comes from the seeding strategy. BLAT and SSAHA2 identify short exact matches as seeds, typically of length 11 or 12 bp. For k-mer seeding between two sequences of length L and l, respectively, the expected number of seeds is L ·l/4 k , or of the order of 10 5 for alignment against the human genome. Extending these seeds each with the Smith–Waterman algorithm is expensive. To reduce unnecessary seed extension, both BLAT and SSAHA2 use non-overlapping seeds by default and require multiple seed matches, which should work well for random sequences, but still involves many seed extensions in highly repetitive regions. BWA-SW resolves this issue by using a few long gapped seeds in unique regions. On real biological data, it saves many unnecessary seed extensions and leads to a better overall performance. However, to reduce time when identifying long seeds, BWA-SW only maintains a very small fraction of the dynamic programming matrix, which may miss all seeds for true matches. This heuristic is the major source of alignment errors especially for short queries when there are only few valid unique seeds between the sequences to be aligned. On long alignments, fortunately, the chance of missing all seeds is small. We have shown BWA-SW works equally well as SSAHA2. BWA-SW differs from BWT-SW in several aspects. First of all, BWT-SW guarantees to find all local matches, whereas BWA-SW is a heuristic algorithm which may miss true hits but is much faster. Secondly, BWA-SW aligns two FM-indices while BWT-SW aligns one sequence and a FM-index. Building a prefix DAWG for the query sequences potentially helps to avoid repeatedly aligning identical substrings in the query, and thus improves the theoretical time complexity. Thirdly, BWA-SW traverses the reference prefix trie in the inner loop while BWT-SW loops through the query sequence in the inner loop. Without heuristics, the BWA-SW approach would hurt performance because we have to trade speed for memory in traversing the reference prefix trie, and it would be more efficient to traverse it in the outer loop. Nonetheless, applying the Z-best strategy requires to know the top-scoring reference nodes matching a query substring without finishing the dynamic programming and thus only works when the reference is traversed in the inner loop. Fourthly, BWA-SW only reports alignments largely non-overlapping on the query sequence, while BWT-SW, like BLAST, reports all statistically significant alignments. BWA-SW retains key information of alignments and generates much smaller</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Gapped BLAST and PSI-BLAST: a new generation of protein database search programs</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">F</forename>
				<surname>Altschul</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nucleic Acids Res</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="3389" to="3402" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">The smallest automaton recognizing the subwords of a text</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Blumer</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theor. Comput. Sci</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="page" from="31" to="55" />
			<date type="published" when="1985" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">A block-sorting lossless data compression algorithm</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Burrows</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Wheeler</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Digital Equipment Corporation</title>
		<meeting><address><addrLine>Palo Alto, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">Real-time DNA sequencing from single polymerase molecules</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Eid</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="volume">323</biblScope>
			<biblScope unit="page" from="133" to="138" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Opportunistic data structures with applications</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Ferragina</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Manzini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 41st Symposium on Foundations of Computer Science</title>
		<meeting>the 41st Symposium on Foundations of Computer Science<address><addrLine>Redondo Beach, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="390" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">SeqMap: mapping massive amount of oligonucleotides to the genome</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">H</forename>
				<surname>Wong</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="2395" to="2396" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">BLAT–the BLAST-like alignment tool</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">J</forename>
				<surname>Kent</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="656" to="664" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">Compressed indexing and local alignment of DNA</title>
		<author>
			<persName>
				<forename type="first">T</forename>
				<forename type="middle">W</forename>
				<surname>Lam</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="791" to="797" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">Ultrafast and memory-efficient alignment of short DNA sequences to the human genome</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Langmead</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page">25</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with BurrowsWheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="1754" to="1760" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">Mapping short DNA sequencing reads and calling variants using mapping quality scores</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="1851" to="1858" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">The Sequence Alignment/Map format and SAMtools</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="2078" to="2079" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">SOAP: short oligonucleotide alignment program</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="713" to="714" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">Zoom! zillions of oligos mapped</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Lin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="2431" to="2437" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">PatternHunter: faster and more sensitive homology search</title>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Ma</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="440" to="445" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">OASIS: an online and accurate technique for local-alignment searches on biological sequences</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<surname>Meek</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 29th International Conference on Very Large Data Bases</title>
		<meeting>29th International Conference on Very Large Data Bases<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="910" to="921" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Database indexing for production megablast searches</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Morgulis</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1757" to="1764" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">SSAHA: a fast search method for large DNA databases</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Ning</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="1725" to="1729" />
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Improved tools for biological sequence comparison</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">R</forename>
				<surname>Pearson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<forename type="middle">J</forename>
				<surname>Lipman</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Natl Acad. Sci. USA</title>
		<meeting>. Natl Acad. Sci. USA</meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="page" from="2444" to="2448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="m">Bioinformatics-btp698.tex] Page</title>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="595" to="589" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">Bwa-Sw</forename>
				<surname>Alignment</surname>
			</persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">SHRiMP: accurate mapping of short color-space reads</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">M</forename>
				<surname>Rumble</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">1000386</biblScope>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Using quality scores and longer reads improves accuracy of Solexa read mapping</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">D</forename>
				<surname>Smith</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page">128</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">RazerS–fast read mapping with sensitivity control</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Weese</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Genome Res</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="page" from="1646" to="1654" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">A greedy algorithm for aligning DNA sequences</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. Comput. Biol</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="203" to="214" />
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>