
<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/joey/Project/grobid/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.4.2-SNAPSHOT" ident="GROBID" when="2017-08-10T23:58+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">H-PoP and H-PoPG: Heuristic Partitioning Algorithms for Single Individual Haplotyping of Polyploids</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName>
								<forename type="first">Minzhu</forename>
								<surname>Xie</surname>
							</persName>
							<email>xieminzhu@hotmail.com</email>
							<affiliation key="aff0">
								<orgName type="department">College of Physics and Information Science</orgName>
								<orgName type="laboratory">Key Laboratory of Internet of Things Technologies and Application</orgName>
								<orgName type="institution">Hunan Normal University</orgName>
								<address>
									<postCode>410081</postCode>
									<settlement>Changsha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Qiong</forename>
								<surname>Wu</surname>
							</persName>
							<affiliation key="aff1">
								<orgName type="department">Institute of Botany</orgName>
								<orgName type="laboratory">State Key Laboratory of Systematic and Evolutionary Botany</orgName>
								<orgName type="institution">Chinese Academy of Sciences</orgName>
								<address>
									<postCode>100093</postCode>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Jianxin</forename>
								<surname>Wang</surname>
							</persName>
							<affiliation key="aff2">
								<orgName type="department">School of Information Science and Engineering</orgName>
								<orgName type="institution">Central South University</orgName>
								<address>
									<postCode>410083</postCode>
									<settlement>Changsha</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Tao</forename>
								<surname>Jiang</surname>
							</persName>
							<affiliation key="aff3">
								<orgName type="department" key="dep1">Department of Computer Science and Engineering</orgName>
								<orgName type="department" key="dep2">TNLIST / Department of Computer Science and Technology</orgName>
								<orgName type="laboratory">Key Lab of Bioinformatics and Bioinformatics Division</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>92521</postCode>
									<settlement>Riverside</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
							<affiliation key="aff4">
								<orgName type="institution">Tsinghua University</orgName>
								<address>
									<settlement>Beijing</settlement>
									<country key="CN">China</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName>
								<forename type="first">Moe</forename>
							</persName>
						</author>
						<title level="a" type="main">H-PoP and H-PoPG: Heuristic Partitioning Algorithms for Single Individual Haplotyping of Polyploids</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note>Genome analysis * To whom correspondence should be addressed. Supplementary information: Supplementary data are available at Bioinformatics online. * to whom correspondence should be addressed</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Motivation: Some economically important plants including wheat and cotton have more than two copies of each chromosome. With the decreasing cost and increasing read length of next-generation sequencing technologies, reconstructing the multiple haplotypes of a polyploid genome from its sequence reads becomes practical. However, the computational challenge in polyploid haplotyping is much greater than that in diploid haplotyping, and there are few related methods. Results: This paper models the polyploid haplotyping problem as an optimal poly-partition problem of the reads, called the Polyploid Balanced Optimal Partition (PBOP) model. For the reads sequenced from a k-ploid genome, the model tries to divide the reads into k groups such that the difference between the reads of the same group is minimized while the difference between the reads of different groups is maximized. When the genotype information is available, the model is extended to the Polyploid Balanced Optimal Partition with Genotype constraint (PBOPG) problem. These models are all NP-hard. We propose two heuristic algorithms, H-PoP and H-PoPG, based on dynamic programming and a strategy of limiting the number of intermediate solutions at each iteration, to solve the two models, respectively. Extensive experimental results on simulated and real data show that our algorithms can solve the models effectively, and are much faster and more accurate than the recent state-of-the-art polyploid haplotyping algorithms. The experiments also show that our algorithms can deal with long reads and deep read coverage effectively and accurately. Furthermore, H-PoP might be applied to help determine the ploidy of an organism. Availability: https://github.com/MinzhuXie/H-PoPG Contact:</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Methods</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Formulation and Problem</head><p>The input of the polyploid haplotyping problem consists of aligned DNA reads sequenced from a k-ploid organism. In our approach, we try to divide the reads into k different groups according to their original haplotypes. Since it is trivial to determine the alleles of the k-haplotypes at homozygous loci, and only loci where the reads have different alleles can be used to partition the reads into different groups, we will only keep alleles of the aligned reads on heterozygous SNP loci. The input aligned reads are denoted by an m × n SNP matrix M as in previous work (<ref type="bibr" target="#b28">Xie et al., 2008</ref><ref type="bibr" target="#b31">Xie et al., , 2012</ref><ref type="bibr" target="#b0">Aguiar and Istrail, 2013;</ref><ref type="bibr" target="#b2">Berger et al., 2014</ref>), where m is the number of reads and n the number of heterozygous SNP loci. M<ref type="bibr">[i, j]</ref>, the entry of M at the ith row and jth column, encodes the allele of the ith read at the jth heterozygous SNP loci. M<ref type="bibr">[i, j]</ref>takes a value from {0, 1, −}, where '0' (or '1') represents the major allele (or the minor allele, respectively) at the locus in the population and '−' represents an unknown allele. The ith row (read) of M is denoted as r i and the jth allele of r is denoted as r<ref type="bibr">[j]</ref>. Similarly, a haplotype is denoted as a sequence of '0', '1' and '−', and the jth allele of a haplotype H is denoted as H<ref type="bibr">[j]</ref>. For two alleles a 1 , a 2 ∈ {0, 1, −}, we define a similarity function</p><formula>s(a 1 , a 2 ) and dissimilarity function d(a 1 , a 2 ) as follows: s(a 1 , a 2 ) = { 1, if a 1 , a 2 ̸ = − and a 1 = a 2 ; 0, otherwise.</formula><formula>(1) d(a 1 , a 2 ) = { 1, if a 1 , a 2 ̸ = − and a 1 ̸ = a 2 ; 0, otherwise. (2)</formula><p>Given a set R = {r 1 , ..., rp} of p rows (reads), a k-partition function P of R is defined as a map P : {1, ..., p} → {1, ..., k}, which means that r i is put into the P (i)th group (subset) G P (i) according to the function P. Since every row in R has a unique index, the row with the smallest index in a group is called the representative row of the group, and the smallest index of the rows in a group G is denoted by I(G). If G = ∅, let I(G) = p + 1. Let the groups obtained by applying P on R be G P 1 , ..., G P k. A k-partition function P is called a canonical k-partition function if the following condition holds: for any two groups</p><formula>G P i and G P j with 1 ≤ i &lt; j ≤ k, I(G P i ) &lt; I(G P j ).</formula><p>The consensus haplotype H i of the ith group G i is defined as the haplotype that maximizes the sum of similarities between the reads in the group G i and the haplotype, i.e.<ref type="bibr">[j]</ref>, H<ref type="bibr">[j]</ref>).</p><formula>H i = argmax H ∑ r∈G i n ∑ j=1 s(r</formula><formula>(3)</formula><p>Assume that the consensus haplotypes are the original haplotypes, and the difference between the consensus haplotypes and the reads can be regarded as sequencing errors. Given a k-partition function P on a set of reads (rows), the corrected error measure C(P ) is defined as the total difference between the reads and the consensus haplotypes of their groups,</p><formula>i.e. C(P ) = k ∑ i=1 ∑ r∈G i n ∑ j=1 d(r[j], H i [j]).</formula><formula>(4)</formula><p>Since we only consider heterozygous loci, any two of the k haplotypes should not be identical when several consecutive heterozygous loci are considered together, and it is desirable that the k consensus haplotypes are distinctively different. We introduce another measure D(P ) as follows, which is called the diversity measure:</p><formula>D(P ) = ∑ i 1 ,i 2 =1,...,k;i 1 ̸ =i 2   n ∑ j=1 d(H i 1 [j], H i 2 [j])   .</formula><formula>(5)</formula><p>We would like to find an ideal partition P that makes the difference between the reads of a same group minimized and the difference between the reads of different groups maximized, i.e. one that minimizes C(P ) and maximizes D(P ). However, this may be impossible in most cases, since a partition function P minimizing C(P ) may not ensure that D(P ) is maximized and vice versa. Therefore, we combine both measures into a weighted partition score:</p><formula>s(P ) = (1 − w)D(P ) − wC(P ),</formula><formula>(6)</formula><p>where w is a weighting parameter with 0 ≤ w ≤ 1. In the following, we propose a new optimization model for the polyploid haplotyping problem. Polyploid Balanced Optimal Partition (PBOP): Given an SNP matrix M and weight w, find a k-partition function P of the rows in M such that</p><formula>s(P ) = (1 − w)D(P ) − wC(P )</formula><p>is maximized. Note that when w = 1 and k = 2, PBOP becomes the MEC model for the diploid haplotype assembly problem. MEC is known to be NPhard (<ref type="bibr" target="#b20">Lippert et al., 2002</ref>). In fact, it has been recently shown not to be in APX under the Unique Games Conjecture (<ref type="bibr" target="#b3">Bonizzoni et al., 2015</ref>). Therefore, PBOP is also NP-hard, and not in APX under the Unique Games Conjecture. In the next subsection, we introduce a heuristic algorithm called H-PoP. When the genotype G of the polyploid is known, we will also consider the genotype constrained version of PBOP. Since we do not consider homozygous loci, for each locus j, G<ref type="bibr">[j]</ref>∈ {1, ..., k − 1}. G<ref type="bibr">[j]</ref>= t means that at the jth locus, there are t haplotypes taking the allele '1' and the other k − t haplotypes taking the allele '0'. Let I i (x) be an indicator function, i.e. I i (x) = 1 if x = i; otherwise 0. Given a k-partition function P on a set of rows R = {r 1 , ..., rp}, the consensus haplotypes H ′ 1 , ..., H ′ k with genotype constraint G are the haplotypes that satisfy the following conditions: (i) H ′ i<ref type="bibr">[j]</ref>= − when there are no reads in group G i covering the jth locus (i.e. the alleles at locus j of the reads in group G i are all unknown), (ii)</p><formula>∑ k i=1 I 1 (H ′ i [j]) ≤ G[j], ∑ k i=1 I 0 (H ′ i [j]</formula><p>) ≤ k − G<ref type="bibr">[j]</ref>for each locus j ∈ {1, ..., n} and (iii)</p><formula>∑ k i=1 ∑ r∈G i</formula><p>∑ n j=1 s(r<ref type="bibr">[j]</ref>, H ′ i<ref type="bibr">[j]</ref>) is maximized.</p><p>The genotype constrained corrected error measure C ′ (P ) and partition score s ′ (P ) are defined as:</p><formula>C ′ (P ) = k ∑ i=1 ∑ r∈G i n ∑ j=1 d(r[j], H ′ i [j]).</formula><formula>(7)</formula><p>Similarly, the genotype constrained diversity measure D ′ (P ) and partition score s ′ (P ) are defined as follows:</p><formula>D ′ (P ) = ∑ i 1 ,i 2 =1,...,k;i 1 ̸ =i 2   n ∑ j=1 d(H ′ i 1 [j], H ′ i 2 [j])   ; (8) s ′ (P ) = (1 − w)D ′ (P ) − wC ′ (P ).</formula><formula>(9)</formula><p>Polyploid Balanced Optimal Partition with Genotype constraint (PBOPG): Given an SNP matrix M , the genotype G of the polyploid and weight w, find a k-partition function P of the rows in M such that</p><formula>s ′ (P ) = (1 − w)D ′ (P ) − wC ′ (P )</formula><p>is maximized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Algorithm</head><p>Given an m × n SNP matrix M , the number of ways to partition m different rows r 1 , ..., rm into k non-empty groups is a Stirling number of the second kind, which is denoted as S(m, k).</p><formula>Since S(m, k) = 1 k! ∑ k i=0 (−1) i ( k i ) (k − i) m ,</formula><p>when m is large, it is impractical to enumerate all possible partitions and choose one with the maximum partition score. To solve the PBOP model of M efficiently, we propose a heuristic dynamic programming algorithm in the subsection. In other words, we will consider solutions for a number of rows of M then extend the solutions to the next row, and so on until all rows of M have been considered. We first introduce some definitions and notations similar to those in (<ref type="bibr" target="#b31">Xie et al., 2012</ref>), but some of which have different meanings. Let b(i) (e(i)) denote the first (the last) column at which the ith row of M takes non-'−' values. If and only if b(i) ≤ j ≤ e(i), row i spans column j. R(j) denotes the set of rows that contain the rows in M spanning the jth column. In the following, we assume that M has been sorted such that for two</p><formula>rows i 1 and i 2 of M with i 1 &lt; i 2 , b(i 1 ) &lt; b(i 2 ), or b(i 1 ) = b(i 2 ) and e(i 1 ) ≤ e(i 2</formula><p>). Let P be a canonical k-partition function on a set of rows R and P ′ a canonical k-partition function on a subset R ′ of R. If for any two rows</p><formula>i, j ∈ R ′ , P ′ (i) = P ′ (j)</formula><p>if and only if P (i) = P (j), P ′ is called the projection of P on R ′ and P an extension of P ′ on R. It is easy to verify that given a partition P of R and a subset R ′ , the projection of P on R ′ is unique, but not vice verse. The projection of P on R ′ is denoted by P<ref type="bibr">[R ′ ]</ref>for convenience. Let P be a canonical k-partition function of the subset R = { r i 1 , ..., r iq } of the rows of M with iq as the largest row index in R,</p><formula>and R ′ = {r 1 , ..., r iq } (i.e.</formula><p>the set of all rows from the first row to row r iq ). P ′ is an optimal extension of P if the following conditions hold: (i) P ′ is an extension of P on R ′ and (ii) for any possible extension P ′′ of</p><formula>P on R ′ , s(P ′ ) ≥ s(P ′′ ).</formula><p>Similarly, when the genotype G is available, P ′ is a genotype constrained optimal extension of P if the following conditions hold: (i) P ′ is an extension of P on R ′ and (ii) for any possible extension P ′′ of</p><formula>P on R ′ , s ′ (P ′ ) ≥ s ′ (P ′′ ). Given a partition P of R, let E(P )</formula><p>denote an optimal extension of P and E ′ (P ) a genotype constrained optimal extension of P. We call</p><formula>s(E(P )) (or s ′ (E ′ (P )</formula><p>)) the global (or the genotype constrained global)score of P and denote it as se(</p><formula>1 S(3, 3) P(1..4) = 1 P(1..3) = 1 P(1..2) = 1 P(1..2) = 1..2 2 P(4) = 2 P(3) = 3 P(1..3) = 1..3 1 2 1 2 2</formula><formula>P ) (or s ′ e (P )</formula><p>, respectively) for convenience. The following theorem is straightforward.</p><formula>of R(n), se(P ) ≥ se(P ′ ) (or s ′ e (P ) ≥ s ′ e (P ′ ), respectively).</formula><p>We consider the set of canonical k-partition functions that partition a set of i rows into at most k groups, and denote the function set as F(i, k). Let S(p, q) denote the set of canonical functions that partition p rows into q non-empty groups. It is obvious that F(i, k) = ∪ q=1..t S(i, q), where t is the maximum of i and k. Let p and q be positive integers. To enumerate all canonical functions that partition p rows into q non-empty groups, we consider the following cases: @BULLET p &lt; q: Such functions do not exist, i.e. S(p, q) = ∅. @BULLET p = q:It is easy to verify that S(p, q) contains only one partition function, i.e. P (i) = i for i = 1 to p (denoted by P (1..p) = 1..p). @BULLET p &gt; q: If q = 1, there is only one partition function in S(p, q), i.e. P (i) = 1 for i = 1 to p (denoted by P (1..p) = 1). If q &gt; 1, we may construct S(p, q) using the following recursive process. Considering the last row p, the group containing row p either has only one row, i.e. row p, or two or more rows. We denote the set of partition functions that put row p into a group by itself (labeled as group q) and partition the first p−1 rows into the other q −1 non-empty groups as</p><formula>{(P (p) = q) · S(p − 1, q − 1</formula><p>)}, and denote the the set of partition functions that partition the first p − 1 rows into q non-empty groups and put row p into one of the q groups as {(</p><formula>P (p) = 1, ..., q) · S(p − 1, q)}</formula><p>. Then, we have the following recurrence:</p><formula>S(p, q) = {(P (p) = q) · S(p − 1, q − 1)} ∪ {(P (p) = 1, ..., q) · S(p − 1, q)}.</formula><p>Figure 2 illustrates F(4, 3), the set of all 15 different functions partitioning 4 rows into at most 3 groups. In the graph, the values S(p, q) with p = q or q = 1 are represented as the leaf nodes and a partition function is represented by a path from the root node to a leaf node. Please note that there may be more than one path from the root to a leaf node. For example, there are three different paths from the root F(4, 3) to the node S(3, 3), corresponding to three different functions:</p><formula>(i) P (4) = 1, P (1..3) = 1..3, (ii) P (4) = 2, P (1..3) = 1..3 and (iii) P (4) = 3, P (1..3) = 1..3.</formula><p>Given an m × n SNP matrix M , our algorithm considers the set R(1) of rows spanning column 1 first. To make the algorithm scalable, we will be able to enumerate all the partition functions on a small number of rows. Let q be the maximum integer such that | F(q, k) |≤ 1000 and q ≤| R(1) |. Let R f be the set of the first q rows in R(1) and R b contain the rest of the rows in R(1). When R(1) contains no more than q rows, R f = R(1) and R b = ∅. Since the number of rows in R f is at most q and | F(q, k) |≤ 1000, it is practical to enumerate all partition functions of R f by the above method. For each group G obtained by partitioning R f according to some function P , let b(G) = min r∈G b(r) and e(G) = max r∈G e(r). We use a 2 × n matrix to record a profile P(G) for G, where the element P(G)<ref type="bibr">[v, j]</ref>counts the number of rows of G whose values at column j is v for v = 0, 1 and j = b(G), ..., e(G). The set of the profiles for all groups incurred by P is denoted as P P. Based on P(G), we obtain a consensus haplotype H G of G easily:</p><formula>H G [j] =      0, if P(G)[0, j] &gt; P(G)[1, j] 1, if P(G)[0, j] &lt; P(G)[1, j] −, otherwise for j = b(G), ..., e(G).</formula><p>(10) Using equations (4)-(6) and (10), the score s(P ) of a k−partition function P on R f can be calculated in time O(lm</p><formula>(q + k 2 )), where lm = max i∈R f e(i) − min i∈R f b(i) + 1. Recall</formula><p>that at the very beginning of the algorithm, R f = {r 1 , ..., rq}, and both the optimal extension and the genotype constrained optimal extension of a partition function P of R f are P itself,</p><formula>i.e. E(P ) = P and E ′ (P ) = P. Therefore, se(P ) = s(P ) and s ′ e (P ) = s ′ (P ).</formula><p>For an optimal partition function P of the set of the rows in M , the projection of P on R f is likely a suboptimal partition function of R f. In the following extension from R f to rows in R b , we will only consider the top 10k 2 partition functions of R f , which is denoted by F , based on empirical experience. If R b is not empty, let r be the row with the smallest index in R b and R ′ f = R f ∪ {r}. We construct all possible extensions of the functions in F to R ′ f and record (at most) 10k 2 extensions with the highest global scores in F ′. For a partition function P on R f , there are at most k extensions of P on R ′ f. Let the number of rows in R f be q f and g = max i=1..q f P (i), i.e. P partitions the q f rows of R f into g nonempty groups G 1 , ..., Gg. Since the row r can be put into any one of the g groups, there are at least</p><formula>g extensions P ′ 1 , ..., P ′ g of P on R ′ f .</formula><p>When g &lt; k, r can be put into a new group and hence there is an additional extension</p><formula>P ′ g+1 of P. For each extension P ′ t , P ′ t (i) = { P (i), 1 ≤ i ≤ q f ; t, i = q f + 1.</formula><formula>(11)</formula><p>Let the nonempty groups obtained by applying</p><formula>P ′ t on R ′ f be G ′ 1 , ..., G ′ g ′ .</formula><p>Since the difference ∆s between the global scores of P ′ t and P is due to putting r in G ′ t , it is easy to compute by considering two cases below.</p><formula>@BULLET t ≤ g: In this case, g ′ = g. For i = 1, ..., g except i = t, G ′ i = G i , P(G ′ i ) = P(G i ) and H G ′ i = H G i. Moreover, G ′ t = Gt ∪ {r}, P(G ′ t )[v, j] = P(Gt)[v, j] + Ir[v, j] for v = 0, 1 and j = b(G ′ t ), ..., e(G ′ t ),</formula><p>where Ir<ref type="bibr">[v, j]</ref>= 1 when r takes value v at column j; otherwise Ir<ref type="bibr">[v, j]</ref>= 0. Use Equation (10) to compute</p><formula>H G ′ t . Let the set of columns where H G t ̸ = H G ′ t be C. Then ∆C = ∑ j∈C | P(Gt)[0, j] − P(Gt)[1, j] | + e(r) ∑ j=b(r) d(H G ′ t [j], r[j])</formula><formula>∆D = ∑ j∈C ∑ i̸ =t ( d(H G ′ t [j], H G i [j]) − d(H Gt [j], H G i [j]) ) ∆s = (1 − w)∆D − w∆C (12)</formula><p>@BULLET t &gt; g: In this case, g &lt; k and g ′ = t = g + 1. For i = 1, ..., g,</p><formula>G ′ i = G i , P(G ′ i ) = P(G i ) and H G ′ i = H G i. Moreover, G ′ t = {r}, P(G ′ t )[v, j]</formula><p>= Ir<ref type="bibr">[v, j]</ref>for v = 0, 1 and j = b(r), .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.., e(r),</head><p>where Ir<ref type="bibr">[v, j]</ref>= 1 when r takes value v at column j; otherwise Ir<ref type="bibr">[v, j]</ref>= 0.</p><formula>H G ′ t</formula><p>can be obtained easily using Equation (10). Then</p><formula>∆s = (1 − w)∆D = (1 − w) e(r) ∑ j=b(r) g ∑ i=1 ( d(H G ′ t [j], H G i [j])</formula><p>)</p><formula>(13)</formula><p>The global score of</p><formula>P ′ t is se(P ′ t ) = se(P ) + ∆s,</formula><formula>(14)</formula><p>which can be calculated in time O(lk),</p><formula>where l = e(r) − b(r) + 1.</formula><formula>F = F ′ , R f = R f ∪ {r} and R b = R b − {r}.</formula><p>The above process is repeated until R b becomes empty and R f = R(1). After obtaining the top 10k 2 partition functions of R(j) for some j, which are again stored in F , we consider the next column j</p><formula>+ 1. Let R d = R(j) − R(j + 1), Rr = R(j) ∩ R(j + 1) and R b = R(j + 1) − R(j).</formula><p>We first compute the projections of the functions in F on Rr, and then extend them to R(j + 1). Let F ′ be the set of the projections of all functions in F on Rr. It is obvious that | F ′ |≤| F |. For a function P in F , we can easily compute its projection P ′ on Rr.</p><formula>If R d = ∅, i.e. Rr = R(j), then P ′ = P and F ′ = F ;</formula><p>otherwise, we compute its projection P ′ as follows. Let the rows in Rr be r i 1 , r i 2 , .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.., and r iz , and P ′′ be such a partition function of Rr</head><formula>that P ′′ (r i ) = P (r i ) for i = i 1 , .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.., iz. Suppose that P ′′ partitions Rr into t non-empty groups G ′′</head><p>1 , .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>.., G ′′</head><p>t. Sort these groups by their representative row indices in the ascending order and let rank(g) be the rank of G ′′ g in the sorted groups, i.e. if the representative row index of G ′′ g is the p smallest then rank(g) = p.</p><formula>Set P ′ (r i ) = rank(P ′′ (r i )) for i = i 1 , ...</formula><p>, iz, and then P ′ is the projection of P on Rr. For each function P ′ in F ′ , we can calculate its global score se(P ′ ) using the equation below:</p><formula>se(P ′ ) = max P ∈F and P ′ is a projection of P se(P ).</formula><formula>(15)</formula><p>The time complexity of computing F ′ and the scores is</p><formula>O(|F |(k log k + |R(j)|)). Once F ′ and</formula><p>the corresponding scores have been computed, set</p><formula>F = F ′ and R f = Rr</formula><p>, and extend the functions in F to R(j + 1) by deleting a row from R b and adding it to R f , one at a time, until R f = R(j + 1) as done above by using Equation (11). The above iteration continues until R(j) contains the last row of M. Finally, an extension of the function in F with the highest global score is output as a solution to the PBOP problem of M. A pseudo code for this algorithm, called H-PoP, is presented at<ref type="figure">Figure S1</ref>in the Supplementary Materials. For the PBOPG model, a similar heuristic algorithm H-PoPG can be easily devised. All we need is a simple modification of H-PoP to make use of the provided genotype information. Please see the Supplementary Materials for the details of H-PoPG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Results</head><p>We use both real data and simulated data to compare the performance of our algorithms H-PoP, H-PoPG and three recent single individual polyplotyping algorithms HapCompass (<ref type="bibr" target="#b0">Aguiar and Istrail, 2013</ref>), HapTree (<ref type="bibr" target="#b2">Berger et al., 2014</ref>) and SDhaP (<ref type="bibr" target="#b8">Das and Vikalo, 2015</ref>). Besides aligned SNP reads, all algorithms except H-PoP and SDhaP require genotype information as an additional input. The weight w is set as 0.9 for H-PoP and H-PoPG unless otherwise specified. All tests are conducted on some 64 bit nodes with 2.6GHz CPU and 128GB RAM of a Linux cluster, and each result on simulated data is the average of 100 repeated tests with the same parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Results on Real Data</head><p>Using 454 GS FLX Titanium sequencing, Curtin et al. (<ref type="bibr" target="#b7">Curtin et al., 2012</ref>) obtained a 12.7 Mb assembly of AWRI1499, a prevalent wine spoilage strain of the yeast species Dekkera bruxellensis. The assembly is comprised of 324 contigs (N50 = 68 kb) in 99 scaffolds, at median read coverage of 26-fold and it was found that AWRI1499 is a triploid (<ref type="bibr" target="#b7">Curtin et al., 2012</ref>). We downloaded the read data from the SRA database of NCBI under the accessions SRX327045 and SRX327033, and the 14 contigs of the first scaffold from the Assembly database of NCBI under the accession AHIQ01. After cleaning adapters and low quality bases from the reads, BWA-MEM () was used to align the reads against the contigs with default parameters, and the SAMtools package (<ref type="bibr" target="#b16">Li, 2011a</ref>,b) was used to call SNPs based on the aligned reads. The genotype of an SNP locus is determined by the proportion of the alleles 0 and 1 on the locus. Keeping only alleles at the heterozygous SNP loci of the aligned reads, we obtained 14 SNP matrices, one for each contig. We tested H-PoPG, H-PoP, HapTree, HapCompass and SDhaP on these real data. AWRI1499 is a triploid, but its three true haplotypes are unavailable. Instead, there are only consensus contigs. Since the true haplotypes are unknown, we use the MEC score (<ref type="bibr" target="#b20">Lippert et al., 2002</ref>) to evaluate the accuracy of the reconstructed haplotypes. More precisely, given an m × n SNP matrix M , let the reconstructed k haplotypes be H = (H 1 ,..., H k ). The MEC score sc(H, M ) is the minimum number of sequencing errors in the SNP matrix if H is considered as the true haplotypes. That is,</p><formula>sc(H, M ) = ∑ i=1,...,m min p=1,..,k ( ∑ j=1</formula><p>,...,n d(M<ref type="bibr">[i, j]</ref>, Hp<ref type="bibr">[j]</ref>) ) ,</p><formula>(16)</formula><p>where d(., .) is the dissimilarity function given in Equation 2. The MEC rate ec(H, M ) is the minimum sequencing error rate of the corresponding DNA reads at the SNP loci if H is considered as the true haplotypes, i.e. ec(H, M ) = sc(H, M )/ the number of non-'-' elements of M. The detailed test results on all 14 individual contigs are given in Tables S1-S14 of the Supplementary Materials. H-PoPG, H-PoP, HapCompass and SDhaP were able to reconstruct the haplotypes from the SNP matrices for all contigs, but the performance of HapCompass was clearly inferior to the other algorithms. H-PoPG and HapTree achieved similar MEC rates. Without the genotype constraint, SDhaP had less MEC rates while H-PoP obtained the least MEC rates. However, HapTree aborted with run-time errors on the data of contigs 6, 8, 15, 17, and 21, and failed to terminate in seven days on the data of contig 19. The SNP matrices of contigs 6, 8, 15, 17, 19 and 21 consist of 64223 rows and 12226 columns (i.e. SNPs).<ref type="figure" target="#tab_2">Table 2</ref>shows that when regarding AWRI1499 as a diploid (i.e. set k = 2), the MEC rate of H-PoP was 4.33%, which is much larger than the raw single base sequencing error rate of 2.23% shown in the Supplementary<ref type="figure" target="#fig_8">Figure 8</ref>of<ref type="bibr" target="#b21">Margulies et al. (2005)</ref>. This suggests that we could perhaps use H-PoP to help determine the ploidy of an organism by trying different k and comparing the MEC rate and DNA sequencing error rate. When regarding AWRI1499 a triploid, without applying the genotype constraint, the MEC rate 0.43% achieved by H-PoP was the least, about a half of that of SDhaP. With the genotype constraint, the MEC rate 1.28 of H-PoPG was a little better than that of HapTree. The MEC rate 3.25 of HapCompass was the largest, which suggests that the reconstructed haplotypes of HapCompass may be inaccurate. The phased SNPs of HapTree, HapCompass and SDhaP are 4096, while two of these SNPs were not phased by H-PoPG since it does not perform phasing at loci that are not covered by reads in the corresponding groups. As for running time, H-PoP and H-PoPG were more than 40 times faster than HapTree, HapCompass and SDhaP. The maximum run-time (resident) memory used by HapCompass and SDhap was more than 20GB, while the other algorithms needed only less than 3GB memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Results on Simulated Data</head><p>We generated aligned SNP reads of a polyploid genome as follows. First, k genomes were generated based on the real contigs and VCF files of AWRI1499. Given a contig as the haplotype template and a corresponding VCF file, we generated k copies of the contig as the initial k genomes. For each heterozygous SNP in the VCF file, a genotype g (the number of alternative alleles) of the SNP was generated randomly following a uniform distribution from 1 to k − 1. Then g genomes were randomly selected from the k genomes and their alleles at the SNP locus were set as the alternative alleles, while the other genomes were set as the reference alleles. The generated k genomes were saved in a FASTA format file named k-ploid.fa. Second, we used ART (<ref type="bibr" target="#b13">Huang et al., 2012</ref>), a next-generation sequencing read simulator, to generate simulated reads from the the k genomes. To simulate the real data of AWRI1499, we ran ART with the 454 GS FLX Titanium platform profile that came with the simulator to generate single-end reads and paired-end reads. ART requires a parameter, the coverage c of each haplotype, to generate single-end reads, and three parameters, the coverage c of each haplotype, the mean insert length f and the standard deviation σ of insert length, to generate paired-end reads. In the following tests without explicit specification, f was set as 800 and σ was set as 150 according to the distribution of the reads in the real data. The single-end and paired-end reads in the same dataset were generated by ART with the same coverage parameter. Correct phasing rate (Rc), and perfect solution rate (Rp) will be used to measure the phasing accuracy of the k haplotypes reconstructed by an algorithm. When the genotype of the reconstructed haplotypes equals to the original genotype, another measure vector error rate (Rv) (<ref type="bibr" target="#b2">Berger et al., 2014</ref>) is used too. Let the set of k haplotypes reconstructed by an algorithm be H = {H 1 , H 2 , ..., H k } and the set of true haplotypes be</p><formula>H * = {H * 1 , H * 2 , ..., H * k }. Let H</formula><p>be a one-to-one mapping from H to</p><formula>H * . Define M (H) = ∑ k i=1 ∑ n j=1 s(H i [j], H(H i )[j]</formula><p>), where s is the similarity function given in Equation (1). The correct phasing rate Rc is defined as follows:</p><formula>Rc(H) = max H M (H)/nk,</formula><p>where n is the number of phased SNPs. For the example, in<ref type="figure" target="#fig_2">Figure 3</ref>, the correct phasing rate Rc(H) = 10/12. The perfect solution rate is Rp = nc/k, where nc is the number of haplotypes correctly reconstructed (i.e. they are exactly the same as the true ones) by the algorithm. For example, the perfect solution rate of H in<ref type="figure" target="#fig_2">Figure 3</ref>is 1/3. The vector error measure is a generalization of the switch error measure for diploid haplotype assembly to polyploid phasing. The vector errors in k reconstructed haplotypes are defined in (<ref type="bibr" target="#b2">Berger et al., 2014</ref>) as the minimum number of segments on all chromosomes for which a switch must occur. To make it easy to understand, we give another equivalent definition of the measure here. A one-to-one mapping H from H to H * is called a matching at locus j if</p><formula>∑ k i=1 d(H i [j], H(H i )[j]) = 0. The distance d(H 1 , H 2 ) between two mappings H 1 and H 2 is defined as ∑ k i=1 I(H 1 (H i ) ̸ = H 2 (H i )</formula><p>), where I is an indicator function (i.e. I(a) = 1 if a is a true statement and I(a) = 0 otherwise). When the genotypes of H and H * are equal, there exist a series of one-to-one mappings M = {H 1 , ..., Hn} such that H j is a matching at locus j for j = 1, ..., n, and such a sequence is called a matching sequence. For a matching sequence M, the total number of changes between adjacent matchings is Tc(</p><formula>M) = ∑ n−1 j=1 d(H j , H j+1 ).</formula><p>The number of vector errors ev in H against H * are defined as:</p><formula>ev(H) = min M is a matching sequence Tc(M).</formula><p>The number of vector errors ev can be calculated by a dynamic programming algorithm in time</p><formula>O(n(k − 1)! 2 )</formula><p>, which is faster than the method used in (<ref type="bibr" target="#b2">Berger et al., 2014</ref>) with time complexity O(kn 2 ), when k is small and n is big. Please see<ref type="figure" target="#fig_2">Figure S3</ref>of the Supplementary Materials for the the pseudocode of the dynamic programming algorithm. The vector error rate Rv is defined as ev/n. For example, in<ref type="figure" target="#fig_2">Figure  3</ref>, there is a matching sequence</p><formula>M = {H 1 , H 2 , H 3 , H 4 }, where H 1 = {H 1 → H * 2 , H 2 → H * 1 , H 3 → H * 3 } and H 2 = H 3 = H 4 = {H 1 → H * 3 , H 2 → H * 1 , H 3 → H * 2 }.</formula><p>It is easy to see that Tc(M) = 2, the number of vector errors in H is 2 and the vector error rate Rv = 2/4 = 0.5. To choose an appropriate weight w for H-PoPG, we tested its performance with different w from 0.8 to 1.0, and compared it with HapTree and HapCompass. We used the first contig of AWRI1499 as the haplotype template and ran ART with c = 2 to generate 100 triploid read data sets (each consisting of a set of single-end reads and a set of paired-end reads). After alignment to the contig and deleting alleles at homozygous SNP loci and reads that cover fewer than 2 heterozygous SNP loci, we obtained 100 SNP matrices, each of which has 449 columns</p><formula>H2: 0 1 1 1 H H3: 1 1 0 0 H1: 0 0 1 0 H * H2 * : 0 1 0 0 H1 * : 0 1 1 1 H3 * : 1 0 1 0</formula><p>Only 1 of 3 haplotypes of H * is phased by H with no error:<ref type="figure" target="#fig_3">Figure 4</ref>. When the weight w was set as 0.9, H-PoPG reached the best performance among the three algorithms according to<ref type="figure" target="#fig_3">Figure 4</ref>(a) in vector error rate,<ref type="figure" target="#fig_3">Figure 4</ref>(b) in perfect solution rate and<ref type="figure" target="#fig_3">Figure 4</ref>(c) in correct phasing rate.<ref type="figure" target="#fig_3">Figure 4</ref>(d) shows that the rate of phased SNPs (i.e. the phased SNPs to total SNPs ratio) of HapTree and HapCompass is the best at 99.3%, while the phased SNP rates of HPoPG with different weights are near 98.5%. Figures 4 (e) and (f) show that the running time and memory of H-PoPG varied little as the weight changes and H-PoPG used much less time and memory than HapTree and HapCompass. In the following experiments, w was set as 0.9 for H-PoPG and H-PoP as the default value. Since HapCompass ran very slow and its performance was clearly inferior to H-PoPG and HapTree, it was not included in the tests.genome.<ref type="figure" target="#fig_6">Figure 6</ref>illustrates the test results on simulated data generated by ART with c = 6. When k = 5, H-PoPG was superior to the other algorithms in terms of vector error rate, perfect solution rate and correct phasing rate. When k = 4 and 6, HapTree was the best in terms of vector error rate and correct phasing rate, but H-PoPG was not far behind. On the other hand, the running time and memory requirement of HapTree increased at a significantly faster rate than those of the other algorithms when k increased. When k = 6, HapTree ran for 1301 seconds and used 63 GB memory, while H-PoPG used only 23 seconds and 4 GB memory. As for the phased SNP rate, there is very little difference between the algorithms, and it was above 99.3% for all algorithms.<ref type="figure" target="#fig_7">Figure 7</ref>shows the test results on triploid data when we changed the haplotype template from the first contig of AWRI1499 to the concatenations of the first two contigs or the first four contigs. The number of heterozygous SNPs of the haplotype template increased from 449 to 1145 and 1739, respectively.<ref type="figure" target="#fig_7">Figure 7</ref>illustrates that H-PoPG had the best performance in terms of vector error rate, perfect solution rate and correct phasing rate, while SDhaP was the worst in terms of perfect solution rate and correct phasing rate. The phased SNP rates of HapTree and SDhaP are a little higher than those of H-PoPG. The running time of HapTree increased significantly with the increased haplotype template length, while the running time of H-PoPG and H-PoP increased slowly. The running times and memories of H-PoPG and H-PoP are much less than those of HapTree and SDhaP. The length of reads generated by ART is limited by the buildin sequencing platform quality profile. To test the performance of the algorithms on long reads that future sequencing technologies might produce, we concatenated multiple copies of the Illumina HiSeq 2500 platform quality profile contained in the ART package and generated a simulated future sequencer quality profile file to avoid the read length limit of ART. We concatenated all 14 contigs of the first scaffold of AWRI1499 into a template haplotype consisting of 22178 heterozygous SNPs, and using the new quality profile, we ran ART to generate reads with parameters r (the length of reads to be simulated), f (the mean length of inserts for paired-end reads), σ (the standard deviation of DNA fragment sizes), and c (the read coverage of each haplotype). We fixed c as 12, σ as 50, and varied (r, f ) from (500, 2000) to (1000, 3000) and (2000, 6000), and the average length l of the generated SNP reads changed from 40 to 80 and 160.<ref type="figure" target="#fig_8">Figure 8</ref>shows the test results. Since HapTree ran slowly when tested on the data withLinux cluster, each with a subset. As for the test with l = 80, since HapTree could only finish 4 subsets in 7 days, the results of HapTree in<ref type="figure" target="#fig_8">Figure 8</ref>are the averages of its results on the 4 subsets. As for the test with l = 160, HapTree was unable to terminate on any subset in 7 days and hence its results are missing in<ref type="figure" target="#fig_8">Figure 8</ref>.<ref type="figure" target="#fig_8">Figure 8</ref>shows again that H-PoPG is the best in terms of vector error rate and perfect phasing rate. The correct phasing rates of H-PoPG, H-PoP and HapTree were all more than 99.8%, while those of SDhaP were less than 94%. With regard to running time and memory, H-PoPG and H-PoP were clearly more efficient than the other two algorithms.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Conclusion</head><p>With the rapid development of sequencing technologies, reconstructing the multiple haplotypes of a polyploid from DNA sequencing reads is becoming more and more practical. In this paper, we modeled polyploid haplotyping as a combinatorial optimization problem to partition the input reads, called the Polyploid Balanced Optimal Partition (PBOP) problem. Since the problem is NP-hard, we developed a heuristic algorithm HPoP for it. When the genotype information is available, we also proposed a genotype constrained version, called PBOPG, of the problem and designed a corresponding heuristic algorithm H-PoPG. Note that these methods are very different from our previous methods for dealing with diploids (<ref type="bibr" target="#b31">Xie et al., 2012</ref>) since they consider the distance between the consensus haplotypes of different groups while the previous methods for diploids calculates the distance between reads belonging to different groups. We compared our algorithms with three recent state-of-the-art polyploid haplotyping algorithms SDhaP, HapTree and HapCompass on both simulated and real data. Our extensive test results showed that HPoPG was generally more accurate in reconstructing haplotypes than SDhaP, HapTree and HapCompass, and H-PoP was able to achieve comparable (though slightly worse) performance without the genotype information. Furthermore, H-PoPG and H-PoP ran much faster than SDhaP, HapTree and HapCompass, and could effectively handle long reads and deep read coverage. Our experiments on real data also showed that H-PoP could be used to infer the number of chromosomes of an organism (i.e. its ploidy), since when the parameter k is set smaller than the ploidy of the organism, the MEC rate of H-PoP would be much larger than the sequencing error rate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Funding</head><p>This work has been supported in part by the National Natural Science Foundation of China under grant NO. 61370172 and US National Science Foundation grant DBI-1262107.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig.2.</head><figDesc>Fig. 2. An illustration of F(4, 3), the set of all 15 canonical functions that partition 4 rows into at most 3 groups. A partition function is represented by a path from the root node to a leaf node. For example, the path from the root node F(4, 3) to the leaf node S(3, 1) represents such a function P with P (4) = 2 and P (i) = 1 for i = 1 to 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><figDesc>The total number of non-'-' elements is 448619, the average read coverage of each SNP is 36.7, and the average number of non-'-' elements in a row (i.e. an SNP read) is 7.0. All algorithms except HapTree reconstructed 20 disjoint blocks of haplotypes on these contigs, with the average block length being 611.3 SNPs. The test results on the 6 contigs are summarized in Table 1. The SNP matrices of the remaining 8 contigs (contigs 1, 2, 4, 7, 10, 12, 16 and 18) consist of 13943 rows and 4096 columns (SNPs). The total number of non-'-' elements is 115371, the average read coverage of each SNP is 28.2, and the average number of non-'-' elements in a row (an SNP read) is 8.3. All algorithms reconstructed 98 disjoint blocks of haplotypes on these contigs, with the average block length being 41.8 SNPs. The test results on the 8 contigs are presented in Table 2.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig.3.</head><figDesc>Fig. 3. An simple illustration of correct phasing rate, perfect solution rate and vector error rate. In this example, the correct phasing rate Rc of the reconstructed haplotypes H is 10/12, the perfect solution rate Rp = 1/3 and the vector error rate Rv = 2/4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig.4.</head><figDesc>Fig. 4. Comparison of the performance of H-PoPG, HapTree and HapCompass on simulated triploid (k = 3) 454 GS FLX Titanium sequencing data. Various weights from 0.8 to 1.0 were considered for the parameter w in H-PoPG.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig.5.</head><figDesc>Fig. 5. Comparison of the performance of H-PoPG, HapTree and SDhaP on simulated triploid (k = 3) 454 GS FLX Titanium sequencing data. The SNP read coverage increased from 11.7 to 23.7, 35.4 and 47.1, and the average SNP length was about 13.5.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.6.</head><figDesc>Fig. 6. Comparison of the performance of H-PoPG, H-PoP, HapTree, and SDhaP on simulated tetraploid (k = 4), pentaploid (k = 5) and hexaploid (k = 6) data. The number of SNPs was 449, and the average SNP read length was 13.5. The SNP read coverage of the simulated data with k = 4(5, 6) was 47.1 (58.9, 70.8, respectively).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig.7.</head><figDesc>Fig. 7. Comparison of performance of H-PoPG, H-PoP, HapTree and SDhaP on simulated triploid (k = 3) 454 GS FLX Titanium sequencing data with the number of SNPs changed. The average SNP read length and coverage of the simulated data with 449 (1145, 1739) SNPs were 13.4 (14.1, 14.7) and 11.7 (11.9, 11.9), respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig.8.</head><figDesc>Fig. 8. Comparison of performance of H-PoPG, H-PoP, HapTree and SDhaP on simulated triploid (k = 3) sequencing data with different SNP read lengths. Each haplotype contained 22178 heterozygous SNPs. When the average SNP read length was 40 (80, 160), the average number of SNP reads and the SNP read coverage were 19719.2 (9827.7, 4877.3) and 35.6 (35.5, 35.2), respectively.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><figDesc>Once all possible extensions of the functions in F to R ′ f have been enumerated, we set</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><figDesc>Table 1. Comparison of the performance of H-PoPG, H-PoP, HapCompass (HapC in the table) and SDhaP on the real data corresponding to contigs 6, 8, 15, 17, 19 and 21 of triploid AWRI1499.</figDesc><table>k = 3 
k = 2 
H-PoPG H-PoP HapC 
SDhaP 
H-PoP 
MEC 
8867 
3891 
22822 
8186 
28400 
MEC rate (%) 1.98 
0.87 
5.08 
1.82 
6.33 
Phased SNPs 
12223 
12160 12226 
12226 
12210 
Time (s) 
19.1 
13.9 
25237.9 41425.9 
7.5 
Memory (GB) 8.2 
8.2 
43.5 
32.4 
4.3 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="true"><figDesc>Table 2. Comparison of the performance of H-PoPG (H-PG in the table), H-PoP, HapTree (HapT in the table), HapCompass (HapC in the table) and SDhaP on</figDesc><table>the real data corresponding to contigs 1, 2, 4, 7, 10, 12, 16 and 18 of triploid 
AWRI1499. 

k = 3 
k = 2 
H-PG H-PoP HapT HapC SDhaP 
H-PoP 
MEC 
1471 
497 
1487 3748 1085 
4991 
MEC rate (%) 1.28 
0.43 
1.29 3.25 0.94 
4.33 
Phased SNPs 
4094 
4061 
4096 4096 4096 
4082 
Time (s) 
6.5 
4.4 
371.5 575.8 345.3 
4.4 
Memory (GB) 2.2 
2.2 
1.3 
39.1 25.6 
0.8 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><figDesc>Rp= 1/3 (H2) (H1) (H3) H1 has a vector error H3 has a vector error Suppose H1 * is reconstructed as H2, H2 * as H3 and H3 * as H1 10 of 12 alleles of H * are correctly phased: Rc = 10/12</figDesc><table>H has 2 vector errors at 4 SNP loci: Rv=2/4 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_6" validated="false"><figDesc>l = 80 and l = 160, in each case we divided 100 test datasets into 10 subsets and tested HapTree on 10 different nodes of the</figDesc><table>10 -4 

10 -3 

10 -2 

10 -1 

H-PoPG 
HapTree 

1739 
1145 
449 
Vector error rate 

SNPs 

(a) Vector error rate 

0.0 

0.5 

1.0 

H-PoPG 
H-PoP 
HapTree 
SDhaP 

1739 
1145 
449 
Perfect solution rate 

SNPs 

(b) Perfect solution rate 

0.6 

0.8 

1.0 

H-PoPG 
H-PoP 
HapTree 
SDhaP 

1739 
1145 
449 
Correct phasing rate 

SNPs 

(c) Correct phasing rate 

0.90 

0.95 

1.00 

1739 
1145 
449 
Phased SNPs rate 

SNPs 

(d) Phased SNP rate 

10 -1 

10 0 

10 1 

10 2 

10 3 

H-PoPG 
H-PoP 
HapTree 
SDhaP 

1739 
1145 
449 
Running time (s) 

SNPs 

(e) Running time 

10 -1 

10 0 

10 1 

10 2 

H-PoPG 
H-PoP 
HapTree 
SDhaP 

1739 
1145 
449 
Max memory (GB) 

SNPs 

(f) Max resident memory 

</table></figure>

			<note place="foot">at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>

			<note place="foot" n="1"> 3 15 F(4, 3) 1 S(4, 1) 7 S(4, 2) 1 S(3, 1) 3 S(3, 2) 1 S(2, 1) 1 S(2, 2) 6 S(4, 3)</note>

			<note place="foot">We increased c from 2 to 4, 6 and 8, and generated SNP matrices with SNP read coverage changing from 11.7 to 23.7, 35.4 and 47.1 to test H-PoPG, H-PoP, HapTree and SDhaP. Figure 5 presents the test results. Without genotype information, the genotypes of the k haplotypes reconstructed by SDhaP and H-PoP were often different from that of the real k-haplotypes and hence vector error rate could not be used to measure the performance of SDhaP and H-PoP. When the coverage increased, the vector error rates, the perfect solution rates and the correct phasing rate of all algorithms improved. The vector error rates of H-PoPG are less than a half of those of HapTree, and the perfect solution rates of H-PoPG and H-PoP are clearly higher than those of HapTree and SDhaP. In the test with SNP read coverage 47.1, HapTree reached the highest correct phasing rate, while in the other tests H-PoPG performed best in term of correct phasing rate. HapTree and SDhaP phased the most SNPs, while the phased SNPs of H-PoPG were a little fewer than those of HapTree and SDhaP. In the test with SNP read coverage 11.7, the phased SNP rate of H-PoP was the lowest. However, even in the worst case, H-PoP phased more than 96% of the SNPs. In terms of efficiency, the average running times of H-PoPG and H-PoP were less than 2 seconds, which is obviously less than those of HapTree and SDhaP. H-PoPG and H-PoP used much less memory than HapTree and SDhaP when the coverage was 11.7, and HapTree used the least amount of memory in the other three cases. The memory requirement of SDhaP was about 26 GB, and it did not change much in different tests (including the tests below), while the memory required by H-PoPG and H-PoP was less than 3 GB in all four cases. It is interesting to observe that HapTree spent much more time and memory to handle the test data with coverage 11.7 than other data with deeper coverages. We varied k from 4 to 6 to test the performance of the algorithms on reconstructing the haplotypes of a tetraploid, pentaploid or hexaploid at University of California, Los Angeles on August 30, 2016 http://bioinformatics.oxfordjournals.org/ Downloaded from</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct   xml:id="b0">
	<analytic>
		<title level="a" type="main">Haplotype assembly in polyploid genomes and identical by descent shared tracts</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Aguiar</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Istrail</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="29" to="352" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b1">
	<analytic>
		<title level="a" type="main">Polynomial and APXhard cases of the individual haplotyping problem</title>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bafna</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Istrail</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Lancia</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Rizzi</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">335</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="109" to="125" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b2">
	<analytic>
		<title level="a" type="main">HapTree: a novel Bayesian framework for single individual polyplotyping using NGS data</title>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Berger</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>Yorukoglu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Peng</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Berger</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS Comput Biol</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">1003502</biblScope>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b3">
	<analytic>
		<title level="a" type="main">On the fixed parameter tractability and approximability of the minimum error correction problem</title>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Bonizzoni</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Dondi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">W</forename>
				<surname>Klau</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Pirola</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Pisanti</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Zaccaria</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">LNCS</title>
		<imprint>
			<publisher>Springer International Publishing</publisher>
			<biblScope unit="volume">9133</biblScope>
			<biblScope unit="page" from="100" to="113" />
			<date type="published" when="2015" />
			<publisher>Springer International Publishing</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b4">
	<analytic>
		<title level="a" type="main">Haplotype phasing: existing methods and new developments</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<forename type="middle">R</forename>
				<surname>Browning</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<forename type="middle">L</forename>
				<surname>Browning</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nat Rev Genet</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="703" to="717" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b5">
	<analytic>
		<title level="a" type="main">Exact algorithms for haplotype assembly from whole-genome sequence data</title>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<forename type="middle">Z</forename>
				<surname>Chen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Deng</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Wang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">16</biblScope>
			<biblScope unit="page" from="29" to="1938" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b6">
	<analytic>
		<title level="a" type="main">The complexity of the single individual SNP haplotyping problem</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Cilibrasi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Van Iersel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Kelk</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Tromp</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">49</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="13" to="36" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b7">
	<analytic>
		<title level="a" type="main">De-novo assembly and analysis of the heterozygous triploid genome of the wine spoilage yeast Dekkera bruxellensis AWRI1499</title>
		<author>
			<persName>
				<forename type="first">C</forename>
				<forename type="middle">D</forename>
				<surname>Curtin</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">R</forename>
				<surname>Borneman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<forename type="middle">J</forename>
				<surname>Chambers</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<forename type="middle">S</forename>
				<surname>Pretorius</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">PLoS One</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">33840</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b8">
	<analytic>
		<title level="a" type="main">SDhaP: haplotype assembly for diploids and polyploids via semi-definite programming</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Das</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Vikalo</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Genomics</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page">260</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b9">
	<monogr>
		<title/>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Duitama</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Huebsch</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Mcewen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E.-K</forename>
				<surname>Suk</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<forename type="middle">R</forename>
				<surname>Hoehe</surname>
			</persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b10">
	<analytic>
		<title level="a" type="main">ReFHap: a reliable and fast algorithm for single individual haplotyping</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First ACM international Conference on Bioinformatics and Computational Biology</title>
		<meeting>the First ACM international Conference on Bioinformatics and Computational Biology<address><addrLine>Niagara Falls, New York</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<biblScope unit="page" from="160" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b11">
	<analytic>
		<title level="a" type="main">SpeedHap: an accurate heuristic for the single individual SNP haplotyping problem with many gaps, high reading error rate and low coverage</title>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">M</forename>
				<surname>Genovese</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">F</forename>
				<surname>Geraci</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Pellegrini</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE/ACM Trans Comput Biol Bioinform</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="492" to="502" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b12">
	<analytic>
		<title level="a" type="main">Optimal algorithms for haplotype assembly from whole-genome sequence data</title>
		<author>
			<persName>
				<forename type="first">D</forename>
				<surname>He</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Choi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">K</forename>
				<surname>Pipatsrisawat</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Darwiche</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">E</forename>
				<surname>Eskin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="26" to="183" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b13">
	<analytic>
		<title level="a" type="main">ART: a next-generation sequencing read simulator</title>
		<author>
			<persName>
				<forename type="first">W</forename>
				<surname>Huang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">R</forename>
				<surname>Myers</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Marth</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">T</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="593" to="597" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b14">
	<analytic>
		<title level="a" type="main">SNPs problems, complexity and algorithms</title>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Lancia</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">V</forename>
				<surname>Bafna</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Istrail</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Lippert</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Schwartz</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Ann. European Symp. on Algorithms (ESA), volume 2161 of Lecture Notes in Computer Science</title>
		<editor>F. M. auf der Heide</editor>
		<meeting>. Ann. European Symp. on Algorithms (ESA), volume 2161 of Lecture Notes in Computer Science<address><addrLine>Berlin/Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="182" to="193" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b15">
	<analytic>
		<title level="a" type="main">Genomic plasticity and the diversity of polyploid plants</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<forename type="middle">R</forename>
				<surname>Leitch</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">I</forename>
				<forename type="middle">J</forename>
				<surname>Leitch</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Science</title>
		<imprint>
			<biblScope unit="issue">5875</biblScope>
			<biblScope unit="page" from="320" to="481" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b16">
	<analytic>
		<title level="a" type="main">Improving SNP discovery by base alignment quality</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1157" to="1165" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b17">
	<analytic>
		<title level="a" type="main">A statistical framework for SNP calling, mutation discovery, association mapping and population genetical parameter estimation from sequencing data</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">21</biblScope>
			<biblScope unit="page" from="27" to="2987" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b18">
	<analytic>
		<title level="a" type="main">Fast and accurate short read alignment with BurrowsWheeler transform</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="25" to="1754" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b19">
	<analytic>
		<title level="a" type="main">The sequence alignment/map format and samtools</title>
		<author>
			<persName>
				<forename type="first">H</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">B</forename>
				<surname>Handsaker</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Wysoker</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Fennell</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Ruan</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Homer</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Marth</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Abecasis</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Durbin</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">16</biblScope>
			<biblScope unit="page" from="25" to="2078" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b20">
	<analytic>
		<title level="a" type="main">Algorithmic strategies for the single nucleotide polymorphism haplotype assembly problem</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Lippert</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Schwartz</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<surname>Lancia</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Istrail</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Brief. Bioinform</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="9" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b21">
	<analytic>
		<title level="a" type="main">Genome sequencing in microfabricated high-density picolitre reactors</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Margulies</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Egholm</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">W</forename>
				<forename type="middle">E</forename>
				<surname>Altman</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Attiya</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Nature</title>
		<imprint>
			<biblScope unit="issue">7057</biblScope>
			<biblScope unit="page" from="437" to="376" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b22">
	<analytic>
		<title level="a" type="main">Fast hare: a fast heuristic for single individual SNP haplotype reconstruction</title>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Panconesi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Sozio</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. WABI</title>
		<editor>I. Jonassen and J. Kim</editor>
		<meeting>. WABI<address><addrLine>Berlin/Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="266" to="277" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b23">
	<analytic>
		<title level="a" type="main">WhatsHap: weighted haplotype assembly for futuregeneration sequencing reads</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Patterson</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Marschall</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Pisanti</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Van Iersel</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<surname>Stougie</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">W</forename>
				<surname>Klau</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">A</forename>
				<surname>Schonhuth</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J Comput Biol</title>
		<imprint>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="22" to="498" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b24">
	<analytic>
		<title level="a" type="main">HapCol: accurate and memory-efficient haplotype assembly from long reads</title>
		<author>
			<persName>
				<forename type="first">Y</forename>
				<surname>Pirola</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Zaccaria</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">R</forename>
				<surname>Dondi</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">G</forename>
				<forename type="middle">W</forename>
				<surname>Klau</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">N</forename>
				<surname>Pisanti</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">P</forename>
				<surname>Bonizzoni</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="page" from="10" to="1093" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b25">
	<analytic>
		<title level="a" type="main">Doubling down on genomes: polyploidy and crop plants</title>
		<author>
			<persName>
				<forename type="first">S</forename>
				<surname>Renny-Byfield</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<forename type="middle">F</forename>
				<surname>Wendel</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Am J Bot</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b26">
	<analytic>
		<title level="a" type="main">A practical exact algorithm for the individual haplotyping problem MEC/GI</title>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Xie</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Chen</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">56</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="283" to="296" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b27">
	<analytic>
		<title level="a" type="main">Haplotype reconstruction from SNP fragments by minimum error correction</title>
		<author>
			<persName>
				<forename type="first">R</forename>
				<forename type="middle">S</forename>
				<surname>Wang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">L</forename>
				<forename type="middle">Y</forename>
				<surname>Wu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Z</forename>
				<forename type="middle">P</forename>
				<surname>Li</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">X</forename>
				<forename type="middle">S</forename>
				<surname>Zhang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="2456" to="2462" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b28">
	<analytic>
		<title level="a" type="main">A model of higher accuracy for the individual haplotyping problem based on weighted SNP fragments and genotype with errors</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Xie</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Chen</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Bioinformatics</title>
		<imprint>
			<biblScope unit="issue">13</biblScope>
			<biblScope unit="page" from="24" to="105" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b29">
	<analytic>
		<title level="a" type="main">Computational models and algorithms for the single individual haplotyping problem</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Xie</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Chen</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wu</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">X</forename>
				<surname>Liu</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Current Bioinformatics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="18" to="28" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b30">
	<analytic>
		<title level="a" type="main">A practical parameterised algorithm for the individual haplotyping problem MLF</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Xie</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">Chen</forename>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Structures in Computer Science</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="851" to="863" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct   xml:id="b31">
	<analytic>
		<title level="a" type="main">A fast and accurate algorithm for single individual haplotyping</title>
		<author>
			<persName>
				<forename type="first">M</forename>
				<surname>Xie</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">J</forename>
				<surname>Wang</surname>
			</persName>
		</author>
		<author>
			<persName>
				<forename type="first">T</forename>
				<surname>Jiang</surname>
			</persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Systems Biology</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">8</biblScope>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
	<note>Suppl</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>