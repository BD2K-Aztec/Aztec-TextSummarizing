Motivation: High-throughput sequencing produces in a small amount of time a large amount of data, which are usually difficult to analyze. Mapping the reads to the transcripts they originate from, to quantify the expression of the genes, is a simple, yet time demanding, example of analysis. Fast genomic comparison algorithms are thus crucial for the analysis of the ever-expanding number of reads sequenced. Results: We used NC-lists to implement an algorithm that compares a set of query intervals with a set of reference intervals in two steps. The first step, a pre-processing done once for all, requires time O½#R logð#RÞ þ #Q logð#QÞ, where Q and R are the sets of query and reference intervals. The search phase requires constant space, and time Oð#R þ #Q þ #MÞ, where M is the set of overlaps. We showed that our algorithm compares favorably with five other algorithms, especially when several comparisons are performed. Availability: The algorithm has been included to S–MART, a versatile tool box for RNA-Seq analysis, freely available at http://urgi.versailles. inra.fr/Tools/S-Mart. The algorithm can be used for many kinds of data (sequencing reads, annotations, etc.) in many formats (GFF3, BED, SAM, etc.), on any operating system. It is thus readily useable for the analysis of next-generation sequencing data.
INTRODUCTIONWith the advent of high-throughput sequencing, bioinformatics must analyze a large amount of data every day. Modern sequencers can generate several hundred millions of sequences in a week for a price that is affordable to more and more labs. When a reference genome is available, the first task is to map the reads on the genome. Many mapping tools are now available and research is active on this topic. For RNA-Seq, the second step may be the assignment of the mapped read to the transcripts they originate from, to estimate the expression of the genes (). In general, the genomic comparison of the mapped reads with a reference annotation is the basis of many analyses: comparison of putative transcription factor binding sites with up-regulated genes (); detection of the single-nucleotide polymorphisms that are located in coding regions (); processing de novo transcript sequences to determine if they represent known or novel genes (). These three examples involve a comparison of two annotations, and the problem has been addressed often. However, high-throughput sequencing, for the amount a data it produces, requires optimized algorithms for its analysis. Most tools model the reads or annotation as intervals, or lists of intervals when different elements are modeled (exons, UTRs, etc.). These intervals are considered along a reference, which usually is a chromosome or a scaffold. Thus, comparing RNASeq reads with known transcripts reduces to comparing a set of query intervals (the reads) with a set of reference intervals (the exons of the transcripts). Every efficient algorithm requires a dedicated data structure, such as an indexed database, an indexed flat file [such as a BAM file (, an R-tree or NC-lists (nested containment lists) (). These structures are usually built once during the pre-processing step, and can be reused for other analyses. Although these structures may take considerable amount of time to build, the balance is usually favorable to pre-processed structures when several comparisons are performed, as the time spent for the comparison itself is considerably reduced. This observation leads to the conception of the BAM format, now widely used in the bioinformatics community. With the notable exception of the fjoin algorithm (), almost all the algorithms previously described only get all the reference intervals that overlap with one given query interval: most algorithms have been designed to retrieve all the intervals a user can see when he selects a given window in a genome browser (). Whereas these algorithms can be used to compare two sets by comparing each query interval, one after the other, with the reference intervals, we will show here how comparing the whole query set with the reference set can be more efficient. Among the possible data structures presented to compare intervals, NC-lists () are one of the most promising. NC-lists have been first described to retrieve all the reference intervals that overlap with a single interval. Their structure is compact (a simple set of two arrays, L and H), the algorithm is fast in practice and the search phase requires only constant space, which is compulsory when handling several hundreds of millions of reads. The key idea of NC-lists is to perform binary dichotomic search on the list of reference intervals. But dichotomic search cannot be performed when some intervals are contained (or nested) inside other intervals, so NC-lists arrange intervals into liststhe L arraywhere no two intervals are nested. If some intervals are nested inside an ancestor interval, *To whom correspondence should be addressed.  The Author 2013. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com they are stored in a separate sublist using the H array (see). NC-lists can be built in linearithmic time [i.e. of the form On log n], using linear space (actually, only five integers are stored per interval). In their article, the authors presented a recursive dichotomic algorithm, equivalent to Alg. 1, which uses NC-lists. It is claimed that getting all the reference intervals that overlap with a query interval could be done in time Olog#R  #M, where R is the reference set and M the pairs query/reference that overlap, but this is not accurate for some cases (see section 3.1). In this article, we will present an algorithm, which relies on NC-lists, and provides all the pairs query intervals/reference intervals that overlap. In a pre-processing step, the algorithm sorts the query and the reference intervals. It then builds a NC-list for the reference intervals. In the search phase, the algorithm compares every query interval with the reference intervals in time O#R  #Q  #M. All together, the algorithm takes O#R log#R  #Q log#Q  #M. Although the complexity of the whole algorithm is not better than already known algorithms, the runtime complexity is significantly lower than other constant-space algorithms. As such, our algorithm is especially useful when performing multiple comparisons on large sets of data, such as in an RNA-Seq data analysis.
DISCUSSIONThe method presented here uses NC-lists and provides a fast algorithm that compares two large sets of intervals efficiently.To our knowledge, it is the first time that an algorithm with both linear time complexity and constant space complexity during the search phase is presented. This low run-time complexity comes at the cost of a high pre-processing time complexity, where the intervals should be sorted. However, this step is done only once and is far from untractable (the samtools sort algorithm is used routinely to sort BAM files). As a result, the algorithm presented in this article is adapted to multiple comparisons. When we designed the algorithm, we had the idea in mind that it could help comparing features such as RNA-Seq data, which can amount to several hundreds millions reads. While this algorithm presents a theoretical interest by itself, we also encapsulated it in the SMART tool box, which includes all the features to handle usual file formats. As a consequence, we hope this work will be useful for both computer scientists and biologists.