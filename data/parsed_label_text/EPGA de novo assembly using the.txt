Motivation: In genome assembly, the primary issue is how to determine upstream and downstream sequence regions of sequence seeds for constructing long contigs or scaffolds. When extending one sequence seed, repetitive regions in the genome always cause multiple feasible extension candidates which increase the difficulty of genome assembly. The universally accepted solution is choosing one based on read overlaps and paired-end (mate-pair) reads. However, this solution faces difficulties with regard to some complex repetitive regions. In addition, sequencing errors may produce false repetitive regions and uneven sequencing depth leads some sequence regions to have too few or too many reads. All the aforementioned problems prohibit existing as-semblers from getting satisfactory assembly results. Results: In this article, we develop an algorithm, called extract paths for genome assembly (EPGA), which extracts paths from De Bruijn graph for genome assembly. EPGA uses a new score function to evaluate extension candidates based on the distributions of reads and insert size. The distribution of reads can solve problems caused by sequencing errors and short repetitive regions. Through assessing the variation of the distribution of insert size, EPGA can solve problems introduced by some complex repetitive regions. For solving uneven sequencing depth, EPGA uses relative mapping to evaluate extension candidates. On real datasets, we compare the performance of EPGA and other popular assemblers. The experimental results demonstrate that EPGA can effectively obtain longer and more accurate contigs and scaffolds.
IntroductionKnowledge of genome sequences has become indispensable in numerous applied fields such as diagnostics, biotechnology, forensic biology and systems biology. The next generation sequencing (NGS) technologies, also known as high-throughput sequencing, including Illumina, 454 Life Sciences and SOLiD, can provide short sequence fragments named reads, much more quickly and cheaply than previously used Sanger sequencing, but at the sacrifice of read length (). A number of genome assemblers have been proposed using a great deal of short reads produced by NGStechnologies for reconstructing complete genome sequence (). The primary issue of these assemblers is how to determine upstream and downstream sequence regions of sequence seeds for constructing contigs or scaffolds. As the length of reads decreases, the number of repetitive regions in one genome will dramatically increase. When extending one seed sequence, repetitive regions can cause multiple feasible candidate regions which increase the difficulty of genome assembly. So, the repetitive regions especially longer than the read length in one genome become one of the most challenges in genome assembly (). The earlier assemblers generally employ read overlaps to extend one sequence seed. When there are multiple feasible extension candidates caused by repetitive regions, the assemblers usually select one with the maximum overlap or the highest consensus to extend (). The length of read overlap is important to identify extension candidates and choose the correct one among them. Because sequencing errors often result in erroneous read overlaps and low-depth regions miss some read overlaps, so read overlaps usually compromise between continuity and error rate (). De Bruijn graph is a useful data structure which can store read overlaps (). There are some improved De Bruijn graphs used for assembly (). However, the information about read overlaps has no effect on repetitive regions longer than the read length. Most recent assemblers make use of paired-end (mate-pair) reads which can be produced by NGS technologies for resolving repetitive region problems. One paired-end read is referred to a pair of short reads sequenced from two ends of one long sequence fragment and the sequence fragment length (the distance between paired-end reads) is usually called insert size which is a random variable with mean l is and SD d is. The insert size is frequently assumed to have a normal distribution N(l is , d is ). For every paired-end read, its two reads are called the mates of each other. In recent years, there have been numerous assemblers presented for biologists (). Velvet () uses paired-end reads to mark nodes, and finds a correct path through marked nodes to connect two long nodes based on De Bruijn graph. However, some nodes shorter than the read length cannot be marked, so it tends to contain more errors at short repetitive regions. Abyss () adopts a method similar to Velvet's. When extending one sequence seed or filling one gap region, PE-Assembly () tries to identify feasible extensions from local read sets produced from paired-end reads. IDBA () and IDBA-UD () iterately change k-mer (k consecutive bases in one read) length and uses paired-end reads to eliminate branches in De Bruijn graph. Telescoper () first constructs read-overlap graph based on reads whose mate reads can map to sequence seeds, and it develops a statistical framework using penalty function to choose paths for constructing contigs. SOAPDenovo () and SOAPDenovo2 () directly use nodes in De Bruijn graph as contigs which are usually short. ALLPATHS-LG () has specific requirements in read length and insert size, which differ from common read libraries. In the following part, let r denote the read length and s denote a sequence. sis the i-th base in s. sis the sub-region of s from i-to j-th base. L(s) is the length of s and R(s) is the set of reads in s. RE(s) is the set of reads in R(s) which exist in the read library. RML(s) is the set of reads in RE(s) which have left mate reads and MRL(s) is one set which includes the corresponding left mate reads. RMLM(s i , s j ) is the set of reads in RML(s j ) whose one left mate read can be mapped to s i and the distance between the mapped pairedend reads must be in the interval l is  3  d is ; l is  3  d is ; DLs i ; s j  is the set including the corresponding distances. RMR(s), MRR(s), RMRM(s i , s j ) and DR(s i , s j ) all can be obtained from right mate reads of the sequences. jTj is cardinality of one set T. The information contained in paired-end reads can facilitate genome assembly (). Because paired-end reads can span repetitive regions shorter than insert size, for one sequence seed s s and one downstream extension candidate s, we can estimate the correctness of s through its MRL(s). When the reads in MRL(s) can be mapped to s s , we consider s as the correct one, as illustrated in. Although paired-end reads are widely applied to resolve problems caused by repetitive regions in genome assembly, the performance of most assemblers is not satisfactory. There are three major problems which prevent most assemblers from identifying correct extension candidates by using paired-end reads: 1. Adjacent repetitive regions and paired repetitive regions: For two same regions B, if the separation distance between the two regions in genome is small, we say that it is adjacent repetitive region, shown in. For two regions (A, C), if the length between A and C is closed to insert size and the two regions appear in genome repeatedly, we say that it is paired repetitive region, shown in. The upstream or downstream regions of adjacent and paired repetitive regions are difficult to determine, because the most reads in MRL or MRR of extension candidates can be mapped to the sequence seed. 2. Sequencing errors: sequencing errors always bring about incorrect reads which probably lead to false repetitive regions and false extension candidates. 3. Uneven sequencing depths: sequencing depth of one sequence region depends on the average number of reads in the read library which can be mapped to the region. Because sequencing depths of different regions in a genome are universally highly uneven (), there are no or fewer reads which can be mapped to low-depth regions, but high-depth regions have too many mapped reads. Uneven sequencing depths aggravate the problems caused by (1) and (2). In, for the sequence seed AB, which is merged by A and B, and the extension candidate C, the distances in DL(AB, C) should follow the distribution Nl is ; d is . D is the correct extension candidate of ABCB and the difference between the length of AB and the length of ABCB is LC  LB. When D is regarded as the extension candidate of AB, the distances in DL(AB, D) will follow Nl is  LB  LC; d is . In, the distances in DL(ABC, D) will follow Nl is ; d is . Because H is the correct extension. Paired-end reads using in extending sequence seed. The graph G is constructed based on sequence s (ABC. .. DBE). When extending downstream region of AB, it has two extension candidates C and E. If no sequencing errors, reads in MRL(C) can be mapped to AB, but reads in MRL(E) can not be mapped to AB. So, C is the correct extension candidate candidate of AEC and the difference between the length of ABC and the length of AEC is LE  LB, the distances in DL(ABC, H) will follow Nl is  LE  LB; d is . It is clear that we can identify which extension candidate is correct by assessing whether the distances in DL follow Nl is ; d is . To our knowledge, PE-Assembly is the only tool which considers the variation of the distribution of insert size in filling gap step. For one fixed length sequence s, R(s) includes L(s)r  1 reads. Due to sequencing depth, some reads in R(s) probably do not appear in the read library. jREsj is usually smaller than jRsj. Every read is sequenced randomly, jREj is a random variable whose distribution is called the distribution of reads. jREsj is a particular value of the random variable which should be within a reasonable range. The probability P is one read can be sequenced, if P is the same for every read in genome reference, the distribution of reads approximately follows binomial distribution. The reasonable range can be determined by binomial distribution. If jREsj goes beyond this range, we consider s including false bases. If sequencing depth is even and sequencing coverage is large enough without sequencing errors, genome sequence is corresponding to one path contained in De Bruijn graph. However, due to the uneven sequencing depth and sequencing errors, the path is inevitably segmented into many noncontiguous sub paths. So, the target of de novo assembly becomes to analyze De Bruijn graph for seeking out accurate sub paths corresponding to sub regions of genome. We develop a novel assembler, called EPGA (extract paths for genome assembly), to improve genome assembly (see the flowchart of EPGA in Supplementary). EPGA selects some nodes in De Bruijn graph as sequence seeds. The precursor nodes and successor nodes of sequence seeds are treated as its upstream and downstream extension candidates. EPGA processes each extension candidate to form an evaluating region which is evaluated based on a new score function. Using the new score function, EPGA iteratively extends sequence seeds on both sides to extract long paths which are contigs. For one sequence seed s s , its downstream extension candidate s and evaluating region s e , EPGA uses the following three new strategies which make novel use of paired-end reads: To resolve problem (1), EPGA adopts the coefficient of determination (CD) to evaluate whether the distances in DLs s ; s e  follow Nl is ; d is . The CD provides a measure of how well the distances are replicated by Nl is ; d is , as the proportion of total variation of the distances is explained by Nl is ; d is . To resolve problem (2), based on the distribution of reads, EPGA determines a reasonable range of jREs e j to identify whether s is a false extension candidate. The probability that jREs e j is within the range should be large enough. To resolve problem (3), EPGA designs a new index named relative mapping (RM) to evaluate extension candidates. The relative mapping is the ratio of RMLMs s ; s e  to RMLs e . So, relative mapping can guarantee that correct extension candidates are given high score no matter sequencing depth is. In EPGA, we mainly incorporate two new ideas for genome assembly: (i) we consider the distribution of reads to identify whether one extension candidate includes sequencing errors, rather than only using k-mer frequency; (ii) based on the distribution of insert size, we develop a new score function to overcome complex repetitive regions. The performance of EPGA and other popular assemblers are compared on real datasets. The results demonstrate that EPGA can get more continuous and correct genome sequences.
ConclusionEPGA extends sequence seeds by iteratively evaluating extension candidates and choosing correct one between them to construct contig set. Because there exists sequencing errors and uneven sequencing depth in read libraries, we present new ideas to avoid problems produced by them. For adjacent repetitive regions and paired repetitive regions, we use CD to distinguish correct extension candidates from false ones. The performance of EPGA is validated on real datasets from two bacteria and two fungi using the Illumina platform. In our experiments, we included some popular algorithms with available implementation. We considered several standard metrics for comparing assemblies. For all four datasets, EPGA produced more satisfactory results than the other assemblers considered. EPGA has been demonstrated that it is possible to obtain complete and highly accurate de novo genome assemblies. As one direction of future work, we would study how to reduce peak memory and running time for better performance. Funding: This work was supported in part by the National Natural Science Foundation of Chinaand the Program for New Century Excellent Talents in University. Conflict of Interest: none declared.