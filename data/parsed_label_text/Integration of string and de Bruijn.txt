Motivation: String and de Bruijn graphs are two graph models used by most genome assemblers. At present, none of the existing assemblers clearly outperforms the others across all datasets. We found that although a string graph can make use of entire reads for resolving repeats, de Bruijn graphs can naturally assemble through regions that are error-prone due to sequencing bias. Results: We developed a novel assembler called StriDe that has advantages of both string and de Bruijn graphs. First, the reads are decomposed adaptively only in error-prone regions. Second, each paired-end read is extended into a long read directly using an FM-index. The decomposed and extended reads are used to build an assembly graph. In addition, several essential components of an assembler were designed or improved. The resulting assembler was fully parallelized, tested and compared with state-of-the-art assemblers using benchmark datasets. The results indicate that contiguity of StriDe is comparable with top assemblers on both short-read and long-read datasets, and the assembly accuracy is high in comparison with the others. Availability and implementation: https://github.com/ythuang0522/StriDe
IntroductionAlthough next-and third-generation sequencing technologies have been widely used to sequence and assemble genomes of many species in the biosphere (), many assembled genomes are still fragmented due to complex repetitive structure (). A fragmented assembled genome often introduces extra complexity into downstream processing, e.g. estimation of gene family size and comparative analysis. Recently, several evaluation projects (e.g. GAGE, GAGE-b and Assemblathon 1/2) have been conducted to assess the accuracy, contiguity and speed of state-of-the-art assemblers (). None of the existing assemblers clearly outperforms all the others across all benchmarks. The overlap-layout-consensus (OLC) and de Bruijn graphs are two models used by most assemblers. These two models represent the overlapping relation between reads in different ways. The OLCbased assemblers, including MIRA, Newbler and Celera assemblers, first identify all pairs of overlapping reads and construct a graph with vertices representing reads and with edges denoting two overlapping reads (). Next, the genome sequence is assembled by figuring out a feasible layout of reads from the graph. The OLC-based methods make good use of the entire read length for resolving repeats and chimeras; this approach is beneficial for sequencing platforms generating long reads (e.g. Sanger sequencing, Roche 454 and Pacific Biosciences). These assemblers, however, are computationally inefficient at assembling a massive amount of short reads because of the time-consuming overlap computation. Nowadays, de Bruijn graph assemblers, including Velvet, SOAPdenovo, ABySS and ALLPATHS, are the preferred choice for most sequencing projects (). These assemblers break each read into fixed-size k-mers, which do not require the overlap computation, and a graph is directly constructed where each vertex is a k-mer and each edge indicates two adjacent k-mers overlapping by k  1 letters. The construction of a de Bruijn graph is much more efficient. Nonetheless, the graph structure is more complex owing to repeats larger than k-mer. Recently, a paired de Bruijn graph assembler (SPAdes) overcame this limitation by building a graph by means of paired k-mers from paired-end reads (). Aside from these two graph models, there is a variant (called string graph) that is similar to the OLC graph without transitive edges (). The construction of a string graph from reads can be computed in linear time using an FM-index (). The first such assembler, called the String Graph Assembler (SGA), is capable of assembling mammalian-size genomes, but its contiguity is not better than that of de Bruijn graph assemblers according to several benchmark tests. The string graph shares many properties with the OLC and de Bruijn graphs, but their equivalence in terms of real sequencing data remains a subject of debate (). We found that the major difference lies in the ability to assemble through regions that are error-prone due to sequencing bias (e.g. high-GC regions; see Supplementary;). This article presents a novel assembler called StriDe, which adaptively decomposes reads within error-prone regions and extends paired-end reads into long reads using an FM-index. In addition, an improved error correction algorithm, overlap computation, specialized layout algorithms and full parallelization were implemented to make the assembler more practical.
ConclusionThis article presents a novel assembler (StriDe) with advantages from string and de Bruijn graphs. Many essential components of an assembler were developed or improved. An initial test over various Illumina short-/long-read datasets showed that StriDe can assemble through error-prone and repetitive regions using decomposed and extended reads, respectively. The entire implementation is largely inherited from two open-source projects: Li's ropebwt2 and Simpson's SGA. The proposed assembler is still lacking a scaffolding module although third-party scaffolding programs can be incorporated.. The number of misassemblies by each assembler on short-read (HiSeq) or long-read (MiSeq) datasets