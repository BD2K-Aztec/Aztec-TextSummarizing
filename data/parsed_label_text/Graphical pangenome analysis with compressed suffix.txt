Motivation: Low-cost genome sequencing gives unprecedented complete information about the genetic structure of populations, and a population graph captures the variations between many individuals of a population. Recently, Marcus et al. proposed to use a compressed de Bruijn graph for representing an entire population of genomes. They devised an Oðn log gÞ time algorithm called splitMEM that constructs this graph directly (i.e. without using the uncompressed de Bruijn graph) based on a suffix tree, where n is the total length of the genomes and g is the length of the longest genome. Since the applicability of their algorithm is limited to rather small datasets, there is a strong need for space-efficient construction algorithms. Results: We present two algorithms that outperform splitMEM in theory and in practice. The first implements a novel linear-time suffix tree algorithm by means of a compressed suffix tree. The second algorithm uses the Burrows–Wheeler transform to build the compressed de Bruijn graph in Oðn log rÞ time, where r is the size of the alphabet. To demonstrate the scalability of the algorithms , we applied it to seven human genomes. Availability and implementation:
Introduction
DiscussionWe have presented two space-efficient methods to build the compressed de Bruijn graph from scratch. An experimental comparison with splitMEM showed that our algorithms are more than an order of magnitude faster than splitMEM while using significantly less space (two orders of magnitude). To demonstrate their scalability, we successfully applied them to seven complete human genomes. Consequently, it is now possible to use the compressed de Bruijn graph for much larger pan-genomes than before (consisting, e.g. of hundreds or even thousands of different strains of bacteria). Although the BWT-based algorithm is the clear winner of the comparison, CSTbased algorithms are still important. This is because STs play a central role in sequence analysis and most bioinformatics curricula comprise courses that cover this important data structure. It is therefore conceivable that a bioinformatician might be able to come up with a suffix tree algorithm that solves his/her problem at hand, but not with an algorithm that is based on the BWT and/or related data structures. If the space requirement of the ST is the bottleneck in the application, one can use a CST instead. CSTs with full functionality are, e.g. implemented in the succinct data structure library (sdsl) of. On the downside, extra features such as suffix skips are not implemented in those libraries so that a direct implementation of a suffix tree algorithm by means of a CST might not be possible. Future work includes parallel implementations of the algorithms. Moreover, it should be worthwhile to investigate the time-space tradeoff if one uses data structures that are optimized for highly repetitive texts, see Navarro and Ord n  ez (2014) and the references therein. Most important, however, is to address the problem of compressing the 'compressed de Bruijn graph' itself. (Our experiments show that for smaller k, the size of the graph can be larger than the size of the index, e.g. the graph for the seven human genomes and k  50 takes 1.65 bytes per base pair, whereas the BWT-index requires only 1.13 bytes per base pair.) Very recently, two Bloom filter methods were presented that can be used for this purpose. Solomon and Kingsford (2015) introduced the Sequence Bloom Tree to support sequence-based querying of large-scale collections of thousands of short-read sequencing experiments and applied it to the problem of finding conditions under which query transcripts are expressed. The second approach byis closer to the splitMEM approach. Their data structurethe Bloom Filter Trie (BFT)allows to efficiently store and traverse the uncompressed de Bruijn graph. In the Section Conclusion of their article,write 'Future work concerns the possibility to compress non-branching paths. .. ' This is exactly what splitMEM and our new algorithms do, so maybe the combination of both approaches will yield the ideal pan-genome representation.The first row in a block specifies the experiment. The second row shows the graph size in bytes per base pair. Rows 36 contain the numbers of edges, nodes, uniqueNodes and repeatNodes, respectively. Rows 710 show the average out-degree of the nodes as well as the average string length of the nodes, uniqueNodes and repeatNodes. The remaining rows (if applicable) contain the percentage of the nodes that are shared by x sequences.