Motivation: Sequence databases are growing fast, challenging existing analysis pipelines. Reducing the redundancy of sequence databases by similarity clustering improves speed and sensitivity of iterative searches. But existing tools cannot efficiently cluster databases of the size of UniProt to 50% maximum pairwise sequence identity or below. Furthermore, in metagenomics experiments typically large fractions of reads cannot be matched to any known sequence anymore because searching with sensitive but relatively slow tools (e.g. BLAST or HMMER3) through comprehensive databases such as UniProt is becoming too costly. Results: MMseqs (Many-against-Many sequence searching) is a software suite for fast and deep clustering and searching of large datasets, such as UniProt, or 6-frame translated metagenomics sequencing reads. MMseqs contains three core modules: a fast and sensitive prefiltering module that sums up the scores of similar k-mers between query and target sequences, an SSE2-and multi-core-parallelized local alignment module, and a clustering module. In our homology detection benchmarks, MMseqs is much more sensitive and 4â€“30 times faster than UBLAST and RAPsearch, respectively, although it does not reach BLAST sensitivity yet. Using its cascaded clustering workflow, MMseqs can cluster large databases down to $30% sequence identity at hundreds of times the speed of BLASTclust and much deeper than CD-HIT and USEARCH. MMseqs can also update a database clustering in linear instead of quadratic time. Its much improved sensitivity-speed trade-off should make MMseqs attractive for a wide range of large-scale sequence analysis tasks. Availability and implementation: MMseqs is open-source software available under GPL at https:// github.com/soedinglab/MMseqs
IntroductionDuring the last 8 years, sequencing costs have come down from 10 000 000$ to less than 1000$ for a human genome at 30 times coverage (http://www.genome.gov/sequencingcosts). As a consequence, protein sequence databases such as the UniProt () database have been growing by a factor of 2 every two V C The Author 2016. Published by Oxford University Press. All rights reserved. For Permissions, please e-mail: journals.permissions@oup.com years (), leading to longer search times, inflated and redundant results list, large memory requirements and saturating or decreasing sensitivities for informative sequence matches (). A solution is to compute a representative subset of sequences by clustering them by their similarity and selecting one representative per cluster. Such clustering schemes achieve a more even sampling, leading to better sensitivities in sequence searches (). UniRef provides representative subsets of UniProtKB clustered at 100%, 90% and 50% sequence identity (). Clustering schemes are also used in metagenomics projects to reduce the size and redundancy of the ever larger amounts of sequence data (). Several tools for clustering protein sequence databases have been developed. BLASTclust from the NCBI BLAST package is sensitive but slow. It uses greedy single-linkage clustering based on all-versusall blastp searches (). The fast tools CD-HIT, (), USEARCH () and kClust () share several similarities. First, they employ the same incremental, greedy clustering scheme, in which each database sequence (the 'query') is compared with the representative sequences of already established clusters. If one of the representative sequences is sufficiently similar, the query is added to this cluster or otherwise becomes the representative of a new cluster. Second, all three tools employ a k-mer word-based similarity prefilter that drastically reduces the number of slow but accurate Smith-Waterman alignments. The prefilters in CD-HIT and USEARCH count the number of common, identical k-mer words between sequences, with k  5 or 6 for USEARCH and k between 2 and 5 for CD-HIT. To obtain a sufficient number of common k-mers between sequences with only 50% residue-wise sequence identity, CD-HIT has to lower k to 2. But this leads to a high probability $ 1=20 k for chance k-mer matches. Therefore, the number of chance matches in an all-against-all comparison of N sequences of average length L is around NL 2 =20 k , which becomes huge for small k. Since each chance match costs a constant amount of time to process, short words lead to an enormous slow-down. kClust employs a k-mer-based prefilter that can even detect pairs at 2030% sequence identity at high speed. To keep the probability for chance matches low and speed high, it uses long words with k  6 or 7. But to increase sensitivity at the same time, it detects similar instead of just identical k-mers. For each k-mer in the query sequence, it computes a list of all k-mers with a BLOSUM62 bit score above a certain cut-off and finds identical matches to these similar k-mers in the database sequences. The prefilter then scores each database sequence by the sum of similarity scores of similar k-mers. A further challenge arising from the rapid progress in highthroughput sequencing is the need for sensitive but fast protein sequence search methods. A large fraction of metagenomics reads cannot be mapped to any known sequence from a cultivated organism anymore, because it has become too costly to search through the entire UniProt database using a sensitive but slow tool such as BLASTX (): It would take approximately 2398 CPU years to search with all 6-frame translated sequences from 2 10 9 reads of length 150 nucleotides through the current UniProt database using BLASTX. Instead, in most projects, much smaller databases are searched, such as KEGG GENOME (), a collection of high-quality genome sequences, or the MetaPhlAn () database of unique clade-specific marker genes (). This carries the risk of missing some of the most interesting matches, which do not conform to prior expectations. To address this challenge, a number of fast protein sequence search tools have been developed: Tachyon (), PAUDA (), PSimScan (), RAPsearch2 (), Lambda (), UBLAST () and DIAMOND (). The latter five, which are the most sensitive in this list, find exact matches of (spaced) k-mers and extend the alignment around them. MMseqs addresses the need for a clustering and search tool that is both fast and sensitive enough to be able to detect sequence matches down to $30% residue-wise sequence identity. While it uses the same core prefiltering algorithm as kClust, it has various important advantages: (i) Its organization into modules (prefiltering, alignment, clustering) and workflows increases flexibility and facilitates future extensions. (ii) Its search workflow can perform sequence searches. With a speed 1000 times faster than BLAST it finds similarities down to 30% sequence identity and is much more sensitive than similarly fast search tools. (iii) Its cascaded clustering workflow achieves much deeper clustering than kClust in a shorter time. (iv) Its database updating workflow adds sequences to a previously clustered set in linear time, obviating the need for frequent reclustering in quadratic time. (v) MMseqs is implemented highly efficiently, using SIMD (single-instruction-multiple-data) instructions to vectorize time-critical loops. (vi) It is parallelized using OpenMP to run on multi-core CPUs (vii) To save memory, the database can be divided into several parts and processed consecutively. (viii) Its prefilter uses a novel Z-score statistic for higher sensitivity and a score correction for compositionally biased sequence regions. (ix) It offers the greedy set cover algorithm for clustering, in addition to the simple, incremental algorithm used by kClust, USEARCH and CD-HIT, enabling deeper clusterings. (x) It performs exact SmithWaterman alignment based on the striped SIMD algorithm () instead of the approximate k-mer dynamic programming algorithm developed for kClust.