Motivation: In genome assembly, as coverage of sequencing and genome size growing, most current softwares require a large memory for handling a great deal of sequence data. However, most researchers usually cannot meet the requirements of computing resources which prevent most current softwares from practical applications. Results: In this article, we present an update algorithm called EPGA2, which applies some new modules and can bring about improved assembly results in small memory. For reducing peak memory in genome assembly, EPGA2 adopts memory-efficient DSK to count K-mers and revised BCALM to construct De Bruijn Graph. Moreover, EPGA2 parallels the step of Contigs Merging and adds Errors Correction in its pipeline. Our experiments demonstrate that all these changes in EPGA2 are more useful for genome assembly.
IntroductionGenome assembly is one of the most important tasks in numerous applied fields (). When using one software to reconstruct complete genome sequence from sequence data, researchers not only emphasize assembly results but also memory efficiency. Although many softwares have been developed for genome assembly, their balance between accuracy and memory efficiency are not satisfactory due to complex data structures. We previously published EPGA (), one de novo assembler which can resolve some problems caused by complex repetitive sequence regions. Although EPGA can get satisfactory assembly results, it does not have advantage about peak memory comparing with other popular assemblers. The bottleneck of EPGA's memory efficiency primarily exists in two steps: K-mers Counting and De Bruijn Graph Constructing, because EPGA requires that all reads and K-mers reside in memory. Such storage strategy ends up with the memory consumption growing dramatically as the number of reads is increasing. DSK () is one K-mer counting tool which partitions reads, and each partition is separately loaded in memory. BCALM () is one algorithm for building simple paths in De Bruijn Graph which clusters K-mers and iteratively loads each cluster in memory. For resolving memory problem in EPGA, we present EPGA2, which replaces some components in EPGA with DSK and BCALM. In addition, EPGA2 adds Errors Correction in its pipeline and parallels the step of Contigs Merging. The experimental results demonstrate that EPGA2 can produce more satisfactory contigs and scaffolds using small memory.
ConclusionIn this article, to resolve the memory efficiency problem in EPGA, we present EPGA2, which updates some modules in EPGA. In addition, for reducing running time, EPGA2 parallels Contigs Merging. For improving accuracy of assembly results, EPGA2 adds Errors Correction using BLESS. The experimental results demonstrate the balance between assembly results and memory efficiency of EPGA2 is satisfactory. EPGA2 should be particularly appropriate for researchers with limited computing resources.C.Num, the number of contigs; C.CN50, the CN50 of contigs; C.Cov, the coverage of contigs; S.Num, the number of scaffolds; S.CN50, the CN50 of scaffolds; S.Cov, the coverage of scaffolds; time, running time; PM, peak memory. Last column is the smallest peak memory and corresponding assembler about other popular assemblers.