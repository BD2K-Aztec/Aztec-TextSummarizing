Analysis of differential gene expression by RNA sequen-cing rnase q is frequently done using feature counts, i.e. the number of reads mapping to a gene. However, commonly used count algorithms (e.g. ht seq do not address the problem of reads aligning with multiple locations in the genome multi reads or reads aligning with positions where two or more genes overlap (ambiguous reads). Rcount specifically addresses these issues. Furthermore, Rcount allows the user to assign priorities to certain feature types (e.g. higher priority for protein coding genes compared to rrna coding genes) or to add flanking regions. Availability and implementation: Rcount provides a fast and easy to use graphical user interface requiring no command line or programming skills. It is implemented in C++ using the seq an www seq an. de) and the Qt libraries qt project org. Source code and 64 bit binaries for (Ubuntu) Linux, Windows (7) and MacOSX are released under the GPLv3 license and are freely available on git hub com mw schmid rcount. Contact: marc schmid gmx ch Supplementary information: Test data, genome annotation files, useful Python and R scripts and a step by step user guide (including run-time and memory usage tests) are available on git hub com mw schmid rcount
introduction rnase q is the method of choice for transcriptional profiling and differential expression (DE) studies. For DE analysis, methods based on negative binomial modeling, such as the popular de seq () and edgeR (), have been shown to outperform other methods in terms of specificity, sensitivity and control of false positives (). Current work flows for DE analysis generally involve the (i) alignment of the short reads to a reference genome, (ii) quantification of expression levels and (iii) comparison between different treatments, tissue cell types and time points (). Read counting and read summarization are essential steps in any rnase q workflow. However, they have received little attention. Specifically for rnase q counting is not as simple as it may appear. First, a read may align multiple times with the genome multi reads. Second, several genes may overlap at a given position within the genome. Reads aligning with those positions are ambiguous with respect to the gene they originate from (ambiguous reads). Third, alignments can span exon junctions exon junction reads). Furthermore, a gene may have several isoforms. However, DE analysis is often performed using the total number of reads per gene. Popular open source tools for read counting, such as ht seq www huber embl de user sanders ht seq bed tools () and feature counts (), do not specifically address all three issues. multi reads are not treated specifically by any of these programs and are generally discarded, although this problem has been addressed for chips eq data analysis (). Ambiguous reads are counted repeatedly for each gene by bed tools and feature counts (optionally), whereas ht seq discards them. ht seq and feature counts both consider exon junction reads, whereas bed tools does not. e range addresses all three problems, but uses rp km (reads per kilobase per million) instead of counts throughout the whole algorithm. Moreover, a conversion to counts during the algorithm is not possible (). Here we describe Rcount, a fast and simple GUI tool for flexible rnase q read counting. It builds on the algorithm described in, and further allows for editing the genome annotation and assigning priorities to certain feature types see for details on genomic feature types).

description rcount takes read alignments files (BAM, Binary Alignment/ Map) and a reference genome annotation gff gtf bed General Feature format gene Transfer format browser Extensible Data) as input, and counts the number of reads per gene, taking into account multi reads ambiguous reads and exon junction reads (). It has three modules: rcount multi reads rcount format and rcount distribute. rcount multi reads assigns weights to each alignment of a multi read (). The weight H i of an individual alignment i is calculated using a score S i divided by the sum of scores from all alignments of the multi read (is currently implemented as the sum of coverage (number of reads per base) originating from uniquely aligned reads at the position of the alignment i and the surrounding region (the size can be set by the user). If an alignment spans an exon junction, S i equals to the number of uniquely aligned reads spanning the same exon junction. Thus, if a multi read has both types of alignments, the un gapped ones are generally preferred. The weight is automatically added as x wfh i tag to the alignments in the BAM file. rcount format reads the reference genome annotation in GFF/ gtf bed format, displays the structure of the genome annotation and saves it in an XML format required by rcount distribute during this process, the user can extend the genes (add flanking regions) or remove features from the annotation. Depending on the library preparation protocol, some of the features in the genome annotation are less likely to be sequenced (e.g. rrna coding genes with poly a selective library preparation protocols). The user can choose to remove these features or to assign a lower priority to them. If a read aligns to a location where two genes with different priorities overlap, it is automatically assigned to the one with higher priority. rcount distribute sums up the weights of the alignments (hits) per gene in two steps. In the first step, all hits are mapped to all genes (i.e. their transcripts). Transcripts of truly expressed genes should generally have at least some hits in the vicinity of their 3 0 end (e.g. due to poly a tail priming during library preparation) and or at least a minimal total number of hits user specified. Transcripts not matching these criteria are discarded during the first round (). During the second step, the hits are divided into unambiguous and ambiguous. The unambiguous hits are assigned first and subsequently used to proportionally distribute the ambiguous hits (). The transcripts are re filtered using the same criteria as before. The final expression value c f of a gene is then calculated as the sum of hits assigned to any of its transcripts (). The final output is one count table per sample. In addition to the final expression values, the output table also contains the number of unambiguous and ambiguous (before and after distributing them) hits per gene (either on the whole gene length, or only within a certain number of bases from the 3 0 end of the transcript, which can be specified by the user). To extract a certain column or to merge multiple samples for downstream analyses, an R script is provided on git hub comm w schmid Rcount.
