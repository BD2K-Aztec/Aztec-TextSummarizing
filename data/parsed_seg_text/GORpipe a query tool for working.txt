Motivation: Our aim was to create a general purpose relational data format and analysis tools to provide an efficient and coherent framework for working with large volumes of DNA sequence data. Results: For this purpose we developed the g or pipe software system. It is based on a genomic ordered architecture and uses a declarative query language that combines features from SQL and shell pipe syntax in a novel manner. The system can for instance be used to annotate sequence variants, find genomic spatial overlap between various types of genomic features, filter and aggregate them in various ways. Availability and Implementation: The g or pipe software is freely available for non-commercial academic usage and can be downloaded from www next code com
introduction rapid advances in high throughput sequencing technology have introduced formidable data management challenges for bioinformatic ians. Conventional relational database management systems (RDBMS) are ill suited to the task of dealing with high volume of sequence reads and sequence variation data, partly because of their requirements for fine grained transactions and partly because of their legacy command set and data structures. In the field of bioinformatics, the exodus from the on hand relational databases has introduced a myriad of specialized tools and file formats, that are often incompatible, causing much computation and IO being spent on data conversions and developer's time to master a large set of disparate tools the work presented here originates over 5 years back within deCODE's large scale population based sequencing project in Iceland (). The aim was to create general purpose relational data format and analysis tools in order to be able to annotate sequence variants, find genomic overlap between various types of features, filter and aggregate them in various ways. Essentially, a replacement for the conventional RDBMS; capable of handling sequence and variation data from hundreds of thousand samples and analyze them in the context of other genomic features. Having worked with very large SNP genotype datasets in the past, our key observation was that in order to support many of the envisioned usage scenarios, such as range queries, data joins and aggregation, we would need a genomic ordered data architecture, where the analysis algorithms largely treat the input data as ordered streams furthermore for on-going sequence analysis, such as in clinical practice or in very large research projects, where practically unlimited number of variations is captured with modern sequencing technology, sparse data formats are needed to represent the sequence variations, as compared to the finite grid structures used for chip based SNPs in the g was era. Rather than using the convention of accessing the data via an index, based on an ID scheme such as r sids the variation data has to be identified and accessed solely based on its position and the sequence difference from a particular reference genome build. In order to achieve the above, we developed a system based on a genomic ordered relational architecture; a g or format and a query system, using a declarative relational query language, which syntax is a hybrid of Unix shell command pipe syntax and SQL. By design, our system works only for the analysis downstream of the sequence read alignment step, and while it does incorporate some functions for variation calling, the primary focus has been to develop query tools for tertiary analysis. While the g or data format shares many features with other earlier formats such as BED () and BAM () and the more general purpose format tab ix (), it differs by being an index free tabular storage format, where the first two columns representing the genomic position must be consistently ordered to allow for a binary like seek. Similarly, when it comes to the data layout, we emphasize relational normalization against de-normalization and columnar storage against excessive usage of attribute value columns. This we do based on the same arguments that have been extensively used in the literature on RDBMS when preaching good relational schema designs for ease of data updates and querying. As to be expected, our g or pipe program overlaps with many tools that have been developed in recent years such as bed tools (), Galaxy (), vcf tools (), g atk (), an novar () and snp eff snp sift (, b) to name few. For instance, many of these tools include features for intersecting and annotating variation data. Our design is, however, very different in the sense that it is more of a query system or a language based approach. In this regard, it has similarities with the work on the genome query language (GQL) (). Our approach does indeed follow the Unix design philosophy of combining 'many small sharp tools' with clear and simple interfaces. That being said, we made a conscious decision not to implement the system using Linux shell commands and rely on the operating systems pipe mechanism, although we also recognized many benefits of using that approach. Rather, we implemented our own multi-threaded command pipe framework, which runs in a single JVM instance, allowing us to create lightweight pipes with full control. This enables us to create efficient queries consisting of a very high number of commands (pipe steps) and importantly, to create declarative and nested streams which are seekable, unlike regular process substitutions in shells. This allows us also to optimize the query execution plan, although our current implementation does nowhere near exhaust the possibilities on that frontier. In the rest of this paper we introduce the g or architecture, briefly describe our tab delimited storage format and explain how other genomic ordered tabular formats can be used with our system. To do this, we introduce the basic g or command, which reads the data from one or more files. We also introduce g or tables (dictionaries), which provide a relational abstraction to equivalent data in multiple files. We then give an informal description of the g or query language. A formal definition of the syntax and a detailed implementation description is, however, outside the scope of this work. Rather, we like to demonstrate the unique nature of the g or pipe system and some of its commands through selected examples, something we think is more intuitive and valuable for practicing bioinformatic ians. Additionally, we briefly describe a related NOR syntax, for non ordered relational data, which together with the g or syntax, provides a powerful framework for working with both clinical and genetic data.

discussion in this paper, we have presented a software system developed around genomic ordered relations and a novel declarative query language. The syntax combines in a novel manner features from both Unix shell commands and SQL. As with most new programming and query languages, it is not so much a question of enabling something that wasn't possible before, but rather, to bring forth an elegant language which allows a good data abstraction, promotes and facilitates efficient query patterns. We do this by combining relational data abstraction patterns from the RDBMS world with pipe shell syntax to implement relational operators. As we show, this flavour of query syntax is not limited to ordered genomic data and is also very convenient for time ordered data or generic relational data. Indeed, since each command is isolated syntactically, we find this type of language structure in many ways easier to extend and work with than languages such as SQL. Here, we have demonstrated the versatile nature of our syntax to express complex queries. The g or pipe system is also easily integrated into Bash pipe commands or Python scripts. Thus, if the expressive power of our declarative g or pipe syntax is exhausted, one can mix it with imperative programming languages. While the relational concepts are not new, our implementation is very different from existing RDBMS. It is based on a genomic ordered streaming architecture which is better suited to deal with the high volume of sequence data which many sites are just starting to grapple with. Just like SQL, our g or pipe command set goes beyond operations that can be mapped to conventional relational algebra and many of the g or pipe commands have similarity with the more recently introduced SQL windowing functions. Unlike in SQL, for simplicity and performance reasons, g or pipe only supports a single genomic ordering scheme. We do indeed find that our system performs quite well, although we have yet not undertaken a formal comparison study. For an example, in the variant effect prediction example, which we provide in Section 1.3 in the supplementary material, we see performance which is ten times faster than the comparison. Also, using version 2. 10.1 of bed tools an intersection of a dbsnp bed table against itself with the '-sorted' option, returns over 118 million rows in 3:36 while the same type of g or pipe query performing as np snp join on equivalent go rz file returns the same number of rows in 3:25. An informal performance comparison between the file formats go rz and tab ix files, in Section 1.5 in the supplementary material, shows that go rz provides almost two times better streaming efficiency for g or pipe than the latest Java implementation of tab ix and equivalent seek performance. Although our simple approach of using a binary like search, as compared to using something like an r tree structure, may not be as well suited for data files where there are features with very different segment sizes, we argue that features of unlike nature, e.g. due to very different size categories, are indeed better split up into separate tables where appropriate max seg options can be applied, since this allows for better streaming utilization in range queries. This approach can indeed also be applied on 'the physical file level', regardless of whether the data is stored in a single file or a collection of files. As to be expected, some of the language features in g or pipe have been introduced elsewhere in similar form, although not in as coherent manner. Recently, it has been brought to our attention, by one of the reviewers, that support for named columns has for instance been introduced in bio awk an extension of AWK. Motivated by the GROUP BY clause in SQL, we introduced the gc option in our aggregate commands as well as some other commands where we think grouping is relevant. It turns out that similar grouping option can be found in the command line utility data mash. The fact that g or pipe supports a 'fork write' to simultaneously output data to multiple files (partitions) and many commands which support grouping (-gc) and equi join options x lxr makes it easy to express queries that process multiple samples and share the overhead of accessing non sample reference data for annotations or filtering. The declarative nature of our syntax means that there is room for many additional optimizations behind the scenes. This may involve changing the order of commands execution and predicate push-down, combining command steps, use of adaptive buffer sizes, fine tuning of the memory model and rely on more powerful iterator abstraction in our implementation. Also, the use of more metadata and more sophisticated query optimization may eliminate the need for the max seg option in the genome spatial joins. On the near term roadmap are features to allow users to create new commands and functions, leveraging dynamic class loading, based on any JVM language such as Scala, Jython and re nj in R. We also foresee an integration with the had oop stack, including the use of HDFS, Parquet columnar storage and drivers relying on spark sql (). Finally, we are working on an extension of the g or pipe system with a full blown elastic cloud based database engine with support for data partition and distributed computing conflict of Interest: none declared.
