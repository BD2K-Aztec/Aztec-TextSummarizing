Motivation: Counting the number of occurrences of every km er (substring of length k) in a long string is a central subproblem in many applications, including genome assembly, error correction of sequencing reads, fast multiple sequence alignment and repeat detection. Recently, the deep sequence coverage generated by next generation sequencing technologies has caused the amount of sequence to be processed during a genome project to grow rapidly, and has rendered current km er counting tools too slow and memory intensive. At the same time, large multicore computers have become commonplace in research facilities allowing for a new parallel computational paradigm. Results: We propose a new km er counting algorithm and associated implementation, called Jellyfish, which is fast and memory efficient. It is based on a multithreaded, lock free hash table optimized for counting km ers up to 31 bases in length. Due to their flexibility, suffix arrays have been the data structure of choice for solving many string problems. For the task of km er counting, important in many biological applications, Jellyfish offers a much faster and more memory efficient solution.

introduction given a string S, we are often interested in counting the number of occurrences in S of every substring of length k. These length k substrings are called km ers and the problem of determining the number of their occurrences is called km er counting. Counting the km ers in a DNA sequence is an important step in many applications. For example, genome assemblers using the overlap layout consensus paradigm, such as the Celera () and Arachne () assemblers, use km ers shared by reads as seeds to find overlaps. Statistics on the number of occurrences of each km er are first computed and used to filter out which km ers are used as seeds. Such km er * To whom correspondence should be addressed. count statistics are also used to estimate the genome size: if a large fraction of km ers occur c times, we can estimate the sequencing coverage to be approximately c and derive an estimate of the genome size from c and the total length of the reads. In addition, in most short read assembly projects, errors are corrected in the sequencing reads to improve the quality of the final assembly. For example use km er frequencies to assess the likelihood that a misalignment between reads is a sequencing error or a genuine difference in sequence. A third application is the detection of repeated sequences, such as transposons, which play an important biological role. De novo repeat annotation techniques find candidate regions based on km er frequencies (). The counts of km ers are also used to seed fast multiple sequence alignment (). Finally, km er distributions can produce new biological insights directly used km ers frequencies with large k (20  k  100) to study the mechanisms of sequence duplication in genomes. We consider the km er counting problem in the context where the input string S is either one DNA sequence or a concatenation of many DNA sequences, and the alphabet is ={A,C,G,T }. The main application to which we apply our new km er counting algorithms here is counting km ers in sequencing reads from large genome sequencing projects where the length n of the sequence to process is equal to the length g of the genome sequenced times the coverage c of the sequencing project (n = gc). Recent sequencing techniques, using shorter reads with a much deeper coverage (), generate large amounts of sequence and provide with a major challenge for genome assembly and for km er counting. For example, the giant Panda () sequencing project generated 73 coverage yielding 176 GB of sequence, much larger than the 510 coverage a sequencing project using traditional Sanger methodology would generate. Of course, km er counting can be naively implemented using a simple hash table, where keys are the km ers and the stored values are the counts. However, this strategy is extremely slow and implementing multithreaded access to the hash table via standard locking mechanisms results in slower performance than a single threaded implementation (). Typically, more advanced km er counters such as tally mer () have been based on the suffix array data structure. Despite the recent algorithmic progress to compute the suffix array of a string, it remains a relatively expensive computational operation. Moreover, in sequencing applications, memory requirements for a suffix array grow linearly with the

conclusion increasingly practical computation on large collections of genomic sequences requires software which can use parallel computer architectures that are commonly available today. The lock free operations used in Jellyfish permit the design of truly concurrent data structures that are fast in serial mode and scale almost linearly with the number of processors used. Jellyfish can tackle km er counting on the large datasets available today. As short read sequencing projects become more common and achieve larger and larger coverage, efficient km er counting will become increasingly important. The hash table at the heart of Jellyfish is a versatile and widely used data structure. Proper optimizations make jellyfish s hash table competitive in both time and space even when compared with other data structures specifically designed for string processing, such as suffix arrays, as implemented in competing km er counting packages.
