We present rust bio the first general purpose bioinformatics library for the innovative Rust programming language. rust bio leverages the unique combination of speed, memory safety and high level syntax offered by Rust to provide a fast and safe set of bioinformatics algorithms and data structures with a focus on sequence analysis.

introduction with ever increasing amounts of experimental data being generated, their computational analysis becomes increasingly challenging. For novel or custom problems where carefully engineered high performance standalone tools (like read mappers) are not yet available, general purpose bioinformatics libraries can help to minimize the coding effort. Bioinformatics libraries are published for many popular programming languages, e.g. seq an for C, Biopython, Bioperl and BioRuby (). Choosing the programming language for a specific task usually entails a tradeoff between execution and development speed. low level system programming languages like C or C provide optimal performance at the cost of increased complexity. Higher level languages like Python or Perl provide a more concise syntax while leading to computational overhead introduced by online memory management (e.g. reference counting or garbage collection), type inference and not being compiled but interpreted during execution. Often, the combination of a high level language with some carefully engineered implementations of a bioinformatics library is a good choice to quickly solve a problem with reasonable performance. However, the amounts of data the bioinformatics community is facing in the coming years and the need to handle nature's resources carefully implies that using a high performance compiled language is still beneficial for certain problems. Recently, Rust (http://www.rust-lang.org) has gained attention as a new programming language combining speed with memory safety and high level syntactical features. Being compiled with LLVM (), Rust has many advantages of low level system programming languages, such as speed and a small memory footprint. Supporting automatic type inference, its code is often less verbose than C or C code. With Rust, type inference happens at compile time, such that runtime overhead (appearing with scripting languages like Python) can be avoided. The key feature of Rust is a concept of ownership and borrowing of variables, that enables the compiler to automatically decide about lifetime of objects during compile time, making an online memory management superfluous without requiring manual freeing of resources. At the same time, this concept prevents common sources of errors with low level languages like accessing invalid memory regions. Finally, the ownership concept enforces thread safety such that race conditions can not occur. These features make Rust a promising solution to above tradeoff problem. In this work, we present rust bio the first general purpose bioinformatics library for the Rust programming language. rust bio provides a high level fast and safe API for many state of the art data structures and algorithms used in bioinformatics.
