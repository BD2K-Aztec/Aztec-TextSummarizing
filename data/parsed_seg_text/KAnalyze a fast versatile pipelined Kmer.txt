Motivation: Converting nucleotide sequences into short overlapping fragments of uniform length, km ers is a common step in many bioinformatics applications. While existing software packages count km ers few are optimized for speed, offer an application programming interface (API), a graphical interface or contain features that make it extensible and maintainable. We designed k analyze to compete with the fastest km er counters, to produce reliable output and to support future development efforts through well architected documented and testable code. Currently, k analyze can output km er counts in a sorted tab delimited file or stream km ers as they are read. k analyze can process large datasets with 2 GB of memory. This project is implemented in Java 7, and the command line interface (CLI) is designed to integrate into pipelines written in any language. Results: As a km er counter, k analyze outperforms Jellyfish, DSK and a pipeline built on Perl and Linux utilities. Through extensive unit and system testing, we have verified that k analyze produces the correct km er counts over multiple datasets and km er sizes.

introduction km er izing sequence data is a necessary step for many bioinformatics applications. km er based approaches are used to assemble reads, detect repeats, estimate read depth, identify protein binding sites (), find mutations in sequencing data () and perform a variety of other tasks. As new applications are created, it is important to have reliable software for generating km ers. If developers choose to rewrite km er code, there is an additional risk of introducing bugs that can affect results. This problem is compounded when algorithms become more complex, such as counting km ers in large datasets with limited memory. The time required to develop and to test a fast algorithm becomes prohibitive. Existing tools often lack features that make them more available to new applications. Few have an API or document return codes. We created k analyze as a fast reusable km er toolkit capable of running on multiple platforms. It is packaged with an API for integration into other programs as well as a CLI for manual execution and scripted pipelines. The count module has a graphical mode for desktop use. Because it is designed for longevity, the project is organized, documented and tested. The source code includes unit tests to quickly verify accuracy as the code changes. We ran tests on several datasets and compared the results with other km er software, including a Perl pipeline we built for verifying results. Throughout the design process, the best practices for scientific computing were observed (). k analyze makes both speed and accuracy available to km er applications.

conclusion k analyze offers an extensible API and a complete CLI for km er processing tools. These interfaces allow k analyze to be integrated directly into Java programs via the API, or into pipelines of any language via the CLI. For desktop users, a graphical interface is included for the count module. With carefully chosen algorithms and data structures, k analyze can perform at a level commensurate with programs compiled to native code. Through extensive testing, we are confident that it produces accurate results. k analyze is designed to survive years of maintenance and feature additions. The source is distributed under the GNU Lesser GPL to restrict its usage as little as possible. We encourage others to contribute to the k analyze project.
