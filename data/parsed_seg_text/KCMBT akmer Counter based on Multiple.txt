Motivation: A massive number of bioinformatics applications require counting of k length sub-strings in genetically important long strings. A km er counter generates the frequencies of each k length substring in genome sequences. Genome assembly, repeat detection, multiple sequence alignment, error detection and many other related applications use a km er counter as a building block. Very fast and efficient algorithms are necessary to count km ers in large data sets to be useful in such applications. Results: We propose a novel trie based algorithm for this km er counting problem. We compare our devised algorithm km er Counter based on Multiple Burst Trees kc mbt with available all well known algorithms. Our experimental results show that kc mbt is around 30% faster than the previous best performing algorithm KMC2 for human genome dataset. As another example, our algorithm is around six times faster than jellyfish 2. Overall, kc mbt is 20â€“30% faster than KMC2 on five benchmark data sets when both the algorithms were run using multiple threads. Availability and Implementation: kc mbt is freely available on git hub (https://github.com/abdul

introduction string algorithms have been frequently used in bioinformatics as genomic sequences can be represented by strings from an alphabet of distinct characters. A substring of length k in a string is defined as a km er where k is a positive integer. km ers in genomic sequences have been utilized to perform various analyses on the sequences. Numerous applications require counting the occurrences of particular km ers. A km er counter computes the abundance of every unique km er in a string or a set of strings. It has become an elementary building block for various bioinformatics applications. Frequencies of km ers along with the coverage information have been used in assembling genomic sequences (burst tries to store km ers consideration of k  x mers and unifying a km er and its count in a single unit. Currently kc mbt is the fastest km er counting algorithm. Experimental results in conjunction with theoretical analysis establish our statement.

discussion kc mbt outperforms every other km er counter by a large margin. KMC2 is currently the best performing km er counter. It requires a low internal memory and some not so much inexpensive disk storage. It is practically a very fast km er counter with several good options. We have collected data sets of the five genomes used in our experiments from available links in the published paper of KMC2 (). In this KMC2 paper the authors also explain how they ran the other programs. We have tried to employ the same values for the underlying parameters except for the number of cores. We have shown in the previous section how our ideas were fruitful in counting km ers efficiently. Our algorithm chooses burst tries to store km ers. Burst trie is very cache efficient for keeping strings in approximate sorted order. We need that for holding somewhat similar km ers together. For large genomes, there exist enormous numbers of km ers. A single tree is not enough to store all of them efficiently. Insertion and traversal become very time expensive operations because of the large height of the tree. We employed hundreds of trees to resolve this issue. When the number of trees is large, we can remove some prefix bits from each km er to index its corresponding tree. These extra bits can be used to store counts. Keeping a km er and its count together in an unsigned 64 bit word is indeed helpful. Since the alphabet size is 4, each symbol needs at least 2 bits. If we want a 5 symbol prefix, there will be 4 5 or 1024 trees. We ran kc mbt for prefix 07 symbols. For 04 value, some of these tree heights become large. For a value of 7, there are a massive number of trees, and cache misses occur regularly. We have found good results for values 5 and 6. It is not fruitful to insert one km er at a time. If we choose this option, in some of the cases the running time rises more than 25% because of frequent cache swapping. Therefore we choose a large buffer to cache these km ers and insert them at a time, which is very cache friendly. Our first attempt was generation and insertion of km ers. There were two phases. The first phase inserted these km ers into trees and the second phase traversed them to accumulate all km ers with their counts. But this idea was not good enough to outperform KMC2 in some cases. We have adapted the very good idea of using of k  x mers from KMC2. We have followed almost the same idea to generate these k  x mers. KMC2 generates them from super km ers stored in disk files. We form them from km ers in the first phase. Experimental outcomes prove the usefulness of this idea. It eliminates many insertion and traverse counts. We generally use k  x mers where 0 x 3. A value of more than 3 for x works better if they have enough duplicate occurrences. We have noticed that 0 x 3 performs better in our experiments in the second phase, we traverse k  x mer trees, and count the number of occurrences of each k  x mer. We then split each k  x mer into km ers and insert them into km er trees. We could have improved the time by not inserting the km ers occurring in the first positions of k  x mers. If we did that, we will have to merge at a later stage. The process would be complicated. As the total time spent in the last two phases is not that much, we have avoided this complexity kc mbt a km er counter
