We developed mol biolib to address the need for adaptable next generation sequencing analysis tools. The result is a compact, portable and extensively tested Cþþ11 software framework and set of applications tailored to the demands of next generation sequencing data and applicable to many other applications. mol biolib is designed to work with common file formats and data types used both in genomic analysis and general data analysis. A central relational database like Table class is a flexible and powerful object to intuitively represent and work with a wide variety of tabular datasets, ranging from alignment data to annotations. mol biolib has been used to identify causative single nucleotide polymorphisms in whole genome sequencing, detect balanced chromosomal rearrangements and compute enrichment of messenger RNAs (mRNAs) on microtubules, typically requiring applications of under 200 lines of code. mol biolib includes programs to perform a wide variety of analysis tasks, such as computing read coverage, annotating gen-omic intervals and novel peak calling with a wavelet algorithm. Although mol biolib was designed primarily for bioinformatics purposes , much of its functionality is applicable to a wide range of problems. Complete documentation and an extensive automated test suite are provided. Availability: mol biolib is available for download at: http://sourceforge net projects mol biolib Contact

introduction next generation sequencing requires a data analysis approach capable of handling large, complex and varied datasets, from large sets of reads to complex polymorphisms to existing feature files. In addition, the competitive nature of research demands rapid development of methods that are flexible enough to integrate new and quickly evolving algorithms. Tools have been developed to address these needs, such as g atk (). However, packages written in Java (e.g. g atk require the maximum memory heap space to be specified at run time (), limiting how the input data are formatted and handled. For example, a coverage program would require more memory to compute coverage of a query ordered SAM file versus a position ordered SAM file, because a sliding window of coverage can not be used. Programs written in C do not require the heap size to be specified and are only limited by the amount of available memory. Other packages written in C have their strengths, but they also have limitations that suggest a niche for our software, mol biolib. Arachne (), the .NET Bio project by outer curve Foundation outer curve 2012) and ncbi s C Toolkit () provide many functions, but are not compact and do not always clearly identify the primary objects. Furthermore, the .NET Bio project is specific to the Windows environment () and Arachne is specific to a particular Linux environment. IBM's genomic tools () has many very useful tools, but addresses common bioinformatics tasks at a lower level than mol biolib such as providing command line tools rather than a unified program to generate chips eq output. Other packages, such as Bio (), lib sequence () and TIGR (), are targeted toward specific applications and not designed to provide breadth of functionality. The package that most closely resembles mol bio libs philosophy is seq an (), though it is written in an older version of C and thus does not take advantage of the variadic templates or other modern features of C11 iso iec 2011). mol biolib fills the need for a platform independent extensively tested, compact and efficient C11 library and an extensive set of bioinformatics applications that can be used to analyze data and rapidly develop new tools. mol bio libs library includes a variety of useful objects and functions, such as a relational database like object, a text file reader object that simplifies data input, statistical functions and peak calling methods that can operate on any array of values, such as per base sequence coverage. In addition, mol biolib includes a broad range of tools, such as to generate coverage, hits of reads to features and chips eq all in one unified package. The design of mol biolib is based on four principles. The first is to simplify bioinformatics programming in C11, achieved by developing a library that includes many common bioinformatics tasks. For example, C11 requires programmers to write specialized data structures to sort associated data keeping them together, such as feature information associated with a position. Additionally, to iterate either sequentially or randomly through a tab separated values (TSV) file and select values from specific columns would require the creation of a function to split * To whom correspondence should be addressed.  The Author(s) 2012. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/3.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited. a line on tabs and constructs to index and traverse a text file. These, and many other common tasks, are built into mol biolib thus greatly simplifying the code one needs to write. It is hoped that mol biolib will allow bioinformatic ians to consider C11 as a possible language of choice. Second, mol biolib is efficient. C11 is used because it is the new standard that introduces constructs for making objects such as Table. C11 is efficient since it is a compiled language with no inherent restriction on memory heap size at run time. Templates are used extensively to compact code, avoid inefficient virtual table lookups and maintain type safety. Objects and method parameters are often templated so that they may be in-lined by the compiler. Third, mol biolib promotes clarity and compactness by consolidating common operations into a concise set of objects. We also provide an extensive library of functions that are not intrinsic to one object, such as those that convert one data type to another, e.g. split string converts a string to a vector 5string4. Given the range of problems mol biolib addresses, the source code is compact: 10 000 lines of code and comments for the core objects and functions. Among the 101 included applications, 86% are coded in fewer than 200 lines and 59% in fewer than 100 lines. In contrast, without such a framework, the user would have to code the thousands of lines of code to reproduce mol bio libs functionality. Finally, mol biolib is extensively tested and facilitates easy testing and debugging of its applications. Automated tests are provided for all objects and functions. Additional validation of the code base comes from extensive application of mol biolib to many molecular biology projects (; Raif S. Geha, manuscript in preparation). To simplify use of mol biolib all libraries are include files following the Boost convention (). Debugging and memory checking is thus facilitated with tools such as with Valgrind (; Seward and) since applications in mol biolib consist of a main program file with many include files. Additional input and programming checks are incorporated into the framework through optional compiler flags.

discussion mol biolib fills the need for an efficient, reliable and compact C11 bioinformatics framework. It is portable across many platforms and aligner formats and is fully documented. mol biolib is unique in offering complete analysis programs for a variety of other very common tasks not addressed by other toolkits, from feature hit counts to coverage to chips eq. mol biolib classes offer considerable power and convenience for creating novel analysis applications. A central and very general Table class simulating the functionality of a database eases construction of many programs. The Table class is based on a collection vectors, thus having a small memory overhead compared to other data structures such as a map. Capacity for larger datasets is only limited by the amount of available memory. File readers provide efficient methods to perform ubiquitous file I/O tasks. These classes will have general utility for application development beyond the specific needs of computational biology. As mol biolib gains adoption, we aim to incorporate many of the applications both user contributed and those developed for our projects into the main distribution through the SourceForge. net code repository mechanism.
