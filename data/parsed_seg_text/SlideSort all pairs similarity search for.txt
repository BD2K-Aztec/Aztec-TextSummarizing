Motivation: Recent progress in DNA sequencing technologies calls for fast and accurate algorithms that can evaluate sequence similarity for a huge amount of short reads. Searching similar pairs from a string pool is a fundamental process of de novo genome assembly, genome wide alignment and other important analyses. Results: In this study, we designed and implemented an exact algorithm slide sort that finds all similar pairs from a string pool in terms of edit distance. Using an efficient pattern growth algorithm, slide sort discovers chains of common km ers to narrow down the search. Compared to existing methods based on single km ers our method is more effective in reducing the number of edit distance calculations. In comparison to backtracking methods such as BWA, our method is much faster in finding remote matches, scaling easily to tens of millions of sequences. Our software has an additional function of single link clustering, which is useful in summarizing short reads for further processing. Availability: Executable binary files and C++ libraries are available at

introduction due to the dramatic improvement of DNA sequencing, it is required to evaluate sequence similarities among a huge amount of fragment sequences such as short reads. We address the problem of enumerating all neighbor pairs in a large string pool in terms of edit distance, where the cost of insertion, deletion and substitution is one. Namely, given a set of n sequences of equal length , s 1 ,...,s n , the task is to find all pairs whose edit distance is at most d,It is conventionally called all pairs similarity search. All pairs search appears in important biological tasks. For example, it is required in finding seed matches in all pairs alignment necessary in sequence clustering (). Such alignments can then be used to detect and correct errors in short reads (). In the first step of de novo genome assembly (), short * To whom correspondence should be addressed. reads are decomposed to km ers and suffix prefix matches of length k 1 are detected. In most cases, exact matches are employed due to time constraint. Using approximate matches, the length of contigs can be extended, which leads to final assembly of better quality. This problem reduces to all pairs similarity search by collecting all k 1 prefixes and suffixes into a sequence pool. From the output, only prefix suffix pairs are reported. Basically, most popular methods solve the search problem by either of the following two approaches or a combination of them i Finding a common km er and verify the match (). (ii) Backtracking in an index structure (i.e. suffix array and fm index (). The first type finds common km ers in strings (i.e. seed match) and verify if two strings sharing the km er are neighbors indeed by extending the match with dynamic programming. It works perfectly well when the string is long enough. However, when strings are short and the threshold d is large, the length of shared km ers falls so short that too many candidate pairs have to be verified. The second type stores the strings into an index structure, most commonly a suffix array. Then, similar strings are found by traversing nodes of the corresponding suffix tree. This approach works fine if d is small, e.g. d  2, and employed in state of the art short read mapping tools such as BWA (), bowtie () and SOAP2 (). However, it becomes rapidly infeasible as d grows larger, mainly because the complexity is exponential to d and no effective pruning is known. el and and seq map () decompose sequences into blocks and use multiple indices to store all k concatenations of blocks. Obviously, it requires much more memory compared with BWA, which would be problematic in many scenarios. multi sorting () uses multiple substring matches to narrow down the search effectively, but it can find neighbors in terms of Hamming distance only. Our method termed slide sort finds a chain of common substrings by an efficient pattern growth algorithm, which has been successfully applied in data mining tasks such as item set mining (). A pattern corresponds to a sequence of substrings. The space of all patterns is organized as a tree and systematically traversed. Our method does not rely on any index structure to avoid storage overhead. Instead, radix sort is employed to find equivalent strings during pattern growth. To demonstrate the correctness of our algorithm, the existence of a common substring chain in any neighbor pair is proved first. In addition, we deliberately avoid reporting the same pair multiple times by duplication checking. As a result, our method scales easily to 10 million sequences and is page 465 464470

conclusion in this study, we developed a novel method that enumerates all similar pairs from a string pool in terms of edit distance. The proposed method is based on a pattern growth algorithm that can effectively narrow down the search by finding chains of common km ers. Using deliberate duplication checks, the number of edit distance calculations is reduced as much as possible. slide sort was evaluated on large datasets of short reads. As a result, it was about 103000 times faster than other index based methods. All these results demonstrate practical merits of slide sort. One naturally arising question is if slide sort can be used for mapping. In fact, it is possible by storing the pattern tree () in memory, and using it as an index structure. However, the index would cost too much memory for genome scale data. What we learned from this study is that all pairs similarity search is essentially different from mapping in that one can employ pruning and dynamic memory management. Thus, all pairs similarity search is not a subproblem of mapping and deserves separate treatment. In future work, we would like to implement slide sort with parallel computation techniques. Recent progress in hardware technology enables end users to use many types of parallel computing scheme such as SSE and gp gpu. slide sort would be further improved by using these technologies.
