Motivation: The deluge of current sequenced data has exceeded Moores Law, more than doubling every 2 years since the next generation sequencing (NGS) technologies were invented. Accordingly, we will able to generate more and more data with high speed at fixed cost, but lack the computational resources to store, process and analyze it. With error prone high throughput NGS reads and genomic repeats, the assembly graph contains massive amount of redundant nodes and branching edges. Most assembly pipelines require this large graph to reside in memory to start their workflows, which is intractable for mammalian genomes. resource efficient genome assemblers combine both the power of advanced computing techniques and innovative data structures to encode the assembly graph efficiently in a computer memory. Results: light assembler is a lightweight assembly algorithm designed to be executed on a desktop machine. It uses a pair of cache oblivious Bloom filters, one holding a uniform sample of g spaced sequenced km ers and the other holding km ers classified as likely correct, using a simple statistical test. light assembler contains a light implementation of the graph traversal and simplification modules that achieves comparable assembly accuracy and contiguity to other competing tools. Our method reduces the memory usage by 50% compared to the resource efficient assemblers using benchmark datasets from GAGE and assemb lath on projects. While light assembler can be considered as a gap based sequence assembler, different gap sizes result in an almost constant assembly size and genome coverage.

introduction the advent of next generation sequencing (NGS) technologies has revolutionized the genomic research, but has not been able to provide a complete picture of a sequenced organism, since the relative positions of the billions of fragmented pieces are unknown without a genome assembly, which is a highly ambiguous overlapping puzzle (). De novo sequence assembly is an initial step towards downstream data analysis such as understanding evolutionary diversity across different species, evidenced by the multitude of data collection projects, including Genome 10K (). With the increasing efforts to sequence and assemble the genomes of more organisms, the assembly problem becomes more complicated and computationally intensive, especially with short inaccurate sequenced reads and genomic repeats (). next generation assembly algorithms play around two basic frameworks for efficiently completing their task: namely, De Bruijn and string graphs. In a De Bruijn graph, nodes are the set of distinct km ers (substrings of length k) extracted from reads and the edges are the k  1  -overlap among them. The string graph is a simplified version of a classical overlap graph, where nodes are the sequenced reads and the non transitive edges encode their suffix to prefix overlaps (). Many efforts have been made to fit the assembly graph into computer memory by the creation of resource efficient genome assemblers. The term resource efficiency touches on both memory space and speed (). One compressed representation for a string graph is introduced in SGA () using fm index and burrows wheeler transformation of the sequenced reads (). Recently, an incremental hashing technique combined with a probabilistic data structure (Bloom filter) revisited the string graph representation (Ben). The early condensed representation of De Bruijn graph is a sparse bit vector (), later implemented in a Gossamer sequence assembler (). This representation is changed in mini a () by introducing the exact representation of De Bruijn graph using the combination of a Bloom filter and a hash table that holds an approximate set of false positive nodes. The hash table is replaced in subsequent versions of mini a by a set of cascading Bloom filters for further space optimization (). The burrows wheeler transformation plays another role in the succinct representation of De Bruijn graph () by combining fm index with frequency based minimizers to reduce its complexity (). sparse assembler () stores a subsample of km ers in a hash table with their overlap links, recorded to maintain De Bruijn graph representation. ABySS () distributes the assembly graph nodes among different machines to reduce the representation complexity in a computer memory. resource efficient sequence assemblers vary in their assembly results in terms of both accuracy and contiguity measures. Each tool has a set of advantages and disadvantages according to the compromises made to achieve efficiency. Also, different evaluation studies () generally reported that the assembly algorithms differ in their outputs according to their working scenarios such as the quality of sequenced data and the complexity of the corresponding genome. There is a common conclusion that there is no one tool is best for all scenarios, and that there is still room for improvement in current assembly pipelines. In this paper, we revisit De Bruijn graph representation and introduce an optimized cache oblivious Bloom filter to the sequence assembly. Our method is inspired by Lighter's idea () to correct the sequenced errors using a pair of Bloom filters and a simple statistical test. Lighter stores a random sample of km ers in a Bloom filter and uses them with a simple statistical test as seeds to classify the read positions as trusted or untrusted. While Lighter's goal is to use the trust classified km ers to correct erroneous ones, our ultimate goal is assembling these km ers without error correction since they are already classified as trusted nodes km ers made by k consecutive trust classified positions in the sequenced reads are considered to be trusted). light assembler obtains a uniform sample of km ers by skipping g bases between the km ers where g is the gap length and stores them in a Bloom filter. The erroneous bases in a read will produce rare km ers and are unlikely to survive in the sample compared to the abundant km ers generated by the correct bases. The trust in ess of a read position will be determined by comparing the number of km ers that cover the position and appear in the sample to a statistically computed threshold. light assembler uses the km ers made by k consecutive trust classified reads positions as the set of assembly graph traversal nodes, while several assemblers rely on error correction modules to identify and correct the erroneous km ers before starting the assembly process. The majority of error correction algorithms count the km ers to determine their confidence and exclude ones with a multiplicity less than a specified threshold, which might result in missing a subset of true km ers with low abundance. Other assemblers such as Velvet () rely on intensive graph simplification modules to resolve the erroneous structures introduced by erroneous bases such as tips and bubbles. Complex assembly pipelines combine both approaches and perform postprocessing graph filtering using mate pairs during scaffolding stage. light assembler uses only two passes over the sequenced reads to identify the approximate set of trusted nodes without error correction or intensive graph simplification modules. Also, one of the efficient representations of De Bruijn graph based on a Bloom filter is implemented in mini a and uses km er counting module to identify the set of trusted km ers. mini as counting algorithm follows a divide and conquer paradigm and utilizes the disk space as secondary memory storage. Our method is able to identify the set of trusted km ers without utilizing either a counting module or disk space overhead. We will present our comparable results to the current state of the art sequence assemblers as well as resource efficient ones using the simulated and benchmarked datasets.
