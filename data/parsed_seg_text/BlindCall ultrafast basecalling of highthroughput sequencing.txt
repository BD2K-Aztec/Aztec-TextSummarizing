Motivation: base calling of sequencing data produced by high throughput sequencing platforms is a fundamental process in current bioinformatics analysis. However, existing third party probabilistic or machine learning methods that significantly improve the accuracy of base calls on these platforms are impractical for production use due to their computational inefficiency. Results: We directly formulate base calling as a blind deconvolution problem and implemented blind call as an efficient solver to this inverse problem. blind call produced base calls at accuracy comparable to state of the art probabilistic methods while processing data at rates 10 times faster in most cases. The computational complexity of blind call scales linearly with read length making it better suited for new long read sequencing technologies. Availability and Implementation: blind call is implemented as a set of Matlab scripts available for download at

introduction second generation sequencing technology has revolutionized high throughput genomics in life science and clinical research. The sheer scale of sequence generated by these instruments has allowed unprecedented views into a number of molecular phenomena, including population genetics, transcript omics epigenetics and translational profiling. Both the throughput and accuracy of second generation sequencing instruments has increased at an accelerated pace in the last few years due to the use of high resolution optics and biochemical methods that allow sequencing of billions of DNA fragments in parallel by generating fluorescence intensity signals that can be decoded into DNA sequences. However due to experimental and hardware limitations, these raw signals are inherently noisy (). base calling is the essential step of converting these noisy fluorescent intensity signals into sequences used in downstream analysis. Providing accurate base calls greatly reduces many difficulties in downstream bioinformatics analysis like genome assembly and variant calling (). sequencing by synthesis () generates millions of reads of short DNA sequences by measuring in parallel the fluorescence intensity of billions of pcr amplified and labeled clusters of DNA from a sample of interest. The DNA fragments attach to a glass surface where it is then pcr amplified in situ to create a cluster of DNA fragments with identical nucleotide composition. Sequence reads are generated from these DNA clusters in parallel and by cycles. A single nucleotide is sequenced from all DNA clusters in parallel by adding labeled nucleotides that incorporate to their complementary nucleotide. This synthesizes DNA fragments complementary to the fragments in each cluster as sequencing progresses. A set of four images is created measuring the fluorescence intensity along four channels to detect incorporation at each cycle. These images are then processed to produce fluorescence intensity measurements from which sequences are then inferred by base calling. In the default base calling process for Illumina sequencers, called Bustard, the highest intensity in each quadruple t of intensity measurements determines the base at the corresponding position of the corresponding read. For current Illumina technologies, sequencers can produce up to 600 GB per run (). The raw intensity signals generated by this process are known to be subject to several biases () (and B). (i) Cross talk: there are significant correlations between different nucleotide channels; (ii) phasing pre phasing the signal in one cycle can spread to the cycles ahead and the cycles after it; (iii) signal decay: where signal intensities become lower in later sequencing cycles; (iv) background noise: the signal to noise ratio becomes lower in later sequencing cycles. A significant challenge in base calling is accounting for these biases. Existing base calling methods can be classified into two major groups: (i) unsupervised model based methods that capture the sequencing by synthesis process in a statistical model of fluorescence intensity from which base call probabilities can be extracted directly () and ii supervised methods that train a statistical model on a set of base calls whereby fluorescence intensity measurements are classified into base calls (). The former methods have been shown to significantly improve the accuracy of Bustard base calls. These model based methods aim to capture the sequencing process described above in a statistical model from which base call probabilities are usually obtained. While these probabilistic or machine learning methods improve *To whom correspondence should be addressed.  The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution License (http://creativecommons.org/licenses/by/3.0/), which permits unrestricted reuse, distribution, and reproduction in any medium, provided the original work is properly cited. the accuracy of base calls they are impractical for use due to their computational inefficiency, which usually scales quadratically with read length since most of them resort to dynamic programming for model fitting (). In this article, we show that the base calling problem can be formulated as an optimization problem called blind deconvolution. Based on this observation, we developed blind call as a method that treats base calling as a blind deconvolution problem (). We model intensity signals (B) output by the sequencer as the convolution of a latent sparse signal of interest X and a convolution kernel k modeling crosstalk and phasing biases, plus background noise N: B  k  X  n the blind deconvolution problem is to recover the latent signal X given only the observed B. This reduces the base calling problem into solving an inverse problem that admits computationally efficient solutions. The blind deconvolution problem has been a research hotspot in recent years () and we adapt methods for its solution to the base calling problem (). blind call was able to provide base calls at comparable accuracy to state of the art probabilistic methods while processing data at rates ten times or faster in most cases. It scales linearly with read length and is thus better suited for new long read sequencing technologies. Direct blind deconvolution modeling and the ultra efficient processing based on optimization methods presented here are essential for bioinformatics analysis workflows to cope with increased throughput and read lengths in new sequencing technologies.

conclusion blind call is a simple and ultra-fast non probabilistic base calling method for Illumina high throughput sequencing data based on blind deconvolution. We have shown that it provides comparable accuracy for Bustard, AYB and blind call on various datasets. blind call was able to produce comparable accuracy to state of the art base callers at significantly faster computational time. All methods improve on Bustard base calls. Run times for blind call are reported as (training time processing time total time in minutes) where the total time includes reading intensity data from disk and writing base calls to disk.. base calling by blind deconvolution is scalable to long read lengths. We compare the computational time of blind call with a state of the art probabilistic base caller AYB, the state of the art supervised learning method free ibis and illumina s Bustard on the PhiX174 dataset reported in as a function of the number of sequencing cycles. Since most model based base callers resort to a dynamic programming solution, running time is quadratic with respect to the read length. In contrast, blind call scales linearly with read length. Base callers based on the blind deconvolution framework will be able to scale as sequencers produce longer reads. free ibis also scales linearly but is much slower than blind call. third party base callers improve Bustard per cycle error rate. We plot error rate of each base caller per sequencing cycle on the PhiX174 test data. All three base callers significantly improve accuracy over Bustard, especially in later cycles. blind call is able to achieve comparable accuracy while processing data at a much faster rate
