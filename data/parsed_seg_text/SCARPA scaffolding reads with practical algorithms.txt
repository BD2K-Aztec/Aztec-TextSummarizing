Motivation: Scaffolding is the process of ordering and orienting con-tigs produced during genome assembly. Accurate scaffolding is essential for finishing draft assemblies, as it facilitates the costly and laborious procedures needed to fill in the gaps between contigs. Conventional formulations of the scaffolding problem are intractable, and most scaffolding programs rely on heuristic or approximate solutions , with potentially exponential running time. Results: We present SCARPA, a novel scaffold er which combines fixed parameter tractable and bounded algorithms with Linear Programming to produce near optimal scaffolds. We test SCARPA on real datasets in addition to a simulated diploid genome and compare its performance with several state of the art scaffold ers. We show that SCARPA produces longer or similar length scaffolds that are highly accurate compared with other scaffold ers. SCARPA is also capable of detecting mis assembled contigs and reports them during scaffolding. Availability: SCARPA is open source and available from http://comp

introduction while assemblers developed for high throughput sequencing (HTS) platforms can produce high quality draft assemblies for the genomes of bacteria and viruses, de novo assemblies of more complex genomes using short reads are typically fragmented. This fragmentation can be partially alleviated through scaffolding: the process of linking contigs into longer sequences (possibly with gaps) using paired read information. Scaffolding not only improves the contiguity of the initial assembly, but is also helpful for designing experiments for finishing of the genome through additional sequencing of selected regions with lower throughput technology, such as Sanger. Although many genome assemblers produce scaffolds using paired reads during the assembly process (), the problems of building contigs and scaffolding them are distinct. A scaffold er takes as input a set of assembled contigs and a set of paired reads. The relative orientation of two paired reads and the approximate distance between them are known. Thus, if the two reads can be unambiguously mapped to different contigs, we can identify the relative ordering and the distance between these contigs. Owing to errors in the read pair data (e.g. chimeric pairs) and in the assembly (e.g. mis assembled contigs), the ordering achieved from different read pairs can be contradictory. Consequently, the scaffolding problem is often defined as finding an ordering on the contigs that maximizes the number of supporting read pairs. Computationally, this formulation is np hard (), leading most scaffolding approaches to use heuristic algorithms with no provable guarantees. Some scaffold ers greedily link contigs by considering them in order of strongest paired read support () or largest contig length (), while rejecting links that contradict those already chosen. Alternatively, the scaffolding problem is often represented as a graph, where nodes denote contigs and edges denote paired read links. SOPRA () partitions this graph into smaller parts and solves the scaffolding problem in each subgraph using statistical optimization. MIP scaffold er () partitions the graph in a similar way; however, it solves the problem for each subgraph exactly using Mixed Integer Programming. To keep the algorithms tractable, both of these scaffold ers limit the sizes of the subgraphs. Opera () applies an alternate partitioning scheme using a graph contraction procedure and solves the scaffolding problem with a fixed parameter tractable algorithm based on a graph bandwidth formulation. These approaches to scaffolding attempt to maximize the number of paired reads that are satisfied, implicitly assuming that paired read links are noisy and the contigs are error free. However, in larger and more complex genomes, the assembled contigs may well have mis assemblies. In this article, we present a novel method that combines several practical algorithms for the scaffolding problem. Our approach assumes that both erroneous read pairs and contigs are possible, allowing us to detect mis assembled contigs and remove these from the scaffolds. This formulation of the problem allows for an algorithm with practical time and memory requirements, while providing an exact solution of bounded error. This algorithm is implemented within SCARPA, a stand-alone scaffold er for HTS data. We have tested SCARPA on real datasets as well as on a simulated diploid genome, and show that it builds highly accurate and longer scaffolds compared with several state of the art scaffold ers
conclusion scaffolding improves the contiguity of an assembly and facilitates the finishing of a genome by establishing an order and orientation of contigs. In this article, we have presented SCARPA, a novel scaffold er for HTS data that combines graph algorithms with LP. Using simulated and real datasets, we show that SCARPA produces as long or longer scaffolds than the current state of the art tools, while at the same time achieving high accuracy note For gcl a viger a the size of the available draft sequence is given in place of the genome size. For the Assemblathon1 dataset, the genome size is given as an average of the haploid reference sequences. A novel feature of SCARPA is the ability to detect mis assembled contigs. Although this procedure may produce false positives, SCARPA reports only a few such contigs per dataset, which can be manually investigated if necessary. For instance, SCARPA discards no contigs in the gcl a viger a and Assemblathon1 datasets and only three contigs in the E.coli dataset, two of which are indeed found to be erroneous we also show that SCARPA has favorable running time on these datasets, although it is slightly slower than s space. In addition, SCARPA has a small memory footprint, requiring 52 GB on the Assemblathon1 dataset. Within SCARPA, the most time consuming step is the contig orientation task. While we believe our method typically produces more accurate scaffolds compared with greedy or heuristic based approach and has the advantage of detecting mis assemblies it can be computationally expensive for large and complex genomes. On the other hand, the fixed parameter tractable algorithm we use is suitable for parallel computation. Although our current implementation is single threaded we plan to explore this direction in a future version note Mapping is performed using Bowtie with 16 threads, and mapping time is included for all scaffold ers. For information, the total wall clock time taken by Bowtie to index the reference and write read mappings in SAM format is also reported.
