Motivation: The throughput of genomic sequencing has increased to the point that is overrunning the rate of downstream analysis. This, along with the desire to revisit old data, has led to a situation where large quantities of raw, and nearly impenetrable, sequence data are rapidly filling the hard drives of modern biology labs. These datasets can be compressed via a multi string variant of the burrows wheeler Transform (BWT), which provides the side benefit of searches for arbitrary km ers within the raw data as well as the ability to reconstitute arbitrary reads as needed. We propose a method for merging such datasets for both increased compression and downstream analysis. Results: We present a novel algorithm that merges multi string b wts in o lcs Â NÞ time where LCS is the length of their longest common substring between any of the inputs, and N is the total length of all inputs combined (number of symbols) using OðN Â log 2 ðFÞÞ bits where F is the number of multi string b wts merged. This merged multi string BWT is also shown to have a higher compressibility compared with the input multi string b wts separately. Additionally, we explore some uses of a merged multi string BWT for bioinformatics applications. Availability and implementation: The ms bwt package is available through PyPI with source code located at https://code.google.com

introduction the throughput of next generation sequencing (NGS) technologies has increased at such a rate that it is now on the cusp of outpacing downstream computational and analysis pipelines (). The result is a bottleneck where huge datasets are held on secondary storage (disk) while awaiting processing. Raw sequence (e.g. fast q files, composed of sequence and quality strings, are the most common intermediate piling up at this bottleneck. Moreover, the rapid development of new analysis tools has led to a culture of archiving raw sequence files for reanalysis in the future. This hoarding tradition reflects an entrenched notion that the costs of data generation far exceed the costs of analysis. The storage overhead of this bottleneck can be somewhat alleviated through the use of compression. However, decompression generally requires additional computational stages to decompress datasets before their use, which further impacts the throughput of subsequent analyses. This, in turn, has led to the need for algorithms that can operate directly on compressed data (). Others have previously proposed representing raw sequencing data in a form that is more compressible and indexed in a way that is suitable for direct queries by downstream tools (). Our primary contribution is a method for merging these indexable representations of NGS raw sequence data to increase compressibility and search through all merged datasets with one query. The entire collection of reads can be efficiently searched for specific km ers and the associated reads recovered. We leverage a burrows wheeler Transform (BWT) variant that has been adapted to string collections by for representing raw sequence data. Originally, the BWT was introduced as an algorithm for permuting a string to improve its compressibility (). The BWT of a string is closely related to a suffix array for the same string. In fact, it is merely the concatenation of the symbols preceding each suffix after those suffixes have been sorted. A special 'end of string' symbol (commonly '$') is used as the predecessor of the string's first symbol. The BWT increases string compressibility because it tends to group similar substrings together, which creates long runs of identical predecessor symbols. The BWT was exploited by who proposed an fm index data structure that allows for searches of the b wts implicit suffix array to be performed. Additionally, these searches were shown to run in O(k) time where k is the query length, meaning that the b wts length does not affect the query time. Moreover, they showed that the fm index can be constructed on the fly in a single pass over a string's BWT. The combination of the BWT and the fm index allows large strings to be compressed into a smaller searchable form. A basic example of the BWT and the associated fm index is shown in. In bioinformatics, the BWT has proven to be a useful tool for aligning short reads. The fundamental problem of short read alignment is to take small strings and place them along a larger string such that the edit distance between corresponding letters is minimized. The BWT is most often used to represent a reference genome so that it can be searched for smaller substrings. Two prominent aligners, BWA () and Bowtie (), take advantage of the BWT for alignment. As sequencing and alignment rises in prominence, storing billions of reads on disk has become a common problem. Recently, several researchers have worked to apply the compression of the BWT to these large short read sets. The BWT can be trivially constructed with multiple strings by simply concatenating them with a distinguishing breaking symbol as was done by. multi string b wts constructed this way generate suffixes that combine adjacent strings to whom correspondence should be addressed proposed a different multi string BWT structure where component strings were both lexicographically ordered and would cycle on themselves, rather than transition to an adjacent string, when repeated fm index searches were applied. Both versions allow reads to be compressed and indexed to perform searches. the version was modified further by to increase the compression by modifying the order of the component strings. Both multi string BWT construction methods require a preprocessing of the entire uncompressed string collection before assembling the BWT. In, the string dataset must first be sorted. On large datasets, this might require an out of core or external sorting algorithm. the approach uses heuristics to choose a string ordering that maximizes the compression benefits of the BWT; this also requires an examination of the entire corpus. In this article, we address the problem of merging two or more multi string b wts such that the result is a multi string BWT containing the combined strings from each constituent multi string BWT. Additionally, we require the strings in the resulting BWT to be annotated such that the origin of each string (in terms of which input it came from) can be identified later. The reasons for merging include adding new information to an existing dataset (more data from a sequencer), combining different datasets for comparative analysis and improving the compression. Others have addressed problems related to merging b wts and three of these are of particular interest. The first is a BWT construction algorithm, which incrementally constructs a BWT in blocks and then merges those blocks together (). The algorithm creates partial b wts in memory. These partial b wts are not true independent b wts because they reference suffixes that are not included in the partial BWT (they either were processed previously or will be processed later). The partial b wts are then merged into a final BWT on disk by comparing the suffixes either implicitly or explicitly depending on the location of the suffixes. Their algorithm is primarily applicable to constructing a BWT of long strings. However, it could be adapted by inserting one string at a time almost as if the string set were one long string. The memory overhead of the modified algorithm would require reconstituting the string collections for all but one of the inputs (the one used as the starting point), and then iteratively going through each string one at a time until the merged result was constructed. The second algorithm, proposed by), is also a BWT construct algorithm that creates a multi string BWT by incrementally inserting a symbol from each string column wise until all symbols are added to the multi string BWT. Given a finished BWT, they also describe how to add new strings to the BWT using this algorithm. This algorithm could be adapted to solve the proposed BWT merging problem by keeping one input in the BWT format and decoding all of the other inputs into their original string collections. Then, their construction algorithm would merge each collection into the BWT. As with the first algorithm, the main issue with this approach is storage overhead of decoding each BWT into its original string collection. The third algorithm is a suffix array merge algorithm proposed by Sir en (2009), which computes the combined suffix array for two inputs. These suffix arrays are actually represented as two multi string b wts. The algorithm searches for the strings of one collection in the other BWT to determine a proper interleaving of the first suffix array into the second. Once the interleaving is calculated, the merged BWT is trivially assembled. The algorithm requires an additional auxiliary index (such as the fm index to support searching. The memory overhead of an un sampled fm index is O(n), where n is length of the BWT. Sampling of the fm index impacts search performance. Moreover, this algorithm is ill suited to multiple datasets (more than two) to merge. In this case, the algorithm performs multiple merges until only one dataset remains. Our algorithm merges two or more multi string b wts directly without any search index or the need to reconstitute any string or suffix of the input b wts. The only auxiliary data structures required are two interleave arrays, which identify the input source of each symbol in the final result, so the only auxiliary data structures used by the algorithm are stored as part of the result. The merging is accomplished by permuting the interleaves of the input b wts which we prove is equivalent to a radix sort over the suffixes of the string collections.

discussion one motivation for merging b wts is to improve on the compression achieved by separate b wts. Depending on the types of data being merged, the merged BWT and its associated interleave are also useful for asking certain biological questions. The most basic benefit is performing a single query in place of multiple queries to separate datasets. For example, the comparison algorithm proposed by, performs two queries to separate b wts to find splice junctions. In their method, one dataset contained DNA and the other contained RNA for the same sample. As the sequences in each dataset are naturally similar, the combined version should compress well. Furthermore, as separate files, the algorithm needs OF  k time to search F b wts for a given km er which is reduced to O(k) when a merged BWT is used instead. In this regard, the merging provides a speed up in downstream analyses in addition to the compression. b wts in general can also be applied to de novo sequence assembly. In fact, some existing assemblers use the BWT as the underlying data structure (). Several de novo assembly techniques currently use the De Bruijn graph as the underlying data structure (). b wts can be used as efficient and compact De Bruijn graph representations with enhanced functionality. The presence, count and sample origin of individual km ers are determined using the b wts fm index. The km er size can be varied without any modifications to the BWT, and the surrounding context (i.e. the containing read fragment) of each km er is accessible. A De Bruijn graph constructed from a merged BWT for a species would include separate paths for haplotypes, thus representing a pan genome of the merged population (). Merged multi string datasets constructed from biological replicates can be used to increase statistical power in de novo assembly and other analyses as well. Such datasets can also be used to examine the consistency between replicates as well as the variants between diverse samples without the overhead of aligning discuss the advantages of using replicates to help reduce errors and biases in experiments. With the eight way merge of biological replicates from, the merged BWT and the corresponding interleave can be used to calculate the abundance and variance of a given km er for all replicates simultaneously also mention how using replicates from different platforms can be useful to reduce bias. In addition to this benefit, we think that combining different datasets in de novo assembly is useful for extending contigs. For example, a BWT consisting of short reads (such as Illumina) could be merged with long reads (such as pac bio to produce a merged BWT with the ability to query both datasets. Alignment is another common use for reads. Given a reference genome, a BWT can be used to search for evidence of the genome in the reads. In this situation, the counts from the query would be similar to pile up heights from an alignment. Regions with lower than expected counts can be reexamined by selecting reads from nearby regions and generating a consensus, and thereby detecting variants including SNPs and indels, as if we were aligning the genome to the reads instead of the reads to the genome. Additionally, there is potential for algorithms that merge b wts from raw sequencing files with a BWT of the reference genome. Ideally, this would lead to a merged BWT where strings from the genome are located near similar notes Experiments are grouped into blocks. Each experiment compares the merged results (in bold) to the totals for separate files. Note that in all experiments there is a decrease in the number of RL entries and increase in average RL when moving from individual files to a single merged file indicating that the merged version is more compressible than separate files.. Plot showing the distribution of RLs for eight separate FF sample files (higher first, then lower) and a merged file containing all eight samples (lower first, then higher). Note that for the merged file, there are more runs of longer length and fewer runs of shorter length. This is because the merged BWT has brought the similar components of each BWT together leading to longer runs strings from the sequenced read fragments, making interleave the basis for alignment. In some situations, researchers are only interested in a specific local effect instead of global analysis. A classic example is designing primers for targeted sequencing. Both BLAST () and BLAT () search for km ers within a database of strings allowing for small errors. Similar algorithms could be executed using the merged multi dataset BWT as the database of strings. This would allow for queries for km er evidence among all of the datasets in a merged BWT simultaneously. Thus, replacing raw sequencing files (i.e. fast a with b wts has several advantages beyond improving compression. The indexing capabilities of the BWT increase the inherent utility of the data by allowing it to be searched and quantified. Furthermore, the interleave vector generated by merging b wts enables finding both sequence similarities and differences between datasets without needing to align. Finally, as the b wts are purely data driven, they are unaffected by new genome builds.
