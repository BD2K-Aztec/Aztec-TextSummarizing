Motivation: In genome assembly, as coverage of sequencing and genome size growing, most current softwares require a large memory for handling a great deal of sequence data. However, most researchers usually can not meet the requirements of computing resources which prevent most current softwares from practical applications. Results: In this article, we present an update algorithm called EPGA2, which applies some new modules and can bring about improved assembly results in small memory. For reducing peak memory in genome assembly, EPGA2 adopts memory efficient DSK to count km ers and revised b calm to construct De Bruijn Graph. Moreover, EPGA2 parallels the step of Contigs Merging and adds Errors Correction in its pipeline. Our experiments demonstrate that all these changes in EPGA2 are more useful for genome assembly.

introduction genome assembly is one of the most important tasks in numerous applied fields (). When using one software to reconstruct complete genome sequence from sequence data, researchers not only emphasize assembly results but also memory efficiency. Although many softwares have been developed for genome assembly, their balance between accuracy and memory efficiency are not satisfactory due to complex data structures. We previously published epg a (), one de novo assembler which can resolve some problems caused by complex repetitive sequence regions. Although epg a can get satisfactory assembly results, it does not have advantage about peak memory comparing with other popular assemblers. The bottleneck of ep gas memory efficiency primarily exists in two steps: km ers Counting and De Bruijn Graph Constructing, because epg a requires that all reads and km ers reside in memory. Such storage strategy ends up with the memory consumption growing dramatically as the number of reads is increasing. DSK () is one km er counting tool which partitions reads, and each partition is separately loaded in memory. b calm () is one algorithm for building simple paths in De Bruijn Graph which clusters km ers and iteratively loads each cluster in memory. For resolving memory problem in epg a we present EPGA2, which replaces some components in epg a with DSK and b calm. In addition, EPGA2 adds Errors Correction in its pipeline and parallels the step of Contigs Merging. The experimental results demonstrate that EPGA2 can produce more satisfactory contigs and scaffolds using small memory.

conclusion in this article, to resolve the memory efficiency problem in epg a we present EPGA2, which updates some modules in epg a. In addition, for reducing running time, EPGA2 parallels Contigs Merging. For improving accuracy of assembly results, EPGA2 adds Errors Correction using BLESS. The experimental results demonstrate the balance between assembly results and memory efficiency of EPGA2 is satisfactory. EPGA2 should be particularly appropriate for researchers with limited computing resources cnum the number of contigs; C.CN50, the CN50 of contigs; c cov the coverage of contigs; S.Num, the number of scaffolds; S.CN50, the CN50 of scaffolds; s cov the coverage of scaffolds; time, running time; PM, peak memory. Last column is the smallest peak memory and corresponding assembler about other popular assemblers.
