rnase q has become a potent and widely used method to qualitatively and quantitatively study transcriptome s. To draw biological conclusions based on rnase q data, several steps, some of which are computationally intensive, have to be taken. Our read emption pipeline takes care of these individual tasks and integrates them into an easy to use tool with a command line interface. To leverage the full power of modern computers, most subcommands of read emption offer parallel data processing. While read emption was mainly developed for the analysis of bacterial primary transcriptome s we have successfully applied it to analyze rnase q reads from other sample types, including whole transcriptome s and RNA immunopre-cipitated with proteins, not only from bacteria but also from eukaryotes and archaea. Availability and implementation: read emption is implemented in Python and is published under the is c open source license. The tool and documentation is hosted at http://pythonhosted.org/ read emption (

introduction rnase q the examination of cDNA by massively parallel sequencing technologies, is a potent way to perform transcriptome analyses at single nucleotide resolution and with a high dynamic range (). It has been successfully used to annotate transcript boundaries and to identify novel transcripts such as small regulatory RNAs in both prokaryotes and eukaryotes (). Most prominently, it can be applied to quantify the expression levels of genes, having been shown to be more powerful to detect changes in gene expression than microarrays (). It can also be used to study the interaction of proteins and RNAs through performing rnase q of co immuno precip ation (coIP) samples (K  on ig et al., 2012). Likewise, any other subset of RNA molecules from, for instance, RNA size fractionation ribosome profiling, meta transcript omics or deg radome profiling experiments can be sequenced. Owing to decreasing costs and ever increasing speed of deep sequencing, the bioinformatic al analysis has become a bottleneck of rnase q based projects. We have created an automated rnase q processing pipeline named read emption with the initial purpose to handle differential rnase q d rnase q data for the determination of transcriptional start sites in bacteria (). We saw the need for this, as other available rnase q analysis pipelines (e.g.) were not designed for this application. Additionally, while most available rnase q pipelines put priority on fast mapping, we have chosen seg e mehl as short read aligner (). This mapper has a relatively high demand of memory and computation capacities but, in return, it offers high sensitivity as well as a low false discovery rate and can perform multiple splitting of reads (). We have since extended the functionality of this python based pipeline, so that it is now capable of analyzing rnase q reads from a wide range of experiments. We have successfully applied read emption for the analyses of RNA samples from bacterial, archaeal and eukaryotic species as well as for RNA virus genomes (e.g.). It is able to work with reads from both Illumina and 454 platforms of different lengths and can be used for single and paired end sequenced libraries. several parameters, which enable the user to adapt its execution to the specific needs. read emption provides the subcommands align, coverage, gene quanti de seq viz align viz gene quanti and viz de seq which combine several processing substeps into comprehensible units. Read processing and mapping: The fundamental tasks of preprocessing the input reads and aligning them to reference sequences is covered by the subcommand align. In an initial step, read emption parses the input read files in fast a or fast q format, performs quality trimming, removes adapters and or polya tails introduced during the library preparation and discards reads shorter than a given cut off (default 12 nt). For the alignment of reads to reference sequences, the short read mapper seg e mehl and its re mapper lack () are used. To have high confidence of read mappings even for short sequences, the required mapping accuracy of 95% is used per default. The mapping is followed by the conversion of the resulting Sequence alignment map format (SAM) alignment files into Binary alignment map format (BAM) files and the generation of mapping statistics. The latter summarizes the numbers of uniquely and multiple mapped reads as well as the number of alignments, clipping and filtering events for each genomic element in table format. Coverage calculation: Based on the read alignments provided in the BAM files, cDNA coverage files can be generated using the subcommand coverage. It creates several wiggle files that are based on different normalization methods such as the division by the total number of aligned reads and represents the nucleotide wise cDNA coverage in a strand specific manner. To visually inspect the reads mapped to the individual cDNA libraries and to compare them among each other, these wiggle files can be loaded into common genome browsers. Gene expression quantification: The read alignments can also be further used by the subcommand gene quanti to calculate gene-wise read counts. For this purpose, annotation files including gene positions in GFF3 format (Gene feature format) have to be provided. For each annotation entry, the number of reads that are overlapping with a user defined number of nucleotides (default 1 nt) are reported. To also detect non annotated antisense transcripts, the reads which are mapped in antisense direction to a given annotation can be quantified. Besides raw genewise read counting s normalized values by total number of aligned reads as well as reads per kilobase per exon model per million mapped reads rp km ()are returned. Differential gene expression analysis: For pairwise expression comparison, the subcommand de seq offers statistical analysis based on the approach implemented in DESeq2 (), which builds on the raw read counting and is a widely adapted and intensively tested library (). The user has to specify the conditions of the libraries to let DESeq2 treat replicates accordingly. The results of DESeq2 are re formated and supplemented with the provided gene annotations. Plotting: The final three subcommands called viz align viz gene quanti and viz de seq generate several visualizations that help to interpret the result of the subcommand align, gene quanti and de seq respectively. The diverse plots contain among others histograms of the read length distributions before and after the read clipping, volcano plots and MA plots (log ratios (M) versus arithmetic mean of expression values (A)) of the differential gene expression analysis. read emption requires Python 3.2 or higher (http://python. org), Biopython (), matplotlib () and numpy () as well as the sam tools () wrapper py sam (http://pypi.python.org/pypi/pysam/). The subcommand de seq relies on an R (http://cran.r-project.org) installation and the bioconductor package DESeq2 (). Instructions how to install read emption and how to execute its subcommands including examples can be found in the documentation. Additionally, an Ubuntu live and installation image with read emption preinstalled is available for download.
