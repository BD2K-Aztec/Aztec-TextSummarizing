Bacterial genomes are simpler than mammalian ones, and yet assembling the former from the data currently generated by high throughput short read sequencing machines still results in hundreds of contigs. To improve assembly quality, recent studies have utilized longer Pacific Biosciences pac bio reads or jumping libraries to connect contigs into larger scaffolds or help assemblers resolve ambiguities in repetitive regions of the genome. However, their popularity in contemporary genomic research is still limited by high cost and error rates. In this work, we explore the possibility of improving assemblies by using complete genomes from closely related species strains. We present Ragout, a genome rearrangement approach, to address this problem. In contrast with most reference guided algorithms, where only one reference genome is used, Ragout uses multiple references along with the evolutionary relationship among these references in order to determine the correct order of the contigs. Additionally, Ragout uses the assembly graph and multi-scale synteny blocks to reduce assembly gaps caused by small contigs from the input assembly. In simulations as well as real datasets, we believe that for common bacterial species, where many complete genome sequences from related strains have been available, the current high throughput short read sequencing paradigm is sufficient to obtain a single high quality scaffold for each chromosome.

introduction the recent proliferation of next generation sequencing with short reads has enabled many new experimental opportunities, but it has also raised formidable computational challenges in genome assembly. Even for relatively simple bacterial genomes, their assemblies from current generation of high throughput short reads are still fragmented with hundreds of contigs. To improve the assembly s quality, recent studies have utilized longer Pacific Biosciences pac bio reads or jumping libraries to connect contigs into larger scaffolds or help assemblers resolve ambiguities in repetitive regions of the genome (). However, their popularity in current genomic research is still limited by high cost and error rates. When a related genome is available, an alternative approach is to use this genome to guide the assembly of the target genome, in a method called reference assisted assembly'. The first reference assisted assembly tools aligned contigs against the reference and ordered them according to their positions in the reference genome. While this approach is still commonly used, it introduces errors when structural variations between the reference and the assembled (target) genome are present. In an attempt to address this problem, Gaul and Blanchette () formulated the contig ordering problem, which attempts to order contigs so that the 2 break distance (DCJ distance) () between the resulting scaffold and the reference genome is minimized. This formulation has been further applied in some reference guided assembly tools (). Unfortunately, while the approach is theoretically sound, these tools still generate erroneous scaffolds when there are rearrangements between the target and reference genomes. This poses an important question: is a single reference genome sufficient to obtain a single scaffold (for each chromosome) without errors? recently introduced rac a software, which made an important step toward reliable reconstruction of the target (assembled) genome. In contrast to other tools, which use only one reference, rac a utilizes a reference as well as multiple out groups to guide the assembly. This approach proved to be valuable, since the adjacency information in the out groups can also help infer the adjacencies in the target assembly. Although rac a marked an important advancement in the reference guided assembly problem, it still suffers some limitations. First, rac a uses information from out group genomes, but it heavily relies on a single reference. As with any genome rearrangement tools, rac a decomposes these sequences into synteny blocks. However, rather than constructing synteny blocks by considering all input sequences, rac a constructs synteny blocks based on pairwise sequence alignment against only the reference genome. This approach, in some cases, can not detect synteny blocks () and also raises the question of what to do with assembly sequences (contigs) that do not align against the reference. Second, unlike synteny blocks constructed from complete genomes, synteny blocks constructed in the presence of contigs can be fragmented, since assemblies usually have contigs of various lengths. Constructing synteny blocks from fragmented assemblies raises a problem: on which scale should synteny blocks be constructed? If one constructs large scale synteny blocks, then small and fragmented synteny blocks (within small contigs) are not considered, thus leading to gaps in the assembly. On the other hand, if one constructs small scale synteny blocks, then the rearrangement *To whom correspondence should be addressed.  The Author 2014. Published by Oxford University Press. This is an Open Access article distributed under the terms of the Creative Commons Attribution Non-Commercial License (http://creativecommons.org/licenses/ by-nc/3.0/), which permits non-commercial re-use, distribution, and reproduction in any medium, provided the original work is properly cited. For commercial re-use, please contact journals permission soup com analysis becomes harder, since smaller synteny blocks are more likely to exhibit structural variations and are also more susceptible to be incorrectly identified (i.e. false synteny blocks). This dilemma must be addressed in order to obtain high quality scaffolds. In this work, we present Ragout reference assisted Genome Ordering UTility), a genome rearrangement approach for reference assisted assembly that can produce high quality scaffolds with a small number of mis ordered contigs and high genome coverage. Rather than working with a single reference, Ragout uses multiple complete genomes from closely related species/ strains. In contrast with most existing tools, in which only a fixed scale of synteny blocks is used, our algorithm works iteratively with different scales of synteny blocks and also utilizes the assembly graph to improve scaffolds. We demonstrate that with multiple references, Ragout significantly improves the assembly of the target genome compared to existing tools. Through simulations as well as real datasets, we believe that for common bacterial species, for which many complete genome sequences from related strains have been made available, the current high throughput short read sequencing paradigm is sufficient to assemble into a single high quality scaffold. The Ragout software is freely available at: https://github. com fender glass ragout
discussion in this article, we have presented Ragout, a package for improving assemblies using multiple complete references. We demonstrated that with multiple related genomes available, one can obtain a complete and high quality scaffold for each chromosome using only high throughput short read sequencing. This marks an important improvement in genome assembly of short reads and even raises a question whether long pac bio reads or long jumping libraries are needed for genomic studies of common bacteria where multiple related references have been available. The current version of Ragout uses sibel i a for synteny block reconstruction and therefore limits itself to bacterial genomes. When synteny blocks have been available, Ragout is fast and memory efficient. We plan to make Ragout compatible with other synteny block generation tools that can work with mammalian genomes [e.g. Cactus aligner] and further extend Ragout to work with mammalian datasets. Another limitation of Ragout is that it only uses the assembly graph for recovering repetitive blocks or small contigs that could not be captured in synteny analysis. Therefore, it can make mistakes when rearrangements happened on the target branch. Since de Bruijn graphs can be transformed into breakpoint graphs and vice versa the de Bruijn graphs output from short read assemblers can also be used for rearrangement analysis and we will focus on this issue in further studies.
