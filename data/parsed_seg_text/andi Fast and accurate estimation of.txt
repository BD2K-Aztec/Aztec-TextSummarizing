Motivation: A standard approach to classifying sets of genomes is to calculate their pairwise distances. This is difficult for large samples. We have therefore developed an algorithm for rapidly computing the evolutionary distances between closely related genomes. Results: Our distance measure is based on un gapped local alignments that we anchor through pairs of maximal unique matches of a minimum length. These exact matches can be looked up efficiently using enhanced suffix arrays and our implementation requires approximately only 1 s and 45 MB ramm base analysed. The pairing of matches distinguishes non-homologous from homologous regions leading to accurate distance estimation. We show this by analysing simulated data and genome samples ranging from 29 Escherichia coli shigella genomes to 3085 genomes of Streptococcus pneumoniae. Availability and implementation: We have implemented the computation of anchor distances in the multithreaded UNIX command line program and i for ANchor DIstances. C sources and documentation are posted at

introduction the spread of infectious diseases is nowadays often monitored by sequencing the genomes of the outbreak strains. Since a given pandemic is usually caused by the rapid expansion of a single clone, monitoring by sequencing leads to the accumulation of hundreds to thousands of similar genome sequences. For example studied the spread of the multi-drug resistant Escherichia coli strain ST131, which causes extra intestinal infections in humans. The authors sequenced 99 outbreak strains and reconstructed their phylogeny. This revealed that the outbreak was caused by a single lineage of ST131. On an even larger scale studied pneumococcal carriage in a refugee camp by sequencing 3085 strains of Streptococcus pneumoniae, which causes pneumoniae in humans. Again, phylogeny reconstruction based on these genomes was an early step in the study. Classifying bacteria by clustering their genomes is set to become routine. For this purpose computed a multiple sequence alignment of their E.coli ST131 strains using the program mugsy (). It is based on the MUMmer software (), which makes mugsy one of the fastest multiple genome aligners available: it took only 19 h to align 57 complete E.coli genomes. However, the run time of mugsy becomes unacceptable when applied to the recently collected samples of hundreds or even thousands of bacterial genomes for their study of 3085 pneumococcal isolates mapped the sequencing reads onto a reference genome, thereby approximating a multiple sequence alignment. Such alignment by mapping is widely used, and have shown that its accuracy can be further improved by mapping against multiple reference genomes instead of the customary single reference. Their implementation of this idea, real phy requires 2 min and 250 mbm base analysed. The genome of s pneumoniae is 2.2 Mbase long, so real phy would run 9.4 days on the 3085 s pneumoniae isolates. However, a more prohibitive aspect of real phy might be the RAM requirement of 1.7 TB. Perhaps surprisingly, it is not necessary to compute an explicit alignment for phylogeny reconstruction. This insight has sparked interest in devising alignment free methods for rapidly calculating pairwise distances between genomes hau bold 2014), which can then be clustered using various quick algorithms (). alignment free distance computation is either based on counting words of a certain length or recording match lengths (). When counting words, there is a choice between the traditional approach of counting exact words and a more recent method of looking for words that enclose one mismatch. The latter is implemented in the program co phy log (), which gives better distances than exact word counting while requiring only moderate additional resources ().devised an alignment free estimator of genetic distance based on match lengths. The expected match length is the inverse of the proportion of mismatches. For example, if 1% of positions between two genomes are mismatched, the expected match length is 100. do maze t loo and hau bold (2009) implemented this idea using a generalized suffix tree of all input sequences to look up the match lengths. Their program kr computes the distances between the complete genomes of 29 ecoli shigella strains in just 5.5 min on a single processor. However, this takes 5.3 GB RAM and kr has been criticized for excessive RAM utilization (). Moreover, Yi and Jin (2013) noted that co phy log gave a better phylogeny when applied to the benchmarking sample of 29 ecoli shigella genomes. This has prompted us to devise a replacement for kr. Our new strategy is to look for mismatches that are bracketed by long exact matches, which we call anchors. We show through simulation that the resulting program and i for ANchor DIstances, is accurate, fast and memory efficient. Moreover, we apply and i to three sets of bacterial genomes: the 29 genomes of ecoli shigella Yi and Jin (2013) used for benchmarking co phy log the 109 genomes of E.coli ST131 studied by of which they sequenced 99 strains and the 3085 genomes of s pneumoniae sequenced by. In each case, and i quickly recovers pairwise distances. For the E.coli samples, we compare the new distances to alignment based distances and find they are so similar that they yield almost identical phylogenies.

discussion our new distance measure, d a , approximates local alignments by anchoring them with long, unique matches (). The requirement that the matches are equidistant in the query and the subject () is equivalent to restricting the analysis to un gapped alignments. and i is therefore a cross between the early version of BLAST () and the genome aligner MUMmer (): From early BLAST it inherits the idea of un gapped local alignments, from MUMmer the idea of looking up unique matches by indexing the subject. do maze t loo and hau bold (2009) had previously used the power of indexing algorithms to estimate the number of substitutions from the match length distribution. Their program kr works on the same principle as the average common substring distance (), except that kr implements theory by to transform common substring lengths to mutation rates. Fast as the average common substring methods are, they suffer from two disadvantages: First, local fluctuations in the mutation rate affect the average match length. As a result, the same number of mutations can lead to different distances depending on the degree to which the mutations are clustered have used this property to devise a test for recombination. and i does not have this problem as it counts mutations directly rather than inferring them from match lengths. The second disadvantage of match length based methods is that matches induced by nonhomologous fast and accurate estimation of evolutionary distances regions are hard to distinguish from matches induced by highly divergent regions. Even a moderate divergence of K  0.1 implies an average match length of 10. Compare this to the expected length of a random match in a 1 Mbase sequence, which according to the theory by is 10.4. To overcome this limitation of match length distances, lei meister and Morgenstern (2014) proposed a k mismatch generalization. They show that this outperforms the classical zero mismatch version of their distance. However, it remains unclear how to choose the critical parameter k when applying this method. Instead of a generalized mismatch approach, we bracket mutations with paired anchors. This should give more accurate results than kr, and and i did compute a better tree for 29 E.coli genomes than co phy log which in turn gave a better tree than kr. Hence, and i is substantially more accurate than kr. The accuracy of and i is excellent when applied to simulated sequences with a wide range of substitution rates, K (). However, at K  0.5 the search for suitable anchors fails increasingly often (), which can not be overcome by lowering the minimum anchor length (Supplementary). Hence, our method is effectively limited to K 0:5. To get an intuition for the evolutionary times implied by K  0.5, consider the average synonymous substitution rate in mammals of 3:51  10 9 (). The last common ancestor that can occur in a tree restricted to K 0:5 lived 0:5=3:51=10 9 =2  71  10 6 years ago. This would allow the analysis of great apes, which diverged 15:7  10 6 years ago () and mice (Muridae, 26:9  10 6 years), but not of these two groups together (92:3  10 6 years). Apart from maximizing accuracy, we strove to minimize time and memory usage by implementing three ideas: (i) Streaming of query against subject as first implemented in v match speeds up suffix array construction compared with the suffix array of all input sequences underlying kr; it also uses much less memory. Our second idea was (ii) to construct only as many enhanced suffix arrays as there are genomes in the sample, rather than constructing an enhanced suffix array for each pairwise comparison. This means that for a sample of n genomes and i requires only n suffix array constructions, whereas a program like mugsy requires the computation of On 2  suffix trees. The third idea was (iii) multithreading, which allows access to the multi-processor architecture of modern computers. However, other programmers might have chosen a different combination of time memory consumption. For example, v match uses half as much memory as and i for suffix array construction, but is slower than the lib div suf sort library we used. When clustering hundreds of genomes, efficiency becomes paramount. As shown in, and i uses only 1 sm base and 45 bytes bp when applied to simulated sequences. There is an intimate connection between the efficiency of and i and its limitation to closely related sequences: and i approximates local alignments by concatenating exact matches. Looking up exact matches is fast, but this strategy breaks down for divergent sequences where homologous matches become shorter than random matches. This phenomenon is also the reason why fast genome alignment programs like mauve and mugsy work best when applied to closely related genomes (). The accuracy and efficiency observed with simulated data carried over to the analysis of genomes. Here, we compared and i to co phy log as hau bold (2014) had found this to be the best alignment free distance estimator for long sequences. However, and i gave a more accurate tree when compared to the tree based on the mugsy alignment (). This improvement in accuracy came without a time penalty as co phy log computed its tree 36 times faster than mugsy, while and i was a thousand times faster than the alignment. The superior speed of and i comes from the structure of its algorithm and the multithreading; without multithreading, and i would still be 1.6 times faster than co phy log when applied to the 29 ecoli shigella genomes. The memory consumption of and i is strictly linear in the number of threads, while time is roughly inversely proportional to the number of threads. This gives the A B. Phylogeny of 3085 stains of s pneumoniae (). A: Based on distances computed using co phy log (user the opportunity to trade speed for memory and processors, depending on the hardware available. Aligning the 109 genomes of E.coli ST131 took mugsy 5.6 days and 52.7 GB RAM. Compare this to the 5 h 33 min it took mugsy to align 29 E.coli genomes. In other words, a 3.8 times larger sample took 24.6 times longer to align. In contrast, and i took with 1 min, 21 s only 4.1 times longer, yielding the correct classification of strains into clades AC in. Moreover, the memory requirement of mugsy grew 18-fold, while that of and i grew by only 7% to 7.7 GB. These comments are not meant to imply that the mugsy alignment computed in the original study was superfluous; it was used for a number of analyses apart from phylogeny reconstruction, including the detection of horizontal gene transfer (). However, quick clustering of genomes is useful, if only as a quality control step. For our final application, we chose the set of 3085 genomes of s pneumoniae because here an alignment program like mugsy would run far longer than anyone is willing to wait. The current method for comparing sets of bacterial genomes this size is mapping the reads to a reference genome. There is some debate as to the accuracy of the resulting trees (). and i takes as input assembled contigs, which are generated from the raw reads early on in all genome sequencing projects. Given these contigs, and i analyses them in 7 h and 35 min using 23.8 GB RAM on a 32 processor computer. Such computing resources are available in most genomics labs. The three outlier strains identified by and i are identical to those found by co phy log after a 36.5 days run. This is gratifying and underlines the usefulness of our program.
