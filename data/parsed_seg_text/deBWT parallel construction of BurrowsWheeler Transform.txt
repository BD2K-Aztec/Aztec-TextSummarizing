Motivation: With the development of high throughput sequencing, the number of assembled gen-omes continues to rise. It is critical to well organize and index many assembled genomes to promote future genomics studies. burrows wheeler Transform (BWT) is an important data structure of genome indexing, which has many fundamental applications; however, it is still non-trivial to construct BWT for large collection of genomes, especially for highly similar or repetitive genomes. Moreover, the state of the art approaches can not well support scalable parallel computing owing to their incremental nature, which is a bottleneck to use modern computers to accelerate BWT construction. Results: We propose de Bruijn branch based BWT constructor de bwt a novel parallel BWT construction approach. de bwt innovatively represents and organizes the suffixes of input sequence with a novel data structure, de Bruijn branch encoding. This data structure takes the advantage of de Bruijn graph to facilitate the comparison between the suffixes with long common prefix, which breaks the bottleneck of the BWT construction of repetitive genomic sequences. Meanwhile, de bwt also uses the structure of de Bruijn graph for reducing unnecessary comparisons between suffixes. The benchmarking suggests that, de bwt is efficient and scalable to construct BWT for large dataset by parallel computing. It is well suited to index many genomes, such as a collection of individual human genomes, with multiple core servers or clusters. Availability and implementation: de bwt is implemented in C language, the source code is available at https

introduction with the rapid development and ubiquitous application of high throughput sequencing, many genomes have been sequenced in cutting edge genomics studies. For example, 1000 Genomes () and UK10K () projects have sequenced many thousands of individual human genomes. Moreover, as the cost of sequencing continuously decreases, e.g. the cost of sequencing a human sample has already been lower than 1000 dollars (), the number of genomes may explosively increase in the future. Under this circumstance, it is fundamental to well organize and index the large amount of genomes to facilitate future genomics studies. burrows wheeler Transform (BWT;) is a self indexing data structure having many fundamental applications, such as genome indexing (), sequence alignment (), genome compression (), genome assembly () and sequencing error correction (). However, the BWT construction of genomic sequence(s) is a non-trivial task. Mainly, the core of BWT construction is to determine the lexicographical order of all the suffixes of the input sequence(s). Because there could be many repetitive sequences within a genome (), the cost would be prohibitively high to straightforwardly compare all the suffixes to determine their lexicographical orders. The problem is even more serious for constructing the BWT of many highly similar genomes, such as a large collection of

discussion the well organization and indexing of many genomes will be on wide demand in future genomics studies, with the rapid increase of assembled genomes. As an important genome indexing data structure, BWT may have many applications; however, the construction of BWT for a large collection of genomes, especially highly similar re sequenced genomes (e.g. many human individual genomes), is still a non-trivial task. Moreover, owing to the incremental nature of the state of the art methods, it is hard to construct BWT with scalable parallel computing. This is a bottleneck to fully use the computational resources of modern servers or clusters to handle large amount of data. We propose de bwt a novel parallel BWT construction approach, to break the bottleneck. The main contribution of de bwt is its dbg based representation and organization of suffixes, which facilitates the comparison of suffixes with long common prefixes and avoid unnecessary comparisons. Moreover, owing to its non incremental design, de bwt has good scalability to various computational resources. These properties make de bwt well suited to construct BWT for large collections of highly similar or repetitive genomes with modern servers or clusters. In the experiments, de bwt achieves a substantial improvement on the speed of indexing multiple individual human genomes and contigs. For more diverse genomes, e.g. multiple primate genomes, de bwt also shows faster speed and better parallelization; however, the improvement is smaller, likely owing to that the density of the dBG is lower. That is, there are more km ers and uni paths to handle, but the overall repetitiveness of the input is lower than highly similar genomes. Comparing with state of the art approaches, de bwt has obviously larger memory footprint. There are potential solutions to reduce the memory footprints of the various phases of de bwt. For phase 1, it is feasible to bin the km ers into several subsets and separately sort each of the subsets with limited memory. The. Time consumption of the various steps of de bwt. The bars respectively indicate the elapsed time (in minutes) of the various steps of de bwt for the 10 human genomes dataset (a), the human genome contig dataset (b) and the 8 primate genomes dataset (c). Bars in the same color correspond to a specific number of threads, i.e. blue, red, green and purple bars are respectively for 8, 16, 24 and 32 threads de bwt indicates the elapsed time of de bwt and de bwt (no conversion)' deducts the time of the format conversion of Jellyfish output file for the 'x/y/z' of de bwt in the memory columns, the x, y and z values respectively indicate the memory footprints of Jellyfish, phase 1 of de bwt and phases 2 and phases 3 of de bwt. results of the multiple subsets can be straightforwardly merged into the ordered list of all the km ers with small memory space. For phase 2, it is also possible to reduce the memory footprint by keeping only a proportion of /    values and BWT characters, which can be implemented with the following strategy. Because all the multiple in km ers and their numbers of copies are known before the second phase, it can partition the whole set of multiple in km ers into several subsets. Each of the subsets has a limited number of km er copies. Thus, the second phase can be done with multiple times of scanning on the input sequences, instead of one time. In each time of scanning, only the copies of the multiple in km ers within the corresponding subset are recognized, recorded and output to a specific file with limited RAM space. As all the subsets are independent to each other for the third phase, the files of the subsets can be separately processed to generate various parts of BWT. Further, the BWT parts can be directly merged to accomplish the construction. This strategy is feasible to limited workspace, but at the expense of time owing to the fact that it needs multiple executions of phase 2. For phase 3, it can also keep only a proportion of unsolved of BWT partitions in memory as all such partitions are independent. There are two possible improvements on de bwt which are important future works for us. First, de bwt straightforwardly sorts the projection suffixes by quick-sort. Because the de Bruijn branch encoding can be also seen as a special DNA sequence, it is also possible to use other approaches to further accelerate the projection suffix sorting step. For example, the method proposed by kark kaine n (2007) uses DCS to accelerate the sorting of the binned suffixes of the original input sequence. This method could be also used for sorting the binned projection suffixes without loss of the ability of parallel computing, as it is non incremental. Second, for the current version of de bwt the io intensive steps are still not optimized, which slowed down the speed. We plan to further optimize the io intensive steps to improve the efficiency of de bwt. Meanwhile, as km er counting is still an open problem, and advanced km er counting tools are developing (), we also plan to replace Jellyfish by other more advanced km er counting tools, or remove the file conversion step by directly accessing the default Jellyfish output file, to break the practical bottleneck of the method.
